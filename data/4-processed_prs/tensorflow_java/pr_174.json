{"pr_number": 174, "pr_title": "[Type Refactor] Use Java type system instead of custom one for typing tensors", "pr_createdAt": "2020-12-22T03:16:56Z", "pr_url": "https://github.com/tensorflow/java/pull/174", "timeline": [{"oid": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "url": "https://github.com/tensorflow/java/commit/ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "message": "Leverage the Java type system for typing tensors", "committedDate": "2020-12-22T15:26:30Z", "type": "commit"}, {"oid": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "url": "https://github.com/tensorflow/java/commit/ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "message": "Leverage the Java type system for typing tensors", "committedDate": "2020-12-22T15:26:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMyODk0NA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547328944", "bodyText": "Was the generator overgenerating the imports? This removal doesn't involve any other code change.", "author": "Craigacp", "createdAt": "2020-12-22T15:06:21Z", "path": "tensorflow-core/tensorflow-core-api/src/gen/java/org/tensorflow/op/bitwise/BitwiseOr.java", "diffHunk": "@@ -26,7 +26,6 @@\n import org.tensorflow.op.annotation.Endpoint;\n import org.tensorflow.op.annotation.Operator;\n import org.tensorflow.types.family.TNumber;\n-import org.tensorflow.types.family.TType;", "originalCommit": "2a24e5d4e44738d49996c142099f3d9e08ad0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4MjkzMQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547482931", "bodyText": "I'm also not too sure how this import has been removed but it seems to be a good thing since it was never used...", "author": "karllessard", "createdAt": "2020-12-22T20:04:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMyODk0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwMTAwNA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547501004", "bodyText": "Ok. The removal of this unnecessary TType import is the reason most of the generated files got touched, so it added a lot of noise to the PR.", "author": "Craigacp", "createdAt": "2020-12-22T20:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMyODk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzNDIwOA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547334208", "bodyText": "Looks like this import is unnecessary?", "author": "Craigacp", "createdAt": "2020-12-22T15:15:45Z", "path": "tensorflow-core/tensorflow-core-api/src/gen/java/org/tensorflow/op/collective/BroadcastRecv.java", "diffHunk": "@@ -17,16 +17,17 @@\n \n package org.tensorflow.op.collective;\n \n-import org.tensorflow.DataType;\n import org.tensorflow.Operand;\n import org.tensorflow.Operation;\n import org.tensorflow.OperationBuilder;\n import org.tensorflow.Output;\n import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Operands;\n import org.tensorflow.op.RawOp;\n import org.tensorflow.op.Scope;\n import org.tensorflow.op.annotation.Endpoint;\n import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.proto.framework.DataType;", "originalCommit": "2a24e5d4e44738d49996c142099f3d9e08ad0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4MjQzMg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547482432", "bodyText": "It is, it was incorporated with my last changes and I've found a way to remove it, thanks for catching it. Now the process of collecting the imported classes in the op generator is a bit cumbersome and should be reviewed at some point, I agree. It will be even more necessary when we will (finally) activate lint checks that will report unused imports as an error.", "author": "karllessard", "createdAt": "2020-12-22T20:02:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzNDIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzOTUwNg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547339506", "bodyText": "These seem to be the same as the classes in org.tensorflow.op.data?", "author": "Craigacp", "createdAt": "2020-12-22T15:25:22Z", "path": "tensorflow-core/tensorflow-core-api/src/gen/java/org/tensorflow/op/data/experimental/AssertCardinalityDataset.java", "diffHunk": "@@ -46,16 +47,12 @@\n    * @return a new instance of AssertCardinalityDataset\n    */\n   @Endpoint(describeByClass = true)\n-  public static AssertCardinalityDataset create(Scope scope, Operand<?> inputDataset, Operand<TInt64> cardinality, List<DataType<?>> outputTypes, List<Shape> outputShapes) {\n+  public static AssertCardinalityDataset create(Scope scope, Operand<?> inputDataset, Operand<TInt64> cardinality, List<Class<? extends TType>> outputTypes, List<Shape> outputShapes) {", "originalCommit": "2a24e5d4e44738d49996c142099f3d9e08ad0fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4MzQ3NA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547483474", "bodyText": "I don't see a AssertCardinalityDataset class under org.tensorflow.op.data, is it what you meant?", "author": "karllessard", "createdAt": "2020-12-22T20:05:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzOTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwMTk5MA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547501990", "bodyText": "Ooops, sorry I meant AssertNextDataset. There are a bunch of classes that are in both org.tensorflow.op.data and org.tensorflow.op.data.experimental.", "author": "Craigacp", "createdAt": "2020-12-22T20:51:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzOTUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3Mjk5Nw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548372997", "bodyText": "These are two different kernels in TensorFlow runtime, like other duplicates found in these package as far as I can see. For example, the op under data is using AssertNextDataset while the other under experimental is using ExperimentalAssertNextDataset. So it is correct that they coexist, probably they achieve the same purpose but using different implementations. See here", "author": "karllessard", "createdAt": "2020-12-24T04:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMzOTUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MzIzMA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547353230", "bodyText": "These methods became package private?", "author": "Craigacp", "createdAt": "2020-12-22T15:49:20Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperation.java", "diffHunk": "@@ -83,12 +84,12 @@ public int inputListLength(final String name) {\n   }\n \n   @Override\n-  public TFE_TensorHandle getUnsafeNativeHandle(int outputIndex) {\n+  TFE_TensorHandle getUnsafeNativeHandle(int outputIndex) {\n     return outputHandles[outputIndex];\n   }\n \n   @Override\n-  public Shape shape(int outputIndex) {\n+  Shape shape(int outputIndex) {", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4NDA3Mw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547484073", "bodyText": "It should have been package private from the start, as it extends AbstractOperation and it was never intended to override the visibility of its endpoint. So it's just a mistake I've found and fixed while making my changes.", "author": "karllessard", "createdAt": "2020-12-22T20:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1MzIzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NTI2OQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547355269", "bodyText": "Do we care about classes coming from different class loaders, as they will fail this check?", "author": "Craigacp", "createdAt": "2020-12-22T15:53:14Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Output.java", "diffHunk": "@@ -39,23 +41,30 @@ public int index() {\n \n   /** Returns the DataType of the tensor referred to by this Output. */\n   @SuppressWarnings(\"unchecked\")\n-  public DataType<T> dataType() {\n-    return (DataType<T>)operation.dtype(index);\n+  public DataType dataType() {\n+    return operation.dtype(index);\n+  }\n+\n+  /** Returns the type of the tensor referred to by this Output. */\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public Class<T> type() {\n+    return (Class<T>)TensorTypeRegistry.find(dataType()).typeClass();\n   }\n \n   /**\n    * Returns this Output object with the type {@code Output<U>}. This method is useful when given a\n    * value of type {@code Output<?>}.\n    *\n-   * @param dt any supported tensor data type\n+   * @param type any supported tensor type\n    * @throws IllegalArgumentException if the actual data type of this object does not match the type\n    *     {@code U}.\n    */\n   @SuppressWarnings(\"unchecked\")\n-  public <U extends TType> Output<U> expect(DataType<U> dt) {\n-    if (!dt.equals(this.dataType())) {\n+  public <U extends TType> Output<U> expect(Class<U> type) {\n+    if (type != type()) {", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4NTcyOA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547485728", "bodyText": "You mean that the tensor type classes would be loaded multiple times by different class loaders? According to these guys, unless we do extra-effort to make the classes distinct, the JVM will continue to consider them equal. Do you have some specific use case in mind?", "author": "karllessard", "createdAt": "2020-12-22T20:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwMzMzMw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547503333", "bodyText": "Well if they start off in different URLClassLoader instances pointed at the same jar file then they will be different, and I think that could happen inside an application container. I don't think we should ever be able to mix them, but given JavaCPP plays tricks with how the libraries are loaded it might happen. Either way, I think it's fine if we decide we don't care about them coming from different class loaders, but it might be worth noting that this check will fail (so if we do get an issue about this bug then there is a note next to it in the code).", "author": "Craigacp", "createdAt": "2020-12-22T20:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2NjQ0Mw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547566443", "bodyText": "I don't see what this has to do with JavaCPP. It uses tricks for its own classes to work around issues that happen in containers and OSGi, but it doesn't do anything about user classes. If you're saying that JavaCPP should also take care of cases like this for user classes, then yeah ok, it doesn't do that, but from what I remember, you were against JavaCPP working around limitations of the JDK just because Oracle doesn't approve of those tricks, even though everyone in the industry is using them, right? If you want to blame JavaCPP for something, stop worrying about what everyone does, and please find something else to complain about.", "author": "saudet", "createdAt": "2020-12-23T00:09:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU3MTcyNA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547571724", "bodyText": "It depends if you're doing a findClass in the generated C++ code, as that will pull down something using a class loader but given javacpp loads the same library into the same address space multiple times it's not clear what class loader you'll get back from jni.\nHowever it's not that likely that you're doing that, so it would be difficult to trigger.\nAnd as usual I'm just pointing out that it's library loading behaviour is explicitly against the JNI spec, so what behaviour we get out of the JVM is undefined. It might work on hotspot today, but it's not guaranteed to always work or always have the same behaviour because it's undefined.", "author": "Craigacp", "createdAt": "2020-12-23T00:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NTI2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3MzA0NA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548373044", "bodyText": "Ok so I'll classify this as a non-issue for now", "author": "karllessard", "createdAt": "2020-12-24T04:05:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NTI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NTczOA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547355738", "bodyText": "type.byteSize() isn't a thing anymore as type is a class literal.", "author": "Craigacp", "createdAt": "2020-12-22T15:54:02Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/RawTensor.java", "diffHunk": "@@ -84,33 +86,37 @@ public ByteDataBuffer data() {\n    */\n   @Override\n   public String toString() {\n-    return String.format(\"%s tensor with shape %s\", dtype.toString(), shape);\n+    return String.format(\"%s tensor with shape %s\", typeInfo.dataType(), shape);\n   }\n \n   /**\n    * Allocates a new tensor in native memory of the given type, shape and size.\n    *\n    * <p>The size of the tensor must be at least large enough to contain all scalars for the\n-   * given type and shape, i.e. <code>size >= dtype.byteSize() * shape.size()</code>. More memory\n+   * given type and shape, i.e. <code>size >= type.byteSize() * shape.size()</code>. More memory", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NjUzMw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547356533", "bodyText": "Does it actually throw ClassCastException? The type will be erased at runtime.", "author": "Craigacp", "createdAt": "2020-12-22T15:55:22Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/RawTensor.java", "diffHunk": "@@ -164,7 +171,7 @@ TF_Tensor nativeHandle() {\n    * @throws ClassCastException if {@code T} is not compatible type with {@link #dataType()}\n    */\n   <T extends TType> T asTypedTensor() {\n-    return (T)dtype.map(this);\n+    return (T)typeInfo.mapper().mapDense(this);", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4NjEzOQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547486139", "bodyText": "I assumed it would, maybe I'm wrong, I'll add a test for it.", "author": "karllessard", "createdAt": "2020-12-22T20:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NjUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ5Nzc5OQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547497799", "bodyText": "yes, that works", "author": "karllessard", "createdAt": "2020-12-22T20:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NjUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwMzUwMQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547503501", "bodyText": "Ok, good.", "author": "Craigacp", "createdAt": "2020-12-22T20:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NjUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgwODI1Mg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549808252", "bodyText": "@Craigacp was right: the generic method can't throw ClassCastException, because at runtime the type is erased and no cast can occur. Rather, the test is flawed.\nHere's a version of the test that also passes, but exposes the real behavior:\n  @Test\n  public void rawToTypedTensor() {\n    RawTensor rawTensor = RawTensor.allocate(TFloat32.class, Shape.of(2, 2), -1);\n    TFloat32 floatTensor = rawTensor.asTypedTensor();\n    assertSame(floatTensor.asRawTensor(), rawTensor);\n    Object objTensor = rawTensor.<TInt32>asTypedTensor();\n    try {\n      TInt32 intTensor = (TInt32) objTensor;\n      fail();\n    } catch (ClassCastException e) {\n      // ok\n    }\n  }", "author": "deansher", "createdAt": "2020-12-29T18:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1NjUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM1ODE2OQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547358169", "bodyText": "I'm dubious of the benefits of special casing -1 here, though I suppose it has all the necessary information.", "author": "Craigacp", "createdAt": "2020-12-22T15:58:12Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/RawTensor.java", "diffHunk": "@@ -84,33 +86,37 @@ public ByteDataBuffer data() {\n    */\n   @Override\n   public String toString() {\n-    return String.format(\"%s tensor with shape %s\", dtype.toString(), shape);\n+    return String.format(\"%s tensor with shape %s\", typeInfo.dataType(), shape);\n   }\n \n   /**\n    * Allocates a new tensor in native memory of the given type, shape and size.\n    *\n    * <p>The size of the tensor must be at least large enough to contain all scalars for the\n-   * given type and shape, i.e. <code>size >= dtype.byteSize() * shape.size()</code>. More memory\n+   * given type and shape, i.e. <code>size >= type.byteSize() * shape.size()</code>. More memory\n    * can be allocated to store also metadata within the tensor itself, e.g. a lookup table\n    * in a string tensor.\n    *\n-   * @param dtype data type\n+   * @param type tensor type class\n    * @param shape shape of the tensor\n-   * @param size size of the tensor\n+   * @param size size in bytes of the tensor, or -1 to compute the size from the shape", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2MzkyMA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547363920", "bodyText": "What happens if typeInfo.byteSize() returns -1?", "author": "Craigacp", "createdAt": "2020-12-22T16:08:36Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/RawTensor.java", "diffHunk": "@@ -84,33 +86,37 @@ public ByteDataBuffer data() {\n    */\n   @Override\n   public String toString() {\n-    return String.format(\"%s tensor with shape %s\", dtype.toString(), shape);\n+    return String.format(\"%s tensor with shape %s\", typeInfo.dataType(), shape);\n   }\n \n   /**\n    * Allocates a new tensor in native memory of the given type, shape and size.\n    *\n    * <p>The size of the tensor must be at least large enough to contain all scalars for the\n-   * given type and shape, i.e. <code>size >= dtype.byteSize() * shape.size()</code>. More memory\n+   * given type and shape, i.e. <code>size >= type.byteSize() * shape.size()</code>. More memory\n    * can be allocated to store also metadata within the tensor itself, e.g. a lookup table\n    * in a string tensor.\n    *\n-   * @param dtype data type\n+   * @param type tensor type class\n    * @param shape shape of the tensor\n-   * @param size size of the tensor\n+   * @param size size in bytes of the tensor, or -1 to compute the size from the shape\n    * @return allocated tensor\n    */\n-  static RawTensor allocate(DataType<?> dtype, Shape shape, long size) {\n-    // Minimum requirements for datatypes of variable length cannot be verified in a relevant way so\n-    // we only validate them for fixed length datatypes\n-    if (!dtype.isVariableLength() && shape.size() * dtype.byteSize() > size) {\n+  static RawTensor allocate(Class<? extends TType> type, Shape shape, long size) {\n+    TensorTypeInfo<?> typeInfo = TensorTypeRegistry.find(type);\n+    long effectiveSize = size;\n+    if (effectiveSize < 0) {\n+      effectiveSize = shape.size() * typeInfo.byteSize();", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4NzAwNg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547487006", "bodyText": "Actually this if/else is kind of reversed, I'll shuffle it a bit to make sure that won't be a problem.", "author": "karllessard", "createdAt": "2020-12-22T20:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2MzkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2NTAzNw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547365037", "bodyText": "This PR doesn't allow user registered classes though right? If so then it should probably say \"in the future we could allow\"", "author": "Craigacp", "createdAt": "2020-12-22T16:10:43Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/internal/types/registry/TensorTypeRegistry.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ *  Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  =======================================================================\n+ */\n+package org.tensorflow.internal.types.registry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.tensorflow.TensorMapper;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.types.TBfloat16;\n+import org.tensorflow.types.TBool;\n+import org.tensorflow.types.TFloat16;\n+import org.tensorflow.types.TFloat32;\n+import org.tensorflow.types.TFloat64;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TString;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.annotation.TensorType;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Repository of all registered tensor types.\n+ */\n+public final class TensorTypeRegistry {\n+\n+  /**\n+   * Find registered information about a tensor type from its equivalent data type\n+   *\n+   * @param dataType data type\n+   * @return type registered information\n+   * @throws IllegalArgumentException if no tensor type for this data type has been registered\n+   */\n+  public static <T extends TType> TensorTypeInfo<T> find(DataType dataType) {\n+    TensorTypeInfo<?> typeInfo = TYPES_BY_CODE.get(dataType.getNumber());\n+    if (typeInfo == null) {\n+      throw new IllegalArgumentException(\"No tensor type has been registered for data type \" + dataType);\n+    }\n+    return (TensorTypeInfo<T>)typeInfo;\n+  }\n+\n+  /**\n+   * Find registered information about a tensor type from its class\n+   *\n+   * @param type class implementing {@link TType}\n+   * @return type registered information\n+   * @throws IllegalArgumentException if the provided class has not been registered as a tensor type\n+   */\n+  public static <T extends TType> TensorTypeInfo<T> find(Class<T> type) {\n+    TensorTypeInfo<?> typeInfo = TYPES_BY_CLASS.get(type);\n+    if (typeInfo == null) {\n+      throw new IllegalArgumentException(\"Class \\\"\" + type.getName() + \"\\\" is not registered as a tensor type\");\n+    }\n+    return (TensorTypeInfo<T>)typeInfo;\n+  }\n+\n+  private static final Map<Integer, TensorTypeInfo<?>> TYPES_BY_CODE = new HashMap<>();\n+  private static final Map<Class<? extends TType>, TensorTypeInfo<?>> TYPES_BY_CLASS = new HashMap<>();\n+\n+  private static <T extends TType> void register(Class<T> type) {\n+    TensorType typeAnnot = type.getDeclaredAnnotation(TensorType.class);\n+    if (typeAnnot == null) {\n+      throw new IllegalArgumentException(\"Class \\\"\" + type.getName() + \"\\\" must be annotated \"\n+          + \"with @TensorType to be registered as a tensor type\");\n+    }\n+    TensorMapper<T> mapper;\n+    try {\n+      mapper = (TensorMapper<T>)typeAnnot.mapperClass().newInstance();\n+    } catch (ReflectiveOperationException e) {\n+      throw new IllegalArgumentException(\"Class \\\"\" + type.getName() + \"\\\" must have a public \"\n+          + \"parameter-less constructor to be used as a tensor mapper\");\n+    }\n+    TensorTypeInfo<T> typeInfo = new TensorTypeInfo<>(type, typeAnnot.dataType(), typeAnnot.byteSize(), mapper);\n+    TYPES_BY_CLASS.put(type, typeInfo);\n+\n+    // If more than one tensor type is mapped to a given native code, the last registered will\n+    // have priority. This way, we can allow user to register their own classes to map tensors", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4NzM1Ng==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547487356", "bodyText": "Ah true, I was planning to support it then postpone that work as a future project but the comment remained, I'll correct it", "author": "karllessard", "createdAt": "2020-12-22T20:15:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2NTAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2NjAzMw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547366033", "bodyText": "Unnecessary import of Iterator?", "author": "Craigacp", "createdAt": "2020-12-22T16:12:39Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/Operands.java", "diffHunk": "@@ -16,10 +16,16 @@\n package org.tensorflow.op;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2NjIzMw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547366233", "bodyText": "Unnecessary import of Tensor?", "author": "Craigacp", "createdAt": "2020-12-22T16:13:03Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/Operands.java", "diffHunk": "@@ -16,10 +16,16 @@\n package org.tensorflow.op;\n \n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n import java.util.List;\n import org.tensorflow.Operand;\n import org.tensorflow.OperationBuilder;\n import org.tensorflow.Output;\n+import org.tensorflow.Tensor;", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2ODYyMA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547368620", "bodyText": "Copyright header is missing the comment * before each line.", "author": "Craigacp", "createdAt": "2020-12-22T16:17:04Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/annotation/TensorType.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2ODg3NQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547368875", "bodyText": "Is this actually plugged into anything yet?", "author": "Craigacp", "createdAt": "2020-12-22T16:17:37Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/family/TIntegral.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ *  Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  =======================================================================\n+ */\n+package org.tensorflow.types.family;\n+\n+/**\n+ * Common interface for all integral numeric tensors.\n+ *\n+ * <p>Operations that only accepts integral values as some of their operands enforce that the tensor\n+ * types for these operands to be bound to this interface.\n+ */\n+public interface TIntegral extends TNumber {}", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM4MDAzNQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547380035", "bodyText": "I found something later on which uses it, but forgot to delete this comment.", "author": "Craigacp", "createdAt": "2020-12-22T16:38:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM2ODg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MTgyNg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547371826", "bodyText": "This more restrictive, do we want that?", "author": "Craigacp", "createdAt": "2020-12-22T16:23:15Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "diffHunk": "@@ -33,12 +33,12 @@\n  *     Identity&lt;TFloat32&gt; initializer =\n  *             new org.tensorflow.framework.initializers.Identity&lt;&gt;(tf);\n  *     Operand&lt;TFloat32&gt; values =\n- *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.class);\n  * </pre>\n  *\n  * @param <T> The TType for the call operation\n  */\n-public class Identity<T extends TType> extends BaseInitializer<T> {\n+public class Identity<T extends TFloating> extends BaseInitializer<T> {", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4ODc4Mw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547488783", "bodyText": "Yes, because the call method has this code before:\n    if (!dtype.isFloating()) {\n      throw new IllegalArgumentException(\"DataType must be a float type: \" + dtype.name());\n    }", "author": "karllessard", "createdAt": "2020-12-22T20:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MjMxNA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547372314", "bodyText": "TNumber import is unnecessary now.", "author": "Craigacp", "createdAt": "2020-12-22T16:24:07Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/LeCun.java", "diffHunk": "@@ -15,6 +15,7 @@\n package org.tensorflow.framework.initializers;\n \n import org.tensorflow.op.Ops;\n+import org.tensorflow.types.family.TFloating;\n import org.tensorflow.types.family.TNumber;", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MzgwNQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547373805", "bodyText": "Shouldn't this be TFloating?", "author": "Craigacp", "createdAt": "2020-12-22T16:26:42Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/TruncatedNormal.java", "diffHunk": "@@ -31,13 +30,12 @@\n  *     TruncatedNormal&lt;TFloat32, TFloat32&gt; initializer =\n  *              new org.tensorflow.framework.initializers.TruncatedNormal&lt;&gt;(tf, seed);\n  *     Operand&lt;TFloat32&gt; values =\n- *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.class);\n  * </pre>\n  *\n  * @param <T> The TType for the call operation\n- * @param <U> The TNumber for the call operation\n  */\n-public class TruncatedNormal<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+public class TruncatedNormal<T extends TNumber> extends BaseInitializer<T> {", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwNzI0MA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547507240", "bodyText": "Check was only one numbers, see this comment", "author": "karllessard", "createdAt": "2020-12-22T21:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MzgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1MDQwNQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547550405", "bodyText": "TrunctedNormal, RandomNormal should be TFloating.\nRandomUniform can be TInteger and TFloating, so that should be TNumber.", "author": "JimClarke5", "createdAt": "2020-12-22T23:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MzgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3MzQzMw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548373433", "bodyText": "Ok so I'll do the corrections for TruncatedNormal and RandomNormal", "author": "karllessard", "createdAt": "2020-12-24T04:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3MzgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NDEwOA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547374108", "bodyText": "TFloating?", "author": "Craigacp", "createdAt": "2020-12-22T16:27:16Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "diffHunk": "@@ -32,13 +32,12 @@\n  *     RandomUniform&lt;TFloat32, TFloat32&gt; initializer =\n  *              new org.tensorflow.framework.initializers.RandomUniform&lt;&gt;(tf, seed);\n  *     Operand&lt;TFloat32&gt; values =\n- *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.class);\n  * </pre>\n  *\n  * @param <T> The TType for the call operation\n- * @param <U> The TNumber for the call operation\n  */\n-public class RandomUniform<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+public class RandomUniform<T extends TNumber> extends BaseInitializer<T> {", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4OTMyMA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547489320", "bodyText": "That one has the following check, so I assume that integral values are also accepted:\n    if (!dtype.isNumeric())\n      throw new IllegalArgumentException(\"The data type must be numeric. Found : \" + dtype.name());", "author": "karllessard", "createdAt": "2020-12-22T20:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NDEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2NTk3Mg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547565972", "bodyText": "RandomNormal should be TFloating.", "author": "JimClarke5", "createdAt": "2020-12-23T00:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NDEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3NTI1Mw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548375253", "bodyText": "According to @JimClarke5 , this one should remain valid for any numeral type.", "author": "karllessard", "createdAt": "2020-12-24T04:18:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NDEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NDE5OQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547374199", "bodyText": "TFloating?", "author": "Craigacp", "createdAt": "2020-12-22T16:27:27Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomNormal.java", "diffHunk": "@@ -31,13 +30,12 @@\n  *     RandomNormal&lt;TFloat32, TFloat32&gt; initializer =\n  *              new org.tensorflow.framework.initializers.RandomNormal&lt;&gt;(tf, seed);\n  *     Operand&lt;TFloat32&gt; values =\n- *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.class);\n  * </pre>\n  *\n  * @param <T> The TType for the call operation\n- * @param <U> The TNumber for the call operation\n  */\n-public class RandomNormal<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+public class RandomNormal<T extends TNumber> extends BaseInitializer<T> {", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ4OTUwNg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547489506", "bodyText": "same thing as #174 (comment)", "author": "karllessard", "createdAt": "2020-12-22T20:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NDE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3NTMwOA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548375308", "bodyText": "According to @JimClarke5 , this one should now be restricted to floating-points only, I'll make the change", "author": "karllessard", "createdAt": "2020-12-24T04:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NDE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547375405", "bodyText": "U extends TFloating?", "author": "Craigacp", "createdAt": "2020-12-22T16:29:52Z", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/losses/Hinge.java", "diffHunk": "@@ -124,16 +124,13 @@ public Hinge(Ops tf, String name, Reduction reduction) {\n   public <T extends TNumber, U extends TNumber> Operand<T> call(\n       Operand<U> labels, Operand<T> predictions, Operand<T> sampleWeights) {", "originalCommit": "ba3d471dd9c3d0174d92fd0b135c04ecb75a848e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzQ5MDA5NQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547490095", "bodyText": "I did not saw any checks enforcing that the tensors to be of a floating type for Hinge, should it?", "author": "karllessard", "createdAt": "2020-12-22T20:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUwNDE3Ng==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547504176", "bodyText": "Well it says predictions should be between 0 and 1. I guess it could supply the integers rather than probabilities, but it's kinda against the docs.", "author": "Craigacp", "createdAt": "2020-12-22T20:57:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU1MjcwMA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547552700", "bodyText": "Labels can be -1, or 1, if the are 0,1, they are converted to -1, 1, but python example show this as float.\nPython is silent on the Predictions, but all the values are between 0 and 1, so should probably be TFLoating.", "author": "JimClarke5", "createdAt": "2020-12-22T23:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU2NTc0OA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r547565748", "bodyText": "The same types should probably apply to SquaredHinge(labels = -1,1 or 0,1) and CategoricalHinge (labels = 0,1)", "author": "JimClarke5", "createdAt": "2020-12-23T00:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM3NDc1Mw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548374753", "bodyText": "Just to make sure I understood @JimClarke5 , so labels could be any numeric values while predictions and sampleWeights must be restricted to floating-points only in all three losses you've mentioned?", "author": "karllessard", "createdAt": "2020-12-24T04:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODY1ODcxOQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548658719", "bodyText": "For these classes, Python does not dictate that they be integers, just that they are value restricted to -1, 0, 1.\nI think if we restrict it to TInteger, it falls more in line with the restriction on the values.", "author": "JimClarke5", "createdAt": "2020-12-24T17:54:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODY3MDU2OQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548670569", "bodyText": "Ok so then labels (U) is bound to TIntegral and predictions/weights (T) is bound to TFloating, I will make this change and we'll adjust later if needed.", "author": "karllessard", "createdAt": "2020-12-24T18:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODY3NjYwMA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548676600", "bodyText": "But in order to change the bound of these generics, I need to move the parameter at the Loss class level instead of the call method level, otherwise the Java compiler does not allow me to override them. e.g.\npublic abstract class Loss<T, U> {\n    public abstract Operand<T> call(Operand<U> labels, Operand<T> predictions, Operand<T> sampleWeights);\n}\n\npublic final class Hinge extends Loss<TFloating, TIntegral> {\n    @Override\n    public Operand<T> call(Operand<U> labels, Operand<T> predictions, Operand<T> sampleWeights) {\n    // ...\n    }\n}\nAre we ok with this change or should we leave Loss parameter-less? ... or should we simply leave it as is (i.e. only bound to TNumber) and review this in a separate PR?", "author": "karllessard", "createdAt": "2020-12-24T18:20:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc0NzU1Mw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548747553", "bodyText": "I don't understand what you need to do? With  Hinge extends Loss<TFloating, TIntegral>,\nWhy doesn't call(Operand<TInt32> labels, Operand<TFloat32> predictions, Operand<TFloat32> sampleWeigthts) work?", "author": "JimClarke5", "createdAt": "2020-12-24T20:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc1NDkyNg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548754926", "bodyText": "That's the thing, it would work that way. But right now the Loss class is unparameterized and the parameters are carried at the method level. I'm not able to override the generic bounds at the method level, only at the class level but that would require me to do a bit of refactoring like I've presented above.", "author": "karllessard", "createdAt": "2020-12-24T22:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc1ODc0NA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548758744", "bodyText": "Ok, now I see. I would change Loss to to be parameterized. That will require touch all the Loss subclasses though, but I think that makes more sense.", "author": "JimClarke5", "createdAt": "2020-12-24T22:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc1ODg3Ng==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548758876", "bodyText": "BTW: Metric is parameterized, so I guess I am learning :-).", "author": "JimClarke5", "createdAt": "2020-12-24T22:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc1OTIzNA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548759234", "bodyText": "In the interests of getting this PR integrated, lets leave firming up these types for another PR. I agree it should be done, but I don't think it's worth blocking this or making it any bigger.", "author": "Craigacp", "createdAt": "2020-12-24T22:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODc1OTg1OA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r548759858", "bodyText": "I agree, so I'm pushing only the other changes that we've discussed.", "author": "karllessard", "createdAt": "2020-12-24T22:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzM3NTQwNQ=="}], "type": "inlineReview"}, {"oid": "71bc78c3c70feaefbfc0b5f7f4736c1b15f6d76c", "url": "https://github.com/tensorflow/java/commit/71bc78c3c70feaefbfc0b5f7f4736c1b15f6d76c", "message": "Cleanup some obsolete imports and comments", "committedDate": "2020-12-23T16:47:05Z", "type": "commit"}, {"oid": "3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "url": "https://github.com/tensorflow/java/commit/3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "message": "Restrict tensor types on some initializers", "committedDate": "2020-12-24T23:04:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczODc4Mg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549738782", "bodyText": "Augment this method to handle a shape of UNKNOWN_SIZE? (The previous version accidentally handled it.)", "author": "deansher", "createdAt": "2020-12-29T15:08:31Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/RawTensor.java", "diffHunk": "@@ -84,33 +86,39 @@ public ByteDataBuffer data() {\n    */\n   @Override\n   public String toString() {\n-    return String.format(\"%s tensor with shape %s\", dtype.toString(), shape);\n+    return String.format(\"%s tensor with shape %s\", typeInfo.dataType(), shape);\n   }\n \n   /**\n    * Allocates a new tensor in native memory of the given type, shape and size.\n    *\n    * <p>The size of the tensor must be at least large enough to contain all scalars for the\n-   * given type and shape, i.e. <code>size >= dtype.byteSize() * shape.size()</code>. More memory\n-   * can be allocated to store also metadata within the tensor itself, e.g. a lookup table\n-   * in a string tensor.\n+   * given type and shape. More memory can also be allocated to store also metadata within the\n+   * tensor itself, e.g. a lookup table in a string tensor.\n    *\n-   * @param dtype data type\n+   * @param type tensor type class\n    * @param shape shape of the tensor\n-   * @param size size of the tensor\n+   * @param size size in bytes of the tensor, or -1 to compute the size from the shape\n    * @return allocated tensor\n    */\n-  static RawTensor allocate(DataType<?> dtype, Shape shape, long size) {\n-    // Minimum requirements for datatypes of variable length cannot be verified in a relevant way so\n-    // we only validate them for fixed length datatypes\n-    if (!dtype.isVariableLength() && shape.size() * dtype.byteSize() > size) {\n+  static RawTensor allocate(Class<? extends TType> type, Shape shape, long size) {", "originalCommit": "3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkyNDA0MQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549924041", "bodyText": "In fact, passing a totally or partially unknown shape to this constructor should be forbidden, I'll add a check for this.", "author": "karllessard", "createdAt": "2020-12-30T03:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTczODc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc0NzczNQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549747735", "bodyText": "Document the behavior when shape has UNKNOWN_SIZE and -1 is passed for size?", "author": "deansher", "createdAt": "2020-12-29T15:33:32Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -57,35 +49,35 @@\n    * <p>The amount of memory to allocate is derived from the datatype and the shape of the tensor,\n    * and is left uninitialized.\n    *\n-   * @param <T> the tensor element type\n-   * @param dtype datatype of the tensor\n+   * @param <T> the tensor type\n+   * @param type the tensor type class\n    * @param shape shape of the tensor\n    * @return an allocated but uninitialized tensor\n    * @throws IllegalStateException if tensor failed to be allocated\n    */\n-  static <T extends TType> T of(DataType<T> dtype, Shape shape) {\n-    return of(dtype, shape, shape.size() * dtype.byteSize());\n+  static <T extends TType> T of(Class<T> type, Shape shape) {\n+    return of(type, shape, -1);\n   }\n \n   /**\n    * Allocates a tensor of a given datatype, shape and size.\n    *\n-   * <p>This method is identical to {@link #of(DataType, Shape)}, except that the final size of the\n+   * <p>This method is identical to {@link #of(Class, Shape)}, except that the final size of the\n    * tensor is explicitly set instead of computing it from the datatype and shape, which could be\n    * larger than the actual space required to store the data but not smaller.\n    *\n-   * @param <T> the tensor element type\n-   * @param dtype datatype of the tensor\n+   * @param <T> the tensor type\n+   * @param type the tensor type class\n    * @param shape shape of the tensor\n-   * @param size size, in bytes, of the tensor\n+   * @param size size in bytes of the tensor or -1 to compute the size from the shape", "originalCommit": "3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkyNDE1Mg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549924152", "bodyText": "same as in #174 (comment)", "author": "karllessard", "createdAt": "2020-12-30T03:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc0NzczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc0ODUwOA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549748508", "bodyText": "Given the new support for size of -1, perhaps change to \"can be explicitly set\".", "author": "deansher", "createdAt": "2020-12-29T15:35:40Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -103,47 +95,47 @@\n    *\n    * <pre>{@code\n    * FloatNdArray data = ...\n-   * try (TFloat32 t = Tensor.of(TFloat32.DTYPE, Shape.of(2, 2), data::copyTo)) {\n+   * try (TFloat32 t = Tensor.of(TFloat32.class, Shape.of(2, 2), data::copyTo)) {\n    *   ...\n    * }\n    * }</pre>\n    *\n    * <p>If {@code dataInitializer} fails and throws an exception, the allocated tensor will be\n    * automatically released before rethrowing the same exception.\n    *\n-   * @param <T> the tensor element type\n-   * @param dtype datatype of the tensor\n+   * @param <T> the tensor type\n+   * @param type the tensor type class\n    * @param shape shape of the tensor\n    * @param dataInitializer method receiving accessor to the allocated tensor data for initialization\n    * @return an allocated and initialized tensor\n    * @throws IllegalStateException if tensor failed to be allocated\n    */\n-  static <T extends TType> T of(DataType<T> dtype, Shape shape, Consumer<T> dataInitializer) {\n-    return of(dtype, shape, shape.size() * dtype.byteSize(), dataInitializer);\n+  static <T extends TType> T of(Class<T> type, Shape shape, Consumer<T> dataInitializer) {\n+    return of(type, shape, -1, dataInitializer);\n   }\n \n   /**\n    * Allocates a tensor of a given datatype, shape and size.\n    *\n-   * <p>This method is identical to {@link #of(DataType, Shape, Consumer)}, except that the final\n+   * <p>This method is identical to {@link #of(Class, Shape, Consumer)}, except that the final\n    * size for the tensor is explicitly set instead of being computed from the datatype and shape.", "originalCommit": "3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxMDg2OQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549810869", "bodyText": "Elsewhere (such as in Tensor), we simply call this type().  I do feel the emotional tug to be more explicit in this case, but I wonder if it will simply feel like inconsistency once we have lived with the new paradigm for a while.", "author": "deansher", "createdAt": "2020-12-29T18:49:45Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/internal/types/registry/TensorTypeInfo.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ *  Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  =======================================================================\n+ */\n+package org.tensorflow.internal.types.registry;\n+\n+import org.tensorflow.TensorMapper;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Registered information about a tensor type.\n+ *\n+ * @param <T> the tensor type\n+ */\n+public final class TensorTypeInfo<T extends TType> {\n+\n+  /**\n+   * Returns the class of this tensor type\n+   */\n+  public Class<T> typeClass() {", "originalCommit": "3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkyNTc0OQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549925749", "bodyText": "I was hesitating on this one as well so sounds like we are two now, meaning that it should be type(), I'll rename it.", "author": "karllessard", "createdAt": "2020-12-30T03:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxMDg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxMjgyMw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549812823", "bodyText": "dType -> type throughout this file", "author": "deansher", "createdAt": "2020-12-29T18:56:26Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/Shapes.java", "diffHunk": "@@ -83,7 +79,7 @@\n    */\n   @Endpoint(name = \"flatten\")\n   public static <T extends TType, U extends TNumber> Operand<T> flatten(\n-      Scope scope, Operand<T> operand, DataType<U> dType) {\n+      Scope scope, Operand<T> operand, Class<U> dType) {", "originalCommit": "3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxMzk0Mg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549813942", "bodyText": "!= would be more consistent.", "author": "deansher", "createdAt": "2020-12-29T19:00:20Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/nn/SoftmaxCrossEntropyWithLogits.java", "diffHunk": "@@ -78,24 +77,20 @@\n       axis += logits.shape().numDimensions();\n     }\n \n-\n-    boolean convertToFloat32 =\n-        logits.asOutput().dataType() == TFloat16.DTYPE\n-            || logits.asOutput().dataType() == TBfloat16.DTYPE;\n-    if (convertToFloat32) {\n+    if (logits.asOutput().type() == TFloat16.class || logits.asOutput().type() == TBfloat16.class) {\n       Operand<TFloat32> result =  softmaxCrossEntropyWithLogits(scope,\n-              Cast.create(scope, labels, TFloat32.DTYPE),\n-              Cast.create(scope, logits, TFloat32.DTYPE),\n+              Cast.create(scope, labels, TFloat32.class),\n+              Cast.create(scope, logits, TFloat32.class),\n               axis);\n-      return Cast.create(scope, result, logits.asOutput().dataType());\n-    } else if(!logits.asOutput().dataType().equals(labels.asOutput().dataType())) {\n+      return Cast.create(scope, result, logits.asOutput().type());\n+    } else if(!logits.asOutput().type().equals(labels.asOutput().type())) {", "originalCommit": "3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgxNDI1OQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549814259", "bodyText": "rankDType -> rankType", "author": "deansher", "createdAt": "2020-12-29T19:01:40Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/nn/SoftmaxCrossEntropyWithLogits.java", "diffHunk": "@@ -197,8 +192,8 @@\n    */\n   private static <T extends TNumber, U extends TNumber> Operand<T> moveDimToEnd(\n       Scope scope, Operand<T> input, int dimIndex, Operand<U> rank) {\n-    DataType<? extends TNumber> rankDType = rank.asOutput().dataType();\n-    Operand one = Cast.create(scope, Constant.scalarOf(scope, 1), rankDType);\n+    Class<U> rankDType = rank.asOutput().type();", "originalCommit": "3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMDE1Nw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549820157", "bodyText": "This test code throws the expected exception because of the assignment to intTensor, rather than in asTypedTensor(). Here is alternative test code that also passes, but demonstrates that asTypedTensor() doesn't have its documented behavior:\n  @Test\n  public void rawToTypedTensor() {\n    RawTensor rawTensor = RawTensor.allocate(TFloat32.class, Shape.of(2, 2), -1);\n    TFloat32 floatTensor = rawTensor.asTypedTensor();\n    assertSame(floatTensor.asRawTensor(), rawTensor);\n    Object objTensor = rawTensor.<TInt32>asTypedTensor();\n    try {\n      TInt32 intTensor = (TInt32) objTensor;\n      fail();\n    } catch (ClassCastException e) {\n      // ok\n    }\n  }", "author": "deansher", "createdAt": "2020-12-29T19:23:32Z", "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/RawTensorTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ *  Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  =======================================================================\n+ */\n+package org.tensorflow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.junit.jupiter.api.Test;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.types.TFloat32;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TString;\n+\n+public class RawTensorTest {\n+\n+  @Test\n+  public void rawToTypedTensor() {\n+    RawTensor rawTensor = RawTensor.allocate(TFloat32.class, Shape.of(2, 2), -1);\n+    TFloat32 floatTensor = rawTensor.asTypedTensor();\n+    assertSame(floatTensor.asRawTensor(), rawTensor);\n+    try {\n+      TInt32 intTensor = rawTensor.asTypedTensor();", "originalCommit": "3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkyODkxOQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549928919", "bodyText": "Good point, I've never tried that before. You want me to update the doc or try to throw an ClassCastException in this case as well?\nNote that asTypedTensor() is an internal package-private method and where it is currently being used, it is implicitly enforced that the returned type matches the type of the tensor for all cases.", "author": "karllessard", "createdAt": "2020-12-30T04:08:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE5NTUyNA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r550195524", "bodyText": "Updating the doc seems good to me for both of the reasons you give.", "author": "deansher", "createdAt": "2020-12-30T13:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDIyODc1Ng==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r550228756", "bodyText": "To be honest I'm not too sure how to document this. It looks to me that this behavior is some kind of \"defect\" in the generic specification, since the explicit <TInt32> parameterization of the method invocation seems to be overridden implicitly to the type inferred by the target (Object in this case).\nSo basically, <TInt32> is ignored and that is probably the case for Java type inference in general when dealing with type parameters inferred by a target, is it worth documenting it here then?", "author": "karllessard", "createdAt": "2020-12-30T15:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDIzMjcxOQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r550232719", "bodyText": "The type will be erased at runtime so the cast is erased to its bound (TType) which always succeeds. It might be better to have it explicitly return TType rather than have it promise something that can't be enforced by the type system. This is going to pollute the internals of our code with casts, but at least we'll remember to put them in rather than having it mysteriously blow up.", "author": "Craigacp", "createdAt": "2020-12-30T15:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI1Mzc5MQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r550253791", "bodyText": "Ok sounds fair, let's do that, anyway all these additional casts will happen internally only.\nUpdate: ended up that only one additional cast was required in the source code...", "author": "karllessard", "createdAt": "2020-12-30T16:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI2NTQ1Mw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r550265453", "bodyText": "On further reflection, I lean the same way as @Craigacp: have this method return TType.\nHere's some analysis to support this choice: At runtime, the current behavior is \"apply the mapper from typeInfo and return whatever TType it produces.\" Since the type parameter T is erased at runtime, the only way to guarantee a return of T would be to have the method take the tensor type class as a runtime parameter and explicitly verify that the mapper returns that type class. I might advocate this approach for a public method or even a widely used package-private method, but not for a rarely used package-private method.\nBut also, a review of the call points of this method raises another issue: whenever we treat the return value of asTypedTensor as simply a Tensor (rather than a TType), we \"forget\" at compile time the semantic upgrade that was presumably the point of the asTypedTensor call in the first place.\nAs an example, let's explore what happens underneath the following method:\nclass EagerOperation extends AbstractOperation {\n  // ...\n  /**\n   * Returns the tensor of the {@code outputIdx}th output of this operation.\n   *\n   * <p>This is only supported in an eager execution environment.\n   *\n   * @param outputIdx index of the output of this operation\n   * @return output tensor\n   */\n  @Override\n  Tensor tensor(int outputIndex) {\n    Tensor tensor = outputTensors.get(outputIndex);\n    if (tensor == null) {\n      tensor = resolveTensor(outputIndex);\n    }\n    return tensor;\n  }\n  // ...\n}\n(I copied the Javadoc above the @Override for easy reference.)\nThe caller should presumably be agnostic as to whether this returns a RawTensor or a TType. But looking deeper into the call path, here's how the returned Tensor is  constructed:\n  private static Tensor resolveTensorHandle(TFE_TensorHandle handle, EagerSession session) {\n    requireTensorHandle(handle);\n    try (PointerScope scope = new PointerScope()) {\n      TF_Status status = TF_Status.newStatus();\n      TF_Tensor tensor = TFE_TensorHandleResolve(handle, status).withDeallocator();\n      status.throwExceptionIfNotOK();\n      return RawTensor.fromHandle(tensor, session).asTypedTensor();\n    }\n  }\nWhat's the point of asTypedTensor() on the last substantive line, above? It causes this method to return a special kind of Tensor -- a TType -- but that fact is immediately forgotten by the type system and is not even asserted in the Javadoc. Presumably, we should either drop the call to .asTypedTensor() or change the whole call path to return TType.", "author": "deansher", "createdAt": "2020-12-30T17:12:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDI2NTc1OQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r550265759", "bodyText": ":-) But not for this PR!", "author": "deansher", "createdAt": "2020-12-30T17:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMDE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTgyMTA3Mg==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r549821072", "bodyText": "Add test to show intended behavior of shape with UNKNOWN_SIZE.", "author": "deansher", "createdAt": "2020-12-29T19:26:43Z", "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/RawTensorTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ *  Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  =======================================================================\n+ */\n+package org.tensorflow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.junit.jupiter.api.Test;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.types.TFloat32;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TString;\n+\n+public class RawTensorTest {\n+\n+  @Test\n+  public void rawToTypedTensor() {\n+    RawTensor rawTensor = RawTensor.allocate(TFloat32.class, Shape.of(2, 2), -1);\n+    TFloat32 floatTensor = rawTensor.asTypedTensor();\n+    assertSame(floatTensor.asRawTensor(), rawTensor);\n+    try {\n+      TInt32 intTensor = rawTensor.asTypedTensor();\n+      fail();\n+    } catch (ClassCastException e) {\n+      // ok\n+    }\n+  }\n+\n+  @Test\n+  public void allocateTensorWithSize() {\n+    try (RawTensor rawTensor = RawTensor.allocate(TFloat32.class, Shape.of(2, 2), 16)) {\n+      assertEquals(16, rawTensor.numBytes());\n+    }\n+    try (RawTensor rawTensor = RawTensor.allocate(TFloat32.class, Shape.of(2, 2), 100)) {\n+      assertEquals(100, rawTensor.numBytes());\n+    }\n+    try (RawTensor rawTensor = RawTensor.allocate(TFloat32.class, Shape.of(2, 2), 10)) {\n+      fail();\n+    } catch (IllegalArgumentException e) {\n+      // ok\n+    }\n+    try (RawTensor rawTensor = RawTensor.allocate(TString.class, Shape.of(2, 2), 100)) {\n+      assertEquals(100, rawTensor.numBytes());\n+    }\n+  }\n+\n+  @Test\n+  public void allocateTensorWithoutSize() {", "originalCommit": "3ce9f9a63554cfa63b1fc8c8a4f128eb42696baa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b2a54aa0a5365e54bce8aba65a92e83c33f6bfbe", "url": "https://github.com/tensorflow/java/commit/b2a54aa0a5365e54bce8aba65a92e83c33f6bfbe", "message": "Document a few exception cases and other cleanups", "committedDate": "2020-12-30T16:48:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMxMDYzOA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r550310638", "bodyText": "At some point we should fix the generator so it doesn't shadow the type name with a variable name, that's just confusing.", "author": "Craigacp", "createdAt": "2020-12-30T19:57:01Z", "path": "tensorflow-core/tensorflow-core-api/src/gen/java/org/tensorflow/op/collective/BroadcastRecv.java", "diffHunk": "@@ -77,10 +77,10 @@ private Options() {\n    * @return a new instance of BroadcastRecv\n    */\n   @Endpoint(describeByClass = true)\n-  public static <T extends TType> BroadcastRecv<T> create(Scope scope, DataType<T> T, Long groupSize, Long groupKey, Long instanceKey, Shape shape, Options... options) {\n+  public static <T extends TType> BroadcastRecv<T> create(Scope scope, Class<T> T, Long groupSize, Long groupKey, Long instanceKey, Shape shape, Options... options) {\n     OperationBuilder opBuilder = scope.env().opBuilder(\"CollectiveBcastRecv\", scope.makeOpName(\"BroadcastRecv\"));\n     opBuilder = scope.apply(opBuilder);\n-    opBuilder.setAttr(\"T\", T);\n+    opBuilder.setAttr(\"T\", Operands.toDataType(T));", "originalCommit": "b2a54aa0a5365e54bce8aba65a92e83c33f6bfbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMxMjUzMw==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r550312533", "bodyText": "This is a place where it will infer the type bound from the calling context, and if that's wrong then we'll get a weird class cast error when people use it. It might be better to return the wildcard as at least the user will get a warning when they make the cast.", "author": "Craigacp", "createdAt": "2020-12-30T20:04:45Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/internal/types/registry/TensorTypeRegistry.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ *  Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  =======================================================================\n+ */\n+package org.tensorflow.internal.types.registry;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.tensorflow.TensorMapper;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.types.TBfloat16;\n+import org.tensorflow.types.TBool;\n+import org.tensorflow.types.TFloat16;\n+import org.tensorflow.types.TFloat32;\n+import org.tensorflow.types.TFloat64;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TString;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.annotation.TensorType;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Repository of all registered tensor types.\n+ */\n+public final class TensorTypeRegistry {\n+\n+  /**\n+   * Find registered information about a tensor type from its equivalent data type\n+   *\n+   * @param dataType data type\n+   * @return type registered information\n+   * @throws IllegalArgumentException if no tensor type for this data type has been registered\n+   */\n+  public static <T extends TType> TensorTypeInfo<T> find(DataType dataType) {", "originalCommit": "b2a54aa0a5365e54bce8aba65a92e83c33f6bfbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM0MTE4OA==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r550341188", "bodyText": "Again note that the TensorTypeRegistry is (for now) an internal class so we do have some control over the context it is being called. But like you've suggested, let's review this later.", "author": "karllessard", "createdAt": "2020-12-30T22:11:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMxMjUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM0MjE2MQ==", "url": "https://github.com/tensorflow/java/pull/174#discussion_r550342161", "bodyText": "Yeah, I know. But I'm in favour of having the compiler warn me before I make a silly mistake, and 6 months from now I won't necessarily remember that this method doesn't quite live up to its contract.", "author": "Craigacp", "createdAt": "2020-12-30T22:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMxMjUzMw=="}], "type": "inlineReview"}]}