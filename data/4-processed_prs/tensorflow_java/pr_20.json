{"pr_number": 20, "pr_title": "Scalars and vectors", "pr_createdAt": "2020-01-22T03:52:46Z", "pr_url": "https://github.com/tensorflow/java/pull/20", "timeline": [{"oid": "34b9d7072fecd54e4b4542de02cdf5c285b74408", "url": "https://github.com/tensorflow/java/commit/34b9d7072fecd54e4b4542de02cdf5c285b74408", "message": "Add Matrix operator", "committedDate": "2020-02-06T16:06:59Z", "type": "forcePushed"}, {"oid": "c9cad150cbc245edb92057b9f7e941750080e432", "url": "https://github.com/tensorflow/java/commit/c9cad150cbc245edb92057b9f7e941750080e432", "message": "Add Matrix operator", "committedDate": "2020-02-06T17:12:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NDY3MQ==", "url": "https://github.com/tensorflow/java/pull/20#discussion_r377184671", "bodyText": "The copyright on new files should probably be 2020.", "author": "Craigacp", "createdAt": "2020-02-10T16:49:02Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/Matrix.java", "diffHunk": "@@ -0,0 +1,563 @@\n+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.", "originalCommit": "c9cad150cbc245edb92057b9f7e941750080e432", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NTk5Ng==", "url": "https://github.com/tensorflow/java/pull/20#discussion_r377185996", "bodyText": "Is a 4-rank object really a matrix? Should these be moved to tensorConstant or some other name? Also the javadoc should probably note that these are slower than other ways of creating a 4-rank object.", "author": "Craigacp", "createdAt": "2020-02-10T16:50:52Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/Matrix.java", "diffHunk": "@@ -0,0 +1,563 @@\n+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+package org.tensorflow.op.core;\n+\n+import org.tensorflow.Operation;\n+import org.tensorflow.Tensor;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.tools.ndarray.NdArray;\n+import org.tensorflow.tools.ndarray.NdArrays;\n+import org.tensorflow.tools.ndarray.StdArrays;\n+import org.tensorflow.types.TBool;\n+import org.tensorflow.types.TFloat32;\n+import org.tensorflow.types.TFloat64;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TString;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * An operator producing a matrix (rank-2 or higher) constant value.\n+ */\n+@Operator\n+public final class Matrix<T extends TType> extends Constant<T> {\n+\n+  /**\n+   * Creates a rank-2 constant of {@code int} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TInt32} constant matrix\n+   */\n+  public static Matrix<TInt32> create(Scope scope, int[][] data) {\n+    try (Tensor<TInt32> value = TInt32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-3 constant of {@code int} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TInt32} constant matrix\n+   */\n+  public static Matrix<TInt32> create(Scope scope, int[][][] data) {\n+    try (Tensor<TInt32> value = TInt32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-4 constant of {@code int} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TInt32} constant matrix\n+   */\n+  public static Matrix<TInt32> create(Scope scope, int[][][][] data) {\n+    try (Tensor<TInt32> value = TInt32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-5 constant of {@code int} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TInt32} constant matrix\n+   */\n+  public static Matrix<TInt32> create(Scope scope, int[][][][][] data) {\n+    try (Tensor<TInt32> value = TInt32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-6 constant of {@code int} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TInt32} constant matrix\n+   */\n+  public static Matrix<TInt32> create(Scope scope, int[][][][][][] data) {\n+    try (Tensor<TInt32> value = TInt32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-2 constant of {@code float} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat32} constant matrix\n+   */\n+  public static Matrix<TFloat32> create(Scope scope, float[][] data) {\n+    try (Tensor<TFloat32> value = TFloat32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-3 constant of {@code float} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat32} constant matrix\n+   */\n+  public static Matrix<TFloat32> create(Scope scope, float[][][] data) {\n+    try (Tensor<TFloat32> value = TFloat32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-4 constant of {@code float} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat32} constant matrix\n+   */\n+  public static Matrix<TFloat32> create(Scope scope, float[][][][] data) {\n+    try (Tensor<TFloat32> value = TFloat32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-5 constant of {@code float} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat32} constant matrix\n+   */\n+  public static Matrix<TFloat32> create(Scope scope, float[][][][][] data) {\n+    try (Tensor<TFloat32> value = TFloat32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-6 constant of {@code float} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat32} constant matrix\n+   */\n+  public static Matrix<TFloat32> create(Scope scope, float[][][][][][] data) {\n+    try (Tensor<TFloat32> value = TFloat32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-2 constant of {@code double} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat64} constant matrix\n+   */\n+  public static Matrix<TFloat64> create(Scope scope, double[][] data) {\n+    try (Tensor<TFloat64> value = TFloat64.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-3 constant of {@code double} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat64} constant matrix\n+   */\n+  public static Matrix<TFloat64> create(Scope scope, double[][][] data) {\n+    try (Tensor<TFloat64> value = TFloat64.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-4 constant of {@code double} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat64} constant matrix\n+   */\n+  public static Matrix<TFloat64> create(Scope scope, double[][][][] data) {", "originalCommit": "c9cad150cbc245edb92057b9f7e941750080e432", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM4MDQ2OQ==", "url": "https://github.com/tensorflow/java/pull/20#discussion_r377380469", "bodyText": "Is a 4-rank object really a matrix\n\ntensor can also be rank-0 or 1, while here it is only used to initialize rank-2+ tensors from standard nd-arrays. I thought matrix meant that in some way but while it is pretty common for 2D and 3D, I personally don't know how awkward it sounds in the field for 4D+ data structures.\nWe can also merge back all those endpoints in a single constant (or tensor?) operator, with an exception for the vector initializers taking advantages of the vararg parameter.\n\nAlso the javadoc should probably note that these are slower than other ways of creating a 4-rank object.\n\nActually, since I removed all reflective operations on them, their performances is comparable to the other methods. In graph mode, the usage of a constant is mainly to instantiate a value from some constant values, which should be relatively small. I think what was really killing performances is when large tensors were created for feeding data to a graph using one of the Tensors.create methods, like this one (that I plan to remove as well).", "author": "karllessard", "createdAt": "2020-02-10T23:34:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NTk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM5MTM3NQ==", "url": "https://github.com/tensorflow/java/pull/20#discussion_r377391375", "bodyText": "Just thought of something, I've always found that tf.constant is a bit verbose for something that is used so often.\nWhat about tf.val instead? It is concise and kind of implies that it is an immutable (constant) value. Then, the tf.vector could be renamed maybe to tf.array for vararg initialization only and other operators would be removed. @Craigacp?", "author": "karllessard", "createdAt": "2020-02-11T00:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NTk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzYxNjE0MA==", "url": "https://github.com/tensorflow/java/pull/20#discussion_r377616140", "bodyText": "Trying it out, I think I really like it:\n  private static Tensor<TFloat32> preprocessImages(ByteNdArray rawImages) {\n    Ops tf = Ops.create();\n\n    // Flatten images in a single dimension and normalize their pixels as floats.\n    long imageSize = rawImages.get(0).shape().size();\n    return tf.math.div(\n        tf.reshape(\n            tf.dtypes.cast(tf.val(rawImages), TFloat32.DTYPE),\n            tf.array(-1L, imageSize)\n        ),\n        tf.val(255.0f)\n    ).asTensor();\n  }\nBoth val and array return a Constant object (with the help of the new @Endpoint annotation). I think I'll push those changes, the timing is right for improving the whole API.", "author": "karllessard", "createdAt": "2020-02-11T12:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NTk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODYzMzczNg==", "url": "https://github.com/tensorflow/java/pull/20#discussion_r378633736", "bodyText": "Just thought of something, I've always found that tf.constant is a bit verbose for something that is used so often.\n\nAgreed; I like the tf.val and tf.array with vararg initialization.\nI think the necessity of a tf.matrix is not very high; it'd be ok to just have tf.constant or tf.tensor methods to construct higher dimensional tensors like you suggest above.", "author": "dhruvrajan", "createdAt": "2020-02-13T03:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NTk5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg3NTgxNQ==", "url": "https://github.com/tensorflow/java/pull/20#discussion_r378875815", "bodyText": "In fact, API speaking, I've reverted most of the signatures to what they were, with the following exceptions:\n\ntf.constant has been renamed to tf.val\ntf.array has been added to support vararg\nShape.make has been renamed to Shape.of\nA few other minor things.\n\nSo there is no more tf.matrix, tf.vector, tf.scalar, tf.tensor....", "author": "karllessard", "createdAt": "2020-02-13T13:58:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NTk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5NDE5Ng==", "url": "https://github.com/tensorflow/java/pull/20#discussion_r377194196", "bodyText": "Is this the behaviour we want for ragged tensors? The ndarray machinery is mostly predicated on the ndarray being a hyperrectangle, is everything robust to getting a Shape.UNKNOWN_SIZE?", "author": "Craigacp", "createdAt": "2020-02-10T17:04:14Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/StdArrays.java", "diffHunk": "@@ -0,0 +1,1476 @@\n+package org.tensorflow.tools.ndarray;\n+\n+import static org.tensorflow.tools.ndarray.NdArrays.vectorOf;\n+import static org.tensorflow.tools.ndarray.NdArrays.vectorOfObjects;\n+\n+import org.tensorflow.tools.Shape;\n+\n+/**\n+ * Utility class for working with {@link NdArray} instances mixed with standard Java arrays.\n+ */\n+public final class StdArrays {\n+\n+  /**\n+   * Copy a single-dimension array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[] array) {\n+    vectorOfObjects(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOfObjects(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOfObjects(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOfObjects(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOfObjects(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOfObjects(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension int array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions int array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions int array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions int array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions int array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions int array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension long array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions long array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions long array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions long array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions long array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions long array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension float array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions float array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions float array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions float array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions float array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions float array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension double array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions double array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions double array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions double array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions double array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions double array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension byte array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions byte array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions byte array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions byte array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions byte array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions byte array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension short array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions short array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions short array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions short array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions short array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions short array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension boolean array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions boolean array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions boolean array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions boolean array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions boolean array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions boolean array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension object array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions object array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions object array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions object array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions object array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions object array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  private static void dimSize(int arrayLength, long[] shape, int dimIdx) {\n+    if (shape[dimIdx] == 0) {\n+      shape[dimIdx] = arrayLength;\n+    } else if (shape[dimIdx] != arrayLength) {\n+      shape[dimIdx] = Shape.UNKNOWN_SIZE;", "originalCommit": "c9cad150cbc245edb92057b9f7e941750080e432", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM4MjQxNQ==", "url": "https://github.com/tensorflow/java/pull/20#discussion_r377382415", "bodyText": "It's in preparation for. Right now, only dense NdArrays can be instantiated by TF Tools. Plus, providing a \"ragged standard array\" to initialize a dense one will fail gracefully, like it is tested here.\nSo I think it is safe to support properly unknown dim sizes for standard arrays.", "author": "karllessard", "createdAt": "2020-02-10T23:40:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5NDE5Ng=="}], "type": "inlineReview"}, {"oid": "400536c04e1745ff09ef555e8acd760939f7c8f1", "url": "https://github.com/tensorflow/java/commit/400536c04e1745ff09ef555e8acd760939f7c8f1", "message": "Close default eager session for testing", "committedDate": "2020-02-12T23:00:17Z", "type": "commit"}, {"oid": "cb98f16556db7b9541ec2d9537e80b8ac17dddb7", "url": "https://github.com/tensorflow/java/commit/cb98f16556db7b9541ec2d9537e80b8ac17dddb7", "message": "Add support for deprecated ops", "committedDate": "2020-02-12T23:02:01Z", "type": "commit"}, {"oid": "23f9123116b4451825fa8f33ea5447e4d4b32693", "url": "https://github.com/tensorflow/java/commit/23f9123116b4451825fa8f33ea5447e4d4b32693", "message": "Add Scalar and Vector ops", "committedDate": "2020-02-12T23:02:03Z", "type": "commit"}, {"oid": "e825b8711d230a6e81741c65c4b7c2e003860536", "url": "https://github.com/tensorflow/java/commit/e825b8711d230a6e81741c65c4b7c2e003860536", "message": "Rename a few methods", "committedDate": "2020-02-12T23:02:03Z", "type": "commit"}, {"oid": "c590483bb0ef5626e1e4498e089fa403e4130358", "url": "https://github.com/tensorflow/java/commit/c590483bb0ef5626e1e4498e089fa403e4130358", "message": "Cleanup types factories", "committedDate": "2020-02-12T23:02:03Z", "type": "commit"}, {"oid": "ba3eb49c322e3a3eb614b3582b7ed70f56780ca1", "url": "https://github.com/tensorflow/java/commit/ba3eb49c322e3a3eb614b3582b7ed70f56780ca1", "message": "Add StdArrays utilities", "committedDate": "2020-02-12T23:02:03Z", "type": "commit"}, {"oid": "785bf7b936d04734a9b53e79d32efc682c3785e6", "url": "https://github.com/tensorflow/java/commit/785bf7b936d04734a9b53e79d32efc682c3785e6", "message": "Add Matrix operator", "committedDate": "2020-02-12T23:02:03Z", "type": "commit"}, {"oid": "172dd5f7e6a9104d8d5ae5f6e0a1cd4cb8417a3a", "url": "https://github.com/tensorflow/java/commit/172dd5f7e6a9104d8d5ae5f6e0a1cd4cb8417a3a", "message": "Reduce constants to 'val' and 'array'", "committedDate": "2020-02-12T23:02:03Z", "type": "commit"}, {"oid": "c6edd32e8f75b6db749cce71c6b4a4f2e84a115a", "url": "https://github.com/tensorflow/java/commit/c6edd32e8f75b6db749cce71c6b4a4f2e84a115a", "message": "Reduce constants to 'val' and 'array'", "committedDate": "2020-02-12T23:23:45Z", "type": "forcePushed"}, {"oid": "8c73b39586ee490f3ec0a8bb07ea67530e6c95ab", "url": "https://github.com/tensorflow/java/commit/8c73b39586ee490f3ec0a8bb07ea67530e6c95ab", "message": "Reduce constants to 'val' and 'array'", "committedDate": "2020-02-12T23:35:43Z", "type": "commit"}, {"oid": "8c73b39586ee490f3ec0a8bb07ea67530e6c95ab", "url": "https://github.com/tensorflow/java/commit/8c73b39586ee490f3ec0a8bb07ea67530e6c95ab", "message": "Reduce constants to 'val' and 'array'", "committedDate": "2020-02-12T23:35:43Z", "type": "forcePushed"}]}