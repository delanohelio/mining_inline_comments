{"pr_number": 63, "pr_title": "Recycle objects when iterating an element sequence", "pr_createdAt": "2020-05-27T22:11:16Z", "pr_url": "https://github.com/tensorflow/java/pull/63", "timeline": [{"oid": "442d65d546db4704422e6f98c7b9c4172fecabef", "url": "https://github.com/tensorflow/java/commit/442d65d546db4704422e6f98c7b9c4172fecabef", "message": "Recycle objects when iterating an element sequence", "committedDate": "2020-05-27T22:24:05Z", "type": "commit"}, {"oid": "442d65d546db4704422e6f98c7b9c4172fecabef", "url": "https://github.com/tensorflow/java/commit/442d65d546db4704422e6f98c7b9c4172fecabef", "message": "Recycle objects when iterating an element sequence", "committedDate": "2020-05-27T22:24:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxMzIyOA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r433413228", "bodyText": "Unnecessary imports?", "author": "Craigacp", "createdAt": "2020-06-01T18:31:37Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/sequence/CoordinatesIncrementor.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ *  Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  =======================================================================\n+ */\n+\n+package org.tensorflow.tools.ndarray.impl.sequence;\n+\n+import java.util.NoSuchElementException;\n+\n+import org.tensorflow.tools.ndarray.impl.dimension.DimensionalSpace;", "originalCommit": "442d65d546db4704422e6f98c7b9c4172fecabef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU4Mjg3NQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r433582875", "bodyText": "Yup, thanks!", "author": "karllessard", "createdAt": "2020-06-02T02:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxMzIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxNjA4MA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r433416080", "bodyText": "What's with all the default methods returning null? I didn't see null checks elsewhere in the code to deal with it not being overridden?", "author": "Craigacp", "createdAt": "2020-06-01T18:37:01Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DoubleDataBuffer.java", "diffHunk": "@@ -157,4 +157,9 @@ default DoubleDataBuffer narrow(long size) {\n \n   @Override\n   DoubleDataBuffer slice(long index, long size);\n+\n+  @Override\n+  default DataBufferWindow<DoubleDataBuffer> window(long size) {\n+    return null;", "originalCommit": "442d65d546db4704422e6f98c7b9c4172fecabef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU4MjUxNw==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r433582517", "bodyText": "Please check here\nI just implemented windows for raw buffers at the moment. At some point, they should have a window implementation but it is not mandatory.\nUnfortunately in Java, when you override the signature of a method in a super interface, you don\u2019t inherit anymore of its default implementation, so I had to return null explicitly in all subinterfaces.", "author": "karllessard", "createdAt": "2020-06-02T02:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxNjA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzU4NjIxNA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r433586214", "bodyText": "Ok, in which case the javadoc should probably note that the window method is optional on DataBuffer, similar to the remove methods on List. And maybe it should throw UnsupportedOperationException? It would be kinda ugly to have the method that uses it catch a RuntimeException though so maybe returning null is fine.", "author": "Craigacp", "createdAt": "2020-06-02T02:24:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxNjA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5OTk4Mg==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r434299982", "bodyText": "Yeah, I was hesitating between the two... but probably after this PR I'll add windows to all other buffer types as well, so it will really become an exception if it is not supported (e.g. if the user provides one of its own buffer implementation). So maybe the runtime exception is better than the null check, I'll change it.", "author": "karllessard", "createdAt": "2020-06-03T04:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxNjA4MA=="}], "type": "inlineReview"}, {"oid": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "url": "https://github.com/tensorflow/java/commit/9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "message": "Throw exception if buffer does not support windows", "committedDate": "2020-06-03T04:58:24Z", "type": "commit"}, {"oid": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "url": "https://github.com/tensorflow/java/commit/9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "message": "Throw exception if buffer does not support windows", "committedDate": "2020-06-03T04:58:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxNDQ2Nw==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436014467", "bodyText": "Can be \"slid\"? Seems like \"slide\" is the wrong tense. Maybe \"and can slide along\"?", "author": "Craigacp", "createdAt": "2020-06-05T15:57:08Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java", "diffHunk": "@@ -247,6 +247,38 @@\n    */\n   DataBuffer<T> slice(long index, long size);\n \n+  /**\n+   * Creates a {@link DataBufferWindow} that provides a partial view of this buffer.\n+   *\n+   * <p>The created window has a fixed size and can be {@link DataBufferWindow#slideTo(long) \"slide\"}", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDk4OQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436230989", "bodyText": "I've picked \"and can slide along\"", "author": "karllessard", "createdAt": "2020-06-06T02:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxNDQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxNDU1NQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436014555", "bodyText": "performances -> performance", "author": "Craigacp", "createdAt": "2020-06-05T15:57:18Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java", "diffHunk": "@@ -247,6 +247,38 @@\n    */\n   DataBuffer<T> slice(long index, long size);\n \n+  /**\n+   * Creates a {@link DataBufferWindow} that provides a partial view of this buffer.\n+   *\n+   * <p>The created window has a fixed size and can be {@link DataBufferWindow#slideTo(long) \"slide\"}\n+   * across this buffer at different offsets to provide different views of the data without allocating\n+   * a new buffer instance, like {@link #offset(long)} does. This improves overall performances when", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxNjU1Mg==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436016552", "bodyText": "\"for viewing part of a DataBuffer\"", "author": "Craigacp", "createdAt": "2020-06-05T16:00:48Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBufferWindow.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.tensorflow.tools.buffer;\n+\n+/**\n+ * A mutable container for viewing partially a {@link DataBuffer}.", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxNzA3MA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436017070", "bodyText": "Same tense issue as in DataBuffer.window().", "author": "Craigacp", "createdAt": "2020-06-05T16:01:40Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBufferWindow.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.tensorflow.tools.buffer;\n+\n+/**\n+ * A mutable container for viewing partially a {@link DataBuffer}.\n+ *\n+ * <p>Data buffer windows have a fixed size and can be {@link DataBufferWindow#slideTo(long) \"slide\"}", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxNzQ2OA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436017468", "bodyText": "performances -> performance.", "author": "Craigacp", "createdAt": "2020-06-05T16:02:25Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBufferWindow.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.tensorflow.tools.buffer;\n+\n+/**\n+ * A mutable container for viewing partially a {@link DataBuffer}.\n+ *\n+ * <p>Data buffer windows have a fixed size and can be {@link DataBufferWindow#slideTo(long) \"slide\"}\n+ * across a buffer at different offsets to provide different views of the data without allocating\n+ * a new buffer instance, like {@link #offset(long)} does. This improves overall performances when", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODk0NQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436018945", "bodyText": "Maybe slideAlong rather than slideOf?", "author": "Craigacp", "createdAt": "2020-06-05T16:05:04Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBufferWindow.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.tensorflow.tools.buffer;\n+\n+/**\n+ * A mutable container for viewing partially a {@link DataBuffer}.\n+ *\n+ * <p>Data buffer windows have a fixed size and can be {@link DataBufferWindow#slideTo(long) \"slide\"}\n+ * across a buffer at different offsets to provide different views of the data without allocating\n+ * a new buffer instance, like {@link #offset(long)} does. This improves overall performances when\n+ * this operation is repeated frequently. For example:\n+ *\n+ * <pre>{@code\n+ * IntDataBuffer bufferA = DataBuffers.ofInts(1024);\n+ * // ... init buffer data\n+ * IntDataBuffer bufferB = DataBuffers.ofInts(1, 2, 3, 4);\n+ *\n+ * // Return the index of the first occurrence of bufferB in bufferA using a sliding window\n+ * DataBufferWindow<IntDataBuffer> windowA = bufferA.window(4);\n+ * for (int i = 0; i < bufferA.size() - bufferB.size(); ++i) {\n+ *     if (windowA.slideTo(i).buffer().equals(bufferB)) {\n+ *         return i;\n+ *     }\n+ * }\n+ * }</pre>>\n+ *\n+ * <p>{@code DataBufferWindow} instances are stateful and not thread-safe.\n+ *\n+ * @param <B> the type of buffer being viewed\n+ */\n+public interface DataBufferWindow<B extends DataBuffer<?>> {\n+\n+  /**\n+   * Returns the current offset of this window in the underlying buffer.\n+   */\n+  long offset();\n+\n+  /**\n+   * Returns the size of this buffer window.\n+   */\n+  long size();\n+\n+  /**\n+   * Moves the window at the given position in the underlying buffer.\n+   *\n+   * <p>The size of the window remains the same and its offset is reset to {@code index}, so that\n+   * accessing the value of {@link #buffer()} at index {@code x} will return the value at\n+   * {@code index + x} in the underlying buffer.\n+   *\n+   * @param index new offset for this window\n+   * @return this instance\n+   * @throws IndexOutOfBoundsException if index is beyond the underlying buffer limits\n+   */\n+  DataBufferWindow<B> slideTo(long index);\n+\n+  /**\n+   * Moves the window of {@code step} elements in the underlying buffer.\n+   *\n+   * <p>The size of the window remains the same and its offset is reset to {@code offset() + step}.\n+   * If {@code step} is positive, then the window will slide forward. If it is negative, it will\n+   * slide backward.\n+   *\n+   * @param step value to add to the current offset of this window\n+   * @return this instance\n+   * @throws IndexOutOfBoundsException if the resulting offset goes beyond the underlying buffer limits\n+   */\n+  DataBufferWindow<B> slideOf(long step);", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTAzMQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436231031", "bodyText": "...or just slide", "author": "karllessard", "createdAt": "2020-06-06T02:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxODk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxOTUxNA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436019514", "bodyText": "\"offset is set to\". I feel reset is a bit strange here, as it's not reverting to a particular value.", "author": "Craigacp", "createdAt": "2020-06-05T16:06:03Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBufferWindow.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.tensorflow.tools.buffer;\n+\n+/**\n+ * A mutable container for viewing partially a {@link DataBuffer}.\n+ *\n+ * <p>Data buffer windows have a fixed size and can be {@link DataBufferWindow#slideTo(long) \"slide\"}\n+ * across a buffer at different offsets to provide different views of the data without allocating\n+ * a new buffer instance, like {@link #offset(long)} does. This improves overall performances when\n+ * this operation is repeated frequently. For example:\n+ *\n+ * <pre>{@code\n+ * IntDataBuffer bufferA = DataBuffers.ofInts(1024);\n+ * // ... init buffer data\n+ * IntDataBuffer bufferB = DataBuffers.ofInts(1, 2, 3, 4);\n+ *\n+ * // Return the index of the first occurrence of bufferB in bufferA using a sliding window\n+ * DataBufferWindow<IntDataBuffer> windowA = bufferA.window(4);\n+ * for (int i = 0; i < bufferA.size() - bufferB.size(); ++i) {\n+ *     if (windowA.slideTo(i).buffer().equals(bufferB)) {\n+ *         return i;\n+ *     }\n+ * }\n+ * }</pre>>\n+ *\n+ * <p>{@code DataBufferWindow} instances are stateful and not thread-safe.\n+ *\n+ * @param <B> the type of buffer being viewed\n+ */\n+public interface DataBufferWindow<B extends DataBuffer<?>> {\n+\n+  /**\n+   * Returns the current offset of this window in the underlying buffer.\n+   */\n+  long offset();\n+\n+  /**\n+   * Returns the size of this buffer window.\n+   */\n+  long size();\n+\n+  /**\n+   * Moves the window at the given position in the underlying buffer.\n+   *\n+   * <p>The size of the window remains the same and its offset is reset to {@code index}, so that", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyMDA3NA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436020074", "bodyText": "Presumably it throws IOOBE if any portion of the window is outside the underlying buffer? If so this language should be tightened up, and if it doesn't then I'm a little confused. Ditto for the throws clause on slideTo.", "author": "Craigacp", "createdAt": "2020-06-05T16:07:08Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBufferWindow.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.tensorflow.tools.buffer;\n+\n+/**\n+ * A mutable container for viewing partially a {@link DataBuffer}.\n+ *\n+ * <p>Data buffer windows have a fixed size and can be {@link DataBufferWindow#slideTo(long) \"slide\"}\n+ * across a buffer at different offsets to provide different views of the data without allocating\n+ * a new buffer instance, like {@link #offset(long)} does. This improves overall performances when\n+ * this operation is repeated frequently. For example:\n+ *\n+ * <pre>{@code\n+ * IntDataBuffer bufferA = DataBuffers.ofInts(1024);\n+ * // ... init buffer data\n+ * IntDataBuffer bufferB = DataBuffers.ofInts(1, 2, 3, 4);\n+ *\n+ * // Return the index of the first occurrence of bufferB in bufferA using a sliding window\n+ * DataBufferWindow<IntDataBuffer> windowA = bufferA.window(4);\n+ * for (int i = 0; i < bufferA.size() - bufferB.size(); ++i) {\n+ *     if (windowA.slideTo(i).buffer().equals(bufferB)) {\n+ *         return i;\n+ *     }\n+ * }\n+ * }</pre>>\n+ *\n+ * <p>{@code DataBufferWindow} instances are stateful and not thread-safe.\n+ *\n+ * @param <B> the type of buffer being viewed\n+ */\n+public interface DataBufferWindow<B extends DataBuffer<?>> {\n+\n+  /**\n+   * Returns the current offset of this window in the underlying buffer.\n+   */\n+  long offset();\n+\n+  /**\n+   * Returns the size of this buffer window.\n+   */\n+  long size();\n+\n+  /**\n+   * Moves the window at the given position in the underlying buffer.\n+   *\n+   * <p>The size of the window remains the same and its offset is reset to {@code index}, so that\n+   * accessing the value of {@link #buffer()} at index {@code x} will return the value at\n+   * {@code index + x} in the underlying buffer.\n+   *\n+   * @param index new offset for this window\n+   * @return this instance\n+   * @throws IndexOutOfBoundsException if index is beyond the underlying buffer limits\n+   */\n+  DataBufferWindow<B> slideTo(long index);\n+\n+  /**\n+   * Moves the window of {@code step} elements in the underlying buffer.\n+   *\n+   * <p>The size of the window remains the same and its offset is reset to {@code offset() + step}.\n+   * If {@code step} is positive, then the window will slide forward. If it is negative, it will\n+   * slide backward.\n+   *\n+   * @param step value to add to the current offset of this window\n+   * @return this instance\n+   * @throws IndexOutOfBoundsException if the resulting offset goes beyond the underlying buffer limits", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTM3OQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436231379", "bodyText": "\"@throws IndexOutOfBoundsException if the window cannot be slid because it goes beyond buffer limits\"", "author": "karllessard", "createdAt": "2020-06-06T02:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAyMDA3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzMDk2OQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436030969", "bodyText": "Is it always the underlying buffer? If so can we just say that?", "author": "Craigacp", "createdAt": "2020-06-05T16:27:24Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBufferWindow.java", "diffHunk": "@@ -0,0 +1,90 @@\n+package org.tensorflow.tools.buffer;\n+\n+/**\n+ * A mutable container for viewing partially a {@link DataBuffer}.\n+ *\n+ * <p>Data buffer windows have a fixed size and can be {@link DataBufferWindow#slideTo(long) \"slide\"}\n+ * across a buffer at different offsets to provide different views of the data without allocating\n+ * a new buffer instance, like {@link #offset(long)} does. This improves overall performances when\n+ * this operation is repeated frequently. For example:\n+ *\n+ * <pre>{@code\n+ * IntDataBuffer bufferA = DataBuffers.ofInts(1024);\n+ * // ... init buffer data\n+ * IntDataBuffer bufferB = DataBuffers.ofInts(1, 2, 3, 4);\n+ *\n+ * // Return the index of the first occurrence of bufferB in bufferA using a sliding window\n+ * DataBufferWindow<IntDataBuffer> windowA = bufferA.window(4);\n+ * for (int i = 0; i < bufferA.size() - bufferB.size(); ++i) {\n+ *     if (windowA.slideTo(i).buffer().equals(bufferB)) {\n+ *         return i;\n+ *     }\n+ * }\n+ * }</pre>>\n+ *\n+ * <p>{@code DataBufferWindow} instances are stateful and not thread-safe.\n+ *\n+ * @param <B> the type of buffer being viewed\n+ */\n+public interface DataBufferWindow<B extends DataBuffer<?>> {\n+\n+  /**\n+   * Returns the current offset of this window in the underlying buffer.\n+   */\n+  long offset();\n+\n+  /**\n+   * Returns the size of this buffer window.\n+   */\n+  long size();\n+\n+  /**\n+   * Moves the window at the given position in the underlying buffer.\n+   *\n+   * <p>The size of the window remains the same and its offset is reset to {@code index}, so that\n+   * accessing the value of {@link #buffer()} at index {@code x} will return the value at\n+   * {@code index + x} in the underlying buffer.\n+   *\n+   * @param index new offset for this window\n+   * @return this instance\n+   * @throws IndexOutOfBoundsException if index is beyond the underlying buffer limits\n+   */\n+  DataBufferWindow<B> slideTo(long index);\n+\n+  /**\n+   * Moves the window of {@code step} elements in the underlying buffer.\n+   *\n+   * <p>The size of the window remains the same and its offset is reset to {@code offset() + step}.\n+   * If {@code step} is positive, then the window will slide forward. If it is negative, it will\n+   * slide backward.\n+   *\n+   * @param step value to add to the current offset of this window\n+   * @return this instance\n+   * @throws IndexOutOfBoundsException if the resulting offset goes beyond the underlying buffer limits\n+   */\n+  DataBufferWindow<B> slideOf(long step);\n+\n+  /**\n+   * Returns a buffer presenting the data currently viewed by this window.", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTc3OQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436231779", "bodyText": "No, this is the \"window buffer\", which is mutable and just shows a portion of the \"underlying buffer\". The \"underlying buffer\" is the buffer on which .window(size) has been invoked.\nI'm not a fan of all this terminology neither, so if you have better suggestions...", "author": "karllessard", "createdAt": "2020-06-06T03:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzMDk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NjM3Mg==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436286372", "bodyText": "Maybe \"Returns the buffer backing this window. Each window instance has it's own buffer providing a view onto the original DataBuffer. The buffers are mutated when the window slides to different offsets.\" Or something along those lines? I like the notion of \"backing\" as I feel that's a fairly common usage for this kind of operation.", "author": "Craigacp", "createdAt": "2020-06-06T17:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzMDk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjczNDYxMg==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436734612", "bodyText": "I replaced all occurrences of \"underlying buffer\" to \"original buffer\" in this file, I think it is a better fit.", "author": "karllessard", "createdAt": "2020-06-08T14:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAzMDk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNzM2Mw==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436107363", "bodyText": "performances -> performance", "author": "Craigacp", "createdAt": "2020-06-05T18:55:43Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/NdArraySequence.java", "diffHunk": "@@ -35,4 +42,27 @@\n    * @param consumer method to invoke for each elements\n    */\n   void forEachIndexed(BiConsumer<long[], T> consumer);\n+\n+  /**\n+   * Returns each element as a new slice.\n+   *\n+   * <p>Unlike conventional Java collections, elements of a {@code NdArraySequence} are transient, i.e. new {@code NdArray}\n+   * instances are allocated for each iteration. To improve performances, the same instance can be recycled to view", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwNzkwMA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436107900", "bodyText": "\"disable such optimizations to ensure that each element returned\"", "author": "Craigacp", "createdAt": "2020-06-05T18:56:53Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/NdArraySequence.java", "diffHunk": "@@ -35,4 +42,27 @@\n    * @param consumer method to invoke for each elements\n    */\n   void forEachIndexed(BiConsumer<long[], T> consumer);\n+\n+  /**\n+   * Returns each element as a new slice.\n+   *\n+   * <p>Unlike conventional Java collections, elements of a {@code NdArraySequence} are transient, i.e. new {@code NdArray}\n+   * instances are allocated for each iteration. To improve performances, the same instance can be recycled to view\n+   * all elements of this sequence, using a {@link org.tensorflow.tools.buffer.DataBufferWindow}.\n+   *\n+   * <p>In some cases though, it might be preferable to disable such optimization to ensure that each elements returned is a", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwODUxMQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436108511", "bodyText": "Should we emit a logger message at FINE saying it fell back to the slow path?", "author": "Craigacp", "createdAt": "2020-06-05T18:58:14Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/dense/AbstractDenseNdArray.java", "diffHunk": "@@ -17,16 +17,40 @@\n package org.tensorflow.tools.ndarray.impl.dense;\n \n import org.tensorflow.tools.buffer.DataBuffer;\n-import org.tensorflow.tools.ndarray.IllegalRankException;\n+import org.tensorflow.tools.buffer.DataBufferWindow;\n import org.tensorflow.tools.ndarray.NdArray;\n+import org.tensorflow.tools.ndarray.NdArraySequence;\n import org.tensorflow.tools.ndarray.impl.AbstractNdArray;\n import org.tensorflow.tools.ndarray.impl.dimension.DimensionalSpace;\n import org.tensorflow.tools.ndarray.impl.dimension.RelativeDimensionalSpace;\n+import org.tensorflow.tools.ndarray.impl.sequence.SlicingElementSequence;\n+import org.tensorflow.tools.ndarray.impl.sequence.SingleElementSequence;\n+import org.tensorflow.tools.ndarray.impl.sequence.FastElementSequence;\n import org.tensorflow.tools.ndarray.index.Index;\n \n @SuppressWarnings(\"unchecked\")\n public abstract class AbstractDenseNdArray<T, U extends NdArray<T>> extends AbstractNdArray<T, U> {\n \n+  @Override\n+  public NdArraySequence<U> elements(int dimensionIdx) {\n+    if (dimensionIdx >= shape().numDimensions()) {\n+      throw new IllegalArgumentException(\"Cannot iterate elements in dimension '\" + dimensionIdx +\n+          \"' of array with shape \" + shape());\n+    }\n+    if (rank() == 0 && dimensionIdx < 0) {\n+      return new SingleElementSequence<>(this);\n+    }\n+    DimensionalSpace elemDims = dimensions().from(dimensionIdx + 1);\n+    try {\n+      DataBufferWindow<? extends DataBuffer<T>> elemWindow = buffer().window(elemDims.physicalSize());\n+      U element = instantiate(elemWindow.buffer(), elemDims);\n+      return new FastElementSequence(this, dimensionIdx, element, elemWindow);\n+    } catch (UnsupportedOperationException e) {\n+      // If buffer windows are not supported, fallback to slicing (and slower) sequence", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMjE2Mg==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436232162", "bodyText": "I thought of it too but the funny part is that we don't have any log yet in TF Java! So adding this one comes up with picking the right strategy to output logs from our library, which can be a story in itself.", "author": "karllessard", "createdAt": "2020-06-06T03:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwODUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwODg2NA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436108864", "bodyText": "What's the extra type variable for?", "author": "Craigacp", "createdAt": "2020-06-05T18:59:02Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/dense/AbstractDenseNdArray.java", "diffHunk": "@@ -112,21 +136,16 @@ protected AbstractDenseNdArray(DimensionalSpace dimensions) {\n     super(dimensions);\n   }\n \n-  abstract protected DataBuffer<T> buffer();\n+  abstract protected <P> DataBuffer<T> buffer();", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMjIwNw==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436232207", "bodyText": "ouf, left over", "author": "karllessard", "createdAt": "2020-06-06T03:10:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwODg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwOTI2Ng==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436109266", "bodyText": "Class level javadoc?", "author": "Craigacp", "createdAt": "2020-06-05T18:59:53Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/sequence/FastElementSequence.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ *  Copyright 2019 The TensorFlow Authors. All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  =======================================================================\n+ */\n+\n+package org.tensorflow.tools.ndarray.impl.sequence;\n+\n+import java.util.Iterator;\n+import java.util.function.BiConsumer;\n+\n+import org.tensorflow.tools.buffer.DataBufferWindow;\n+import org.tensorflow.tools.ndarray.NdArray;\n+import org.tensorflow.tools.ndarray.NdArraySequence;\n+import org.tensorflow.tools.ndarray.impl.AbstractNdArray;\n+\n+public final class FastElementSequence<T, U extends NdArray<T>> implements NdArraySequence<U> {", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMjQwNA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436232404", "bodyText": "This is an internal class (under impl package) and a lot of them are not documented. I can add something for this one now but probably it would be worth adding doc to all other internal classes as well.", "author": "karllessard", "createdAt": "2020-06-06T03:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwOTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEwOTM2Ng==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436109366", "bodyText": "Copyright year 2020?", "author": "Craigacp", "createdAt": "2020-06-05T19:00:06Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/sequence/FastElementSequence.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ *  Copyright 2019 The TensorFlow Authors. All Rights Reserved.", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMTA4NA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436111084", "bodyText": "Class level javadoc, now it's public? Or is this something we'd exclude using modules if we were on Java 9?", "author": "Craigacp", "createdAt": "2020-06-05T19:03:55Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/sequence/SingleElementSequence.java", "diffHunk": "@@ -24,7 +24,11 @@\n import org.tensorflow.tools.ndarray.NdArraySequence;\n import org.tensorflow.tools.ndarray.impl.AbstractNdArray;\n \n-class SingleElementSequence<T, U extends NdArray<T>> implements NdArraySequence<U> {\n+public final class SingleElementSequence<T, U extends NdArray<T>> implements NdArraySequence<U> {", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMjc1Ng==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436232756", "bodyText": "yes that would be something we would exclude in Java 9, pretty much everything under impl in fact should be limited to internal usage only. Still, some javadoc wouldn't hurt.", "author": "karllessard", "createdAt": "2020-06-06T03:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMTA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjk5MQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436112991", "bodyText": "Do we still need to suppress warnings here? It looks like it's all properly typed?", "author": "Craigacp", "createdAt": "2020-06-05T19:08:15Z", "path": "tensorflow-tools/src/test/java/org/tensorflow/tools/ndarray/impl/sequence/ElementSequenceTest.java", "diffHunk": "@@ -37,8 +41,7 @@ public void iterateVectorsWithIndex() {\n     IntNdArray array = NdArrays.ofInts(Shape.of(2, 3, 2));\n \n     @SuppressWarnings(\"unchecked\")\n-    NdArraySequence<IntNdArray> sequence = ElementSequence\n-        .create((AbstractNdArray<Integer, IntNdArray>)array, 1);\n+    NdArraySequence<IntNdArray> sequence = new SlicingElementSequence((AbstractNdArray<Integer, IntNdArray>)array, 1);", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMjgzOA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436232838", "bodyText": "good catch!", "author": "karllessard", "createdAt": "2020-06-06T03:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMjk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMzA4NQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436113085", "bodyText": "SuppressWarnings?", "author": "Craigacp", "createdAt": "2020-06-05T19:08:29Z", "path": "tensorflow-tools/src/test/java/org/tensorflow/tools/ndarray/impl/sequence/ElementSequenceTest.java", "diffHunk": "@@ -56,7 +59,7 @@ public void iterateScalarsWithIndex() {\n     IntNdArray array = NdArrays.ofInts(Shape.of(2, 3, 2));\n \n     @SuppressWarnings(\"unchecked\")\n-    NdArraySequence<IntNdArray> cursor = ElementSequence.create((AbstractNdArray<Integer, IntNdArray>)array, 2);\n+    NdArraySequence<IntNdArray> cursor = new SlicingElementSequence((AbstractNdArray<Integer, IntNdArray>)array, 2);", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMzM3Mg==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436113372", "bodyText": "SuppressWarnings?", "author": "Craigacp", "createdAt": "2020-06-05T19:09:12Z", "path": "tensorflow-tools/src/test/java/org/tensorflow/tools/ndarray/impl/sequence/ElementSequenceTest.java", "diffHunk": "@@ -74,4 +77,71 @@ public void iterateScalarsWithIndex() {\n     assertArrayEquals(new long[] {1, 2, 0}, coords.get(10));\n     assertArrayEquals(new long[] {1, 2, 1}, coords.get(11));\n   }\n+\n+  @Test\n+  public void slicingElementSequenceReturnsUniqueInstances() {\n+    IntNdArray array = NdArrays.ofInts(Shape.of(2, 3, 2));\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMzQzOQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436113439", "bodyText": "SuppressWarnings?", "author": "Craigacp", "createdAt": "2020-06-05T19:09:21Z", "path": "tensorflow-tools/src/test/java/org/tensorflow/tools/ndarray/impl/sequence/ElementSequenceTest.java", "diffHunk": "@@ -74,4 +77,71 @@ public void iterateScalarsWithIndex() {\n     assertArrayEquals(new long[] {1, 2, 0}, coords.get(10));\n     assertArrayEquals(new long[] {1, 2, 1}, coords.get(11));\n   }\n+\n+  @Test\n+  public void slicingElementSequenceReturnsUniqueInstances() {\n+    IntNdArray array = NdArrays.ofInts(Shape.of(2, 3, 2));\n+    @SuppressWarnings(\"unchecked\")\n+    NdArraySequence<IntNdArray> sequence = new SlicingElementSequence(\n+        (AbstractNdArray<Integer, IntNdArray>) array, 1);\n+    List<IntNdArray> elements = new ArrayList<>();\n+    sequence.forEach(e -> {\n+      elements.forEach(tmp -> {\n+        if (tmp == e) {\n+          fail();\n+        }\n+      });\n+      elements.add(e);\n+    });\n+  }\n+\n+  @Test\n+  public void fastElementSequenceReturnsSameInstance() {\n+    IntNdArray array = NdArrays.ofInts(Shape.of(2, 3, 2));\n+    IntNdArray element = array.get(0);\n+    @SuppressWarnings(\"unchecked\")", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNjQxOA==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436116418", "bodyText": "This is the crucial change right? Making this class no longer completely immutable so it can walk down an allocated block of memory.", "author": "Craigacp", "createdAt": "2020-06-05T19:16:20Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/raw/UnsafeMemoryHandle.java", "diffHunk": "@@ -138,39 +142,47 @@ int arrayOffset(Class<?> arrayClass) {\n   }\n \n   ByteBuffer toArrayByteBuffer() {\n-    return ByteBuffer.wrap((byte[])object, (int)byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(byte[].class), (int)size());\n+    return ByteBuffer.wrap((byte[])object, (int) byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(byte[].class), (int)size);\n   }\n \n   ShortBuffer toArrayShortBuffer() {\n-    return ShortBuffer.wrap((short[])object, (int)((byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(short[].class)) / scale), (int)size());\n+    return ShortBuffer.wrap((short[])object, (int)((byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(short[].class)) / scale), (int)size);\n   }\n \n   IntBuffer toArrayIntBuffer() {\n-    return IntBuffer.wrap((int[])object, (int)((byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(int[].class)) / scale), (int)size());\n+    return IntBuffer.wrap((int[])object, (int)((byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(int[].class)) / scale), (int)size);\n   }\n \n   LongBuffer toArrayLongBuffer() {\n-    return LongBuffer.wrap((long[])object, (int)((byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(long[].class)) / scale), (int)size());\n+    return LongBuffer.wrap((long[])object, (int)((byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(long[].class)) / scale), (int)size);\n   }\n \n   FloatBuffer toArrayFloatBuffer() {\n-    return FloatBuffer.wrap((float[])object, (int)((byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(float[].class)) / scale), (int)size());\n+    return FloatBuffer.wrap((float[])object, (int)((byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(float[].class)) / scale), (int)size);\n   }\n \n   DoubleBuffer toArrayDoubleBuffer() {\n-    return DoubleBuffer.wrap((double[])object, (int)((byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(double[].class)) / scale), (int)size());\n+    return DoubleBuffer.wrap((double[])object, (int)((byteOffset - UnsafeReference.UNSAFE.arrayBaseOffset(double[].class)) / scale), (int)size);\n   }\n \n   final Object object;\n-  final long byteOffset;\n+  final long baseOffset;\n+  long byteOffset;", "originalCommit": "9ffa5b02709427ff50d1ed35d965ac685ffc14cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMjk5OQ==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436232999", "bodyText": "It is a crucial change... but the whole point of this PR is to have somewhere a mutable object that can be recycled. Note that this class is package-scoped, so nothing outside this internal package can change the value of it other that the endpoints we expose (which is window.slide() in this case).\nStill, do you think that might be worth having two version of this object, one mutable and one not?", "author": "karllessard", "createdAt": "2020-06-06T03:22:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNjQxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDYyNw==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436284627", "bodyText": "It's fine as is, I was just checking that I'd understood the PR properly. I don't think it will make too much difference performance wise having a mutable field, unless it's on a JVM with more aggressive escape analysis like Graal (where it might be able to elide the allocation, but it might be able to do that for the mutable version too).", "author": "Craigacp", "createdAt": "2020-06-06T17:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNjQxOA=="}], "type": "inlineReview"}, {"oid": "023eaeaf7c2fc691037c560e91cbb116acaee899", "url": "https://github.com/tensorflow/java/commit/023eaeaf7c2fc691037c560e91cbb116acaee899", "message": "Improve javadoc", "committedDate": "2020-06-06T03:34:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDQ0Mg==", "url": "https://github.com/tensorflow/java/pull/63#discussion_r436284442", "bodyText": "\"for viewing\"", "author": "Craigacp", "createdAt": "2020-06-06T17:07:35Z", "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBufferWindow.java", "diffHunk": "@@ -1,12 +1,12 @@\n package org.tensorflow.tools.buffer;\n \n /**\n- * A mutable container for viewing partially a {@link DataBuffer}.\n+ * A mutable container for view part of a {@link DataBuffer}.", "originalCommit": "023eaeaf7c2fc691037c560e91cbb116acaee899", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "08e13247da8f6489a0150bbb1590a7a9863974b0", "url": "https://github.com/tensorflow/java/commit/08e13247da8f6489a0150bbb1590a7a9863974b0", "message": "More javadoc fixes", "committedDate": "2020-06-08T14:06:53Z", "type": "commit"}]}