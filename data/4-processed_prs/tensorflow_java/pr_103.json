{"pr_number": 103, "pr_title": "Save models as functions", "pr_createdAt": "2020-08-24T15:47:08Z", "pr_url": "https://github.com/tensorflow/java/pull/103", "timeline": [{"oid": "bcd533f6ff5f48027d5975e75b479a80c92ff0eb", "url": "https://github.com/tensorflow/java/commit/bcd533f6ff5f48027d5975e75b479a80c92ff0eb", "message": "Draft: Java API to use tf.function available on SavedModel. (#89)\n\nPython models that contain tf.function is inconvenient to be consumed by Java clients.\r\nThis proposal provides an API to\r\n(a) Invoke a tf.function, given the signature name\r\n(b) Retrieve the node name in the graph corresponding to a tf.function\r\n\r\nCo-authored-by: Shajan Dasan <sdasan@twitter.com>", "committedDate": "2020-08-05T00:50:10Z", "type": "commit"}, {"oid": "0dbdd3ea83216e58fdf7ecf8dcabe8d7f9e60370", "url": "https://github.com/tensorflow/java/commit/0dbdd3ea83216e58fdf7ecf8dcabe8d7f9e60370", "message": "tmp", "committedDate": "2020-08-06T03:38:04Z", "type": "commit"}, {"oid": "5f17f385908cb165e8743c8f4193144153c195d0", "url": "https://github.com/tensorflow/java/commit/5f17f385908cb165e8743c8f4193144153c195d0", "message": "Merge branch 'saved_model_2' into shared-saved-model\n\n# Conflicts:\n#\ttensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java\n#\ttensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "committedDate": "2020-08-24T01:49:38Z", "type": "commit"}, {"oid": "b311e27b71ca70c11c0e4eb8b75b3d4a462b2258", "url": "https://github.com/tensorflow/java/commit/b311e27b71ca70c11c0e4eb8b75b3d4a462b2258", "message": "Create function objects as callable graphs", "committedDate": "2020-08-24T05:10:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcyNjk3NA==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475726974", "bodyText": "Suggestion: Rename GRAPH to GRAPH_AND_SESSION", "author": "Shajan", "createdAt": "2020-08-24T16:08:21Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/FunctionGraph.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.math.Sign;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * FunctionGraph myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class FunctionGraph implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (FunctionGraph function = FunctionGraph.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static FunctionGraph create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new FunctionGraph(signature, graph, new Session(graph), Ownership.GRAPH);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (FunctionGraph f = FunctionGraph.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static FunctionGraph create(Signature signature, Graph graph) {\n+    return new FunctionGraph(signature, graph, new Session(graph), Ownership.SESSION);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (FunctionGraph f = FunctionGraph.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static FunctionGraph create(Signature signature, Session session) {\n+    return new FunctionGraph(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();\n+    outputToNode.values().forEach(t -> runner.fetch(t.getName()));\n+\n+    List<Tensor<?>> resultTensors = runner.run();\n+    try {\n+      ListIterator<Tensor<?>> resultTensorIter = resultTensors.listIterator();\n+      Map<String, Tensor<?>> returnMap = new HashMap<String, Tensor<?>>();\n+\n+      // Use the output names as present in the signature definition\n+      for (String nodeName: outputToNode.keySet()) {\n+        returnMap.put(nodeName, resultTensorIter.next());\n+      }\n+      return returnMap;\n+\n+    } catch (Exception e) {\n+      // Release tensors before throwing exception\n+      for (Tensor<?> t : resultTensors) {\n+        t.close();\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Invokes a function with a single input and output.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   * @throws IllegalArgumentException if there are multiple input or output parameters defined\n+   *                                  in the function\n+   */\n+  public Tensor<?> call(Tensor<?> tensor) throws IllegalArgumentException {\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+\n+    if (signatureDef.getInputsCount() != 1) {\n+      throw new IllegalArgumentException(\n+        String.format(\"Function [%s] requires multiple inputs\", signatureDef.getMethodName()));\n+    }\n+    String inputNodeName = signatureDef.getInputsMap().values().iterator().next().getName();\n+\n+    if (signatureDef.getOutputsCount() != 1) {\n+      throw new IllegalArgumentException(\n+        String.format(\"Function [%s] has multiple outputs\", signatureDef.getMethodName()));\n+    }\n+    String outputNodeName = signatureDef.getOutputsMap().values().iterator().next().getName();\n+\n+    return session.runner().feed(inputNodeName, tensor).fetch(outputNodeName).run().get(0);\n+  }\n+\n+  /**\n+   * Returns the session used to execute the graph when calling this function\n+   *\n+   * <p>In general, a user does not need to handle directly the session of a function and rely\n+   * on {@link #call(Map)} to execute the graph instead. But in some cases, direct access to\n+   * the session might be necessary, as it presents more running options.\n+   *\n+   * @return the function session\n+   */\n+  public Session session() {\n+    return session;\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (ownership != Ownership.NONE) {\n+      session.close();\n+      if (ownership == Ownership.GRAPH) {\n+        graph.close();\n+      }\n+    }\n+  }\n+\n+  private enum Ownership {\n+    GRAPH, SESSION, NONE;", "originalCommit": "45cb250de1722c7f4837a9d171844060785498c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcyNjk0Nw==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475726947", "bodyText": "Maybe FunctionSession as it's a specialised session? That way it conceptually lives next to EagerSession and  Session, rather than next to Graph. I feel like this is much closer to a session than a graph.", "author": "Craigacp", "createdAt": "2020-08-24T16:08:18Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/FunctionGraph.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.math.Sign;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * FunctionGraph myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class FunctionGraph implements AutoCloseable {", "originalCommit": "45cb250de1722c7f4837a9d171844060785498c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2MjI0OQ==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r476162249", "bodyText": "Right now, it is true that all functions loaded from a saved model share the same graph and are just used to execute it with a given signature (therefore they are acting more as a session). Nonetheless, I still have a preference to preserve the FunctionGraph naming.\nIf we ignore the saving part (which is limited due to the actual state of the C API), conceptually these functions also allow you to build your graphs, replacing the need of allocating explicitly a Graph instance, e.g.\npublic class MyModel {\n\n  // Function graph #1\n  private static Signature addTwo(Ops tf) {\n    Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n    Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n    return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n  }\n\n  // Function graph #2\n  private static Signature minusTwo(Ops tf) {\n    Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n    Add<TFloat32> output = tf.math.sub(input, tf.constant(2.0f));\n    return Signature.builder(\"subTwo\").input(\"x\", input).output(\"y\", output).build();\n  }\n\n  public static void main(String args[]) {\n    try (FunctionGraph f1 = FunctionGraph.create(MyModel::addTwo);\n         FunctionGraph f2 = FunctionGraph.create(MyModel::minusTwo);\n         Tensor<TFloat32> x = TFloat32.scalarOf(3.0f)) {\n        assertEquals(3.0f, f2.call(f1.call(x)).expect(TFloat32.DTYPE).data().getFloat());\n    }\n  }\n}\nEach function has its own graph and therefore if very coupled with that concept (where EagerSession has no graph at all). They will also appear as separate graphs when exporting them into a saved model the same way Python does it (in fact, Python saves each function as one or more \"objects\", which are then linked to their distinct graph in the function library).", "author": "karllessard", "createdAt": "2020-08-25T04:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcyNjk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ0NzYxNg==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r476447616", "bodyText": "Another idea would be to call this class a ConcreteFunction. Concrete functions and functions are two very similar but distinct concepts in TF Python. The former is a typed realization of a function graph while the latter is its polymorphic version, only acting as a facade (e.g. a function is eventually composed of multiple concrete functions, one for each type of operands the function has been called with).\nIn our scenario here, the function graphs are strongly typed and refer to a single graph, therefore more behave like a concrete function in the Python paradigm and it would make sense to name them after it.\nWe can probably support polymorphic functions too in the future, where we pass the type of the input tensors in parameter to the function builder. So we will still need to find a proper name for this concept, which will probably result in class encapsulating one or more ConcreteFunction. Maybe simply PolymorphicFunction?", "author": "karllessard", "createdAt": "2020-08-25T13:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcyNjk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYzNjcyNg==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r476636726", "bodyText": "My preference for a non-graph name is that Graphs aren't executable, and are missing necessary state because the Variables live in the Session. So FunctionGraph is more like a Session because it contains all the necessary bits to execute. However I'm also fine with the ConcreteFunction name as that's just a new concept that people have to learn.", "author": "Craigacp", "createdAt": "2020-08-25T17:58:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcyNjk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMDUxMg==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475730512", "bodyText": "saverDef needs to be declared volatile for this to work - http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html", "author": "Craigacp", "createdAt": "2020-08-24T16:14:01Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Graph.java", "diffHunk": "@@ -287,6 +301,17 @@ public synchronized void addInitializer(Op initializer) {\n     return addGradients(null, new Output<?>[] {y}, x, null);\n   }\n \n+  public SaverDef saverDef() {\n+    if (saverDef == null) {\n+      synchronized (this) {\n+        if (saverDef == null) {\n+          saverDef = addVariableSaver(this);", "originalCommit": "45cb250de1722c7f4837a9d171844060785498c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMDc3OQ==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475730779", "bodyText": "Or we make the whole method synchronized, which also seems fine as it's unlikely to be heavily contended.", "author": "Craigacp", "createdAt": "2020-08-24T16:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMDUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMzMwNQ==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475733305", "bodyText": "Should we add a helper that takes an exportDir, a FunctionGraph and then performs all the necessary operations? Seems like there are a bunch of hoops to jump through if you just want to save a single FunctionGraph.", "author": "Craigacp", "createdAt": "2020-08-24T16:18:32Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -224,6 +240,18 @@ public static Loader loader(String exportDir) {\n     return new Loader(exportDir);\n   }\n \n+  /**\n+   * Export a saved model.\n+   *\n+   * <p/>Returns a <code>Exporter</code> object for setting configuration options before actually\n+   * saving the model.\n+   *\n+   * @param exportDir the directory path containing a saved model.\n+   */\n+  public static Exporter exporter(String exportDir) {", "originalCommit": "45cb250de1722c7f4837a9d171844060785498c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE2NjIyNQ==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r476166225", "bodyText": "I guess we could, what about making that endpoint available at the function level? Something like function.save(exportDir)", "author": "karllessard", "createdAt": "2020-08-25T04:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMzMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYzNzE2NQ==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r476637165", "bodyText": "I like that.", "author": "Craigacp", "createdAt": "2020-08-25T17:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMzMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczNDcyNw==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475734727", "bodyText": "Wrong import.", "author": "Craigacp", "createdAt": "2020-08-24T16:20:56Z", "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/SavedModelBundleTest.java", "diffHunk": "@@ -15,20 +15,38 @@\n \n package org.tensorflow;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.junit.jupiter.api.Assertions.fail;\n \n+import java.io.IOException;\n import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.nio.file.Paths;\n+import jdk.nashorn.internal.codegen.FunctionSignature;", "originalCommit": "45cb250de1722c7f4837a9d171844060785498c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "175d9e6676d360efc4832d51d96a75b8d7c09b7f", "url": "https://github.com/tensorflow/java/commit/175d9e6676d360efc4832d51d96a75b8d7c09b7f", "message": "Make FunctionGraph auto-closeable", "committedDate": "2020-08-24T22:38:46Z", "type": "commit"}, {"oid": "175d9e6676d360efc4832d51d96a75b8d7c09b7f", "url": "https://github.com/tensorflow/java/commit/175d9e6676d360efc4832d51d96a75b8d7c09b7f", "message": "Make FunctionGraph auto-closeable", "committedDate": "2020-08-24T22:38:46Z", "type": "forcePushed"}, {"oid": "99a74503f7a97e4615f754b916b9d7fe95add1dc", "url": "https://github.com/tensorflow/java/commit/99a74503f7a97e4615f754b916b9d7fe95add1dc", "message": "Rename `FunctionGraph` to `ConcreteFunction`", "committedDate": "2020-08-27T16:07:21Z", "type": "commit"}, {"oid": "1383a38006bf2ebbc08146bc76881db6f66d9860", "url": "https://github.com/tensorflow/java/commit/1383a38006bf2ebbc08146bc76881db6f66d9860", "message": "Add more unit tests", "committedDate": "2020-08-28T01:57:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIyNzA2Nw==", "url": "https://github.com/tensorflow/java/pull/103#discussion_r479227067", "bodyText": "Minor feature request: adding a toString() function to this ConcreteFunction class that prints a readable text representation of the signature would be really useful.", "author": "yzhuang", "createdAt": "2020-08-28T12:24:36Z", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {", "originalCommit": "1383a38006bf2ebbc08146bc76881db6f66d9860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}