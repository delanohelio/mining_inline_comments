{"pr_number": 1620, "pr_title": "SOLR-14590 : Add support for Lucene's FeatureField in Solr", "pr_createdAt": "2020-06-26T21:54:05Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1620", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQyOTE3MQ==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r446429171", "bodyText": "I think so? Essentially this is an exists query right?\nWe can be safe and not support this for now?\nThinking aloud on another option - What if we rewrite ( like how you have it right now ) when the value is * and throw an exception otherwise?", "author": "vthacker", "createdAt": "2020-06-26T21:59:57Z", "path": "solr/core/src/java/org/apache/solr/schema/RankField.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import org.apache.lucene.document.FeatureField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.IndexableFieldType;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.response.TextResponseWriter;\n+import org.apache.solr.search.QParser;\n+import org.apache.solr.uninverting.UninvertingReader.Type;\n+\n+public class RankField extends FieldType {\n+  \n+  public static final String INTERNAL_RANK_FIELD_NAME = \"_internal_rank_field\";\n+\n+  @Override\n+  public Type getUninversionType(SchemaField sf) {\n+    throw null;\n+  }\n+\n+  @Override\n+  public void write(TextResponseWriter writer, String name, IndexableField f) throws IOException {\n+  }\n+  \n+  @Override\n+  protected void init(IndexSchema schema, Map<String,String> args) {\n+    super.init(schema, args);\n+    if (schema.getFieldOrNull(INTERNAL_RANK_FIELD_NAME) != null) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"A field named \\\"\" + INTERNAL_RANK_FIELD_NAME + \"\\\" can't be defined in the schema\");\n+    }\n+    for (int prop:new int[] {STORED, DOC_VALUES, OMIT_TF_POSITIONS, SORT_MISSING_FIRST, SORT_MISSING_LAST}) {\n+      if ((trueProperties & prop) != 0) {\n+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Property \\\"\" + getPropertyName(prop) + \"\\\" can't be set to true in RankFields\");\n+      }\n+    }\n+    for (int prop:new int[] {UNINVERTIBLE, INDEXED, MULTIVALUED}) {\n+      if ((falseProperties & prop) != 0) {\n+        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Property \\\"\" + getPropertyName(prop) + \"\\\" can't be set to false in RankFields\");\n+      }\n+    }\n+    properties &= ~(UNINVERTIBLE | STORED | DOC_VALUES);\n+    \n+  }\n+\n+  @Override\n+  protected IndexableField createField(String name, String val, IndexableFieldType type) {\n+    if (val == null || val.isEmpty()) {\n+      return null;\n+    }\n+    float featureValue;\n+    try {\n+      featureValue = Float.parseFloat(val);\n+    } catch (NumberFormatException nfe) {\n+      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Error while creating field '\" + name + \"' from value '\" + val + \"'. Expecting float.\", nfe);\n+    }\n+    return new FeatureField(INTERNAL_RANK_FIELD_NAME, name, featureValue);\n+  }\n+\n+  @Override\n+  public Query getFieldQuery(QParser parser, SchemaField field, String externalVal) {", "originalCommit": "e5319c73a554bdb249e1f896b7d711b7fa635217", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQzNTM5NA==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r446435394", "bodyText": "Good idea. I'll add that", "author": "tflobbe", "createdAt": "2020-06-26T22:22:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQyOTE3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxMTMzMw==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447411333", "bodyText": "Thinking aloud on another option - What if we rewrite ( like how you have it right now ) when the value is * and throw an exception otherwise?\n\nNice! we added it to getExistenceQuery and in getFieldQuery we throw an exception!", "author": "vthacker", "createdAt": "2020-06-30T05:04:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQyOTE3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4ODU0MA==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r446488540", "bodyText": "should end with a final underscore as well like our other internal fields", "author": "dsmiley", "createdAt": "2020-06-27T05:41:11Z", "path": "solr/core/src/java/org/apache/solr/schema/RankField.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import org.apache.lucene.document.FeatureField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.IndexableFieldType;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.response.TextResponseWriter;\n+import org.apache.solr.search.QParser;\n+import org.apache.solr.search.RankQParserPlugin;\n+import org.apache.solr.uninverting.UninvertingReader.Type;\n+\n+/**\n+ * <p>\n+ * {@code RankField}s can be used to store scoring factors to improve document ranking. They should be used\n+ * in combination with {@link RankQParserPlugin}. To use:\n+ * </p>\n+ * <p>\n+ * Define the {@code RankField} {@code fieldType} in your schema:\n+ * </p>\n+ * <pre class=\"prettyprint\">\n+ * &lt;fieldType name=\"rank\" class=\"solr.RankField\" /&gt;\n+ * </pre>\n+ * <p>\n+ * Add fields to the schema, i.e.:\n+ * </p>\n+ * <pre class=\"prettyprint\">\n+ * &lt;field name=\"rank_1\" type=\"rank\" /&gt;\n+ * </pre>\n+ * \n+ * Query using the {@link RankQParserPlugin}, for example\n+ * <pre class=\"prettyprint\">\n+ * http://localhost:8983/solr/techproducts?q=memory _query_:{!rank f='rank_1', function='log' scalingFactor='1.2'}\n+ * </pre>\n+ * \n+ * @see RankQParserPlugin\n+ * @lucene.experimental\n+ * @since 8.6\n+ */\n+public class RankField extends FieldType {\n+  \n+  /*\n+   * While the user can create multiple RankFields, internally we use a single Lucene field,\n+   * and we map the Solr field name to the \"feature\" in Lucene's FeatureField. This is mainly\n+   * to simplify the user experience.\n+   */\n+  public static final String INTERNAL_RANK_FIELD_NAME = \"_internal_rank_field\";", "originalCommit": "54e30df0e512da5b51b143fbd0a89df2eb741c05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4ODcyMQ==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r446488721", "bodyText": "might simply _rank_ be fine?  The \"internal\" aspect is implied by the leading/trailing underscore, and I don't think any field needs to have \"field\" in its name ;-)", "author": "dsmiley", "createdAt": "2020-06-27T05:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ4ODU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxMDI1Mw==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447410253", "bodyText": "small nit: something like document_length_boost might be a better example to help a user realize how they can leverage this feature?", "author": "vthacker", "createdAt": "2020-06-30T05:00:08Z", "path": "solr/core/src/java/org/apache/solr/schema/RankField.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import org.apache.lucene.document.FeatureField;\n+import org.apache.lucene.index.IndexableField;\n+import org.apache.lucene.index.IndexableFieldType;\n+import org.apache.lucene.index.Term;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.SortField;\n+import org.apache.lucene.search.TermQuery;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.response.TextResponseWriter;\n+import org.apache.solr.search.QParser;\n+import org.apache.solr.search.RankQParserPlugin;\n+import org.apache.solr.uninverting.UninvertingReader.Type;\n+\n+/**\n+ * <p>\n+ * {@code RankField}s can be used to store scoring factors to improve document ranking. They should be used\n+ * in combination with {@link RankQParserPlugin}. To use:\n+ * </p>\n+ * <p>\n+ * Define the {@code RankField} {@code fieldType} in your schema:\n+ * </p>\n+ * <pre class=\"prettyprint\">\n+ * &lt;fieldType name=\"rank\" class=\"solr.RankField\" /&gt;\n+ * </pre>\n+ * <p>\n+ * Add fields to the schema, i.e.:\n+ * </p>\n+ * <pre class=\"prettyprint\">\n+ * &lt;field name=\"rank_1\" type=\"rank\" /&gt;", "originalCommit": "4c8410b027881dc69a35efc1792cd56ce6aab822", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMDM2NA==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447830364", "bodyText": "I've switched to pagerank, since that's also in Jira and tests.", "author": "tflobbe", "createdAt": "2020-06-30T16:45:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxMDI1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxMjI1NA==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447412254", "bodyText": "\ud83d\udc4d All parsers in https://lucene.apache.org/solr/guide/8_5/other-parsers.html that expect a field use f as the key", "author": "vthacker", "createdAt": "2020-06-30T05:07:20Z", "path": "solr/core/src/java/org/apache/solr/search/RankQParserPlugin.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.search;\n+\n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import org.apache.lucene.document.FeatureField;\n+import org.apache.lucene.search.Query;\n+import org.apache.solr.common.params.SolrParams;\n+import org.apache.solr.request.SolrQueryRequest;\n+import org.apache.solr.schema.RankField;\n+import org.apache.solr.schema.SchemaField;\n+/**\n+ * {@code RankQParserPlugin} can be used to introduce document-depending scoring factors to ranking.\n+ * While this {@code QParser} delivers a (subset of) functionality already available via {@link FunctionQParser},\n+ * the benefit is that {@code RankQParserPlugin} can be used in combination with the {@code minExactCount} to\n+ * use BlockMax-WAND algorithm (skip non-competitive documents) to provide faster responses. \n+ * \n+ *  @see RankField\n+ * \n+ * @lucene.experimental\n+ * @since 8.6\n+ */\n+public class RankQParserPlugin extends QParserPlugin {\n+  \n+  public static final String NAME = \"rank\";\n+  public static final String FIELD = \"f\";", "originalCommit": "4c8410b027881dc69a35efc1792cd56ce6aab822", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxODc3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447418777", "bodyText": "I manually checked the 'score' from these two runs to ensure that the score was changing! Would it make sense to add this as a test?\nString rsp = h.query(req(\"q\", \"foo\",\n        \"defType\", \"dismax\",\n        \"qf\", \"str_field^10\",\n        \"fl\", \"*,score\"\n    ));\n\n    rsp = h.query(req(\"q\", \"foo\",\n        \"defType\", \"dismax\",\n        \"qf\", \"str_field^10\",\n        \"fl\", \"*,score\",\n        \"bq\", \"{!rank f='\" + RANK_2 + \"' function='log' scalingFactor='1'}\"\n    ));", "author": "vthacker", "createdAt": "2020-06-30T05:30:09Z", "path": "solr/core/src/test/org/apache/solr/schema/RankFieldTest.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+\n+public class RankFieldTest extends SolrTestCaseJ4 {\n+  \n+  private static final String RANK_1 = \"rank_1\";\n+  private static final String RANK_2 = \"rank_2\";\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    initCore(\"solrconfig-minimal.xml\",\"schema-rank-fields.xml\");\n+  }\n+  \n+  @Override\n+  public void setUp() throws Exception {\n+    clearIndex();\n+    assertU(commit());\n+    super.setUp();\n+  }\n+  \n+  public void testInternalFieldName() {\n+    assertEquals(\"RankField.INTERNAL_RANK_FIELD_NAME changed in an incompatible way\",\n+        \"_rank_\", RankField.INTERNAL_RANK_FIELD_NAME);\n+  }\n+\n+  public void testBasic() {\n+    assertNotNull(h.getCore().getLatestSchema().getFieldOrNull(RANK_1));\n+    assertEquals(RankField.class, h.getCore().getLatestSchema().getField(RANK_1).getType().getClass());\n+  }\n+  \n+  public void testBadFormat() {\n+    ignoreException(\"Expecting float\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"foo\"\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"1.2.3\"\n+        ));\n+    \n+    unIgnoreException(\"Expecting float\");\n+    \n+    ignoreException(\"must be finite\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.POSITIVE_INFINITY)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.NEGATIVE_INFINITY)\n+        ));\n+    \n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.NaN)\n+        ));\n+    \n+    unIgnoreException(\"must be finite\");\n+    \n+    ignoreException(\"must be a positive\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(-0.0f)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(-1f)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(0.0f)\n+        ));\n+    unIgnoreException(\"must be a positive\");\n+  }\n+  \n+  public void testAddRandom() {\n+    for (int i = 0 ; i < random().nextInt(TEST_NIGHTLY ? 10000 : 100); i++) {\n+      assertU(adoc(\n+          \"id\", String.valueOf(i),\n+          RANK_1, Float.toString(random().nextFloat())\n+          ));\n+    }\n+    assertU(commit());\n+  }\n+  \n+  public void testSkipEmpty() {\n+    assertU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"\"\n+        ));\n+  }\n+  \n+  public void testBasicAdd() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testBasicAdd\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    //assert that the document made it in\n+    assertQ(req(\"q\", \"id:testBasicAdd\"), \"//*[@numFound='1']\");\n+    h.getCore().withSearcher((searcher) -> {\n+      LeafReader reader = searcher.getIndexReader().getContext().leaves().get(0).reader();\n+      // assert that the field made it in\n+      assertNotNull(reader.getFieldInfos().fieldInfo(RankField.INTERNAL_RANK_FIELD_NAME));\n+      // assert that the feature made it in\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_1.getBytes(StandardCharsets.UTF_8))));\n+      return null;\n+    });\n+  }\n+  \n+  public void testMultipleRankFields() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testMultiValueAdd\",\n+        RANK_1, \"1\",\n+        RANK_2, \"2\"\n+        ));\n+    assertU(commit());\n+    //assert that the document made it in\n+    assertQ(req(\"q\", \"id:testMultiValueAdd\"), \"//*[@numFound='1']\");\n+    h.getCore().withSearcher((searcher) -> {\n+      LeafReader reader = searcher.getIndexReader().getContext().leaves().get(0).reader();\n+      // assert that the field made it in\n+      assertNotNull(reader.getFieldInfos().fieldInfo(RankField.INTERNAL_RANK_FIELD_NAME));\n+      // assert that the features made it in\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_2.getBytes(StandardCharsets.UTF_8))));\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_1.getBytes(StandardCharsets.UTF_8))));\n+      return null;\n+    });\n+  }\n+  \n+  public void testSortFails() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testSortFails\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQEx(\"Can't sort on rank field\", req(\n+        \"q\", \"id:testSortFails\",\n+        \"sort\", RANK_1 + \" desc\"), 400);\n+  }\n+  \n+  @Ignore(\"We currently don't fail these kinds of requests with other field types\")\n+  public void testFacetFails() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testFacetFails\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQEx(\"Can't facet on rank field\", req(\n+        \"q\", \"id:testFacetFails\",\n+        \"facet\", \"true\",\n+        \"facet.field\", RANK_1), 400);\n+  }\n+  \n+  public void testTermQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testTermQuery\",\n+        RANK_1, \"1\",\n+        RANK_2, \"1\"\n+        ));\n+    assertU(adoc(\n+        \"id\", \"testTermQuery2\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQ(req(\"q\", RANK_1 + \":*\"), \"//*[@numFound='2']\");\n+    assertQ(req(\"q\", RANK_1 + \":[* TO *]\"), \"//*[@numFound='2']\");\n+    assertQ(req(\"q\", RANK_2 + \":*\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"q\", RANK_2 + \":[* TO *]\"), \"//*[@numFound='1']\");\n+    \n+    assertQEx(\"Term queries not supported\", req(\"q\", RANK_1 + \":1\"), 400);\n+    assertQEx(\"Range queries not supported\", req(\"q\", RANK_1 + \":[1 TO 10]\"), 400);\n+  }\n+  \n+  \n+  public void testResponseQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testResponseQuery\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    // Ignore requests to retrieve rank\n+    assertQ(req(\"q\", RANK_1 + \":*\",\n+        \"fl\", \"id,\" + RANK_1),\n+        \"//*[@numFound='1']\",\n+        \"count(//result/doc[1]/str)=1\");\n+  }\n+  \n+  public void testRankQParserQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"1\",\n+        \"str_field\", \"foo\",\n+        RANK_1, \"1\",\n+        RANK_2, \"2\"\n+        ));\n+    assertU(adoc(\n+        \"id\", \"2\",\n+        \"str_field\", \"foo\",\n+        RANK_1, \"2\",\n+        RANK_2, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQ(req(\"q\", \"str_field:foo _query_:{!rank f='\" + RANK_1 + \"' function='log' scalingFactor='1'}\"),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='2']\",\n+        \"//result/doc[2]/str[@name='id'][.='1']\");\n+    \n+    assertQ(req(\"q\", \"str_field:foo _query_:{!rank f='\" + RANK_2 + \"' function='log' scalingFactor='1'}\"),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='1']\",\n+        \"//result/doc[2]/str[@name='id'][.='2']\");\n+    \n+    assertQ(req(\"q\", \"foo\",\n+        \"defType\", \"dismax\",\n+        \"qf\", \"str_field^10\",\n+        \"bq\", \"{!rank f='\" + RANK_1 + \"' function='log' scalingFactor='1'}\"\n+        ),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='2']\",\n+        \"//result/doc[2]/str[@name='id'][.='1']\");\n+    \n+    assertQ(req(\"q\", \"foo\",\n+        \"defType\", \"dismax\",\n+        \"qf\", \"str_field^10\",\n+        \"bq\", \"{!rank f='\" + RANK_2 + \"' function='log' scalingFactor='1'}\"\n+        ),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='1']\",\n+        \"//result/doc[2]/str[@name='id'][.='2']\");\n+  }", "originalCommit": "4c8410b027881dc69a35efc1792cd56ce6aab822", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxOTcwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447419709", "bodyText": "Also I was curious to see if debugQuery=true does the right thing ( it does! )\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<response>\n   <lst name=\"responseHeader\">\n      <int name=\"status\">0</int>\n      <int name=\"QTime\">161</int>\n      <lst name=\"params\">\n         <str name=\"q\">foo</str>\n         <str name=\"defType\">dismax</str>\n         <str name=\"qf\">str_field^10</str>\n         <str name=\"fl\">*,score,rank_1,rank_2</str>\n         <str name=\"wt\">xml</str>\n         <str name=\"debugQuery\">true</str>\n         <str name=\"bq\">{!rank f='rank_2' function='log' scalingFactor='1'}</str>\n      </lst>\n   </lst>\n   <result name=\"response\" numFound=\"2\" start=\"0\" maxScore=\"1.9273467\" numFoundExact=\"true\">\n      <doc>\n         <str name=\"id\">1</str>\n         <str name=\"str_field\">foo</str>\n         <float name=\"score\">1.9273467</float>\n      </doc>\n      <doc>\n         <str name=\"id\">2</str>\n         <str name=\"str_field\">foo</str>\n         <float name=\"score\">1.5218816</float>\n      </doc>\n   </result>\n   <lst name=\"debug\">\n      <str name=\"rawquerystring\">foo</str>\n      <str name=\"querystring\">foo</str>\n      <str name=\"parsedquery\">+DisjunctionMaxQuery(((str_field:foo)^10.0)) () FeatureQuery(FeatureQuery(field=_rank_, feature=rank_2, function=LogFunction(scalingFactor=1.0)))</str>\n      <str name=\"parsedquery_toString\">+((str_field:foo)^10.0) () FeatureQuery(field=_rank_, feature=rank_2, function=LogFunction(scalingFactor=1.0))</str>\n      <lst name=\"explain\">\n         <str>1.9273467 = sum of:\n  0.82873434 = weight(str_field:foo in 0) [SchemaSimilarity], result of:\n    0.82873434 = score(freq=1.0), computed as boost * idf * tf from:\n      10.0 = boost\n      0.18232156 = idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:\n        2 = n, number of documents containing term\n        2 = N, total number of documents with field\n      0.45454544 = tf, computed as freq / (freq + k1 * (1 - b + b * dl / avgdl)) from:\n        1.0 = freq, occurrences of term within document\n        1.2 = k1, term saturation parameter\n        0.75 = b, length normalization parameter\n        1.0 = dl, length of field\n        1.0 = avgdl, average length of field\n  1.0986123 = Log function on the _rank_ field for the rank_2 feature, computed as w * log(a + S) from:\n    1.0 = w, weight of this function\n    1.0 = a, scaling factor\n    2.0 = S, feature value</str>\n         <str>1.5218816 = sum of:\n  0.82873434 = weight(str_field:foo in 1) [SchemaSimilarity], result of:\n    0.82873434 = score(freq=1.0), computed as boost * idf * tf from:\n      10.0 = boost\n      0.18232156 = idf, computed as log(1 + (N - n + 0.5) / (n + 0.5)) from:\n        2 = n, number of documents containing term\n        2 = N, total number of documents with field\n      0.45454544 = tf, computed as freq / (freq + k1 * (1 - b + b * dl / avgdl)) from:\n        1.0 = freq, occurrences of term within document\n        1.2 = k1, term saturation parameter\n        0.75 = b, length normalization parameter\n        1.0 = dl, length of field\n        1.0 = avgdl, average length of field\n  0.6931472 = Log function on the _rank_ field for the rank_2 feature, computed as w * log(a + S) from:\n    1.0 = w, weight of this function\n    1.0 = a, scaling factor\n    1.0 = S, feature value</str>\n      </lst>\n      <str name=\"QParser\">DisMaxQParser</str>\n      <null name=\"altquerystring\" />\n      <arr name=\"boost_queries\">\n         <str>{!rank f='rank_2' function='log' scalingFactor='1'}</str>\n      </arr>\n      <arr name=\"parsed_boost_queries\">\n         <str>FeatureQuery(FeatureQuery(field=_rank_, feature=rank_2, function=LogFunction(scalingFactor=1.0)))</str>\n      </arr>\n      <null name=\"boostfuncs\" />\n      <lst name=\"timing\">\n         <double name=\"time\">160.0</double>\n         <lst name=\"prepare\">\n            <double name=\"time\">1.0</double>\n            <lst name=\"query\">\n               <double name=\"time\">1.0</double>\n            </lst>\n            <lst name=\"facet\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"facet_module\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"mlt\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"highlight\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"stats\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"expand\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"terms\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"debug\">\n               <double name=\"time\">0.0</double>\n            </lst>\n         </lst>\n         <lst name=\"process\">\n            <double name=\"time\">155.0</double>\n            <lst name=\"query\">\n               <double name=\"time\">3.0</double>\n            </lst>\n            <lst name=\"facet\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"facet_module\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"mlt\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"highlight\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"stats\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"expand\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"terms\">\n               <double name=\"time\">0.0</double>\n            </lst>\n            <lst name=\"debug\">\n               <double name=\"time\">152.0</double>\n            </lst>\n         </lst>\n      </lst>\n   </lst>\n</response>", "author": "vthacker", "createdAt": "2020-06-30T05:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxODc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg1NTAyMA==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447855020", "bodyText": "Added the \"score change\" test", "author": "tflobbe", "createdAt": "2020-06-30T17:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxODc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxOTk1Mg==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447419952", "bodyText": "If I add \"fl\", \"*,score,rank_1,rank_2\", we won't retrieve the value back. I think it's fine not to throw an error or anything right?", "author": "vthacker", "createdAt": "2020-06-30T05:33:56Z", "path": "solr/core/src/test/org/apache/solr/schema/RankFieldTest.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.schema;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.util.BytesRef;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+\n+public class RankFieldTest extends SolrTestCaseJ4 {\n+  \n+  private static final String RANK_1 = \"rank_1\";\n+  private static final String RANK_2 = \"rank_2\";\n+\n+  @BeforeClass\n+  public static void beforeClass() throws Exception {\n+    initCore(\"solrconfig-minimal.xml\",\"schema-rank-fields.xml\");\n+  }\n+  \n+  @Override\n+  public void setUp() throws Exception {\n+    clearIndex();\n+    assertU(commit());\n+    super.setUp();\n+  }\n+  \n+  public void testInternalFieldName() {\n+    assertEquals(\"RankField.INTERNAL_RANK_FIELD_NAME changed in an incompatible way\",\n+        \"_rank_\", RankField.INTERNAL_RANK_FIELD_NAME);\n+  }\n+\n+  public void testBasic() {\n+    assertNotNull(h.getCore().getLatestSchema().getFieldOrNull(RANK_1));\n+    assertEquals(RankField.class, h.getCore().getLatestSchema().getField(RANK_1).getType().getClass());\n+  }\n+  \n+  public void testBadFormat() {\n+    ignoreException(\"Expecting float\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"foo\"\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"1.2.3\"\n+        ));\n+    \n+    unIgnoreException(\"Expecting float\");\n+    \n+    ignoreException(\"must be finite\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.POSITIVE_INFINITY)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.NEGATIVE_INFINITY)\n+        ));\n+    \n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(Float.NaN)\n+        ));\n+    \n+    unIgnoreException(\"must be finite\");\n+    \n+    ignoreException(\"must be a positive\");\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(-0.0f)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(-1f)\n+        ));\n+\n+    assertFailedU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, Float.toString(0.0f)\n+        ));\n+    unIgnoreException(\"must be a positive\");\n+  }\n+  \n+  public void testAddRandom() {\n+    for (int i = 0 ; i < random().nextInt(TEST_NIGHTLY ? 10000 : 100); i++) {\n+      assertU(adoc(\n+          \"id\", String.valueOf(i),\n+          RANK_1, Float.toString(random().nextFloat())\n+          ));\n+    }\n+    assertU(commit());\n+  }\n+  \n+  public void testSkipEmpty() {\n+    assertU(adoc(\n+        \"id\", \"1\",\n+        RANK_1, \"\"\n+        ));\n+  }\n+  \n+  public void testBasicAdd() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testBasicAdd\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    //assert that the document made it in\n+    assertQ(req(\"q\", \"id:testBasicAdd\"), \"//*[@numFound='1']\");\n+    h.getCore().withSearcher((searcher) -> {\n+      LeafReader reader = searcher.getIndexReader().getContext().leaves().get(0).reader();\n+      // assert that the field made it in\n+      assertNotNull(reader.getFieldInfos().fieldInfo(RankField.INTERNAL_RANK_FIELD_NAME));\n+      // assert that the feature made it in\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_1.getBytes(StandardCharsets.UTF_8))));\n+      return null;\n+    });\n+  }\n+  \n+  public void testMultipleRankFields() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testMultiValueAdd\",\n+        RANK_1, \"1\",\n+        RANK_2, \"2\"\n+        ));\n+    assertU(commit());\n+    //assert that the document made it in\n+    assertQ(req(\"q\", \"id:testMultiValueAdd\"), \"//*[@numFound='1']\");\n+    h.getCore().withSearcher((searcher) -> {\n+      LeafReader reader = searcher.getIndexReader().getContext().leaves().get(0).reader();\n+      // assert that the field made it in\n+      assertNotNull(reader.getFieldInfos().fieldInfo(RankField.INTERNAL_RANK_FIELD_NAME));\n+      // assert that the features made it in\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_2.getBytes(StandardCharsets.UTF_8))));\n+      assertTrue(reader.terms(RankField.INTERNAL_RANK_FIELD_NAME).iterator().seekExact(new BytesRef(RANK_1.getBytes(StandardCharsets.UTF_8))));\n+      return null;\n+    });\n+  }\n+  \n+  public void testSortFails() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testSortFails\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQEx(\"Can't sort on rank field\", req(\n+        \"q\", \"id:testSortFails\",\n+        \"sort\", RANK_1 + \" desc\"), 400);\n+  }\n+  \n+  @Ignore(\"We currently don't fail these kinds of requests with other field types\")\n+  public void testFacetFails() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testFacetFails\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQEx(\"Can't facet on rank field\", req(\n+        \"q\", \"id:testFacetFails\",\n+        \"facet\", \"true\",\n+        \"facet.field\", RANK_1), 400);\n+  }\n+  \n+  public void testTermQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testTermQuery\",\n+        RANK_1, \"1\",\n+        RANK_2, \"1\"\n+        ));\n+    assertU(adoc(\n+        \"id\", \"testTermQuery2\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQ(req(\"q\", RANK_1 + \":*\"), \"//*[@numFound='2']\");\n+    assertQ(req(\"q\", RANK_1 + \":[* TO *]\"), \"//*[@numFound='2']\");\n+    assertQ(req(\"q\", RANK_2 + \":*\"), \"//*[@numFound='1']\");\n+    assertQ(req(\"q\", RANK_2 + \":[* TO *]\"), \"//*[@numFound='1']\");\n+    \n+    assertQEx(\"Term queries not supported\", req(\"q\", RANK_1 + \":1\"), 400);\n+    assertQEx(\"Range queries not supported\", req(\"q\", RANK_1 + \":[1 TO 10]\"), 400);\n+  }\n+  \n+  \n+  public void testResponseQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"testResponseQuery\",\n+        RANK_1, \"1\"\n+        ));\n+    assertU(commit());\n+    // Ignore requests to retrieve rank\n+    assertQ(req(\"q\", RANK_1 + \":*\",\n+        \"fl\", \"id,\" + RANK_1),\n+        \"//*[@numFound='1']\",\n+        \"count(//result/doc[1]/str)=1\");\n+  }\n+  \n+  public void testRankQParserQuery() throws IOException {\n+    assertU(adoc(\n+        \"id\", \"1\",\n+        \"str_field\", \"foo\",\n+        RANK_1, \"1\",\n+        RANK_2, \"2\"\n+        ));\n+    assertU(adoc(\n+        \"id\", \"2\",\n+        \"str_field\", \"foo\",\n+        RANK_1, \"2\",\n+        RANK_2, \"1\"\n+        ));\n+    assertU(commit());\n+    assertQ(req(\"q\", \"str_field:foo _query_:{!rank f='\" + RANK_1 + \"' function='log' scalingFactor='1'}\"),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='2']\",\n+        \"//result/doc[2]/str[@name='id'][.='1']\");\n+    \n+    assertQ(req(\"q\", \"str_field:foo _query_:{!rank f='\" + RANK_2 + \"' function='log' scalingFactor='1'}\"),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='1']\",\n+        \"//result/doc[2]/str[@name='id'][.='2']\");\n+    \n+    assertQ(req(\"q\", \"foo\",\n+        \"defType\", \"dismax\",\n+        \"qf\", \"str_field^10\",\n+        \"bq\", \"{!rank f='\" + RANK_1 + \"' function='log' scalingFactor='1'}\"\n+        ),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='2']\",\n+        \"//result/doc[2]/str[@name='id'][.='1']\");\n+    \n+    assertQ(req(\"q\", \"foo\",\n+        \"defType\", \"dismax\",\n+        \"qf\", \"str_field^10\",\n+        \"bq\", \"{!rank f='\" + RANK_2 + \"' function='log' scalingFactor='1'}\"\n+        ),\n+        \"//*[@numFound='2']\",\n+        \"//result/doc[1]/str[@name='id'][.='1']\",\n+        \"//result/doc[2]/str[@name='id'][.='2']\");\n+  }\n+", "originalCommit": "4c8410b027881dc69a35efc1792cd56ce6aab822", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg1NTYwNg==", "url": "https://github.com/apache/lucene-solr/pull/1620#discussion_r447855606", "bodyText": "I think it should be fine? I believe this is the behavior when trying to retrieve non-stored (or dv) fields?", "author": "tflobbe", "createdAt": "2020-06-30T17:25:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxOTk1Mg=="}], "type": "inlineReview"}, {"oid": "517b43e7ef8242557cab09b235252f2121eb97aa", "url": "https://github.com/apache/lucene-solr/commit/517b43e7ef8242557cab09b235252f2121eb97aa", "message": "Add CHANGES entry", "committedDate": "2020-06-30T17:22:29Z", "type": "forcePushed"}, {"oid": "b95f1a274a81f96d018158e9339a02a2205ebbd1", "url": "https://github.com/apache/lucene-solr/commit/b95f1a274a81f96d018158e9339a02a2205ebbd1", "message": "Add CHANGES entry", "committedDate": "2020-06-30T17:37:31Z", "type": "forcePushed"}, {"oid": "8ca1481f186dd2cff2bb3985373453fa2d8d2a9e", "url": "https://github.com/apache/lucene-solr/commit/8ca1481f186dd2cff2bb3985373453fa2d8d2a9e", "message": "Add RankQParserPlugin", "committedDate": "2020-06-30T17:56:42Z", "type": "commit"}, {"oid": "38a31e02bb7dd7b51d7355f3ba1fd96c6af3886b", "url": "https://github.com/apache/lucene-solr/commit/38a31e02bb7dd7b51d7355f3ba1fd96c6af3886b", "message": "Move the Function enum to the QPArser Plugin", "committedDate": "2020-06-30T17:56:42Z", "type": "commit"}, {"oid": "f5697759e47f3b001d943fd3055a5b62b29830a9", "url": "https://github.com/apache/lucene-solr/commit/f5697759e47f3b001d943fd3055a5b62b29830a9", "message": "Add RankField", "committedDate": "2020-06-30T17:56:42Z", "type": "commit"}, {"oid": "8cab07cdd682430b03554e1168e07af014d388e9", "url": "https://github.com/apache/lucene-solr/commit/8cab07cdd682430b03554e1168e07af014d388e9", "message": "Cleaned up tabs", "committedDate": "2020-06-30T17:56:42Z", "type": "commit"}, {"oid": "64f9e6c03fd35dee3205d13228a64ddd066fa21d", "url": "https://github.com/apache/lucene-solr/commit/64f9e6c03fd35dee3205d13228a64ddd066fa21d", "message": "Validate Rank Query is on Rank Field", "committedDate": "2020-06-30T17:56:42Z", "type": "commit"}, {"oid": "340c6c41811f60754ad4aa1096396e83e5552ecd", "url": "https://github.com/apache/lucene-solr/commit/340c6c41811f60754ad4aa1096396e83e5552ecd", "message": "Use a single Lucene field internally", "committedDate": "2020-06-30T17:56:43Z", "type": "commit"}, {"oid": "e3bf0869d7d38663205b0240b1e3943c0d95f964", "url": "https://github.com/apache/lucene-solr/commit/e3bf0869d7d38663205b0240b1e3943c0d95f964", "message": "Some more tests", "committedDate": "2020-06-30T17:56:43Z", "type": "commit"}, {"oid": "b4863b6a2569fe45665ae69811f478223216a56e", "url": "https://github.com/apache/lucene-solr/commit/b4863b6a2569fe45665ae69811f478223216a56e", "message": "Add support for existence query", "committedDate": "2020-06-30T17:56:43Z", "type": "commit"}, {"oid": "f8699fb420f22559299f093e6846f76da9c6cdb0", "url": "https://github.com/apache/lucene-solr/commit/f8699fb420f22559299f093e6846f76da9c6cdb0", "message": "Add retrieve field test", "committedDate": "2020-06-30T17:56:43Z", "type": "commit"}, {"oid": "cb472ffdc25beabef4ffa8c293248e451442bf0e", "url": "https://github.com/apache/lucene-solr/commit/cb472ffdc25beabef4ffa8c293248e451442bf0e", "message": "Add class javadocs", "committedDate": "2020-06-30T17:56:43Z", "type": "commit"}, {"oid": "1138f91e439a3cf27df90c14331e4d825ab11df5", "url": "https://github.com/apache/lucene-solr/commit/1138f91e439a3cf27df90c14331e4d825ab11df5", "message": "Add rank field type to default schema", "committedDate": "2020-06-30T17:56:43Z", "type": "commit"}, {"oid": "01fa910f05185d50102bc5d4c0166e178f7bf2a5", "url": "https://github.com/apache/lucene-solr/commit/01fa910f05185d50102bc5d4c0166e178f7bf2a5", "message": "Fix failing test", "committedDate": "2020-06-30T17:56:43Z", "type": "commit"}, {"oid": "06571c63d041a6942a1c2de4198c1a900592e5f5", "url": "https://github.com/apache/lucene-solr/commit/06571c63d041a6942a1c2de4198c1a900592e5f5", "message": "Rename internal field name", "committedDate": "2020-06-30T17:56:43Z", "type": "commit"}, {"oid": "96aa9fcf024397dccd9609818775964a5e5acca9", "url": "https://github.com/apache/lucene-solr/commit/96aa9fcf024397dccd9609818775964a5e5acca9", "message": "Addressed PR comments", "committedDate": "2020-06-30T17:56:43Z", "type": "commit"}, {"oid": "2898e16ae2d35fb1a13c1550fff673fef5340c3e", "url": "https://github.com/apache/lucene-solr/commit/2898e16ae2d35fb1a13c1550fff673fef5340c3e", "message": "Add CHANGES entry", "committedDate": "2020-06-30T17:56:43Z", "type": "commit"}, {"oid": "2898e16ae2d35fb1a13c1550fff673fef5340c3e", "url": "https://github.com/apache/lucene-solr/commit/2898e16ae2d35fb1a13c1550fff673fef5340c3e", "message": "Add CHANGES entry", "committedDate": "2020-06-30T17:56:43Z", "type": "forcePushed"}]}