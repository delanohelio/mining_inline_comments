{"pr_number": 2010, "pr_title": "SOLR-12182: Don't persist base_url in ZK as the scheme is variable, compute from node_name instead", "pr_createdAt": "2020-10-20T20:29:00Z", "pr_url": "https://github.com/apache/lucene-solr/pull/2010", "timeline": [{"oid": "63faeff81a630964e452758db87ed73600485723", "url": "https://github.com/apache/lucene-solr/commit/63faeff81a630964e452758db87ed73600485723", "message": "SOLR-12182: Don't store the URL scheme in state in ZK", "committedDate": "2020-10-20T19:09:40Z", "type": "commit"}, {"oid": "9ae741bbf917ce18054eaddcab7264c69947ceea", "url": "https://github.com/apache/lucene-solr/commit/9ae741bbf917ce18054eaddcab7264c69947ceea", "message": "Merge branch 'master' into jira/solr-12182", "committedDate": "2020-10-20T19:12:46Z", "type": "commit"}, {"oid": "369793a4ca532d4136ea97bea0af6881de5cdac9", "url": "https://github.com/apache/lucene-solr/commit/369793a4ca532d4136ea97bea0af6881de5cdac9", "message": "Remove unused imports", "committedDate": "2020-10-20T19:27:37Z", "type": "commit"}, {"oid": "73829adb1e9b4247e01de9b20facdbdf8de7bdcb", "url": "https://github.com/apache/lucene-solr/commit/73829adb1e9b4247e01de9b20facdbdf8de7bdcb", "message": "Remove unused imports", "committedDate": "2020-10-20T19:30:30Z", "type": "commit"}, {"oid": "a8f2ea35572d6829303f351d85a539d22c2fdc67", "url": "https://github.com/apache/lucene-solr/commit/a8f2ea35572d6829303f351d85a539d22c2fdc67", "message": "Check for null value in map", "committedDate": "2020-10-20T21:07:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzOTMzOQ==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508839339", "bodyText": "nit: alphabetize imports", "author": "madrob", "createdAt": "2020-10-20T21:06:13Z", "path": "solr/core/src/java/org/apache/solr/core/ZkContainer.java", "diffHunk": "@@ -31,6 +31,7 @@\n import java.util.function.Supplier;\n \n import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.common.cloud.GlobalStateVars;", "originalCommit": "73829adb1e9b4247e01de9b20facdbdf8de7bdcb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mjg1OA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508842858", "bodyText": "?", "author": "madrob", "createdAt": "2020-10-20T21:12:50Z", "path": "solr/core/src/test/org/apache/solr/cloud/SSLMigrationTest.java", "diffHunk": "@@ -63,7 +61,7 @@ public void test() throws Exception {\n     testMigrateSSL(new SSLTestConfig(false, false));\n   }\n   \n-  public void testMigrateSSL(SSLTestConfig sslConfig) throws Exception {\n+  private void testMigrateSSL(SSLTestConfig sslConfig) throws Exception {", "originalCommit": "a8f2ea35572d6829303f351d85a539d22c2fdc67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NzA4OQ==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508867089", "bodyText": "it's an internal test method and doesn't need to be public but I'll rename it to make it clear", "author": "thelabdude", "createdAt": "2020-10-20T22:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mjg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mzg3Ng==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508843876", "bodyText": "I prefer the enum singleton pattern", "author": "madrob", "createdAt": "2020-10-20T21:14:53Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String SCHEME_VAR = \"${scheme}://\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+\n+  private static final GlobalStateVars _singleton = new GlobalStateVars();", "originalCommit": "a8f2ea35572d6829303f351d85a539d22c2fdc67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2NzE2OQ==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508867169", "bodyText": "ah yes, good call, thanks", "author": "thelabdude", "createdAt": "2020-10-20T22:02:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0Mzg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NDU2OQ==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508844569", "bodyText": "null on unchanged seems like a trap to me", "author": "madrob", "createdAt": "2020-10-20T21:16:07Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String SCHEME_VAR = \"${scheme}://\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+\n+  private static final GlobalStateVars _singleton = new GlobalStateVars();\n+\n+  public static GlobalStateVars singleton() {\n+    return _singleton;\n+  }\n+\n+  private String urlScheme = System.getProperty(URL_SCHEME, HTTP);\n+\n+  // no new! you have to use the static singleton!\n+  private GlobalStateVars() {\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public void setUrlScheme(final String urlScheme) {\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme or null if the supplied url remains unchanged.\n+   */\n+  public String applyUrlSchemeIfChanged(final String url) {", "originalCommit": "a8f2ea35572d6829303f351d85a539d22c2fdc67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2MzQwNA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508863404", "bodyText": "yeah, it's ugly for sure, but wanted to capture the fact that the url didn't change ... how about Optional instead?", "author": "thelabdude", "createdAt": "2020-10-20T21:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NDU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0NDk1MA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508844950", "bodyText": "Use Objects.requireNonNull", "author": "madrob", "createdAt": "2020-10-20T21:16:47Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkCoreNodeProps.java", "diffHunk": "@@ -20,6 +20,9 @@\n   private ZkNodeProps nodeProps;\n   \n   public ZkCoreNodeProps(ZkNodeProps nodeProps) {\n+    if (nodeProps == null) {", "originalCommit": "a8f2ea35572d6829303f351d85a539d22c2fdc67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0OTg0NA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508849844", "bodyText": "I think it's clearer here if we only have a single return from the method, so we should fall through or have an else.", "author": "madrob", "createdAt": "2020-10-20T21:26:28Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkNodeProps.java", "diffHunk": "@@ -105,6 +111,17 @@ public static ZkNodeProps load(byte[] bytes) {\n \n   @Override\n   public void write(JSONWriter jsonWriter) {\n+    final String baseUrl = (String)propMap.get(ZkStateReader.BASE_URL_PROP);\n+    if (baseUrl != null && !baseUrl.startsWith(SCHEME_VAR)) {\n+      final int at = baseUrl.indexOf(\"://\");\n+      if (at != -1) {\n+        final String updatedUrl = SCHEME_VAR + baseUrl.substring(at+3);\n+        Map<String,Object> modMap = new LinkedHashMap<>(propMap);\n+        modMap.put(ZkStateReader.BASE_URL_PROP, updatedUrl);\n+        jsonWriter.write(modMap);", "originalCommit": "a8f2ea35572d6829303f351d85a539d22c2fdc67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MzUxMw==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508853513", "bodyText": "If we have an initially HTTP cluster, and then one node comes up with HTTPS, then that will bring down the rest of the cluster, right? I don't think we can do this rolling, however.", "author": "madrob", "createdAt": "2020-10-20T21:33:29Z", "path": "solr/core/src/java/org/apache/solr/core/ZkContainer.java", "diffHunk": "@@ -263,4 +275,27 @@ public void close() {\n   public ExecutorService getCoreZkRegisterExecutorService() {\n     return coreZkRegister;\n   }\n+\n+  private void setGlobalUrlScheme(final ZkController zkCtrl) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String urlScheme = zkCtrl.getZkStateReader().getClusterProperty(ZkStateReader.URL_SCHEME, null);\n+    if (StringUtils.isNotEmpty(urlScheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      GlobalStateVars.singleton().setUrlScheme(urlScheme);\n+    } else {\n+      final String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        // it's OK to set the cluster prop to https b/c we're making the cluster more secure, not less\n+        // wouldn't do this for http though\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. Updating the cluster property to match.\");", "originalCommit": "a8f2ea35572d6829303f351d85a539d22c2fdc67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg2ODkxNw==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508868917", "bodyText": "I'll just remove this, not strictly necessary (was trying to save the user some work but could have side-effects)", "author": "thelabdude", "createdAt": "2020-10-20T22:06:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MzUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NjIxMg==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508856212", "bodyText": "I don't think we want to encourage further use of this pattern. Let's call it something more specific like UrlSchemeState", "author": "madrob", "createdAt": "2020-10-20T21:38:59Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/GlobalStateVars.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public class GlobalStateVars {", "originalCommit": "a8f2ea35572d6829303f351d85a539d22c2fdc67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg3MDIyNQ==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508870225", "bodyText": "I agree, thanks for confirming ;-)", "author": "thelabdude", "createdAt": "2020-10-20T22:09:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1NjIxMg=="}], "type": "inlineReview"}, {"oid": "34e2a4636aba850bd99d2daed4d66d872ffb8fa5", "url": "https://github.com/apache/lucene-solr/commit/34e2a4636aba850bd99d2daed4d66d872ffb8fa5", "message": "First pass at fixing code review issues", "committedDate": "2020-10-20T22:15:33Z", "type": "commit"}, {"oid": "2573d464143daf699b0633f6fe010d1c8ed12645", "url": "https://github.com/apache/lucene-solr/commit/2573d464143daf699b0633f6fe010d1c8ed12645", "message": "Fix broken test", "committedDate": "2020-10-20T22:45:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODkwNTI2MA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r508905260", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method ZkStateReader.getLeaderUrl(...) indirectly reads without synchronization from cloud.UrlScheme.INSTANCE.urlScheme. Potentially races with write in method ZkStateReader.forciblyRefreshAllClusterStateSlow().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-10-20T23:49:27Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java", "diffHunk": "@@ -798,7 +799,11 @@ public boolean isClosed() {\n   }\n \n   public String getLeaderUrl(String collection, String shard, int timeout) throws InterruptedException {\n-    ZkCoreNodeProps props = new ZkCoreNodeProps(getLeaderRetry(collection, shard, timeout));\n+    Replica replica = getLeaderRetry(collection, shard, timeout);", "originalCommit": "34e2a4636aba850bd99d2daed4d66d872ffb8fa5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5da58b5cc6df98904faf31a2adda93445e0e310c", "url": "https://github.com/apache/lucene-solr/commit/5da58b5cc6df98904faf31a2adda93445e0e310c", "message": "WIP: Store https scheme in liveNode registration", "committedDate": "2020-10-22T00:04:45Z", "type": "commit"}, {"oid": "e7e32ef7c4542c7b375c9a1fa14e192320eeea8b", "url": "https://github.com/apache/lucene-solr/commit/e7e32ef7c4542c7b375c9a1fa14e192320eeea8b", "message": "Fix imports", "committedDate": "2020-10-22T00:06:52Z", "type": "commit"}, {"oid": "810523a23d66d27eae681203127fb070156c6665", "url": "https://github.com/apache/lucene-solr/commit/810523a23d66d27eae681203127fb070156c6665", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182", "committedDate": "2020-10-22T00:09:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTgyOTAzOQ==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r509829039", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method ZkController(...) indirectly writes to field noggit.JSONParser.devNull.buf outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-10-22T01:38:24Z", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -448,6 +447,11 @@ public boolean isClosed() {\n         return cc.isShutDown();\n       }});\n \n+    // setup the scheme before updating cluster state\n+    setGlobalUrlSchemeFromClusterProps(zkClient);", "originalCommit": "e7e32ef7c4542c7b375c9a1fa14e192320eeea8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c13c182671746b9db4c55b23a717959f2cee416d", "url": "https://github.com/apache/lucene-solr/commit/c13c182671746b9db4c55b23a717959f2cee416d", "message": "Store the scheme as data on the live node znode instead of changing the node name", "committedDate": "2020-10-22T20:10:54Z", "type": "commit"}, {"oid": "9cf0701a32e3bdb7b652f215427426968473ab76", "url": "https://github.com/apache/lucene-solr/commit/9cf0701a32e3bdb7b652f215427426968473ab76", "message": "Fix precommit fail", "committedDate": "2020-10-22T20:57:51Z", "type": "commit"}, {"oid": "11592a4cc6897c3a51dc9e15fb2a79f50b5c5a61", "url": "https://github.com/apache/lucene-solr/commit/11592a4cc6897c3a51dc9e15fb2a79f50b5c5a61", "message": "Revert unnecessary changes", "committedDate": "2020-10-22T21:45:28Z", "type": "commit"}, {"oid": "9920301e7aeaf1e7a821c6e488f5818bfd425bdc", "url": "https://github.com/apache/lucene-solr/commit/9920301e7aeaf1e7a821c6e488f5818bfd425bdc", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182", "committedDate": "2020-10-30T15:09:09Z", "type": "commit"}, {"oid": "3dcec628122e0f2f34c3e7db7ca8dbeefca4cff8", "url": "https://github.com/apache/lucene-solr/commit/3dcec628122e0f2f34c3e7db7ca8dbeefca4cff8", "message": "First pass at not storing the base_url but deriving it from node_name if possible", "committedDate": "2020-11-02T23:54:58Z", "type": "commit"}, {"oid": "583e6c22d7b123c18b8e3b67e047f2ffab7ddfcb", "url": "https://github.com/apache/lucene-solr/commit/583e6c22d7b123c18b8e3b67e047f2ffab7ddfcb", "message": "Remove unused import", "committedDate": "2020-11-02T23:59:02Z", "type": "commit"}, {"oid": "dcde2ed0d668bfa97fb03f6ca88835de1e56a1d4", "url": "https://github.com/apache/lucene-solr/commit/dcde2ed0d668bfa97fb03f6ca88835de1e56a1d4", "message": "call assumeWorkingMockito", "committedDate": "2020-11-03T00:01:33Z", "type": "commit"}, {"oid": "42801149bd331e3b5554456d7e8f318e219e72e7", "url": "https://github.com/apache/lucene-solr/commit/42801149bd331e3b5554456d7e8f318e219e72e7", "message": "Remove unused import", "committedDate": "2020-11-03T00:02:49Z", "type": "commit"}, {"oid": "f01f2ed45cf4fb2602992b722edf6940a759c609", "url": "https://github.com/apache/lucene-solr/commit/f01f2ed45cf4fb2602992b722edf6940a759c609", "message": "Make urlScheme effectively immutable on the server-side", "committedDate": "2020-11-03T18:52:03Z", "type": "commit"}, {"oid": "178696040d8cecc1681e30bfa63326c0ecc0341c", "url": "https://github.com/apache/lucene-solr/commit/178696040d8cecc1681e30bfa63326c0ecc0341c", "message": "Remove unused import", "committedDate": "2020-11-03T18:54:47Z", "type": "commit"}, {"oid": "d278d82c92383fdd74ad9aea429ff3e2581f4283", "url": "https://github.com/apache/lucene-solr/commit/d278d82c92383fdd74ad9aea429ff3e2581f4283", "message": "Add comment for tricky area of urlScheme related logic", "committedDate": "2020-11-03T18:59:01Z", "type": "commit"}, {"oid": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "url": "https://github.com/apache/lucene-solr/commit/6b39af9e4b6c823d7a55d458efeca98ae4bee108", "message": "Update SSL migration test to perform a rolling restart", "committedDate": "2020-11-04T18:55:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjgwOA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612808", "bodyText": "NULL_DEREFERENCE:  object baseUrl last assigned on line 30 could be null and is dereferenced by call to getCoreUrl(...) at line 32.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:29Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkCoreNodeProps.java", "diffHunk": "@@ -16,15 +16,20 @@\n  */\n package org.apache.solr.common.cloud;\n \n+import java.util.Objects;\n+\n public class ZkCoreNodeProps {\n   private ZkNodeProps nodeProps;\n   \n   public ZkCoreNodeProps(ZkNodeProps nodeProps) {\n+    Objects.requireNonNull(nodeProps, \"nodeProps should not be null\");\n     this.nodeProps = nodeProps;\n   }\n   \n   public String getCoreUrl() {\n-    return getCoreUrl(nodeProps.getStr(ZkStateReader.BASE_URL_PROP), nodeProps.getStr(ZkStateReader.CORE_NAME_PROP));\n+    String baseUrl = nodeProps.getStr(ZkStateReader.BASE_URL_PROP);\n+    Objects.requireNonNull(baseUrl, \"No base_url in ZkNodeProps! \"+nodeProps.toString());\n+    return getCoreUrl(baseUrl, nodeProps.getStr(ZkStateReader.CORE_NAME_PROP));", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg0NA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612844", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.applyUrlScheme(...) indirectly reads without synchronization from this.zkClient. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:32Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg1MA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612850", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.applyUrlScheme(...) reads without synchronization from this.liveNodes. Potentially races with write in method UrlScheme.onChange(...).\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:34Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg2Ng==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612866", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.applyUrlScheme(...) reads without synchronization from this.urlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:35Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg3OA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612878", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.getBaseUrlForNodeName(...) indirectly reads without synchronization from this.liveNodes. Potentially races with write in method UrlScheme.onChange(...).\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:36Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg4Mw==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612883", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.getUrlScheme() reads without synchronization from this.urlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:38Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjg5OA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612898", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.getUrlSchemeForNodeName(...) indirectly reads without synchronization from this.liveNodes. Potentially races with write in method UrlScheme.onChange(...).\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:39Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjkxOA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612918", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.isOnServer() reads without synchronization from this.zkClient. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:40Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjkyNw==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612927", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.onChange(...) reads without synchronization from this.useLiveNodesUrlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:41Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;\n+  }\n+\n+  @Override\n+  public synchronized boolean onChange(SortedSet<String> oldLiveNodes, SortedSet<String> newLiveNodes) {\n+    if (useLiveNodesUrlScheme) {\n+      liveNodes = newLiveNodes;\n+      if (liveNodes != null) {\n+        // we only need to clear the cached HTTP entries, keep the HTTPS\n+        // as we don't really support a graceful downgrade from HTTPS -> HTTP\n+        liveNodes.forEach(n -> {\n+          if (HTTP.equals(nodeSchemeCache.get(n))) {\n+            nodeSchemeCache.remove(n, HTTP);\n+          }\n+        });\n+      } else {\n+        nodeSchemeCache.clear();\n+      }\n+    } else {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;\n+    }\n+    return !useLiveNodesUrlScheme;\n+  }\n+\n+  private String applyUrlSchemeFromLiveNodes(final String url) {\n+    String updatedUrl = null;\n+    Optional<String> maybeFromLiveNode = getSchemeFromLiveNode(getNodeNameFromUrl(url));\n+    if (maybeFromLiveNode.isPresent()) {\n+      final int at = url.indexOf(\"://\");\n+      // replace the scheme on the url with the one from the matching live node entry\n+      updatedUrl = maybeFromLiveNode.get() + ((at != -1) ? url.substring(at) : \"://\" + url);\n+    }\n+    return updatedUrl;\n+  }\n+\n+  // Gets the urlScheme from the matching live node entry for this URL\n+  private Optional<String> getSchemeFromLiveNode(final String nodeName) {\n+    return (liveNodes != null && liveNodes.contains(nodeName)) ? Optional.ofNullable(getSchemeForLiveNode(nodeName)) : Optional.empty();\n+  }\n+\n+  private String getNodeNameFromUrl(String url) {\n+    final int at = url.indexOf(\"://\");\n+    if (at != -1) {\n+      url = url.substring(at+3);\n+    }\n+    String hostAndPort = url;\n+    String context = \"\";\n+    int slashAt = url.indexOf('/');\n+    if (slashAt != -1) {\n+      hostAndPort = url.substring(0, slashAt);\n+      // has context in url?s\n+      if (slashAt < url.length()-1) {\n+        context = url.substring(slashAt + 1);\n+      }\n+    }\n+    if (!context.isEmpty()) {\n+      context = URLEncoder.encode(trimLeadingAndTrailingSlashes(context), StandardCharsets.UTF_8);\n+    }\n+    return hostAndPort + \"_\" + context;\n+  }\n+\n+  private String trimLeadingAndTrailingSlashes(final String in) {\n+    String out = in;\n+    if (out.startsWith(\"/\")) {\n+      out = out.substring(1);\n+    }\n+    if (out.endsWith(\"/\")) {\n+      out = out.substring(0, out.length() - 1);\n+    }\n+    return out;\n+  }\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    useLiveNodesUrlScheme = \"true\".equals(properties.getOrDefault(USE_LIVENODES_URL_SCHEME, \"false\"));\n+    if (!useLiveNodesUrlScheme) {", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjkzNw==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612937", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method UrlScheme.onChange(...) writes to field this.liveNodes outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:42Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;\n+  }\n+\n+  @Override\n+  public synchronized boolean onChange(SortedSet<String> oldLiveNodes, SortedSet<String> newLiveNodes) {\n+    if (useLiveNodesUrlScheme) {\n+      liveNodes = newLiveNodes;\n+      if (liveNodes != null) {\n+        // we only need to clear the cached HTTP entries, keep the HTTPS\n+        // as we don't really support a graceful downgrade from HTTPS -> HTTP\n+        liveNodes.forEach(n -> {\n+          if (HTTP.equals(nodeSchemeCache.get(n))) {\n+            nodeSchemeCache.remove(n, HTTP);\n+          }\n+        });\n+      } else {\n+        nodeSchemeCache.clear();\n+      }\n+    } else {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;\n+    }\n+    return !useLiveNodesUrlScheme;\n+  }\n+\n+  private String applyUrlSchemeFromLiveNodes(final String url) {\n+    String updatedUrl = null;\n+    Optional<String> maybeFromLiveNode = getSchemeFromLiveNode(getNodeNameFromUrl(url));\n+    if (maybeFromLiveNode.isPresent()) {\n+      final int at = url.indexOf(\"://\");\n+      // replace the scheme on the url with the one from the matching live node entry\n+      updatedUrl = maybeFromLiveNode.get() + ((at != -1) ? url.substring(at) : \"://\" + url);\n+    }\n+    return updatedUrl;\n+  }\n+\n+  // Gets the urlScheme from the matching live node entry for this URL\n+  private Optional<String> getSchemeFromLiveNode(final String nodeName) {\n+    return (liveNodes != null && liveNodes.contains(nodeName)) ? Optional.ofNullable(getSchemeForLiveNode(nodeName)) : Optional.empty();\n+  }\n+\n+  private String getNodeNameFromUrl(String url) {\n+    final int at = url.indexOf(\"://\");\n+    if (at != -1) {\n+      url = url.substring(at+3);\n+    }\n+    String hostAndPort = url;\n+    String context = \"\";\n+    int slashAt = url.indexOf('/');\n+    if (slashAt != -1) {\n+      hostAndPort = url.substring(0, slashAt);\n+      // has context in url?s\n+      if (slashAt < url.length()-1) {\n+        context = url.substring(slashAt + 1);\n+      }\n+    }\n+    if (!context.isEmpty()) {\n+      context = URLEncoder.encode(trimLeadingAndTrailingSlashes(context), StandardCharsets.UTF_8);\n+    }\n+    return hostAndPort + \"_\" + context;\n+  }\n+\n+  private String trimLeadingAndTrailingSlashes(final String in) {\n+    String out = in;\n+    if (out.startsWith(\"/\")) {\n+      out = out.substring(1);\n+    }\n+    if (out.endsWith(\"/\")) {\n+      out = out.substring(0, out.length() - 1);\n+    }\n+    return out;\n+  }\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    useLiveNodesUrlScheme = \"true\".equals(properties.getOrDefault(USE_LIVENODES_URL_SCHEME, \"false\"));\n+    if (!useLiveNodesUrlScheme) {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjk0NA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612944", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method UrlScheme.onChange(...) writes to field this.useLiveNodesUrlScheme outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:44Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;\n+  }\n+\n+  public String getBaseUrlForNodeName(String nodeName) {\n+    Objects.requireNonNull(nodeName,\"node_name should not be null\");\n+    if (nodeName.indexOf('_') == -1) {\n+      nodeName += '_'; // underscore required to indicate context\n+    }\n+    return Utils.getBaseUrlForNodeName(nodeName, getUrlSchemeForNodeName(nodeName));\n+  }\n+\n+  public String getUrlSchemeForNodeName(final String nodeName) {\n+    return useLiveNodesUrlScheme ? getSchemeFromLiveNode(nodeName).orElse(urlScheme) : urlScheme;\n+  }\n+\n+  /**\n+   * Given a URL with a replaceable parameter for the scheme, return a new URL with the correct scheme applied.\n+   * @param url A URL to change the scheme (http|https)\n+   * @return A new URL with the correct scheme\n+   */\n+  public String applyUrlScheme(final String url) {\n+    Objects.requireNonNull(url, \"URL must not be null!\");\n+\n+    String updatedUrl;\n+    if (useLiveNodesUrlScheme && liveNodes != null) {\n+      updatedUrl = applyUrlSchemeFromLiveNodes(url);\n+      if (updatedUrl != null) {\n+        return updatedUrl;\n+      }\n+    }\n+\n+    // heal an incorrect scheme if needed, otherwise return null indicating no change\n+    final int at = url.indexOf(\"://\");\n+    return (at == -1) ? (urlScheme + \"://\" + url) : urlScheme + url.substring(at);\n+  }\n+\n+  public String getUrlScheme() {\n+    return urlScheme;\n+  }\n+\n+  @Override\n+  public synchronized boolean onChange(SortedSet<String> oldLiveNodes, SortedSet<String> newLiveNodes) {\n+    if (useLiveNodesUrlScheme) {\n+      liveNodes = newLiveNodes;\n+      if (liveNodes != null) {\n+        // we only need to clear the cached HTTP entries, keep the HTTPS\n+        // as we don't really support a graceful downgrade from HTTPS -> HTTP\n+        liveNodes.forEach(n -> {\n+          if (HTTP.equals(nodeSchemeCache.get(n))) {\n+            nodeSchemeCache.remove(n, HTTP);\n+          }\n+        });\n+      } else {\n+        nodeSchemeCache.clear();\n+      }\n+    } else {\n+      nodeSchemeCache.clear();\n+      liveNodes = null;\n+    }\n+    return !useLiveNodesUrlScheme;\n+  }\n+\n+  private String applyUrlSchemeFromLiveNodes(final String url) {\n+    String updatedUrl = null;\n+    Optional<String> maybeFromLiveNode = getSchemeFromLiveNode(getNodeNameFromUrl(url));\n+    if (maybeFromLiveNode.isPresent()) {\n+      final int at = url.indexOf(\"://\");\n+      // replace the scheme on the url with the one from the matching live node entry\n+      updatedUrl = maybeFromLiveNode.get() + ((at != -1) ? url.substring(at) : \"://\" + url);\n+    }\n+    return updatedUrl;\n+  }\n+\n+  // Gets the urlScheme from the matching live node entry for this URL\n+  private Optional<String> getSchemeFromLiveNode(final String nodeName) {\n+    return (liveNodes != null && liveNodes.contains(nodeName)) ? Optional.ofNullable(getSchemeForLiveNode(nodeName)) : Optional.empty();\n+  }\n+\n+  private String getNodeNameFromUrl(String url) {\n+    final int at = url.indexOf(\"://\");\n+    if (at != -1) {\n+      url = url.substring(at+3);\n+    }\n+    String hostAndPort = url;\n+    String context = \"\";\n+    int slashAt = url.indexOf('/');\n+    if (slashAt != -1) {\n+      hostAndPort = url.substring(0, slashAt);\n+      // has context in url?s\n+      if (slashAt < url.length()-1) {\n+        context = url.substring(slashAt + 1);\n+      }\n+    }\n+    if (!context.isEmpty()) {\n+      context = URLEncoder.encode(trimLeadingAndTrailingSlashes(context), StandardCharsets.UTF_8);\n+    }\n+    return hostAndPort + \"_\" + context;\n+  }\n+\n+  private String trimLeadingAndTrailingSlashes(final String in) {\n+    String out = in;\n+    if (out.startsWith(\"/\")) {\n+      out = out.substring(1);\n+    }\n+    if (out.endsWith(\"/\")) {\n+      out = out.substring(0, out.length() - 1);\n+    }\n+    return out;\n+  }\n+\n+  @Override\n+  public boolean onChange(Map<String, Object> properties) {\n+    useLiveNodesUrlScheme = \"true\".equals(properties.getOrDefault(USE_LIVENODES_URL_SCHEME, \"false\"));", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYxMjk1Mg==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517612952", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UrlScheme.useLiveNodesUrlScheme() reads without synchronization from this.useLiveNodesUrlScheme. Potentially races with write in method UrlScheme.reset().\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-04T20:29:45Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global vars in persisted state, such as the urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private String urlScheme = HTTP;\n+  private boolean useLiveNodesUrlScheme = false;\n+  private SortedSet<String> liveNodes = null;\n+  private SolrZkClient zkClient = null;\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public synchronized void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing\n+   * the value on-the-fly.\n+   * @param urlScheme The new URL scheme, either http or https.\n+   */\n+  public synchronized void setUrlScheme(final String urlScheme) {\n+    if (!this.urlScheme.equals(urlScheme) && this.zkClient != null) {\n+      throw new IllegalStateException(\"Global, immutable 'urlScheme' already set for this node!\");\n+    }\n+\n+    if (HTTP.equals(urlScheme) || HTTPS.equals(urlScheme)) {\n+      this.urlScheme = urlScheme;\n+    } else {\n+      throw new IllegalArgumentException(\"Invalid urlScheme: \"+urlScheme);\n+    }\n+  }\n+\n+  public boolean useLiveNodesUrlScheme() {\n+    return useLiveNodesUrlScheme;", "originalCommit": "6b39af9e4b6c823d7a55d458efeca98ae4bee108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8436a396db768840376193ff401ec9c928de7962", "url": "https://github.com/apache/lucene-solr/commit/8436a396db768840376193ff401ec9c928de7962", "message": "Restart leader last to test http connections during TLS upgrade", "committedDate": "2020-11-04T22:50:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxMjQ3Mg==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r517712472", "bodyText": "NULL_DEREFERENCE:  object returned by getBaseUrl() could be null and is dereferenced by call to getCoreUrl(...) at line 237.", "author": "sonatype-lift", "createdAt": "2020-11-05T00:34:03Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/Replica.java", "diffHunk": "@@ -235,11 +234,11 @@ public String getName() {\n   }\n \n   public String getCoreUrl() {\n-    return ZkCoreNodeProps.getCoreUrl(getStr(ZkStateReader.BASE_URL_PROP), core);\n+    return ZkCoreNodeProps.getCoreUrl(getBaseUrl(), core);", "originalCommit": "8436a396db768840376193ff401ec9c928de7962", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ad94b03fbb1a84107f4fbfdf9d7d6e37c6cdf1e8", "url": "https://github.com/apache/lucene-solr/commit/ad94b03fbb1a84107f4fbfdf9d7d6e37c6cdf1e8", "message": "Clean-up node_name handling in OverseerTest", "committedDate": "2020-11-05T00:37:38Z", "type": "commit"}, {"oid": "377370b2cc19cbb8044a16b86d9e29ef9707c2b5", "url": "https://github.com/apache/lucene-solr/commit/377370b2cc19cbb8044a16b86d9e29ef9707c2b5", "message": "check null issue found by muse", "committedDate": "2020-11-05T15:03:02Z", "type": "commit"}, {"oid": "61e7122c34c7df694a5e452a0f3db0831e566575", "url": "https://github.com/apache/lucene-solr/commit/61e7122c34c7df694a5e452a0f3db0831e566575", "message": "Supply base_url in ClusterState API response used by Admin UI", "committedDate": "2020-11-05T18:57:41Z", "type": "commit"}, {"oid": "fe7385b8af9b7b83bcc606efae495bdd1c03a3d0", "url": "https://github.com/apache/lucene-solr/commit/fe7385b8af9b7b83bcc606efae495bdd1c03a3d0", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182", "committedDate": "2020-11-05T19:15:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM1NzkzMg==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r518357932", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method ZkController.getLeaderProps(...) indirectly writes to field noggit.JSONParser.devNull.buf outside of synchronization.\nReporting because another access to the same memory occurs on a background thread, although this access may not.", "author": "sonatype-lift", "createdAt": "2020-11-05T20:53:42Z", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -1401,8 +1420,7 @@ public ZkCoreNodeProps getLeaderProps(final String collection,\n         byte[] data = zkClient.getData(\n             ZkStateReader.getShardLeadersPath(collection, slice), null, null,\n             true);\n-        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(\n-            ZkNodeProps.load(data));\n+        ZkCoreNodeProps leaderProps = new ZkCoreNodeProps(ZkNodeProps.load(data));", "originalCommit": "fe7385b8af9b7b83bcc606efae495bdd1c03a3d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzExNzQzMA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r523117430", "bodyText": "that'll teach me to fix weird whitespacing!", "author": "thelabdude", "createdAt": "2020-11-13T17:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODM1NzkzMg=="}], "type": "inlineReview"}, {"oid": "7bfed262c6cb036d3268ac3b29ee10ea0effe8c5", "url": "https://github.com/apache/lucene-solr/commit/7bfed262c6cb036d3268ac3b29ee10ea0effe8c5", "message": "Revert changes un-related to this PR", "committedDate": "2020-11-05T20:55:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1MTg4OQ==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r520351889", "bodyText": "Should we instead mention that Solr doesn't support partial TLS enabled clusters?", "author": "anshumg", "createdAt": "2020-11-10T07:46:21Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ *\n+ * Client applications should not use this class directly; it is only included in SolrJ because Replica\n+ * and ZkNodeProps depend on it.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private volatile String urlScheme = HTTP;\n+  private volatile boolean useLiveNodesUrlScheme = false;\n+  private volatile SortedSet<String> liveNodes = null;\n+  private volatile SolrZkClient zkClient = null;\n+\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");", "originalCommit": "7bfed262c6cb036d3268ac3b29ee10ea0effe8c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM1MjE4NQ==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r520352185", "bodyText": "\ud83d\udc4d\ud83c\udffd", "author": "anshumg", "createdAt": "2020-11-10T07:47:02Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/UrlScheme.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.SortedSet;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.solr.common.util.Utils;\n+import org.apache.zookeeper.KeeperException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.solr.common.cloud.ZkStateReader.URL_SCHEME;\n+\n+/**\n+ * Singleton access to global urlScheme, which although is stored in ZK as a cluster property\n+ * really should be treated like a static global that is set at initialization and not altered after.\n+ *\n+ * Client applications should not use this class directly; it is only included in SolrJ because Replica\n+ * and ZkNodeProps depend on it.\n+ */\n+public enum UrlScheme implements LiveNodesListener, ClusterPropertiesListener {\n+  INSTANCE;\n+\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  public static final String HTTP = \"http\";\n+  public static final String HTTPS = \"https\";\n+  public static final String HTTPS_PORT_PROP = \"solr.jetty.https.port\";\n+  public static final String USE_LIVENODES_URL_SCHEME = \"ext.useLiveNodesUrlScheme\";\n+\n+  private volatile String urlScheme = HTTP;\n+  private volatile boolean useLiveNodesUrlScheme = false;\n+  private volatile SortedSet<String> liveNodes = null;\n+  private volatile SolrZkClient zkClient = null;\n+\n+  private final ConcurrentMap<String,String> nodeSchemeCache = new ConcurrentHashMap<>();\n+\n+  /**\n+   * Called during ZkController initialization to set the urlScheme based on cluster properties.\n+   * @param client The SolrZkClient needed to read cluster properties from ZK.\n+   * @throws IOException If a connection or other I/O related error occurs while reading from ZK.\n+   */\n+  public void initFromClusterProps(final SolrZkClient client) throws IOException {\n+    this.zkClient = client;\n+\n+    // Have to go directly to the cluster props b/c this needs to happen before ZkStateReader does its thing\n+    ClusterProperties clusterProps = new ClusterProperties(client);\n+    this.useLiveNodesUrlScheme =\n+      \"true\".equals(clusterProps.getClusterProperty(UrlScheme.USE_LIVENODES_URL_SCHEME, \"false\"));\n+    setUrlSchemeFromClusterProps(clusterProps.getClusterProperties());\n+  }\n+\n+  private void setUrlSchemeFromClusterProps(Map<String,Object> props) {\n+    // Set the global urlScheme from cluster prop or if that is not set, look at the urlScheme sys prop\n+    final String scheme = (String)props.get(ZkStateReader.URL_SCHEME);\n+    if (StringUtils.isNotEmpty(scheme)) {\n+      // track the urlScheme in a global so we can use it during ZK read / write operations for cluster state objects\n+      this.urlScheme = HTTPS.equals(scheme) ? HTTPS : HTTP;\n+    } else {\n+      String urlSchemeFromSysProp = System.getProperty(URL_SCHEME, HTTP);\n+      if (HTTPS.equals(urlSchemeFromSysProp)) {\n+        log.warn(\"Cluster property 'urlScheme' not set but system property is set to 'https'. \" +\n+            \"You should set the cluster property and restart all nodes for consistency.\");\n+      }\n+      // TODO: We may not want this? See: https://issues.apache.org/jira/browse/SOLR-10202\n+      this.urlScheme = HTTPS.equals(urlSchemeFromSysProp) ? HTTPS : HTTP;\n+    }\n+  }\n+\n+  public boolean isOnServer() {\n+    return zkClient != null;\n+  }\n+\n+  /**\n+   * Set the global urlScheme variable; ideally this should be immutable once set, but some tests rely on changing", "originalCommit": "7bfed262c6cb036d3268ac3b29ee10ea0effe8c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b8045135849e1da0e0945d76da33e7adbe8a82c2", "url": "https://github.com/apache/lucene-solr/commit/b8045135849e1da0e0945d76da33e7adbe8a82c2", "message": "Remove feature to get urlScheme from live_nodes", "committedDate": "2020-11-13T17:23:38Z", "type": "commit"}, {"oid": "eca9275e282e697edeffc28a63a22b6462c4f427", "url": "https://github.com/apache/lucene-solr/commit/eca9275e282e697edeffc28a63a22b6462c4f427", "message": "Remove unused import", "committedDate": "2020-11-13T17:30:19Z", "type": "commit"}, {"oid": "db58e20554a82cf5539f2dd08fa58ce12e03f267", "url": "https://github.com/apache/lucene-solr/commit/db58e20554a82cf5539f2dd08fa58ce12e03f267", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182", "committedDate": "2020-11-13T20:14:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI0ODY1MA==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r523248650", "bodyText": "NULL_DEREFERENCE:  object leaderUrl last assigned on line 348 could be null and is dereferenced at line 351.", "author": "sonatype-lift", "createdAt": "2020-11-13T21:45:21Z", "path": "solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java", "diffHunk": "@@ -344,13 +344,8 @@ final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedExce\n                                                                                             // though\n       try {\n         CloudDescriptor cloudDesc = this.coreDescriptor.getCloudDescriptor();\n-        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(\n-            cloudDesc.getCollectionName(), cloudDesc.getShardId());\n-        final String leaderBaseUrl = leaderprops.getStr(ZkStateReader.BASE_URL_PROP);\n-        final String leaderCoreName = leaderprops.getStr(ZkStateReader.CORE_NAME_PROP);\n-\n-        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderBaseUrl, leaderCoreName);\n-\n+        ZkNodeProps leaderprops = zkStateReader.getLeaderRetry(cloudDesc.getCollectionName(), cloudDesc.getShardId());\n+        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderprops);\n         String ourUrl = ZkCoreNodeProps.getCoreUrl(baseUrl, coreName);\n \n         boolean isLeader = leaderUrl.equals(ourUrl); // TODO: We can probably delete most of this code if we say this", "originalCommit": "db58e20554a82cf5539f2dd08fa58ce12e03f267", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "be36c943f31364004a969c20d750db36427b13c0", "url": "https://github.com/apache/lucene-solr/commit/be36c943f31364004a969c20d750db36427b13c0", "message": "Fix issue found by muse", "committedDate": "2020-11-13T22:24:09Z", "type": "commit"}, {"oid": "debe339768a6a53bd51960977f1fc171cfe028b7", "url": "https://github.com/apache/lucene-solr/commit/debe339768a6a53bd51960977f1fc171cfe028b7", "message": "Update changes.txt", "committedDate": "2020-11-17T15:06:44Z", "type": "commit"}, {"oid": "ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf", "url": "https://github.com/apache/lucene-solr/commit/ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182", "committedDate": "2020-11-17T15:07:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTgwODA4Mg==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r525808082", "bodyText": "Java8 doesn't have URLEncoder.encode(String, Charset). Also, it'd through the exception on 8x.\nI like it this way, just saying that you might have to remember that when merging.", "author": "anshumg", "createdAt": "2020-11-18T04:48:44Z", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -2131,12 +2128,7 @@ public LeaderElector getOverseerElector() {\n   static String generateNodeName(final String hostName,\n                                  final String hostPort,\n                                  final String hostContext) {\n-    try {\n-      return hostName + ':' + hostPort + '_' +\n-          URLEncoder.encode(trimLeadingAndTrailingSlashes(hostContext), \"UTF-8\");\n-    } catch (UnsupportedEncodingException e) {\n-      throw new Error(\"JVM Does not seem to support UTF-8\", e);\n-    }\n+    return hostName + ':' + hostPort + '_' + URLEncoder.encode(trimLeadingAndTrailingSlashes(hostContext), StandardCharsets.UTF_8);", "originalCommit": "ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTgwOTkzMw==", "url": "https://github.com/apache/lucene-solr/pull/2010#discussion_r525809933", "bodyText": "Can you please add a space around +.", "author": "anshumg", "createdAt": "2020-11-18T04:50:39Z", "path": "solr/core/src/test/org/apache/solr/cloud/LeaderElectionTest.java", "diffHunk": "@@ -414,6 +425,11 @@ private void waitForLeader(List<ClientThread> threads, int seq)\n \n   private int getLeaderThread() throws KeeperException, InterruptedException {\n     String leaderUrl = getLeaderUrl(\"collection1\", \"shard1\");\n+    // strip off the scheme\n+    final int at = leaderUrl.indexOf(\"://\");\n+    if (at != -1) {\n+      leaderUrl = leaderUrl.substring(at+3);", "originalCommit": "ac1fc4c7ad27dd0dc8f08631c7aebc2a385cafcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f155c1cccde26a3aeacc4df5aa63430ec9738998", "url": "https://github.com/apache/lucene-solr/commit/f155c1cccde26a3aeacc4df5aa63430ec9738998", "message": "Fix whitespacing around plus sign", "committedDate": "2020-11-30T17:31:23Z", "type": "commit"}, {"oid": "7d09ef75847e03a42f673e218edae33d00a49541", "url": "https://github.com/apache/lucene-solr/commit/7d09ef75847e03a42f673e218edae33d00a49541", "message": "Merge remote-tracking branch 'asf/master' into jira/solr-12182", "committedDate": "2020-11-30T17:31:29Z", "type": "commit"}]}