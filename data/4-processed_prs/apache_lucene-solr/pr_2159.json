{"pr_number": 2159, "pr_title": "SOLR-14923: Nested docs indexing performance.", "pr_createdAt": "2020-12-21T21:46:38Z", "pr_url": "https://github.com/apache/lucene-solr/pull/2159", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTEzMTE1OQ==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r551131159", "bodyText": "NULL_DEREFERENCE:  object returned by field.getFirstValue() could be null and is dereferenced at line 205.", "author": "sonatype-lift", "createdAt": "2021-01-04T06:04:05Z", "path": "solr/core/src/java/org/apache/solr/update/AddUpdateCommand.java", "diffHunk": "@@ -95,121 +124,129 @@ public SolrInputDocument getSolrInputDocument() {\n    }\n \n   /**\n-   * Creates and returns a lucene Document to index.\n-   * Nested documents, if found, will cause an exception to be thrown.  Call {@link #getLuceneDocsIfNested()} for that.\n+   * Creates and returns a lucene Document for in-place update.\n+   * The SolrInputDocument itself may be modified, which will be reflected in the update log.\n    * Any changes made to the returned Document will not be reflected in the SolrInputDocument, or future calls to this\n    * method.\n-   * Note that the behavior of this is sensitive to {@link #isInPlaceUpdate()}.*/\n-   public Document getLuceneDocument() {\n-     final boolean ignoreNestedDocs = false; // throw an exception if found\n-     SolrInputDocument solrInputDocument = getSolrInputDocument();\n-     if (!isInPlaceUpdate() && getReq().getSchema().isUsableForChildDocs()) {\n-       addRootField(solrInputDocument, getRootIdUsingRouteParam());\n-     }\n-     return DocumentBuilder.toDocument(solrInputDocument, req.getSchema(), isInPlaceUpdate(), ignoreNestedDocs);\n-   }\n-\n-  /** Returns the indexed ID for this document.  The returned BytesRef is retained across multiple calls, and should not be modified. */\n-   public BytesRef getIndexedId() {\n-     if (indexedId == null) {\n-       IndexSchema schema = req.getSchema();\n-       SchemaField sf = schema.getUniqueKeyField();\n-       if (sf != null) {\n-         if (solrDoc != null) {\n-           SolrInputField field = solrDoc.getField(sf.getName());\n-\n-           int count = field==null ? 0 : field.getValueCount();\n-           if (count == 0) {\n-             if (overwrite) {\n-               throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Document is missing mandatory uniqueKey field: \" + sf.getName());\n-             }\n-           } else if (count  > 1) {\n-             throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Document contains multiple values for uniqueKey field: \" + field);\n-           } else {\n-             BytesRefBuilder b = new BytesRefBuilder();\n-             sf.getType().readableToIndexed(field.getFirstValue().toString(), b);\n-             indexedId = b.get();\n-           }\n-         }\n-       }\n+   */\n+   Document makeLuceneDocForInPlaceUpdate() {\n+     // perhaps this should move to UpdateHandler or DocumentBuilder?\n+     assert isInPlaceUpdate();\n+     if (req.getSchema().isUsableForChildDocs() && solrDoc.getField(IndexSchema.ROOT_FIELD_NAME) == null) {\n+       solrDoc.setField(IndexSchema.ROOT_FIELD_NAME, getIndexedIdStr());\n      }\n-     return indexedId;\n-   }\n-\n-   public void setIndexedId(BytesRef indexedId) {\n-     this.indexedId = indexedId;\n+     final boolean forInPlaceUpdate = true;\n+     final boolean ignoreNestedDocs = false; // throw an exception if found\n+     return DocumentBuilder.toDocument(solrDoc, req.getSchema(), forInPlaceUpdate, ignoreNestedDocs);\n    }\n \n-   public String getPrintableId() {\n-    if (req != null) {\n-      IndexSchema schema = req.getSchema();\n-      SchemaField sf = schema.getUniqueKeyField();\n-      if (solrDoc != null && sf != null) {\n-        SolrInputField field = solrDoc.getField(sf.getName());\n-        if (field != null) {\n-          return field.getFirstValue().toString();\n-        }\n-      }\n-    }\n-     return \"(null)\";\n-   }\n+  /**\n+   * Returns the indexed ID for this document, or the root ID for nested documents.\n+   *\n+   * @return possibly null if there's no uniqueKey field\n+   */\n+  public String getIndexedIdStr() {\n+    extractIdsIfNeeded();\n+    return indexedIdStr;\n+  }\n \n   /**\n+   * Returns the indexed ID for this document, or the root ID for nested documents. The returned\n+   * BytesRef should be treated as immutable. It will not be re-used/modified for additional docs.\n    *\n-   * @return value of _route_ param({@link ShardParams#_ROUTE_}), otherwise doc id.\n+   * @return possibly null if there's no uniqueKey field\n    */\n-  public String getRootIdUsingRouteParam() {\n-     return req.getParams().get(ShardParams._ROUTE_, getHashableId());\n-   }\n+  public BytesRef getIndexedId() {\n+    extractIdsIfNeeded();\n+    return indexedId;\n+  }\n \n   /**\n-   * @return String id to hash\n+   * Returns the ID of the doc itself, possibly different from {@link #getIndexedIdStr()} which\n+   * points to the root doc.\n+   *\n+   * @return possibly null if there's no uniqueKey field\n    */\n-  public String getHashableId() {\n+  public String getChildDocIdStr() {\n+    extractIdsIfNeeded();\n+    return childDocIdStr;\n+  }\n+\n+  /** The ID for logging purposes. */\n+  public String getPrintableId() {\n+    extractIdsIfNeeded();\n+    if (indexedIdStr == null) {\n+      return \"(null)\";\n+    } else if (indexedIdStr.equals(childDocIdStr)) {\n+      return indexedIdStr;\n+    } else {\n+      return childDocIdStr + \" (root=\" + indexedIdStr + \")\";\n+    }\n+  }\n+\n+  private void extractIdsIfNeeded() {\n+    if (indexedId != null) {\n+      return;\n+    }\n     IndexSchema schema = req.getSchema();\n     SchemaField sf = schema.getUniqueKeyField();\n     if (sf != null) {\n       if (solrDoc != null) {\n         SolrInputField field = solrDoc.getField(sf.getName());\n-\n-        int count = field == null ? 0 : field.getValueCount();\n+        // check some uniqueKey constraints\n+        int count = field==null ? 0 : field.getValueCount();\n         if (count == 0) {\n           if (overwrite) {\n-            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-                \"Document is missing mandatory uniqueKey field: \"\n-                    + sf.getName());\n+            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Document is missing mandatory uniqueKey field: \" + sf.getName());\n           }\n-        } else if (count > 1) {\n-          throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n-              \"Document contains multiple values for uniqueKey field: \" + field);\n+        } else if (count  > 1) {\n+          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Document contains multiple values for uniqueKey field: \" + field);\n         } else {\n-          return field.getFirstValue().toString();\n+          this.childDocIdStr = field.getFirstValue().toString();", "originalCommit": "6f3854058969475d99ad582097d702010f5e0bf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTEzMTE2Mw==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r551131163", "bodyText": "THREAD_SAFETY_VIOLATION:  Read/Write race. Non-private method UpdateLog.add(...) indirectly reads without synchronization from container cmd.solrDoc._fields via call to Map.get(...). Potentially races with write in method UpdateLog.add(...).\nReporting because this access may occur on a background thread.", "author": "sonatype-lift", "createdAt": "2021-01-04T06:04:07Z", "path": "solr/core/src/java/org/apache/solr/update/UpdateLog.java", "diffHunk": "@@ -561,6 +565,13 @@ public void add(AddUpdateCommand cmd, boolean clearCaches) {\n     // TODO: we currently need to log to maintain correct versioning, rtg, etc\n     // if ((cmd.getFlags() & UpdateCommand.REPLAY) != 0) return;\n \n+    // This hack could be removed after SOLR-15064 when we insist updates to child docs include _root_.\n+    // Until then, if we're in a buffering mode, then the solrDoc won't have the _root_ field.\n+    // Otherwise, it should already be there, placed by the client.\n+    if (usableForChildDocs && cmd.useRouteAsRoot != null && cmd.solrDoc.getField(IndexSchema.ROOT_FIELD_NAME) == null) {", "originalCommit": "6f3854058969475d99ad582097d702010f5e0bf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTEzMTE2Ng==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r551131166", "bodyText": "THREAD_SAFETY_VIOLATION:  Unprotected write. Non-private method UpdateLog.add(...) indirectly writes to field cmd.childDocIdStr outside of synchronization.\nReporting because this access may occur on a background thread.", "author": "sonatype-lift", "createdAt": "2021-01-04T06:04:08Z", "path": "solr/core/src/java/org/apache/solr/update/UpdateLog.java", "diffHunk": "@@ -561,6 +565,13 @@ public void add(AddUpdateCommand cmd, boolean clearCaches) {\n     // TODO: we currently need to log to maintain correct versioning, rtg, etc\n     // if ((cmd.getFlags() & UpdateCommand.REPLAY) != 0) return;\n \n+    // This hack could be removed after SOLR-15064 when we insist updates to child docs include _root_.\n+    // Until then, if we're in a buffering mode, then the solrDoc won't have the _root_ field.\n+    // Otherwise, it should already be there, placed by the client.\n+    if (usableForChildDocs && cmd.useRouteAsRoot != null && cmd.solrDoc.getField(IndexSchema.ROOT_FIELD_NAME) == null) {\n+      cmd.solrDoc.setField(IndexSchema.ROOT_FIELD_NAME, cmd.getIndexedIdStr());", "originalCommit": "6f3854058969475d99ad582097d702010f5e0bf9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzMTU0MA==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r552231540", "bodyText": "NULL_DEREFERENCE:  object docs last assigned on line 111 could be null and is dereferenced at line 112.", "author": "sonatype-lift", "createdAt": "2021-01-05T22:15:55Z", "path": "solr/core/src/java/org/apache/solr/response/transform/ChildDocTransformer.java", "diffHunk": "@@ -76,6 +87,37 @@ public String getName()  {\n   @Override\n   public boolean needsSolrIndexSearcher() { return true; }\n \n+  @Override\n+  public String[] getExtraRequestFields() {\n+    return extraRequestedFields;\n+  }\n+\n+  private int getPrevRootGivenFilter(LeafReaderContext leafReaderContext, int segRootId) throws IOException {\n+    final BitSet segParentsBitSet = parentsFilter.getBitSet(leafReaderContext);\n+    if (segParentsBitSet != null) {\n+      return segRootId == 0 ? -1 : segParentsBitSet.prevSetBit(segRootId - 1);\n+    }\n+    throw new SolrException(SolrException.ErrorCode.BAD_REQUEST,\n+        \"Parent filter '\" + parentsFilter + \"' doesn't match any parent documents\");\n+  }\n+\n+  private int getPrevRootGivenId(LeafReaderContext leafReaderContext, int segRootId,\n+                                 BytesRef idBytes) throws IOException {\n+    final LeafReader reader = leafReaderContext.reader();\n+    final Terms terms = reader.terms(IndexSchema.ROOT_FIELD_NAME); // never returns null here\n+    final TermsEnum iterator = terms.iterator();\n+    if (iterator.seekExact(idBytes)) {\n+      PostingsEnum docs = iterator.postings(null, PostingsEnum.NONE);\n+      docs = BitsFilteredPostingsEnum.wrap(docs, reader.getLiveDocs());\n+      int id = docs.nextDoc();", "originalCommit": "1bc9a612545ca49cdbe95b18acd6abfd88c4bca7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjI0MTU5Ng==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r552241596", "bodyText": "Wrong; iterator.postings() never returns null -- so says its documentation.", "author": "dsmiley", "createdAt": "2021-01-05T22:39:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjIzMTU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg1MTMyNg==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r552851326", "bodyText": "The removed section introduces the _nest_path_ field which is shown in the example that has been retained. However the change here talks about the field requirements for the _root_ field. That leaves the _nest_path_ field unaddressed and makes the following example seem like it's coming out of nowhere. This gets a bit more confusing as the section goes on, with a later sub-bullet that talks about the _nest_path_ field which hasn't been discussed really up to that point (the example is literally the first time in the doc that it's mentioned).", "author": "ctargett", "createdAt": "2021-01-06T17:45:36Z", "path": "solr/solr-ref-guide/src/indexing-nested-documents.adoc", "diffHunk": "@@ -218,31 +225,40 @@ Indexing nested documents _requires_ an indexed field named `\\_root_`:\n \n [source,xml]\n ----\n-<field name=\"_root_\" type=\"string\" indexed=\"true\" />\n+<field name=\"_root_\" type=\"string\" indexed=\"true\" stored=\"false\" docValues=\"false\" />\n ----\n \n-Solr automatically populates this field in every nested document with the `id` value of the top most parent document in the block.\n+Solr automatically populates this field in _all_ documents with the `id` value of it's root document\n+-- it's highest ancestor, possibly itself.\n \n \n There are several additional schema considerations that should be considered for people who wish to use nested documents:\n \n-* Nested child documents are very much documents in their own right even if certain nested documents hold different information from the parent, Therefore:\n+* Nested child documents are very much documents in their own right even if certain nested\n+documents hold different information from the parent or other child documents, therefore:\n ** All field names in the schema can only be configured in one -- different types of child documents can not have the same field name configured in different ways.\n-** It may be infeasible to use `required` for any field names that aren't reqiured for all types of documents.\n+** It may be infeasible to use `required` for any field names that aren't required for all types of\n+documents.\n ** Even child documents need a _globally_ unique `id`.\n-* `\\_root_` must be configured to either be stored (`stored=\"true\"`) or use doc values (`docValues=\"true\"`) to enable <<updating-parts-of-documents#updating-child-documents,atomic updates of nested documents>>.\n-** Also, beware of `uniqueBlock(\\_root_)` <<json-facet-api#stat-facet-functions,field type limitation>>, if you plan to use one.\n-* `\\_nest_path_` is an optional field that (if definied) will be populated by Solr automatically with the ancestor path of each non-root document.\n+* The `\\_root_` must be indexed (`indexed=\"true\"`) but doesn't need to\n+ be either stored (`stored=\"true\"`) or use doc values (`docValues=\"true\"`), however you are free\n+to do so if you find it useful.  If you want to use `uniqueBlock(\\_root_)`\n+<<json-facet-api#stat-facet-functions,field type limitation>>, then you should enable docValues.", "originalCommit": "1bc9a612545ca49cdbe95b18acd6abfd88c4bca7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjkyMDgzMA==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r552920830", "bodyText": "I don't think I broke the flow of introduction.  Perhaps the diff makes this unclear?  Any way, I just submitted an update that improves the whole matter (I hope).  I recommend building the HTML file looking at it in a browser.", "author": "dsmiley", "createdAt": "2021-01-06T19:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg1MTMyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk4MzM0Nw==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r552983347", "bodyText": "GitHub also allows one to view the whole file as of the commit, which is what I did so I feel like I did already look at your changes in their broader context. I think you've misunderstood the point of my comment, which is not only about that one change, but how it relates to the child bullets under it (which you didn't change, so maybe overlooked).\nThe bullet point in question talks about the _route_ field.\nRight under that, indented so it is clearly part of the same bullet item, is an example from a schema for the _nest_path_ field. There is no _route_ field shown in the example. This example used to have text which introduced the _nest_path_ field, but that was removed to add the current paragraph about the _route_ field.\nThis example is now the very first time the _nest_path_ field is mentioned on the page. What is that field? How does it relate to the _route_ field?\nRight after this example, there is a child-level bullet that states: \"In a nutshell, this fields makes child/nested documents easier to use, and so it\u2019s recommended you add it.\" Which field? The typo makes it even more confusing - does it mean both fields?\nThe next child-level bullet again says \"This field enables Solr to ...\" - again, which field?\nA later child-level bullet then says, \"If you don't use _nest_path_ ...\" This is only the 2nd time this field is mentioned. What is this field? Why would I use it or not use it?", "author": "ctargett", "createdAt": "2021-01-06T22:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg1MTMyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk5OTg4MA==", "url": "https://github.com/apache/lucene-solr/pull/2159#discussion_r552999880", "bodyText": "Thank you for entertaining my request to do a screen share.  We're cleared up now; you were looking at my earlier commit, it seems.", "author": "dsmiley", "createdAt": "2021-01-06T22:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg1MTMyNg=="}], "type": "inlineReview"}, {"oid": "3d50a2fd05c9256344ef82123efc0f4d64eb8a02", "url": "https://github.com/apache/lucene-solr/commit/3d50a2fd05c9256344ef82123efc0f4d64eb8a02", "message": "SOLR-14923: Nested docs indexing performance & robustness\n* When the schema defines _root_, and you want to do atomic/partial updates...\n** _root_ needn't be stored or have docValues any more\n** _nest_path_ field isn't needed for this any more\n** Simplified internal logic\n* Allow (and recommend, eventually insist) that the _root_ field be passed for atomic/partial updates to child docs.\n** In the absence of _root_, assume the _route_ param is equivalent to ameliorate back-compat scope.  This is a temporary hack; remove in SOLR-15064.\n** One of the two is required; you'll get an exception if the assumption is false.  THIS IS A BACK-COMPAT CHANGE\n* Ensure that the update log contains the _root_ field if it's defined in the schema; in some cases it wasn't.  It's important for robustness of atomic/partial updates to child docs.  Caveat: the buffer replay scenario is not tested with child docs.\n* Limited the cases when a realtime searcher is re-opened.  It was being applied to any update that included child docs but now only some narrow subset: only for atomic/partial updates, and when the update log contains an in-place update for the same nest because it's complicated to resolve those log entries.\n* Internal improvements to RealTimeGetComponent to aid clarity & robustness & probably performance...\n** Use SolrDocumentFetcher.solrDoc(docID, ReturnFields) instead of more manual loading.  Will do more with this in another PR.\n** Clarify when only root doc IDs are expected.\n** Use Resolution enum more, add PARTIAL, remove DOC_WITH_CHILDREN; enhance docs.\n** When have ReturnFields, a Set of \"onlyTheseFields\" becomes redundant.  Add a child doc resolution via a transformer when needed.\n** Clarified where copy-field targets are removed\n* NestPathField should default to single valued, instead of inheriting the schema default, which for ancient schemas was multi-valued.\n* AddUpdateCommand.getLuceneDocument(s) methods are very internal; made package visible and refactored a bit for clarity\n* DocumentBuilder: when in-place update, skip id and _root_ here, thus also simplifying further logic\n* NestedShardedAtomicUpdateTest no longer extends AbstractFullDistribZkTestBase because it wasn't really leveraging the \"control client\" checking, and it added too much complexity to debug failures.", "committedDate": "2021-01-07T15:49:40Z", "type": "commit"}, {"oid": "064aa7a2d7e61b01a855009a4fc95be55f6a8ca9", "url": "https://github.com/apache/lucene-solr/commit/064aa7a2d7e61b01a855009a4fc95be55f6a8ca9", "message": "small improvements", "committedDate": "2021-01-07T15:50:55Z", "type": "commit"}, {"oid": "064aa7a2d7e61b01a855009a4fc95be55f6a8ca9", "url": "https://github.com/apache/lucene-solr/commit/064aa7a2d7e61b01a855009a4fc95be55f6a8ca9", "message": "small improvements", "committedDate": "2021-01-07T15:50:55Z", "type": "forcePushed"}, {"oid": "6ba773a6d7a8245bb16896abbea129bfe8c42d30", "url": "https://github.com/apache/lucene-solr/commit/6ba773a6d7a8245bb16896abbea129bfe8c42d30", "message": "docs: no more field requirements for nested docs.\ndocs: clarity under-the-hood.", "committedDate": "2021-01-07T17:36:21Z", "type": "commit"}, {"oid": "3ccedcf4521e87bf79049916b8c355e9ed1c257c", "url": "https://github.com/apache/lucene-solr/commit/3ccedcf4521e87bf79049916b8c355e9ed1c257c", "message": "docs: Woops; the root doc has \"!prod\" suffix", "committedDate": "2021-01-07T20:51:01Z", "type": "commit"}, {"oid": "4e474bbae5154b3938e2bd7c6468d2c5cb1ff7d0", "url": "https://github.com/apache/lucene-solr/commit/4e474bbae5154b3938e2bd7c6468d2c5cb1ff7d0", "message": "Merge branch 'master' into solr-14923-nestedDocsRealtimeSearcher", "committedDate": "2021-01-08T04:19:10Z", "type": "commit"}]}