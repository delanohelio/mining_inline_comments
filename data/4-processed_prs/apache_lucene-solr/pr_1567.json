{"pr_number": 1567, "pr_title": "LUCENE-9402: Let MultiCollector handle minCompetitiveScore", "pr_createdAt": "2020-06-10T21:30:11Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1567", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyMDMwMQ==", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r438420301", "bodyText": "I should fix this comment", "author": "tflobbe", "createdAt": "2020-06-10T21:32:32Z", "path": "lucene/core/src/java/org/apache/lucene/search/MultiCollector.java", "diffHunk": "@@ -143,32 +143,43 @@ public LeafCollector getLeafCollector(LeafReaderContext context) throws IOExcept\n     private final boolean cacheScores;\n     private final LeafCollector[] collectors;\n     private int numCollectors;\n+    private final float[] minScores;\n+    private final boolean skipNonCompetitiveScores;\n \n-    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores) {\n+    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores, boolean skipNonCompetitive) {\n       this.collectors = collectors.toArray(new LeafCollector[collectors.size()]);\n       this.cacheScores = cacheScores;\n       this.numCollectors = this.collectors.length;\n+      this.skipNonCompetitiveScores = skipNonCompetitive;\n+      this.minScores = new float[this.skipNonCompetitiveScores ? this.numCollectors : 0];\n     }\n \n     @Override\n     public void setScorer(Scorable scorer) throws IOException {\n       if (cacheScores) {\n         scorer = new ScoreCachingWrappingScorer(scorer);\n       }\n-      scorer = new FilterScorable(scorer) {\n-        @Override\n-        public void setMinCompetitiveScore(float minScore) {\n-          // Ignore calls to setMinCompetitiveScore so that if we wrap two\n-          // collectors and one of them wants to skip low-scoring hits, then\n-          // the other collector still sees all hits. We could try to reconcile\n-          // min scores and take the maximum min score across collectors, but\n-          // this is very unlikely to be helpful in practice.\n+      if (skipNonCompetitiveScores) {\n+        for (int i = 0; i < numCollectors; ++i) {\n+          final LeafCollector c = collectors[i];\n+          c.setScorer(new MinCompetitiveScoreAwareScorable(scorer,  i,  minScores));\n         }\n+      } else {\n+        scorer = new FilterScorable(scorer) {\n+          @Override\n+          public void setMinCompetitiveScore(float minScore) throws IOException {\n+            // Ignore calls to setMinCompetitiveScore so that if we wrap two\n+            // collectors and one of them wants to skip low-scoring hits, then\n+            // the other collector still sees all hits. We could try to reconcile\n+            // min scores and take the maximum min score across collectors, but\n+            // this is very unlikely to be helpful in practice.", "originalCommit": "829717b2f17e3b36875b9b0fc02b9a4e830bc81b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3Mzc5NQ==", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r438573795", "bodyText": "Let's make the array null when skipNonCompetitiveScores is false?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  this.minScores = new float[this.skipNonCompetitiveScores ? this.numCollectors : 0];\n          \n          \n            \n                  this.minScores = this.skipNonCompetitiveScores ? new float[ this.numCollectors] : null;", "author": "jpountz", "createdAt": "2020-06-11T06:41:56Z", "path": "lucene/core/src/java/org/apache/lucene/search/MultiCollector.java", "diffHunk": "@@ -143,32 +143,43 @@ public LeafCollector getLeafCollector(LeafReaderContext context) throws IOExcept\n     private final boolean cacheScores;\n     private final LeafCollector[] collectors;\n     private int numCollectors;\n+    private final float[] minScores;\n+    private final boolean skipNonCompetitiveScores;\n \n-    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores) {\n+    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores, boolean skipNonCompetitive) {\n       this.collectors = collectors.toArray(new LeafCollector[collectors.size()]);\n       this.cacheScores = cacheScores;\n       this.numCollectors = this.collectors.length;\n+      this.skipNonCompetitiveScores = skipNonCompetitive;\n+      this.minScores = new float[this.skipNonCompetitiveScores ? this.numCollectors : 0];", "originalCommit": "829717b2f17e3b36875b9b0fc02b9a4e830bc81b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU3NTg0NA==", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r438575844", "bodyText": "no need to commit, the follow-up call to getReader() creates a NRT segment anyway", "author": "jpountz", "createdAt": "2020-06-11T06:47:25Z", "path": "lucene/core/src/test/org/apache/lucene/search/MultiCollectorTest.java", "diffHunk": "@@ -163,4 +163,64 @@ public void testCacheScoresIfNecessary() throws IOException {\n     reader.close();\n     dir.close();\n   }\n+  \n+  public void testScorerWrappingForTopScores() throws IOException {\n+    Directory dir = newDirectory();\n+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);\n+    iw.addDocument(new Document());\n+    iw.commit();", "originalCommit": "829717b2f17e3b36875b9b0fc02b9a4e830bc81b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0MjMwMw==", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r440242303", "bodyText": "I don't think that this assertion is right, the collector could be null if the collector already threw a CollectionTerminatedException? (we don't disallow calling setCollector after collection started)", "author": "jpountz", "createdAt": "2020-06-15T15:03:36Z", "path": "lucene/core/src/java/org/apache/lucene/search/MultiCollector.java", "diffHunk": "@@ -134,69 +134,110 @@ public LeafCollector getLeafCollector(LeafReaderContext context) throws IOExcept\n       case 1:\n         return leafCollectors.get(0);\n       default:\n-        return new MultiLeafCollector(leafCollectors, cacheScores);\n+        return new MultiLeafCollector(leafCollectors, cacheScores, scoreMode() == ScoreMode.TOP_SCORES);\n     }\n   }\n \n   private static class MultiLeafCollector implements LeafCollector {\n \n     private final boolean cacheScores;\n     private final LeafCollector[] collectors;\n-    private int numCollectors;\n+    private final float[] minScores;\n+    private final boolean skipNonCompetitiveScores;\n \n-    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores) {\n+    private MultiLeafCollector(List<LeafCollector> collectors, boolean cacheScores, boolean skipNonCompetitive) {\n       this.collectors = collectors.toArray(new LeafCollector[collectors.size()]);\n       this.cacheScores = cacheScores;\n-      this.numCollectors = this.collectors.length;\n+      this.skipNonCompetitiveScores = skipNonCompetitive;\n+      this.minScores = this.skipNonCompetitiveScores ? new float[this.collectors.length] : null;\n     }\n \n     @Override\n     public void setScorer(Scorable scorer) throws IOException {\n       if (cacheScores) {\n         scorer = new ScoreCachingWrappingScorer(scorer);\n       }\n-      scorer = new FilterScorable(scorer) {\n-        @Override\n-        public void setMinCompetitiveScore(float minScore) {\n-          // Ignore calls to setMinCompetitiveScore so that if we wrap two\n-          // collectors and one of them wants to skip low-scoring hits, then\n-          // the other collector still sees all hits. We could try to reconcile\n-          // min scores and take the maximum min score across collectors, but\n-          // this is very unlikely to be helpful in practice.\n+      if (skipNonCompetitiveScores) {\n+        for (int i = 0; i < collectors.length; ++i) {\n+          final LeafCollector c = collectors[i];\n+          assert c != null;", "originalCommit": "e880e1b4a19ec0fba063459bda86cafb193dc514", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ5MjExNQ==", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r440492115", "bodyText": "hmm I had the null check before, but I thought setScorer had to only be called before the collect calls because of the javadoc: Called before successive calls to {@link #collect(int)}.. I'll put the null checks back.", "author": "tflobbe", "createdAt": "2020-06-15T22:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0MjMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDYyODEyOQ==", "url": "https://github.com/apache/lucene-solr/pull/1567#discussion_r440628129", "bodyText": "maybe create a new variant of this test that calls setScorer again after this collect call?", "author": "jpountz", "createdAt": "2020-06-16T07:01:54Z", "path": "lucene/core/src/test/org/apache/lucene/search/MultiCollectorTest.java", "diffHunk": "@@ -163,4 +163,115 @@ public void testCacheScoresIfNecessary() throws IOException {\n     reader.close();\n     dir.close();\n   }\n+  \n+  public void testScorerWrappingForTopScores() throws IOException {\n+    Directory dir = newDirectory();\n+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);\n+    iw.addDocument(new Document());\n+    DirectoryReader reader = iw.getReader();\n+    iw.close();\n+    final LeafReaderContext ctx = reader.leaves().get(0);\n+    Collector c1 = collector(ScoreMode.TOP_SCORES, MultiCollector.MinCompetitiveScoreAwareScorable.class);\n+    Collector c2 = collector(ScoreMode.TOP_SCORES, MultiCollector.MinCompetitiveScoreAwareScorable.class);\n+    MultiCollector.wrap(c1, c2).getLeafCollector(ctx).setScorer(new ScoreAndDoc());\n+    \n+    c1 = collector(ScoreMode.TOP_SCORES, ScoreCachingWrappingScorer.class);\n+    c2 = collector(ScoreMode.COMPLETE, ScoreCachingWrappingScorer.class);\n+    MultiCollector.wrap(c1, c2).getLeafCollector(ctx).setScorer(new ScoreAndDoc());\n+    \n+    reader.close();\n+    dir.close();\n+  }\n+  \n+  public void testMinCompetitiveScore() throws IOException {\n+    float[] currentMinScores = new float[3];\n+    float[] minCompetitiveScore = new float[1];\n+    Scorable scorer = new Scorable() {\n+      \n+      @Override\n+      public float score() throws IOException {\n+        return 0;\n+      }\n+      \n+      @Override\n+      public int docID() {\n+        return 0;\n+      }\n+      \n+      @Override\n+      public void setMinCompetitiveScore(float minScore) throws IOException {\n+        minCompetitiveScore[0] = minScore;\n+      }\n+    };\n+    Scorable s0 = new MultiCollector.MinCompetitiveScoreAwareScorable(scorer, 0, currentMinScores);\n+    Scorable s1 = new MultiCollector.MinCompetitiveScoreAwareScorable(scorer, 1, currentMinScores);\n+    Scorable s2 = new MultiCollector.MinCompetitiveScoreAwareScorable(scorer, 2, currentMinScores);\n+    assertEquals(0f, minCompetitiveScore[0], 0);\n+    s0.setMinCompetitiveScore(0.5f);\n+    assertEquals(0f, minCompetitiveScore[0], 0);\n+    s1.setMinCompetitiveScore(0.8f);\n+    assertEquals(0f, minCompetitiveScore[0], 0);\n+    s2.setMinCompetitiveScore(0.3f);\n+    assertEquals(0.3f, minCompetitiveScore[0], 0);\n+    s2.setMinCompetitiveScore(0.1f);\n+    assertEquals(0.3f, minCompetitiveScore[0], 0);\n+    s1.setMinCompetitiveScore(Float.MAX_VALUE);\n+    assertEquals(0.3f, minCompetitiveScore[0], 0);\n+    s2.setMinCompetitiveScore(Float.MAX_VALUE);\n+    assertEquals(0.5f, minCompetitiveScore[0], 0);\n+    s0.setMinCompetitiveScore(Float.MAX_VALUE);\n+    assertEquals(Float.MAX_VALUE, minCompetitiveScore[0], 0);\n+  }\n+  \n+  public void testCollectionTermination() throws IOException {\n+    Directory dir = newDirectory();\n+    RandomIndexWriter iw = new RandomIndexWriter(random(), dir);\n+    iw.addDocument(new Document());\n+    DirectoryReader reader = iw.getReader();\n+    iw.close();\n+    final LeafReaderContext ctx = reader.leaves().get(0);\n+    DummyCollector c1 = new DummyCollector() {\n+      @Override\n+      public void collect(int doc) throws IOException {\n+        if (doc == 1) {\n+          throw new CollectionTerminatedException();\n+        }\n+        super.collect(doc);\n+      }\n+      \n+    };\n+    \n+    DummyCollector c2 = new DummyCollector() {\n+      @Override\n+      public void collect(int doc) throws IOException {\n+        if (doc == 2) {\n+          throw new CollectionTerminatedException();\n+        }\n+        super.collect(doc);\n+      }\n+      \n+    };\n+\n+    Collector mc = MultiCollector.wrap(c1, c2);\n+    LeafCollector lc = mc.getLeafCollector(ctx);\n+    lc.setScorer(new ScoreAndDoc());\n+    lc.collect(0); // OK\n+    assertTrue(\"c1's collect should be called\", c1.collectCalled);\n+    assertTrue(\"c2's collect should be called\", c2.collectCalled);\n+    c1.collectCalled = false;\n+    c2.collectCalled = false;\n+    lc.collect(1); // OK, but c1 should terminate", "originalCommit": "8f0292e0a7581a322d347b478c3b8198ba8cbc63", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "44cdbab1fa1227658a789b6ce42145e9bd5e8bd0", "url": "https://github.com/apache/lucene-solr/commit/44cdbab1fa1227658a789b6ce42145e9bd5e8bd0", "message": "Let MultiCollector handle minCompetitiveScore", "committedDate": "2020-06-18T17:01:38Z", "type": "commit"}, {"oid": "9eaf5d5dd8aa6e5eb8a33cf063ebabfe47cb2ca6", "url": "https://github.com/apache/lucene-solr/commit/9eaf5d5dd8aa6e5eb8a33cf063ebabfe47cb2ca6", "message": "Address PR comments", "committedDate": "2020-06-18T17:01:38Z", "type": "commit"}, {"oid": "7d91ea09d199d03e0284819d8da9b4d6a2e82265", "url": "https://github.com/apache/lucene-solr/commit/7d91ea09d199d03e0284819d8da9b4d6a2e82265", "message": "Add null checks in setScorer", "committedDate": "2020-06-18T17:01:38Z", "type": "commit"}, {"oid": "ee2683d30c34e10dda644ab39935a75e7a960fbc", "url": "https://github.com/apache/lucene-solr/commit/ee2683d30c34e10dda644ab39935a75e7a960fbc", "message": "Add setScorer tests", "committedDate": "2020-06-18T17:01:38Z", "type": "commit"}, {"oid": "e46f50ce15f754a4ca14941037096fad188e33fd", "url": "https://github.com/apache/lucene-solr/commit/e46f50ce15f754a4ca14941037096fad188e33fd", "message": "Add CHANGES entry", "committedDate": "2020-06-18T17:09:24Z", "type": "commit"}, {"oid": "e46f50ce15f754a4ca14941037096fad188e33fd", "url": "https://github.com/apache/lucene-solr/commit/e46f50ce15f754a4ca14941037096fad188e33fd", "message": "Add CHANGES entry", "committedDate": "2020-06-18T17:09:24Z", "type": "forcePushed"}]}