{"pr_number": 1351, "pr_title": "LUCENE-9280: Collectors to skip noncompetitive documents", "pr_createdAt": "2020-03-13T22:19:01Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1351", "timeline": [{"oid": "0d4b2f5e476a7270ca178c6cde3ca46bfdf43405", "url": "https://github.com/apache/lucene-solr/commit/0d4b2f5e476a7270ca178c6cde3ca46bfdf43405", "message": "Collectors to skip noncompetitive documents\n\nSimilar how scorers can update their iterators to skip non-competitive\ndocuments, collectors and comparators should also provide and update\niterators that allow them to skip non-competive documents\n\nThis could be useful if we want to sort by some field.", "committedDate": "2020-03-13T22:10:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyMTU0OQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r393621549", "bodyText": "Why do we need this ? We could update the iterator every time a bottom value is set ?", "author": "jimczi", "createdAt": "2020-03-17T11:48:35Z", "path": "lucene/core/src/java/org/apache/lucene/search/FieldComparator.java", "diffHunk": "@@ -928,4 +928,9 @@ public int compareTop(int doc) throws IOException {\n     @Override\n     public void setScorer(Scorable scorer) {}\n   }\n+\n+  public static abstract class IteratorSupplierComparator<T> extends FieldComparator<T> implements LeafFieldComparator {\n+    abstract DocIdSetIterator iterator();\n+    abstract void updateIterator() throws IOException;", "originalCommit": "0d4b2f5e476a7270ca178c6cde3ca46bfdf43405", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY1OTc4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r394659789", "bodyText": "Indeed it is more straightforward to just update an iterator in setBottom function of a comparator.\nBut I was thinking it is better to have a special function for two reasons:\n\n\nAfter updating an iterator, in TopFieldCollector we need to change\ntotalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;\n\n\nwe also need to check hitsThresholdChecker.isThresholdReached(), and passing not strictly related object hitsThresholdChecker to a comparator's constructor doesn't look nice to me.\n\n\nPlease let me know if you think otherwise", "author": "mayya-sharipova", "createdAt": "2020-03-18T21:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyMTU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4MzUwNQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r394683505", "bodyText": "For 1. we could set the totalHitsRelation when we reach the total hits threshold in the TOP_DOCS mode ?\nFor 2. I wonder if we could pass the hitsThresholdChecker to the LeafFieldComparator like we do for the scorer ?\nThis way we can update the iterator internally when a new bottom is set or when compareBottom is called ?", "author": "jimczi", "createdAt": "2020-03-18T22:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyMTU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyNzgzMQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r396127831", "bodyText": "The name seems to indicate that this is something that compares IteratorSuppliers, when in fact it is something that is a comparator that also supplies iterators. I'm not sure I understand yet where it fits, but given that, a better name might be IterableComparator?", "author": "msokolov", "createdAt": "2020-03-22T18:50:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyMTU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY4NzEzNA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r396687134", "bodyText": "@msokolov  Thanks for the suggestion, naming is tough, addressed in 95e1bc1.", "author": "mayya-sharipova", "createdAt": "2020-03-23T19:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyMTU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyMzQxNw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r393623417", "bodyText": "we should update the iterator only if it allows to skip \"lots\" of documents, in distance feature query we set the threshold to a 8x reduction.", "author": "jimczi", "createdAt": "2020-03-17T11:52:04Z", "path": "lucene/core/src/java/org/apache/lucene/search/LongDocValuesPointComparator.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.NumericDocValues;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.apache.lucene.search.FieldComparator.IteratorSupplierComparator;\n+\n+public class LongDocValuesPointComparator extends IteratorSupplierComparator<Long> {\n+    private final String field;\n+    private final boolean reverse;\n+    private final long[] values;\n+    private long bottom;\n+    private long topValue;\n+    protected NumericDocValues docValues;\n+    private DocIdSetIterator iterator;\n+    private PointValues pointValues;\n+    private int maxDoc;\n+    private int maxDocVisited;\n+\n+    public LongDocValuesPointComparator(String field, int numHits, boolean reverse) {\n+        this.field = field;\n+        this.reverse = reverse;\n+        this.values = new long[numHits];\n+    }\n+\n+    private long getValueForDoc(int doc) throws IOException {\n+        if (docValues.advanceExact(doc)) {\n+            return docValues.longValue();\n+        } else {\n+            return 0L; // TODO: missing value\n+        }\n+    }\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        return Long.compare(values[slot1], values[slot2]);\n+    }\n+\n+    @Override\n+    public void setTopValue(Long value) {\n+        topValue = value;\n+    }\n+\n+    @Override\n+    public Long value(int slot) {\n+        return Long.valueOf(values[slot]);\n+    }\n+\n+    @Override\n+    public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+        docValues = DocValues.getNumeric(context.reader(), field);\n+        iterator = docValues;\n+        pointValues = context.reader().getPointValues(field);\n+        maxDoc = context.reader().maxDoc();\n+        maxDocVisited = 0;\n+        return this;\n+    }\n+\n+    @Override\n+    public void setBottom(int slot) {\n+        this.bottom = values[slot];\n+    }\n+\n+    @Override\n+    public int compareBottom(int doc) throws IOException {\n+        return Long.compare(bottom, getValueForDoc(doc));\n+    }\n+\n+    @Override\n+    public int compareTop(int doc) throws IOException {\n+        return Long.compare(topValue, getValueForDoc(doc));\n+    }\n+\n+    @Override\n+    public void copy(int slot, int doc) throws IOException {\n+        maxDocVisited = doc;\n+        values[slot] = getValueForDoc(doc);\n+    }\n+\n+    @Override\n+    public void setScorer(Scorable scorer) throws IOException {}\n+\n+    public DocIdSetIterator iterator() {\n+        return iterator;\n+    }\n+\n+    public void updateIterator() throws IOException {\n+        final byte[] maxValueAsBytes = new byte[Long.BYTES];\n+        final byte[] minValueAsBytes = new byte[Long.BYTES];\n+        if (reverse == false) {\n+            LongPoint.encodeDimension(bottom, maxValueAsBytes, 0);\n+        } else {\n+            LongPoint.encodeDimension(bottom, minValueAsBytes, 0);\n+        };\n+\n+        DocIdSetBuilder result = new DocIdSetBuilder(maxDoc);\n+        PointValues.IntersectVisitor visitor = new PointValues.IntersectVisitor() {\n+            DocIdSetBuilder.BulkAdder adder;\n+            @Override\n+            public void grow(int count) {\n+                adder = result.grow(count);\n+            }\n+\n+            @Override\n+            public void visit(int docID) {\n+                if (docID <= maxDocVisited) {\n+                    return; // Already visited or skipped\n+                }\n+                adder.add(docID);\n+            }\n+\n+            @Override\n+            public void visit(int docID, byte[] packedValue) {\n+                if (docID <= maxDocVisited) {\n+                    return;  // Already visited or skipped\n+                }\n+                if ((reverse == false) && (Arrays.compareUnsigned(packedValue, 0, Long.BYTES, maxValueAsBytes, 0, Long.BYTES) > 0)) {\n+                    return; // Doc's value is too high\n+                }\n+                if ((reverse == true) && (Arrays.compareUnsigned(packedValue, 0, Long.BYTES, minValueAsBytes, 0, Long.BYTES) < 0)) {\n+                    return;  // Doc's value is too low,\n+                }\n+                adder.add(docID); // doc is competitive\n+            }\n+\n+            @Override\n+            public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n+                if ((reverse == false) && (Arrays.compareUnsigned(minPackedValue, 0, Long.BYTES, maxValueAsBytes, 0, Long.BYTES) > 0)) {\n+                   return PointValues.Relation.CELL_OUTSIDE_QUERY;\n+                }\n+                if ((reverse == true) && (Arrays.compareUnsigned(maxPackedValue, 0, Long.BYTES, minValueAsBytes, 0, Long.BYTES) < 0)) {\n+                    return PointValues.Relation.CELL_OUTSIDE_QUERY;\n+                }\n+                return PointValues.Relation.CELL_CROSSES_QUERY;\n+            }\n+        };\n+        pointValues.intersect(visitor);", "originalCommit": "0d4b2f5e476a7270ca178c6cde3ca46bfdf43405", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY1NjIyMA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r394656220", "bodyText": "Addressed in 6384b15", "author": "mayya-sharipova", "createdAt": "2020-03-18T21:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyMzQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyNDE1NA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r393624154", "bodyText": "We should throttle the checks here (if the bottom value changes frequently). In the distance feature query we start throttling after 256 calls, we should replicate here ?", "author": "jimczi", "createdAt": "2020-03-17T11:53:31Z", "path": "lucene/core/src/java/org/apache/lucene/search/LongDocValuesPointComparator.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.NumericDocValues;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.apache.lucene.search.FieldComparator.IteratorSupplierComparator;\n+\n+public class LongDocValuesPointComparator extends IteratorSupplierComparator<Long> {\n+    private final String field;\n+    private final boolean reverse;\n+    private final long[] values;\n+    private long bottom;\n+    private long topValue;\n+    protected NumericDocValues docValues;\n+    private DocIdSetIterator iterator;\n+    private PointValues pointValues;\n+    private int maxDoc;\n+    private int maxDocVisited;\n+\n+    public LongDocValuesPointComparator(String field, int numHits, boolean reverse) {\n+        this.field = field;\n+        this.reverse = reverse;\n+        this.values = new long[numHits];\n+    }\n+\n+    private long getValueForDoc(int doc) throws IOException {\n+        if (docValues.advanceExact(doc)) {\n+            return docValues.longValue();\n+        } else {\n+            return 0L; // TODO: missing value\n+        }\n+    }\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        return Long.compare(values[slot1], values[slot2]);\n+    }\n+\n+    @Override\n+    public void setTopValue(Long value) {\n+        topValue = value;\n+    }\n+\n+    @Override\n+    public Long value(int slot) {\n+        return Long.valueOf(values[slot]);\n+    }\n+\n+    @Override\n+    public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+        docValues = DocValues.getNumeric(context.reader(), field);\n+        iterator = docValues;\n+        pointValues = context.reader().getPointValues(field);\n+        maxDoc = context.reader().maxDoc();\n+        maxDocVisited = 0;\n+        return this;\n+    }\n+\n+    @Override\n+    public void setBottom(int slot) {\n+        this.bottom = values[slot];\n+    }\n+\n+    @Override\n+    public int compareBottom(int doc) throws IOException {\n+        return Long.compare(bottom, getValueForDoc(doc));\n+    }\n+\n+    @Override\n+    public int compareTop(int doc) throws IOException {\n+        return Long.compare(topValue, getValueForDoc(doc));\n+    }\n+\n+    @Override\n+    public void copy(int slot, int doc) throws IOException {\n+        maxDocVisited = doc;\n+        values[slot] = getValueForDoc(doc);\n+    }\n+\n+    @Override\n+    public void setScorer(Scorable scorer) throws IOException {}\n+\n+    public DocIdSetIterator iterator() {\n+        return iterator;\n+    }\n+\n+    public void updateIterator() throws IOException {", "originalCommit": "0d4b2f5e476a7270ca178c6cde3ca46bfdf43405", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY1NTk4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r394655989", "bodyText": "Addressed in 6384b15", "author": "mayya-sharipova", "createdAt": "2020-03-18T21:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyNDE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyNTA5OA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r393625098", "bodyText": "Can you update the iterator here ? We would need to check the total hits threshold so maybe pass the HitsThresholdChecker in the ctr somehow ?", "author": "jimczi", "createdAt": "2020-03-17T11:55:21Z", "path": "lucene/core/src/java/org/apache/lucene/search/LongDocValuesPointComparator.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.NumericDocValues;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.apache.lucene.search.FieldComparator.IteratorSupplierComparator;\n+\n+public class LongDocValuesPointComparator extends IteratorSupplierComparator<Long> {\n+    private final String field;\n+    private final boolean reverse;\n+    private final long[] values;\n+    private long bottom;\n+    private long topValue;\n+    protected NumericDocValues docValues;\n+    private DocIdSetIterator iterator;\n+    private PointValues pointValues;\n+    private int maxDoc;\n+    private int maxDocVisited;\n+\n+    public LongDocValuesPointComparator(String field, int numHits, boolean reverse) {\n+        this.field = field;\n+        this.reverse = reverse;\n+        this.values = new long[numHits];\n+    }\n+\n+    private long getValueForDoc(int doc) throws IOException {\n+        if (docValues.advanceExact(doc)) {\n+            return docValues.longValue();\n+        } else {\n+            return 0L; // TODO: missing value\n+        }\n+    }\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        return Long.compare(values[slot1], values[slot2]);\n+    }\n+\n+    @Override\n+    public void setTopValue(Long value) {\n+        topValue = value;\n+    }\n+\n+    @Override\n+    public Long value(int slot) {\n+        return Long.valueOf(values[slot]);\n+    }\n+\n+    @Override\n+    public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+        docValues = DocValues.getNumeric(context.reader(), field);\n+        iterator = docValues;\n+        pointValues = context.reader().getPointValues(field);\n+        maxDoc = context.reader().maxDoc();\n+        maxDocVisited = 0;\n+        return this;\n+    }\n+\n+    @Override\n+    public void setBottom(int slot) {\n+        this.bottom = values[slot];", "originalCommit": "0d4b2f5e476a7270ca178c6cde3ca46bfdf43405", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyNTc1MA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r393625750", "bodyText": "you should also take the topValue into  account here (searchAfter) ?", "author": "jimczi", "createdAt": "2020-03-17T11:56:38Z", "path": "lucene/core/src/java/org/apache/lucene/search/LongDocValuesPointComparator.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.NumericDocValues;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.apache.lucene.search.FieldComparator.IteratorSupplierComparator;\n+\n+public class LongDocValuesPointComparator extends IteratorSupplierComparator<Long> {\n+    private final String field;\n+    private final boolean reverse;\n+    private final long[] values;\n+    private long bottom;\n+    private long topValue;\n+    protected NumericDocValues docValues;\n+    private DocIdSetIterator iterator;\n+    private PointValues pointValues;\n+    private int maxDoc;\n+    private int maxDocVisited;\n+\n+    public LongDocValuesPointComparator(String field, int numHits, boolean reverse) {\n+        this.field = field;\n+        this.reverse = reverse;\n+        this.values = new long[numHits];\n+    }\n+\n+    private long getValueForDoc(int doc) throws IOException {\n+        if (docValues.advanceExact(doc)) {\n+            return docValues.longValue();\n+        } else {\n+            return 0L; // TODO: missing value\n+        }\n+    }\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        return Long.compare(values[slot1], values[slot2]);\n+    }\n+\n+    @Override\n+    public void setTopValue(Long value) {\n+        topValue = value;\n+    }\n+\n+    @Override\n+    public Long value(int slot) {\n+        return Long.valueOf(values[slot]);\n+    }\n+\n+    @Override\n+    public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+        docValues = DocValues.getNumeric(context.reader(), field);\n+        iterator = docValues;\n+        pointValues = context.reader().getPointValues(field);\n+        maxDoc = context.reader().maxDoc();\n+        maxDocVisited = 0;\n+        return this;\n+    }\n+\n+    @Override\n+    public void setBottom(int slot) {\n+        this.bottom = values[slot];\n+    }\n+\n+    @Override\n+    public int compareBottom(int doc) throws IOException {\n+        return Long.compare(bottom, getValueForDoc(doc));\n+    }\n+\n+    @Override\n+    public int compareTop(int doc) throws IOException {\n+        return Long.compare(topValue, getValueForDoc(doc));\n+    }\n+\n+    @Override\n+    public void copy(int slot, int doc) throws IOException {\n+        maxDocVisited = doc;\n+        values[slot] = getValueForDoc(doc);\n+    }\n+\n+    @Override\n+    public void setScorer(Scorable scorer) throws IOException {}\n+\n+    public DocIdSetIterator iterator() {\n+        return iterator;\n+    }\n+\n+    public void updateIterator() throws IOException {\n+        final byte[] maxValueAsBytes = new byte[Long.BYTES];\n+        final byte[] minValueAsBytes = new byte[Long.BYTES];\n+        if (reverse == false) {\n+            LongPoint.encodeDimension(bottom, maxValueAsBytes, 0);\n+        } else {\n+            LongPoint.encodeDimension(bottom, minValueAsBytes, 0);\n+        };\n+", "originalCommit": "0d4b2f5e476a7270ca178c6cde3ca46bfdf43405", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY1NjEwOA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r394656108", "bodyText": "Addressed in 6384b15", "author": "mayya-sharipova", "createdAt": "2020-03-18T21:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyNTc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyNzkyMw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r393627923", "bodyText": "I think we should try to handle the collector iterator early in the chain. The default BulkScorer can be overridden so I wonder how this would look like if we build a conjunction from the main query and the collector iterator directly when building the weight (in IndexSearcher) ?", "author": "jimczi", "createdAt": "2020-03-17T12:00:49Z", "path": "lucene/core/src/java/org/apache/lucene/search/Weight.java", "diffHunk": "@@ -249,6 +249,10 @@ static int scoreRange(LeafCollector collector, DocIdSetIterator iterator, TwoPha\n      *  See <a href=\"https://issues.apache.org/jira/browse/LUCENE-5487\">LUCENE-5487</a> */\n     static void scoreAll(LeafCollector collector, DocIdSetIterator iterator, TwoPhaseIterator twoPhase, Bits acceptDocs) throws IOException {\n       if (twoPhase == null) {\n+        if (collector.iterator() != null) {", "originalCommit": "0d4b2f5e476a7270ca178c6cde3ca46bfdf43405", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY2MzMyMw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r394663323", "bodyText": "@jimczi Thanks for the initial review.\n\nI wonder how this would look like if we build a conjunction from the main query and the collector iterator directly when building the weight (in IndexSearcher)\n\nI could not think of any clever way  to do this in IndexSearcher,  I would appreciate your help if you can suggest any such way. I just redesigned DefaultBulkScorer to use a conjunction of a scorer's and collector's iterators.\nI looked at classes that override BulkScorer and many of them still refer to a default BulkScorer, and for those that don't such as BooleanScorer I found its logic to be too complex to understand and for me to combine with  a collector's iterator.", "author": "mayya-sharipova", "createdAt": "2020-03-18T21:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzYyNzkyMw=="}], "type": "inlineReview"}, {"oid": "6384b1591b8054108cc94a0ae4c69da48abcb801", "url": "https://github.com/apache/lucene-solr/commit/6384b1591b8054108cc94a0ae4c69da48abcb801", "message": "Address feedback1", "committedDate": "2020-03-18T21:39:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3MTk2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r394671963", "bodyText": "you can replace this with ConjunctionDISI#intersectIterators ?", "author": "jimczi", "createdAt": "2020-03-18T22:19:48Z", "path": "lucene/core/src/java/org/apache/lucene/search/Weight.java", "diffHunk": "@@ -201,20 +201,54 @@ public long cost() {\n     @Override\n     public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n       collector.setScorer(scorer);\n+      DocIdSetIterator scorerIterator = twoPhase == null? iterator: twoPhase.approximation();\n+      DocIdSetIterator combinedIterator = collector.iterator() == null ? scorerIterator: combineScorerAndCollectorIterators(scorerIterator, collector);\n       if (scorer.docID() == -1 && min == 0 && max == DocIdSetIterator.NO_MORE_DOCS) {\n-        scoreAll(collector, iterator, twoPhase, acceptDocs);\n+        scoreAll(collector, combinedIterator, twoPhase, acceptDocs);\n         return DocIdSetIterator.NO_MORE_DOCS;\n       } else {\n         int doc = scorer.docID();\n-        if (doc < min) {\n-          if (twoPhase == null) {\n-            doc = iterator.advance(min);\n-          } else {\n-            doc = twoPhase.approximation().advance(min);\n+        if (doc < min) scorerIterator.advance(min);\n+        return scoreRange(collector, combinedIterator, twoPhase, acceptDocs, doc, max);\n+      }\n+    }\n+\n+    // conjunction iterator between scorer's iterator and collector's iterator", "originalCommit": "6384b1591b8054108cc94a0ae4c69da48abcb801", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NDE0OQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r395284149", "bodyText": "d732d7e", "author": "mayya-sharipova", "createdAt": "2020-03-19T19:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3MTk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3NjcyOA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r394676728", "bodyText": "this change is not required ? I see hotspot in the javadoc comment above so  we shouldn't touch it if it's not  required ;).", "author": "jimczi", "createdAt": "2020-03-18T22:30:31Z", "path": "lucene/core/src/java/org/apache/lucene/search/Weight.java", "diffHunk": "@@ -223,44 +257,23 @@ public int score(LeafCollector collector, Bits acceptDocs, int min, int max) thr\n      *  See <a href=\"https://issues.apache.org/jira/browse/LUCENE-5487\">LUCENE-5487</a> */\n     static int scoreRange(LeafCollector collector, DocIdSetIterator iterator, TwoPhaseIterator twoPhase,\n         Bits acceptDocs, int currentDoc, int end) throws IOException {\n-      if (twoPhase == null) {\n-        while (currentDoc < end) {\n-          if (acceptDocs == null || acceptDocs.get(currentDoc)) {\n-            collector.collect(currentDoc);\n-          }\n-          currentDoc = iterator.nextDoc();\n-        }\n-        return currentDoc;\n-      } else {\n-        final DocIdSetIterator approximation = twoPhase.approximation();\n-        while (currentDoc < end) {\n-          if ((acceptDocs == null || acceptDocs.get(currentDoc)) && twoPhase.matches()) {\n-            collector.collect(currentDoc);\n-          }\n-          currentDoc = approximation.nextDoc();\n+      while (currentDoc < end) {\n+        if ((acceptDocs == null || acceptDocs.get(currentDoc)) && (twoPhase == null || twoPhase.matches())) {\n+          collector.collect(currentDoc);\n         }\n-        return currentDoc;\n+        currentDoc = iterator.nextDoc();\n       }\n+      return currentDoc;", "originalCommit": "6384b1591b8054108cc94a0ae4c69da48abcb801", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4NDA3Mw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r395284073", "bodyText": "Addressed in d732d7e", "author": "mayya-sharipova", "createdAt": "2020-03-19T19:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3NjcyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3NzAzOQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r394677039", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (doc < min) scorerIterator.advance(min);\n          \n          \n            \n                    if (doc < min) {\n          \n          \n            \n                      doc = combinedIterator.advance(min);\n          \n          \n            \n                    }\n          \n      \n    \n    \n  \n\n?", "author": "jimczi", "createdAt": "2020-03-18T22:31:16Z", "path": "lucene/core/src/java/org/apache/lucene/search/Weight.java", "diffHunk": "@@ -201,20 +201,54 @@ public long cost() {\n     @Override\n     public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n       collector.setScorer(scorer);\n+      DocIdSetIterator scorerIterator = twoPhase == null? iterator: twoPhase.approximation();\n+      DocIdSetIterator combinedIterator = collector.iterator() == null ? scorerIterator: combineScorerAndCollectorIterators(scorerIterator, collector);\n       if (scorer.docID() == -1 && min == 0 && max == DocIdSetIterator.NO_MORE_DOCS) {\n-        scoreAll(collector, iterator, twoPhase, acceptDocs);\n+        scoreAll(collector, combinedIterator, twoPhase, acceptDocs);\n         return DocIdSetIterator.NO_MORE_DOCS;\n       } else {\n         int doc = scorer.docID();\n-        if (doc < min) {\n-          if (twoPhase == null) {\n-            doc = iterator.advance(min);\n-          } else {\n-            doc = twoPhase.approximation().advance(min);\n+        if (doc < min) scorerIterator.advance(min);", "originalCommit": "6384b1591b8054108cc94a0ae4c69da48abcb801", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI4Mzg4MA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r395283880", "bodyText": "Addressed in d732d7e", "author": "mayya-sharipova", "createdAt": "2020-03-19T19:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY3NzAzOQ=="}], "type": "inlineReview"}, {"oid": "d732d7eb9de67a597f67e91c9774104aa055e293", "url": "https://github.com/apache/lucene-solr/commit/d732d7eb9de67a597f67e91c9774104aa055e293", "message": "Address Feedback2", "committedDate": "2020-03-19T19:51:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI5MTgwMw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r395291803", "bodyText": "@jimczi  I am not very happy about this change because of 2 reasons:\n\nWe  can't use hitsThresholdChecker.isThresholdReached as it checks for greater than numHits, but we need to check starting with equal, as if there are no competitive docs later setBottom will not be called.\nDo you know the reason why hitsThresholdChecker.isThresholdReached  checks for greater than numHits and not greater or equal numHits?\ntotalHitsRelation may not end up to be set to TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO, as we set it only when we have  later competitive hits.\n\nI think it is better to have a previous implementation with a dedicated updateIterator function called from TopFieldCollector. WDYT?", "author": "mayya-sharipova", "createdAt": "2020-03-19T20:11:16Z", "path": "lucene/core/src/java/org/apache/lucene/search/LongDocValuesPointComparator.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.NumericDocValues;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.apache.lucene.search.FieldComparator.IteratorSupplierComparator;\n+\n+public class LongDocValuesPointComparator extends IteratorSupplierComparator<Long> {\n+    private final String field;\n+    private final int numHits;\n+    private final boolean reverse;\n+    private final long missingValue;\n+    private final long[] values;\n+    private long bottom;\n+    private long topValue;\n+    boolean hasTopValue = false; // indicates that topValue for searchAfter is set\n+    protected NumericDocValues docValues;\n+    private DocIdSetIterator iterator;\n+    private PointValues pointValues;\n+    private HitsThresholdChecker hitsThresholdChecker = null;\n+    private int maxDoc;\n+    private int maxDocVisited;\n+    private int updateCounter = 0;\n+\n+    public LongDocValuesPointComparator(String field, int numHits, boolean reverse, Long missingValue) {\n+        this.field = field;\n+        this.numHits = numHits;\n+        this.reverse = reverse;\n+        this.missingValue = missingValue != null ? missingValue : 0L;\n+        this.values = new long[numHits];\n+    }\n+\n+    @Override\n+    void setHitsThresholdChecker(HitsThresholdChecker hitsThresholdChecker) {\n+        this.hitsThresholdChecker = hitsThresholdChecker;\n+    }\n+\n+    private long getValueForDoc(int doc) throws IOException {\n+        if (docValues.advanceExact(doc)) {\n+            return docValues.longValue();\n+        } else {\n+            return missingValue;\n+        }\n+    }\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        return Long.compare(values[slot1], values[slot2]);\n+    }\n+\n+    @Override\n+    public void setTopValue(Long value) {\n+        topValue = value;\n+        hasTopValue = true;\n+    }\n+\n+    @Override\n+    public Long value(int slot) {\n+        return Long.valueOf(values[slot]);\n+    }\n+\n+    @Override\n+    public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+        docValues = DocValues.getNumeric(context.reader(), field);\n+        iterator = docValues;\n+        pointValues = context.reader().getPointValues(field);\n+        maxDoc = context.reader().maxDoc();\n+        maxDocVisited = 0;\n+        return this;\n+    }\n+\n+    @Override\n+    public void setBottom(int slot) throws IOException {\n+        this.bottom = values[slot];\n+        // can't use hitsThresholdChecker.isThresholdReached() as it uses > numHits,\n+        // while we want to update iterator as soon as threshold reaches numHits\n+        if (hitsThresholdChecker != null && (hitsThresholdChecker.getHitsThreshold() >= numHits)) {", "originalCommit": "d732d7eb9de67a597f67e91c9774104aa055e293", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "209bc2110558759abfb314e6f88993c32d6581db", "url": "https://github.com/apache/lucene-solr/commit/209bc2110558759abfb314e6f88993c32d6581db", "message": "Adjust tests", "committedDate": "2020-03-20T21:50:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyODAxOQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r396128019", "bodyText": "Can we move this initialization into the constructor, or is this not shareable and must be local storage? I think we call updateIterator in collect() right? If we can avoid object creation in an inner loop, that would be good. We could create both arrays unconditionally I think and set a boolean here to be used below?", "author": "msokolov", "createdAt": "2020-03-22T18:52:52Z", "path": "lucene/core/src/java/org/apache/lucene/search/LongDocValuesPointComparator.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.NumericDocValues;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.apache.lucene.search.FieldComparator.IteratorSupplierComparator;\n+\n+public class LongDocValuesPointComparator extends IteratorSupplierComparator<Long> {\n+    private final String field;\n+    private final boolean reverse;\n+    private final long missingValue;\n+    private final long[] values;\n+    private long bottom;\n+    private long topValue;\n+    boolean hasTopValue = false; // indicates that topValue for searchAfter is set\n+    protected NumericDocValues docValues;\n+    private DocIdSetIterator iterator;\n+    private PointValues pointValues;\n+    private int maxDoc;\n+    private int maxDocVisited;\n+    private int updateCounter = 0;\n+\n+    public LongDocValuesPointComparator(String field, int numHits, boolean reverse, Long missingValue) {\n+        this.field = field;\n+        this.reverse = reverse;\n+        this.missingValue = missingValue != null ? missingValue : 0L;\n+        this.values = new long[numHits];\n+    }\n+\n+    private long getValueForDoc(int doc) throws IOException {\n+        if (docValues.advanceExact(doc)) {\n+            return docValues.longValue();\n+        } else {\n+            return missingValue;\n+        }\n+    }\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        return Long.compare(values[slot1], values[slot2]);\n+    }\n+\n+    @Override\n+    public void setTopValue(Long value) {\n+        topValue = value;\n+        hasTopValue = true;\n+    }\n+\n+    @Override\n+    public Long value(int slot) {\n+        return Long.valueOf(values[slot]);\n+    }\n+\n+    @Override\n+    public LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+        docValues = DocValues.getNumeric(context.reader(), field);\n+        iterator = docValues;\n+        pointValues = context.reader().getPointValues(field);\n+        maxDoc = context.reader().maxDoc();\n+        maxDocVisited = 0;\n+        return this;\n+    }\n+\n+    @Override\n+    public void setBottom(int slot) throws IOException {\n+        this.bottom = values[slot];\n+    }\n+\n+    @Override\n+    public int compareBottom(int doc) throws IOException {\n+        return Long.compare(bottom, getValueForDoc(doc));\n+    }\n+\n+    @Override\n+    public int compareTop(int doc) throws IOException {\n+        return Long.compare(topValue, getValueForDoc(doc));\n+    }\n+\n+    @Override\n+    public void copy(int slot, int doc) throws IOException {\n+        maxDocVisited = doc;\n+        values[slot] = getValueForDoc(doc);\n+    }\n+\n+    @Override\n+    public void setScorer(Scorable scorer) throws IOException {}\n+\n+    public DocIdSetIterator iterator() {\n+        return iterator;\n+    }\n+\n+    // update its iterator to include possibly only docs that are \"stronger\" than the current bottom entry\n+    public void updateIterator() throws IOException {\n+        updateCounter++;\n+        if (updateCounter > 256 && (updateCounter & 0x1f) != 0x1f) { // Start sampling if we get called too much\n+            return;\n+        }\n+\n+        final byte[] maxValueAsBytes = reverse == false ? new byte[Long.BYTES] : hasTopValue ? new byte[Long.BYTES]: null;", "originalCommit": "209bc2110558759abfb314e6f88993c32d6581db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY5MDExNg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r396690116", "bodyText": "@msokolov  Thanks for the suggestion, indeed these values can be initialized in the comparator's constructor. As each topfieldcollector has its own comparator and processes segments sequentially, these values should be shareable.  Addressed in 95e1bc1", "author": "mayya-sharipova", "createdAt": "2020-03-23T19:05:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyODAxOQ=="}], "type": "inlineReview"}, {"oid": "95e1bc19f6561bb8e0b4709334d3e607604cfb5c", "url": "https://github.com/apache/lucene-solr/commit/95e1bc19f6561bb8e0b4709334d3e607604cfb5c", "message": "Address feedback", "committedDate": "2020-03-23T18:57:47Z", "type": "commit"}, {"oid": "0e3c7da860cd0fde96946505c32ed4d27f5c9b55", "url": "https://github.com/apache/lucene-solr/commit/0e3c7da860cd0fde96946505c32ed4d27f5c9b55", "message": "Add docs and correct bugs", "committedDate": "2020-03-25T16:28:19Z", "type": "commit"}, {"oid": "d7e9507888fcdc89a5b90357e183ff7d2bd4961b", "url": "https://github.com/apache/lucene-solr/commit/d7e9507888fcdc89a5b90357e183ff7d2bd4961b", "message": "Make constructor of LongDocValuesPointSortField public", "committedDate": "2020-03-25T20:16:32Z", "type": "commit"}, {"oid": "1154d4a0825d61415bff03e595904a1b01e22457", "url": "https://github.com/apache/lucene-solr/commit/1154d4a0825d61415bff03e595904a1b01e22457", "message": "Adjust docs and tests", "committedDate": "2020-03-26T20:05:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTgyOTk5OA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r399829998", "bodyText": "Can these be final, and allocated only in the constructor? I think it might be clearer to add a boolean \"hasTopValues\" and set that in setTopValue, rather than use the existence of these byte[]? Then you could make these final and eliminate the local variables where they get copied below", "author": "msokolov", "createdAt": "2020-03-29T17:45:11Z", "path": "lucene/core/src/java/org/apache/lucene/search/LongDocValuesPointComparator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.NumericDocValues;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.apache.lucene.search.FieldComparator.IterableComparator;\n+\n+/**\n+ * Expert: a FieldComparator class for long types corresponding to\n+ * {@link LongDocValuesPointSortField}.\n+ * This comparator provides {@code iterator} over competitive documents,\n+ * that are stronger than the current {@code bottom} value.\n+ */\n+public class LongDocValuesPointComparator extends IterableComparator<Long> {\n+    private final String field;\n+    private final boolean reverse;\n+    private final long missingValue;\n+    private final long[] values;\n+    private long bottom;\n+    private long topValue;\n+    protected NumericDocValues docValues;\n+    private DocIdSetIterator iterator;\n+    private PointValues pointValues;\n+    private int maxDoc;\n+    private int maxDocVisited;\n+    private int updateCounter = 0;\n+    private byte[] cmaxValueAsBytes = null;", "originalCommit": "1154d4a0825d61415bff03e595904a1b01e22457", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "39379a711936b38224dc249b1dfb20bb2f34e25f", "url": "https://github.com/apache/lucene-solr/commit/39379a711936b38224dc249b1dfb20bb2f34e25f", "message": "Optimized sort of field without points\n\nEnsure optimized sort works as expected (as long sort)\nof a field that is not indexed with points.", "committedDate": "2020-03-30T14:34:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczNjYzMQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r400736631", "bodyText": "maybe add a isExhaustive() method on the enum to avoid these large conditions?", "author": "jpountz", "createdAt": "2020-03-31T08:35:27Z", "path": "lucene/core/src/java/org/apache/lucene/search/ConstantScoreQuery.java", "diffHunk": "@@ -115,7 +115,7 @@ public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float bo\n       return new ConstantScoreWeight(this, boost) {\n         @Override\n         public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {\n-          if (scoreMode == ScoreMode.TOP_SCORES) {\n+          if (scoreMode == ScoreMode.TOP_SCORES || scoreMode == ScoreMode.TOP_DOCS || scoreMode == ScoreMode.TOP_DOCS_WITH_SCORES) {", "originalCommit": "39379a711936b38224dc249b1dfb20bb2f34e25f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczOTUzMw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r400739533", "bodyText": "maybe give it a more descriptive name, e.g. competitiveFilter", "author": "jpountz", "createdAt": "2020-03-31T08:40:15Z", "path": "lucene/core/src/java/org/apache/lucene/search/LeafCollector.java", "diffHunk": "@@ -93,4 +93,11 @@\n    */\n   void collect(int doc) throws IOException;\n \n+  /*\n+   * optionally returns an iterator over competitive documents\n+   */\n+  default DocIdSetIterator iterator() {", "originalCommit": "39379a711936b38224dc249b1dfb20bb2f34e25f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNzg3MQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r401227871", "bodyText": "Would competitiveIterator make sense?  If yes, addressed in 6c628f7", "author": "mayya-sharipova", "createdAt": "2020-03-31T21:32:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczOTUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczOTk1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r400739959", "bodyText": "Let's make it proper javadocs, not comments?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /*\n          \n          \n            \n              /**", "author": "jpountz", "createdAt": "2020-03-31T08:41:01Z", "path": "lucene/core/src/java/org/apache/lucene/search/LeafCollector.java", "diffHunk": "@@ -93,4 +93,11 @@\n    */\n   void collect(int doc) throws IOException;\n \n+  /*", "originalCommit": "39379a711936b38224dc249b1dfb20bb2f34e25f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyNzYzMg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r401227632", "bodyText": "Addressed in 6c628f7", "author": "mayya-sharipova", "createdAt": "2020-03-31T21:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczOTk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0MTA2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r400741063", "bodyText": "Can you document that the default is to return null which Lucene interprets as the collector doesn't filter any documents. It's probably worth making explicit as null iterators are elsewhere interpreted as matching no documents.", "author": "jpountz", "createdAt": "2020-03-31T08:42:44Z", "path": "lucene/core/src/java/org/apache/lucene/search/LeafCollector.java", "diffHunk": "@@ -93,4 +93,11 @@\n    */\n   void collect(int doc) throws IOException;\n \n+  /*\n+   * optionally returns an iterator over competitive documents", "originalCommit": "39379a711936b38224dc249b1dfb20bb2f34e25f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIyODMyNQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r401228325", "bodyText": "Thanks @jpountz\n\nIt's probably worth making explicit as null iterators are elsewhere interpreted as matching no documents\n\nWhat is the way to make this explicit?", "author": "mayya-sharipova", "createdAt": "2020-03-31T21:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc0MTA2Mw=="}], "type": "inlineReview"}, {"oid": "6c628f7aaccf0d949e709334ef1db303c518ff64", "url": "https://github.com/apache/lucene-solr/commit/6c628f7aaccf0d949e709334ef1db303c518ff64", "message": "Address Adrien's feedback", "committedDate": "2020-03-31T18:22:12Z", "type": "commit"}, {"oid": "eeb23c11de59d0fe1965a235d1bf80d284a0fa8b", "url": "https://github.com/apache/lucene-solr/commit/eeb23c11de59d0fe1965a235d1bf80d284a0fa8b", "message": "Add IterableFieldComparator\n\nAdd a decorator for FieldComparatori to add a functionality to skip\n over non-competitive docs", "committedDate": "2020-04-02T19:20:46Z", "type": "commit"}, {"oid": "89d241eb5ff320fbd43de7cda1b0a6b2a8bdcbde", "url": "https://github.com/apache/lucene-solr/commit/89d241eb5ff320fbd43de7cda1b0a6b2a8bdcbde", "message": "Address Alan's comments", "committedDate": "2020-04-06T21:50:59Z", "type": "commit"}, {"oid": "4448499f0f6c3bdcb7c641e4727d2329dfe7240f", "url": "https://github.com/apache/lucene-solr/commit/4448499f0f6c3bdcb7c641e4727d2329dfe7240f", "message": "Address Alan's feedback2", "committedDate": "2020-04-09T00:15:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0NjY0OA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r406046648", "bodyText": "Can we merge this with the  if statement immediately above it? That way scoreMode can stay final", "author": "romseygeek", "createdAt": "2020-04-09T08:38:21Z", "path": "lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java", "diffHunk": "@@ -302,20 +312,27 @@ private TopFieldCollector(FieldValueHitQueue<Entry> pq, int numHits,\n     this.numHits = numHits;\n     this.hitsThresholdChecker = hitsThresholdChecker;\n     this.numComparators = pq.getComparators().length;\n-    FieldComparator<?> fieldComparator = pq.getComparators()[0];\n+    FieldComparator<?> firstComparator = pq.getComparators()[0];\n     int reverseMul = pq.reverseMul[0];\n-    if (fieldComparator.getClass().equals(FieldComparator.RelevanceComparator.class)\n+    if (firstComparator.getClass().equals(FieldComparator.RelevanceComparator.class)\n           && reverseMul == 1 // if the natural sort is preserved (sort by descending relevance)\n           && hitsThresholdChecker.getHitsThreshold() != Integer.MAX_VALUE) {\n-      firstComparator = (FieldComparator.RelevanceComparator) fieldComparator;\n+      relevanceComparator = (FieldComparator.RelevanceComparator) firstComparator;\n       scoreMode = ScoreMode.TOP_SCORES;\n       canSetMinScore = true;\n     } else {\n-      firstComparator = null;\n+      relevanceComparator = null;\n       scoreMode = needsScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n       canSetMinScore = false;\n     }\n     this.minScoreAcc = minScoreAcc;\n+\n+    if ((firstComparator instanceof FilteringFieldComparator) && (hitsThresholdChecker.getHitsThreshold() != Integer.MAX_VALUE)) {", "originalCommit": "4448499f0f6c3bdcb7c641e4727d2329dfe7240f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwNzk1Mg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r407107952", "bodyText": "@romseygeek  Addressed in 719882e", "author": "mayya-sharipova", "createdAt": "2020-04-11T20:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA0NjY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzAxNg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r406053016", "bodyText": "Can we avoid having to set this explicitly? The fact that we're setting a totalHitsThreshold on the collector should be enough to tell the comparator that we're enabling skipping.  Maybe have a SkippableSortField implementation that wraps an existing SortField and overrides getComparator(); then in TopFieldCollector.create() we check if totalHitsThreshold is set and if so rebuild the sort", "author": "romseygeek", "createdAt": "2020-04-09T08:49:17Z", "path": "lucene/core/src/test/org/apache/lucene/search/TestSortOptimization.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.document.FloatDocValuesField;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.document.NumericDocValuesField;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.IndexWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.LuceneTestCase;\n+\n+import java.io.IOException;\n+\n+public class TestSortOptimization extends LuceneTestCase {\n+\n+  public void testLongSortOptimization() throws IOException {\n+    final Directory dir = newDirectory();\n+    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig());\n+    final int numDocs = atLeast(10000);\n+    for (int i = 0; i < numDocs; ++i) {\n+      final Document doc = new Document();\n+      doc.add(new NumericDocValuesField(\"my_field\", i));\n+      doc.add(new LongPoint(\"my_field\", i));\n+      writer.addDocument(doc);\n+    }\n+    final IndexReader reader = DirectoryReader.open(writer);\n+    IndexSearcher searcher = new IndexSearcher(reader);\n+    final SortField sortField = new SortField(\"my_field\", SortField.Type.LONG);\n+    sortField.allowFilterNonCompetitveDocs();", "originalCommit": "4448499f0f6c3bdcb7c641e4727d2329dfe7240f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwODYwNw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r407108607", "bodyText": "@romseygeek  Thanks for the suggestion.  It makes sense.\nIt is difficult to wrap SortField into another class that extends SortField, as SortField is a concrete class with several constructors.\nInstead, I  am setting sort.fields[0].allowFilterNonCompetitveDocs() when we create a TopFieldCollector with a set hitsTreshold.  What do you think of this implementation?\nPartially addressed in 719882e", "author": "mayya-sharipova", "createdAt": "2020-04-11T20:40:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyMzkyOQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r407523929", "bodyText": "I'm a bit wary of this, as I don't think we should be mutating objects passed in to the API that may well be shared (it's already a bit sketchy that SortField doesn't have final fields, mainly due to how the constructors are implemented - also the case for Sort, which I think we should make immutable as a follow-up).  There are several specialised implementations of SortField elsewhere in the codebase, so I don't think it should be too hard to create a new SkippingSortField that takes another SortField in its constructor and copies the relevant field, type, etc data from that?", "author": "romseygeek", "createdAt": "2020-04-13T15:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1MzAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1NDM5OA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r406054398", "bodyText": "Rather than defining these as abstract, maybe have two final fields set in a constructor?  Then the definitions become much less verbose: TOP_DOCS_WITH_SCORES(true, false);", "author": "romseygeek", "createdAt": "2020-04-09T08:51:43Z", "path": "lucene/core/src/java/org/apache/lucene/search/ScoreMode.java", "diffHunk": "@@ -51,10 +59,51 @@ public boolean needsScores() {\n     public boolean needsScores() {\n       return true;\n     }\n+    @Override\n+    public boolean isExhaustive() {\n+      return false;\n+    }\n+  },\n+\n+  /**\n+   * ScoreMode for top field collectors that can provide their own iterators,\n+   * to optionally allow to skip for non-competitive docs\n+   */\n+  TOP_DOCS {\n+    @Override\n+    public boolean needsScores() {\n+      return false;\n+    }\n+    @Override\n+    public boolean isExhaustive() {\n+      return false;\n+    }\n+  },\n+\n+  /**\n+   * ScoreMode for top field collectors that can provide their own iterators,\n+   * to optionally allow to skip for non-competitive docs.\n+   * This mode is used when there is a secondary sort by _score.\n+   */\n+  TOP_DOCS_WITH_SCORES {\n+    @Override\n+    public boolean needsScores() {\n+      return true;\n+    }\n+    @Override\n+    public boolean isExhaustive() {\n+      return false;\n+    }\n   };\n \n   /**\n    * Whether this {@link ScoreMode} needs to compute scores.\n    */\n   public abstract boolean needsScores();\n+\n+  /**\n+   * Returns {@code true} if for this {@link ScoreMode} it is necessary to process all documents,\n+   * or {@code false} if is enough to go through top documents only.\n+   */\n+  public abstract boolean isExhaustive();", "originalCommit": "4448499f0f6c3bdcb7c641e4727d2329dfe7240f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzEwODAzMg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r407108032", "bodyText": "@romseygeek Thanks, a very good suggestion, this indeed made the code more clear and less verbose.  Addressed in 719882e", "author": "mayya-sharipova", "createdAt": "2020-04-11T20:33:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA1NDM5OA=="}], "type": "inlineReview"}, {"oid": "719882eec45546e5643bb229624d6354eea05e49", "url": "https://github.com/apache/lucene-solr/commit/719882eec45546e5643bb229624d6354eea05e49", "message": "Address Alan's feedback 3", "committedDate": "2020-04-11T20:31:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNDc2NA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r407524764", "bodyText": "Do we need to distinguish between TOP_SCORES and TOP_DOCS_WITH_SCORES?", "author": "romseygeek", "createdAt": "2020-04-13T15:02:57Z", "path": "lucene/core/src/java/org/apache/lucene/search/ScoreMode.java", "diffHunk": "@@ -24,37 +24,53 @@\n   /**\n    * Produced scorers will allow visiting all matches and get their score.\n    */\n-  COMPLETE {\n-    @Override\n-    public boolean needsScores() {\n-      return true;\n-    }\n-  },\n+  COMPLETE(true, true),\n \n   /**\n    * Produced scorers will allow visiting all matches but scores won't be\n    * available.\n    */\n-  COMPLETE_NO_SCORES {\n-    @Override\n-    public boolean needsScores() {\n-      return false;\n-    }\n-  },\n+  COMPLETE_NO_SCORES(true, false),\n \n   /**\n    * Produced scorers will optionally allow skipping over non-competitive\n    * hits using the {@link Scorer#setMinCompetitiveScore(float)} API.\n    */\n-  TOP_SCORES {\n-    @Override\n-    public boolean needsScores() {\n-      return true;\n-    }\n-  };\n+  TOP_SCORES(false, true),\n+\n+  /**\n+   * ScoreMode for top field collectors that can provide their own iterators,\n+   * to optionally allow to skip for non-competitive docs\n+   */\n+  TOP_DOCS(false, false),\n+\n+  /**\n+   * ScoreMode for top field collectors that can provide their own iterators,\n+   * to optionally allow to skip for non-competitive docs.\n+   * This mode is used when there is a secondary sort by _score.\n+   */\n+  TOP_DOCS_WITH_SCORES(false, true);", "originalCommit": "719882eec45546e5643bb229624d6354eea05e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyMjA3NQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r408522075", "bodyText": "Yes, I think this distinction is necessary, if there is an additional sort field on _score.\nWeight and Scorer classes check collector's scoreMode for needsScores(), and will not calculate scores if needsScores is false.  I have added an additional test  to check that scores computed .", "author": "mayya-sharipova", "createdAt": "2020-04-15T01:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNDc2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4NzgwMA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r408887800", "bodyText": "But TOP_SCORES and TOP_DOCS_WITH_SCORES have identical needsScores() and isExhaustive() values, so I'm not sure why we need both?", "author": "romseygeek", "createdAt": "2020-04-15T14:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNDc2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY5MDg5NA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r410690894", "bodyText": "We need both because the first one sorts by score first and should use e.g. block-max WAND while the latter sorts by field so block-max WAND isn't relevant, but we still need to disable bulk scoring. needsScores and isExhaustive are not complete descriptions of these enum constants.", "author": "jpountz", "createdAt": "2020-04-18T12:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNDc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNTI4Nw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r407525287", "bodyText": "nit: extra line", "author": "romseygeek", "createdAt": "2020-04-13T15:03:49Z", "path": "lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java", "diffHunk": "@@ -30,6 +30,7 @@\n import org.apache.lucene.search.MaxScoreAccumulator.DocAndScore;\n import org.apache.lucene.search.TotalHits.Relation;\n \n+", "originalCommit": "719882eec45546e5643bb229624d6354eea05e49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNjUxOA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r407526518", "bodyText": "I think this should be done in FieldValueHitQueue.create() below - pass in a boolean to indicate that we want to skip hits if we can, and then do the wrapping/rewriting/whatever it ends up being as a part of building the sort queue", "author": "romseygeek", "createdAt": "2020-04-13T15:06:13Z", "path": "lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java", "diffHunk": "@@ -432,6 +462,12 @@ static TopFieldCollector create(Sort sort, int numHits, FieldDoc after,\n       throw new IllegalArgumentException(\"hitsThresholdChecker should not be null\");\n     }\n \n+    // here we assume that if hitsThreshold was set, we let the corresponding comparator to skip non-competitive docs\n+    // It is beneficial for the 1st field only to skip non-competitive docs\n+    if (hitsThresholdChecker.getHitsThreshold() != Integer.MAX_VALUE) {\n+      sort.fields[0].allowFilterNonCompetitveDocs();\n+    }\n+", "originalCommit": "719882eec45546e5643bb229624d6354eea05e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyMjcxNg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r408522716", "bodyText": "@romseygeek  Great suggestion to move wrapping into FieldValueHitQueue. I like the APIs more and more now.  Addressed in c84fe5e.\nAnd also looks like we don't even need any changes to SortField, we can just wrap comparators.", "author": "mayya-sharipova", "createdAt": "2020-04-15T01:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNjUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNzI4Mg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r407527282", "bodyText": "Is this necessary?", "author": "romseygeek", "createdAt": "2020-04-13T15:07:46Z", "path": "lucene/test-framework/src/java/org/apache/lucene/search/AssertingLeafCollector.java", "diffHunk": "@@ -50,5 +50,9 @@ public void collect(int doc) throws IOException {\n     lastCollected = doc;\n   }\n \n+  @Override\n+  public DocIdSetIterator filterIterator(DocIdSetIterator scorerIterator) {\n+    return super.filterIterator(scorerIterator);", "originalCommit": "719882eec45546e5643bb229624d6354eea05e49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUyMTE4Mg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r408521182", "bodyText": "@romseygeek Good notice, not it is not necessary. Removed in c84fe5e", "author": "mayya-sharipova", "createdAt": "2020-04-15T01:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzUyNzI4Mg=="}], "type": "inlineReview"}, {"oid": "c84fe5ed90b866dcbe41979dc6ba2ce2a874d59b", "url": "https://github.com/apache/lucene-solr/commit/c84fe5ed90b866dcbe41979dc6ba2ce2a874d59b", "message": "Address Alan's feedback 4", "committedDate": "2020-04-15T00:59:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMjEwNw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r408712107", "bodyText": "This allows for some hacks like returning an iterator that matches more docs than the scorer. I liked the previous approach that returned an iterator better.", "author": "jpountz", "createdAt": "2020-04-15T09:39:11Z", "path": "lucene/core/src/java/org/apache/lucene/search/LeafCollector.java", "diffHunk": "@@ -93,4 +93,16 @@\n    */\n   void collect(int doc) throws IOException;\n \n+  /**\n+   * Optionally creates a view of the scorerIterator where only competitive documents\n+   * in the scorerIterator are kept and non-competitive are skipped.\n+   *\n+   * Collectors should delegate this method to their comparators if\n+   * their comparators provide the skipping functionality over non-competitive docs.\n+   * The default is to return the same iterator which is interpreted as the collector doesn't filter any documents.\n+   */\n+  default DocIdSetIterator filterIterator(DocIdSetIterator scorerIterator) {\n+    return scorerIterator;\n+  }", "originalCommit": "c84fe5ed90b866dcbe41979dc6ba2ce2a874d59b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4ODY1Ng==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r408888656", "bodyText": "Oh that's a good point. +1 to just return an iterator based on the comparator, and do the conjuncion/combination in BulkScorer", "author": "romseygeek", "createdAt": "2020-04-15T14:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMjEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA3OTU4OQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r409079589", "bodyText": "Thanks, makes sense. Addressed in d7ef9b6", "author": "mayya-sharipova", "createdAt": "2020-04-15T19:23:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcxMjEwNw=="}], "type": "inlineReview"}, {"oid": "d7ef9b69567bd4c80c42f56c612ff95ceec6e26a", "url": "https://github.com/apache/lucene-solr/commit/d7ef9b69567bd4c80c42f56c612ff95ceec6e26a", "message": "Collector returns comparator's iterator", "committedDate": "2020-04-15T19:18:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY4ODE4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r410688181", "bodyText": "It feels wrong to have an iterator - which is a per-segment object - on a FieldComparator - which is a top-level object. Can we only have it on the LeafComparator?", "author": "jpountz", "createdAt": "2020-04-18T11:53:03Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringFieldComparator.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.IntPoint;\n+import org.apache.lucene.document.DoublePoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * Decorates a wrapped FieldComparator to add a functionality to skip over non-competitive docs.\n+ * FilteringFieldComparator provides two additional functions for a FieldComparator:\n+ * 1) {@code competitiveIterator()} that returns an iterator over\n+ *      competitive docs that are stronger than already collected docs.\n+ * 2) {@code setCanUpdateIterator()} that notifies the comparator when it is ok to start updating its internal iterator.\n+ *  This method is called from a collector to inform the comparator to start updating its iterator.\n+ */\n+public abstract class FilteringFieldComparator<T> extends FieldComparator<T> {\n+    final FieldComparator<T> in;\n+    protected DocIdSetIterator iterator = null;", "originalCommit": "d7ef9b69567bd4c80c42f56c612ff95ceec6e26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NTg5Mg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r412495892", "bodyText": "addressed in  24c94ff", "author": "mayya-sharipova", "createdAt": "2020-04-21T21:13:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY4ODE4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY4ODQzNw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r410688437", "bodyText": "I know some existing comparators do this but it'd be cleaner to not implement FieldComparator and LeafFieldComparator in the same class?", "author": "jpountz", "createdAt": "2020-04-18T11:55:34Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringFieldComparator.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.IntPoint;\n+import org.apache.lucene.document.DoublePoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * Decorates a wrapped FieldComparator to add a functionality to skip over non-competitive docs.\n+ * FilteringFieldComparator provides two additional functions for a FieldComparator:\n+ * 1) {@code competitiveIterator()} that returns an iterator over\n+ *      competitive docs that are stronger than already collected docs.\n+ * 2) {@code setCanUpdateIterator()} that notifies the comparator when it is ok to start updating its internal iterator.\n+ *  This method is called from a collector to inform the comparator to start updating its iterator.\n+ */\n+public abstract class FilteringFieldComparator<T> extends FieldComparator<T> {\n+    final FieldComparator<T> in;\n+    protected DocIdSetIterator iterator = null;\n+\n+    public FilteringFieldComparator(FieldComparator<T> in) {\n+        this.in = in;\n+    }\n+\n+    protected abstract void setCanUpdateIterator() throws IOException;\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        return in.compare(slot1, slot2);\n+    }\n+\n+    @Override\n+    public T value(int slot) {\n+        return in.value(slot);\n+    }\n+\n+    @Override\n+    public void setTopValue(T value) {\n+        in.setTopValue(value);\n+    }\n+\n+    @Override\n+    public int compareValues(T first, T second) {\n+        return in.compareValues(first, second);\n+    }\n+\n+    /**\n+     * Returns an iterator over competitive documents\n+     */\n+    public DocIdSetIterator competitiveIterator() {\n+        if (iterator == null) return null;\n+        return new DocIdSetIterator() {\n+            private int doc;\n+            @Override\n+            public int nextDoc() throws IOException {\n+                return doc = iterator.nextDoc();\n+            }\n+\n+            @Override\n+            public int docID() {\n+                return doc;\n+            }\n+\n+            @Override\n+            public long cost() {\n+                return iterator.cost();\n+            }\n+\n+            @Override\n+            public int advance(int target) throws IOException {\n+                return doc = iterator.advance(target);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Try to wrap a given field comparator to add to it a functionality to skip over non-competitive docs.\n+     * If for the given comparator the skip functionality is not implemented, return the comparator itself.\n+     */\n+    public static FieldComparator<?> wrapToFilteringComparator(FieldComparator<?> comparator, boolean reverse) {\n+        if (comparator instanceof FieldComparator.LongComparator){\n+            return new FilteringFieldComparator.FilteringLongComparator((FieldComparator.LongComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.IntComparator){\n+            return new FilteringFieldComparator.FilteringIntComparator((FieldComparator.IntComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.DoubleComparator){\n+            return new FilteringFieldComparator.FilteringDoubleComparator((FieldComparator.DoubleComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.FloatComparator){\n+            return new FilteringFieldComparator.FilteringFloatComparator((FieldComparator.FloatComparator) comparator, reverse);\n+        }\n+        return comparator;\n+    }\n+\n+    /**\n+     * A wrapper over {@code NumericComparator} that adds a functionality to filter non-competitive docs.\n+     */\n+    public static abstract class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> implements LeafFieldComparator {", "originalCommit": "d7ef9b69567bd4c80c42f56c612ff95ceec6e26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5Mzk4Ng==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r412493986", "bodyText": "@jpountz  Thanks for the review, very good points. I tried to address all your feedback in 24c94ff", "author": "mayya-sharipova", "createdAt": "2020-04-21T21:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY4ODQzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY4ODY3OA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r410688678", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                boolean filterNonCompetitveDocs = hitsThresholdChecker.getHitsThreshold() == Integer.MAX_VALUE ? false : true;\n          \n          \n            \n                boolean filterNonCompetitiveDocs = hitsThresholdChecker.getHitsThreshold() == Integer.MAX_VALUE ? false : true;", "author": "jpountz", "createdAt": "2020-04-18T11:58:37Z", "path": "lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java", "diffHunk": "@@ -432,7 +461,9 @@ static TopFieldCollector create(Sort sort, int numHits, FieldDoc after,\n       throw new IllegalArgumentException(\"hitsThresholdChecker should not be null\");\n     }\n \n-    FieldValueHitQueue<Entry> queue = FieldValueHitQueue.create(sort.fields, numHits);\n+    // here we assume that if hitsThreshold was set, we let a comparator to skip non-competitive docs\n+    boolean filterNonCompetitveDocs = hitsThresholdChecker.getHitsThreshold() == Integer.MAX_VALUE ? false : true;", "originalCommit": "d7ef9b69567bd4c80c42f56c612ff95ceec6e26a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY4OTg4Ng==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r410689886", "bodyText": "I believe that this pointValues == null aims at disabling the optimization when the field has doc values but is not indexed. However it can also be null if the field is indexed but doesn't have values on this segment. It's fine to not optimize this case right now, but let's at least leave a comment about it?", "author": "jpountz", "createdAt": "2020-04-18T12:11:47Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringFieldComparator.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.IntPoint;\n+import org.apache.lucene.document.DoublePoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * Decorates a wrapped FieldComparator to add a functionality to skip over non-competitive docs.\n+ * FilteringFieldComparator provides two additional functions for a FieldComparator:\n+ * 1) {@code competitiveIterator()} that returns an iterator over\n+ *      competitive docs that are stronger than already collected docs.\n+ * 2) {@code setCanUpdateIterator()} that notifies the comparator when it is ok to start updating its internal iterator.\n+ *  This method is called from a collector to inform the comparator to start updating its iterator.\n+ */\n+public abstract class FilteringFieldComparator<T> extends FieldComparator<T> {\n+    final FieldComparator<T> in;\n+    protected DocIdSetIterator iterator = null;\n+\n+    public FilteringFieldComparator(FieldComparator<T> in) {\n+        this.in = in;\n+    }\n+\n+    protected abstract void setCanUpdateIterator() throws IOException;\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        return in.compare(slot1, slot2);\n+    }\n+\n+    @Override\n+    public T value(int slot) {\n+        return in.value(slot);\n+    }\n+\n+    @Override\n+    public void setTopValue(T value) {\n+        in.setTopValue(value);\n+    }\n+\n+    @Override\n+    public int compareValues(T first, T second) {\n+        return in.compareValues(first, second);\n+    }\n+\n+    /**\n+     * Returns an iterator over competitive documents\n+     */\n+    public DocIdSetIterator competitiveIterator() {\n+        if (iterator == null) return null;\n+        return new DocIdSetIterator() {\n+            private int doc;\n+            @Override\n+            public int nextDoc() throws IOException {\n+                return doc = iterator.nextDoc();\n+            }\n+\n+            @Override\n+            public int docID() {\n+                return doc;\n+            }\n+\n+            @Override\n+            public long cost() {\n+                return iterator.cost();\n+            }\n+\n+            @Override\n+            public int advance(int target) throws IOException {\n+                return doc = iterator.advance(target);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Try to wrap a given field comparator to add to it a functionality to skip over non-competitive docs.\n+     * If for the given comparator the skip functionality is not implemented, return the comparator itself.\n+     */\n+    public static FieldComparator<?> wrapToFilteringComparator(FieldComparator<?> comparator, boolean reverse) {\n+        if (comparator instanceof FieldComparator.LongComparator){\n+            return new FilteringFieldComparator.FilteringLongComparator((FieldComparator.LongComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.IntComparator){\n+            return new FilteringFieldComparator.FilteringIntComparator((FieldComparator.IntComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.DoubleComparator){\n+            return new FilteringFieldComparator.FilteringDoubleComparator((FieldComparator.DoubleComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.FloatComparator){\n+            return new FilteringFieldComparator.FilteringFloatComparator((FieldComparator.FloatComparator) comparator, reverse);\n+        }\n+        return comparator;\n+    }\n+\n+    /**\n+     * A wrapper over {@code NumericComparator} that adds a functionality to filter non-competitive docs.\n+     */\n+    public static abstract class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> implements LeafFieldComparator {\n+        private final boolean reverse;\n+        private boolean hasTopValue = false;\n+        private PointValues pointValues;\n+        private final int bytesCount;\n+        private final byte[] minValueAsBytes;\n+        private final byte[] maxValueAsBytes;\n+        private boolean minValueExist = false;\n+        private boolean maxValueExist = false;\n+        private int maxDoc;\n+        private int maxDocVisited;\n+        private int updateCounter = 0;\n+        private final String field;\n+        protected boolean canUpdateIterator = false; // set to true when queue becomes full and hitsThreshold is reached\n+\n+        public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, int bytesCount) {\n+            super(in);\n+            this.field = in.field;\n+            this.bytesCount = bytesCount;\n+            this.reverse = reverse;\n+            minValueAsBytes = new byte[bytesCount];\n+            maxValueAsBytes = new byte[bytesCount];\n+            if (reverse) {\n+                minValueExist = true;\n+            } else {\n+                maxValueExist = true;\n+            }\n+        }\n+\n+        @Override\n+        public void setCanUpdateIterator() throws IOException {\n+            this.canUpdateIterator = true;\n+            // for the 1st time queue becomes full and hitsThreshold is reached\n+            // we can start updating competitive iterator\n+            updateCompetitiveIterator();\n+        }\n+\n+        @Override\n+        public void setTopValue(T value) {\n+            hasTopValue = true;\n+            if (reverse) {\n+                maxValueExist = true;\n+            } else {\n+                minValueExist = true;\n+            }\n+            in.setTopValue(value);\n+        }\n+\n+        @Override\n+        public void setBottom(int slot) throws IOException {\n+            ((NumericComparator) in).setBottom(slot);\n+            updateCompetitiveIterator(); // update an iterator if we set a new bottom\n+        }\n+\n+        @Override\n+        public int compareBottom(int doc) throws IOException {\n+            return ((NumericComparator) in).compareBottom(doc);\n+        }\n+\n+        @Override\n+        public int compareTop(int doc) throws IOException {\n+            return ((NumericComparator) in).compareTop(doc);\n+        }\n+\n+        @Override\n+        public void copy(int slot, int doc) throws IOException {\n+            ((NumericComparator) in).copy(slot, doc);\n+        }\n+\n+        @Override\n+        public void setScorer(Scorable scorer) throws IOException {}\n+\n+        @Override\n+        public final LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+            ((NumericComparator) in).doSetNextReader(context);\n+            pointValues = context.reader().getPointValues(field);\n+            iterator = pointValues == null ? null : ((NumericComparator)in).currentReaderValues;\n+            maxDoc = context.reader().maxDoc();\n+            maxDocVisited = 0;\n+            updateCompetitiveIterator(); // update an iterator if we have a new segment\n+            return this;\n+        }\n+\n+        // update its iterator to include possibly only docs that are \"stronger\" than the current bottom entry\n+        public void updateCompetitiveIterator() throws IOException {\n+            if (canUpdateIterator == false) return;\n+            if (pointValues == null) return;", "originalCommit": "d7ef9b69567bd4c80c42f56c612ff95ceec6e26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjE0NQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r412496145", "bodyText": "addressed in  24c94ff", "author": "mayya-sharipova", "createdAt": "2020-04-21T21:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY4OTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY5MDM5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r410690396", "bodyText": "I don't think we should steal the iterator of the wrapped comparator, it's a hacky and I believe that it could cause bugs due to the iterator being advanced on doc IDs out-of-order since the same iterator has two consumers that don't know about each other.", "author": "jpountz", "createdAt": "2020-04-18T12:16:55Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringFieldComparator.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.IntPoint;\n+import org.apache.lucene.document.DoublePoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * Decorates a wrapped FieldComparator to add a functionality to skip over non-competitive docs.\n+ * FilteringFieldComparator provides two additional functions for a FieldComparator:\n+ * 1) {@code competitiveIterator()} that returns an iterator over\n+ *      competitive docs that are stronger than already collected docs.\n+ * 2) {@code setCanUpdateIterator()} that notifies the comparator when it is ok to start updating its internal iterator.\n+ *  This method is called from a collector to inform the comparator to start updating its iterator.\n+ */\n+public abstract class FilteringFieldComparator<T> extends FieldComparator<T> {\n+    final FieldComparator<T> in;\n+    protected DocIdSetIterator iterator = null;\n+\n+    public FilteringFieldComparator(FieldComparator<T> in) {\n+        this.in = in;\n+    }\n+\n+    protected abstract void setCanUpdateIterator() throws IOException;\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        return in.compare(slot1, slot2);\n+    }\n+\n+    @Override\n+    public T value(int slot) {\n+        return in.value(slot);\n+    }\n+\n+    @Override\n+    public void setTopValue(T value) {\n+        in.setTopValue(value);\n+    }\n+\n+    @Override\n+    public int compareValues(T first, T second) {\n+        return in.compareValues(first, second);\n+    }\n+\n+    /**\n+     * Returns an iterator over competitive documents\n+     */\n+    public DocIdSetIterator competitiveIterator() {\n+        if (iterator == null) return null;\n+        return new DocIdSetIterator() {\n+            private int doc;\n+            @Override\n+            public int nextDoc() throws IOException {\n+                return doc = iterator.nextDoc();\n+            }\n+\n+            @Override\n+            public int docID() {\n+                return doc;\n+            }\n+\n+            @Override\n+            public long cost() {\n+                return iterator.cost();\n+            }\n+\n+            @Override\n+            public int advance(int target) throws IOException {\n+                return doc = iterator.advance(target);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Try to wrap a given field comparator to add to it a functionality to skip over non-competitive docs.\n+     * If for the given comparator the skip functionality is not implemented, return the comparator itself.\n+     */\n+    public static FieldComparator<?> wrapToFilteringComparator(FieldComparator<?> comparator, boolean reverse) {\n+        if (comparator instanceof FieldComparator.LongComparator){\n+            return new FilteringFieldComparator.FilteringLongComparator((FieldComparator.LongComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.IntComparator){\n+            return new FilteringFieldComparator.FilteringIntComparator((FieldComparator.IntComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.DoubleComparator){\n+            return new FilteringFieldComparator.FilteringDoubleComparator((FieldComparator.DoubleComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.FloatComparator){\n+            return new FilteringFieldComparator.FilteringFloatComparator((FieldComparator.FloatComparator) comparator, reverse);\n+        }\n+        return comparator;\n+    }\n+\n+    /**\n+     * A wrapper over {@code NumericComparator} that adds a functionality to filter non-competitive docs.\n+     */\n+    public static abstract class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> implements LeafFieldComparator {\n+        private final boolean reverse;\n+        private boolean hasTopValue = false;\n+        private PointValues pointValues;\n+        private final int bytesCount;\n+        private final byte[] minValueAsBytes;\n+        private final byte[] maxValueAsBytes;\n+        private boolean minValueExist = false;\n+        private boolean maxValueExist = false;\n+        private int maxDoc;\n+        private int maxDocVisited;\n+        private int updateCounter = 0;\n+        private final String field;\n+        protected boolean canUpdateIterator = false; // set to true when queue becomes full and hitsThreshold is reached\n+\n+        public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, int bytesCount) {\n+            super(in);\n+            this.field = in.field;\n+            this.bytesCount = bytesCount;\n+            this.reverse = reverse;\n+            minValueAsBytes = new byte[bytesCount];\n+            maxValueAsBytes = new byte[bytesCount];\n+            if (reverse) {\n+                minValueExist = true;\n+            } else {\n+                maxValueExist = true;\n+            }\n+        }\n+\n+        @Override\n+        public void setCanUpdateIterator() throws IOException {\n+            this.canUpdateIterator = true;\n+            // for the 1st time queue becomes full and hitsThreshold is reached\n+            // we can start updating competitive iterator\n+            updateCompetitiveIterator();\n+        }\n+\n+        @Override\n+        public void setTopValue(T value) {\n+            hasTopValue = true;\n+            if (reverse) {\n+                maxValueExist = true;\n+            } else {\n+                minValueExist = true;\n+            }\n+            in.setTopValue(value);\n+        }\n+\n+        @Override\n+        public void setBottom(int slot) throws IOException {\n+            ((NumericComparator) in).setBottom(slot);\n+            updateCompetitiveIterator(); // update an iterator if we set a new bottom\n+        }\n+\n+        @Override\n+        public int compareBottom(int doc) throws IOException {\n+            return ((NumericComparator) in).compareBottom(doc);\n+        }\n+\n+        @Override\n+        public int compareTop(int doc) throws IOException {\n+            return ((NumericComparator) in).compareTop(doc);\n+        }\n+\n+        @Override\n+        public void copy(int slot, int doc) throws IOException {\n+            ((NumericComparator) in).copy(slot, doc);\n+        }\n+\n+        @Override\n+        public void setScorer(Scorable scorer) throws IOException {}\n+\n+        @Override\n+        public final LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+            ((NumericComparator) in).doSetNextReader(context);\n+            pointValues = context.reader().getPointValues(field);\n+            iterator = pointValues == null ? null : ((NumericComparator)in).currentReaderValues;", "originalCommit": "d7ef9b69567bd4c80c42f56c612ff95ceec6e26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY5MDU0MA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r410690540", "bodyText": "Furthermore we use iterator.cost() >>> 3 below as a condition. I think that the first time we should instead use the cost of the scorer otherwise this approach is going to slow down selective queries.", "author": "jpountz", "createdAt": "2020-04-18T12:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY5MDM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjEwMg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r412496102", "bodyText": "addressed in  24c94ff", "author": "mayya-sharipova", "createdAt": "2020-04-21T21:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY5MDM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY5MTM0Mg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r410691342", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  DocIdSetIterator scorerIterator = twoPhase == null? iterator : twoPhase.approximation();\n          \n          \n            \n                  DocIdSetIterator scorerIterator = twoPhase == null ? iterator : twoPhase.approximation();", "author": "jpountz", "createdAt": "2020-04-18T12:25:53Z", "path": "lucene/core/src/java/org/apache/lucene/search/Weight.java", "diffHunk": "@@ -201,19 +202,20 @@ public long cost() {\n     @Override\n     public int score(LeafCollector collector, Bits acceptDocs, int min, int max) throws IOException {\n       collector.setScorer(scorer);\n+      DocIdSetIterator scorerIterator = twoPhase == null? iterator : twoPhase.approximation();", "originalCommit": "d7ef9b69567bd4c80c42f56c612ff95ceec6e26a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY5MjgxMg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r410692812", "bodyText": "I believe that doing it is incorrect if a missing value is configured and would be competitive.", "author": "jpountz", "createdAt": "2020-04-18T12:39:14Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringFieldComparator.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.IntPoint;\n+import org.apache.lucene.document.DoublePoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * Decorates a wrapped FieldComparator to add a functionality to skip over non-competitive docs.\n+ * FilteringFieldComparator provides two additional functions for a FieldComparator:\n+ * 1) {@code competitiveIterator()} that returns an iterator over\n+ *      competitive docs that are stronger than already collected docs.\n+ * 2) {@code setCanUpdateIterator()} that notifies the comparator when it is ok to start updating its internal iterator.\n+ *  This method is called from a collector to inform the comparator to start updating its iterator.\n+ */\n+public abstract class FilteringFieldComparator<T> extends FieldComparator<T> {\n+    final FieldComparator<T> in;\n+    protected DocIdSetIterator iterator = null;\n+\n+    public FilteringFieldComparator(FieldComparator<T> in) {\n+        this.in = in;\n+    }\n+\n+    protected abstract void setCanUpdateIterator() throws IOException;\n+\n+    @Override\n+    public int compare(int slot1, int slot2) {\n+        return in.compare(slot1, slot2);\n+    }\n+\n+    @Override\n+    public T value(int slot) {\n+        return in.value(slot);\n+    }\n+\n+    @Override\n+    public void setTopValue(T value) {\n+        in.setTopValue(value);\n+    }\n+\n+    @Override\n+    public int compareValues(T first, T second) {\n+        return in.compareValues(first, second);\n+    }\n+\n+    /**\n+     * Returns an iterator over competitive documents\n+     */\n+    public DocIdSetIterator competitiveIterator() {\n+        if (iterator == null) return null;\n+        return new DocIdSetIterator() {\n+            private int doc;\n+            @Override\n+            public int nextDoc() throws IOException {\n+                return doc = iterator.nextDoc();\n+            }\n+\n+            @Override\n+            public int docID() {\n+                return doc;\n+            }\n+\n+            @Override\n+            public long cost() {\n+                return iterator.cost();\n+            }\n+\n+            @Override\n+            public int advance(int target) throws IOException {\n+                return doc = iterator.advance(target);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Try to wrap a given field comparator to add to it a functionality to skip over non-competitive docs.\n+     * If for the given comparator the skip functionality is not implemented, return the comparator itself.\n+     */\n+    public static FieldComparator<?> wrapToFilteringComparator(FieldComparator<?> comparator, boolean reverse) {\n+        if (comparator instanceof FieldComparator.LongComparator){\n+            return new FilteringFieldComparator.FilteringLongComparator((FieldComparator.LongComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.IntComparator){\n+            return new FilteringFieldComparator.FilteringIntComparator((FieldComparator.IntComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.DoubleComparator){\n+            return new FilteringFieldComparator.FilteringDoubleComparator((FieldComparator.DoubleComparator) comparator, reverse);\n+        }\n+        if (comparator instanceof FieldComparator.FloatComparator){\n+            return new FilteringFieldComparator.FilteringFloatComparator((FieldComparator.FloatComparator) comparator, reverse);\n+        }\n+        return comparator;\n+    }\n+\n+    /**\n+     * A wrapper over {@code NumericComparator} that adds a functionality to filter non-competitive docs.\n+     */\n+    public static abstract class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> implements LeafFieldComparator {\n+        private final boolean reverse;\n+        private boolean hasTopValue = false;\n+        private PointValues pointValues;\n+        private final int bytesCount;\n+        private final byte[] minValueAsBytes;\n+        private final byte[] maxValueAsBytes;\n+        private boolean minValueExist = false;\n+        private boolean maxValueExist = false;\n+        private int maxDoc;\n+        private int maxDocVisited;\n+        private int updateCounter = 0;\n+        private final String field;\n+        protected boolean canUpdateIterator = false; // set to true when queue becomes full and hitsThreshold is reached\n+\n+        public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, int bytesCount) {\n+            super(in);\n+            this.field = in.field;\n+            this.bytesCount = bytesCount;\n+            this.reverse = reverse;\n+            minValueAsBytes = new byte[bytesCount];\n+            maxValueAsBytes = new byte[bytesCount];\n+            if (reverse) {\n+                minValueExist = true;\n+            } else {\n+                maxValueExist = true;\n+            }\n+        }\n+\n+        @Override\n+        public void setCanUpdateIterator() throws IOException {\n+            this.canUpdateIterator = true;\n+            // for the 1st time queue becomes full and hitsThreshold is reached\n+            // we can start updating competitive iterator\n+            updateCompetitiveIterator();\n+        }\n+\n+        @Override\n+        public void setTopValue(T value) {\n+            hasTopValue = true;\n+            if (reverse) {\n+                maxValueExist = true;\n+            } else {\n+                minValueExist = true;\n+            }\n+            in.setTopValue(value);\n+        }\n+\n+        @Override\n+        public void setBottom(int slot) throws IOException {\n+            ((NumericComparator) in).setBottom(slot);\n+            updateCompetitiveIterator(); // update an iterator if we set a new bottom\n+        }\n+\n+        @Override\n+        public int compareBottom(int doc) throws IOException {\n+            return ((NumericComparator) in).compareBottom(doc);\n+        }\n+\n+        @Override\n+        public int compareTop(int doc) throws IOException {\n+            return ((NumericComparator) in).compareTop(doc);\n+        }\n+\n+        @Override\n+        public void copy(int slot, int doc) throws IOException {\n+            ((NumericComparator) in).copy(slot, doc);\n+        }\n+\n+        @Override\n+        public void setScorer(Scorable scorer) throws IOException {}\n+\n+        @Override\n+        public final LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+            ((NumericComparator) in).doSetNextReader(context);\n+            pointValues = context.reader().getPointValues(field);\n+            iterator = pointValues == null ? null : ((NumericComparator)in).currentReaderValues;\n+            maxDoc = context.reader().maxDoc();\n+            maxDocVisited = 0;\n+            updateCompetitiveIterator(); // update an iterator if we have a new segment\n+            return this;\n+        }\n+\n+        // update its iterator to include possibly only docs that are \"stronger\" than the current bottom entry\n+        public void updateCompetitiveIterator() throws IOException {\n+            if (canUpdateIterator == false) return;\n+            if (pointValues == null) return;\n+            updateCounter++;\n+            if (updateCounter > 256 && (updateCounter & 0x1f) != 0x1f) { // Start sampling if we get called too much\n+                return;\n+            }\n+            if (reverse == false) {\n+                encodeBottom(maxValueAsBytes);\n+                if (hasTopValue) {\n+                    encodeTop(minValueAsBytes);\n+                }\n+            } else {\n+                encodeBottom(minValueAsBytes);\n+                if (hasTopValue) {\n+                    encodeTop(maxValueAsBytes);\n+                }\n+            };\n+            DocIdSetBuilder result = new DocIdSetBuilder(maxDoc);\n+            PointValues.IntersectVisitor visitor = new PointValues.IntersectVisitor() {\n+                DocIdSetBuilder.BulkAdder adder;\n+                @Override\n+                public void grow(int count) {\n+                    adder = result.grow(count);\n+                }\n+\n+                @Override\n+                public void visit(int docID) {\n+                    if (docID <= maxDocVisited) {\n+                        return; // Already visited or skipped\n+                    }\n+                    adder.add(docID);\n+                }\n+\n+                @Override\n+                public void visit(int docID, byte[] packedValue) {\n+                    if (docID <= maxDocVisited) {\n+                        return;  // Already visited or skipped\n+                    }\n+                    if (maxValueExist) {\n+                        // doc's value is too high\n+                        if (Arrays.compareUnsigned(packedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount) > 0) return;\n+                    }\n+                    if (minValueExist) {\n+                        // doc's value is too low\n+                        if (Arrays.compareUnsigned(packedValue, 0, bytesCount, minValueAsBytes, 0, bytesCount) < 0) return;\n+                    }\n+                    adder.add(docID); // doc is competitive\n+                }\n+\n+                @Override\n+                public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n+                    if ((maxValueExist && Arrays.compareUnsigned(minPackedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount) > 0) ||\n+                            (minValueExist && Arrays.compareUnsigned(maxPackedValue, 0, bytesCount, minValueAsBytes, 0, bytesCount) < 0)) {\n+                        return PointValues.Relation.CELL_OUTSIDE_QUERY;\n+                    }\n+                    if ((maxValueExist && Arrays.compareUnsigned(maxPackedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount) > 0) ||\n+                            (minValueExist && Arrays.compareUnsigned(minPackedValue, 0, bytesCount, minValueAsBytes, 0, bytesCount) < 0)) {\n+                        return PointValues.Relation.CELL_CROSSES_QUERY;\n+                    }\n+                    return PointValues.Relation.CELL_INSIDE_QUERY;\n+                }\n+            };\n+            final long threshold = iterator.cost() >>> 3;\n+            long estimatedNumberOfMatches = pointValues.estimatePointCount(visitor); // runs in O(log(numPoints))\n+            if (estimatedNumberOfMatches >= threshold) {\n+                // the new range is not selective enough to be worth materializing, it doesn't reduce number of docs at least 8x\n+                return;\n+            }\n+            pointValues.intersect(visitor);\n+            this.iterator = result.build().iterator();", "originalCommit": "d7ef9b69567bd4c80c42f56c612ff95ceec6e26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ5NjMxMw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r412496313", "bodyText": "addressed in  24c94ff", "author": "mayya-sharipova", "createdAt": "2020-04-21T21:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDY5MjgxMg=="}], "type": "inlineReview"}, {"oid": "24c94ff85a5b6d6a9dc2d110b7f0c83df06f64c4", "url": "https://github.com/apache/lucene-solr/commit/24c94ff85a5b6d6a9dc2d110b7f0c83df06f64c4", "message": "Address Adrien's feedback", "committedDate": "2020-04-21T21:04:46Z", "type": "commit"}, {"oid": "2fd9075f1ea7f5d084965c3687cb28da45eb9432", "url": "https://github.com/apache/lucene-solr/commit/2fd9075f1ea7f5d084965c3687cb28da45eb9432", "message": "Set scorer for inner comparator", "committedDate": "2020-04-23T20:32:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MjI1MQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r414392251", "bodyText": "We've had endless discussions about whether or not to delegate in FilterXXX classes and I think that the consensus is that we should only delegate abstract methods. Since this one has a default implementation, let's not delegate and look for extensions of FilterCollector that should delegate it? (e.g. asserting collectors)", "author": "jpountz", "createdAt": "2020-04-24T08:27:42Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilterLeafCollector.java", "diffHunk": "@@ -53,4 +53,8 @@ public String toString() {\n     return name + \"(\" + in + \")\";\n   }\n \n+  @Override\n+  public DocIdSetIterator competitiveIterator() {\n+    return in.competitiveIterator();\n+  }", "originalCommit": "2fd9075f1ea7f5d084965c3687cb28da45eb9432", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzM5OTQyOA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r417399428", "bodyText": "addressed in 7120424", "author": "mayya-sharipova", "createdAt": "2020-04-29T15:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MjI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MzY4Mw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r414393683", "bodyText": "indentation looks wrong, Lucene uses 2-spaces indentation", "author": "jpountz", "createdAt": "2020-04-24T08:29:55Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringFieldComparator.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Decorates a wrapped FieldComparator to add a functionality to skip over non-competitive docs.\n+ * FilteringFieldComparator provides two additional functions for a FieldComparator:\n+ * 1) {@code competitiveIterator()} that returns an iterator over\n+ *      competitive docs that are stronger than already collected docs.\n+ * 2) {@code setCanUpdateIterator()} that notifies the comparator when it is ok to start updating its internal iterator.\n+ *  This method is called from a collector to inform the comparator to start updating its iterator.\n+ */\n+public abstract class FilteringFieldComparator<T> extends FieldComparator<T> {\n+    final FieldComparator<T> in;", "originalCommit": "2fd9075f1ea7f5d084965c3687cb28da45eb9432", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwMjA5MA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r417402090", "bodyText": "addressed in b8e138c", "author": "mayya-sharipova", "createdAt": "2020-04-29T15:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5MzY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NDc5MA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r414394790", "bodyText": "Let's only have this method on LeafFieldCompatarors, e.g. by doing something like this? FieldComparators are top-level objects so it doesn't make sense to have leaf-level objects defined on them like DocIdSetIterators.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected abstract DocIdSetIterator competitiveIterator();\n          \n          \n            \n              @Override\n          \n          \n            \n              public abstract FilteringLeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException; // covariant return type\n          \n          \n            \n            \n          \n          \n            \n              public static interface FilteringLeafFieldComparator extends LeafFieldComparator {\n          \n          \n            \n                DocIdSetIterator competitiveIterator();\n          \n          \n            \n              }\n          \n      \n    \n    \n  \n\nThen there's a question of whether setCanUpdateIterator should go there too as well or not.", "author": "jpountz", "createdAt": "2020-04-24T08:31:37Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringFieldComparator.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Decorates a wrapped FieldComparator to add a functionality to skip over non-competitive docs.\n+ * FilteringFieldComparator provides two additional functions for a FieldComparator:\n+ * 1) {@code competitiveIterator()} that returns an iterator over\n+ *      competitive docs that are stronger than already collected docs.\n+ * 2) {@code setCanUpdateIterator()} that notifies the comparator when it is ok to start updating its internal iterator.\n+ *  This method is called from a collector to inform the comparator to start updating its iterator.\n+ */\n+public abstract class FilteringFieldComparator<T> extends FieldComparator<T> {\n+    final FieldComparator<T> in;\n+\n+    public FilteringFieldComparator(FieldComparator<T> in) {\n+        this.in = in;\n+    }\n+\n+    protected abstract DocIdSetIterator competitiveIterator();", "originalCommit": "2fd9075f1ea7f5d084965c3687cb28da45eb9432", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwMDEyMg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r417400122", "bodyText": "Thanks @jpountz, indeed the suggested structure is much better. addressed in 7120424", "author": "mayya-sharipova", "createdAt": "2020-04-29T15:20:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NDc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NTM4NA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r414395384", "bodyText": "can you add javadocs?", "author": "jpountz", "createdAt": "2020-04-24T08:32:34Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringFieldComparator.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Decorates a wrapped FieldComparator to add a functionality to skip over non-competitive docs.\n+ * FilteringFieldComparator provides two additional functions for a FieldComparator:\n+ * 1) {@code competitiveIterator()} that returns an iterator over\n+ *      competitive docs that are stronger than already collected docs.\n+ * 2) {@code setCanUpdateIterator()} that notifies the comparator when it is ok to start updating its internal iterator.\n+ *  This method is called from a collector to inform the comparator to start updating its iterator.\n+ */\n+public abstract class FilteringFieldComparator<T> extends FieldComparator<T> {\n+    final FieldComparator<T> in;\n+\n+    public FilteringFieldComparator(FieldComparator<T> in) {\n+        this.in = in;\n+    }\n+\n+    protected abstract DocIdSetIterator competitiveIterator();\n+\n+    protected abstract void setCanUpdateIterator() throws IOException;", "originalCommit": "2fd9075f1ea7f5d084965c3687cb28da45eb9432", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwMDM0MA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r417400340", "bodyText": "addressed in 7120424", "author": "mayya-sharipova", "createdAt": "2020-04-29T15:20:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDM5NTM4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMTUyMw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r414401523", "bodyText": "Related to my above comment, I think we could make things cleaner by implementing the comparator and the leaf comparator in different classes. Then each class would be smaller and many fields could become final.", "author": "jpountz", "createdAt": "2020-04-24T08:41:50Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringNumericComparator.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.DoublePoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.document.IntPoint;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * A wrapper over {@code NumericComparator} that adds a functionality to filter non-competitive docs.\n+ */\n+public abstract class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> implements LeafFieldComparator {\n+    protected final boolean reverse;\n+    private boolean hasTopValue = false;\n+    private PointValues pointValues;\n+    private final int bytesCount;\n+    private final byte[] minValueAsBytes;\n+    private final byte[] maxValueAsBytes;\n+    private boolean minValueExist = false;\n+    private boolean maxValueExist = false;\n+    private int maxDoc;\n+    private int maxDocVisited;\n+    private int updateCounter = 0;\n+    private final String field;\n+    protected boolean canUpdateIterator = false; // set to true when queue becomes full and hitsThreshold is reached\n+    protected DocIdSetIterator competitiveIterator = null;\n+    private long iteratorCost = 0;\n+\n+    public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, int bytesCount) {\n+        super(in);\n+        this.field = in.field;\n+        this.bytesCount = bytesCount;\n+        this.reverse = reverse;\n+        minValueAsBytes = new byte[bytesCount];\n+        maxValueAsBytes = new byte[bytesCount];\n+        if (reverse) {\n+            minValueExist = true;\n+        } else {\n+            maxValueExist = true;\n+        }\n+    }\n+\n+    /**\n+     * Returns an iterator over competitive documents\n+     */\n+    @Override\n+    public DocIdSetIterator competitiveIterator() {\n+        if (competitiveIterator == null) return null;\n+        return new DocIdSetIterator() {\n+            private int doc;\n+            @Override\n+            public int nextDoc() throws IOException {\n+                return doc = competitiveIterator.nextDoc();\n+            }\n+\n+            @Override\n+            public int docID() {\n+                return doc;\n+            }\n+\n+            @Override\n+            public long cost() {\n+                return competitiveIterator.cost();\n+            }\n+\n+            @Override\n+            public int advance(int target) throws IOException {\n+                return doc = competitiveIterator.advance(target);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public void setCanUpdateIterator() throws IOException {\n+        this.canUpdateIterator = true;\n+        // for the 1st time queue becomes full and hitsThreshold is reached\n+        // we can start updating competitive iterator\n+        updateCompetitiveIterator();\n+    }\n+\n+    @Override\n+    public void setTopValue(T value) {\n+        hasTopValue = true;\n+        if (reverse) {\n+            maxValueExist = true;\n+        } else {\n+            minValueExist = true;\n+        }\n+        in.setTopValue(value);\n+    }\n+\n+    @Override\n+    public void setBottom(int slot) throws IOException {\n+        ((NumericComparator) in).setBottom(slot);\n+        updateCompetitiveIterator(); // update an iterator if we set a new bottom\n+    }\n+\n+    @Override\n+    public int compareBottom(int doc) throws IOException {\n+        return ((NumericComparator) in).compareBottom(doc);\n+    }\n+\n+    @Override\n+    public int compareTop(int doc) throws IOException {\n+        return ((NumericComparator) in).compareTop(doc);\n+    }\n+\n+    @Override\n+    public void copy(int slot, int doc) throws IOException {\n+        ((NumericComparator) in).copy(slot, doc);\n+    }\n+\n+    @Override\n+    public void setScorer(Scorable scorer) throws IOException {\n+        ((NumericComparator) in).setScorer(scorer);\n+        if (scorer instanceof Scorer) {\n+            iteratorCost = ((Scorer) scorer).iterator().cost(); // starting iterator cost is the scorer's cost\n+            updateCompetitiveIterator(); // update an iterator when we have a new segment\n+        }\n+    }\n+\n+    @Override\n+    public final LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+        ((NumericComparator) in).doSetNextReader(context);\n+        maxDoc = context.reader().maxDoc();\n+        maxDocVisited = 0;\n+        pointValues = context.reader().getPointValues(field);\n+        // TODO: optimize a case when pointValues are missing only on this segment\n+        competitiveIterator = pointValues == null ? null : DocIdSetIterator.all(maxDoc);\n+        iteratorCost = 0;\n+        return this;", "originalCommit": "2fd9075f1ea7f5d084965c3687cb28da45eb9432", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwMDYwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r417400609", "bodyText": "Thanks @jpountz, indeed the suggested structure is much better. addressed in 7120424", "author": "mayya-sharipova", "createdAt": "2020-04-29T15:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwMTUyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwNTA2Mw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r414405063", "bodyText": "Let's open a separate issue about adding Scorable.cost() to make such optimizations easier?", "author": "jpountz", "createdAt": "2020-04-24T08:47:11Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringNumericComparator.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.DoublePoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.document.IntPoint;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * A wrapper over {@code NumericComparator} that adds a functionality to filter non-competitive docs.\n+ */\n+public abstract class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> implements LeafFieldComparator {\n+    protected final boolean reverse;\n+    private boolean hasTopValue = false;\n+    private PointValues pointValues;\n+    private final int bytesCount;\n+    private final byte[] minValueAsBytes;\n+    private final byte[] maxValueAsBytes;\n+    private boolean minValueExist = false;\n+    private boolean maxValueExist = false;\n+    private int maxDoc;\n+    private int maxDocVisited;\n+    private int updateCounter = 0;\n+    private final String field;\n+    protected boolean canUpdateIterator = false; // set to true when queue becomes full and hitsThreshold is reached\n+    protected DocIdSetIterator competitiveIterator = null;\n+    private long iteratorCost = 0;\n+\n+    public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, int bytesCount) {\n+        super(in);\n+        this.field = in.field;\n+        this.bytesCount = bytesCount;\n+        this.reverse = reverse;\n+        minValueAsBytes = new byte[bytesCount];\n+        maxValueAsBytes = new byte[bytesCount];\n+        if (reverse) {\n+            minValueExist = true;\n+        } else {\n+            maxValueExist = true;\n+        }\n+    }\n+\n+    /**\n+     * Returns an iterator over competitive documents\n+     */\n+    @Override\n+    public DocIdSetIterator competitiveIterator() {\n+        if (competitiveIterator == null) return null;\n+        return new DocIdSetIterator() {\n+            private int doc;\n+            @Override\n+            public int nextDoc() throws IOException {\n+                return doc = competitiveIterator.nextDoc();\n+            }\n+\n+            @Override\n+            public int docID() {\n+                return doc;\n+            }\n+\n+            @Override\n+            public long cost() {\n+                return competitiveIterator.cost();\n+            }\n+\n+            @Override\n+            public int advance(int target) throws IOException {\n+                return doc = competitiveIterator.advance(target);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public void setCanUpdateIterator() throws IOException {\n+        this.canUpdateIterator = true;\n+        // for the 1st time queue becomes full and hitsThreshold is reached\n+        // we can start updating competitive iterator\n+        updateCompetitiveIterator();\n+    }\n+\n+    @Override\n+    public void setTopValue(T value) {\n+        hasTopValue = true;\n+        if (reverse) {\n+            maxValueExist = true;\n+        } else {\n+            minValueExist = true;\n+        }\n+        in.setTopValue(value);\n+    }\n+\n+    @Override\n+    public void setBottom(int slot) throws IOException {\n+        ((NumericComparator) in).setBottom(slot);\n+        updateCompetitiveIterator(); // update an iterator if we set a new bottom\n+    }\n+\n+    @Override\n+    public int compareBottom(int doc) throws IOException {\n+        return ((NumericComparator) in).compareBottom(doc);\n+    }\n+\n+    @Override\n+    public int compareTop(int doc) throws IOException {\n+        return ((NumericComparator) in).compareTop(doc);\n+    }\n+\n+    @Override\n+    public void copy(int slot, int doc) throws IOException {\n+        ((NumericComparator) in).copy(slot, doc);\n+    }\n+\n+    @Override\n+    public void setScorer(Scorable scorer) throws IOException {\n+        ((NumericComparator) in).setScorer(scorer);\n+        if (scorer instanceof Scorer) {\n+            iteratorCost = ((Scorer) scorer).iterator().cost(); // starting iterator cost is the scorer's cost\n+            updateCompetitiveIterator(); // update an iterator when we have a new segment\n+        }", "originalCommit": "2fd9075f1ea7f5d084965c3687cb28da45eb9432", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQxMDIyNQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r417410225", "bodyText": "Opened  LUCENE-9352", "author": "mayya-sharipova", "createdAt": "2020-04-29T15:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwNTA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwNTgwOA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r414405808", "bodyText": "I'd rather have maxDoc as a default, the reason being that this optimization otherwise wouldn't apply with MatchAllDocsQuery, which would be a pity.", "author": "jpountz", "createdAt": "2020-04-24T08:48:18Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringNumericComparator.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.DoublePoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.document.IntPoint;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * A wrapper over {@code NumericComparator} that adds a functionality to filter non-competitive docs.\n+ */\n+public abstract class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> implements LeafFieldComparator {\n+    protected final boolean reverse;\n+    private boolean hasTopValue = false;\n+    private PointValues pointValues;\n+    private final int bytesCount;\n+    private final byte[] minValueAsBytes;\n+    private final byte[] maxValueAsBytes;\n+    private boolean minValueExist = false;\n+    private boolean maxValueExist = false;\n+    private int maxDoc;\n+    private int maxDocVisited;\n+    private int updateCounter = 0;\n+    private final String field;\n+    protected boolean canUpdateIterator = false; // set to true when queue becomes full and hitsThreshold is reached\n+    protected DocIdSetIterator competitiveIterator = null;\n+    private long iteratorCost = 0;\n+\n+    public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, int bytesCount) {\n+        super(in);\n+        this.field = in.field;\n+        this.bytesCount = bytesCount;\n+        this.reverse = reverse;\n+        minValueAsBytes = new byte[bytesCount];\n+        maxValueAsBytes = new byte[bytesCount];\n+        if (reverse) {\n+            minValueExist = true;\n+        } else {\n+            maxValueExist = true;\n+        }\n+    }\n+\n+    /**\n+     * Returns an iterator over competitive documents\n+     */\n+    @Override\n+    public DocIdSetIterator competitiveIterator() {\n+        if (competitiveIterator == null) return null;\n+        return new DocIdSetIterator() {\n+            private int doc;\n+            @Override\n+            public int nextDoc() throws IOException {\n+                return doc = competitiveIterator.nextDoc();\n+            }\n+\n+            @Override\n+            public int docID() {\n+                return doc;\n+            }\n+\n+            @Override\n+            public long cost() {\n+                return competitiveIterator.cost();\n+            }\n+\n+            @Override\n+            public int advance(int target) throws IOException {\n+                return doc = competitiveIterator.advance(target);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public void setCanUpdateIterator() throws IOException {\n+        this.canUpdateIterator = true;\n+        // for the 1st time queue becomes full and hitsThreshold is reached\n+        // we can start updating competitive iterator\n+        updateCompetitiveIterator();\n+    }\n+\n+    @Override\n+    public void setTopValue(T value) {\n+        hasTopValue = true;\n+        if (reverse) {\n+            maxValueExist = true;\n+        } else {\n+            minValueExist = true;\n+        }\n+        in.setTopValue(value);\n+    }\n+\n+    @Override\n+    public void setBottom(int slot) throws IOException {\n+        ((NumericComparator) in).setBottom(slot);\n+        updateCompetitiveIterator(); // update an iterator if we set a new bottom\n+    }\n+\n+    @Override\n+    public int compareBottom(int doc) throws IOException {\n+        return ((NumericComparator) in).compareBottom(doc);\n+    }\n+\n+    @Override\n+    public int compareTop(int doc) throws IOException {\n+        return ((NumericComparator) in).compareTop(doc);\n+    }\n+\n+    @Override\n+    public void copy(int slot, int doc) throws IOException {\n+        ((NumericComparator) in).copy(slot, doc);\n+    }\n+\n+    @Override\n+    public void setScorer(Scorable scorer) throws IOException {\n+        ((NumericComparator) in).setScorer(scorer);\n+        if (scorer instanceof Scorer) {\n+            iteratorCost = ((Scorer) scorer).iterator().cost(); // starting iterator cost is the scorer's cost\n+            updateCompetitiveIterator(); // update an iterator when we have a new segment\n+        }\n+    }\n+\n+    @Override\n+    public final LeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+        ((NumericComparator) in).doSetNextReader(context);\n+        maxDoc = context.reader().maxDoc();\n+        maxDocVisited = 0;\n+        pointValues = context.reader().getPointValues(field);\n+        // TODO: optimize a case when pointValues are missing only on this segment\n+        competitiveIterator = pointValues == null ? null : DocIdSetIterator.all(maxDoc);\n+        iteratorCost = 0;", "originalCommit": "2fd9075f1ea7f5d084965c3687cb28da45eb9432", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQwMDcwNg==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r417400706", "bodyText": "addressed in 7120424", "author": "mayya-sharipova", "createdAt": "2020-04-29T15:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDQwNTgwOA=="}], "type": "inlineReview"}, {"oid": "b8e138c9b8246036d9b0a6a342aee43ef22154eb", "url": "https://github.com/apache/lucene-solr/commit/b8e138c9b8246036d9b0a6a342aee43ef22154eb", "message": "Correct Indent", "committedDate": "2020-04-24T19:11:21Z", "type": "commit"}, {"oid": "7120424ffadefd684a644926be556fbd36cdc1c4", "url": "https://github.com/apache/lucene-solr/commit/7120424ffadefd684a644926be556fbd36cdc1c4", "message": "Separate classes for comparator and leaf comparator\n\nHandle equal values", "committedDate": "2020-04-29T15:12:11Z", "type": "commit"}, {"oid": "6c62fd0fe2c4623e90b40791c49957d4fa97cc5e", "url": "https://github.com/apache/lucene-solr/commit/6c62fd0fe2c4623e90b40791c49957d4fa97cc5e", "message": "Merge remote-tracking branch 'upstream/master' into comparator-set-min-competitive", "committedDate": "2020-04-29T15:17:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDkzMDAwNQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r424930005", "bodyText": "nit: remove line", "author": "jimczi", "createdAt": "2020-05-14T07:37:34Z", "path": "lucene/core/src/java/org/apache/lucene/search/FieldComparator.java", "diffHunk": "@@ -159,14 +159,15 @@ protected void doSetNextReader(LeafReaderContext context) throws IOException {\n     protected NumericDocValues getNumericDocValues(LeafReaderContext context, String field) throws IOException {\n       return DocValues.getNumeric(context.reader(), field);\n     }\n+", "originalCommit": "6c62fd0fe2c4623e90b40791c49957d4fa97cc5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk0OTU4NA==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r429949584", "bodyText": "this relies on the implementation detail that NumericComparator extends SimpleFieldCompatator, can we instead call LeafFieldComparator inLeafComparator = in.getLeafComparator(context); and then apply the below if statements over inLeafComparator rather than in?", "author": "jpountz", "createdAt": "2020-05-25T13:58:52Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringNumericComparator.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A wrapper over {@code NumericComparator} that provides a leaf comparator that can filter non-competitive docs.\n+ */\n+public class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> {\n+  public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, boolean singleSort) {\n+    super(in, reverse, singleSort);\n+  }\n+\n+  @Override\n+  public final FilteringLeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+    ((NumericComparator) in).doSetNextReader(context);", "originalCommit": "6c62fd0fe2c4623e90b40791c49957d4fa97cc5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2NjA1MQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r429966051", "bodyText": "FieldComparator.LongComparator allows to customize the way that it gets NumericDocValues from the index, so I think that it needs to check the exact class rather than do an instanceof?", "author": "jpountz", "createdAt": "2020-05-25T14:32:39Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringNumericComparator.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A wrapper over {@code NumericComparator} that provides a leaf comparator that can filter non-competitive docs.\n+ */\n+public class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> {\n+  public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, boolean singleSort) {\n+    super(in, reverse, singleSort);\n+  }\n+\n+  @Override\n+  public final FilteringLeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+    ((NumericComparator) in).doSetNextReader(context);\n+    if (in instanceof FieldComparator.LongComparator) {", "originalCommit": "6c62fd0fe2c4623e90b40791c49957d4fa97cc5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2NjU5Ng==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r429966596", "bodyText": "can you actually do the instanceof check so that it would be more future proof? E.g. in case we add support for bfloat16 one day.", "author": "jpountz", "createdAt": "2020-05-25T14:33:48Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringNumericComparator.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A wrapper over {@code NumericComparator} that provides a leaf comparator that can filter non-competitive docs.\n+ */\n+public class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> {\n+  public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, boolean singleSort) {\n+    super(in, reverse, singleSort);\n+  }\n+\n+  @Override\n+  public final FilteringLeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+    ((NumericComparator) in).doSetNextReader(context);\n+    if (in instanceof FieldComparator.LongComparator) {\n+      return new FilteringNumericLeafComparator.FilteringLongLeafComparator((FieldComparator.LongComparator) in, context,\n+          ((LongComparator) in).field, reverse, singleSort, hasTopValue);\n+    } else if (in instanceof FieldComparator.IntComparator) {\n+      return new FilteringNumericLeafComparator.FilteringIntLeafComparator((FieldComparator.IntComparator) in, context,\n+          ((IntComparator) in).field, reverse, singleSort, hasTopValue);\n+    } else if (in instanceof FieldComparator.DoubleComparator) {\n+      return new FilteringNumericLeafComparator.FilteringDoubleLeafComparator((FieldComparator.DoubleComparator) in, context,\n+          ((DoubleComparator) in).field, reverse, singleSort, hasTopValue);\n+    } else { // instanceof FieldComparator.FloatComparator", "originalCommit": "6c62fd0fe2c4623e90b40791c49957d4fa97cc5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk3ODA4Mw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r429978083", "bodyText": "no need for parentheses with assert", "author": "jpountz", "createdAt": "2020-05-25T14:58:36Z", "path": "lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.java", "diffHunk": "@@ -302,18 +327,24 @@ private TopFieldCollector(FieldValueHitQueue<Entry> pq, int numHits,\n     this.numHits = numHits;\n     this.hitsThresholdChecker = hitsThresholdChecker;\n     this.numComparators = pq.getComparators().length;\n-    FieldComparator<?> fieldComparator = pq.getComparators()[0];\n+    FieldComparator<?> firstComparator = pq.getComparators()[0];\n     int reverseMul = pq.reverseMul[0];\n-    if (fieldComparator.getClass().equals(FieldComparator.RelevanceComparator.class)\n-          && reverseMul == 1 // if the natural sort is preserved (sort by descending relevance)\n-          && hitsThresholdChecker.getHitsThreshold() != Integer.MAX_VALUE) {\n-      firstComparator = (FieldComparator.RelevanceComparator) fieldComparator;\n+\n+    if (firstComparator.getClass().equals(FieldComparator.RelevanceComparator.class)\n+            && reverseMul == 1 // if the natural sort is preserved (sort by descending relevance)\n+            && hitsThresholdChecker.getHitsThreshold() != Integer.MAX_VALUE) {\n+      relevanceComparator = (FieldComparator.RelevanceComparator) firstComparator;\n       scoreMode = ScoreMode.TOP_SCORES;\n       canSetMinScore = true;\n     } else {\n-      firstComparator = null;\n-      scoreMode = needsScores ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES;\n+      relevanceComparator = null;\n       canSetMinScore = false;\n+      if (firstComparator instanceof FilteringFieldComparator) {\n+        assert(hitsThresholdChecker.getHitsThreshold() != Integer.MAX_VALUE);", "originalCommit": "6c62fd0fe2c4623e90b40791c49957d4fa97cc5e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk3OTg1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r429979859", "bodyText": "Let's use a less generic name, e.g. TestFieldSortOptimization to make it clear it doesn't apply to scores, or maybe something even more describing such as TestFieldSortOptimizationSkipping?", "author": "jpountz", "createdAt": "2020-05-25T15:02:43Z", "path": "lucene/core/src/test/org/apache/lucene/search/TestSortOptimization.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.document.FloatDocValuesField;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.document.IntPoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.document.NumericDocValuesField;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.IndexReader;\n+import org.apache.lucene.index.IndexWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.store.Directory;\n+import org.apache.lucene.util.LuceneTestCase;\n+\n+import java.io.IOException;\n+\n+import static org.apache.lucene.search.SortField.FIELD_SCORE;\n+\n+public class TestSortOptimization extends LuceneTestCase {", "originalCommit": "6c62fd0fe2c4623e90b40791c49957d4fa97cc5e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY3NzIwOQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r430677209", "bodyText": "@jpountz Thank you for the feedback,  all last comments are addressed in 1ab2a6e.\nI have also created a LUCENE-9384  for backporting to 8.x.", "author": "mayya-sharipova", "createdAt": "2020-05-26T20:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk3OTg1OQ=="}], "type": "inlineReview"}, {"oid": "1ab2a6e3c1895070ac926e0192dd895641c4954b", "url": "https://github.com/apache/lucene-solr/commit/1ab2a6e3c1895070ac926e0192dd895641c4954b", "message": "Address Adrien's comments\n\n- use getClass instead of instanceof\n- make filtering comparator classes package private", "committedDate": "2020-05-26T18:46:39Z", "type": "commit"}, {"oid": "f9100306125bc7256ae1406228dfdf26531c1d96", "url": "https://github.com/apache/lucene-solr/commit/f9100306125bc7256ae1406228dfdf26531c1d96", "message": "Merge remote-tracking branch 'upstream/master' into comparator-set-min-competitive", "committedDate": "2020-05-26T20:02:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NTUwMQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r440675501", "bodyText": "maybe we should throw IOException here to not force some implementations to catch/rethrow an an UncheckedIOException", "author": "jpountz", "createdAt": "2020-06-16T08:26:36Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringLeafFieldComparator.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Decorates a wrapped LeafFieldComparator to add a functionality to skip over non-competitive docs.\n+ * FilteringLeafFieldComparator provides two additional functions to a LeafFieldComparator:\n+ *  {@code competitiveIterator()} and {@code setCanUpdateIterator()}.\n+ */\n+public interface FilteringLeafFieldComparator extends LeafFieldComparator {\n+  /**\n+   * Returns a competitive iterator\n+   * @return an iterator over competitive docs that are stronger than already collected docs\n+   * or {@code null} if such an iterator is not available for the current segment.\n+   */\n+  DocIdSetIterator competitiveIterator();", "originalCommit": "f9100306125bc7256ae1406228dfdf26531c1d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NTc4Nw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r440675787", "bodyText": "add the class to the error message?", "author": "jpountz", "createdAt": "2020-06-16T08:27:02Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringNumericComparator.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A wrapper over {@code NumericComparator} that provides a leaf comparator that can filter non-competitive docs.\n+ */\n+class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> {\n+  public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, boolean singleSort) {\n+    super(in, reverse, singleSort);\n+  }\n+\n+  @Override\n+  public final FilteringLeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+    LeafFieldComparator inLeafComparator = in.getLeafComparator(context);\n+    Class<?> comparatorClass = inLeafComparator.getClass();\n+    if (comparatorClass == FieldComparator.LongComparator.class) {\n+      return new FilteringNumericLeafComparator.FilteringLongLeafComparator((FieldComparator.LongComparator) inLeafComparator, context,\n+          ((LongComparator) inLeafComparator).field, reverse, singleSort, hasTopValue);\n+    } if (comparatorClass == FieldComparator.IntComparator.class) {\n+      return new FilteringNumericLeafComparator.FilteringIntLeafComparator((FieldComparator.IntComparator) inLeafComparator, context,\n+          ((IntComparator) inLeafComparator).field, reverse, singleSort, hasTopValue);\n+    } else if (comparatorClass == FieldComparator.DoubleComparator.class) {\n+      return new FilteringNumericLeafComparator.FilteringDoubleLeafComparator((FieldComparator.DoubleComparator) inLeafComparator, context,\n+          ((DoubleComparator) inLeafComparator).field, reverse, singleSort, hasTopValue);\n+    } else if (comparatorClass == FieldComparator.FloatComparator.class) {\n+      return new FilteringNumericLeafComparator.FilteringFloatLeafComparator((FieldComparator.FloatComparator) inLeafComparator, context,\n+          ((FloatComparator) inLeafComparator).field, reverse, singleSort, hasTopValue);\n+    } else {\n+      assert false: \"Unexpected class for [FieldComparator]!\";", "originalCommit": "f9100306125bc7256ae1406228dfdf26531c1d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY3NjA3NQ==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r440676075", "bodyText": "should we throw an IllegalStateException instead of being lenient when assertions are disabled?", "author": "jpountz", "createdAt": "2020-06-16T08:27:29Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringNumericComparator.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.index.LeafReaderContext;\n+\n+import java.io.IOException;\n+\n+/**\n+ * A wrapper over {@code NumericComparator} that provides a leaf comparator that can filter non-competitive docs.\n+ */\n+class FilteringNumericComparator<T extends Number> extends FilteringFieldComparator<T> {\n+  public FilteringNumericComparator(NumericComparator<T> in, boolean reverse, boolean singleSort) {\n+    super(in, reverse, singleSort);\n+  }\n+\n+  @Override\n+  public final FilteringLeafFieldComparator getLeafComparator(LeafReaderContext context) throws IOException {\n+    LeafFieldComparator inLeafComparator = in.getLeafComparator(context);\n+    Class<?> comparatorClass = inLeafComparator.getClass();\n+    if (comparatorClass == FieldComparator.LongComparator.class) {\n+      return new FilteringNumericLeafComparator.FilteringLongLeafComparator((FieldComparator.LongComparator) inLeafComparator, context,\n+          ((LongComparator) inLeafComparator).field, reverse, singleSort, hasTopValue);\n+    } if (comparatorClass == FieldComparator.IntComparator.class) {\n+      return new FilteringNumericLeafComparator.FilteringIntLeafComparator((FieldComparator.IntComparator) inLeafComparator, context,\n+          ((IntComparator) inLeafComparator).field, reverse, singleSort, hasTopValue);\n+    } else if (comparatorClass == FieldComparator.DoubleComparator.class) {\n+      return new FilteringNumericLeafComparator.FilteringDoubleLeafComparator((FieldComparator.DoubleComparator) inLeafComparator, context,\n+          ((DoubleComparator) inLeafComparator).field, reverse, singleSort, hasTopValue);\n+    } else if (comparatorClass == FieldComparator.FloatComparator.class) {\n+      return new FilteringNumericLeafComparator.FilteringFloatLeafComparator((FieldComparator.FloatComparator) inLeafComparator, context,\n+          ((FloatComparator) inLeafComparator).field, reverse, singleSort, hasTopValue);\n+    } else {\n+      assert false: \"Unexpected class for [FieldComparator]!\";\n+      return null;", "originalCommit": "f9100306125bc7256ae1406228dfdf26531c1d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY4NTk2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1351#discussion_r440685967", "bodyText": "should we return CELL_OUTSIDE_QUERY here when appropriate instead of delaying?", "author": "jpountz", "createdAt": "2020-06-16T08:43:02Z", "path": "lucene/core/src/java/org/apache/lucene/search/FilteringNumericLeafComparator.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.lucene.search;\n+\n+import org.apache.lucene.document.DoublePoint;\n+import org.apache.lucene.document.FloatPoint;\n+import org.apache.lucene.document.IntPoint;\n+import org.apache.lucene.document.LongPoint;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.index.PointValues;\n+import org.apache.lucene.util.DocIdSetBuilder;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+/**\n+ * A {@code FilteringLeafFieldComparator} that provides a functionality to skip over non-competitive documents\n+ * for numeric fields indexed with points.\n+ */\n+abstract class FilteringNumericLeafComparator implements FilteringLeafFieldComparator {\n+  protected final LeafFieldComparator in;\n+  protected final boolean reverse;\n+  protected final boolean singleSort;\n+  private final boolean hasTopValue;\n+  private final PointValues pointValues;\n+  private final int bytesCount;\n+  private final int maxDoc;\n+  private final byte[] minValueAsBytes;\n+  private final byte[] maxValueAsBytes;\n+\n+  private long iteratorCost;\n+  private int maxDocVisited = 0;\n+  private int updateCounter = 0;\n+  private boolean canUpdateIterator = false; // set to true when queue becomes full and hitsThreshold is reached\n+  private DocIdSetIterator competitiveIterator;\n+\n+  public FilteringNumericLeafComparator(LeafFieldComparator in, LeafReaderContext context, String field,\n+        boolean reverse, boolean singleSort, boolean hasTopValue, int bytesCount) throws IOException {\n+    this.in = in;\n+    this.pointValues = context.reader().getPointValues(field);\n+    this.reverse = reverse;\n+    this.singleSort = singleSort;\n+    this.hasTopValue = hasTopValue;\n+    this.maxDoc = context.reader().maxDoc();\n+    this.bytesCount = bytesCount;\n+    this.maxValueAsBytes = reverse == false ? new byte[bytesCount] : hasTopValue ? new byte[bytesCount] : null;\n+    this.minValueAsBytes = reverse ? new byte[bytesCount] : hasTopValue ? new byte[bytesCount] : null;\n+\n+    // TODO: optimize a case when pointValues are missing only on this segment\n+    this.competitiveIterator = pointValues == null ? null : DocIdSetIterator.all(maxDoc);\n+    this.iteratorCost = maxDoc;\n+  }\n+\n+  @Override\n+  public void setBottom(int slot) throws IOException {\n+    in.setBottom(slot);\n+    updateCompetitiveIterator(); // update an iterator if we set a new bottom\n+  }\n+\n+  @Override\n+  public int compareBottom(int doc) throws IOException {\n+    return in.compareBottom(doc);\n+  }\n+\n+  @Override\n+  public int compareTop(int doc) throws IOException {\n+    return in.compareTop(doc);\n+  }\n+\n+  @Override\n+  public void copy(int slot, int doc) throws IOException {\n+    in.copy(slot, doc);\n+    maxDocVisited = doc;\n+  }\n+\n+  @Override\n+  public void setScorer(Scorable scorer) throws IOException {\n+    in.setScorer(scorer);\n+    if (scorer instanceof Scorer) {\n+      iteratorCost = ((Scorer) scorer).iterator().cost(); // starting iterator cost is the scorer's cost\n+      updateCompetitiveIterator(); // update an iterator when we have a new segment\n+    }\n+  }\n+\n+  @Override\n+  public void setCanUpdateIterator() throws IOException {\n+    this.canUpdateIterator = true;\n+    updateCompetitiveIterator();\n+  }\n+\n+  @Override\n+  public DocIdSetIterator competitiveIterator() {\n+    if (competitiveIterator == null) return null;\n+    return new DocIdSetIterator() {\n+      private int doc;\n+\n+      @Override\n+      public int nextDoc() throws IOException {\n+        return doc = competitiveIterator.nextDoc();\n+      }\n+\n+      @Override\n+      public int docID() {\n+        return doc;\n+      }\n+\n+      @Override\n+      public long cost() {\n+        return competitiveIterator.cost();\n+      }\n+\n+      @Override\n+      public int advance(int target) throws IOException {\n+        return doc = competitiveIterator.advance(target);\n+      }\n+    };\n+  }\n+\n+  // update its iterator to include possibly only docs that are \"stronger\" than the current bottom entry\n+  private void updateCompetitiveIterator() throws IOException {\n+    if (canUpdateIterator == false) return;\n+    if (pointValues == null) return;\n+    // if some documents have missing points, check that missing values prohibits optimization\n+    if ((pointValues.getDocCount() < maxDoc) && isMissingValueCompetitive()) {\n+      return; // we can't filter out documents, as documents with missing values are competitive\n+    }\n+\n+    updateCounter++;\n+    if (updateCounter > 256 && (updateCounter & 0x1f) != 0x1f) { // Start sampling if we get called too much\n+      return;\n+    }\n+    if (reverse == false) {\n+      encodeBottom(maxValueAsBytes);\n+      if (hasTopValue) {\n+        encodeTop(minValueAsBytes);\n+      }\n+    } else {\n+      encodeBottom(minValueAsBytes);\n+      if (hasTopValue) {\n+        encodeTop(maxValueAsBytes);\n+      }\n+    }\n+\n+    DocIdSetBuilder result = new DocIdSetBuilder(maxDoc);\n+    PointValues.IntersectVisitor visitor = new PointValues.IntersectVisitor() {\n+      DocIdSetBuilder.BulkAdder adder;\n+\n+      @Override\n+      public void grow(int count) {\n+        adder = result.grow(count);\n+      }\n+\n+      @Override\n+      public void visit(int docID) {\n+        if (docID <= maxDocVisited) {\n+          return; // Already visited or skipped\n+        }\n+        adder.add(docID);\n+      }\n+\n+      @Override\n+      public void visit(int docID, byte[] packedValue) {\n+        if (docID <= maxDocVisited) {\n+          return;  // already visited or skipped\n+        }\n+        if (maxValueAsBytes != null) {\n+          int cmp = Arrays.compareUnsigned(packedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount);\n+          // if doc's value is too high or for single sort even equal, it is not competitive and the doc can be skipped\n+          if (cmp > 0 || (singleSort && cmp == 0)) return;\n+        }\n+        if (minValueAsBytes != null) {\n+          int cmp = Arrays.compareUnsigned(packedValue, 0, bytesCount, minValueAsBytes, 0, bytesCount);\n+          // if doc's value is too low or for single sort even equal, it is not competitive and the doc can be skipped\n+          if (cmp < 0 || (singleSort && cmp == 0)) return;\n+        }\n+        adder.add(docID); // doc is competitive\n+      }\n+\n+      @Override\n+      public PointValues.Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {\n+        boolean maxValueOutsideQuery = false;\n+        boolean minValueOutsideQuery = false;\n+        if (maxValueAsBytes != null) {\n+          int cmp = Arrays.compareUnsigned(minPackedValue, 0, bytesCount, maxValueAsBytes, 0, bytesCount);\n+          maxValueOutsideQuery = cmp > 0 || (singleSort && cmp == 0);", "originalCommit": "f9100306125bc7256ae1406228dfdf26531c1d96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "99dd0c1e219b3b74e09bc0dad257533247de9ab0", "url": "https://github.com/apache/lucene-solr/commit/99dd0c1e219b3b74e09bc0dad257533247de9ab0", "message": "Address Adrien's feedback", "committedDate": "2020-06-16T18:43:41Z", "type": "commit"}, {"oid": "8ebcff85cbd06a9d5a198397f15c82a40196df32", "url": "https://github.com/apache/lucene-solr/commit/8ebcff85cbd06a9d5a198397f15c82a40196df32", "message": "Merge remote-tracking branch 'upstream/master' into comparator-set-min-competitive", "committedDate": "2020-06-16T18:45:28Z", "type": "commit"}, {"oid": "55f2940eca0345c170a4a72e0f8bd2e7cb069864", "url": "https://github.com/apache/lucene-solr/commit/55f2940eca0345c170a4a72e0f8bd2e7cb069864", "message": "Add contributors' names", "committedDate": "2020-06-23T19:35:16Z", "type": "commit"}]}