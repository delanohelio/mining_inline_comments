{"pr_number": 1470, "pr_title": "SOLR-14354: HttpShardHandler send requests in async", "pr_createdAt": "2020-04-30T08:54:09Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1470", "timeline": [{"oid": "4d6894bca3b477dde2cbfdf68007784136e7c360", "url": "https://github.com/apache/lucene-solr/commit/4d6894bca3b477dde2cbfdf68007784136e7c360", "message": "SOLR-14354: Async or using threads in better way for HttpShardHandler", "committedDate": "2020-04-30T08:49:50Z", "type": "commit"}, {"oid": "7d06eea940a851b09812d71b51da84c9886a14d5", "url": "https://github.com/apache/lucene-solr/commit/7d06eea940a851b09812d71b51da84c9886a14d5", "message": "Merge branch 'jira/SOLR-14354' of github.com:apache/lucene-solr into jira/SOLR-14354", "committedDate": "2020-04-30T08:51:07Z", "type": "commit"}, {"oid": "95208faedfe4f00b5e8ee5d48c6088f318049f03", "url": "https://github.com/apache/lucene-solr/commit/95208faedfe4f00b5e8ee5d48c6088f318049f03", "message": "Fix precommit", "committedDate": "2020-04-30T08:57:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MzQ4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418163481", "bodyText": "Why is this in LBSolrClient instead of LBHttp2SolrClient?", "author": "madrob", "createdAt": "2020-04-30T17:13:30Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBSolrClient.java", "diffHunk": "@@ -136,6 +137,91 @@ public boolean equals(Object obj) {\n     }\n   }\n \n+  protected static class ServerIterator {", "originalCommit": "95208faedfe4f00b5e8ee5d48c6088f318049f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM5MTUxNw==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418391517", "bodyText": "I do not see this class very relates to LBHttp2SolrClient only and most of the code in LBSolrClient.req() can be replaced by this class.", "author": "CaoManhDat", "createdAt": "2020-05-01T02:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MzQ4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2NjEzOA==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418166138", "bodyText": "There is already an interface OnComplete in Http2SolrClient, can we either reuse that or maybe we can use CompletableFuture or something here? Have two similarly named interfaces is going to get confusing I think.", "author": "madrob", "createdAt": "2020-04-30T17:17:51Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/LBHttp2SolrClient.java", "diffHunk": "@@ -66,4 +80,132 @@ public LBHttp2SolrClient(Http2SolrClient httpClient, String... baseSolrUrls) {\n   protected SolrClient getClient(String baseUrl) {\n     return httpClient;\n   }\n+\n+  public interface OnComplete {", "originalCommit": "95208faedfe4f00b5e8ee5d48c6088f318049f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxNjc5MA==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418416790", "bodyText": "Hmm, so the to OnComplete different in the parameter of onSuccess one is\n\nNamedList\nanother is LBSolrClient.Rsp\nShould we making them as template then move it to util package of solrj?", "author": "CaoManhDat", "createdAt": "2020-05-01T04:56:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2NjEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyNzU1OQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418627559", "bodyText": "Yea, having a generic interface sounds good.", "author": "madrob", "createdAt": "2020-05-01T16:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2NjEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3MDg4MA==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418170880", "bodyText": "How many requests are we planning on handling? LinkedList is not great for performance due to node allocation overhead.\nI also don't see us removing requests anywhere?", "author": "madrob", "createdAt": "2020-04-30T17:25:50Z", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -64,18 +62,23 @@\n    * by the RealtimeGet handler, since other types of replicas shouldn't respond to RTG requests\n    */\n   public static String ONLY_NRT_REPLICAS = \"distribOnlyRealtime\";\n+  private static final ShardResponse END_QUEUE = new ShardResponse();\n \n   private HttpShardHandlerFactory httpShardHandlerFactory;\n-  private CompletionService<ShardResponse> completionService;\n-  private Set<Future<ShardResponse>> pending;\n+  private LinkedList<Cancellable> requests;", "originalCommit": "95208faedfe4f00b5e8ee5d48c6088f318049f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM5NDEzMQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418394131", "bodyText": "I think most of the time, max size of the list will equals to number of shards, so I think it won't be very different here but I can change it back to ArrayList.\n\nI also don't see us removing requests anywhere?\n\nThat is right, we need to remove elements from this list on the corresponding result arrived.", "author": "CaoManhDat", "createdAt": "2020-05-01T02:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3MDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3MzcxNw==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418173717", "bodyText": "Do we need to reinsert the END_QUEUE element in case there are other threads?", "author": "madrob", "createdAt": "2020-04-30T17:30:33Z", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -243,12 +233,13 @@ public ShardResponse takeCompletedOrError() {\n   }\n \n   private ShardResponse take(boolean bailOnError) {\n+    try {\n+      while (pending.get() > 0) {\n+        ShardResponse rsp = responses.take();\n+        if (rsp == END_QUEUE)", "originalCommit": "95208faedfe4f00b5e8ee5d48c6088f318049f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQwNDQ1NQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418404455", "bodyText": "So all usage of HttpShardHandler is single-thread. Submit tasks, takeResponse then cancelAll() if there are anyerror. Therefore even END_QUEUE is not needed here. I may add some comments to indicate that HttpShardHandler is not thread-safe.", "author": "CaoManhDat", "createdAt": "2020-05-01T03:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3MzcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NTg3Nw==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418175877", "bodyText": "Might be worthwhile to create a singleton instance and reuse that, since we can give it a descriptive name like alreadyFailedRequest, assuming I understand the intent here.", "author": "madrob", "createdAt": "2020-04-30T17:34:15Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "diffHunk": "@@ -359,65 +366,95 @@ public void send(OutStream outStream, SolrRequest req, String collection) throws\n     outStream.flush();\n   }\n \n-  public NamedList<Object> request(SolrRequest solrRequest,\n-                                      String collection,\n-                                      OnComplete onComplete) throws IOException, SolrServerException {\n-    Request req = makeRequest(solrRequest, collection);\n+  private static final Exception CANCELLED_EXCEPTION = new Exception();\n+\n+  public Cancellable asyncRequest(SolrRequest solrRequest, String collection, OnComplete onComplete) {\n+    Request req;\n+    try {\n+      req = makeRequest(solrRequest, collection);\n+    } catch (SolrServerException | IOException e) {\n+      onComplete.onFailure(e);\n+      return () -> {};", "originalCommit": "95208faedfe4f00b5e8ee5d48c6088f318049f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQxNjg4MQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418416881", "bodyText": "+1", "author": "CaoManhDat", "createdAt": "2020-05-01T04:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NTg3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NjM0OQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418176349", "bodyText": "Catching Throwable seems very broad to me, can we do something less aggressive here?", "author": "madrob", "createdAt": "2020-04-30T17:35:03Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "diffHunk": "@@ -359,65 +366,95 @@ public void send(OutStream outStream, SolrRequest req, String collection) throws\n     outStream.flush();\n   }\n \n-  public NamedList<Object> request(SolrRequest solrRequest,\n-                                      String collection,\n-                                      OnComplete onComplete) throws IOException, SolrServerException {\n-    Request req = makeRequest(solrRequest, collection);\n+  private static final Exception CANCELLED_EXCEPTION = new Exception();\n+\n+  public Cancellable asyncRequest(SolrRequest solrRequest, String collection, OnComplete onComplete) {\n+    Request req;\n+    try {\n+      req = makeRequest(solrRequest, collection);\n+    } catch (SolrServerException | IOException e) {\n+      onComplete.onFailure(e);\n+      return () -> {};\n+    }\n     final ResponseParser parser = solrRequest.getResponseParser() == null\n         ? this.parser: solrRequest.getResponseParser();\n-\n-    if (onComplete != null) {\n-      // This async call only suitable for indexing since the response size is limited by 5MB\n-      req.onRequestQueued(asyncTracker.queuedListener)\n-          .onComplete(asyncTracker.completeListener).send(new BufferingResponseListener(5 * 1024 * 1024) {\n-\n-        @Override\n-        public void onComplete(Result result) {\n-          if (result.isFailed()) {\n-            onComplete.onFailure(result.getFailure());\n-            return;\n+    req.onRequestQueued(asyncTracker.queuedListener)\n+        .onComplete(asyncTracker.completeListener)\n+        .send(new InputStreamResponseListener() {\n+          @Override\n+          public void onHeaders(Response response) {\n+            super.onHeaders(response);\n+            InputStreamResponseListener listener = this;\n+            executor.execute(() -> {\n+              InputStream is = listener.getInputStream();\n+              assert ObjectReleaseTracker.track(is);\n+              try {\n+                NamedList<Object> body = processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n+                onComplete.onSuccess(body);\n+              } catch (RemoteSolrException e) {\n+                if (SolrException.getRootCause(e) != CANCELLED_EXCEPTION) {\n+                  onComplete.onFailure(e);\n+                }\n+              } catch (SolrServerException e) {\n+                onComplete.onFailure(e);\n+              }\n+            });\n           }\n \n-          NamedList<Object> rsp;\n-          try {\n-            InputStream is = getContentAsInputStream();\n-            assert ObjectReleaseTracker.track(is);\n-            rsp = processErrorsAndResponse(result.getResponse(),\n-                parser, is, getEncoding(), isV2ApiRequest(solrRequest));\n-            onComplete.onSuccess(rsp);\n-          } catch (Exception e) {\n-            onComplete.onFailure(e);\n+          @Override\n+          public void onFailure(Response response, Throwable failure) {\n+            super.onFailure(response, failure);\n+            if (failure != CANCELLED_EXCEPTION) {\n+              onComplete.onFailure(createException(req, failure));\n+            }\n           }\n-        }\n-      });\n-      return null;\n-    } else {\n-      try {\n-        InputStreamResponseListener listener = new InputStreamResponseListener();\n-        req.send(listener);\n-        Response response = listener.get(idleTimeout, TimeUnit.MILLISECONDS);\n-        InputStream is = listener.getInputStream();\n-        assert ObjectReleaseTracker.track(is);\n-        return processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        throw new RuntimeException(e);\n-      } catch (TimeoutException e) {\n-        throw new SolrServerException(\n-            \"Timeout occured while waiting response from server at: \" + req.getURI(), e);\n-      } catch (ExecutionException e) {\n-        Throwable cause = e.getCause();\n-        if (cause instanceof ConnectException) {\n-          throw new SolrServerException(\"Server refused connection at: \" + req.getURI(), cause);\n-        }\n-        if (cause instanceof SolrServerException) {\n-          throw (SolrServerException) cause;\n-        } else if (cause instanceof IOException) {\n-          throw new SolrServerException(\n-              \"IOException occured when talking to server at: \" + getBaseURL(), cause);\n-        }\n-        throw new SolrServerException(cause.getMessage(), cause);\n+        });\n+    return () -> req.abort(CANCELLED_EXCEPTION);\n+  }\n+\n+  @Override\n+  public NamedList<Object> request(SolrRequest solrRequest, String collection) throws SolrServerException, IOException {\n+    Request req = makeRequest(solrRequest, collection);\n+    final ResponseParser parser = solrRequest.getResponseParser() == null\n+        ? this.parser: solrRequest.getResponseParser();\n+\n+    try {\n+      InputStreamResponseListener listener = new InputStreamResponseListener();\n+      req.send(listener);\n+      Response response = listener.get(idleTimeout, TimeUnit.MILLISECONDS);\n+      InputStream is = listener.getInputStream();\n+      assert ObjectReleaseTracker.track(is);\n+      return processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(e);\n+    } catch (RuntimeException e) {\n+      throw e;\n+    } catch (Throwable e) {\n+      throw createException(req, e);", "originalCommit": "95208faedfe4f00b5e8ee5d48c6088f318049f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODM5OTc2NQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418399765", "bodyText": "Right, I think it is worth to seperate the exception handling logic of asyncReq() and req().", "author": "CaoManhDat", "createdAt": "2020-05-01T03:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NjM0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NzA3MQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418177071", "bodyText": "This whole method seems problematic, but I can't immediately think of what the alternative should look like.", "author": "madrob", "createdAt": "2020-04-30T17:36:16Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Http2SolrClient.java", "diffHunk": "@@ -359,65 +366,95 @@ public void send(OutStream outStream, SolrRequest req, String collection) throws\n     outStream.flush();\n   }\n \n-  public NamedList<Object> request(SolrRequest solrRequest,\n-                                      String collection,\n-                                      OnComplete onComplete) throws IOException, SolrServerException {\n-    Request req = makeRequest(solrRequest, collection);\n+  private static final Exception CANCELLED_EXCEPTION = new Exception();\n+\n+  public Cancellable asyncRequest(SolrRequest solrRequest, String collection, OnComplete onComplete) {\n+    Request req;\n+    try {\n+      req = makeRequest(solrRequest, collection);\n+    } catch (SolrServerException | IOException e) {\n+      onComplete.onFailure(e);\n+      return () -> {};\n+    }\n     final ResponseParser parser = solrRequest.getResponseParser() == null\n         ? this.parser: solrRequest.getResponseParser();\n-\n-    if (onComplete != null) {\n-      // This async call only suitable for indexing since the response size is limited by 5MB\n-      req.onRequestQueued(asyncTracker.queuedListener)\n-          .onComplete(asyncTracker.completeListener).send(new BufferingResponseListener(5 * 1024 * 1024) {\n-\n-        @Override\n-        public void onComplete(Result result) {\n-          if (result.isFailed()) {\n-            onComplete.onFailure(result.getFailure());\n-            return;\n+    req.onRequestQueued(asyncTracker.queuedListener)\n+        .onComplete(asyncTracker.completeListener)\n+        .send(new InputStreamResponseListener() {\n+          @Override\n+          public void onHeaders(Response response) {\n+            super.onHeaders(response);\n+            InputStreamResponseListener listener = this;\n+            executor.execute(() -> {\n+              InputStream is = listener.getInputStream();\n+              assert ObjectReleaseTracker.track(is);\n+              try {\n+                NamedList<Object> body = processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n+                onComplete.onSuccess(body);\n+              } catch (RemoteSolrException e) {\n+                if (SolrException.getRootCause(e) != CANCELLED_EXCEPTION) {\n+                  onComplete.onFailure(e);\n+                }\n+              } catch (SolrServerException e) {\n+                onComplete.onFailure(e);\n+              }\n+            });\n           }\n \n-          NamedList<Object> rsp;\n-          try {\n-            InputStream is = getContentAsInputStream();\n-            assert ObjectReleaseTracker.track(is);\n-            rsp = processErrorsAndResponse(result.getResponse(),\n-                parser, is, getEncoding(), isV2ApiRequest(solrRequest));\n-            onComplete.onSuccess(rsp);\n-          } catch (Exception e) {\n-            onComplete.onFailure(e);\n+          @Override\n+          public void onFailure(Response response, Throwable failure) {\n+            super.onFailure(response, failure);\n+            if (failure != CANCELLED_EXCEPTION) {\n+              onComplete.onFailure(createException(req, failure));\n+            }\n           }\n-        }\n-      });\n-      return null;\n-    } else {\n-      try {\n-        InputStreamResponseListener listener = new InputStreamResponseListener();\n-        req.send(listener);\n-        Response response = listener.get(idleTimeout, TimeUnit.MILLISECONDS);\n-        InputStream is = listener.getInputStream();\n-        assert ObjectReleaseTracker.track(is);\n-        return processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n-      } catch (InterruptedException e) {\n-        Thread.currentThread().interrupt();\n-        throw new RuntimeException(e);\n-      } catch (TimeoutException e) {\n-        throw new SolrServerException(\n-            \"Timeout occured while waiting response from server at: \" + req.getURI(), e);\n-      } catch (ExecutionException e) {\n-        Throwable cause = e.getCause();\n-        if (cause instanceof ConnectException) {\n-          throw new SolrServerException(\"Server refused connection at: \" + req.getURI(), cause);\n-        }\n-        if (cause instanceof SolrServerException) {\n-          throw (SolrServerException) cause;\n-        } else if (cause instanceof IOException) {\n-          throw new SolrServerException(\n-              \"IOException occured when talking to server at: \" + getBaseURL(), cause);\n-        }\n-        throw new SolrServerException(cause.getMessage(), cause);\n+        });\n+    return () -> req.abort(CANCELLED_EXCEPTION);\n+  }\n+\n+  @Override\n+  public NamedList<Object> request(SolrRequest solrRequest, String collection) throws SolrServerException, IOException {\n+    Request req = makeRequest(solrRequest, collection);\n+    final ResponseParser parser = solrRequest.getResponseParser() == null\n+        ? this.parser: solrRequest.getResponseParser();\n+\n+    try {\n+      InputStreamResponseListener listener = new InputStreamResponseListener();\n+      req.send(listener);\n+      Response response = listener.get(idleTimeout, TimeUnit.MILLISECONDS);\n+      InputStream is = listener.getInputStream();\n+      assert ObjectReleaseTracker.track(is);\n+      return processErrorsAndResponse(response, parser, is, getEncoding(response), isV2ApiRequest(solrRequest));\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new RuntimeException(e);\n+    } catch (RuntimeException e) {\n+      throw e;\n+    } catch (Throwable e) {\n+      throw createException(req, e);\n+    }\n+  }\n+\n+  private SolrServerException createException(Request req, Throwable throwable) {", "originalCommit": "95208faedfe4f00b5e8ee5d48c6088f318049f03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c7ad19d9b6b7700b319fa56a384e38771319356d", "url": "https://github.com/apache/lucene-solr/commit/c7ad19d9b6b7700b319fa56a384e38771319356d", "message": "Update based on review", "committedDate": "2020-05-01T07:42:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyODIwNA==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418628204", "bodyText": "Use @SolrSingleThreaded", "author": "madrob", "createdAt": "2020-05-01T16:48:57Z", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -54,6 +53,10 @@\n import org.apache.solr.util.tracing.GlobalTracer;\n import org.apache.solr.util.tracing.SolrRequestCarrier;\n \n+/**\n+ * Submit requests in async manner.\n+ * This class is not thread-safe so all methods should be called in a same thread.", "originalCommit": "c7ad19d9b6b7700b319fa56a384e38771319356d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE5ODA4Nw==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r419198087", "bodyText": "+1", "author": "CaoManhDat", "createdAt": "2020-05-04T03:07:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyODIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyODc0MA==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r418628740", "bodyText": "And clear the map?", "author": "madrob", "createdAt": "2020-05-01T16:50:04Z", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -259,12 +261,10 @@ private ShardResponse take(boolean bailOnError) {\n \n   @Override\n   public void cancelAll() {\n-    for (Cancellable cancellable : requests) {\n+    for (Cancellable cancellable : responseCancellableMap.values()) {", "originalCommit": "c7ad19d9b6b7700b319fa56a384e38771319356d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE5ODA3Mg==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r419198072", "bodyText": "+1", "author": "CaoManhDat", "createdAt": "2020-05-04T03:07:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYyODc0MA=="}], "type": "inlineReview"}, {"oid": "ee01af972f0f0537d4710221eb413ea67084f396", "url": "https://github.com/apache/lucene-solr/commit/ee01af972f0f0537d4710221eb413ea67084f396", "message": "Update based on reviews and fixing precommit", "committedDate": "2020-05-04T03:08:34Z", "type": "commit"}, {"oid": "b7b32be19922c71799221cb8b7e0b53cd9b39d36", "url": "https://github.com/apache/lucene-solr/commit/b7b32be19922c71799221cb8b7e0b53cd9b39d36", "message": "Fix test failure", "committedDate": "2020-05-04T03:41:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NzgxNA==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r420457814", "bodyText": "Service unavailable error code seems reasonable to me here. Do you have something else you were debating to switch this out to?", "author": "anshumg", "createdAt": "2020-05-05T23:02:59Z", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -130,77 +134,64 @@ public void submit(final ShardRequest sreq, final String shard, final Modifiable\n     final Tracer tracer = GlobalTracer.getTracer();\n     final Span span = tracer != null ? tracer.activeSpan() : null;\n \n-    Callable<ShardResponse> task = () -> {\n+    params.remove(CommonParams.WT); // use default (currently javabin)\n+    params.remove(CommonParams.VERSION);\n+    QueryRequest req = makeQueryRequest(sreq, params, shard);\n+    req.setMethod(SolrRequest.METHOD.POST);\n \n-      ShardResponse srsp = new ShardResponse();\n-      if (sreq.nodeName != null) {\n-        srsp.setNodeName(sreq.nodeName);\n-      }\n-      srsp.setShardRequest(sreq);\n-      srsp.setShard(shard);\n-      SimpleSolrResponse ssr = new SimpleSolrResponse();\n-      srsp.setSolrResponse(ssr);\n-      long startTime = System.nanoTime();\n+    LBSolrClient.Req lbReq = httpShardHandlerFactory.newLBHttpSolrClientReq(req, urls);\n+\n+    ShardResponse srsp = new ShardResponse();\n+    if (sreq.nodeName != null) {\n+      srsp.setNodeName(sreq.nodeName);\n+    }\n+    srsp.setShardRequest(sreq);\n+    srsp.setShard(shard);\n+    SimpleSolrResponse ssr = new SimpleSolrResponse();\n+    srsp.setSolrResponse(ssr);\n+\n+    pending.incrementAndGet();\n+    // if there are no shards available for a slice, urls.size()==0\n+    if (urls.size() == 0) {\n+      // TODO: what's the right error code here? We should use the same thing when", "originalCommit": "b7b32be19922c71799221cb8b7e0b53cd9b39d36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1OTEzOQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r422459139", "bodyText": "I do not, just copied and pasted from the old code.", "author": "CaoManhDat", "createdAt": "2020-05-09T06:28:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ1NzgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTMxOQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445295319", "bodyText": "Perhaps rename to RequestLifecycleListener?", "author": "shalinmangar", "createdAt": "2020-06-25T04:07:50Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/util/OnComplete.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.util;\n+\n+/**\n+ * Listener for async requests\n+ */\n+public interface OnComplete<T> {", "originalCommit": "b7b32be19922c71799221cb8b7e0b53cd9b39d36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NTU5OA==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445955598", "bodyText": "changed, thanks!", "author": "CaoManhDat", "createdAt": "2020-06-26T04:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTYwNA==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445295604", "bodyText": "This needs to be volatile or AtomicLong because it is accessed from other threads that call onSuccess and onFailure", "author": "shalinmangar", "createdAt": "2020-06-25T04:09:02Z", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -130,77 +134,64 @@ public void submit(final ShardRequest sreq, final String shard, final Modifiable\n     final Tracer tracer = GlobalTracer.getTracer();\n     final Span span = tracer != null ? tracer.activeSpan() : null;\n \n-    Callable<ShardResponse> task = () -> {\n+    params.remove(CommonParams.WT); // use default (currently javabin)\n+    params.remove(CommonParams.VERSION);\n+    QueryRequest req = makeQueryRequest(sreq, params, shard);\n+    req.setMethod(SolrRequest.METHOD.POST);\n \n-      ShardResponse srsp = new ShardResponse();\n-      if (sreq.nodeName != null) {\n-        srsp.setNodeName(sreq.nodeName);\n-      }\n-      srsp.setShardRequest(sreq);\n-      srsp.setShard(shard);\n-      SimpleSolrResponse ssr = new SimpleSolrResponse();\n-      srsp.setSolrResponse(ssr);\n-      long startTime = System.nanoTime();\n+    LBSolrClient.Req lbReq = httpShardHandlerFactory.newLBHttpSolrClientReq(req, urls);\n+\n+    ShardResponse srsp = new ShardResponse();\n+    if (sreq.nodeName != null) {\n+      srsp.setNodeName(sreq.nodeName);\n+    }\n+    srsp.setShardRequest(sreq);\n+    srsp.setShard(shard);\n+    SimpleSolrResponse ssr = new SimpleSolrResponse();\n+    srsp.setSolrResponse(ssr);\n+\n+    pending.incrementAndGet();\n+    // if there are no shards available for a slice, urls.size()==0\n+    if (urls.size() == 0) {\n+      // TODO: what's the right error code here? We should use the same thing when\n+      // all of the servers for a shard are down.\n+      SolrException exception = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"no servers hosting shard: \" + shard);\n+      srsp.setException(exception);\n+      srsp.setResponseCode(exception.code());\n+      responses.add(srsp);\n+      return;\n+    }\n \n-      try {\n-        params.remove(CommonParams.WT); // use default (currently javabin)\n-        params.remove(CommonParams.VERSION);\n+    // all variables that set inside this listener must be at least volatile\n+    responseCancellableMap.put(srsp, this.lbClient.asyncReq(lbReq, new OnComplete<>() {\n+      long startTime = System.nanoTime();", "originalCommit": "b7b32be19922c71799221cb8b7e0b53cd9b39d36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NTY0OQ==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445955649", "bodyText": "right, thank you Shalin.", "author": "CaoManhDat", "createdAt": "2020-06-26T04:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTcyOA==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445295728", "bodyText": "It seems that this Http2SolrClient instance can be removed. It is being used in the request method but that method is not used anywhere anymore.", "author": "shalinmangar", "createdAt": "2020-06-25T04:09:38Z", "path": "solr/core/src/java/org/apache/solr/handler/component/HttpShardHandler.java", "diffHunk": "@@ -66,16 +66,20 @@\n   public static String ONLY_NRT_REPLICAS = \"distribOnlyRealtime\";\n \n   private HttpShardHandlerFactory httpShardHandlerFactory;\n-  private CompletionService<ShardResponse> completionService;\n-  private Set<Future<ShardResponse>> pending;\n+  private Map<ShardResponse, Cancellable> responseCancellableMap;\n+  private BlockingQueue<ShardResponse> responses;\n+  private AtomicInteger pending;\n   private Map<String, List<String>> shardToURLs;\n   private Http2SolrClient httpClient;", "originalCommit": "b7b32be19922c71799221cb8b7e0b53cd9b39d36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk1NTcyNw==", "url": "https://github.com/apache/lucene-solr/pull/1470#discussion_r445955727", "bodyText": "right, I removed that in this commit 0a02baa.", "author": "CaoManhDat", "createdAt": "2020-06-26T04:02:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI5NTcyOA=="}], "type": "inlineReview"}, {"oid": "0a02baad8587ff6c4f6fce10f06aeeaf88dd8fb2", "url": "https://github.com/apache/lucene-solr/commit/0a02baad8587ff6c4f6fce10f06aeeaf88dd8fb2", "message": "Prevent using custom client for httpshardhandler", "committedDate": "2020-06-26T03:57:54Z", "type": "commit"}, {"oid": "ca72b3c9266764683b1a4ba46f1b723ee8abd345", "url": "https://github.com/apache/lucene-solr/commit/ca72b3c9266764683b1a4ba46f1b723ee8abd345", "message": "SOLR-14354: Remove unusage httpclient in httpshardhandler", "committedDate": "2020-06-26T04:00:21Z", "type": "commit"}, {"oid": "c6341c156d8902c961aa94a163ebf997f40c476f", "url": "https://github.com/apache/lucene-solr/commit/c6341c156d8902c961aa94a163ebf997f40c476f", "message": "Merge branch 'master' into jira/SOLR-14354", "committedDate": "2020-06-26T09:42:53Z", "type": "commit"}, {"oid": "852d947db0fdcdd84db615b85ad8c87d721d438e", "url": "https://github.com/apache/lucene-solr/commit/852d947db0fdcdd84db615b85ad8c87d721d438e", "message": "SOLR-14354: Update CHANGES.txt", "committedDate": "2020-06-26T09:46:33Z", "type": "commit"}, {"oid": "cd0060ca33dbd82d599a25edba91a2e8c72cd5ca", "url": "https://github.com/apache/lucene-solr/commit/cd0060ca33dbd82d599a25edba91a2e8c72cd5ca", "message": "Fix warning", "committedDate": "2020-06-26T09:53:36Z", "type": "commit"}, {"oid": "02f7cc421ff90b3c234ab6d769276b53a79ffea7", "url": "https://github.com/apache/lucene-solr/commit/02f7cc421ff90b3c234ab6d769276b53a79ffea7", "message": "SOLR-14354: Fix precommit", "committedDate": "2020-06-26T10:10:23Z", "type": "commit"}, {"oid": "593b87cb4c28d7e46b132b7f6f195b36b763a7d9", "url": "https://github.com/apache/lucene-solr/commit/593b87cb4c28d7e46b132b7f6f195b36b763a7d9", "message": "Fix precommit", "committedDate": "2020-06-27T03:23:48Z", "type": "commit"}, {"oid": "1110af2a4a119d8e4367244fbb00e9f605742d2d", "url": "https://github.com/apache/lucene-solr/commit/1110af2a4a119d8e4367244fbb00e9f605742d2d", "message": "Merge branch 'master' into jira/SOLR-14354", "committedDate": "2020-06-30T06:58:38Z", "type": "commit"}, {"oid": "6e2dc5d2c2558bedf89d118875b734ce76367efa", "url": "https://github.com/apache/lucene-solr/commit/6e2dc5d2c2558bedf89d118875b734ce76367efa", "message": "Fix TrackingShardHandlerFactoroy", "committedDate": "2020-07-02T09:23:59Z", "type": "commit"}, {"oid": "8473ce3f1538004a894b2f8b2eb1bb803b100fb4", "url": "https://github.com/apache/lucene-solr/commit/8473ce3f1538004a894b2f8b2eb1bb803b100fb4", "message": "Fix TestSolrCloudWithHadoopAuthPlugin", "committedDate": "2020-07-06T05:23:56Z", "type": "commit"}, {"oid": "6a92804f8b7e307045e977a0d92d705665b0c8c1", "url": "https://github.com/apache/lucene-solr/commit/6a92804f8b7e307045e977a0d92d705665b0c8c1", "message": "Merge branch 'master' into jira/SOLR-14354", "committedDate": "2020-07-06T10:15:48Z", "type": "commit"}, {"oid": "2f579ec98f8e3879f43ae86f5047d1064f30b498", "url": "https://github.com/apache/lucene-solr/commit/2f579ec98f8e3879f43ae86f5047d1064f30b498", "message": "Move change entry to 8.7.0", "committedDate": "2020-07-06T10:16:36Z", "type": "commit"}]}