{"pr_number": 2148, "pr_title": "SOLR-15052: Per-replica states for reducing overseer bottlenecks (branch_8x)", "pr_createdAt": "2020-12-16T10:20:32Z", "pr_url": "https://github.com/apache/lucene-solr/pull/2148", "timeline": [{"oid": "3c02c91973763973138db7c874f9fca11d88f492", "url": "https://github.com/apache/lucene-solr/commit/3c02c91973763973138db7c874f9fca11d88f492", "message": "SOLR-15052: Per-replica states for reducing overseer bottlenecks\n\nCo-authored-by: Noble Paul <noble@apache.org>", "committedDate": "2020-12-16T10:15:41Z", "type": "commit"}, {"oid": "f217a589f644a2ef52c182fe6e74697abb3c4b19", "url": "https://github.com/apache/lucene-solr/commit/f217a589f644a2ef52c182fe6e74697abb3c4b19", "message": "SOLR-15052: Fixing compilation", "committedDate": "2020-12-16T11:42:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1NTUzMQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544255531", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if(leader != null) currentLeader = leader.getName();\n          \n          \n            \n                  if (leader != null) currentLeader = leader.getName();", "author": "jbampton", "createdAt": "2020-12-16T12:22:21Z", "path": "solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase.java", "diffHunk": "@@ -161,9 +163,11 @@ void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStartMs)\n \n     assert shardId != null;\n     boolean isAlreadyLeader = false;\n+    String currentLeader = null;\n     if (zkStateReader.getClusterState() != null &&\n         zkStateReader.getClusterState().getCollection(collection).getSlice(shardId).getReplicas().size() < 2) {\n       Replica leader = zkStateReader.getLeader(collection, shardId);\n+      if(leader != null) currentLeader = leader.getName();", "originalCommit": "f217a589f644a2ef52c182fe6e74697abb3c4b19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1NTk1OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544255958", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if(forcePublish || sendToOverseer(coll, coreNodeName)) {\n          \n          \n            \n                  if (forcePublish || sendToOverseer(coll, coreNodeName)) {", "author": "jbampton", "createdAt": "2020-12-16T12:23:02Z", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -1609,12 +1611,41 @@ public void publish(final CoreDescriptor cd, final Replica.State state, boolean\n       if (updateLastState) {\n         cd.getCloudDescriptor().setLastPublished(state);\n       }\n-      overseerJobQueue.offer(Utils.toJSON(m));\n+      DocCollection coll = zkStateReader.getCollection(collection);\n+      if(forcePublish || sendToOverseer(coll, coreNodeName)) {", "originalCommit": "f217a589f644a2ef52c182fe6e74697abb3c4b19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1NjEwOA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544256108", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            //        if(log.isInfoEnabled()) {\n          \n          \n            \n            //        if (log.isInfoEnabled()) {", "author": "jbampton", "createdAt": "2020-12-16T12:23:17Z", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -1609,12 +1611,41 @@ public void publish(final CoreDescriptor cd, final Replica.State state, boolean\n       if (updateLastState) {\n         cd.getCloudDescriptor().setLastPublished(state);\n       }\n-      overseerJobQueue.offer(Utils.toJSON(m));\n+      DocCollection coll = zkStateReader.getCollection(collection);\n+      if(forcePublish || sendToOverseer(coll, coreNodeName)) {\n+        overseerJobQueue.offer(Utils.toJSON(m));\n+      } else {\n+//        if(log.isInfoEnabled()) {", "originalCommit": "f217a589f644a2ef52c182fe6e74697abb3c4b19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1NjUxMw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544256513", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if(prop.equals(DocCollection.PER_REPLICA_STATE)) {\n          \n          \n            \n                  if (prop.equals(DocCollection.PER_REPLICA_STATE)) {", "author": "jbampton", "createdAt": "2020-12-16T12:23:59Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java", "diffHunk": "@@ -107,7 +111,21 @@ public ZkWriteCommand modifyCollection(final ClusterState clusterState, ZkNodePr\n     DocCollection coll = clusterState.getCollection(message.getStr(COLLECTION_PROP));\n     Map<String, Object> m = coll.shallowCopy();\n     boolean hasAnyOps = false;\n+    PerReplicaStates.WriteOps replicaOps = null;\n     for (String prop : CollectionAdminRequest.MODIFIABLE_COLLECTION_PROPERTIES) {\n+      if(prop.equals(DocCollection.PER_REPLICA_STATE)) {", "originalCommit": "f217a589f644a2ef52c182fe6e74697abb3c4b19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1NjYxNA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544256614", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     if(val == null) continue;\n          \n          \n            \n                     if (val == null) continue;", "author": "jbampton", "createdAt": "2020-12-16T12:24:12Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java", "diffHunk": "@@ -107,7 +111,21 @@ public ZkWriteCommand modifyCollection(final ClusterState clusterState, ZkNodePr\n     DocCollection coll = clusterState.getCollection(message.getStr(COLLECTION_PROP));\n     Map<String, Object> m = coll.shallowCopy();\n     boolean hasAnyOps = false;\n+    PerReplicaStates.WriteOps replicaOps = null;\n     for (String prop : CollectionAdminRequest.MODIFIABLE_COLLECTION_PROPERTIES) {\n+      if(prop.equals(DocCollection.PER_REPLICA_STATE)) {\n+         String val = message.getStr(DocCollection.PER_REPLICA_STATE);\n+         if(val == null) continue;", "originalCommit": "f217a589f644a2ef52c182fe6e74697abb3c4b19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1Njc1NQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544256755", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(enable == coll.isPerReplicaState()) {\n          \n          \n            \n                    if (enable == coll.isPerReplicaState()) {", "author": "jbampton", "createdAt": "2020-12-16T12:24:25Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java", "diffHunk": "@@ -107,7 +111,21 @@ public ZkWriteCommand modifyCollection(final ClusterState clusterState, ZkNodePr\n     DocCollection coll = clusterState.getCollection(message.getStr(COLLECTION_PROP));\n     Map<String, Object> m = coll.shallowCopy();\n     boolean hasAnyOps = false;\n+    PerReplicaStates.WriteOps replicaOps = null;\n     for (String prop : CollectionAdminRequest.MODIFIABLE_COLLECTION_PROPERTIES) {\n+      if(prop.equals(DocCollection.PER_REPLICA_STATE)) {\n+         String val = message.getStr(DocCollection.PER_REPLICA_STATE);\n+         if(val == null) continue;\n+        boolean enable = Boolean.parseBoolean(val);\n+        if(enable == coll.isPerReplicaState()) {", "originalCommit": "f217a589f644a2ef52c182fe6e74697abb3c4b19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1Njk3OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544256978", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if(replicaOps == null){\n          \n          \n            \n                if (replicaOps == null){", "author": "jbampton", "createdAt": "2020-12-16T12:24:45Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java", "diffHunk": "@@ -136,8 +154,13 @@ public ZkWriteCommand modifyCollection(final ClusterState clusterState, ZkNodePr\n       return ZkStateWriter.NO_OP;\n     }\n \n-    return new ZkWriteCommand(coll.getName(),\n-        new DocCollection(coll.getName(), coll.getSlicesMap(), m, coll.getRouter(), coll.getZNodeVersion(), coll.getZNode()));\n+    DocCollection collection = new DocCollection(coll.getName(), coll.getSlicesMap(), m, coll.getRouter(), coll.getZNodeVersion(), coll.getZNode());\n+    if(replicaOps == null){", "originalCommit": "f217a589f644a2ef52c182fe6e74697abb3c4b19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI4NDYyMQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544284621", "bodyText": "Thanks, fixed.", "author": "chatman", "createdAt": "2020-12-16T13:09:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1Njk3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1NzEzNA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544257134", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(docCollection.isPerReplicaState()) {\n          \n          \n            \n                    if (docCollection.isPerReplicaState()) {", "author": "jbampton", "createdAt": "2020-12-16T12:25:03Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/NodeMutator.java", "diffHunk": "@@ -76,7 +80,12 @@\n       }\n \n       if (needToUpdateCollection) {\n-        zkWriteCommands.add(new ZkWriteCommand(collection, docCollection.copyWithSlices(slicesCopy)));\n+        if(docCollection.isPerReplicaState()) {", "originalCommit": "f217a589f644a2ef52c182fe6e74697abb3c4b19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1NzY0Ng==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544257646", "bodyText": "There are more like this", "author": "jbampton", "createdAt": "2020-12-16T12:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1NzEzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI4NDQ2MA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544284460", "bodyText": "Thanks, fixed.", "author": "chatman", "createdAt": "2020-12-16T13:09:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDI1NzEzNA=="}], "type": "inlineReview"}, {"oid": "5b5e3f8fb5988a6101d62a1c5dab3f82771fed25", "url": "https://github.com/apache/lucene-solr/commit/5b5e3f8fb5988a6101d62a1c5dab3f82771fed25", "message": "SOLR-15052: Fixing ConfigureRecoveryStrategyTest test failure", "committedDate": "2020-12-16T12:43:51Z", "type": "commit"}, {"oid": "55421922ff1d843ca378fe43a63183e8c77914c4", "url": "https://github.com/apache/lucene-solr/commit/55421922ff1d843ca378fe43a63183e8c77914c4", "message": "SOLR-15052: Fixing based on review from jbampton", "committedDate": "2020-12-16T12:48:35Z", "type": "commit"}, {"oid": "bf9aee07386f2617a793ce0853e8709d547d31ab", "url": "https://github.com/apache/lucene-solr/commit/bf9aee07386f2617a793ce0853e8709d547d31ab", "message": "SOLR-15052: Formatting fixes", "committedDate": "2020-12-16T13:04:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMwNjE4OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544306188", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(created) break;\n          \n          \n            \n                    if (created) break;", "author": "jbampton", "createdAt": "2020-12-16T13:41:10Z", "path": "solr/core/src/java/org/apache/solr/cloud/api/collections/CreateCollectionCmd.java", "diffHunk": "@@ -182,6 +182,7 @@ public void call(ClusterState clusterState, ZkNodeProps message, @SuppressWarnin\n         if(created) break;", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMwNzA5OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544307098", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                zkStateReader.nodeName =  nodeName;\n          \n          \n            \n                zkStateReader.nodeName = nodeName;", "author": "jbampton", "createdAt": "2020-12-16T13:42:24Z", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -474,6 +475,7 @@ public boolean isClosed() {\n     zkStateReader = new ZkStateReader(zkClient, () -> {\n       if (cc != null) cc.securityNodeChanged();\n     });\n+    zkStateReader.nodeName =  nodeName;", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMwNzQ1Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544307457", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (message.get(prop) == null)  {\n          \n          \n            \n                    if (message.get(prop) == null) {", "author": "jbampton", "createdAt": "2020-12-16T13:42:51Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java", "diffHunk": "@@ -107,7 +111,21 @@ public ZkWriteCommand modifyCollection(final ClusterState clusterState, ZkNodePr\n     DocCollection coll = clusterState.getCollection(message.getStr(COLLECTION_PROP));\n     Map<String, Object> m = coll.shallowCopy();\n     boolean hasAnyOps = false;\n+    PerReplicaStates.WriteOps replicaOps = null;\n     for (String prop : CollectionAdminRequest.MODIFIABLE_COLLECTION_PROPERTIES) {\n+      if (prop.equals(DocCollection.PER_REPLICA_STATE)) {\n+         String val = message.getStr(DocCollection.PER_REPLICA_STATE);\n+         if (val == null) continue;\n+        boolean enable = Boolean.parseBoolean(val);\n+        if (enable == coll.isPerReplicaState()) {\n+          //already enabled\n+          log.error(\"trying to set perReplicaState to {} from {}\", val, coll.isPerReplicaState());\n+          continue;\n+        }\n+        replicaOps = PerReplicaStates.WriteOps.modifyCollection(coll, enable, PerReplicaStates.fetch(coll.getZNode(), zkClient, null));\n+      }\n+\n+\n       if (message.containsKey(prop)) {\n         hasAnyOps = true;\n         if (message.get(prop) == null)  {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMwNzc0Ng==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544307746", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Slice slice = collection != null ?  collection.getSlice(sliceName) : null;\n          \n          \n            \n                Slice slice = collection != null ? collection.getSlice(sliceName) : null;", "author": "jbampton", "createdAt": "2020-12-16T13:43:17Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/ReplicaMutator.java", "diffHunk": "@@ -281,13 +290,15 @@ private ZkWriteCommand updateState(final ClusterState prevState, ZkNodeProps mes\n       }\n       sliceName = Assign.assignShard(collection, numShards);\n       log.info(\"Assigning new node to shard shard={}\", sliceName);\n+      persistCollectionState = true;\n     }\n \n     Slice slice = collection != null ?  collection.getSlice(sliceName) : null;", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMwODE0Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544308147", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (forceFlush ||  maybeFlushAfter()) {\n          \n          \n            \n                if (forceFlush || maybeFlushAfter()) {", "author": "jbampton", "createdAt": "2020-12-16T13:43:51Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter.java", "diffHunk": "@@ -113,20 +114,52 @@ public ClusterState enqueueUpdate(ClusterState prevState, List<ZkWriteCommand> c\n     if (cmds.isEmpty()) return prevState;\n     if (isNoOps(cmds)) return prevState;\n \n+    boolean forceFlush = false;\n+    if (cmds.size() == 1) {\n+      //most messages result in only one command. let's deal with it right away\n+      ZkWriteCommand cmd = cmds.get(0);\n+      if (cmd.collection != null && cmd.collection.isPerReplicaState()) {\n+        //we do not wish to batch any updates for collections with per-replica state because\n+        // these changes go to individual ZK nodes and there is zero advantage to batching\n+        //now check if there are any updates for the same collection already present\n+        if (updates.containsKey(cmd.name)) {\n+          //this should not happen\n+          // but let's get those updates out anyway\n+          writeUpdate(updates.remove(cmd.name));\n+        }\n+        //now let's write the current message\n+        try {\n+          return writeUpdate(cmd);\n+        } finally {\n+          if (callback !=null) callback.onWrite();\n+        }\n+      }\n+    } else {\n+      //there are more than one commands created as a result of this message\n+      for (ZkWriteCommand cmd : cmds) {\n+        if (cmd.collection != null && cmd.collection.isPerReplicaState()) {\n+          // we don't try to optimize for this case. let's flush out all after this\n+          forceFlush = true;\n+          break;\n+        }\n+      }\n+    }\n+\n+\n     for (ZkWriteCommand cmd : cmds) {\n       if (cmd == NO_OP) continue;\n       if (!isClusterStateModified && clusterStateGetModifiedWith(cmd, prevState)) {\n         isClusterStateModified = true;\n       }\n       prevState = prevState.copyWith(cmd.name, cmd.collection);\n       if (cmd.collection == null || cmd.collection.getStateFormat() != 1) {\n-        updates.put(cmd.name, cmd.collection);\n+        updates.put(cmd.name, cmd);\n         numUpdates++;\n       }\n     }\n     clusterState = prevState;\n \n-    if (maybeFlushAfter()) {\n+    if (forceFlush ||  maybeFlushAfter()) {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMwODI5OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544308298", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Map<String, ZkWriteCommand> commands =  new HashMap<>();\n          \n          \n            \n                Map<String, ZkWriteCommand> commands = new HashMap<>();", "author": "jbampton", "createdAt": "2020-12-16T13:44:04Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/ZkStateWriter.java", "diffHunk": "@@ -165,7 +198,15 @@ private boolean maybeFlushAfter() {\n   public boolean hasPendingUpdates() {\n     return numUpdates != 0 || isClusterStateModified;\n   }\n+  public ClusterState writeUpdate(ZkWriteCommand command) throws IllegalStateException, KeeperException, InterruptedException {\n+    Map<String, ZkWriteCommand> commands =  new HashMap<>();", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMwODg1OQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544308859", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .setMaxShardsPerNode(2), TRA_Dim,  CRA_Dim);\n          \n          \n            \n                        .setMaxShardsPerNode(2), TRA_Dim, CRA_Dim);", "author": "jbampton", "createdAt": "2020-12-16T13:44:50Z", "path": "solr/core/src/test/org/apache/solr/update/processor/DimensionalRoutedAliasUpdateProcessorTest.java", "diffHunk": "@@ -100,6 +101,7 @@ public void testTimeCat() throws Exception {\n \n     CollectionAdminRequest.DimensionalRoutedAlias dra = CollectionAdminRequest.createDimensionalRoutedAlias(getAlias(),\n         CollectionAdminRequest.createCollection(\"_unused_\", configName, 2, 2)\n+            .setPerReplicaState(SolrCloudTestCase.USE_PER_REPLICA_STATE)\n             .setMaxShardsPerNode(2), TRA_Dim,  CRA_Dim);", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMwOTIwMw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544309203", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Create setPerReplicaState(Boolean b) {this.perReplicaState =  b; return this; }\n          \n          \n            \n                public Create setPerReplicaState(Boolean b) {this.perReplicaState = b; return this; }", "author": "jbampton", "createdAt": "2020-12-16T13:45:18Z", "path": "solr/solrj/src/java/org/apache/solr/client/solrj/request/CollectionAdminRequest.java", "diffHunk": "@@ -489,6 +492,7 @@ private Create(String collection, String config, String routerName, Integer numS\n     public Create setStateFormat(Integer stateFormat) { this.stateFormat = stateFormat; return this; }\n     public Create setRule(String... s){ this.rule = s; return this; }\n     public Create setSnitch(String... s){ this.snitch = s; return this; }\n+    public Create setPerReplicaState(Boolean b) {this.perReplicaState =  b; return this; }", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMxMDAyNA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544310024", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static State getState(String  c) {\n          \n          \n            \n              public static State getState(String c) {", "author": "jbampton", "createdAt": "2020-12-16T13:46:27Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/Replica.java", "diffHunk": "@@ -208,6 +234,40 @@ public String getProperty(String propertyName) {\n     return propertyValue;\n   }\n \n+  public Replica copyWith(PerReplicaStates.State state) {\n+    log.debug(\"A replica is updated with new state : {}\", state);\n+    Map<String, Object> props = new LinkedHashMap<>(propMap);\n+    if (state == null) {\n+      props.put(ZkStateReader.STATE_PROP, State.DOWN.toString());\n+      props.remove(Slice.LEADER);\n+    } else {\n+      props.put(ZkStateReader.STATE_PROP, state.state.toString());\n+      if (state.isLeader) props.put(Slice.LEADER, \"true\");\n+    }\n+    Replica r = new Replica(name, props, collection, slice);\n+    r.replicaState = state;\n+    return r;\n+  }\n+\n+  public PerReplicaStates.State getReplicaState() {\n+    return replicaState;\n+  }\n+\n+  private static final Map<String, State> STATES = new HashMap<>();\n+  static {\n+    STATES.put(Replica.State.ACTIVE.shortName, Replica.State.ACTIVE);\n+    STATES.put(Replica.State.DOWN.shortName, Replica.State.DOWN);\n+    STATES.put(Replica.State.RECOVERING.shortName, Replica.State.RECOVERING);\n+    STATES.put(Replica.State.RECOVERY_FAILED.shortName, Replica.State.RECOVERY_FAILED);\n+  }\n+  public static State getState(String  c) {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDYxOTM3NQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r544619375", "bodyText": "We don't need this anymore after #2151", "author": "madrob", "createdAt": "2020-12-16T21:00:04Z", "path": "solr/core/src/java/org/apache/solr/cloud/RecoveryStrategy.java", "diffHunk": "@@ -432,7 +432,7 @@ final private void doReplicateOnlyRecovery(SolrCore core) throws InterruptedExce\n   /**\n    * @return true if we have reached max attempts or should stop recovering for some other reason\n    */\n-  private boolean waitBetweenRecoveries(String coreName) {\n+  final private boolean waitBetweenRecoveries(String coreName) {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzMjA5MA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545332090", "bodyText": "Is this just used for debug logging? If so, I'd just load it where we use it.", "author": "madrob", "createdAt": "2020-12-17T19:03:11Z", "path": "solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase.java", "diffHunk": "@@ -161,9 +163,11 @@ void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStartMs)\n \n     assert shardId != null;\n     boolean isAlreadyLeader = false;\n+    String currentLeader = null;", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0MzE3Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547043177", "bodyText": "yeah, it can be removed", "author": "noblepaul", "createdAt": "2020-12-22T03:12:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzMjA5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1ODQyMg==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547058422", "bodyText": "we do not need it", "author": "noblepaul", "createdAt": "2020-12-22T04:15:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMzMjA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4ODUxOQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545388519", "bodyText": "unused.", "author": "madrob", "createdAt": "2020-12-17T20:38:20Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    try {\n+      persist(ops.get(), znode, zkClient);\n+    } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+      //state is stale\n+      log.info(\"stale state for {} . retrying...\", znode);\n+      List<Op> freshOps = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      persist(freshOps, znode, zkClient);\n+      log.info(\"retried for stale state {}, succeeded\", znode);\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Op> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<org.apache.zookeeper.Op> ops = new ArrayList<>(operations.size());\n+    for (Op op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Op.Type.ADD ?\n+          org.apache.zookeeper.Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          org.apache.zookeeper.Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Fetch the latest {@link PerReplicaStates} . It fetches data after checking the {@link Stat#getCversion()} of state.json.\n+   * If this is not modified, the same object is returned\n+   */\n+  public static PerReplicaStates fetch(String path, SolrZkClient zkClient, PerReplicaStates current) {\n+    try {\n+      if (current != null) {\n+        Stat stat = zkClient.exists(current.path, null, true);\n+        if (stat == null) return new PerReplicaStates(path, -1, Collections.emptyList());\n+        if (current.cversion == stat.getCversion()) return current;// not modifiedZkStateReaderTest\n+      }\n+      Stat stat = new Stat();\n+      List<String> children = zkClient.getChildren(path, null, stat, true);\n+      return new PerReplicaStates(path, stat.getCversion(), Collections.unmodifiableList(children));\n+    } catch (KeeperException e) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error fetching per-replica states\", e);\n+    } catch (InterruptedException e) {\n+      SolrZkClient.checkInterrupted(e);\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted when loading per-replica states from \" + path, e);\n+    }\n+  }\n+\n+\n+  private static List<Op> addDeleteStaleNodes(List<Op> ops, State rs) {\n+    while (rs != null) {\n+      ops.add(new Op(Op.Type.DELETE, rs));\n+      rs = rs.duplicate;\n+    }\n+    return ops;\n+  }\n+\n+  public static String getReplicaName(String s) {\n+    int idx = s.indexOf(SEPARATOR);\n+    if (idx > 0) {\n+      return s.substring(0, idx);\n+    }\n+    return null;\n+  }\n+\n+  public State get(String replica) {\n+    return states.get(replica);\n+  }\n+\n+  public static class Op {\n+    public final Type typ;\n+    public final State state;\n+\n+    public Op(Type typ, State replicaState) {\n+      this.typ = typ;\n+      this.state = replicaState;\n+    }\n+\n+\n+    public enum Type {\n+      //add a new node\n+      ADD,\n+      //delete an existing node\n+      DELETE\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return typ.toString() + \" : \" + state;\n+    }\n+  }\n+\n+\n+  /**\n+   * The state of a replica as stored as a node under /collections/collection-name/state.json/replica-state\n+   */\n+  public static class State implements MapWriter {\n+\n+    public final String replica;\n+\n+    public final Replica.State state;\n+\n+    public final Boolean isLeader;\n+\n+    public final int version;\n+\n+    public final String asString;\n+\n+    /**\n+     * if there are multiple entries for the same replica, e.g: core_node_1:12:A core_node_1:13:D\n+     * <p>\n+     * the entry with '13' is the latest and the one with '12' is considered a duplicate\n+     * <p>\n+     * These are unlikely, but possible\n+     */\n+    final State duplicate;\n+\n+    private State(String serialized, List<String> pieces) {\n+      this.asString = serialized;\n+      replica = pieces.get(0);\n+      version = Integer.parseInt(pieces.get(1));\n+      String encodedStatus = pieces.get(2);\n+      this.state = Replica.getState(encodedStatus);\n+      isLeader = pieces.size() > 3 && \"L\".equals(pieces.get(3));\n+      duplicate = null;\n+    }\n+\n+    public static State parse(String serialized) {\n+      List<String> pieces = StrUtils.splitSmart(serialized, ':');\n+      if (pieces.size() < 3) return null;\n+      return new State(serialized, pieces);\n+\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version) {\n+      this(replica, state, isLeader, version, null);\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version, State duplicate) {\n+      this.replica = replica;\n+      this.state = state == null ? Replica.State.ACTIVE : state;\n+      this.isLeader = isLeader == null ? Boolean.FALSE : isLeader;\n+      this.version = version;\n+      asString = serialize();\n+      this.duplicate = duplicate;\n+    }\n+\n+    @Override\n+    public void writeMap(EntryWriter ew) throws IOException {\n+      ew.put(NAME, replica);\n+      ew.put(VERSION, version);\n+      ew.put(ZkStateReader.STATE_PROP, state.toString());\n+      if (isLeader) ew.put(Slice.LEADER, isLeader);\n+      ew.putIfNotNull(\"duplicate\", duplicate);\n+    }\n+\n+    private State insert(State duplicate) {\n+      assert this.replica.equals(duplicate.replica);\n+      if (this.version >= duplicate.version) {\n+        if (this.duplicate != null) {\n+          duplicate = new State(duplicate.replica, duplicate.state, duplicate.isLeader, duplicate.version, this.duplicate);\n+        }\n+        return new State(this.replica, this.state, this.isLeader, this.version, duplicate);\n+      } else {\n+        return duplicate.insert(this);\n+      }\n+    }\n+\n+    /**\n+     * fetch duplicates entries for this replica\n+     */\n+    List<State> getDuplicates() {\n+      if (duplicate == null) return Collections.emptyList();\n+      List<State> result = new ArrayList<>();\n+      State current = duplicate;\n+      while (current != null) {\n+        result.add(current);\n+        current = current.duplicate;\n+      }\n+      return result;\n+    }\n+\n+    private String serialize() {\n+      StringBuilder sb = new StringBuilder(replica)\n+          .append(\":\")\n+          .append(version)\n+          .append(\":\")\n+          .append(state.shortName);\n+      if (isLeader) sb.append(\":\").append(\"L\");\n+      return sb.toString();\n+    }\n+\n+\n+    @Override\n+    public String toString() {\n+      return asString;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof State) {\n+        State that = (State) o;\n+        return Objects.equals(this.asString, that.asString);\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return asString.hashCode();\n+    }\n+  }\n+\n+\n+  public static abstract class WriteOps {\n+    private PerReplicaStates rs;\n+    List<Op> ops;\n+    private boolean preOp = true;\n+\n+    /**\n+     * state of a replica is changed\n+     *\n+     * @param newState the new state\n+     */\n+    public static WriteOps flipState(String replica, Replica.State newState, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> ops = new ArrayList<>(2);\n+          State existing = rs.get(replica);\n+          if (existing == null) {\n+            ops.add(new Op(Op.Type.ADD, new State(replica, newState, Boolean.FALSE, 0)));\n+          } else {\n+            ops.add(new Op(Op.Type.ADD, new State(replica, newState, existing.isLeader, existing.version + 1)));\n+            addDeleteStaleNodes(ops, existing);\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"flipState on {}, {} -> {}, ops :{}\", rs.path, replica, newState, ops);\n+          }\n+          return ops;\n+        }\n+      }.init(rs);\n+    }\n+\n+    public PerReplicaStates getPerReplicaStates() {\n+      return rs;\n+    }\n+\n+\n+    /**Switch a collection from/to perReplicaState=true\n+     */\n+    public static WriteOps modifyCollection(DocCollection coll, boolean enable, PerReplicaStates prs) {\n+      return new WriteOps() {\n+        @Override\n+        List<Op> refresh(PerReplicaStates prs) {\n+          return enable ? enable(coll) : disable(prs);\n+        }\n+\n+        List<Op> enable(DocCollection coll) {\n+          List<Op> result = new ArrayList<>();\n+          coll.forEachReplica((s, r) -> result.add(new Op(Op.Type.ADD, new State(r.getName(), r.getState(), r.isLeader(), 0))));\n+          return result;\n+        }\n+\n+        List<Op> disable(PerReplicaStates prs) {\n+          List<Op> result = new ArrayList<>();\n+          prs.states.forEachEntry((s, state) -> result.add(new Op(Op.Type.DELETE, state)));\n+          return result;\n+        }\n+      }.init(prs);\n+\n+    }\n+\n+    /**\n+     * Flip the leader replica to a new one\n+     *\n+     * @param allReplicas  allReplicas of the shard\n+     * @param next next leader\n+     */\n+    public static WriteOps flipLeader(Set<String> allReplicas, String next, PerReplicaStates rs) {\n+      return new WriteOps() {\n+\n+        @Override\n+        protected List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> ops = new ArrayList<>(4);\n+          if (next != null) {\n+            State st = rs.get(next);\n+            if (st != null) {\n+              if (!st.isLeader) {\n+                ops.add(new Op(Op.Type.ADD, new State(st.replica, Replica.State.ACTIVE, Boolean.TRUE, st.version + 1)));\n+                ops.add(new Op(Op.Type.DELETE, st));\n+              }\n+              //else do not do anything , that node is the leader\n+            } else {\n+              //there is no entry for the new leader.\n+              //create one\n+              ops.add(new Op(Op.Type.ADD, new State(next, Replica.State.ACTIVE, Boolean.TRUE, 0)));\n+            }\n+          }\n+\n+          //now go through all other replicas and unset previous leader\n+          for (String r : allReplicas) {\n+            State st = rs.get(r);\n+            if (st == null) continue;//unlikely\n+            if (!Objects.equals(r, next)) {\n+              if (st.isLeader) {\n+                //some other replica is the leader now. unset\n+                ops.add(new Op(Op.Type.ADD, new State(st.replica, st.state, Boolean.FALSE, st.version + 1)));\n+                ops.add(new Op(Op.Type.DELETE, st));\n+              }\n+            }\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"flipLeader on:{}, {} -> {}, ops: {}\", rs.path, allReplicas, next, ops);\n+          }\n+          return ops;\n+        }\n+\n+      }.init(rs);\n+    }\n+\n+    /**\n+     * Delete a replica entry from per-replica states\n+     *\n+     * @param replica name of the replica to be deleted\n+     */\n+    public static WriteOps deleteReplica(String replica, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> result;\n+          if (rs == null) {\n+            result = Collections.emptyList();\n+          } else {\n+            State state = rs.get(replica);\n+            result = addDeleteStaleNodes(new ArrayList<>(), state);\n+          }\n+          return result;\n+        }\n+      }.init(rs);\n+    }\n+\n+    public static WriteOps addReplica(String replica, Replica.State state, boolean isLeader, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Op> refresh(PerReplicaStates rs) {\n+          return singletonList(new Op(Op.Type.ADD,\n+              new State(replica, state, isLeader, 0)));\n+        }\n+      }.init(rs);\n+    }\n+\n+    /**\n+     * mark a bunch of replicas as DOWN\n+     */\n+    public static WriteOps downReplicas(List<String> replicas, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> ops = new ArrayList<>();\n+          for (String replica : replicas) {\n+            State r = rs.get(replica);\n+            if (r != null) {\n+              if (r.state == Replica.State.DOWN && !r.isLeader) continue;\n+              ops.add(new Op(Op.Type.ADD, new State(replica, Replica.State.DOWN, Boolean.FALSE, r.version + 1)));\n+              addDeleteStaleNodes(ops, r);\n+            } else {\n+              ops.add(new Op(Op.Type.ADD, new State(replica, Replica.State.DOWN, Boolean.FALSE, 0)));\n+            }\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"for coll: {} down replicas {}, ops {}\", rs, replicas, ops);\n+          }\n+          return ops;\n+        }\n+      }.init(rs);\n+    }\n+\n+    /**\n+     * Just creates and deletes a summy entry so that the {@link Stat#getCversion()} of states.json\n+     * is updated\n+     */\n+    public static WriteOps touchChildren() {\n+      WriteOps result = new WriteOps() {\n+        @Override\n+        List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> ops = new ArrayList<>();\n+          State st = new State(\".dummy.\" + System.nanoTime(), Replica.State.DOWN, Boolean.FALSE, 0);\n+          ops.add(new Op(Op.Type.ADD, st));\n+          ops.add(new Op(Op.Type.DELETE, st));\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"touchChildren {}\", ops);\n+          }\n+          return ops;\n+        }\n+      };\n+      result.preOp = false;\n+      result.ops = result.refresh(null);\n+      return result;\n+    }\n+\n+    WriteOps init(PerReplicaStates rs) {\n+      if (rs == null) return null;\n+      get(rs);\n+      return this;\n+    }\n+\n+    public List<Op> get() {\n+      return ops;\n+    }\n+\n+    public List<Op> get(PerReplicaStates rs) {\n+      ops = refresh(rs);\n+      if (ops == null) ops = Collections.emptyList();\n+      this.rs = rs;\n+      return ops;\n+    }\n+\n+    /**\n+     * To be executed before collection state.json is persisted\n+     */\n+    public boolean isPreOp() {\n+      return preOp;\n+    }\n+\n+    /**\n+     * if a multi operation fails because the state got modified from behind,\n+     * refresh the operation and try again\n+     *\n+     * @param prs The new state\n+     */\n+    abstract List<Op> refresh(PerReplicaStates prs);\n+\n+    @Override\n+    public String toString() {\n+      return ops.toString();\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder(\"{\").append(path).append(\"/[\").append(cversion).append(\"]: [\");\n+    appendStates(sb);\n+    return sb.append(\"]}\").toString();\n+  }\n+\n+  private StringBuilder appendStates(StringBuilder sb) {\n+    states.forEachEntry(new BiConsumer<String, State>() {\n+      int count = 0;\n+      @Override\n+      public void accept(String s, State state) {\n+        if (count++ > 0) sb.append(\", \");\n+        sb.append(state.asString);\n+        for (State d : state.getDuplicates()) sb.append(d.asString);\n+      }\n+    });\n+    return sb;", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM4OTMwOA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545389308", "bodyText": "there is a lot of content in this class, I think it would be good as a stand alone file.\nalso, please add javadoc.", "author": "madrob", "createdAt": "2020-12-17T20:39:48Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    try {\n+      persist(ops.get(), znode, zkClient);\n+    } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+      //state is stale\n+      log.info(\"stale state for {} . retrying...\", znode);\n+      List<Op> freshOps = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      persist(freshOps, znode, zkClient);\n+      log.info(\"retried for stale state {}, succeeded\", znode);\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Op> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<org.apache.zookeeper.Op> ops = new ArrayList<>(operations.size());\n+    for (Op op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Op.Type.ADD ?\n+          org.apache.zookeeper.Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          org.apache.zookeeper.Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Fetch the latest {@link PerReplicaStates} . It fetches data after checking the {@link Stat#getCversion()} of state.json.\n+   * If this is not modified, the same object is returned\n+   */\n+  public static PerReplicaStates fetch(String path, SolrZkClient zkClient, PerReplicaStates current) {\n+    try {\n+      if (current != null) {\n+        Stat stat = zkClient.exists(current.path, null, true);\n+        if (stat == null) return new PerReplicaStates(path, -1, Collections.emptyList());\n+        if (current.cversion == stat.getCversion()) return current;// not modifiedZkStateReaderTest\n+      }\n+      Stat stat = new Stat();\n+      List<String> children = zkClient.getChildren(path, null, stat, true);\n+      return new PerReplicaStates(path, stat.getCversion(), Collections.unmodifiableList(children));\n+    } catch (KeeperException e) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error fetching per-replica states\", e);\n+    } catch (InterruptedException e) {\n+      SolrZkClient.checkInterrupted(e);\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted when loading per-replica states from \" + path, e);\n+    }\n+  }\n+\n+\n+  private static List<Op> addDeleteStaleNodes(List<Op> ops, State rs) {\n+    while (rs != null) {\n+      ops.add(new Op(Op.Type.DELETE, rs));\n+      rs = rs.duplicate;\n+    }\n+    return ops;\n+  }\n+\n+  public static String getReplicaName(String s) {\n+    int idx = s.indexOf(SEPARATOR);\n+    if (idx > 0) {\n+      return s.substring(0, idx);\n+    }\n+    return null;\n+  }\n+\n+  public State get(String replica) {\n+    return states.get(replica);\n+  }\n+\n+  public static class Op {\n+    public final Type typ;\n+    public final State state;\n+\n+    public Op(Type typ, State replicaState) {\n+      this.typ = typ;\n+      this.state = replicaState;\n+    }\n+\n+\n+    public enum Type {\n+      //add a new node\n+      ADD,\n+      //delete an existing node\n+      DELETE\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return typ.toString() + \" : \" + state;\n+    }\n+  }\n+\n+\n+  /**\n+   * The state of a replica as stored as a node under /collections/collection-name/state.json/replica-state\n+   */\n+  public static class State implements MapWriter {\n+\n+    public final String replica;\n+\n+    public final Replica.State state;\n+\n+    public final Boolean isLeader;\n+\n+    public final int version;\n+\n+    public final String asString;\n+\n+    /**\n+     * if there are multiple entries for the same replica, e.g: core_node_1:12:A core_node_1:13:D\n+     * <p>\n+     * the entry with '13' is the latest and the one with '12' is considered a duplicate\n+     * <p>\n+     * These are unlikely, but possible\n+     */\n+    final State duplicate;\n+\n+    private State(String serialized, List<String> pieces) {\n+      this.asString = serialized;\n+      replica = pieces.get(0);\n+      version = Integer.parseInt(pieces.get(1));\n+      String encodedStatus = pieces.get(2);\n+      this.state = Replica.getState(encodedStatus);\n+      isLeader = pieces.size() > 3 && \"L\".equals(pieces.get(3));\n+      duplicate = null;\n+    }\n+\n+    public static State parse(String serialized) {\n+      List<String> pieces = StrUtils.splitSmart(serialized, ':');\n+      if (pieces.size() < 3) return null;\n+      return new State(serialized, pieces);\n+\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version) {\n+      this(replica, state, isLeader, version, null);\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version, State duplicate) {\n+      this.replica = replica;\n+      this.state = state == null ? Replica.State.ACTIVE : state;\n+      this.isLeader = isLeader == null ? Boolean.FALSE : isLeader;\n+      this.version = version;\n+      asString = serialize();\n+      this.duplicate = duplicate;\n+    }\n+\n+    @Override\n+    public void writeMap(EntryWriter ew) throws IOException {\n+      ew.put(NAME, replica);\n+      ew.put(VERSION, version);\n+      ew.put(ZkStateReader.STATE_PROP, state.toString());\n+      if (isLeader) ew.put(Slice.LEADER, isLeader);\n+      ew.putIfNotNull(\"duplicate\", duplicate);\n+    }\n+\n+    private State insert(State duplicate) {\n+      assert this.replica.equals(duplicate.replica);\n+      if (this.version >= duplicate.version) {\n+        if (this.duplicate != null) {\n+          duplicate = new State(duplicate.replica, duplicate.state, duplicate.isLeader, duplicate.version, this.duplicate);\n+        }\n+        return new State(this.replica, this.state, this.isLeader, this.version, duplicate);\n+      } else {\n+        return duplicate.insert(this);\n+      }\n+    }\n+\n+    /**\n+     * fetch duplicates entries for this replica\n+     */\n+    List<State> getDuplicates() {\n+      if (duplicate == null) return Collections.emptyList();\n+      List<State> result = new ArrayList<>();\n+      State current = duplicate;\n+      while (current != null) {\n+        result.add(current);\n+        current = current.duplicate;\n+      }\n+      return result;\n+    }\n+\n+    private String serialize() {\n+      StringBuilder sb = new StringBuilder(replica)\n+          .append(\":\")\n+          .append(version)\n+          .append(\":\")\n+          .append(state.shortName);\n+      if (isLeader) sb.append(\":\").append(\"L\");\n+      return sb.toString();\n+    }\n+\n+\n+    @Override\n+    public String toString() {\n+      return asString;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof State) {\n+        State that = (State) o;\n+        return Objects.equals(this.asString, that.asString);\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return asString.hashCode();\n+    }\n+  }\n+\n+\n+  public static abstract class WriteOps {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NTExMA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545395110", "bodyText": "What benefits does this class provide over using Pair?", "author": "madrob", "createdAt": "2020-12-17T20:50:38Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    try {\n+      persist(ops.get(), znode, zkClient);\n+    } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+      //state is stale\n+      log.info(\"stale state for {} . retrying...\", znode);\n+      List<Op> freshOps = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      persist(freshOps, znode, zkClient);\n+      log.info(\"retried for stale state {}, succeeded\", znode);\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Op> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<org.apache.zookeeper.Op> ops = new ArrayList<>(operations.size());\n+    for (Op op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Op.Type.ADD ?\n+          org.apache.zookeeper.Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          org.apache.zookeeper.Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Fetch the latest {@link PerReplicaStates} . It fetches data after checking the {@link Stat#getCversion()} of state.json.\n+   * If this is not modified, the same object is returned\n+   */\n+  public static PerReplicaStates fetch(String path, SolrZkClient zkClient, PerReplicaStates current) {\n+    try {\n+      if (current != null) {\n+        Stat stat = zkClient.exists(current.path, null, true);\n+        if (stat == null) return new PerReplicaStates(path, -1, Collections.emptyList());\n+        if (current.cversion == stat.getCversion()) return current;// not modifiedZkStateReaderTest\n+      }\n+      Stat stat = new Stat();\n+      List<String> children = zkClient.getChildren(path, null, stat, true);\n+      return new PerReplicaStates(path, stat.getCversion(), Collections.unmodifiableList(children));\n+    } catch (KeeperException e) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error fetching per-replica states\", e);\n+    } catch (InterruptedException e) {\n+      SolrZkClient.checkInterrupted(e);\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted when loading per-replica states from \" + path, e);\n+    }\n+  }\n+\n+\n+  private static List<Op> addDeleteStaleNodes(List<Op> ops, State rs) {\n+    while (rs != null) {\n+      ops.add(new Op(Op.Type.DELETE, rs));\n+      rs = rs.duplicate;\n+    }\n+    return ops;\n+  }\n+\n+  public static String getReplicaName(String s) {\n+    int idx = s.indexOf(SEPARATOR);\n+    if (idx > 0) {\n+      return s.substring(0, idx);\n+    }\n+    return null;\n+  }\n+\n+  public State get(String replica) {\n+    return states.get(replica);\n+  }\n+\n+  public static class Op {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI3NzAyNA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r546277024", "bodyText": "Op class name is confusing because it is used in places where org.apache.zookeeper.Op is also used.", "author": "murblanc", "createdAt": "2020-12-19T20:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0Mjg3OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547042878", "bodyText": "Wanted to use a concrete class, that's it", "author": "noblepaul", "createdAt": "2020-12-22T03:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NTExMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0MzAwOA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547543008", "bodyText": "Agree with @murblanc - too confusing with overloaded terms.", "author": "madrob", "createdAt": "2020-12-22T22:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NjEyNA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545396124", "bodyText": "why is it correct to only retry once?", "author": "madrob", "createdAt": "2020-12-17T20:52:27Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    try {\n+      persist(ops.get(), znode, zkClient);\n+    } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0MzkzMA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547043930", "bodyText": "true. I forgot to make it try multiple times", "author": "noblepaul", "createdAt": "2020-12-22T03:15:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NjEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NjU4NA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545396584", "bodyText": "this seems like it should be an instance method on WriteOps, not needing to be a static method here.", "author": "madrob", "createdAt": "2020-12-17T20:53:20Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTMzMTY4Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r549331687", "bodyText": "the persist op really has nothing much to do with the instance of PRS", "author": "noblepaul", "createdAt": "2020-12-28T12:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NjU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5ODU2Mw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552098563", "bodyText": "but it has everything to do with the instance of the WriteOps.", "author": "madrob", "createdAt": "2021-01-05T17:59:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5NjU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTM5Nzc1OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545397758", "bodyText": "4 seems odd to me - add a comment why it is correct?", "author": "madrob", "createdAt": "2020-12-17T20:55:32Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    try {\n+      persist(ops.get(), znode, zkClient);\n+    } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+      //state is stale\n+      log.info(\"stale state for {} . retrying...\", znode);\n+      List<Op> freshOps = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      persist(freshOps, znode, zkClient);\n+      log.info(\"retried for stale state {}, succeeded\", znode);\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Op> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<org.apache.zookeeper.Op> ops = new ArrayList<>(operations.size());\n+    for (Op op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Op.Type.ADD ?\n+          org.apache.zookeeper.Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          org.apache.zookeeper.Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Fetch the latest {@link PerReplicaStates} . It fetches data after checking the {@link Stat#getCversion()} of state.json.\n+   * If this is not modified, the same object is returned\n+   */\n+  public static PerReplicaStates fetch(String path, SolrZkClient zkClient, PerReplicaStates current) {\n+    try {\n+      if (current != null) {\n+        Stat stat = zkClient.exists(current.path, null, true);\n+        if (stat == null) return new PerReplicaStates(path, -1, Collections.emptyList());\n+        if (current.cversion == stat.getCversion()) return current;// not modifiedZkStateReaderTest\n+      }\n+      Stat stat = new Stat();\n+      List<String> children = zkClient.getChildren(path, null, stat, true);\n+      return new PerReplicaStates(path, stat.getCversion(), Collections.unmodifiableList(children));\n+    } catch (KeeperException e) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error fetching per-replica states\", e);\n+    } catch (InterruptedException e) {\n+      SolrZkClient.checkInterrupted(e);\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted when loading per-replica states from \" + path, e);\n+    }\n+  }\n+\n+\n+  private static List<Op> addDeleteStaleNodes(List<Op> ops, State rs) {\n+    while (rs != null) {\n+      ops.add(new Op(Op.Type.DELETE, rs));\n+      rs = rs.duplicate;\n+    }\n+    return ops;\n+  }\n+\n+  public static String getReplicaName(String s) {\n+    int idx = s.indexOf(SEPARATOR);\n+    if (idx > 0) {\n+      return s.substring(0, idx);\n+    }\n+    return null;\n+  }\n+\n+  public State get(String replica) {\n+    return states.get(replica);\n+  }\n+\n+  public static class Op {\n+    public final Type typ;\n+    public final State state;\n+\n+    public Op(Type typ, State replicaState) {\n+      this.typ = typ;\n+      this.state = replicaState;\n+    }\n+\n+\n+    public enum Type {\n+      //add a new node\n+      ADD,\n+      //delete an existing node\n+      DELETE\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return typ.toString() + \" : \" + state;\n+    }\n+  }\n+\n+\n+  /**\n+   * The state of a replica as stored as a node under /collections/collection-name/state.json/replica-state\n+   */\n+  public static class State implements MapWriter {\n+\n+    public final String replica;\n+\n+    public final Replica.State state;\n+\n+    public final Boolean isLeader;\n+\n+    public final int version;\n+\n+    public final String asString;\n+\n+    /**\n+     * if there are multiple entries for the same replica, e.g: core_node_1:12:A core_node_1:13:D\n+     * <p>\n+     * the entry with '13' is the latest and the one with '12' is considered a duplicate\n+     * <p>\n+     * These are unlikely, but possible\n+     */\n+    final State duplicate;\n+\n+    private State(String serialized, List<String> pieces) {\n+      this.asString = serialized;\n+      replica = pieces.get(0);\n+      version = Integer.parseInt(pieces.get(1));\n+      String encodedStatus = pieces.get(2);\n+      this.state = Replica.getState(encodedStatus);\n+      isLeader = pieces.size() > 3 && \"L\".equals(pieces.get(3));\n+      duplicate = null;\n+    }\n+\n+    public static State parse(String serialized) {\n+      List<String> pieces = StrUtils.splitSmart(serialized, ':');\n+      if (pieces.size() < 3) return null;\n+      return new State(serialized, pieces);\n+\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version) {\n+      this(replica, state, isLeader, version, null);\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version, State duplicate) {\n+      this.replica = replica;\n+      this.state = state == null ? Replica.State.ACTIVE : state;\n+      this.isLeader = isLeader == null ? Boolean.FALSE : isLeader;\n+      this.version = version;\n+      asString = serialize();\n+      this.duplicate = duplicate;\n+    }\n+\n+    @Override\n+    public void writeMap(EntryWriter ew) throws IOException {\n+      ew.put(NAME, replica);\n+      ew.put(VERSION, version);\n+      ew.put(ZkStateReader.STATE_PROP, state.toString());\n+      if (isLeader) ew.put(Slice.LEADER, isLeader);\n+      ew.putIfNotNull(\"duplicate\", duplicate);\n+    }\n+\n+    private State insert(State duplicate) {\n+      assert this.replica.equals(duplicate.replica);\n+      if (this.version >= duplicate.version) {\n+        if (this.duplicate != null) {\n+          duplicate = new State(duplicate.replica, duplicate.state, duplicate.isLeader, duplicate.version, this.duplicate);\n+        }\n+        return new State(this.replica, this.state, this.isLeader, this.version, duplicate);\n+      } else {\n+        return duplicate.insert(this);\n+      }\n+    }\n+\n+    /**\n+     * fetch duplicates entries for this replica\n+     */\n+    List<State> getDuplicates() {\n+      if (duplicate == null) return Collections.emptyList();\n+      List<State> result = new ArrayList<>();\n+      State current = duplicate;\n+      while (current != null) {\n+        result.add(current);\n+        current = current.duplicate;\n+      }\n+      return result;\n+    }\n+\n+    private String serialize() {\n+      StringBuilder sb = new StringBuilder(replica)\n+          .append(\":\")\n+          .append(version)\n+          .append(\":\")\n+          .append(state.shortName);\n+      if (isLeader) sb.append(\":\").append(\"L\");\n+      return sb.toString();\n+    }\n+\n+\n+    @Override\n+    public String toString() {\n+      return asString;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof State) {\n+        State that = (State) o;\n+        return Objects.equals(this.asString, that.asString);\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return asString.hashCode();\n+    }\n+  }\n+\n+\n+  public static abstract class WriteOps {\n+    private PerReplicaStates rs;\n+    List<Op> ops;\n+    private boolean preOp = true;\n+\n+    /**\n+     * state of a replica is changed\n+     *\n+     * @param newState the new state\n+     */\n+    public static WriteOps flipState(String replica, Replica.State newState, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> ops = new ArrayList<>(2);\n+          State existing = rs.get(replica);\n+          if (existing == null) {\n+            ops.add(new Op(Op.Type.ADD, new State(replica, newState, Boolean.FALSE, 0)));\n+          } else {\n+            ops.add(new Op(Op.Type.ADD, new State(replica, newState, existing.isLeader, existing.version + 1)));\n+            addDeleteStaleNodes(ops, existing);\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"flipState on {}, {} -> {}, ops :{}\", rs.path, replica, newState, ops);\n+          }\n+          return ops;\n+        }\n+      }.init(rs);\n+    }\n+\n+    public PerReplicaStates getPerReplicaStates() {\n+      return rs;\n+    }\n+\n+\n+    /**Switch a collection from/to perReplicaState=true\n+     */\n+    public static WriteOps modifyCollection(DocCollection coll, boolean enable, PerReplicaStates prs) {\n+      return new WriteOps() {\n+        @Override\n+        List<Op> refresh(PerReplicaStates prs) {\n+          return enable ? enable(coll) : disable(prs);\n+        }\n+\n+        List<Op> enable(DocCollection coll) {\n+          List<Op> result = new ArrayList<>();\n+          coll.forEachReplica((s, r) -> result.add(new Op(Op.Type.ADD, new State(r.getName(), r.getState(), r.isLeader(), 0))));\n+          return result;\n+        }\n+\n+        List<Op> disable(PerReplicaStates prs) {\n+          List<Op> result = new ArrayList<>();\n+          prs.states.forEachEntry((s, state) -> result.add(new Op(Op.Type.DELETE, state)));\n+          return result;\n+        }\n+      }.init(prs);\n+\n+    }\n+\n+    /**\n+     * Flip the leader replica to a new one\n+     *\n+     * @param allReplicas  allReplicas of the shard\n+     * @param next next leader\n+     */\n+    public static WriteOps flipLeader(Set<String> allReplicas, String next, PerReplicaStates rs) {\n+      return new WriteOps() {\n+\n+        @Override\n+        protected List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> ops = new ArrayList<>(4);", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMTEwOA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545401108", "bodyText": "javadoc", "author": "madrob", "createdAt": "2020-12-17T21:01:33Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  public PerReplicaStates(String path, int cversion, List<String> states) {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMTM4NQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545401385", "bodyText": "don't need to wrap as unmodifiable, we should trust our own code.", "author": "madrob", "createdAt": "2020-12-17T21:02:03Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    try {\n+      persist(ops.get(), znode, zkClient);\n+    } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+      //state is stale\n+      log.info(\"stale state for {} . retrying...\", znode);\n+      List<Op> freshOps = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      persist(freshOps, znode, zkClient);\n+      log.info(\"retried for stale state {}, succeeded\", znode);\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Op> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<org.apache.zookeeper.Op> ops = new ArrayList<>(operations.size());\n+    for (Op op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Op.Type.ADD ?\n+          org.apache.zookeeper.Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          org.apache.zookeeper.Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Fetch the latest {@link PerReplicaStates} . It fetches data after checking the {@link Stat#getCversion()} of state.json.\n+   * If this is not modified, the same object is returned\n+   */\n+  public static PerReplicaStates fetch(String path, SolrZkClient zkClient, PerReplicaStates current) {\n+    try {\n+      if (current != null) {\n+        Stat stat = zkClient.exists(current.path, null, true);\n+        if (stat == null) return new PerReplicaStates(path, -1, Collections.emptyList());\n+        if (current.cversion == stat.getCversion()) return current;// not modifiedZkStateReaderTest\n+      }\n+      Stat stat = new Stat();\n+      List<String> children = zkClient.getChildren(path, null, stat, true);\n+      return new PerReplicaStates(path, stat.getCversion(), Collections.unmodifiableList(children));", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMjI1MA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545402250", "bodyText": "This is bypassed overseer, not bypassed zookeeper, right? we're still storing that information in ZK but in a different place.", "author": "madrob", "createdAt": "2020-12-17T21:03:44Z", "path": "solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase.java", "diffHunk": "@@ -179,7 +183,16 @@ void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStartMs)\n           ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n       assert zkController != null;\n       assert zkController.getOverseer() != null;\n-      zkController.getOverseer().offerStateUpdate(Utils.toJSON(m));\n+      DocCollection coll = zkStateReader.getCollection(this.collection);\n+      if (coll == null || coll.getStateFormat() < 2 || ZkController.sendToOverseer(coll, id)) {\n+        zkController.getOverseer().offerStateUpdate(Utils.toJSON(m));\n+      } else {\n+        PerReplicaStates prs = PerReplicaStates.fetch(coll.getZNode(), zkClient, coll.getPerReplicaStates());\n+        PerReplicaStates.WriteOps writeOps = PerReplicaStates.WriteOps.flipLeader(zkStateReader.getClusterState().getCollection(collection).getSlice(shardId).getReplicaNames(), id, prs);\n+        //nocommit make this debug\n+        log.info(\"bypassed Zookeeper for leader election for {}/{}, old:{},new {} \", this.collection, shardId, currentLeader, id);", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0MjY5NQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547042695", "bodyText": "Yes, it's true. bypassed overseer, but not zookeeper\nit's a nocommit added for debugging.", "author": "noblepaul", "createdAt": "2020-12-22T03:10:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMjI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMjQ4MQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545402481", "bodyText": "This fetch/WriteOps.X/persist method flow seems very clunky to me, I've made a few comments on PerReplicaStates about how we could try to make it better. Another helpful change would be more descriptive naming of the variables instead of repeating the type name", "author": "madrob", "createdAt": "2020-12-17T21:04:12Z", "path": "solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase.java", "diffHunk": "@@ -179,7 +183,16 @@ void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStartMs)\n           ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n       assert zkController != null;\n       assert zkController.getOverseer() != null;\n-      zkController.getOverseer().offerStateUpdate(Utils.toJSON(m));\n+      DocCollection coll = zkStateReader.getCollection(this.collection);\n+      if (coll == null || coll.getStateFormat() < 2 || ZkController.sendToOverseer(coll, id)) {\n+        zkController.getOverseer().offerStateUpdate(Utils.toJSON(m));\n+      } else {\n+        PerReplicaStates prs = PerReplicaStates.fetch(coll.getZNode(), zkClient, coll.getPerReplicaStates());\n+        PerReplicaStates.WriteOps writeOps = PerReplicaStates.WriteOps.flipLeader(zkStateReader.getClusterState().getCollection(collection).getSlice(shardId).getReplicaNames(), id, prs);\n+        //nocommit make this debug\n+        log.info(\"bypassed Zookeeper for leader election for {}/{}, old:{},new {} \", this.collection, shardId, currentLeader, id);\n+        PerReplicaStates.persist(writeOps, coll.getZNode(), zkStateReader.getZkClient());", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMzgwNA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545403804", "bodyText": "why do we let forcePublish override us here? Won't this cause split state later?", "author": "madrob", "createdAt": "2020-12-17T21:06:39Z", "path": "solr/core/src/java/org/apache/solr/cloud/ZkController.java", "diffHunk": "@@ -1609,12 +1611,41 @@ public void publish(final CoreDescriptor cd, final Replica.State state, boolean\n       if (updateLastState) {\n         cd.getCloudDescriptor().setLastPublished(state);\n       }\n-      overseerJobQueue.offer(Utils.toJSON(m));\n+      DocCollection coll = zkStateReader.getCollection(collection);\n+      if (forcePublish || sendToOverseer(coll, coreNodeName)) {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1ODU5Mw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547058593", "bodyText": "\"split state\"\nWhat do you mean by that?", "author": "noblepaul", "createdAt": "2020-12-22T04:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMzgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0MjcwNQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547542705", "bodyText": "some aspects of state stored in the old place, some aspects stored in the new place. I'm still working on building a full mental model, so maybe this is a wrong question.", "author": "madrob", "createdAt": "2020-12-22T22:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQwMzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzODEzNw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r545438137", "bodyText": "Can we add a setting to the client to default whether it uses new state or not, and then that should simplify a lot of unit tests? our mini cluster can set it on the client for you?", "author": "madrob", "createdAt": "2020-12-17T22:14:23Z", "path": "solr/test-framework/src/java/org/apache/solr/cloud/SolrCloudTestCase.java", "diffHunk": "@@ -81,6 +81,7 @@\n public class SolrCloudTestCase extends SolrTestCaseJ4 {\n \n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final Boolean USE_PER_REPLICA_STATE = Boolean.parseBoolean(System.getProperty(\"use.per-replica\", \"false\"));", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA1ODc4MA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547058780", "bodyText": "Yeah we need to find a simpler way to do this.\nBut the client cannot be modified", "author": "noblepaul", "createdAt": "2020-12-22T04:17:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzODEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzU0MjQ3OQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547542479", "bodyText": "Can it be a setting in cluster properties that controls how new collections are created?", "author": "madrob", "createdAt": "2020-12-22T22:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzODEzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg5MDQxOA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547890418", "bodyText": "There's a defaults section in our unofficial kitchen-sink ZK config file, i.e. /clusterprops.json.", "author": "sigram", "createdAt": "2020-12-23T10:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzODEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI3NzQ3NQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r546277475", "bodyText": "Isn't reading the state.json znode Stat sufficient?\nIf it is not and this can't be simplified, then doesn't it break the logic used elsewhere of comparing the stored cversion to the actual znode cversion to decide if the children should be read again?", "author": "murblanc", "createdAt": "2020-12-19T20:06:19Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    try {\n+      persist(ops.get(), znode, zkClient);\n+    } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+      //state is stale\n+      log.info(\"stale state for {} . retrying...\", znode);\n+      List<Op> freshOps = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      persist(freshOps, znode, zkClient);\n+      log.info(\"retried for stale state {}, succeeded\", znode);\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Op> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<org.apache.zookeeper.Op> ops = new ArrayList<>(operations.size());\n+    for (Op op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Op.Type.ADD ?\n+          org.apache.zookeeper.Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          org.apache.zookeeper.Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Fetch the latest {@link PerReplicaStates} . It fetches data after checking the {@link Stat#getCversion()} of state.json.\n+   * If this is not modified, the same object is returned\n+   */\n+  public static PerReplicaStates fetch(String path, SolrZkClient zkClient, PerReplicaStates current) {\n+    try {\n+      if (current != null) {\n+        Stat stat = zkClient.exists(current.path, null, true);\n+        if (stat == null) return new PerReplicaStates(path, -1, Collections.emptyList());\n+        if (current.cversion == stat.getCversion()) return current;// not modifiedZkStateReaderTest\n+      }\n+      Stat stat = new Stat();\n+      List<String> children = zkClient.getChildren(path, null, stat, true);\n+      return new PerReplicaStates(path, stat.getCversion(), Collections.unmodifiableList(children));\n+    } catch (KeeperException e) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error fetching per-replica states\", e);\n+    } catch (InterruptedException e) {\n+      SolrZkClient.checkInterrupted(e);\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted when loading per-replica states from \" + path, e);\n+    }\n+  }\n+\n+\n+  private static List<Op> addDeleteStaleNodes(List<Op> ops, State rs) {\n+    while (rs != null) {\n+      ops.add(new Op(Op.Type.DELETE, rs));\n+      rs = rs.duplicate;\n+    }\n+    return ops;\n+  }\n+\n+  public static String getReplicaName(String s) {\n+    int idx = s.indexOf(SEPARATOR);\n+    if (idx > 0) {\n+      return s.substring(0, idx);\n+    }\n+    return null;\n+  }\n+\n+  public State get(String replica) {\n+    return states.get(replica);\n+  }\n+\n+  public static class Op {\n+    public final Type typ;\n+    public final State state;\n+\n+    public Op(Type typ, State replicaState) {\n+      this.typ = typ;\n+      this.state = replicaState;\n+    }\n+\n+\n+    public enum Type {\n+      //add a new node\n+      ADD,\n+      //delete an existing node\n+      DELETE\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return typ.toString() + \" : \" + state;\n+    }\n+  }\n+\n+\n+  /**\n+   * The state of a replica as stored as a node under /collections/collection-name/state.json/replica-state\n+   */\n+  public static class State implements MapWriter {\n+\n+    public final String replica;\n+\n+    public final Replica.State state;\n+\n+    public final Boolean isLeader;\n+\n+    public final int version;\n+\n+    public final String asString;\n+\n+    /**\n+     * if there are multiple entries for the same replica, e.g: core_node_1:12:A core_node_1:13:D\n+     * <p>\n+     * the entry with '13' is the latest and the one with '12' is considered a duplicate\n+     * <p>\n+     * These are unlikely, but possible\n+     */\n+    final State duplicate;\n+\n+    private State(String serialized, List<String> pieces) {\n+      this.asString = serialized;\n+      replica = pieces.get(0);\n+      version = Integer.parseInt(pieces.get(1));\n+      String encodedStatus = pieces.get(2);\n+      this.state = Replica.getState(encodedStatus);\n+      isLeader = pieces.size() > 3 && \"L\".equals(pieces.get(3));\n+      duplicate = null;\n+    }\n+\n+    public static State parse(String serialized) {\n+      List<String> pieces = StrUtils.splitSmart(serialized, ':');\n+      if (pieces.size() < 3) return null;\n+      return new State(serialized, pieces);\n+\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version) {\n+      this(replica, state, isLeader, version, null);\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version, State duplicate) {\n+      this.replica = replica;\n+      this.state = state == null ? Replica.State.ACTIVE : state;\n+      this.isLeader = isLeader == null ? Boolean.FALSE : isLeader;\n+      this.version = version;\n+      asString = serialize();\n+      this.duplicate = duplicate;\n+    }\n+\n+    @Override\n+    public void writeMap(EntryWriter ew) throws IOException {\n+      ew.put(NAME, replica);\n+      ew.put(VERSION, version);\n+      ew.put(ZkStateReader.STATE_PROP, state.toString());\n+      if (isLeader) ew.put(Slice.LEADER, isLeader);\n+      ew.putIfNotNull(\"duplicate\", duplicate);\n+    }\n+\n+    private State insert(State duplicate) {\n+      assert this.replica.equals(duplicate.replica);\n+      if (this.version >= duplicate.version) {\n+        if (this.duplicate != null) {\n+          duplicate = new State(duplicate.replica, duplicate.state, duplicate.isLeader, duplicate.version, this.duplicate);\n+        }\n+        return new State(this.replica, this.state, this.isLeader, this.version, duplicate);\n+      } else {\n+        return duplicate.insert(this);\n+      }\n+    }\n+\n+    /**\n+     * fetch duplicates entries for this replica\n+     */\n+    List<State> getDuplicates() {\n+      if (duplicate == null) return Collections.emptyList();\n+      List<State> result = new ArrayList<>();\n+      State current = duplicate;\n+      while (current != null) {\n+        result.add(current);\n+        current = current.duplicate;\n+      }\n+      return result;\n+    }\n+\n+    private String serialize() {\n+      StringBuilder sb = new StringBuilder(replica)\n+          .append(\":\")\n+          .append(version)\n+          .append(\":\")\n+          .append(state.shortName);\n+      if (isLeader) sb.append(\":\").append(\"L\");\n+      return sb.toString();\n+    }\n+\n+\n+    @Override\n+    public String toString() {\n+      return asString;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof State) {\n+        State that = (State) o;\n+        return Objects.equals(this.asString, that.asString);\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return asString.hashCode();\n+    }\n+  }\n+\n+\n+  public static abstract class WriteOps {\n+    private PerReplicaStates rs;\n+    List<Op> ops;\n+    private boolean preOp = true;\n+\n+    /**\n+     * state of a replica is changed\n+     *\n+     * @param newState the new state\n+     */\n+    public static WriteOps flipState(String replica, Replica.State newState, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> ops = new ArrayList<>(2);\n+          State existing = rs.get(replica);\n+          if (existing == null) {\n+            ops.add(new Op(Op.Type.ADD, new State(replica, newState, Boolean.FALSE, 0)));\n+          } else {\n+            ops.add(new Op(Op.Type.ADD, new State(replica, newState, existing.isLeader, existing.version + 1)));\n+            addDeleteStaleNodes(ops, existing);\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"flipState on {}, {} -> {}, ops :{}\", rs.path, replica, newState, ops);\n+          }\n+          return ops;\n+        }\n+      }.init(rs);\n+    }\n+\n+    public PerReplicaStates getPerReplicaStates() {\n+      return rs;\n+    }\n+\n+\n+    /**Switch a collection from/to perReplicaState=true\n+     */\n+    public static WriteOps modifyCollection(DocCollection coll, boolean enable, PerReplicaStates prs) {\n+      return new WriteOps() {\n+        @Override\n+        List<Op> refresh(PerReplicaStates prs) {\n+          return enable ? enable(coll) : disable(prs);\n+        }\n+\n+        List<Op> enable(DocCollection coll) {\n+          List<Op> result = new ArrayList<>();\n+          coll.forEachReplica((s, r) -> result.add(new Op(Op.Type.ADD, new State(r.getName(), r.getState(), r.isLeader(), 0))));\n+          return result;\n+        }\n+\n+        List<Op> disable(PerReplicaStates prs) {\n+          List<Op> result = new ArrayList<>();\n+          prs.states.forEachEntry((s, state) -> result.add(new Op(Op.Type.DELETE, state)));\n+          return result;\n+        }\n+      }.init(prs);\n+\n+    }\n+\n+    /**\n+     * Flip the leader replica to a new one\n+     *\n+     * @param allReplicas  allReplicas of the shard\n+     * @param next next leader\n+     */\n+    public static WriteOps flipLeader(Set<String> allReplicas, String next, PerReplicaStates rs) {\n+      return new WriteOps() {\n+\n+        @Override\n+        protected List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> ops = new ArrayList<>(4);\n+          if (next != null) {\n+            State st = rs.get(next);\n+            if (st != null) {\n+              if (!st.isLeader) {\n+                ops.add(new Op(Op.Type.ADD, new State(st.replica, Replica.State.ACTIVE, Boolean.TRUE, st.version + 1)));\n+                ops.add(new Op(Op.Type.DELETE, st));\n+              }\n+              //else do not do anything , that node is the leader\n+            } else {\n+              //there is no entry for the new leader.\n+              //create one\n+              ops.add(new Op(Op.Type.ADD, new State(next, Replica.State.ACTIVE, Boolean.TRUE, 0)));\n+            }\n+          }\n+\n+          //now go through all other replicas and unset previous leader\n+          for (String r : allReplicas) {\n+            State st = rs.get(r);\n+            if (st == null) continue;//unlikely\n+            if (!Objects.equals(r, next)) {\n+              if (st.isLeader) {\n+                //some other replica is the leader now. unset\n+                ops.add(new Op(Op.Type.ADD, new State(st.replica, st.state, Boolean.FALSE, st.version + 1)));\n+                ops.add(new Op(Op.Type.DELETE, st));\n+              }\n+            }\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"flipLeader on:{}, {} -> {}, ops: {}\", rs.path, allReplicas, next, ops);\n+          }\n+          return ops;\n+        }\n+\n+      }.init(rs);\n+    }\n+\n+    /**\n+     * Delete a replica entry from per-replica states\n+     *\n+     * @param replica name of the replica to be deleted\n+     */\n+    public static WriteOps deleteReplica(String replica, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> result;\n+          if (rs == null) {\n+            result = Collections.emptyList();\n+          } else {\n+            State state = rs.get(replica);\n+            result = addDeleteStaleNodes(new ArrayList<>(), state);\n+          }\n+          return result;\n+        }\n+      }.init(rs);\n+    }\n+\n+    public static WriteOps addReplica(String replica, Replica.State state, boolean isLeader, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Op> refresh(PerReplicaStates rs) {\n+          return singletonList(new Op(Op.Type.ADD,\n+              new State(replica, state, isLeader, 0)));\n+        }\n+      }.init(rs);\n+    }\n+\n+    /**\n+     * mark a bunch of replicas as DOWN\n+     */\n+    public static WriteOps downReplicas(List<String> replicas, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        List<Op> refresh(PerReplicaStates rs) {\n+          List<Op> ops = new ArrayList<>();\n+          for (String replica : replicas) {\n+            State r = rs.get(replica);\n+            if (r != null) {\n+              if (r.state == Replica.State.DOWN && !r.isLeader) continue;\n+              ops.add(new Op(Op.Type.ADD, new State(replica, Replica.State.DOWN, Boolean.FALSE, r.version + 1)));\n+              addDeleteStaleNodes(ops, r);\n+            } else {\n+              ops.add(new Op(Op.Type.ADD, new State(replica, Replica.State.DOWN, Boolean.FALSE, 0)));\n+            }\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"for coll: {} down replicas {}, ops {}\", rs, replicas, ops);\n+          }\n+          return ops;\n+        }\n+      }.init(rs);\n+    }\n+\n+    /**\n+     * Just creates and deletes a summy entry so that the {@link Stat#getCversion()} of states.json\n+     * is updated\n+     */\n+    public static WriteOps touchChildren() {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0NDM1Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547044357", "bodyText": "I'll explore that", "author": "noblepaul", "createdAt": "2020-12-22T03:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI3NzQ3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2MTIxNA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552361214", "bodyText": "This is a rare and we always ensure that if cversion is same the content is same", "author": "noblepaul", "createdAt": "2021-01-06T04:23:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI3NzQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI3NzYyMA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r546277620", "bodyText": "The two return statements above end up doing exactly the same thing.", "author": "murblanc", "createdAt": "2020-12-19T20:07:40Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java", "diffHunk": "@@ -136,8 +154,13 @@ public ZkWriteCommand modifyCollection(final ClusterState clusterState, ZkNodePr\n       return ZkStateWriter.NO_OP;\n     }\n \n-    return new ZkWriteCommand(coll.getName(),\n-        new DocCollection(coll.getName(), coll.getSlicesMap(), m, coll.getRouter(), coll.getZNodeVersion(), coll.getZNode()));\n+    DocCollection collection = new DocCollection(coll.getName(), coll.getSlicesMap(), m, coll.getRouter(), coll.getZNodeVersion(), coll.getZNode());\n+    if (replicaOps == null){\n+      return new ZkWriteCommand(coll.getName(), collection);\n+    } else {\n+      return new ZkWriteCommand(coll.getName(), collection, replicaOps, true);\n+    }", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzA0MzMxOQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547043319", "bodyText": "how so?", "author": "noblepaul", "createdAt": "2020-12-22T03:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI3NzYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzIzNjA2OQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547236069", "bodyText": "My bad, the two are different.\nWhen replicaOps is null, ops in ZkWriteCommand is set to PerReplicaStates.WriteOps.touchChildren().\nWhen replicaOps is not null, ops in ZkWriteCommand is set to replicaOps.", "author": "murblanc", "createdAt": "2020-12-22T11:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI3NzYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg4NzE0OQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r547887149", "bodyText": "This unit test is misplaced, it has nothing to do with this suite. It should be moved to ZkSolrClientTest.", "author": "sigram", "createdAt": "2020-12-23T10:25:30Z", "path": "solr/core/src/test/org/apache/solr/handler/TestContainerPlugin.java", "diffHunk": "@@ -73,6 +79,29 @@ public void teardown() {\n     System.clearProperty(\"enable.packages\");\n   }\n \n+  public void testZkBehavior() throws Exception {", "originalCommit": "bf9aee07386f2617a793ce0853e8709d547d31ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTMyOTQ5Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r549329497", "bodyText": "true", "author": "noblepaul", "createdAt": "2020-12-28T12:24:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzg4NzE0OQ=="}], "type": "inlineReview"}, {"oid": "e63d8741bf603a78689dc4f8967261acc6b9a94d", "url": "https://github.com/apache/lucene-solr/commit/e63d8741bf603a78689dc4f8967261acc6b9a94d", "message": "review comments incorporated", "committedDate": "2020-12-28T13:39:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUwMjUxNg==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r549502516", "bodyText": "Nit: first two checks are run in sendToOverseer, are you checking here to avoid opening a new stackframe?", "author": "megancarey", "createdAt": "2020-12-28T22:11:24Z", "path": "solr/core/src/java/org/apache/solr/cloud/ShardLeaderElectionContextBase.java", "diffHunk": "@@ -179,17 +181,19 @@ void runLeaderProcess(boolean weAreReplacement, int pauseBeforeStartMs)\n           ZkStateReader.STATE_PROP, Replica.State.ACTIVE.toString());\n       assert zkController != null;\n       assert zkController.getOverseer() != null;\n-      zkController.getOverseer().offerStateUpdate(Utils.toJSON(m));\n+      DocCollection coll = zkStateReader.getCollection(this.collection);\n+      if (coll == null || coll.getStateFormat() < 2 || ZkController.sendToOverseer(coll, id)) {", "originalCommit": "e63d8741bf603a78689dc4f8967261acc6b9a94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0MTY2OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r549541668", "bodyText": "yeah, early termination", "author": "noblepaul", "createdAt": "2020-12-29T02:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUwMjUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUwNjQ2NQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r549506465", "bodyText": "Nit: move special prop case below line 136 (previously L118), where other such props are handled", "author": "megancarey", "createdAt": "2020-12-28T22:30:46Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java", "diffHunk": "@@ -107,7 +111,21 @@ public ZkWriteCommand modifyCollection(final ClusterState clusterState, ZkNodePr\n     DocCollection coll = clusterState.getCollection(message.getStr(COLLECTION_PROP));\n     Map<String, Object> m = coll.shallowCopy();\n     boolean hasAnyOps = false;\n+    PerReplicaStates.WriteOps replicaOps = null;\n     for (String prop : CollectionAdminRequest.MODIFIABLE_COLLECTION_PROPERTIES) {\n+      if (prop.equals(DocCollection.PER_REPLICA_STATE)) {", "originalCommit": "e63d8741bf603a78689dc4f8967261acc6b9a94d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNjU3Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r549516577", "bodyText": "Supernit: newLeader =", "author": "megancarey", "createdAt": "2020-12-28T23:24:32Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/SliceMutator.java", "diffHunk": "@@ -132,7 +160,7 @@ public ZkWriteCommand setShardLeader(ClusterState clusterState, ZkNodeProps mess\n       if (replica == oldLeader && !coreURL.equals(leaderUrl)) {\n         replica = new ReplicaMutator(cloudManager).unsetLeader(replica);\n       } else if (coreURL.equals(leaderUrl)) {\n-        replica = new ReplicaMutator(cloudManager).setLeader(replica);\n+        newLeader= replica = new ReplicaMutator(cloudManager).setLeader(replica);", "originalCommit": "e63d8741bf603a78689dc4f8967261acc6b9a94d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTc2NQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r549519765", "bodyText": "Nit: I'd prefer Boolean.parseBoolean(String.valueOf(objs.get(DocCollection.PER_REPLICA_STATE)))", "author": "megancarey", "createdAt": "2020-12-28T23:43:22Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ClusterState.java", "diffHunk": "@@ -256,6 +263,12 @@ private static DocCollection collectionFromObjects(String name, Map<String, Obje\n     Map<String,Object> props;\n     Map<String,Slice> slices;\n \n+    if (\"true\".equals(String.valueOf(objs.get(DocCollection.PER_REPLICA_STATE)))) {", "originalCommit": "e63d8741bf603a78689dc4f8967261acc6b9a94d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMjk2NA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r549522964", "bodyText": "What is the value of having upper case here if we translate to lower case elsewhere?", "author": "megancarey", "createdAt": "2020-12-29T00:02:41Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/Replica.java", "diffHunk": "@@ -70,16 +75,24 @@\n      * cluster and it's state should be discarded.\n      * </p>\n      */\n-    RECOVERY_FAILED;\n-    \n+    RECOVERY_FAILED(\"F\");\n+\n+    /**short name for a state. Used to encode this in the state node see {@link PerReplicaStates.State}\n+     */\n+    public final String shortName;\n+\n+    State(String c) {\n+      this.shortName = c;\n+    }\n+\n     @Override\n     public String toString() {\n       return super.toString().toLowerCase(Locale.ROOT);", "originalCommit": "e63d8741bf603a78689dc4f8967261acc6b9a94d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzOTU3Ng==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r549539576", "bodyText": "The shortname is not the same as name.", "author": "noblepaul", "createdAt": "2020-12-29T01:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMjk2NA=="}], "type": "inlineReview"}, {"oid": "4c4d0ff2e1d30f688e2c33ca60caae43264e52fb", "url": "https://github.com/apache/lucene-solr/commit/4c4d0ff2e1d30f688e2c33ca60caae43264e52fb", "message": "Apply suggestions from code review\n\nCo-authored-by: John Bampton <jbampton@users.noreply.github.com>", "committedDate": "2020-12-29T01:58:28Z", "type": "commit"}, {"oid": "6132a36d312665b183f7f9504c14e8a69243392d", "url": "https://github.com/apache/lucene-solr/commit/6132a36d312665b183f7f9504c14e8a69243392d", "message": "review comments incorporated", "committedDate": "2020-12-29T02:20:31Z", "type": "commit"}, {"oid": "672e41ebb5eb25a003100d4494433d30e6933acc", "url": "https://github.com/apache/lucene-solr/commit/672e41ebb5eb25a003100d4494433d30e6933acc", "message": "removed nocommits", "committedDate": "2020-12-29T04:14:59Z", "type": "commit"}, {"oid": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "url": "https://github.com/apache/lucene-solr/commit/29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "message": "added CHANGES.txt entry", "committedDate": "2021-01-04T06:22:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyMzIwNw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r551623207", "bodyText": "Can add this case to the group of two just above since they do the same thing already.", "author": "murblanc", "createdAt": "2021-01-04T23:12:15Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection.java", "diffHunk": "@@ -165,6 +205,8 @@ public static Object verifyProp(Map<String, Object> props, String propName, Obje\n       case AUTO_ADD_REPLICAS:\n       case READ_ONLY:\n         return Boolean.parseBoolean(o.toString());\n+      case PER_REPLICA_STATE:", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyMzczNQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r551623735", "bodyText": "Body of method can be replaced by:\nreturn (dataVersion > znodeVersion) || (childVersion > getChildNodesVersion());", "author": "murblanc", "createdAt": "2021-01-04T23:13:47Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection.java", "diffHunk": "@@ -253,6 +297,16 @@ public void forEachReplica(BiConsumer<String, Replica> consumer) {\n   public int getZNodeVersion(){\n     return znodeVersion;\n   }\n+  public int getChildNodesVersion() {\n+    return perReplicaStates == null ? -1 : perReplicaStates.cversion;\n+  }\n+\n+  public boolean isModified(int dataVersion, int childVersion) {\n+    if (dataVersion > znodeVersion) return true;", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyNTk1MA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r551625950", "bodyText": "Do we want to add a space after the znodeVersion in the output if perReplicaStates is non null?", "author": "murblanc", "createdAt": "2021-01-04T23:20:06Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/DocCollection.java", "diffHunk": "@@ -292,7 +346,9 @@ public boolean isReadOnly() {\n \n   @Override\n   public String toString() {\n-    return \"DocCollection(\"+name+\"/\" + znode + \"/\" + znodeVersion + \")=\" + toJSONString(this);\n+    return \"DocCollection(\"+name+\"/\" + znode + \"/\" + znodeVersion\n+        + (perReplicaStates == null ? \"\": perReplicaStates.toString())+\")=\"", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzMTM0MA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r551631340", "bodyText": "Some of the code in this method duplicates code from refreshAndWatch from where it is called. Is there a way to refactor so that code common to both only appears once?", "author": "murblanc", "createdAt": "2021-01-04T23:35:58Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java", "diffHunk": "@@ -1365,6 +1382,32 @@ public void refreshAndWatch() {\n         log.error(\"Unwatched collection: [{}]\", coll, e);\n       }\n     }\n+\n+    private void refreshAndWatchChildren() throws KeeperException, InterruptedException {", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzMzMwMg==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r551633302", "bodyText": "Please do not initialize newState to null and instead mark it final so compiler enforces it being assigned. (same for replicaStates above)", "author": "murblanc", "createdAt": "2021-01-04T23:38:21Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader.java", "diffHunk": "@@ -1365,6 +1382,32 @@ public void refreshAndWatch() {\n         log.error(\"Unwatched collection: [{}]\", coll, e);\n       }\n     }\n+\n+    private void refreshAndWatchChildren() throws KeeperException, InterruptedException {\n+      Stat stat = new Stat();\n+      List<String> replicaStates = null;\n+      try {\n+        replicaStates = zkClient.getChildren(collectionPath, this, stat, true);\n+        PerReplicaStates newStates = new PerReplicaStates(collectionPath, stat.getCversion(), replicaStates);\n+        DocCollection oldState = watchedCollectionStates.get(coll);\n+        DocCollection newState = null;", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2MzIxOA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552063218", "bodyText": "nit: one of these indentations is inconsistent.", "author": "madrob", "createdAt": "2021-01-05T16:59:07Z", "path": "solr/core/src/java/org/apache/solr/cloud/overseer/CollectionMutator.java", "diffHunk": "@@ -107,10 +111,24 @@ public ZkWriteCommand modifyCollection(final ClusterState clusterState, ZkNodePr\n     DocCollection coll = clusterState.getCollection(message.getStr(COLLECTION_PROP));\n     Map<String, Object> m = coll.shallowCopy();\n     boolean hasAnyOps = false;\n+    PerReplicaStates.WriteOps replicaOps = null;\n     for (String prop : CollectionAdminRequest.MODIFIABLE_COLLECTION_PROPERTIES) {\n+      if (prop.equals(DocCollection.PER_REPLICA_STATE)) {\n+         String val = message.getStr(DocCollection.PER_REPLICA_STATE);\n+         if (val == null) continue;\n+        boolean enable = Boolean.parseBoolean(val);", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5MzU3Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552093577", "bodyText": "This feels weird that enable takes the collection but disable takes the PRS.", "author": "madrob", "createdAt": "2021-01-05T17:50:45Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  /**\n+   * Construct with data read from ZK\n+   * @param path path from where this is loaded\n+   * @param cversion the current child version of the znode\n+   * @param states the per-replica states (the list of all child nodes)\n+   */\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    List<Operation> operations = ops.get();\n+    for (int i = 0; i < 10; i++) {\n+      try {\n+        persist(operations, znode, zkClient);\n+        return;\n+      } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+        //state is stale\n+        log.info(\"stale state for {}. retrying...\", znode);\n+        operations = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Operation> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<Op> ops = new ArrayList<>(operations.size());\n+    for (Operation op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Operation.Type.ADD ?\n+          Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Fetch the latest {@link PerReplicaStates} . It fetches data after checking the {@link Stat#getCversion()} of state.json.\n+   * If this is not modified, the same object is returned\n+   */\n+  public static PerReplicaStates fetch(String path, SolrZkClient zkClient, PerReplicaStates current) {\n+    try {\n+      if (current != null) {\n+        Stat stat = zkClient.exists(current.path, null, true);\n+        if (stat == null) return new PerReplicaStates(path, -1, Collections.emptyList());\n+        if (current.cversion == stat.getCversion()) return current;// not modifiedZkStateReaderTest\n+      }\n+      Stat stat = new Stat();\n+      List<String> children = zkClient.getChildren(path, null, stat, true);\n+      return new PerReplicaStates(path, stat.getCversion(), Collections.unmodifiableList(children));\n+    } catch (KeeperException e) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error fetching per-replica states\", e);\n+    } catch (InterruptedException e) {\n+      SolrZkClient.checkInterrupted(e);\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted when loading per-replica states from \" + path, e);\n+    }\n+  }\n+\n+\n+  private static List<Operation> addDeleteStaleNodes(List<Operation> ops, State rs) {\n+    while (rs != null) {\n+      ops.add(new Operation(Operation.Type.DELETE, rs));\n+      rs = rs.duplicate;\n+    }\n+    return ops;\n+  }\n+\n+  public static String getReplicaName(String s) {\n+    int idx = s.indexOf(SEPARATOR);\n+    if (idx > 0) {\n+      return s.substring(0, idx);\n+    }\n+    return null;\n+  }\n+\n+  public State get(String replica) {\n+    return states.get(replica);\n+  }\n+\n+  public static class Operation {\n+    public final Type typ;\n+    public final State state;\n+\n+    public Operation(Type typ, State replicaState) {\n+      this.typ = typ;\n+      this.state = replicaState;\n+    }\n+\n+\n+    public enum Type {\n+      //add a new node\n+      ADD,\n+      //delete an existing node\n+      DELETE\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return typ.toString() + \" : \" + state;\n+    }\n+  }\n+\n+\n+  /**\n+   * The state of a replica as stored as a node under /collections/collection-name/state.json/replica-state\n+   */\n+  public static class State implements MapWriter {\n+\n+    public final String replica;\n+\n+    public final Replica.State state;\n+\n+    public final Boolean isLeader;\n+\n+    public final int version;\n+\n+    public final String asString;\n+\n+    /**\n+     * if there are multiple entries for the same replica, e.g: core_node_1:12:A core_node_1:13:D\n+     * <p>\n+     * the entry with '13' is the latest and the one with '12' is considered a duplicate\n+     * <p>\n+     * These are unlikely, but possible\n+     */\n+    final State duplicate;\n+\n+    private State(String serialized, List<String> pieces) {\n+      this.asString = serialized;\n+      replica = pieces.get(0);\n+      version = Integer.parseInt(pieces.get(1));\n+      String encodedStatus = pieces.get(2);\n+      this.state = Replica.getState(encodedStatus);\n+      isLeader = pieces.size() > 3 && \"L\".equals(pieces.get(3));\n+      duplicate = null;\n+    }\n+\n+    public static State parse(String serialized) {\n+      List<String> pieces = StrUtils.splitSmart(serialized, ':');\n+      if (pieces.size() < 3) return null;\n+      return new State(serialized, pieces);\n+\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version) {\n+      this(replica, state, isLeader, version, null);\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version, State duplicate) {\n+      this.replica = replica;\n+      this.state = state == null ? Replica.State.ACTIVE : state;\n+      this.isLeader = isLeader == null ? Boolean.FALSE : isLeader;\n+      this.version = version;\n+      asString = serialize();\n+      this.duplicate = duplicate;\n+    }\n+\n+    @Override\n+    public void writeMap(EntryWriter ew) throws IOException {\n+      ew.put(NAME, replica);\n+      ew.put(VERSION, version);\n+      ew.put(ZkStateReader.STATE_PROP, state.toString());\n+      if (isLeader) ew.put(Slice.LEADER, isLeader);\n+      ew.putIfNotNull(\"duplicate\", duplicate);\n+    }\n+\n+    private State insert(State duplicate) {\n+      assert this.replica.equals(duplicate.replica);\n+      if (this.version >= duplicate.version) {\n+        if (this.duplicate != null) {\n+          duplicate = new State(duplicate.replica, duplicate.state, duplicate.isLeader, duplicate.version, this.duplicate);\n+        }\n+        return new State(this.replica, this.state, this.isLeader, this.version, duplicate);\n+      } else {\n+        return duplicate.insert(this);\n+      }\n+    }\n+\n+    /**\n+     * fetch duplicates entries for this replica\n+     */\n+    List<State> getDuplicates() {\n+      if (duplicate == null) return Collections.emptyList();\n+      List<State> result = new ArrayList<>();\n+      State current = duplicate;\n+      while (current != null) {\n+        result.add(current);\n+        current = current.duplicate;\n+      }\n+      return result;\n+    }\n+\n+    private String serialize() {\n+      StringBuilder sb = new StringBuilder(replica)\n+          .append(\":\")\n+          .append(version)\n+          .append(\":\")\n+          .append(state.shortName);\n+      if (isLeader) sb.append(\":\").append(\"L\");\n+      return sb.toString();\n+    }\n+\n+\n+    @Override\n+    public String toString() {\n+      return asString;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof State) {\n+        State that = (State) o;\n+        return Objects.equals(this.asString, that.asString);\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return asString.hashCode();\n+    }\n+  }\n+\n+\n+  /**This is a helper class that encapsulates various operations performed on the per-replica states\n+   * Do not directly manipulate the per replica states as it can become difficult to debug them\n+   *\n+   */\n+  public static abstract class WriteOps {\n+    private PerReplicaStates rs;\n+    List<Operation> ops;\n+    private boolean preOp = true;\n+\n+    /**\n+     * state of a replica is changed\n+     *\n+     * @param newState the new state\n+     */\n+    public static WriteOps flipState(String replica, Replica.State newState, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Operation> refresh(PerReplicaStates rs) {\n+          List<Operation> ops = new ArrayList<>(2);\n+          State existing = rs.get(replica);\n+          if (existing == null) {\n+            ops.add(new Operation(Operation.Type.ADD, new State(replica, newState, Boolean.FALSE, 0)));\n+          } else {\n+            ops.add(new Operation(Operation.Type.ADD, new State(replica, newState, existing.isLeader, existing.version + 1)));\n+            addDeleteStaleNodes(ops, existing);\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"flipState on {}, {} -> {}, ops :{}\", rs.path, replica, newState, ops);\n+          }\n+          return ops;\n+        }\n+      }.init(rs);\n+    }\n+\n+    public PerReplicaStates getPerReplicaStates() {\n+      return rs;\n+    }\n+\n+\n+    /**Switch a collection from/to perReplicaState=true\n+     */\n+    public static WriteOps modifyCollection(DocCollection coll, boolean enable, PerReplicaStates prs) {\n+      return new WriteOps() {\n+        @Override\n+        List<Operation> refresh(PerReplicaStates prs) {\n+          return enable ? enable(coll) : disable(prs);", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM2MjM4Ng==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552362386", "bodyText": "yeah , disable just blindly deletes everything", "author": "noblepaul", "createdAt": "2021-01-06T04:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5MzU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5Mzc4Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552093787", "bodyText": "Is this sufficient? We don't need to copy the state to anywhere in the overseer?", "author": "madrob", "createdAt": "2021-01-05T17:51:08Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  /**\n+   * Construct with data read from ZK\n+   * @param path path from where this is loaded\n+   * @param cversion the current child version of the znode\n+   * @param states the per-replica states (the list of all child nodes)\n+   */\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    List<Operation> operations = ops.get();\n+    for (int i = 0; i < 10; i++) {\n+      try {\n+        persist(operations, znode, zkClient);\n+        return;\n+      } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+        //state is stale\n+        log.info(\"stale state for {}. retrying...\", znode);\n+        operations = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Operation> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<Op> ops = new ArrayList<>(operations.size());\n+    for (Operation op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Operation.Type.ADD ?\n+          Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Fetch the latest {@link PerReplicaStates} . It fetches data after checking the {@link Stat#getCversion()} of state.json.\n+   * If this is not modified, the same object is returned\n+   */\n+  public static PerReplicaStates fetch(String path, SolrZkClient zkClient, PerReplicaStates current) {\n+    try {\n+      if (current != null) {\n+        Stat stat = zkClient.exists(current.path, null, true);\n+        if (stat == null) return new PerReplicaStates(path, -1, Collections.emptyList());\n+        if (current.cversion == stat.getCversion()) return current;// not modifiedZkStateReaderTest\n+      }\n+      Stat stat = new Stat();\n+      List<String> children = zkClient.getChildren(path, null, stat, true);\n+      return new PerReplicaStates(path, stat.getCversion(), Collections.unmodifiableList(children));\n+    } catch (KeeperException e) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error fetching per-replica states\", e);\n+    } catch (InterruptedException e) {\n+      SolrZkClient.checkInterrupted(e);\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted when loading per-replica states from \" + path, e);\n+    }\n+  }\n+\n+\n+  private static List<Operation> addDeleteStaleNodes(List<Operation> ops, State rs) {\n+    while (rs != null) {\n+      ops.add(new Operation(Operation.Type.DELETE, rs));\n+      rs = rs.duplicate;\n+    }\n+    return ops;\n+  }\n+\n+  public static String getReplicaName(String s) {\n+    int idx = s.indexOf(SEPARATOR);\n+    if (idx > 0) {\n+      return s.substring(0, idx);\n+    }\n+    return null;\n+  }\n+\n+  public State get(String replica) {\n+    return states.get(replica);\n+  }\n+\n+  public static class Operation {\n+    public final Type typ;\n+    public final State state;\n+\n+    public Operation(Type typ, State replicaState) {\n+      this.typ = typ;\n+      this.state = replicaState;\n+    }\n+\n+\n+    public enum Type {\n+      //add a new node\n+      ADD,\n+      //delete an existing node\n+      DELETE\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return typ.toString() + \" : \" + state;\n+    }\n+  }\n+\n+\n+  /**\n+   * The state of a replica as stored as a node under /collections/collection-name/state.json/replica-state\n+   */\n+  public static class State implements MapWriter {\n+\n+    public final String replica;\n+\n+    public final Replica.State state;\n+\n+    public final Boolean isLeader;\n+\n+    public final int version;\n+\n+    public final String asString;\n+\n+    /**\n+     * if there are multiple entries for the same replica, e.g: core_node_1:12:A core_node_1:13:D\n+     * <p>\n+     * the entry with '13' is the latest and the one with '12' is considered a duplicate\n+     * <p>\n+     * These are unlikely, but possible\n+     */\n+    final State duplicate;\n+\n+    private State(String serialized, List<String> pieces) {\n+      this.asString = serialized;\n+      replica = pieces.get(0);\n+      version = Integer.parseInt(pieces.get(1));\n+      String encodedStatus = pieces.get(2);\n+      this.state = Replica.getState(encodedStatus);\n+      isLeader = pieces.size() > 3 && \"L\".equals(pieces.get(3));\n+      duplicate = null;\n+    }\n+\n+    public static State parse(String serialized) {\n+      List<String> pieces = StrUtils.splitSmart(serialized, ':');\n+      if (pieces.size() < 3) return null;\n+      return new State(serialized, pieces);\n+\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version) {\n+      this(replica, state, isLeader, version, null);\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version, State duplicate) {\n+      this.replica = replica;\n+      this.state = state == null ? Replica.State.ACTIVE : state;\n+      this.isLeader = isLeader == null ? Boolean.FALSE : isLeader;\n+      this.version = version;\n+      asString = serialize();\n+      this.duplicate = duplicate;\n+    }\n+\n+    @Override\n+    public void writeMap(EntryWriter ew) throws IOException {\n+      ew.put(NAME, replica);\n+      ew.put(VERSION, version);\n+      ew.put(ZkStateReader.STATE_PROP, state.toString());\n+      if (isLeader) ew.put(Slice.LEADER, isLeader);\n+      ew.putIfNotNull(\"duplicate\", duplicate);\n+    }\n+\n+    private State insert(State duplicate) {\n+      assert this.replica.equals(duplicate.replica);\n+      if (this.version >= duplicate.version) {\n+        if (this.duplicate != null) {\n+          duplicate = new State(duplicate.replica, duplicate.state, duplicate.isLeader, duplicate.version, this.duplicate);\n+        }\n+        return new State(this.replica, this.state, this.isLeader, this.version, duplicate);\n+      } else {\n+        return duplicate.insert(this);\n+      }\n+    }\n+\n+    /**\n+     * fetch duplicates entries for this replica\n+     */\n+    List<State> getDuplicates() {\n+      if (duplicate == null) return Collections.emptyList();\n+      List<State> result = new ArrayList<>();\n+      State current = duplicate;\n+      while (current != null) {\n+        result.add(current);\n+        current = current.duplicate;\n+      }\n+      return result;\n+    }\n+\n+    private String serialize() {\n+      StringBuilder sb = new StringBuilder(replica)\n+          .append(\":\")\n+          .append(version)\n+          .append(\":\")\n+          .append(state.shortName);\n+      if (isLeader) sb.append(\":\").append(\"L\");\n+      return sb.toString();\n+    }\n+\n+\n+    @Override\n+    public String toString() {\n+      return asString;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof State) {\n+        State that = (State) o;\n+        return Objects.equals(this.asString, that.asString);\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return asString.hashCode();\n+    }\n+  }\n+\n+\n+  /**This is a helper class that encapsulates various operations performed on the per-replica states\n+   * Do not directly manipulate the per replica states as it can become difficult to debug them\n+   *\n+   */\n+  public static abstract class WriteOps {\n+    private PerReplicaStates rs;\n+    List<Operation> ops;\n+    private boolean preOp = true;\n+\n+    /**\n+     * state of a replica is changed\n+     *\n+     * @param newState the new state\n+     */\n+    public static WriteOps flipState(String replica, Replica.State newState, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Operation> refresh(PerReplicaStates rs) {\n+          List<Operation> ops = new ArrayList<>(2);\n+          State existing = rs.get(replica);\n+          if (existing == null) {\n+            ops.add(new Operation(Operation.Type.ADD, new State(replica, newState, Boolean.FALSE, 0)));\n+          } else {\n+            ops.add(new Operation(Operation.Type.ADD, new State(replica, newState, existing.isLeader, existing.version + 1)));\n+            addDeleteStaleNodes(ops, existing);\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"flipState on {}, {} -> {}, ops :{}\", rs.path, replica, newState, ops);\n+          }\n+          return ops;\n+        }\n+      }.init(rs);\n+    }\n+\n+    public PerReplicaStates getPerReplicaStates() {\n+      return rs;\n+    }\n+\n+\n+    /**Switch a collection from/to perReplicaState=true\n+     */\n+    public static WriteOps modifyCollection(DocCollection coll, boolean enable, PerReplicaStates prs) {\n+      return new WriteOps() {\n+        @Override\n+        List<Operation> refresh(PerReplicaStates prs) {\n+          return enable ? enable(coll) : disable(prs);\n+        }\n+\n+        List<Operation> enable(DocCollection coll) {\n+          List<Operation> result = new ArrayList<>();\n+          coll.forEachReplica((s, r) -> result.add(new Operation(Operation.Type.ADD, new State(r.getName(), r.getState(), r.isLeader(), 0))));\n+          return result;\n+        }\n+\n+        List<Operation> disable(PerReplicaStates prs) {\n+          List<Operation> result = new ArrayList<>();\n+          prs.states.forEachEntry((s, state) -> result.add(new Operation(Operation.Type.DELETE, state)));", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5NDUyNw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552094527", "bodyText": "Can you give more context on the returned list? Can we return unmodifiable lists or will it be modified by the caller as it gets processed?", "author": "madrob", "createdAt": "2021-01-05T17:52:31Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  /**\n+   * Construct with data read from ZK\n+   * @param path path from where this is loaded\n+   * @param cversion the current child version of the znode\n+   * @param states the per-replica states (the list of all child nodes)\n+   */\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    List<Operation> operations = ops.get();\n+    for (int i = 0; i < 10; i++) {\n+      try {\n+        persist(operations, znode, zkClient);\n+        return;\n+      } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+        //state is stale\n+        log.info(\"stale state for {}. retrying...\", znode);\n+        operations = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Operation> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<Op> ops = new ArrayList<>(operations.size());\n+    for (Operation op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Operation.Type.ADD ?\n+          Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Fetch the latest {@link PerReplicaStates} . It fetches data after checking the {@link Stat#getCversion()} of state.json.\n+   * If this is not modified, the same object is returned\n+   */\n+  public static PerReplicaStates fetch(String path, SolrZkClient zkClient, PerReplicaStates current) {\n+    try {\n+      if (current != null) {\n+        Stat stat = zkClient.exists(current.path, null, true);\n+        if (stat == null) return new PerReplicaStates(path, -1, Collections.emptyList());\n+        if (current.cversion == stat.getCversion()) return current;// not modifiedZkStateReaderTest\n+      }\n+      Stat stat = new Stat();\n+      List<String> children = zkClient.getChildren(path, null, stat, true);\n+      return new PerReplicaStates(path, stat.getCversion(), Collections.unmodifiableList(children));\n+    } catch (KeeperException e) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error fetching per-replica states\", e);\n+    } catch (InterruptedException e) {\n+      SolrZkClient.checkInterrupted(e);\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted when loading per-replica states from \" + path, e);\n+    }\n+  }\n+\n+\n+  private static List<Operation> addDeleteStaleNodes(List<Operation> ops, State rs) {\n+    while (rs != null) {\n+      ops.add(new Operation(Operation.Type.DELETE, rs));\n+      rs = rs.duplicate;\n+    }\n+    return ops;\n+  }\n+\n+  public static String getReplicaName(String s) {\n+    int idx = s.indexOf(SEPARATOR);\n+    if (idx > 0) {\n+      return s.substring(0, idx);\n+    }\n+    return null;\n+  }\n+\n+  public State get(String replica) {\n+    return states.get(replica);\n+  }\n+\n+  public static class Operation {\n+    public final Type typ;\n+    public final State state;\n+\n+    public Operation(Type typ, State replicaState) {\n+      this.typ = typ;\n+      this.state = replicaState;\n+    }\n+\n+\n+    public enum Type {\n+      //add a new node\n+      ADD,\n+      //delete an existing node\n+      DELETE\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return typ.toString() + \" : \" + state;\n+    }\n+  }\n+\n+\n+  /**\n+   * The state of a replica as stored as a node under /collections/collection-name/state.json/replica-state\n+   */\n+  public static class State implements MapWriter {\n+\n+    public final String replica;\n+\n+    public final Replica.State state;\n+\n+    public final Boolean isLeader;\n+\n+    public final int version;\n+\n+    public final String asString;\n+\n+    /**\n+     * if there are multiple entries for the same replica, e.g: core_node_1:12:A core_node_1:13:D\n+     * <p>\n+     * the entry with '13' is the latest and the one with '12' is considered a duplicate\n+     * <p>\n+     * These are unlikely, but possible\n+     */\n+    final State duplicate;\n+\n+    private State(String serialized, List<String> pieces) {\n+      this.asString = serialized;\n+      replica = pieces.get(0);\n+      version = Integer.parseInt(pieces.get(1));\n+      String encodedStatus = pieces.get(2);\n+      this.state = Replica.getState(encodedStatus);\n+      isLeader = pieces.size() > 3 && \"L\".equals(pieces.get(3));\n+      duplicate = null;\n+    }\n+\n+    public static State parse(String serialized) {\n+      List<String> pieces = StrUtils.splitSmart(serialized, ':');\n+      if (pieces.size() < 3) return null;\n+      return new State(serialized, pieces);\n+\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version) {\n+      this(replica, state, isLeader, version, null);\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version, State duplicate) {\n+      this.replica = replica;\n+      this.state = state == null ? Replica.State.ACTIVE : state;\n+      this.isLeader = isLeader == null ? Boolean.FALSE : isLeader;\n+      this.version = version;\n+      asString = serialize();\n+      this.duplicate = duplicate;\n+    }\n+\n+    @Override\n+    public void writeMap(EntryWriter ew) throws IOException {\n+      ew.put(NAME, replica);\n+      ew.put(VERSION, version);\n+      ew.put(ZkStateReader.STATE_PROP, state.toString());\n+      if (isLeader) ew.put(Slice.LEADER, isLeader);\n+      ew.putIfNotNull(\"duplicate\", duplicate);\n+    }\n+\n+    private State insert(State duplicate) {\n+      assert this.replica.equals(duplicate.replica);\n+      if (this.version >= duplicate.version) {\n+        if (this.duplicate != null) {\n+          duplicate = new State(duplicate.replica, duplicate.state, duplicate.isLeader, duplicate.version, this.duplicate);\n+        }\n+        return new State(this.replica, this.state, this.isLeader, this.version, duplicate);\n+      } else {\n+        return duplicate.insert(this);\n+      }\n+    }\n+\n+    /**\n+     * fetch duplicates entries for this replica\n+     */\n+    List<State> getDuplicates() {\n+      if (duplicate == null) return Collections.emptyList();\n+      List<State> result = new ArrayList<>();\n+      State current = duplicate;\n+      while (current != null) {\n+        result.add(current);\n+        current = current.duplicate;\n+      }\n+      return result;\n+    }\n+\n+    private String serialize() {\n+      StringBuilder sb = new StringBuilder(replica)\n+          .append(\":\")\n+          .append(version)\n+          .append(\":\")\n+          .append(state.shortName);\n+      if (isLeader) sb.append(\":\").append(\"L\");\n+      return sb.toString();\n+    }\n+\n+\n+    @Override\n+    public String toString() {\n+      return asString;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof State) {\n+        State that = (State) o;\n+        return Objects.equals(this.asString, that.asString);\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return asString.hashCode();\n+    }\n+  }\n+\n+\n+  /**This is a helper class that encapsulates various operations performed on the per-replica states\n+   * Do not directly manipulate the per replica states as it can become difficult to debug them\n+   *\n+   */\n+  public static abstract class WriteOps {\n+    private PerReplicaStates rs;\n+    List<Operation> ops;\n+    private boolean preOp = true;\n+\n+    /**\n+     * state of a replica is changed\n+     *\n+     * @param newState the new state\n+     */\n+    public static WriteOps flipState(String replica, Replica.State newState, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Operation> refresh(PerReplicaStates rs) {\n+          List<Operation> ops = new ArrayList<>(2);\n+          State existing = rs.get(replica);\n+          if (existing == null) {\n+            ops.add(new Operation(Operation.Type.ADD, new State(replica, newState, Boolean.FALSE, 0)));\n+          } else {\n+            ops.add(new Operation(Operation.Type.ADD, new State(replica, newState, existing.isLeader, existing.version + 1)));\n+            addDeleteStaleNodes(ops, existing);\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"flipState on {}, {} -> {}, ops :{}\", rs.path, replica, newState, ops);\n+          }\n+          return ops;\n+        }\n+      }.init(rs);\n+    }\n+\n+    public PerReplicaStates getPerReplicaStates() {\n+      return rs;\n+    }\n+\n+\n+    /**Switch a collection from/to perReplicaState=true\n+     */\n+    public static WriteOps modifyCollection(DocCollection coll, boolean enable, PerReplicaStates prs) {\n+      return new WriteOps() {\n+        @Override\n+        List<Operation> refresh(PerReplicaStates prs) {\n+          return enable ? enable(coll) : disable(prs);\n+        }\n+\n+        List<Operation> enable(DocCollection coll) {\n+          List<Operation> result = new ArrayList<>();\n+          coll.forEachReplica((s, r) -> result.add(new Operation(Operation.Type.ADD, new State(r.getName(), r.getState(), r.isLeader(), 0))));\n+          return result;\n+        }\n+\n+        List<Operation> disable(PerReplicaStates prs) {\n+          List<Operation> result = new ArrayList<>();\n+          prs.states.forEachEntry((s, state) -> result.add(new Operation(Operation.Type.DELETE, state)));\n+          return result;\n+        }\n+      }.init(prs);\n+\n+    }\n+\n+    /**\n+     * Flip the leader replica to a new one\n+     *\n+     * @param allReplicas  allReplicas of the shard\n+     * @param next next leader\n+     */\n+    public static WriteOps flipLeader(Set<String> allReplicas, String next, PerReplicaStates rs) {\n+      return new WriteOps() {\n+\n+        @Override\n+        protected List<Operation> refresh(PerReplicaStates rs) {\n+          List<Operation> ops = new ArrayList<>();\n+          if (next != null) {\n+            State st = rs.get(next);\n+            if (st != null) {\n+              if (!st.isLeader) {\n+                ops.add(new Operation(Operation.Type.ADD, new State(st.replica, Replica.State.ACTIVE, Boolean.TRUE, st.version + 1)));\n+                ops.add(new Operation(Operation.Type.DELETE, st));\n+              }\n+              //else do not do anything , that node is the leader\n+            } else {\n+              //there is no entry for the new leader.\n+              //create one\n+              ops.add(new Operation(Operation.Type.ADD, new State(next, Replica.State.ACTIVE, Boolean.TRUE, 0)));\n+            }\n+          }\n+\n+          //now go through all other replicas and unset previous leader\n+          for (String r : allReplicas) {\n+            State st = rs.get(r);\n+            if (st == null) continue;//unlikely\n+            if (!Objects.equals(r, next)) {\n+              if (st.isLeader) {\n+                //some other replica is the leader now. unset\n+                ops.add(new Operation(Operation.Type.ADD, new State(st.replica, st.state, Boolean.FALSE, st.version + 1)));\n+                ops.add(new Operation(Operation.Type.DELETE, st));\n+              }\n+            }\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"flipLeader on:{}, {} -> {}, ops: {}\", rs.path, allReplicas, next, ops);\n+          }\n+          return ops;\n+        }\n+\n+      }.init(rs);\n+    }\n+\n+    /**\n+     * Delete a replica entry from per-replica states\n+     *\n+     * @param replica name of the replica to be deleted\n+     */\n+    public static WriteOps deleteReplica(String replica, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Operation> refresh(PerReplicaStates rs) {\n+          List<Operation> result;\n+          if (rs == null) {\n+            result = Collections.emptyList();\n+          } else {\n+            State state = rs.get(replica);\n+            result = addDeleteStaleNodes(new ArrayList<>(), state);\n+          }\n+          return result;\n+        }\n+      }.init(rs);\n+    }\n+\n+    public static WriteOps addReplica(String replica, Replica.State state, boolean isLeader, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        protected List<Operation> refresh(PerReplicaStates rs) {\n+          return singletonList(new Operation(Operation.Type.ADD,\n+              new State(replica, state, isLeader, 0)));\n+        }\n+      }.init(rs);\n+    }\n+\n+    /**\n+     * mark a bunch of replicas as DOWN\n+     */\n+    public static WriteOps downReplicas(List<String> replicas, PerReplicaStates rs) {\n+      return new WriteOps() {\n+        @Override\n+        List<Operation> refresh(PerReplicaStates rs) {\n+          List<Operation> ops = new ArrayList<>();\n+          for (String replica : replicas) {\n+            State r = rs.get(replica);\n+            if (r != null) {\n+              if (r.state == Replica.State.DOWN && !r.isLeader) continue;\n+              ops.add(new Operation(Operation.Type.ADD, new State(replica, Replica.State.DOWN, Boolean.FALSE, r.version + 1)));\n+              addDeleteStaleNodes(ops, r);\n+            } else {\n+              ops.add(new Operation(Operation.Type.ADD, new State(replica, Replica.State.DOWN, Boolean.FALSE, 0)));\n+            }\n+          }\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"for coll: {} down replicas {}, ops {}\", rs, replicas, ops);\n+          }\n+          return ops;\n+        }\n+      }.init(rs);\n+    }\n+\n+    /**\n+     * Just creates and deletes a summy entry so that the {@link Stat#getCversion()} of states.json\n+     * is updated\n+     */\n+    public static WriteOps touchChildren() {\n+      WriteOps result = new WriteOps() {\n+        @Override\n+        List<Operation> refresh(PerReplicaStates rs) {\n+          List<Operation> ops = new ArrayList<>();\n+          State st = new State(\".dummy.\" + System.nanoTime(), Replica.State.DOWN, Boolean.FALSE, 0);\n+          ops.add(new Operation(Operation.Type.ADD, st));\n+          ops.add(new Operation(Operation.Type.DELETE, st));\n+          if (log.isDebugEnabled()) {\n+            log.debug(\"touchChildren {}\", ops);\n+          }\n+          return ops;\n+        }\n+      };\n+      result.preOp = false;\n+      result.ops = result.refresh(null);\n+      return result;\n+    }\n+\n+    WriteOps init(PerReplicaStates rs) {\n+      if (rs == null) return null;\n+      get(rs);\n+      return this;\n+    }\n+\n+    public List<Operation> get() {\n+      return ops;\n+    }\n+\n+    public List<Operation> get(PerReplicaStates rs) {\n+      ops = refresh(rs);\n+      if (ops == null) ops = Collections.emptyList();\n+      this.rs = rs;\n+      return ops;\n+    }\n+\n+    /**\n+     * To be executed before collection state.json is persisted\n+     */\n+    public boolean isPreOp() {\n+      return preOp;\n+    }\n+\n+    /**\n+     * if a multi operation fails because the state got modified from behind,\n+     * refresh the operation and try again\n+     *\n+     * @param prs The new state\n+     */\n+    abstract List<Operation> refresh(PerReplicaStates prs);", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA5NzM5Ng==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552097396", "bodyText": "All of these static methods are of the form return new WriteOps() { @Override refresh() { ... } }.init(rs); Can we refactor the boilerplate into a separate method so it's easier to just look at the logic in all of them. Maybe it needs to wait until Java 11 to be done cleanly.", "author": "madrob", "createdAt": "2021-01-05T17:57:04Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  /**\n+   * Construct with data read from ZK\n+   * @param path path from where this is loaded\n+   * @param cversion the current child version of the znode\n+   * @param states the per-replica states (the list of all child nodes)\n+   */\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    List<Operation> operations = ops.get();\n+    for (int i = 0; i < 10; i++) {\n+      try {\n+        persist(operations, znode, zkClient);\n+        return;\n+      } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+        //state is stale\n+        log.info(\"stale state for {}. retrying...\", znode);\n+        operations = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Operation> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<Op> ops = new ArrayList<>(operations.size());\n+    for (Operation op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Operation.Type.ADD ?\n+          Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;\n+    }\n+\n+  }\n+\n+\n+  /**\n+   * Fetch the latest {@link PerReplicaStates} . It fetches data after checking the {@link Stat#getCversion()} of state.json.\n+   * If this is not modified, the same object is returned\n+   */\n+  public static PerReplicaStates fetch(String path, SolrZkClient zkClient, PerReplicaStates current) {\n+    try {\n+      if (current != null) {\n+        Stat stat = zkClient.exists(current.path, null, true);\n+        if (stat == null) return new PerReplicaStates(path, -1, Collections.emptyList());\n+        if (current.cversion == stat.getCversion()) return current;// not modifiedZkStateReaderTest\n+      }\n+      Stat stat = new Stat();\n+      List<String> children = zkClient.getChildren(path, null, stat, true);\n+      return new PerReplicaStates(path, stat.getCversion(), Collections.unmodifiableList(children));\n+    } catch (KeeperException e) {\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Error fetching per-replica states\", e);\n+    } catch (InterruptedException e) {\n+      SolrZkClient.checkInterrupted(e);\n+      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Thread interrupted when loading per-replica states from \" + path, e);\n+    }\n+  }\n+\n+\n+  private static List<Operation> addDeleteStaleNodes(List<Operation> ops, State rs) {\n+    while (rs != null) {\n+      ops.add(new Operation(Operation.Type.DELETE, rs));\n+      rs = rs.duplicate;\n+    }\n+    return ops;\n+  }\n+\n+  public static String getReplicaName(String s) {\n+    int idx = s.indexOf(SEPARATOR);\n+    if (idx > 0) {\n+      return s.substring(0, idx);\n+    }\n+    return null;\n+  }\n+\n+  public State get(String replica) {\n+    return states.get(replica);\n+  }\n+\n+  public static class Operation {\n+    public final Type typ;\n+    public final State state;\n+\n+    public Operation(Type typ, State replicaState) {\n+      this.typ = typ;\n+      this.state = replicaState;\n+    }\n+\n+\n+    public enum Type {\n+      //add a new node\n+      ADD,\n+      //delete an existing node\n+      DELETE\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return typ.toString() + \" : \" + state;\n+    }\n+  }\n+\n+\n+  /**\n+   * The state of a replica as stored as a node under /collections/collection-name/state.json/replica-state\n+   */\n+  public static class State implements MapWriter {\n+\n+    public final String replica;\n+\n+    public final Replica.State state;\n+\n+    public final Boolean isLeader;\n+\n+    public final int version;\n+\n+    public final String asString;\n+\n+    /**\n+     * if there are multiple entries for the same replica, e.g: core_node_1:12:A core_node_1:13:D\n+     * <p>\n+     * the entry with '13' is the latest and the one with '12' is considered a duplicate\n+     * <p>\n+     * These are unlikely, but possible\n+     */\n+    final State duplicate;\n+\n+    private State(String serialized, List<String> pieces) {\n+      this.asString = serialized;\n+      replica = pieces.get(0);\n+      version = Integer.parseInt(pieces.get(1));\n+      String encodedStatus = pieces.get(2);\n+      this.state = Replica.getState(encodedStatus);\n+      isLeader = pieces.size() > 3 && \"L\".equals(pieces.get(3));\n+      duplicate = null;\n+    }\n+\n+    public static State parse(String serialized) {\n+      List<String> pieces = StrUtils.splitSmart(serialized, ':');\n+      if (pieces.size() < 3) return null;\n+      return new State(serialized, pieces);\n+\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version) {\n+      this(replica, state, isLeader, version, null);\n+    }\n+\n+    public State(String replica, Replica.State state, Boolean isLeader, int version, State duplicate) {\n+      this.replica = replica;\n+      this.state = state == null ? Replica.State.ACTIVE : state;\n+      this.isLeader = isLeader == null ? Boolean.FALSE : isLeader;\n+      this.version = version;\n+      asString = serialize();\n+      this.duplicate = duplicate;\n+    }\n+\n+    @Override\n+    public void writeMap(EntryWriter ew) throws IOException {\n+      ew.put(NAME, replica);\n+      ew.put(VERSION, version);\n+      ew.put(ZkStateReader.STATE_PROP, state.toString());\n+      if (isLeader) ew.put(Slice.LEADER, isLeader);\n+      ew.putIfNotNull(\"duplicate\", duplicate);\n+    }\n+\n+    private State insert(State duplicate) {\n+      assert this.replica.equals(duplicate.replica);\n+      if (this.version >= duplicate.version) {\n+        if (this.duplicate != null) {\n+          duplicate = new State(duplicate.replica, duplicate.state, duplicate.isLeader, duplicate.version, this.duplicate);\n+        }\n+        return new State(this.replica, this.state, this.isLeader, this.version, duplicate);\n+      } else {\n+        return duplicate.insert(this);\n+      }\n+    }\n+\n+    /**\n+     * fetch duplicates entries for this replica\n+     */\n+    List<State> getDuplicates() {\n+      if (duplicate == null) return Collections.emptyList();\n+      List<State> result = new ArrayList<>();\n+      State current = duplicate;\n+      while (current != null) {\n+        result.add(current);\n+        current = current.duplicate;\n+      }\n+      return result;\n+    }\n+\n+    private String serialize() {\n+      StringBuilder sb = new StringBuilder(replica)\n+          .append(\":\")\n+          .append(version)\n+          .append(\":\")\n+          .append(state.shortName);\n+      if (isLeader) sb.append(\":\").append(\"L\");\n+      return sb.toString();\n+    }\n+\n+\n+    @Override\n+    public String toString() {\n+      return asString;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (o instanceof State) {\n+        State that = (State) o;\n+        return Objects.equals(this.asString, that.asString);\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return asString.hashCode();\n+    }\n+  }\n+\n+\n+  /**This is a helper class that encapsulates various operations performed on the per-replica states\n+   * Do not directly manipulate the per replica states as it can become difficult to debug them\n+   *\n+   */\n+  public static abstract class WriteOps {\n+    private PerReplicaStates rs;\n+    List<Operation> ops;\n+    private boolean preOp = true;\n+\n+    /**\n+     * state of a replica is changed\n+     *\n+     * @param newState the new state\n+     */\n+    public static WriteOps flipState(String replica, Replica.State newState, PerReplicaStates rs) {\n+      return new WriteOps() {", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMTEyOQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552101129", "bodyText": "log the attempt number when we retry. why is this hard-coded to 10 attempts? should we do some backoff between attempts?", "author": "madrob", "createdAt": "2021-01-05T18:04:02Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  /**\n+   * Construct with data read from ZK\n+   * @param path path from where this is loaded\n+   * @param cversion the current child version of the znode\n+   * @param states the per-replica states (the list of all child nodes)\n+   */\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    List<Operation> operations = ops.get();\n+    for (int i = 0; i < 10; i++) {", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMxOTY2OQ==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552319669", "bodyText": "I think 10 is too much. we should stick to a lower number. There has to be a limit", "author": "noblepaul", "createdAt": "2021-01-06T01:53:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMTEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMTY1Mg==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552101652", "bodyText": "nit: I think the :znode format is going to be unclear.", "author": "madrob", "createdAt": "2021-01-05T18:05:04Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  /**\n+   * Construct with data read from ZK\n+   * @param path path from where this is loaded\n+   * @param cversion the current child version of the znode\n+   * @param states the per-replica states (the list of all child nodes)\n+   */\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    List<Operation> operations = ops.get();\n+    for (int i = 0; i < 10; i++) {\n+      try {\n+        persist(operations, znode, zkClient);\n+        return;\n+      } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+        //state is stale\n+        log.info(\"stale state for {}. retrying...\", znode);\n+        operations = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Operation> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMjU3NA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552102574", "bodyText": "nit: only compute ACLs if we are adding.", "author": "madrob", "createdAt": "2021-01-05T18:06:45Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  /**\n+   * Construct with data read from ZK\n+   * @param path path from where this is loaded\n+   * @param cversion the current child version of the znode\n+   * @param states the per-replica states (the list of all child nodes)\n+   */\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    List<Operation> operations = ops.get();\n+    for (int i = 0; i < 10; i++) {\n+      try {\n+        persist(operations, znode, zkClient);\n+        return;\n+      } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+        //state is stale\n+        log.info(\"stale state for {}. retrying...\", znode);\n+        operations = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Operation> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<Op> ops = new ArrayList<>(operations.size());\n+    for (Operation op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMzA2OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552103068", "bodyText": "do we want to rethrow as keeper exception or wrap in something different?", "author": "madrob", "createdAt": "2021-01-05T18:07:37Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  /**\n+   * Construct with data read from ZK\n+   * @param path path from where this is loaded\n+   * @param cversion the current child version of the znode\n+   * @param states the per-replica states (the list of all child nodes)\n+   */\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    List<Operation> operations = ops.get();\n+    for (int i = 0; i < 10; i++) {\n+      try {\n+        persist(operations, znode, zkClient);\n+        return;\n+      } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+        //state is stale\n+        log.info(\"stale state for {}. retrying...\", znode);\n+        operations = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Operation> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<Op> ops = new ArrayList<>(operations.size());\n+    for (Operation op : operations) {\n+      //the state of the replica is being updated\n+      String path = znode + \"/\" + op.state.asString;\n+      List<ACL> acls = zkClient.getZkACLProvider().getACLsToAdd(path);\n+      ops.add(op.typ == Operation.Type.ADD ?\n+          Op.create(path, null, acls, CreateMode.PERSISTENT) :\n+          Op.delete(path, -1));\n+    }\n+    try {\n+      zkClient.multi(ops, true);\n+      if (log.isDebugEnabled()) {\n+        //nocommit\n+        try {\n+          Stat stat = zkClient.exists(znode, null, true);\n+          log.debug(\"After update, cversion : {}\", stat.getCversion());\n+        } catch (Exception e) {\n+        }\n+\n+      }\n+    } catch (KeeperException e) {\n+      log.error(\"multi op exception : \" + e.getMessage() + zkClient.getChildren(znode, null, true));\n+      throw e;", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjMxODk2Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552318967", "bodyText": "does it add any value?", "author": "noblepaul", "createdAt": "2021-01-06T01:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMzA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg2MTk3OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552861978", "bodyText": "It might make things more consistent for callers for what they need to be prepared to handle.", "author": "madrob", "createdAt": "2021-01-06T17:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwMzA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjEwNjA0MA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552106040", "bodyText": "This is part is a good example of the confusion that I think @murblanc alluded to. We go from WriteOps to Operation to Op, one of which happens to be a Zookeeper class and not ours.", "author": "madrob", "createdAt": "2021-01-05T18:13:07Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -0,0 +1,600 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.common.cloud;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.solr.cluster.api.SimpleMap;\n+import org.apache.solr.common.MapWriter;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.annotation.JsonProperty;\n+import org.apache.solr.common.util.ReflectMapWriter;\n+import org.apache.solr.common.util.StrUtils;\n+import org.apache.solr.common.util.WrappedSimpleMap;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.Op;\n+import org.apache.zookeeper.data.ACL;\n+import org.apache.zookeeper.data.Stat;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.singletonList;\n+import static org.apache.solr.common.params.CommonParams.NAME;\n+import static org.apache.solr.common.params.CommonParams.VERSION;\n+\n+/**\n+ * This represents the individual replica states in a collection\n+ * This is an immutable object. When states are modified, a new instance is constructed\n+ */\n+public class PerReplicaStates implements ReflectMapWriter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  public static final char SEPARATOR = ':';\n+\n+\n+  @JsonProperty\n+  public final String path;\n+\n+  @JsonProperty\n+  public final int cversion;\n+\n+  @JsonProperty\n+  public final SimpleMap<State> states;\n+\n+  /**\n+   * Construct with data read from ZK\n+   * @param path path from where this is loaded\n+   * @param cversion the current child version of the znode\n+   * @param states the per-replica states (the list of all child nodes)\n+   */\n+  public PerReplicaStates(String path, int cversion, List<String> states) {\n+    this.path = path;\n+    this.cversion = cversion;\n+    Map<String, State> tmp = new LinkedHashMap<>();\n+\n+    for (String state : states) {\n+      State rs = State.parse(state);\n+      if (rs == null) continue;\n+      State existing = tmp.get(rs.replica);\n+      if (existing == null) {\n+        tmp.put(rs.replica, rs);\n+      } else {\n+        tmp.put(rs.replica, rs.insert(existing));\n+      }\n+    }\n+    this.states = new WrappedSimpleMap<>(tmp);\n+\n+  }\n+\n+  /**Get the changed replicas\n+   */\n+  public static Set<String> findModifiedReplicas(PerReplicaStates old, PerReplicaStates fresh) {\n+    Set<String> result = new HashSet<>();\n+    if (fresh == null) {\n+      old.states.forEachKey(result::add);\n+      return result;\n+    }\n+    old.states.forEachEntry((s, state) -> {\n+      // the state is modified or missing\n+      if (!Objects.equals(fresh.get(s) , state)) result.add(s);\n+    });\n+    fresh.states.forEachEntry((s, state) -> { if (old.get(s) == null ) result.add(s);\n+    });\n+    return result;\n+  }\n+\n+  /**\n+   * This is a persist operation with retry if a write fails due to stale state\n+   */\n+  public static void persist(WriteOps ops, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    List<Operation> operations = ops.get();\n+    for (int i = 0; i < 10; i++) {\n+      try {\n+        persist(operations, znode, zkClient);\n+        return;\n+      } catch (KeeperException.NodeExistsException | KeeperException.NoNodeException e) {\n+        //state is stale\n+        log.info(\"stale state for {}. retrying...\", znode);\n+        operations = ops.get(PerReplicaStates.fetch(znode, zkClient, null));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Persist a set of operations to Zookeeper\n+   */\n+  public static void persist(List<Operation> operations, String znode, SolrZkClient zkClient) throws KeeperException, InterruptedException {\n+    if (operations == null || operations.isEmpty()) return;\n+    log.debug(\"Per-replica state being persisted for :{}, ops: {}\", znode, operations);\n+\n+    List<Op> ops = new ArrayList<>(operations.size());\n+    for (Operation op : operations) {", "originalCommit": "29cf47099ccdeb0d5c7d2d1898fa830278cce68b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2fb2b66dbd79c98c332536c9c9a8a924a626a554", "url": "https://github.com/apache/lucene-solr/commit/2fb2b66dbd79c98c332536c9c9a8a924a626a554", "message": "cleanup", "committedDate": "2021-01-06T04:19:26Z", "type": "commit"}, {"oid": "9d1769e39cf7e21123499f08d857a600b59ea2b5", "url": "https://github.com/apache/lucene-solr/commit/9d1769e39cf7e21123499f08d857a600b59ea2b5", "message": "cleanup", "committedDate": "2021-01-06T04:31:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg2NTI3OA==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552865278", "bodyText": "I think this sentence ends mid-way.", "author": "madrob", "createdAt": "2021-01-06T18:00:35Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -564,12 +539,17 @@ public boolean isPreOp() {\n     }\n \n     /**\n+     * This method should compute the set of ZK operations for a given action\n+     * for instance, a state change may result in", "originalCommit": "9d1769e39cf7e21123499f08d857a600b59ea2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg2NjgxMw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552866813", "bodyText": "nit: set initial size = 2", "author": "madrob", "createdAt": "2021-01-06T18:02:20Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -465,75 +454,61 @@ public static WriteOps flipLeader(Set<String> allReplicas, String next, PerRepli\n      * @param replica name of the replica to be deleted\n      */\n     public static WriteOps deleteReplica(String replica, PerReplicaStates rs) {\n-      return new WriteOps() {\n-        @Override\n-        protected List<Operation> refresh(PerReplicaStates rs) {\n-          List<Operation> result;\n-          if (rs == null) {\n-            result = Collections.emptyList();\n-          } else {\n-            State state = rs.get(replica);\n-            result = addDeleteStaleNodes(new ArrayList<>(), state);\n-          }\n-          return result;\n+      return new WriteOps(prs -> {\n+        List<Operation> result;\n+        if (rs == null) {\n+          result = Collections.emptyList();\n+        } else {\n+          State state = rs.get(replica);\n+          result = addDeleteStaleNodes(new ArrayList<>(), state);\n         }\n-      }.init(rs);\n+        return result;\n+      }).init(rs);\n     }\n \n     public static WriteOps addReplica(String replica, Replica.State state, boolean isLeader, PerReplicaStates rs) {\n-      return new WriteOps() {\n-        @Override\n-        protected List<Operation> refresh(PerReplicaStates rs) {\n-          return singletonList(new Operation(Operation.Type.ADD,\n-              new State(replica, state, isLeader, 0)));\n-        }\n-      }.init(rs);\n+      return new WriteOps(perReplicaStates -> singletonList(new Operation(Operation.Type.ADD,\n+          new State(replica, state, isLeader, 0)))).init(rs);\n     }\n \n     /**\n      * mark a bunch of replicas as DOWN\n      */\n     public static WriteOps downReplicas(List<String> replicas, PerReplicaStates rs) {\n-      return new WriteOps() {\n-        @Override\n-        List<Operation> refresh(PerReplicaStates rs) {\n-          List<Operation> ops = new ArrayList<>();\n-          for (String replica : replicas) {\n-            State r = rs.get(replica);\n-            if (r != null) {\n-              if (r.state == Replica.State.DOWN && !r.isLeader) continue;\n-              ops.add(new Operation(Operation.Type.ADD, new State(replica, Replica.State.DOWN, Boolean.FALSE, r.version + 1)));\n-              addDeleteStaleNodes(ops, r);\n-            } else {\n-              ops.add(new Operation(Operation.Type.ADD, new State(replica, Replica.State.DOWN, Boolean.FALSE, 0)));\n-            }\n-          }\n-          if (log.isDebugEnabled()) {\n-            log.debug(\"for coll: {} down replicas {}, ops {}\", rs, replicas, ops);\n+      return new WriteOps(prs -> {\n+        List<Operation> operations = new ArrayList<>();\n+        for (String replica : replicas) {\n+          State r = rs.get(replica);\n+          if (r != null) {\n+            if (r.state == Replica.State.DOWN && !r.isLeader) continue;\n+            operations.add(new Operation(Operation.Type.ADD, new State(replica, Replica.State.DOWN, Boolean.FALSE, r.version + 1)));\n+            addDeleteStaleNodes(operations, r);\n+          } else {\n+            operations.add(new Operation(Operation.Type.ADD, new State(replica, Replica.State.DOWN, Boolean.FALSE, 0)));\n           }\n-          return ops;\n         }\n-      }.init(rs);\n+        if (log.isDebugEnabled()) {\n+          log.debug(\"for coll: {} down replicas {}, ops {}\", rs, replicas, operations);\n+        }\n+        return operations;\n+      }).init(rs);\n     }\n \n     /**\n-     * Just creates and deletes a summy entry so that the {@link Stat#getCversion()} of states.json\n+     * Just creates and deletes a dummy entry so that the {@link Stat#getCversion()} of states.json\n      * is updated\n      */\n     public static WriteOps touchChildren() {\n-      WriteOps result = new WriteOps() {\n-        @Override\n-        List<Operation> refresh(PerReplicaStates rs) {\n-          List<Operation> ops = new ArrayList<>();\n-          State st = new State(\".dummy.\" + System.nanoTime(), Replica.State.DOWN, Boolean.FALSE, 0);\n-          ops.add(new Operation(Operation.Type.ADD, st));\n-          ops.add(new Operation(Operation.Type.DELETE, st));\n-          if (log.isDebugEnabled()) {\n-            log.debug(\"touchChildren {}\", ops);\n-          }\n-          return ops;\n+      WriteOps result = new WriteOps(prs -> {\n+        List<Operation> operations = new ArrayList<>();", "originalCommit": "9d1769e39cf7e21123499f08d857a600b59ea2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg2OTg3Nw==", "url": "https://github.com/apache/lucene-solr/pull/2148#discussion_r552869877", "bodyText": "I still think this class should be moved out to its own file. There is a LOT going on in here and it is deserving of a separate compilation unit.", "author": "madrob", "createdAt": "2021-01-06T18:05:21Z", "path": "solr/solrj/src/java/org/apache/solr/common/cloud/PerReplicaStates.java", "diffHunk": "@@ -352,111 +349,103 @@ public int hashCode() {\n    * Do not directly manipulate the per replica states as it can become difficult to debug them\n    *\n    */\n-  public static abstract class WriteOps {\n+  public static class WriteOps {", "originalCommit": "9d1769e39cf7e21123499f08d857a600b59ea2b5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "00d7cb4b3b9ac6430dbf3aa34652c995fcd398b5", "url": "https://github.com/apache/lucene-solr/commit/00d7cb4b3b9ac6430dbf3aa34652c995fcd398b5", "message": "more cleanup", "committedDate": "2021-01-07T04:59:46Z", "type": "commit"}, {"oid": "8bd8bd3f41157ba4568904b92a59a79d8b39ae6a", "url": "https://github.com/apache/lucene-solr/commit/8bd8bd3f41157ba4568904b92a59a79d8b39ae6a", "message": "more cleanup", "committedDate": "2021-01-07T07:50:26Z", "type": "commit"}, {"oid": "6cf06368c8614e1251470c34b44a4924796e4558", "url": "https://github.com/apache/lucene-solr/commit/6cf06368c8614e1251470c34b44a4924796e4558", "message": "unused import", "committedDate": "2021-01-07T08:00:22Z", "type": "commit"}, {"oid": "acd87025fecff900d4ab9a6325ebe69c6e7dd731", "url": "https://github.com/apache/lucene-solr/commit/acd87025fecff900d4ab9a6325ebe69c6e7dd731", "message": "unused import", "committedDate": "2021-01-07T08:03:53Z", "type": "commit"}, {"oid": "95773c567146293617fe5b2653bca8b165fc417e", "url": "https://github.com/apache/lucene-solr/commit/95773c567146293617fe5b2653bca8b165fc417e", "message": "cleanup", "committedDate": "2021-01-07T08:08:14Z", "type": "commit"}, {"oid": "61bae09151aaae93a3951509473bc5c79546e53f", "url": "https://github.com/apache/lucene-solr/commit/61bae09151aaae93a3951509473bc5c79546e53f", "message": "cleanup", "committedDate": "2021-01-07T11:37:53Z", "type": "commit"}, {"oid": "d37275e39d1b790a5b4608f4d1911ae949a89b87", "url": "https://github.com/apache/lucene-solr/commit/d37275e39d1b790a5b4608f4d1911ae949a89b87", "message": "Merge branch 'branch_8x' into jira/solr-15052-8x", "committedDate": "2021-01-07T11:42:17Z", "type": "commit"}, {"oid": "0a7f7ef092380c8b9821ade43b429f5c96dbc74c", "url": "https://github.com/apache/lucene-solr/commit/0a7f7ef092380c8b9821ade43b429f5c96dbc74c", "message": "randomize the flag", "committedDate": "2021-01-07T15:28:42Z", "type": "commit"}]}