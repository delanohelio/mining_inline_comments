{"pr_number": 2127, "pr_title": "LUCENE-9633: Improve match highlighter behavior for degenerate intervals", "pr_createdAt": "2020-12-07T16:55:51Z", "pr_url": "https://github.com/apache/lucene-solr/pull/2127", "timeline": [{"oid": "e0685fcc57c3ef2c43118d556fbde60f66dcff24", "url": "https://github.com/apache/lucene-solr/commit/e0685fcc57c3ef2c43118d556fbde60f66dcff24", "message": "LUCENE-9633: Improve match highlighter behavior for degenerate intervals (on non-existing positions).", "committedDate": "2020-12-07T16:57:58Z", "type": "commit"}, {"oid": "e0685fcc57c3ef2c43118d556fbde60f66dcff24", "url": "https://github.com/apache/lucene-solr/commit/e0685fcc57c3ef2c43118d556fbde60f66dcff24", "message": "LUCENE-9633: Improve match highlighter behavior for degenerate intervals (on non-existing positions).", "committedDate": "2020-12-07T16:57:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2OTEyNA==", "url": "https://github.com/apache/lucene-solr/pull/2127#discussion_r537669124", "bodyText": "@romseygeek Alan - this may be interesting for you. Is this how it's supposed to work with fields with offsets? If you enable this test and compare how positions only vs. positions+offsets field behaves you'll see what I mean - the stored offsets actually cause an incorrect highlight in this case.", "author": "dweiss", "createdAt": "2020-12-07T17:00:39Z", "path": "lucene/highlighter/src/test/org/apache/lucene/search/matchhighlight/TestMatchRegionRetriever.java", "diffHunk": "@@ -361,6 +374,41 @@ public void testIntervalQueries() throws IOException {\n     );\n   }\n \n+  @Test\n+  public void testDegenerateIntervalsWithPositions() throws IOException {\n+    testDegenerateIntervals(FLD_TEXT_POS);\n+  }\n+\n+  @Test @AwaitsFix(bugUrl = \"https://issues.apache.org/jira/browse/LUCENE-9634: \" +", "originalCommit": "e0685fcc57c3ef2c43118d556fbde60f66dcff24", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1NzUzMg==", "url": "https://github.com/apache/lucene-solr/pull/2127#discussion_r538157532", "bodyText": "So extend will widen the bounds of an interval's positions, but leave its offsets untouched (because it has no way of knowing what the offsets actually are).  I sort of think that just highlighting the original term is the correct behaviour?  But there will be a discrepancy when we generate offsets directly from the token stream by comparing to positions.\nI see that ExtendedIntervalIterator's javadoc is incorrect regarding prefixes.  It says\nAn interval with prefix bounds extended by n will skip over matches that appear in positions lower than n\n\nbut it actually just readjusts these matches to start at position 0.", "author": "romseygeek", "createdAt": "2020-12-08T09:04:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2OTEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2MjcxMg==", "url": "https://github.com/apache/lucene-solr/pull/2127#discussion_r538162712", "bodyText": "I sort of think that just highlighting the original term is the correct behaviour?\n\nHmm... I don't think I agree. When you have a query parser that allows intervals then extend becomes a function just like anything else. The intuitive user expectation for a query extend(foo 2 2) is to actually highlight the matching interval of positions  (well, users think of \"words\") pointed to by that interval. This is particularly important if you're building more complex expressions out of these (left/ right/ extend, etc.) and you wish to see partial fragments as you're building more focused expressions.\nI'm not saying this has to be fixed (neither do I know how it should) but it's real feedback from people who use those queries intensively (and my gut feeling agrees).", "author": "dweiss", "createdAt": "2020-12-08T09:11:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2OTEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIyMDQ0Mw==", "url": "https://github.com/apache/lucene-solr/pull/2127#discussion_r538220443", "bodyText": "Fair enough! I originally added extend to deal with stopwords and to help implement before and after filters, but if it's being used elsewhere then that's all good.\nI'm interested in how it's being exposed in query parsers - we don't actually have it as an option in the elasticsearch intervals DSL but maybe we ought to add it?", "author": "romseygeek", "createdAt": "2020-12-08T10:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2OTEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODMxMzkwOA==", "url": "https://github.com/apache/lucene-solr/pull/2127#discussion_r538313908", "bodyText": "It is extremely useful to capture and drill down in the context of another query. Let's say apples nearby oranges. Yes, you can achieve a similar thing with other queries but it's pretty useful on its own (because you can first inspect the context you're looking at by running the extends query in isolation).\nI've modified flexible query parser and added those functions as prefix-scoped \"language\". Looks like this:\nhttps://get.carrotsearch.com/lingo4g/1.12.0-SNAPSHOT/doc/#interval-functions\nAnd combine with the matches highlighter it really shines. It's the best when you get multiple overlapping intervals; I don't have an example won this computer (I have a day of on home duties) but I can send you one later on - you can do some really impressive stuff with intervals!", "author": "dweiss", "createdAt": "2020-12-08T12:32:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2OTEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc5NjQ4MA==", "url": "https://github.com/apache/lucene-solr/pull/2127#discussion_r538796480", "bodyText": "I may provide a PR with those query parser changes I made if there's interest - they're not that difficult and they make it possible to use intervals from plain text queries. I'll get to it.", "author": "dweiss", "createdAt": "2020-12-08T20:51:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2OTEyNA=="}], "type": "inlineReview"}]}