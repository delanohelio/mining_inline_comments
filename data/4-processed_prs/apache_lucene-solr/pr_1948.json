{"pr_number": 1948, "pr_title": "LUCENE-9536: Optimize OrdinalMap when one segment contains all distinct values.", "pr_createdAt": "2020-10-05T20:24:47Z", "pr_url": "https://github.com/apache/lucene-solr/pull/1948", "timeline": [{"oid": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc", "url": "https://github.com/apache/lucene-solr/commit/4f22cbab03d19f2c826d6d5915d86cea2957d6cc", "message": "LUCENE-9536: Optimize OrdinalMap when one segment contains all distinct values.\n\nFor doc values that are not too high cardinality, it is common for some large\nsegments to contain all distinct values. In this case, we can check if the first\nsegment ords map perfectly to global ords, and if so store the global ord deltas\nand first segment indices as `LongValues.ZEROES`\nto save some space.", "committedDate": "2020-10-05T18:39:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwNDA4NQ==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r503704085", "bodyText": "We could ignore it completely from ramBytesUsed, since this singleton is allocated anyway, regardless of whether the optimization uses it.", "author": "jpountz", "createdAt": "2020-10-13T06:48:16Z", "path": "lucene/core/src/java/org/apache/lucene/index/OrdinalMap.java", "diffHunk": "@@ -271,13 +273,26 @@ protected boolean lessThan(TermsEnumIndex a, TermsEnumIndex b) {\n       globalOrd++;\n     }\n \n-    this.firstSegments = firstSegments.build();\n-    this.globalOrdDeltas = globalOrdDeltas.build();\n+    long ramBytesUsed = BASE_RAM_BYTES_USED + segmentMap.ramBytesUsed();\n+    this.valueCount = globalOrd;\n+\n+    // If the first segment contains all of the global ords, then we can apply a small optimization\n+    // and hardcode the first segments and global ord deltas as all zeroes.\n+    if (ordDeltaBits.length > 0 && ordDeltaBits[0] == 0L && ordDeltas[0].size() == this.valueCount) {\n+      this.firstSegments = LongValues.ZEROES;\n+      this.globalOrdDeltas = LongValues.ZEROES;\n+      ramBytesUsed += RamUsageEstimator.shallowSizeOf(LongValues.ZEROES);", "originalCommit": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNzIzOA==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r504927238", "bodyText": "I added this to address a failure in TestOrdinalMap. But now I see it makes more sense to modify the test !", "author": "jtibshirani", "createdAt": "2020-10-14T19:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwNDA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwNTIwNg==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r503705206", "bodyText": "could be do something like if (firstSegments != LongValues.ZEROES) { resources.add(Accountables.namedAccountable(\"first segments\", firstSegments)); }?", "author": "jpountz", "createdAt": "2020-10-13T06:50:40Z", "path": "lucene/core/src/java/org/apache/lucene/index/OrdinalMap.java", "diffHunk": "@@ -359,10 +375,9 @@ public long ramBytesUsed() {\n   @Override\n   public Collection<Accountable> getChildResources() {\n     List<Accountable> resources = new ArrayList<>();\n-    resources.add(Accountables.namedAccountable(\"global ord deltas\", globalOrdDeltas));\n-    resources.add(Accountables.namedAccountable(\"first segments\", firstSegments));\n     resources.add(Accountables.namedAccountable(\"segment map\", segmentMap));\n-    // TODO: would be nice to return actual child segment deltas too, but the optimizations are confusing\n+    // TODO: would be nice to return the ordinal and segment maps too, but it's not straightforward\n+    //  because of optimizations.", "originalCommit": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2OTU2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r505869567", "bodyText": "I think we'd need a cast here, since LongValues doesn't implement Accountable. Alternatively, we could consider a bigger change to have LongValues implement Accountable.\nUpdate: I just saw LUCENE-9387, it probably doesn't make sense to increase usage of Accountable.", "author": "jtibshirani", "createdAt": "2020-10-15T21:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzcwNTIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2MzY2Nw==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r504863667", "bodyText": "Hmm why only the first segment?  Couldn't it be the 3rd segment, in addition, that matches the global ords?\nEdit: ahh OK I understand now -- this opto is indeed specific to the first segment, so we can store this.firstSegments as all 0s.  Good!\nDo we (somewhere, couldn't find it here) pre-sort all segments by the cardinality descending?  Then we could know all segments that meet this optimization are at the start of the segments list, and possibly building the ordinal map is faster (not sure).  But then we would need to un-sort in the end to return the final OrdinalMap.  But it might enable this opto to apply more often, except, I think we would then need an additional dereference on lookup, hmm.\nDoes our PackedLongValues.monotonicBuilder already optimize for the case where it is all 0s, for the case where another segment (not the first) has all the global values as well?", "author": "mikemccand", "createdAt": "2020-10-14T17:50:58Z", "path": "lucene/core/src/java/org/apache/lucene/index/OrdinalMap.java", "diffHunk": "@@ -271,13 +273,26 @@ protected boolean lessThan(TermsEnumIndex a, TermsEnumIndex b) {\n       globalOrd++;\n     }\n \n-    this.firstSegments = firstSegments.build();\n-    this.globalOrdDeltas = globalOrdDeltas.build();\n+    long ramBytesUsed = BASE_RAM_BYTES_USED + segmentMap.ramBytesUsed();\n+    this.valueCount = globalOrd;\n+\n+    // If the first segment contains all of the global ords, then we can apply a small optimization\n+    // and hardcode the first segments and global ord deltas as all zeroes.\n+    if (ordDeltaBits.length > 0 && ordDeltaBits[0] == 0L && ordDeltas[0].size() == this.valueCount) {", "originalCommit": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg5OTE5Mw==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r504899193", "bodyText": "Do we (somewhere, couldn't find it here) pre-sort all segments by the cardinality descending?\n\nWe do in fact -- the segments are sorted by 'weight', which in all call sites corresponds to the number of unique terms. This was added in LUCENE-5782.\n\nDoes our PackedLongValues.monotonicBuilder already optimize for the case where it is all 0s, for the case where another segment (not the first) has all the global values as well?\n\nWhen constructing the individual PackedInts.Reader instances, we do identify the all 0s case and use the lightweight PackedInts.NullReader. It's great we optimize that case, but it does mean this PR doesn't make an enormous space difference.", "author": "jtibshirani", "createdAt": "2020-10-14T18:50:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2MzY2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgwMDM0OA==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r505800348", "bodyText": "Do we (somewhere, couldn't find it here) pre-sort all segments by the cardinality descending?\n\nWe do in fact -- the segments are sorted by 'weight', which in all call sites corresponds to the number of unique terms. This was added in LUCENE-5782.\n\nAhh, so then we know the first segment will indeed have the most unique terms, and therefore the highest chance of having \"all 0s\" ord deltas.\nI think 2nd and 3rd segments also might have all 0s ord deltas?  But we can try to optimize that in a followon issue ... progress not perfection!\n\n\nDoes our PackedLongValues.monotonicBuilder already optimize for the case where it is all 0s, for the case where another segment (not the first) has all the global values as well?\n\nWhen constructing the individual PackedInts.Reader instances, we do identify the all 0s case and use the lightweight PackedInts.NullReader. It's great we optimize that case, but it does mean this PR doesn't make an enormous space difference.\n\nGot it.  Well, it's great that all these layers optimize :)", "author": "mikemccand", "createdAt": "2020-10-15T19:51:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2MzY2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTgyODM5OQ==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r505828399", "bodyText": "I think 2nd and 3rd segments also might have all 0s ord deltas? But we can try to optimize that in a followon issue ... progress not perfection!\n\nI wonder if you are confused here, the proposed changes optimize the mapping from global ordinals to the ordinals of one arbitrary segment. When a segment has all value, we can simplify by always picking this segment, but there is no need to optimize this for the 2nd or 3rd segments, since we only need to be able to translate global ordinals to the ordinal of a single segment. Or maybe I'm the one confused by what you were suggesting. :)", "author": "jpountz", "createdAt": "2020-10-15T20:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2MzY2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE3OTgyMA==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r515179820", "bodyText": "Aha!  Sorry, I was indeed confused ;)\nThis is to enable \"retrieve BytesRef for this global ordinal\" use-case, right?  For that, we first pick a segment to use (the first one also containing that BytesRef), then map to its segment-local ordinal, then retrieve the BytesRef for that using the existing doc values API for that segment.\nWe do not (need to, nor) expose an API today to \"retrieve segment N's ordinal corresponding to global ordinal M\".  Only the reverse direction (segment N's ordinal M maps to global ordinal O).\nI think I understand now!", "author": "mikemccand", "createdAt": "2020-10-30T15:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2MzY2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwOTYzOA==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r515209638", "bodyText": "This is to enable \"retrieve BytesRef for this global ordinal\" use-case, right?\n\nRight!\n\nWe do not (need to, nor) expose an API today to \"retrieve segment N's ordinal corresponding to global ordinal M\"\n\nCorrect.", "author": "jpountz", "createdAt": "2020-10-30T16:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2MzY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2Mzg4Nw==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r504863887", "bodyText": "Insert possessive quote (first segment's)?", "author": "mikemccand", "createdAt": "2020-10-14T17:51:20Z", "path": "lucene/core/src/java/org/apache/lucene/index/OrdinalMap.java", "diffHunk": "@@ -271,13 +273,26 @@ protected boolean lessThan(TermsEnumIndex a, TermsEnumIndex b) {\n       globalOrd++;\n     }\n \n-    this.firstSegments = firstSegments.build();\n-    this.globalOrdDeltas = globalOrdDeltas.build();\n+    long ramBytesUsed = BASE_RAM_BYTES_USED + segmentMap.ramBytesUsed();\n+    this.valueCount = globalOrd;\n+\n+    // If the first segment contains all of the global ords, then we can apply a small optimization\n+    // and hardcode the first segments and global ord deltas as all zeroes.", "originalCommit": "4f22cbab03d19f2c826d6d5915d86cea2957d6cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg4ODIxMg==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r504888212", "bodyText": "I don't think the possessive quote gives the right meaning? Perhaps I could say 'first segment indices' here to be more clear.", "author": "jtibshirani", "createdAt": "2020-10-14T18:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2Mzg4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5ODQzMQ==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r505798431", "bodyText": "Oh I thought it was the first segment's deltas as all zeros and alos the global ord deltas as all zeros?  But I'm OK with just rewording it to make it less controversial, or even just leaving this wording!", "author": "mikemccand", "createdAt": "2020-10-15T19:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDg2Mzg4Nw=="}], "type": "inlineReview"}, {"oid": "55ac801915f0ff0f0b2dd11794af630d83d70c98", "url": "https://github.com/apache/lucene-solr/commit/55ac801915f0ff0f0b2dd11794af630d83d70c98", "message": "Omit static singleton from RAM estimate.", "committedDate": "2020-10-15T18:35:27Z", "type": "commit"}, {"oid": "e9d7b9433c7ee31d0ec9013bb760a7d571ae083b", "url": "https://github.com/apache/lucene-solr/commit/e9d7b9433c7ee31d0ec9013bb760a7d571ae083b", "message": "Clarify comment.", "committedDate": "2020-10-15T18:55:10Z", "type": "commit"}, {"oid": "a0330e3af31c286af1a553d6169248dfec7a0b98", "url": "https://github.com/apache/lucene-solr/commit/a0330e3af31c286af1a553d6169248dfec7a0b98", "message": "Add test that covers the optomization.", "committedDate": "2020-10-15T21:29:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE4NDIyOA==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r515184228", "bodyText": "Does (would) https://issues.apache.org/jira/browse/LUCENE-9564 enforce import ordering check?", "author": "mikemccand", "createdAt": "2020-10-30T15:31:15Z", "path": "lucene/core/src/test/org/apache/lucene/index/TestOrdinalMap.java", "diffHunk": "@@ -32,6 +28,10 @@\n import org.apache.lucene.util.RamUsageTester;\n import org.apache.lucene.util.TestUtil;\n \n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.util.HashMap;\n+", "originalCommit": "a0330e3af31c286af1a553d6169248dfec7a0b98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwNzI4Mw==", "url": "https://github.com/apache/lucene-solr/pull/1948#discussion_r515207283", "bodyText": "I think it would avoid this sort of change (I use IntelliJ which autoformats  java imports at the end).", "author": "jtibshirani", "createdAt": "2020-10-30T16:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE4NDIyOA=="}], "type": "inlineReview"}]}