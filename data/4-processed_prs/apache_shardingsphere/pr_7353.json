{"pr_number": 7353, "pr_title": "Improve the Statement definition", "pr_createdAt": "2020-09-09T09:07:58Z", "pr_url": "https://github.com/apache/shardingsphere/pull/7353", "timeline": [{"oid": "8816778759867647785222ad6c04259a97880cb3", "url": "https://github.com/apache/shardingsphere/commit/8816778759867647785222ad6c04259a97880cb3", "message": "merge from upstream master", "committedDate": "2020-09-03T02:07:02Z", "type": "commit"}, {"oid": "3e43d12268f6c99036c1bff59774947dce094bc7", "url": "https://github.com/apache/shardingsphere/commit/3e43d12268f6c99036c1bff59774947dce094bc7", "message": "fix", "committedDate": "2020-09-04T09:14:16Z", "type": "commit"}, {"oid": "fe36767f7855e1202e4c99de45c01d00eea296a4", "url": "https://github.com/apache/shardingsphere/commit/fe36767f7855e1202e4c99de45c01d00eea296a4", "message": "fix test case", "committedDate": "2020-09-09T08:38:49Z", "type": "commit"}, {"oid": "3e347db6e62b1e4339c1c3581199920bdf625386", "url": "https://github.com/apache/shardingsphere/commit/3e347db6e62b1e4339c1c3581199920bdf625386", "message": "fix", "committedDate": "2020-09-09T09:06:01Z", "type": "commit"}, {"oid": "e1060cf090d500974842b52ab271069d6311e9da", "url": "https://github.com/apache/shardingsphere/commit/e1060cf090d500974842b52ab271069d6311e9da", "message": "merge from upstream/master", "committedDate": "2020-09-09T09:34:37Z", "type": "commit"}, {"oid": "87d217717ffa70121d5ece086299f64dcb9ff7ce", "url": "https://github.com/apache/shardingsphere/commit/87d217717ffa70121d5ece086299f64dcb9ff7ce", "message": "fix", "committedDate": "2020-09-09T09:46:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAzMjc4OA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486032788", "bodyText": "A concrete class for operator is recommended.", "author": "tristaZero", "createdAt": "2020-09-10T02:55:55Z", "path": "shardingsphere-features/shardingsphere-encrypt/shardingsphere-encrypt-rewrite/src/main/java/org/apache/shardingsphere/encrypt/rewrite/condition/EncryptConditionEngine.java", "diffHunk": "@@ -81,50 +102,72 @@\n     private Collection<EncryptCondition> createEncryptConditions(final SQLStatementContext sqlStatementContext, final AndPredicate andPredicate) {\n         Collection<EncryptCondition> result = new LinkedList<>();\n         Collection<Integer> stopIndexes = new HashSet<>();\n-        for (PredicateSegment predicate : andPredicate.getPredicates()) {\n+        for (ExpressionSegment predicate : andPredicate.getPredicates()) {\n             if (stopIndexes.add(predicate.getStopIndex())) {\n                 createEncryptCondition(sqlStatementContext, predicate).ifPresent(result::add);\n             }\n         }\n         return result;\n     }\n     \n-    private Optional<EncryptCondition> createEncryptCondition(final SQLStatementContext sqlStatementContext, final PredicateSegment predicateSegment) {\n-        Optional<String> tableName = sqlStatementContext.getTablesContext().findTableName(predicateSegment.getColumn(), schemaMetaData);\n-        return tableName.isPresent() && encryptRule.findEncryptor(tableName.get(), predicateSegment.getColumn().getIdentifier().getValue()).isPresent()\n-                ? createEncryptCondition(predicateSegment, tableName.get()) : Optional.empty();\n+    private Optional<EncryptCondition> createEncryptCondition(final SQLStatementContext sqlStatementContext, final ExpressionSegment expression) {\n+        ColumnSegment column = null;\n+        if (expression instanceof BinaryOperationExpression && ((BinaryOperationExpression) expression).getLeft() instanceof ColumnSegment) {\n+            column = (ColumnSegment) ((BinaryOperationExpression) expression).getLeft();\n+        } else if (expression instanceof InExpression && ((InExpression) expression).getLeft() instanceof ColumnSegment) {\n+            column = (ColumnSegment) ((InExpression) expression).getLeft();\n+        } else if (expression instanceof BetweenExpression && ((BetweenExpression) expression).getLeft() instanceof ColumnSegment) {\n+            column = (ColumnSegment) ((BetweenExpression) expression).getLeft();\n+        }\n+        if (null == column) {\n+            return Optional.empty();\n+        }\n+        Optional<String> tableName = sqlStatementContext.getTablesContext().findTableName(column, schemaMetaData);\n+        return tableName.isPresent() && encryptRule.findEncryptor(tableName.get(), column.getIdentifier().getValue()).isPresent()\n+                ? createEncryptCondition(expression, tableName.get()) : Optional.empty();\n     }\n     \n-    private Optional<EncryptCondition> createEncryptCondition(final PredicateSegment predicateSegment, final String tableName) {\n-        if (predicateSegment.getRightValue() instanceof PredicateCompareRightValue) {\n-            PredicateCompareRightValue compareRightValue = (PredicateCompareRightValue) predicateSegment.getRightValue();\n-            return isSupportedOperator(compareRightValue.getOperator()) ? createCompareEncryptCondition(tableName, predicateSegment, compareRightValue) : Optional.empty();\n+    private Optional<EncryptCondition> createEncryptCondition(final ExpressionSegment expression, final String tableName) {\n+        if (expression instanceof BinaryOperationExpression) {\n+            String operator = ((BinaryOperationExpression) expression).getOperator();", "originalCommit": "87d217717ffa70121d5ece086299f64dcb9ff7ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAzMzU4OA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486033588", "bodyText": "The similar handling appears many times, so do you think it is possible to exact a function?", "author": "tristaZero", "createdAt": "2020-09-10T02:58:59Z", "path": "shardingsphere-features/shardingsphere-shadow/shardingsphere-shadow-common/src/main/java/org/apache/shardingsphere/shadow/condition/ShadowConditionEngine.java", "diffHunk": "@@ -75,10 +98,18 @@\n     }\n     \n     private Optional<ShadowCondition> createShadowCondition(final AndPredicate andPredicate) {\n-        for (PredicateSegment predicate : andPredicate.getPredicates()) {\n+        for (ExpressionSegment predicate : andPredicate.getPredicates()) {\n+            ColumnSegment column = null;\n+            if (predicate instanceof BinaryOperationExpression && ((BinaryOperationExpression) predicate).getLeft() instanceof ColumnSegment) {\n+                column = (ColumnSegment) ((BinaryOperationExpression) predicate).getLeft();\n+            } else if (predicate instanceof InExpression && ((InExpression) predicate).getLeft() instanceof ColumnSegment) {\n+                column = (ColumnSegment) ((InExpression) predicate).getLeft();", "originalCommit": "87d217717ffa70121d5ece086299f64dcb9ff7ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAzNDA5OA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486034098", "bodyText": "Why do we need this interface?", "author": "tristaZero", "createdAt": "2020-09-10T03:00:48Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/main/java/org/apache/shardingsphere/sql/parser/binder/segment/insert/values/expression/DerivedParameterMarkerExpressionSegment.java", "diffHunk": "@@ -31,4 +31,9 @@\n     public DerivedParameterMarkerExpressionSegment(final int parameterMarkerIndex) {\n         super(0, 0, parameterMarkerIndex);\n     }\n+    \n+    @Override\n+    public String getText() {\n+        return null;", "originalCommit": "87d217717ffa70121d5ece086299f64dcb9ff7ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAzNDQxMg==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486034412", "bodyText": "realtable? I suppose we do not have this concept. Do you mean actualTable?", "author": "tristaZero", "createdAt": "2020-09-10T03:02:07Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/main/java/org/apache/shardingsphere/sql/parser/binder/segment/table/TablesContext.java", "diffHunk": "@@ -44,6 +45,18 @@ public TablesContext(final SimpleTableSegment tableSegment) {\n         this(null == tableSegment ? Collections.emptyList() : Collections.singletonList(tableSegment));\n     }\n     \n+    public TablesContext(final Collection<SimpleTableSegment> tableSegments) {\n+        Map<String, SimpleTableSegment> tableMaps = new HashMap<>(1, 1);\n+        Collection<SimpleTableSegment> realtables = new LinkedList<>();\n+        for (SimpleTableSegment each : tableSegments) {\n+            if (!tableMaps.containsKey(each.getTableName().getIdentifier().getValue())) {\n+                tableMaps.put(each.getTableName().getIdentifier().getValue(), each);\n+                realtables.add(each);\n+            }\n+        }\n+        this.tables = realtables;", "originalCommit": "87d217717ffa70121d5ece086299f64dcb9ff7ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAzNDY1Nw==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486034657", "bodyText": "Please remove it.", "author": "tristaZero", "createdAt": "2020-09-10T03:03:08Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/MySQLVisitor.java", "diffHunk": "@@ -255,123 +254,185 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n+        if (null != ctx.XOR()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(\"XOR\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(ctx.logicalOperator().getText());\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n         }\n-        // TODO deal with XOR\n-        return visit(ctx.expr().get(0));\n+        NotExpression result = new NotExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setExpression((ExpressionSegment) visit(ctx.expr(0)));\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitBooleanPrimary(final BooleanPrimaryContext ctx) {\n+        if (null != ctx.IS()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+            result.setRight(new LiteralExpressionSegment(ctx.IS().getSymbol().getStopIndex() + 1, ctx.stop.getStopIndex(), new Interval(ctx.IS().getSymbol().getStopIndex() + 1,\n+                    ctx.stop.getStopIndex())));\n+            result.setOperator(\"IS\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.comparisonOperator() || null != ctx.SAFE_EQ_()) {\n             return createCompareSegment(ctx);\n         }\n-        if (null != ctx.predicate()) {\n-            return visit(ctx.predicate());\n-        }\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        //TODO deal with IS NOT? (TRUE | FALSE | UNKNOWN | NULL)\n-        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n-        return new CommonExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), text);\n+        return visit(ctx.predicate());\n     }\n     \n     private ASTNode createCompareSegment(final BooleanPrimaryContext ctx) {\n-        ASTNode leftValue = visit(ctx.booleanPrimary());\n-        if (!(leftValue instanceof ColumnSegment)) {\n-            return leftValue;\n-        }\n-        PredicateRightValue rightValue = (PredicateRightValue) createPredicateRightValue(ctx);\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (ColumnSegment) leftValue, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx) {\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        ASTNode rightValue = visit(ctx.predicate());\n-        return createPredicateRightValue(ctx, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx, final ASTNode rightValue) {\n-        if (rightValue instanceof ColumnSegment) {\n-            return rightValue;\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+        if (null != ctx.predicate()) {\n+            result.setRight((ExpressionSegment) visit(ctx.predicate()));\n+        } else {\n+            result.setRight((ExpressionSegment) visit(ctx.subquery()));\n         }\n-        return rightValue instanceof SubquerySegment ? new PredicateCompareRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                ctx.comparisonOperator().getText(), new SubqueryExpressionSegment((SubquerySegment) rightValue))\n-                : new PredicateCompareRightValue(ctx.predicate().start.getStartIndex(), ctx.predicate().stop.getStopIndex(), ctx.comparisonOperator().getText(),\n-                (ExpressionSegment) rightValue);\n+        String operator = null != ctx.SAFE_EQ_() ? ctx.SAFE_EQ_().getText() : ctx.comparisonOperator().getText();\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitPredicate(final PredicateContext ctx) {\n-        if (null != ctx.IN() && null == ctx.NOT()) {\n+        if (null != ctx.IN()) {\n             return createInSegment(ctx);\n         }\n-        if (null != ctx.BETWEEN() && null == ctx.NOT()) {\n+        if (null != ctx.BETWEEN()) {\n             return createBetweenSegment(ctx);\n         }\n-        if (1 == ctx.children.size()) {\n-            return visit(ctx.bitExpr(0));\n+        if (null != ctx.LIKE()) {\n+            return createBinaryOperationExpressionFromLike(ctx);\n         }\n-        return visitRemainPredicate(ctx);\n+        if (null != ctx.REGEXP()) {\n+            return createBinaryOperationExpressionFromRegexp(ctx);\n+        }\n+        return visit(ctx.bitExpr(0));\n     }\n     \n-    private PredicateSegment createInSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        PredicateInRightValue predicateInRightValue = null != ctx.subquery() ? new PredicateInRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                getExpressionSegments(ctx))\n-                : new PredicateInRightValue(ctx.LP_().getSymbol().getStartIndex(), ctx.RP_().getSymbol().getStopIndex(), getExpressionSegments(ctx));\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, predicateInRightValue);\n+    private InExpression createInSegment(final PredicateContext ctx) {\n+        InExpression result = new InExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        if (null != ctx.subquery()) {\n+            result.setRight(new SubqueryExpressionSegment(new SubquerySegment(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n+        } else {\n+            ListExpression listExpression = new ListExpression();\n+            listExpression.setStartIndex(ctx.LP_().getSymbol().getStartIndex());\n+            listExpression.setStopIndex(ctx.RP_().getSymbol().getStopIndex());\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.LP_().getSymbol().getStartIndex(), ctx.RP_().getSymbol().getStopIndex()));\n+            listExpression.setText(text);\n+            for (ExprContext each : ctx.expr()) {\n+                listExpression.getItems().add((ExpressionSegment) visit(each));\n+            }\n+            result.setRight(listExpression);\n+        }\n+        Boolean operator = null != ctx.NOT() ? true : false;\n+        result.setNot(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n-    private Collection<ExpressionSegment> getExpressionSegments(final PredicateContext ctx) {\n-        Collection<ExpressionSegment> result = new LinkedList<>();\n-        if (null != ctx.subquery()) {\n-            SubqueryContext subquery = ctx.subquery();\n-            result.add(new SubqueryExpressionSegment(new SubquerySegment(subquery.getStart().getStartIndex(), subquery.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n-            return result;\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            result.add((ExpressionSegment) visit(each));\n-        }\n+    private BinaryOperationExpression createBinaryOperationExpressionFromLike(final PredicateContext ctx) {\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        String operator;\n+        if (null != ctx.SOUNDS()) {\n+            ", "originalCommit": "87d217717ffa70121d5ece086299f64dcb9ff7ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b7c6f09dcaab0f4e89284db7e1020914018ac0c7", "url": "https://github.com/apache/shardingsphere/commit/b7c6f09dcaab0f4e89284db7e1020914018ac0c7", "message": "simplify code", "committedDate": "2020-09-10T09:39:38Z", "type": "commit"}, {"oid": "e054c5a97bab61bcf3e2c2a78bba889452e315ac", "url": "https://github.com/apache/shardingsphere/commit/e054c5a97bab61bcf3e2c2a78bba889452e315ac", "message": "merge from upstream master", "committedDate": "2020-09-10T10:18:24Z", "type": "commit"}, {"oid": "c79ecd541bc7e26a7e08a99c9389ff98064bcffa", "url": "https://github.com/apache/shardingsphere/commit/c79ecd541bc7e26a7e08a99c9389ff98064bcffa", "message": "fix", "committedDate": "2020-09-10T10:28:42Z", "type": "commit"}, {"oid": "222f71ebc9f31fcfd79fd5ad9cec84bb0f39e14b", "url": "https://github.com/apache/shardingsphere/commit/222f71ebc9f31fcfd79fd5ad9cec84bb0f39e14b", "message": "Merge branch 'master' into fix-6938", "committedDate": "2020-09-11T03:15:50Z", "type": "commit"}, {"oid": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "url": "https://github.com/apache/shardingsphere/commit/2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "message": "delete unused import", "committedDate": "2020-09-11T03:28:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwMTE3OA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486801178", "bodyText": "Please extract a function for this one.", "author": "tristaZero", "createdAt": "2020-09-11T06:29:13Z", "path": "shardingsphere-features/shardingsphere-encrypt/shardingsphere-encrypt-rewrite/src/main/java/org/apache/shardingsphere/encrypt/rewrite/token/generator/impl/EncryptPredicateColumnTokenGenerator.java", "diffHunk": "@@ -55,37 +60,51 @@ protected boolean isGenerateSQLTokenForEncrypt(final SQLStatementContext sqlStat\n     public Collection<SubstitutableColumnNameToken> generateSQLTokens(final SQLStatementContext sqlStatementContext) {\n         Preconditions.checkState(((WhereAvailable) sqlStatementContext).getWhere().isPresent());\n         Collection<SubstitutableColumnNameToken> result = new LinkedHashSet<>();\n-        for (AndPredicate each : ((WhereAvailable) sqlStatementContext).getWhere().get().getAndPredicates()) {\n+        Collection<AndPredicate> andPredicates = new LinkedList<>();\n+        ExpressionSegment expression = ((WhereAvailable) sqlStatementContext).getWhere().get().getExpr();\n+        ExpressionBuildUtil util = new ExpressionBuildUtil(expression);\n+        andPredicates.addAll(util.extractAndPredicates().getAndPredicates());\n+        for (AndPredicate each : andPredicates) {\n             result.addAll(generateSQLTokens(sqlStatementContext, each));\n         }\n         return result;\n     }\n     \n     private Collection<SubstitutableColumnNameToken> generateSQLTokens(final SQLStatementContext sqlStatementContext, final AndPredicate andPredicate) {\n         Collection<SubstitutableColumnNameToken> result = new LinkedList<>();\n-        for (PredicateSegment each : andPredicate.getPredicates()) {\n-            Optional<EncryptTable> encryptTable = findEncryptTable(sqlStatementContext, each);\n-            if (!encryptTable.isPresent() || !encryptTable.get().findEncryptorName(each.getColumn().getIdentifier().getValue()).isPresent()) {\n+        for (ExpressionSegment each : andPredicate.getPredicates()) {\n+            ColumnSegment column;\n+            if (each instanceof BinaryOperationExpression && ((BinaryOperationExpression) each).getLeft() instanceof ColumnSegment) {\n+                column = (ColumnSegment) ((BinaryOperationExpression) each).getLeft();\n+            } else if (each instanceof InExpression && ((InExpression) each).getLeft() instanceof ColumnSegment) {\n+                column = (ColumnSegment) ((InExpression) each).getLeft();\n+            } else if (each instanceof BetweenExpression && ((BetweenExpression) each).getLeft() instanceof ColumnSegment) {\n+                column = (ColumnSegment) ((BetweenExpression) each).getLeft();\n+            } else {\n+                continue;\n+            }\n+            Optional<EncryptTable> encryptTable = findEncryptTable(sqlStatementContext, column);", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwMTQ2NQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486801465", "bodyText": "Please remove it.", "author": "tristaZero", "createdAt": "2020-09-11T06:30:02Z", "path": "shardingsphere-features/shardingsphere-shadow/shardingsphere-shadow-common/src/main/java/org/apache/shardingsphere/shadow/condition/ShadowConditionEngine.java", "diffHunk": "@@ -56,7 +59,12 @@\n         if (!whereSegment.isPresent()) {\n             return Optional.empty();\n         }\n-        for (AndPredicate each : whereSegment.get().getAndPredicates()) {\n+    ", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwMjE3Nw==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486802177", "bodyText": "An expressive name is needed.", "author": "tristaZero", "createdAt": "2020-09-11T06:32:01Z", "path": "shardingsphere-features/shardingsphere-shadow/shardingsphere-shadow-route/src/main/java/org/apache/shardingsphere/shadow/route/engine/judge/impl/PreparedShadowDataSourceJudgeEngine.java", "diffHunk": "@@ -61,27 +63,47 @@ public boolean isShadow() {\n             }\n             return false;\n         }\n-        if (sqlStatementContext instanceof WhereAvailable) {\n-            Optional<WhereSegment> whereSegment = ((WhereAvailable) sqlStatementContext).getWhere();\n-            if (!whereSegment.isPresent()) {\n-                return false;\n-            }\n-            Collection<AndPredicate> andPredicates = whereSegment.get().getAndPredicates();\n-            for (AndPredicate andPredicate : andPredicates) {\n-                if (judgePredicateSegments(andPredicate.getPredicates())) {\n-                    return true;\n-                }\n+        if (!(sqlStatementContext instanceof WhereAvailable)) {\n+            return false;\n+        }\n+        Optional<WhereSegment> whereSegment = ((WhereAvailable) sqlStatementContext).getWhere();\n+        if (!whereSegment.isPresent()) {\n+            return false;\n+        }\n+        Collection<AndPredicate> andPredicates = new LinkedList<>();\n+        ExpressionSegment expression = whereSegment.get().getExpr();\n+        ExpressionBuildUtil util = new ExpressionBuildUtil(expression);\n+        andPredicates.addAll(util.extractAndPredicates().getAndPredicates());\n+        for (AndPredicate andPredicate : andPredicates) {\n+            if (judgePredicateSegments(andPredicate.getPredicates())) {", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwMzAxMA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486803010", "bodyText": "Please remove", "author": "tristaZero", "createdAt": "2020-09-11T06:34:11Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/test/java/org/apache/shardingsphere/sql/parser/binder/segment/select/pagination/engine/RowNumberPaginationContextEngineTest.java", "diffHunk": "@@ -133,14 +134,16 @@ private void assertCreatePaginationContextWhenRowNumberAliasPresentAndRowNumberP\n     }\n     \n     private void assertCreatePaginationContextWhenOffsetSegmentInstanceOfNumberLiteralRowNumberValueSegmentWithGivenOperator(final String operator) {\n-        PredicateCompareRightValue predicateCompareRightValue = new PredicateCompareRightValue(0, 10, operator, new LiteralExpressionSegment(0, 10, 100));\n-        AndPredicate andPredicate = new AndPredicate();\n-        andPredicate.getPredicates().add(new PredicateSegment(0, 10, new ColumnSegment(0, 10, new IdentifierValue(ROW_NUMBER_COLUMN_NAME)), predicateCompareRightValue));\n         Projection projectionWithRowNumberAlias = new ColumnProjection(null, ROW_NUMBER_COLUMN_NAME, ROW_NUMBER_COLUMN_ALIAS);\n         ProjectionsContext projectionsContext = new ProjectionsContext(0, 0, false, Collections.singleton(projectionWithRowNumberAlias));\n+    ", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwMzA3OA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486803078", "bodyText": "Please remove it.", "author": "tristaZero", "createdAt": "2020-09-11T06:34:23Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/test/java/org/apache/shardingsphere/sql/parser/binder/segment/select/pagination/engine/RowNumberPaginationContextEngineTest.java", "diffHunk": "@@ -133,14 +134,16 @@ private void assertCreatePaginationContextWhenRowNumberAliasPresentAndRowNumberP\n     }\n     \n     private void assertCreatePaginationContextWhenOffsetSegmentInstanceOfNumberLiteralRowNumberValueSegmentWithGivenOperator(final String operator) {\n-        PredicateCompareRightValue predicateCompareRightValue = new PredicateCompareRightValue(0, 10, operator, new LiteralExpressionSegment(0, 10, 100));\n-        AndPredicate andPredicate = new AndPredicate();\n-        andPredicate.getPredicates().add(new PredicateSegment(0, 10, new ColumnSegment(0, 10, new IdentifierValue(ROW_NUMBER_COLUMN_NAME)), predicateCompareRightValue));\n         Projection projectionWithRowNumberAlias = new ColumnProjection(null, ROW_NUMBER_COLUMN_NAME, ROW_NUMBER_COLUMN_ALIAS);\n         ProjectionsContext projectionsContext = new ProjectionsContext(0, 0, false, Collections.singleton(projectionWithRowNumberAlias));\n+    \n+        BinaryOperationExpression expression = new BinaryOperationExpression();\n+        expression.setOperator(operator);\n+        expression.setRight(new LiteralExpressionSegment(0, 10, 100));\n+        expression.setLeft(new ColumnSegment(0, 10, new IdentifierValue(ROW_NUMBER_COLUMN_NAME)));\n         ", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwMzQ3Mw==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486803473", "bodyText": "A redundant line is needed to remove.", "author": "tristaZero", "createdAt": "2020-09-11T06:35:18Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/test/java/org/apache/shardingsphere/sql/parser/binder/statement/dml/UpdateStatementContextTest.java", "diffHunk": "@@ -47,29 +47,31 @@\n     @Mock\n     private WhereSegment whereSegment;\n     \n-    @Mock\n-    private AndPredicate andPredicate;\n-    \n-    @Mock\n-    private PredicateSegment predicateSegment;\n-    \n     @Mock\n     private ColumnSegment columnSegment;\n     \n     @Test\n     public void assertNewInstance() {\n         when(columnSegment.getOwner()).thenReturn(Optional.of(new OwnerSegment(0, 0, new IdentifierValue(\"tbl_2\"))));\n-        when(predicateSegment.getColumn()).thenReturn(columnSegment);\n-        when(andPredicate.getPredicates()).thenReturn(Collections.singletonList(predicateSegment));\n-        when(whereSegment.getAndPredicates()).thenReturn(Lists.newLinkedList(Arrays.asList(andPredicate)));\n-        SimpleTableSegment simpleTableSegment = new SimpleTableSegment(0, 0, new IdentifierValue(\"tbl_1\"));\n+        BinaryOperationExpression expression = new BinaryOperationExpression();\n+        expression.setLeft(columnSegment);\n+        ", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwMzg3NA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486803874", "bodyText": "Please extract a function", "author": "tristaZero", "createdAt": "2020-09-11T06:36:21Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/MySQLVisitor.java", "diffHunk": "@@ -255,123 +254,173 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n+        if (null != ctx.XOR()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(\"XOR\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNDI0OA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486804248", "bodyText": "Please remove it.", "author": "tristaZero", "createdAt": "2020-09-11T06:37:23Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-postgresql/src/main/java/org/apache/shardingsphere/sql/parser/postgresql/visitor/impl/PostgreSQLDMLVisitor.java", "diffHunk": "@@ -459,101 +451,88 @@ public ASTNode visitTargetEl(final TargetElContext ctx) {\n         return result;\n     }\n     \n-    private ColumnProjectionSegment generateColumnProjection(final ColumnrefContext ctx) {\n-        if (null != ctx.indirection()) {\n-            PostgreSQLStatementParser.AttrNameContext attrName = ctx.indirection().indirectionEl().attrName();\n-            ColumnSegment columnSegment = new ColumnSegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex(), new IdentifierValue(attrName.getText()));\n-            OwnerSegment owner = new OwnerSegment(ctx.colId().start.getStartIndex(), ctx.colId().stop.getStopIndex(), new IdentifierValue(ctx.colId().getText()));\n-            columnSegment.setOwner(owner);\n-            return new ColumnProjectionSegment(columnSegment);\n-        }\n-        ColumnSegment columnSegment = new ColumnSegment(ctx.colId().start.getStartIndex(), ctx.colId().stop.getStopIndex(), new IdentifierValue(ctx.colId().getText()));\n-        return new ColumnProjectionSegment(columnSegment);\n-    }\n-    \n     @Override\n     public ASTNode visitFromClause(final FromClauseContext ctx) {\n         return visit(ctx.fromList());\n     }\n     \n     @Override\n-    public ASTNode visitFromList(final PostgreSQLStatementParser.FromListContext ctx) {\n-        CollectionValue<TableReferenceSegment> result = new CollectionValue<>();\n+    public ASTNode visitFromList(final FromListContext ctx) {\n         if (null != ctx.fromList()) {\n-            result.getValue().addAll(((CollectionValue<TableReferenceSegment>) visit(ctx.fromList())).getValue());\n+            JoinTableSegment result = new JoinTableSegment();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((TableSegment) visit(ctx.fromList()));\n+            result.setRight((TableSegment) visit(ctx.tableReference()));\n+            return result;\n         }\n-        result.getValue().add((TableReferenceSegment) visit(ctx.tableReference()));\n+        TableSegment result = (TableSegment) visit(ctx.tableReference());\n         return result;\n     }\n     \n     @Override\n     public ASTNode visitTableReference(final TableReferenceContext ctx) {\n-        if (null != ctx.tableReference()) {\n-            TableReferenceSegment result = (TableReferenceSegment) visit(ctx.tableReference());\n-            if (null != ctx.joinedTable()) {\n-                result.getJoinedTables().add((JoinedTableSegment) visit(ctx.joinedTable()));\n-            }\n-            return result;\n-        }\n         if (null != ctx.relationExpr()) {\n-            TableReferenceSegment result = new TableReferenceSegment();\n-            SimpleTableSegment table = generateTableFromRelationExpr(ctx.relationExpr());\n+            SimpleTableSegment result = generateTableFromRelationExpr(ctx.relationExpr());\n             if (null != ctx.aliasClause()) {\n-                table.setAlias((AliasSegment) visit(ctx.aliasClause()));\n+                result.setAlias((AliasSegment) visit(ctx.aliasClause()));\n             }\n-            TableFactorSegment tableFactorSegment = new TableFactorSegment();\n-            tableFactorSegment.setTable(table);\n-            result.setTableFactor(tableFactorSegment);\n             return result;\n         }\n         if (null != ctx.selectWithParens()) {\n-            TableReferenceSegment result = new TableReferenceSegment();\n             SelectStatement select = (SelectStatement) visit(ctx.selectWithParens());\n             SubquerySegment subquery = new SubquerySegment(ctx.selectWithParens().start.getStartIndex(), ctx.selectWithParens().stop.getStopIndex(), select);\n             AliasSegment alias = null != ctx.aliasClause() ? (AliasSegment) visit(ctx.aliasClause()) : null;\n-            SubqueryTableSegment subqueryTable = new SubqueryTableSegment(subquery);\n-            subqueryTable.setAlias(alias);\n-            TableFactorSegment tableFactor = new TableFactorSegment();\n-            tableFactor.setTable(subqueryTable);\n-            result.setTableFactor(tableFactor);\n+            SubqueryTableSegment result = new SubqueryTableSegment(subquery);\n+            result.setAlias(alias);\n+            return result;\n+        }\n+        if (null != ctx.tableReference()) {\n+            JoinTableSegment result = new JoinTableSegment();\n+            int startIndex = null != ctx.LP_() ? ctx.LP_().getSymbol().getStartIndex() : ctx.tableReference().start.getStartIndex();\n+            int stopIndex = 0;\n+            AliasSegment alias = null;\n+            if (null != ctx.aliasClause()) {\n+                alias = (AliasSegment) visit(ctx.aliasClause());\n+                startIndex = null != ctx.RP_() ? ctx.RP_().getSymbol().getStopIndex() : ctx.joinedTable().stop.getStopIndex();\n+            } else {\n+                stopIndex = null != ctx.RP_() ? ctx.RP_().getSymbol().getStopIndex() : ctx.tableReference().start.getStopIndex();\n+            }\n+    ", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNDk0Mg==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486804942", "bodyText": "Final ?", "author": "tristaZero", "createdAt": "2020-09-11T06:39:19Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/main/java/org/apache/shardingsphere/sql/parser/sql/common/segment/dml/item/BinaryOperationProjection.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.sql.common.segment.dml.item;\n+\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.BinaryOperationExpression;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.AliasAvailable;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.AliasSegment;\n+\n+import java.util.Optional;\n+\n+@Setter\n+@Getter\n+public class BinaryOperationProjection implements ProjectionSegment, AliasAvailable {", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNTExMA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486805110", "bodyText": "Fianl?", "author": "tristaZero", "createdAt": "2020-09-11T06:39:42Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/main/java/org/apache/shardingsphere/sql/parser/sql/common/segment/generic/table/DeleteMultiTableSegment.java", "diffHunk": "@@ -15,40 +15,35 @@\n  * limitations under the License.\n  */\n \n-package org.apache.shardingsphere.sql.parser.sql.common.segment.dml;\n+package org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table;\n \n import lombok.Getter;\n import lombok.Setter;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.SQLSegment;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.AliasSegment;\n \n-import java.util.Collection;\n import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Optional;\n \n-@Getter\n @Setter\n-public final class JoinedTableSegment implements SQLSegment {\n+@Getter\n+public class DeleteMultiTableSegment implements TableSegment {", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNTI5Mg==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486805292", "bodyText": "Final?", "author": "tristaZero", "createdAt": "2020-09-11T06:40:06Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/main/java/org/apache/shardingsphere/sql/parser/sql/common/segment/generic/table/JoinTableSegment.java", "diffHunk": "@@ -15,26 +15,39 @@\n  * limitations under the License.\n  */\n \n-package org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate;\n+package org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table;\n \n import lombok.Getter;\n-import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.column.ColumnSegment;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.SQLSegment;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.value.PredicateRightValue;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.ExpressionSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.AliasSegment;\n+\n+import java.util.List;\n+import java.util.Optional;\n \n-/**\n- * Predicate segment.\n- */\n-@RequiredArgsConstructor\n @Getter\n-public final class PredicateSegment implements SQLSegment {\n+@Setter\n+public class JoinTableSegment implements TableSegment {", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNTQ2Nw==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486805467", "bodyText": "Final?", "author": "tristaZero", "createdAt": "2020-09-11T06:40:34Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/main/java/org/apache/shardingsphere/sql/parser/sql/common/util/ExpressionBuildUtil.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.sql.common.util;\n+\n+import lombok.RequiredArgsConstructor;\n+import org.apache.shardingsphere.sql.parser.sql.common.constant.LogicalOperator;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.BinaryOperationExpression;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.ExpressionSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.AndPredicate;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.OrPredicateSegment;\n+\n+import java.util.Optional;\n+\n+@RequiredArgsConstructor\n+public class ExpressionBuildUtil {", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgwNTYyOA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486805628", "bodyText": "Remove", "author": "tristaZero", "createdAt": "2020-09-11T06:41:03Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/main/java/org/apache/shardingsphere/sql/parser/sql/common/util/TableExtractUtils.java", "diffHunk": "@@ -17,293 +17,191 @@\n \n package org.apache.shardingsphere.sql.parser.sql.common.util;\n \n-import com.google.common.base.Preconditions;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.JoinSpecificationSegment;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.JoinedTableSegment;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.TableReferenceSegment;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.OwnerAvailable;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.OwnerSegment;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.TableFactorSegment;\n+import lombok.Getter;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.column.ColumnSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.BetweenExpression;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.BinaryOperationExpression;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.ExpressionSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.InExpression;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.ListExpression;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.subquery.SubqueryExpressionSegment;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.item.ColumnProjectionSegment;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.item.ProjectionSegment;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.item.ProjectionsSegment;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.item.SubqueryProjectionSegment;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.order.item.ColumnOrderByItemSegment;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.order.item.OrderByItemSegment;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.AndPredicate;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.PredicateSegment;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.WhereSegment;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.value.PredicateBetweenRightValue;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.value.PredicateCompareRightValue;\n-import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.value.PredicateInRightValue;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.OwnerAvailable;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.OwnerSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.JoinTableSegment;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SubqueryTableSegment;\n import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.TableSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.DeleteStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.InsertStatement;\n import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.SelectStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.UpdateStatement;\n \n import java.util.Collection;\n import java.util.LinkedList;\n import java.util.Optional;\n \n public final class TableExtractUtils {\n+    \n+    @Getter\n+    private Collection<SimpleTableSegment> rewriteTables = new LinkedList<>();\n+    \n+    @Getter\n+    private Collection<TableSegment> tableContext = new LinkedList<>();\n+    \n     /**\n-     * Get table that should be rewrited from SelectStatement.\n+     * Extract table that should be rewrited from SelectStatement.\n      *\n      * @param selectStatement SelectStatement.\n-     * @return SimpleTableSegment collection\n      */\n-    public static Collection<SimpleTableSegment> getTablesFromSelect(final SelectStatement selectStatement) {\n-        Collection<SimpleTableSegment> result = new LinkedList<>();\n-        Collection<TableSegment> realTables = new LinkedList<>();\n-        Collection<TableSegment> allTables = new LinkedList<>();\n-        for (TableReferenceSegment each : selectStatement.getTableReferences()) {\n-            allTables.addAll(getTablesFromTableReference(each));\n-            realTables.addAll(getRealTablesFromTableReference(each));\n+    public void extractTablesFromSelect(final SelectStatement selectStatement) {\n+        if (null != selectStatement.getFrom()) {\n+            extractTablesFromTableSegment(selectStatement.getFrom());\n         }\n         if (selectStatement.getWhere().isPresent()) {\n-            allTables.addAll(getAllTablesFromWhere(selectStatement.getWhere().get(), realTables));\n+            extractTablesFromExpression(selectStatement.getWhere().get().getExpr());\n+        }\n+        if (null != selectStatement.getProjections()) {\n+            extractTablesFromProjections(selectStatement.getProjections());\n         }\n-        result.addAll(getAllTablesFromProjections(selectStatement.getProjections(), realTables));\n         if (selectStatement.getGroupBy().isPresent()) {\n-            result.addAll(getAllTablesFromOrderByItems(selectStatement.getGroupBy().get().getGroupByItems(), realTables));\n+            extractTablesFromOrderByItems(selectStatement.getGroupBy().get().getGroupByItems());\n         }\n         if (selectStatement.getOrderBy().isPresent()) {\n-            result.addAll(getAllTablesFromOrderByItems(selectStatement.getOrderBy().get().getOrderByItems(), realTables));\n-        }\n-        for (TableSegment each : allTables) {\n-            if (each instanceof SubqueryTableSegment) {\n-                result.addAll(getTablesFromSelect(((SubqueryTableSegment) each).getSubquery().getSelect()));\n-            } else {\n-                result.add((SimpleTableSegment) each);\n-            }\n+            extractTablesFromOrderByItems(selectStatement.getOrderBy().get().getOrderByItems());\n         }\n-        return result;\n     }\n     \n-    /**\n-     * Get real table that should be rewrited from SelectStatement.\n-     *\n-     * @param selectStatement SelectStatement.\n-     * @return SimpleTableSegment collection\n-     */\n-    public static Collection<SimpleTableSegment> getSimpleTableFromSelect(final SelectStatement selectStatement) {\n-        Collection<SimpleTableSegment> result = new LinkedList<>();\n-        Collection<TableSegment> realTables = new LinkedList<>();\n-        for (TableReferenceSegment each : selectStatement.getTableReferences()) {\n-            realTables.addAll(getRealTablesFromTableReference(each));\n+    private void extractTablesFromTableSegment(final TableSegment tableSegment) {\n+        if (tableSegment instanceof SimpleTableSegment) {\n+            tableContext.add(tableSegment);\n+            rewriteTables.add((SimpleTableSegment) tableSegment);\n         }\n-        for (TableSegment each : realTables) {\n-            if (each instanceof SubqueryTableSegment) {\n-                result.addAll(getSimpleTableFromSelect(((SubqueryTableSegment) each).getSubquery().getSelect()));\n-            } else {\n-                result.add((SimpleTableSegment) each);\n-            }\n+        if (tableSegment instanceof SubqueryTableSegment) {\n+            tableContext.add(tableSegment);\n+            TableExtractUtils utils = new TableExtractUtils();\n+            utils.extractTablesFromSelect(((SubqueryTableSegment) tableSegment).getSubquery().getSelect());\n+            rewriteTables.addAll(utils.getRewriteTables());\n         }\n-        return result;\n-    }\n-    \n-    private static Collection<TableSegment> getTablesFromTableReference(final TableReferenceSegment tableReferenceSegment) {\n-        Collection<TableSegment> result = new LinkedList<>();\n-        if (null != tableReferenceSegment.getTableFactor()) {\n-            result.addAll(getTablesFromTableFactor(tableReferenceSegment.getTableFactor()));\n+        if (tableSegment instanceof JoinTableSegment) {\n+            extractTablesFromTableSegment(((JoinTableSegment) tableSegment).getLeft());\n+            extractTablesFromTableSegment(((JoinTableSegment) tableSegment).getRight());\n+            extractTablesFromExpression(((JoinTableSegment) tableSegment).getCondition());\n         }\n-        if (null != tableReferenceSegment.getJoinedTables()) {\n-            for (JoinedTableSegment each : tableReferenceSegment.getJoinedTables()) {\n-                result.addAll(getTablesFromJoinTable(each, result));\n-            }\n-        }\n-        return result;\n     }\n     \n-    private static Collection<TableSegment> getRealTablesFromTableReference(final TableReferenceSegment tableReferenceSegment) {\n-        Collection<TableSegment> result = new LinkedList<>();\n-        if (null != tableReferenceSegment.getTableFactor()) {\n-            result.addAll(getRealTablesFromTableFactor(tableReferenceSegment.getTableFactor()));\n-        }\n-        if (null != tableReferenceSegment.getJoinedTables()) {\n-            for (JoinedTableSegment each : tableReferenceSegment.getJoinedTables()) {\n-                result.addAll(getRealTablesFromJoinTable(each));\n+    private void extractTablesFromExpression(final ExpressionSegment expressionSegment) {\n+        if (expressionSegment instanceof ColumnSegment) {\n+            if (((ColumnSegment) expressionSegment).getOwner().isPresent() && needRewrite(((ColumnSegment) expressionSegment).getOwner().get())) {\n+                OwnerSegment ownerSegment = ((ColumnSegment) expressionSegment).getOwner().get();\n+                rewriteTables.add(new SimpleTableSegment(ownerSegment.getStartIndex(), ownerSegment.getStopIndex(), ownerSegment.getIdentifier()));\n             }\n         }\n-        return result;\n-    }\n-    \n-    private static Collection<TableSegment> getTablesFromTableFactor(final TableFactorSegment tableFactorSegment) {\n-        Collection<TableSegment> result = new LinkedList<>();\n-        if (null != tableFactorSegment.getTable() && tableFactorSegment.getTable() instanceof SimpleTableSegment) {\n-            result.add(tableFactorSegment.getTable());\n-        }\n-        if (null != tableFactorSegment.getTable() && tableFactorSegment.getTable() instanceof SubqueryTableSegment) {\n-            result.add(tableFactorSegment.getTable());\n-        }\n-        if (null != tableFactorSegment.getTableReferences() && !tableFactorSegment.getTableReferences().isEmpty()) {\n-            for (TableReferenceSegment each: tableFactorSegment.getTableReferences()) {\n-                result.addAll(getTablesFromTableReference(each));\n+        if (expressionSegment instanceof ListExpression) {\n+            for (ExpressionSegment each : ((ListExpression) expressionSegment).getItems()) {\n+                extractTablesFromExpression(each);\n             }\n         }\n-        return result;\n-    }\n-    \n-    private static Collection<TableSegment> getRealTablesFromTableFactor(final TableFactorSegment tableFactorSegment) {\n-        Collection<TableSegment> result = new LinkedList<>();\n-        if (null != tableFactorSegment.getTable() && tableFactorSegment.getTable() instanceof SimpleTableSegment) {\n-            result.add(tableFactorSegment.getTable());\n+        if (expressionSegment instanceof BetweenExpression) {\n+            extractTablesFromExpression(((BetweenExpression) expressionSegment).getLeft());\n+            extractTablesFromExpression(((BetweenExpression) expressionSegment).getBetweenExpr());\n+            extractTablesFromExpression(((BetweenExpression) expressionSegment).getAndExpr());\n         }\n-        if (null != tableFactorSegment.getTable() && tableFactorSegment.getTable() instanceof SubqueryTableSegment) {\n-            result.add(tableFactorSegment.getTable());\n+        if (expressionSegment instanceof InExpression) {\n+            extractTablesFromExpression(((InExpression) expressionSegment).getLeft());\n+            extractTablesFromExpression(((InExpression) expressionSegment).getRight());\n         }\n-        if (null != tableFactorSegment.getTableReferences() && !tableFactorSegment.getTableReferences().isEmpty()) {\n-            for (TableReferenceSegment each: tableFactorSegment.getTableReferences()) {\n-                result.addAll(getRealTablesFromTableReference(each));\n-            }\n+        if (expressionSegment instanceof SubqueryExpressionSegment) {\n+            extractTablesFromSelect(((SubqueryExpressionSegment) expressionSegment).getSubquery().getSelect());\n         }\n-        return result;\n-    }\n-    \n-    private static Collection<TableSegment> getTablesFromJoinTable(final JoinedTableSegment joinedTableSegment, final Collection<TableSegment> tableSegments) {\n-        Collection<TableSegment> result = new LinkedList<>();\n-        Collection<TableSegment> realTables = new LinkedList<>();\n-        realTables.addAll(tableSegments);\n-        if (null != joinedTableSegment.getTableFactor()) {\n-            result.addAll(getTablesFromTableFactor(joinedTableSegment.getTableFactor()));\n-            realTables.addAll(getTablesFromTableFactor(joinedTableSegment.getTableFactor()));\n-        }\n-        if (null != joinedTableSegment.getJoinSpecification()) {\n-            result.addAll(getTablesFromJoinSpecification(joinedTableSegment.getJoinSpecification(), realTables));\n-        }\n-        return result;\n-    }\n-    \n-    private static Collection<TableSegment> getRealTablesFromJoinTable(final JoinedTableSegment joinedTableSegment) {\n-        Collection<TableSegment> result = new LinkedList<>();\n-        if (null != joinedTableSegment.getTableFactor()) {\n-            result.addAll(getTablesFromTableFactor(joinedTableSegment.getTableFactor()));\n+        if (expressionSegment instanceof BinaryOperationExpression) {\n+            extractTablesFromExpression(((BinaryOperationExpression) expressionSegment).getLeft());\n+            extractTablesFromExpression(((BinaryOperationExpression) expressionSegment).getRight());\n         }\n-        return result;\n     }\n     \n-    private static Collection<SimpleTableSegment> getTablesFromJoinSpecification(final JoinSpecificationSegment joinSpecificationSegment, final Collection<TableSegment> tableSegments) {\n-        Collection<SimpleTableSegment> result = new LinkedList<>();\n-        Collection<AndPredicate> andPredicates = joinSpecificationSegment.getAndPredicates();\n-        for (AndPredicate each : andPredicates) {\n-            for (PredicateSegment e : each.getPredicates()) {\n-                if (null != e.getColumn() && (e.getColumn().getOwner().isPresent())) {\n-                    OwnerSegment ownerSegment = e.getColumn().getOwner().get();\n-                    if (isTable(ownerSegment, tableSegments)) {\n-                        result.add(new SimpleTableSegment(ownerSegment.getStartIndex(), ownerSegment.getStopIndex(), ownerSegment.getIdentifier()));\n-                    }\n+    private void extractTablesFromProjections(final ProjectionsSegment projections) {\n+        for (ProjectionSegment each : projections.getProjections()) {\n+            if (each instanceof SubqueryProjectionSegment) {\n+                extractTablesFromSelect(((SubqueryProjectionSegment) each).getSubquery().getSelect());\n+            } else if (each instanceof OwnerAvailable) {\n+                if (((OwnerAvailable) each).getOwner().isPresent() && needRewrite(((OwnerAvailable) each).getOwner().get())) {\n+                    OwnerSegment ownerSegment = ((OwnerAvailable) each).getOwner().get();\n+                    rewriteTables.add(new SimpleTableSegment(ownerSegment.getStartIndex(), ownerSegment.getStopIndex(), ownerSegment.getIdentifier()));\n                 }\n-                if (null != e.getRightValue() && (e.getRightValue() instanceof ColumnSegment) && ((ColumnSegment) e.getRightValue()).getOwner().isPresent()) {\n-                    OwnerSegment ownerSegment = ((ColumnSegment) e.getRightValue()).getOwner().get();\n-                    if (isTable(ownerSegment, tableSegments)) {\n-                        result.add(new SimpleTableSegment(ownerSegment.getStartIndex(), ownerSegment.getStopIndex(), ownerSegment.getIdentifier()));\n-                    }\n+            } else if (each instanceof ColumnProjectionSegment) {\n+                if (((ColumnProjectionSegment) each).getColumn().getOwner().isPresent() && needRewrite(((ColumnProjectionSegment) each).getColumn().getOwner().get())) {\n+                    OwnerSegment ownerSegment = ((ColumnProjectionSegment) each).getColumn().getOwner().get();\n+                    rewriteTables.add(new SimpleTableSegment(ownerSegment.getStartIndex(), ownerSegment.getStopIndex(), ownerSegment.getIdentifier()));\n                 }\n             }\n         }\n-        return result;\n     }\n     \n-    private static Collection<SimpleTableSegment> getAllTablesFromWhere(final WhereSegment where, final Collection<TableSegment> tableSegments) {\n-        Collection<SimpleTableSegment> result = new LinkedList<>();\n-        for (AndPredicate each : where.getAndPredicates()) {\n-            for (PredicateSegment predicate : each.getPredicates()) {\n-                result.addAll(getAllTablesFromPredicate(predicate, tableSegments));\n-            }\n-        }\n-        return result;\n-    }\n-    \n-    private static Collection<SimpleTableSegment> getAllTablesFromPredicate(final PredicateSegment predicate, final Collection<TableSegment> tableSegments) {\n-        Collection<SimpleTableSegment> result = new LinkedList<>();\n-        if (predicate.getColumn().getOwner().isPresent() && isTable(predicate.getColumn().getOwner().get(), tableSegments)) {\n-            OwnerSegment segment = predicate.getColumn().getOwner().get();\n-            result.add(new SimpleTableSegment(segment.getStartIndex(), segment.getStopIndex(), segment.getIdentifier()));\n-        }\n-        if (predicate.getRightValue() instanceof PredicateCompareRightValue) {\n-            if (((PredicateCompareRightValue) predicate.getRightValue()).getExpression() instanceof SubqueryExpressionSegment) {\n-                result.addAll(TableExtractUtils.getTablesFromSelect(((SubqueryExpressionSegment) ((PredicateCompareRightValue) predicate.getRightValue()).getExpression()).getSubquery().getSelect()));\n-            }\n-        }\n-        if (predicate.getRightValue() instanceof PredicateInRightValue) {\n-            for (ExpressionSegment expressionSegment : ((PredicateInRightValue) predicate.getRightValue()).getSqlExpressions()) {\n-                if (expressionSegment instanceof SubqueryExpressionSegment) {\n-                    result.addAll(TableExtractUtils.getTablesFromSelect(((SubqueryExpressionSegment) expressionSegment).getSubquery().getSelect()));\n+    private void extractTablesFromOrderByItems(final Collection<OrderByItemSegment> orderByItems) {\n+        for (OrderByItemSegment each : orderByItems) {\n+            if (each instanceof ColumnOrderByItemSegment) {\n+                Optional<OwnerSegment> owner = ((ColumnOrderByItemSegment) each).getColumn().getOwner();\n+                if (owner.isPresent() && needRewrite(owner.get())) {\n+                    OwnerSegment segment = ((ColumnOrderByItemSegment) each).getColumn().getOwner().get();\n+                    rewriteTables.add(new SimpleTableSegment(segment.getStartIndex(), segment.getStopIndex(), segment.getIdentifier()));\n                 }\n             }\n-        } \n-        if (predicate.getRightValue() instanceof PredicateBetweenRightValue) {\n-            if (((PredicateBetweenRightValue) predicate.getRightValue()).getBetweenExpression() instanceof SubqueryExpressionSegment) {\n-                SelectStatement subquerySelect = ((SubqueryExpressionSegment) (((PredicateBetweenRightValue) predicate.getRightValue()).getBetweenExpression())).getSubquery().getSelect();\n-                result.addAll(TableExtractUtils.getTablesFromSelect(subquerySelect));    \n-            }\n-            if (((PredicateBetweenRightValue) predicate.getRightValue()).getAndExpression() instanceof SubqueryExpressionSegment) {\n-                SelectStatement subquerySelect = ((SubqueryExpressionSegment) (((PredicateBetweenRightValue) predicate.getRightValue()).getAndExpression())).getSubquery().getSelect();\n-                result.addAll(TableExtractUtils.getTablesFromSelect(subquerySelect));\n-            }\n-        } \n-        if (predicate.getRightValue() instanceof ColumnSegment) {\n-            Preconditions.checkState(((ColumnSegment) predicate.getRightValue()).getOwner().isPresent());\n-            OwnerSegment segment = ((ColumnSegment) predicate.getRightValue()).getOwner().get();\n-            result.add(new SimpleTableSegment(segment.getStartIndex(), segment.getStopIndex(), segment.getIdentifier()));\n         }\n-        return result;\n     }\n     \n-    private static Collection<SimpleTableSegment> getAllTablesFromProjections(final ProjectionsSegment projections, final Collection<TableSegment> tableSegments) {\n-        Collection<SimpleTableSegment> result = new LinkedList<>();\n-        if (null == projections || projections.getProjections().isEmpty()) {\n-            return result;\n-        }\n-        for (ProjectionSegment each : projections.getProjections()) {\n-            if (each instanceof SubqueryProjectionSegment) {\n-                result.addAll(getTablesFromSelect(((SubqueryProjectionSegment) each).getSubquery().getSelect()));\n-            } else {\n-                Optional<SimpleTableSegment> table = getTableSegment(each, tableSegments);\n-                table.ifPresent(result::add);\n-            }\n+    /**\n+     * Extract table that should be rewrited from DeleteStatement.\n+     *\n+     * @param deleteStatement DeleteStatement.\n+     */\n+    public void extractTablesFromDelete(final DeleteStatement deleteStatement) {\n+        ", "originalCommit": "2ed972dfe16bc14adc238c6c5e6ea2775c69ddf6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "68aa0cb67ac882f5abea28c5f02b375a29cacc30", "url": "https://github.com/apache/shardingsphere/commit/68aa0cb67ac882f5abea28c5f02b375a29cacc30", "message": "fix", "committedDate": "2020-09-11T07:52:07Z", "type": "commit"}, {"oid": "cc17c1f2871ba6455cbaf179f82ef9b9f3fe725d", "url": "https://github.com/apache/shardingsphere/commit/cc17c1f2871ba6455cbaf179f82ef9b9f3fe725d", "message": "fix", "committedDate": "2020-09-11T08:47:28Z", "type": "commit"}, {"oid": "03ee18274ca59ed49cdd029e4d058316e255e5de", "url": "https://github.com/apache/shardingsphere/commit/03ee18274ca59ed49cdd029e4d058316e255e5de", "message": "fix", "committedDate": "2020-09-11T09:51:26Z", "type": "commit"}, {"oid": "ec00860ecaf059bd9efe7fb732d2771d788ff360", "url": "https://github.com/apache/shardingsphere/commit/ec00860ecaf059bd9efe7fb732d2771d788ff360", "message": "fix", "committedDate": "2020-09-11T10:13:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzNjU0Ng==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486936546", "bodyText": "return Optional", "author": "tristaZero", "createdAt": "2020-09-11T09:58:01Z", "path": "shardingsphere-features/shardingsphere-encrypt/shardingsphere-encrypt-rewrite/src/main/java/org/apache/shardingsphere/encrypt/rewrite/condition/EncryptConditionEngine.java", "diffHunk": "@@ -81,50 +88,65 @@\n     private Collection<EncryptCondition> createEncryptConditions(final SQLStatementContext sqlStatementContext, final AndPredicate andPredicate) {\n         Collection<EncryptCondition> result = new LinkedList<>();\n         Collection<Integer> stopIndexes = new HashSet<>();\n-        for (PredicateSegment predicate : andPredicate.getPredicates()) {\n+        for (ExpressionSegment predicate : andPredicate.getPredicates()) {\n             if (stopIndexes.add(predicate.getStopIndex())) {\n                 createEncryptCondition(sqlStatementContext, predicate).ifPresent(result::add);\n             }\n         }\n         return result;\n     }\n     \n-    private Optional<EncryptCondition> createEncryptCondition(final SQLStatementContext sqlStatementContext, final PredicateSegment predicateSegment) {\n-        Optional<String> tableName = sqlStatementContext.getTablesContext().findTableName(predicateSegment.getColumn(), schemaMetaData);\n-        return tableName.isPresent() && encryptRule.findEncryptor(tableName.get(), predicateSegment.getColumn().getIdentifier().getValue()).isPresent()\n-                ? createEncryptCondition(predicateSegment, tableName.get()) : Optional.empty();\n+    private Optional<EncryptCondition> createEncryptCondition(final SQLStatementContext sqlStatementContext, final ExpressionSegment expression) {\n+        ColumnSegment column = ExpressionUtil.getColumnFromExpression(expression);", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0MTkyOQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486941929", "bodyText": "Functions are needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:02:23Z", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/condition/engine/WhereClauseShardingConditionEngine.java", "diffHunk": "@@ -98,22 +107,45 @@\n         return result;\n     }\n     \n-    private Map<Column, Collection<RouteValue>> createRouteValueMap(final SQLStatementContext sqlStatementContext, final AndPredicate andPredicate, final List<Object> parameters) {\n+    private Map<Column, Collection<RouteValue>> createRouteValueMap(final SQLStatementContext sqlStatementContext, final AndPredicate expressions, final List<Object> parameters) {\n         Map<Column, Collection<RouteValue>> result = new HashMap<>();\n-        for (PredicateSegment each : andPredicate.getPredicates()) {\n-            Optional<String> tableName = sqlStatementContext.getTablesContext().findTableName(each.getColumn(), schemaMetaData);\n-            if (!tableName.isPresent() || !shardingRule.isShardingColumn(each.getColumn().getIdentifier().getValue(), tableName.get())) {\n-                continue;\n+    \n+        for (ExpressionSegment each : expressions.getPredicates()) {\n+            Optional<RouteValue> routeValue = Optional.empty();\n+            Column column = null;\n+            if (each instanceof BinaryOperationExpression && ((BinaryOperationExpression) each).getLeft() instanceof ColumnSegment) {\n+                ColumnSegment columnSegment = (ColumnSegment) ((BinaryOperationExpression) each).getLeft();\n+                Optional<String> tableName = sqlStatementContext.getTablesContext().findTableName(columnSegment, schemaMetaData);\n+                if (tableName.isPresent() && shardingRule.isShardingColumn(columnSegment.getIdentifier().getValue(), tableName.get())) {\n+                    column = new Column(columnSegment.getIdentifier().getValue(), tableName.get());\n+                    routeValue = ConditionValueGeneratorFactory.generate(each, column, parameters);\n+                }\n             }\n-            Column column = new Column(each.getColumn().getIdentifier().getValue(), tableName.get());\n-            Optional<RouteValue> routeValue = ConditionValueGeneratorFactory.generate(each.getRightValue(), column, parameters);\n-            if (!routeValue.isPresent()) {\n-                continue;\n+            if (each instanceof InExpression && ((InExpression) each).getLeft() instanceof ColumnSegment) {\n+                ColumnSegment columnSegment = (ColumnSegment) ((InExpression) each).getLeft();\n+                Optional<String> tableName = sqlStatementContext.getTablesContext().findTableName(columnSegment, schemaMetaData);\n+                if (tableName.isPresent() && shardingRule.isShardingColumn(columnSegment.getIdentifier().getValue(), tableName.get())) {\n+                    column = new Column(columnSegment.getIdentifier().getValue(), tableName.get());\n+                    routeValue = ConditionValueGeneratorFactory.generate(each, column, parameters);\n+                }\n             }\n-            if (!result.containsKey(column)) {\n-                result.put(column, new LinkedList<>());\n+            if (each instanceof BetweenExpression && ((BetweenExpression) each).getLeft() instanceof ColumnSegment) {\n+                ColumnSegment columnSegment = (ColumnSegment) ((BetweenExpression) each).getLeft();", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0NTU4MQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486945581", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:05:57Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/MySQLVisitor.java", "diffHunk": "@@ -255,123 +254,173 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n+        if (null != ctx.XOR()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(\"XOR\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(ctx.logicalOperator().getText());\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n         }\n-        // TODO deal with XOR\n-        return visit(ctx.expr().get(0));\n+        NotExpression result = new NotExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setExpression((ExpressionSegment) visit(ctx.expr(0)));\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitBooleanPrimary(final BooleanPrimaryContext ctx) {\n+        if (null != ctx.IS()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+            result.setRight(new LiteralExpressionSegment(ctx.IS().getSymbol().getStopIndex() + 1, ctx.stop.getStopIndex(), new Interval(ctx.IS().getSymbol().getStopIndex() + 1,\n+                    ctx.stop.getStopIndex())));\n+            result.setOperator(\"IS\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.comparisonOperator() || null != ctx.SAFE_EQ_()) {\n             return createCompareSegment(ctx);\n         }\n-        if (null != ctx.predicate()) {\n-            return visit(ctx.predicate());\n-        }\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        //TODO deal with IS NOT? (TRUE | FALSE | UNKNOWN | NULL)\n-        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n-        return new CommonExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), text);\n+        return visit(ctx.predicate());\n     }\n     \n     private ASTNode createCompareSegment(final BooleanPrimaryContext ctx) {\n-        ASTNode leftValue = visit(ctx.booleanPrimary());\n-        if (!(leftValue instanceof ColumnSegment)) {\n-            return leftValue;\n-        }\n-        PredicateRightValue rightValue = (PredicateRightValue) createPredicateRightValue(ctx);\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (ColumnSegment) leftValue, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx) {\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        ASTNode rightValue = visit(ctx.predicate());\n-        return createPredicateRightValue(ctx, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx, final ASTNode rightValue) {\n-        if (rightValue instanceof ColumnSegment) {\n-            return rightValue;\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+        if (null != ctx.predicate()) {\n+            result.setRight((ExpressionSegment) visit(ctx.predicate()));\n+        } else {\n+            result.setRight((ExpressionSegment) visit(ctx.subquery()));\n         }\n-        return rightValue instanceof SubquerySegment ? new PredicateCompareRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                ctx.comparisonOperator().getText(), new SubqueryExpressionSegment((SubquerySegment) rightValue))\n-                : new PredicateCompareRightValue(ctx.predicate().start.getStartIndex(), ctx.predicate().stop.getStopIndex(), ctx.comparisonOperator().getText(),\n-                (ExpressionSegment) rightValue);\n+        String operator = null != ctx.SAFE_EQ_() ? ctx.SAFE_EQ_().getText() : ctx.comparisonOperator().getText();\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitPredicate(final PredicateContext ctx) {\n-        if (null != ctx.IN() && null == ctx.NOT()) {\n+        if (null != ctx.IN()) {\n             return createInSegment(ctx);\n         }\n-        if (null != ctx.BETWEEN() && null == ctx.NOT()) {\n+        if (null != ctx.BETWEEN()) {\n             return createBetweenSegment(ctx);\n         }\n-        if (1 == ctx.children.size()) {\n-            return visit(ctx.bitExpr(0));\n+        if (null != ctx.LIKE()) {\n+            return createBinaryOperationExpressionFromLike(ctx);\n         }\n-        return visitRemainPredicate(ctx);\n-    }\n-    \n-    private PredicateSegment createInSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        PredicateInRightValue predicateInRightValue = null != ctx.subquery() ? new PredicateInRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                getExpressionSegments(ctx))\n-                : new PredicateInRightValue(ctx.LP_().getSymbol().getStartIndex(), ctx.RP_().getSymbol().getStopIndex(), getExpressionSegments(ctx));\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, predicateInRightValue);\n+        if (null != ctx.REGEXP()) {\n+            return createBinaryOperationExpressionFromRegexp(ctx);\n+        }\n+        return visit(ctx.bitExpr(0));\n     }\n     \n-    private Collection<ExpressionSegment> getExpressionSegments(final PredicateContext ctx) {\n-        Collection<ExpressionSegment> result = new LinkedList<>();\n+    private InExpression createInSegment(final PredicateContext ctx) {\n+        InExpression result = new InExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n         if (null != ctx.subquery()) {\n-            SubqueryContext subquery = ctx.subquery();\n-            result.add(new SubqueryExpressionSegment(new SubquerySegment(subquery.getStart().getStartIndex(), subquery.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n-            return result;\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            result.add((ExpressionSegment) visit(each));\n-        }\n+            result.setRight(new SubqueryExpressionSegment(new SubquerySegment(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n+        } else {\n+            ListExpression listExpression = new ListExpression();\n+            listExpression.setStartIndex(ctx.LP_().getSymbol().getStartIndex());\n+            listExpression.setStopIndex(ctx.RP_().getSymbol().getStopIndex());\n+            for (ExprContext each : ctx.expr()) {\n+                listExpression.getItems().add((ExpressionSegment) visit(each));\n+            }\n+            result.setRight(listExpression);\n+        }\n+        Boolean operator = null != ctx.NOT() ? true : false;\n+        result.setNot(operator);\n         return result;\n     }\n     \n-    private PredicateSegment createBetweenSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        ExpressionSegment between = (ExpressionSegment) visit(ctx.bitExpr(1));\n-        ExpressionSegment and = (ExpressionSegment) visit(ctx.predicate());\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, new PredicateBetweenRightValue(between.getStartIndex(), and.getStopIndex(), between, and));\n+    private BinaryOperationExpression createBinaryOperationExpressionFromLike(final PredicateContext ctx) {\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        String operator;\n+        if (null != ctx.SOUNDS()) {\n+            result.setRight((ExpressionSegment) visit(ctx.bitExpr(1)));\n+            operator = \"SOUNDS LIKE\";\n+        } else {\n+            ListExpression listExpression = new ListExpression();\n+            for (SimpleExprContext each : ctx.simpleExpr()) {\n+                listExpression.getItems().add((ExpressionSegment) visit(each));\n+            }\n+            result.setRight(listExpression);\n+            operator = null != ctx.NOT() ? \"NOT LIKE\" : \"LIKE\";\n+        }\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n-    private ASTNode visitRemainPredicate(final PredicateContext ctx) {\n-        for (BitExprContext each : ctx.bitExpr()) {\n-            visit(each);\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            visit(each);\n-        }\n-        for (SimpleExprContext each : ctx.simpleExpr()) {\n-            visit(each);\n-        }\n-        if (null != ctx.predicate()) {\n-            visit(ctx.predicate());\n-        }\n+    private BinaryOperationExpression createBinaryOperationExpressionFromRegexp(final PredicateContext ctx) {\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        result.setRight((ExpressionSegment) visit(ctx.bitExpr(1)));", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0NTYzMQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486945631", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:06:04Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/MySQLVisitor.java", "diffHunk": "@@ -255,123 +254,173 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n+        if (null != ctx.XOR()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(\"XOR\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(ctx.logicalOperator().getText());\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n         }\n-        // TODO deal with XOR\n-        return visit(ctx.expr().get(0));\n+        NotExpression result = new NotExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setExpression((ExpressionSegment) visit(ctx.expr(0)));\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitBooleanPrimary(final BooleanPrimaryContext ctx) {\n+        if (null != ctx.IS()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+            result.setRight(new LiteralExpressionSegment(ctx.IS().getSymbol().getStopIndex() + 1, ctx.stop.getStopIndex(), new Interval(ctx.IS().getSymbol().getStopIndex() + 1,\n+                    ctx.stop.getStopIndex())));\n+            result.setOperator(\"IS\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.comparisonOperator() || null != ctx.SAFE_EQ_()) {\n             return createCompareSegment(ctx);\n         }\n-        if (null != ctx.predicate()) {\n-            return visit(ctx.predicate());\n-        }\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        //TODO deal with IS NOT? (TRUE | FALSE | UNKNOWN | NULL)\n-        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n-        return new CommonExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), text);\n+        return visit(ctx.predicate());\n     }\n     \n     private ASTNode createCompareSegment(final BooleanPrimaryContext ctx) {\n-        ASTNode leftValue = visit(ctx.booleanPrimary());\n-        if (!(leftValue instanceof ColumnSegment)) {\n-            return leftValue;\n-        }\n-        PredicateRightValue rightValue = (PredicateRightValue) createPredicateRightValue(ctx);\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (ColumnSegment) leftValue, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx) {\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        ASTNode rightValue = visit(ctx.predicate());\n-        return createPredicateRightValue(ctx, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx, final ASTNode rightValue) {\n-        if (rightValue instanceof ColumnSegment) {\n-            return rightValue;\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+        if (null != ctx.predicate()) {\n+            result.setRight((ExpressionSegment) visit(ctx.predicate()));\n+        } else {\n+            result.setRight((ExpressionSegment) visit(ctx.subquery()));\n         }\n-        return rightValue instanceof SubquerySegment ? new PredicateCompareRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                ctx.comparisonOperator().getText(), new SubqueryExpressionSegment((SubquerySegment) rightValue))\n-                : new PredicateCompareRightValue(ctx.predicate().start.getStartIndex(), ctx.predicate().stop.getStopIndex(), ctx.comparisonOperator().getText(),\n-                (ExpressionSegment) rightValue);\n+        String operator = null != ctx.SAFE_EQ_() ? ctx.SAFE_EQ_().getText() : ctx.comparisonOperator().getText();\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitPredicate(final PredicateContext ctx) {\n-        if (null != ctx.IN() && null == ctx.NOT()) {\n+        if (null != ctx.IN()) {\n             return createInSegment(ctx);\n         }\n-        if (null != ctx.BETWEEN() && null == ctx.NOT()) {\n+        if (null != ctx.BETWEEN()) {\n             return createBetweenSegment(ctx);\n         }\n-        if (1 == ctx.children.size()) {\n-            return visit(ctx.bitExpr(0));\n+        if (null != ctx.LIKE()) {\n+            return createBinaryOperationExpressionFromLike(ctx);\n         }\n-        return visitRemainPredicate(ctx);\n-    }\n-    \n-    private PredicateSegment createInSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        PredicateInRightValue predicateInRightValue = null != ctx.subquery() ? new PredicateInRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                getExpressionSegments(ctx))\n-                : new PredicateInRightValue(ctx.LP_().getSymbol().getStartIndex(), ctx.RP_().getSymbol().getStopIndex(), getExpressionSegments(ctx));\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, predicateInRightValue);\n+        if (null != ctx.REGEXP()) {\n+            return createBinaryOperationExpressionFromRegexp(ctx);\n+        }\n+        return visit(ctx.bitExpr(0));\n     }\n     \n-    private Collection<ExpressionSegment> getExpressionSegments(final PredicateContext ctx) {\n-        Collection<ExpressionSegment> result = new LinkedList<>();\n+    private InExpression createInSegment(final PredicateContext ctx) {\n+        InExpression result = new InExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n         if (null != ctx.subquery()) {\n-            SubqueryContext subquery = ctx.subquery();\n-            result.add(new SubqueryExpressionSegment(new SubquerySegment(subquery.getStart().getStartIndex(), subquery.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n-            return result;\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            result.add((ExpressionSegment) visit(each));\n-        }\n+            result.setRight(new SubqueryExpressionSegment(new SubquerySegment(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n+        } else {\n+            ListExpression listExpression = new ListExpression();\n+            listExpression.setStartIndex(ctx.LP_().getSymbol().getStartIndex());\n+            listExpression.setStopIndex(ctx.RP_().getSymbol().getStopIndex());\n+            for (ExprContext each : ctx.expr()) {\n+                listExpression.getItems().add((ExpressionSegment) visit(each));\n+            }\n+            result.setRight(listExpression);\n+        }\n+        Boolean operator = null != ctx.NOT() ? true : false;\n+        result.setNot(operator);\n         return result;\n     }\n     \n-    private PredicateSegment createBetweenSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        ExpressionSegment between = (ExpressionSegment) visit(ctx.bitExpr(1));\n-        ExpressionSegment and = (ExpressionSegment) visit(ctx.predicate());\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, new PredicateBetweenRightValue(between.getStartIndex(), and.getStopIndex(), between, and));\n+    private BinaryOperationExpression createBinaryOperationExpressionFromLike(final PredicateContext ctx) {\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        String operator;\n+        if (null != ctx.SOUNDS()) {\n+            result.setRight((ExpressionSegment) visit(ctx.bitExpr(1)));", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0NTczMA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486945730", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:06:17Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/MySQLVisitor.java", "diffHunk": "@@ -255,123 +254,173 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n+        if (null != ctx.XOR()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(\"XOR\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(ctx.logicalOperator().getText());\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n         }\n-        // TODO deal with XOR\n-        return visit(ctx.expr().get(0));\n+        NotExpression result = new NotExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setExpression((ExpressionSegment) visit(ctx.expr(0)));\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitBooleanPrimary(final BooleanPrimaryContext ctx) {\n+        if (null != ctx.IS()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+            result.setRight(new LiteralExpressionSegment(ctx.IS().getSymbol().getStopIndex() + 1, ctx.stop.getStopIndex(), new Interval(ctx.IS().getSymbol().getStopIndex() + 1,\n+                    ctx.stop.getStopIndex())));\n+            result.setOperator(\"IS\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.comparisonOperator() || null != ctx.SAFE_EQ_()) {\n             return createCompareSegment(ctx);\n         }\n-        if (null != ctx.predicate()) {\n-            return visit(ctx.predicate());\n-        }\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        //TODO deal with IS NOT? (TRUE | FALSE | UNKNOWN | NULL)\n-        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n-        return new CommonExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), text);\n+        return visit(ctx.predicate());\n     }\n     \n     private ASTNode createCompareSegment(final BooleanPrimaryContext ctx) {\n-        ASTNode leftValue = visit(ctx.booleanPrimary());\n-        if (!(leftValue instanceof ColumnSegment)) {\n-            return leftValue;\n-        }\n-        PredicateRightValue rightValue = (PredicateRightValue) createPredicateRightValue(ctx);\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (ColumnSegment) leftValue, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx) {\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        ASTNode rightValue = visit(ctx.predicate());\n-        return createPredicateRightValue(ctx, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx, final ASTNode rightValue) {\n-        if (rightValue instanceof ColumnSegment) {\n-            return rightValue;\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+        if (null != ctx.predicate()) {\n+            result.setRight((ExpressionSegment) visit(ctx.predicate()));\n+        } else {\n+            result.setRight((ExpressionSegment) visit(ctx.subquery()));\n         }\n-        return rightValue instanceof SubquerySegment ? new PredicateCompareRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                ctx.comparisonOperator().getText(), new SubqueryExpressionSegment((SubquerySegment) rightValue))\n-                : new PredicateCompareRightValue(ctx.predicate().start.getStartIndex(), ctx.predicate().stop.getStopIndex(), ctx.comparisonOperator().getText(),\n-                (ExpressionSegment) rightValue);\n+        String operator = null != ctx.SAFE_EQ_() ? ctx.SAFE_EQ_().getText() : ctx.comparisonOperator().getText();\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitPredicate(final PredicateContext ctx) {\n-        if (null != ctx.IN() && null == ctx.NOT()) {\n+        if (null != ctx.IN()) {\n             return createInSegment(ctx);\n         }\n-        if (null != ctx.BETWEEN() && null == ctx.NOT()) {\n+        if (null != ctx.BETWEEN()) {\n             return createBetweenSegment(ctx);\n         }\n-        if (1 == ctx.children.size()) {\n-            return visit(ctx.bitExpr(0));\n+        if (null != ctx.LIKE()) {\n+            return createBinaryOperationExpressionFromLike(ctx);\n         }\n-        return visitRemainPredicate(ctx);\n-    }\n-    \n-    private PredicateSegment createInSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        PredicateInRightValue predicateInRightValue = null != ctx.subquery() ? new PredicateInRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                getExpressionSegments(ctx))\n-                : new PredicateInRightValue(ctx.LP_().getSymbol().getStartIndex(), ctx.RP_().getSymbol().getStopIndex(), getExpressionSegments(ctx));\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, predicateInRightValue);\n+        if (null != ctx.REGEXP()) {\n+            return createBinaryOperationExpressionFromRegexp(ctx);\n+        }\n+        return visit(ctx.bitExpr(0));\n     }\n     \n-    private Collection<ExpressionSegment> getExpressionSegments(final PredicateContext ctx) {\n-        Collection<ExpressionSegment> result = new LinkedList<>();\n+    private InExpression createInSegment(final PredicateContext ctx) {\n+        InExpression result = new InExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n         if (null != ctx.subquery()) {\n-            SubqueryContext subquery = ctx.subquery();\n-            result.add(new SubqueryExpressionSegment(new SubquerySegment(subquery.getStart().getStartIndex(), subquery.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n-            return result;\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            result.add((ExpressionSegment) visit(each));\n-        }\n+            result.setRight(new SubqueryExpressionSegment(new SubquerySegment(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n+        } else {\n+            ListExpression listExpression = new ListExpression();\n+            listExpression.setStartIndex(ctx.LP_().getSymbol().getStartIndex());\n+            listExpression.setStopIndex(ctx.RP_().getSymbol().getStopIndex());\n+            for (ExprContext each : ctx.expr()) {\n+                listExpression.getItems().add((ExpressionSegment) visit(each));\n+            }\n+            result.setRight(listExpression);\n+        }\n+        Boolean operator = null != ctx.NOT() ? true : false;\n+        result.setNot(operator);\n         return result;\n     }\n     \n-    private PredicateSegment createBetweenSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        ExpressionSegment between = (ExpressionSegment) visit(ctx.bitExpr(1));\n-        ExpressionSegment and = (ExpressionSegment) visit(ctx.predicate());\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, new PredicateBetweenRightValue(between.getStartIndex(), and.getStopIndex(), between, and));\n+    private BinaryOperationExpression createBinaryOperationExpressionFromLike(final PredicateContext ctx) {\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        String operator;\n+        if (null != ctx.SOUNDS()) {\n+            result.setRight((ExpressionSegment) visit(ctx.bitExpr(1)));\n+            operator = \"SOUNDS LIKE\";\n+        } else {\n+            ListExpression listExpression = new ListExpression();\n+            for (SimpleExprContext each : ctx.simpleExpr()) {\n+                listExpression.getItems().add((ExpressionSegment) visit(each));\n+            }\n+            result.setRight(listExpression);\n+            operator = null != ctx.NOT() ? \"NOT LIKE\" : \"LIKE\";\n+        }\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n-    private ASTNode visitRemainPredicate(final PredicateContext ctx) {\n-        for (BitExprContext each : ctx.bitExpr()) {\n-            visit(each);\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            visit(each);\n-        }\n-        for (SimpleExprContext each : ctx.simpleExpr()) {\n-            visit(each);\n-        }\n-        if (null != ctx.predicate()) {\n-            visit(ctx.predicate());\n-        }\n+    private BinaryOperationExpression createBinaryOperationExpressionFromRegexp(final PredicateContext ctx) {\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        result.setRight((ExpressionSegment) visit(ctx.bitExpr(1)));\n+        String operator = null != ctx.NOT() ? \"NOT REGEXP\" : \"REGEXP\";\n+        result.setOperator(operator);\n         String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n-        return new CommonExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), text);\n+        result.setText(text);\n+        return result;\n+    }\n+    \n+    private BetweenExpression createBetweenSegment(final PredicateContext ctx) {\n+        BetweenExpression result = new BetweenExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0NTkzMA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486945930", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:06:42Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/impl/MySQLDMLVisitor.java", "diffHunk": "@@ -516,6 +506,13 @@ private ASTNode createProjection(final ProjectionContext ctx, final AliasSegment\n             result.setAlias(alias);\n             return result;\n         }\n+        if (projection instanceof BinaryOperationExpression) {\n+            int startIndex = ((BinaryOperationExpression) projection).getStartIndex();\n+            int stopIndex = null != alias ? alias.getStopIndex() : ((BinaryOperationExpression) projection).getStopIndex();\n+            ExpressionProjectionSegment result = new ExpressionProjectionSegment(startIndex, stopIndex, ((BinaryOperationExpression) projection).getText());", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0NjE0MQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486946141", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:07:08Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-oracle/src/main/java/org/apache/shardingsphere/sql/parser/oracle/visitor/OracleVisitor.java", "diffHunk": "@@ -236,120 +234,141 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(ctx.logicalOperator().getText());\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n         }\n-        // TODO deal with XOR\n-        return visit(ctx.expr().get(0));\n+        NotExpression result = new NotExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setExpression((ExpressionSegment) visit(ctx.expr(0)));\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitBooleanPrimary(final BooleanPrimaryContext ctx) {\n+        if (null != ctx.IS()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+            result.setRight(new LiteralExpressionSegment(ctx.IS().getSymbol().getStopIndex() + 1, ctx.stop.getStopIndex(), new Interval(ctx.IS().getSymbol().getStopIndex() + 1,", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0NjI4NA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486946284", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:07:27Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-oracle/src/main/java/org/apache/shardingsphere/sql/parser/oracle/visitor/OracleVisitor.java", "diffHunk": "@@ -236,120 +234,141 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(ctx.logicalOperator().getText());\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n         }\n-        // TODO deal with XOR\n-        return visit(ctx.expr().get(0));\n+        NotExpression result = new NotExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setExpression((ExpressionSegment) visit(ctx.expr(0)));\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitBooleanPrimary(final BooleanPrimaryContext ctx) {\n+        if (null != ctx.IS()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+            result.setRight(new LiteralExpressionSegment(ctx.IS().getSymbol().getStopIndex() + 1, ctx.stop.getStopIndex(), new Interval(ctx.IS().getSymbol().getStopIndex() + 1,\n+                    ctx.stop.getStopIndex())));\n+            result.setOperator(\"IS\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.comparisonOperator() || null != ctx.SAFE_EQ_()) {\n             return createCompareSegment(ctx);\n         }\n-        if (null != ctx.predicate()) {\n-            return visit(ctx.predicate());\n-        }\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        //TODO deal with IS NOT? (TRUE | FALSE | UNKNOWN | NULL)\n-        return new CommonExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), ctx.getText());\n+        return visit(ctx.predicate());\n     }\n     \n     private ASTNode createCompareSegment(final BooleanPrimaryContext ctx) {\n-        ASTNode leftValue = visit(ctx.booleanPrimary());\n-        if (!(leftValue instanceof ColumnSegment)) {\n-            return leftValue;\n-        }\n-        PredicateRightValue rightValue = (PredicateRightValue) createPredicateRightValue(ctx);\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (ColumnSegment) leftValue, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx) {\n-        if (null != ctx.subquery()) {\n-            new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        ASTNode rightValue = visit(ctx.predicate());\n-        return createPredicateRightValue(ctx, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx, final ASTNode rightValue) {\n-        if (rightValue instanceof ColumnSegment) {\n-            return rightValue;\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+        if (null != ctx.predicate()) {\n+            result.setRight((ExpressionSegment) visit(ctx.predicate()));\n+        } else {\n+            result.setRight((ExpressionSegment) visit(ctx.subquery()));\n         }\n-        return rightValue instanceof SubquerySegment ? new PredicateCompareRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(), ctx.comparisonOperator().getText(),\n-                new SubqueryExpressionSegment((SubquerySegment) rightValue))\n-                : new PredicateCompareRightValue(ctx.predicate().start.getStartIndex(), ctx.predicate().stop.getStopIndex(), ctx.comparisonOperator().getText(), (ExpressionSegment) rightValue);\n+        String operator = null != ctx.SAFE_EQ_() ? ctx.SAFE_EQ_().getText() : ctx.comparisonOperator().getText();\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitPredicate(final PredicateContext ctx) {\n-        if (null != ctx.IN() && null == ctx.NOT()) {\n+        if (null != ctx.IN()) {\n             return createInSegment(ctx);\n         }\n-        if (null != ctx.BETWEEN() && null == ctx.NOT()) {\n+        if (null != ctx.BETWEEN()) {\n             return createBetweenSegment(ctx);\n         }\n-        if (1 == ctx.children.size()) {\n-            return visit(ctx.bitExpr(0));\n+        if (null != ctx.LIKE()) {\n+            return createBinaryOperationExpressionFromLike(ctx);\n         }\n-        return visitRemainPredicate(ctx);\n+        return visit(ctx.bitExpr(0));\n     }\n     \n-    private PredicateSegment createInSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        PredicateInRightValue predicateInRightValue = null != ctx.subquery() ? new PredicateInRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                getExpressionSegments(ctx))\n-                : new PredicateInRightValue(ctx.LP_().getSymbol().getStartIndex(), ctx.RP_().getSymbol().getStopIndex(), getExpressionSegments(ctx));\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, predicateInRightValue);\n-    }\n-    \n-    private Collection<ExpressionSegment> getExpressionSegments(final PredicateContext ctx) {\n-        Collection<ExpressionSegment> result = new LinkedList<>();\n+    private InExpression createInSegment(final PredicateContext ctx) {\n+        InExpression result = new InExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n         if (null != ctx.subquery()) {\n-            SubqueryContext subquery = ctx.subquery();\n-            result.add(new SubqueryExpressionSegment(new SubquerySegment(subquery.getStart().getStartIndex(), subquery.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n-            return result;\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            result.add((ExpressionSegment) visit(each));\n-        }\n+            result.setRight(new SubqueryExpressionSegment(new SubquerySegment(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n+        } else {\n+            ListExpression listExpression = new ListExpression();\n+            listExpression.setStartIndex(ctx.LP_().getSymbol().getStartIndex());\n+            listExpression.setStopIndex(ctx.RP_().getSymbol().getStopIndex());\n+            for (ExprContext each : ctx.expr()) {\n+                listExpression.getItems().add((ExpressionSegment) visit(each));\n+            }\n+            result.setRight(listExpression);\n+        }\n+        Boolean operator = null != ctx.NOT() ? true : false;\n+        result.setNot(operator);\n         return result;\n     }\n     \n-    private PredicateSegment createBetweenSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        ExpressionSegment between = (ExpressionSegment) visit(ctx.bitExpr(1));\n-        ExpressionSegment and = (ExpressionSegment) visit(ctx.predicate());\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, new PredicateBetweenRightValue(between.getStartIndex(), and.getStopIndex(), between, and));\n-    }\n-    \n-    private ASTNode visitRemainPredicate(final PredicateContext ctx) {\n-        for (BitExprContext each : ctx.bitExpr()) {\n-            visit(each);\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            visit(each);\n-        }\n+    private BinaryOperationExpression createBinaryOperationExpressionFromLike(final PredicateContext ctx) {\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        ListExpression listExpression = new ListExpression();\n         for (SimpleExprContext each : ctx.simpleExpr()) {\n-            visit(each);\n-        }\n-        if (null != ctx.predicate()) {\n-            visit(ctx.predicate());\n+            listExpression.getItems().add((ExpressionSegment) visit(each));\n         }\n-        return new CommonExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), ctx.getText());\n+        result.setRight(listExpression);\n+        String operator;", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0NjMzNg==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486946336", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:07:33Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-oracle/src/main/java/org/apache/shardingsphere/sql/parser/oracle/visitor/OracleVisitor.java", "diffHunk": "@@ -236,120 +234,141 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0NjUzNQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486946535", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:07:55Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-postgresql/src/main/java/org/apache/shardingsphere/sql/parser/postgresql/visitor/PostgreSQLVisitor.java", "diffHunk": "@@ -173,26 +176,33 @@ public ASTNode visitAExpr(final AExprContext ctx) {\n         if (null != ctx.cExpr()) {\n             return visit(ctx.cExpr());\n         }\n-        if (null != ctx.BETWEEN() && null == ctx.NOT()) {\n+        if (null != ctx.BETWEEN()) {\n             return createBetweenSegment(ctx);\n         }\n-        if (null != ctx.IN() && null == ctx.NOT()) {\n+        if (null != ctx.IN()) {\n             return createInSegment(ctx);\n         }\n         if (null != ctx.comparisonOperator()) {\n-            ASTNode left = visit(ctx.aExpr(0));\n-            if (left instanceof ColumnSegment) {\n-                ColumnSegment columnSegment = (ColumnSegment) left;\n-                SQLSegment right = (SQLSegment) visit(ctx.aExpr(1));\n-                PredicateRightValue value = right instanceof ColumnSegment\n-                        ? (PredicateRightValue) right : new PredicateCompareRightValue(right.getStartIndex(), right.getStopIndex(), ctx.comparisonOperator().getText(), (ExpressionSegment) right);\n-                return new PredicateSegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex(), columnSegment, value);\n-            }\n-            visit(ctx.aExpr(1));\n-            return new LiteralExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), ctx.getText());\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.aExpr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.aExpr(1)));", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0NjY4NA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486946684", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:08:15Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-postgresql/src/main/java/org/apache/shardingsphere/sql/parser/postgresql/visitor/impl/PostgreSQLDMLVisitor.java", "diffHunk": "@@ -459,101 +451,87 @@ public ASTNode visitTargetEl(final TargetElContext ctx) {\n         return result;\n     }\n     \n-    private ColumnProjectionSegment generateColumnProjection(final ColumnrefContext ctx) {\n-        if (null != ctx.indirection()) {\n-            PostgreSQLStatementParser.AttrNameContext attrName = ctx.indirection().indirectionEl().attrName();\n-            ColumnSegment columnSegment = new ColumnSegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex(), new IdentifierValue(attrName.getText()));\n-            OwnerSegment owner = new OwnerSegment(ctx.colId().start.getStartIndex(), ctx.colId().stop.getStopIndex(), new IdentifierValue(ctx.colId().getText()));\n-            columnSegment.setOwner(owner);\n-            return new ColumnProjectionSegment(columnSegment);\n-        }\n-        ColumnSegment columnSegment = new ColumnSegment(ctx.colId().start.getStartIndex(), ctx.colId().stop.getStopIndex(), new IdentifierValue(ctx.colId().getText()));\n-        return new ColumnProjectionSegment(columnSegment);\n-    }\n-    \n     @Override\n     public ASTNode visitFromClause(final FromClauseContext ctx) {\n         return visit(ctx.fromList());\n     }\n     \n     @Override\n-    public ASTNode visitFromList(final PostgreSQLStatementParser.FromListContext ctx) {\n-        CollectionValue<TableReferenceSegment> result = new CollectionValue<>();\n+    public ASTNode visitFromList(final FromListContext ctx) {\n         if (null != ctx.fromList()) {\n-            result.getValue().addAll(((CollectionValue<TableReferenceSegment>) visit(ctx.fromList())).getValue());\n+            JoinTableSegment result = new JoinTableSegment();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((TableSegment) visit(ctx.fromList()));\n+            result.setRight((TableSegment) visit(ctx.tableReference()));\n+            return result;\n         }\n-        result.getValue().add((TableReferenceSegment) visit(ctx.tableReference()));\n+        TableSegment result = (TableSegment) visit(ctx.tableReference());\n         return result;\n     }\n     \n     @Override\n     public ASTNode visitTableReference(final TableReferenceContext ctx) {\n-        if (null != ctx.tableReference()) {\n-            TableReferenceSegment result = (TableReferenceSegment) visit(ctx.tableReference());\n-            if (null != ctx.joinedTable()) {\n-                result.getJoinedTables().add((JoinedTableSegment) visit(ctx.joinedTable()));\n-            }\n-            return result;\n-        }\n         if (null != ctx.relationExpr()) {\n-            TableReferenceSegment result = new TableReferenceSegment();\n-            SimpleTableSegment table = generateTableFromRelationExpr(ctx.relationExpr());\n+            SimpleTableSegment result = generateTableFromRelationExpr(ctx.relationExpr());\n             if (null != ctx.aliasClause()) {\n-                table.setAlias((AliasSegment) visit(ctx.aliasClause()));\n+                result.setAlias((AliasSegment) visit(ctx.aliasClause()));\n             }\n-            TableFactorSegment tableFactorSegment = new TableFactorSegment();\n-            tableFactorSegment.setTable(table);\n-            result.setTableFactor(tableFactorSegment);\n             return result;\n         }\n         if (null != ctx.selectWithParens()) {\n-            TableReferenceSegment result = new TableReferenceSegment();\n             SelectStatement select = (SelectStatement) visit(ctx.selectWithParens());\n             SubquerySegment subquery = new SubquerySegment(ctx.selectWithParens().start.getStartIndex(), ctx.selectWithParens().stop.getStopIndex(), select);\n             AliasSegment alias = null != ctx.aliasClause() ? (AliasSegment) visit(ctx.aliasClause()) : null;\n-            SubqueryTableSegment subqueryTable = new SubqueryTableSegment(subquery);\n-            subqueryTable.setAlias(alias);\n-            TableFactorSegment tableFactor = new TableFactorSegment();\n-            tableFactor.setTable(subqueryTable);\n-            result.setTableFactor(tableFactor);\n+            SubqueryTableSegment result = new SubqueryTableSegment(subquery);\n+            result.setAlias(alias);\n+            return result;\n+        }\n+        if (null != ctx.tableReference()) {\n+            JoinTableSegment result = new JoinTableSegment();\n+            int startIndex = null != ctx.LP_() ? ctx.LP_().getSymbol().getStartIndex() : ctx.tableReference().start.getStartIndex();\n+            int stopIndex = 0;\n+            AliasSegment alias = null;\n+            if (null != ctx.aliasClause()) {\n+                alias = (AliasSegment) visit(ctx.aliasClause());\n+                startIndex = null != ctx.RP_() ? ctx.RP_().getSymbol().getStopIndex() : ctx.joinedTable().stop.getStopIndex();\n+            } else {", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0Njc5OQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486946799", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:08:31Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-sql92/src/main/java/org/apache/shardingsphere/sql/parser/sql92/visitor/SQL92Visitor.java", "diffHunk": "@@ -229,123 +227,141 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(ctx.logicalOperator().getText());\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n         }\n-        // TODO deal with XOR\n-        return visit(ctx.expr().get(0));\n+        NotExpression result = new NotExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setExpression((ExpressionSegment) visit(ctx.expr(0)));\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitBooleanPrimary(final BooleanPrimaryContext ctx) {\n+        if (null != ctx.IS()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+            result.setRight(new LiteralExpressionSegment(ctx.IS().getSymbol().getStopIndex() + 1, ctx.stop.getStopIndex(), new Interval(ctx.IS().getSymbol().getStopIndex() + 1,\n+                    ctx.stop.getStopIndex())));\n+            result.setOperator(\"IS\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.comparisonOperator() || null != ctx.SAFE_EQ_()) {\n             return createCompareSegment(ctx);\n         }\n-        if (null != ctx.predicate()) {\n-            return visit(ctx.predicate());\n-        }\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        //TODO deal with IS NOT? (TRUE | FALSE | UNKNOWN | NULL)\n-        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n-        return new CommonExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), text);\n+        return visit(ctx.predicate());\n     }\n     \n     private ASTNode createCompareSegment(final BooleanPrimaryContext ctx) {\n-        ASTNode leftValue = visit(ctx.booleanPrimary());\n-        if (!(leftValue instanceof ColumnSegment)) {\n-            return leftValue;\n-        }\n-        PredicateRightValue rightValue = (PredicateRightValue) createPredicateRightValue(ctx);\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (ColumnSegment) leftValue, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx) {\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        ASTNode rightValue = visit(ctx.predicate());\n-        return createPredicateRightValue(ctx, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx, final ASTNode rightValue) {\n-        if (rightValue instanceof ColumnSegment) {\n-            return rightValue;\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        if (null != ctx.predicate()) {\n+            result.setRight((ExpressionSegment) visit(ctx.predicate()));\n+        } else {\n+            result.setRight((ExpressionSegment) visit(ctx.subquery()));\n         }\n-        return rightValue instanceof SubquerySegment ? new PredicateCompareRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                ctx.comparisonOperator().getText(), new SubqueryExpressionSegment((SubquerySegment) rightValue))\n-                : new PredicateCompareRightValue(ctx.predicate().start.getStartIndex(), ctx.predicate().stop.getStopIndex(), ctx.comparisonOperator().getText(),\n-                (ExpressionSegment) rightValue);\n+        String operator = null != ctx.SAFE_EQ_() ? ctx.SAFE_EQ_().getText() : ctx.comparisonOperator().getText();\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitPredicate(final PredicateContext ctx) {\n-        if (null != ctx.IN() && null == ctx.NOT()) {\n+        if (null != ctx.IN()) {\n             return createInSegment(ctx);\n         }\n-        if (null != ctx.BETWEEN() && null == ctx.NOT()) {\n+        if (null != ctx.BETWEEN()) {\n             return createBetweenSegment(ctx);\n         }\n-        if (1 == ctx.children.size()) {\n-            return visit(ctx.bitExpr(0));\n+        if (null != ctx.LIKE()) {\n+            return createBinaryOperationExpressionFromLike(ctx);\n         }\n-        return visitRemainPredicate(ctx);\n-    }\n-    \n-    private PredicateSegment createInSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        PredicateInRightValue predicateInRightValue = null != ctx.subquery() ? new PredicateInRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                getExpressionSegments(ctx))\n-                : new PredicateInRightValue(ctx.LP_().getSymbol().getStartIndex(), ctx.RP_().getSymbol().getStopIndex(), getExpressionSegments(ctx));\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, predicateInRightValue);\n+        return visit(ctx.bitExpr(0));\n     }\n     \n-    private Collection<ExpressionSegment> getExpressionSegments(final PredicateContext ctx) {\n-        Collection<ExpressionSegment> result = new LinkedList<>();\n-        if (null != ctx.subquery()) {\n-            SubqueryContext subquery = ctx.subquery();\n-            result.add(new SubqueryExpressionSegment(new SubquerySegment(subquery.getStart().getStartIndex(), subquery.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n-            return result;\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            result.add((ExpressionSegment) visit(each));\n+    private BinaryOperationExpression createBinaryOperationExpressionFromLike(final PredicateContext ctx) {\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        ListExpression listExpression = new ListExpression();\n+        for (SimpleExprContext each : ctx.simpleExpr()) {\n+            listExpression.getItems().add((ExpressionSegment) visit(each));\n         }\n+        result.setRight(listExpression);\n+        String operator;\n+        operator = null != ctx.NOT() ? \"NOT LIKE\" : \"LIKE\";\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n         return result;\n     }\n     \n-    private PredicateSegment createBetweenSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        ExpressionSegment between = (ExpressionSegment) visit(ctx.bitExpr(1));\n-        ExpressionSegment and = (ExpressionSegment) visit(ctx.predicate());\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, new PredicateBetweenRightValue(between.getStartIndex(), and.getStopIndex(), between, and));\n+    private InExpression createInSegment(final PredicateContext ctx) {\n+        InExpression result = new InExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        if (null != ctx.subquery()) {\n+            result.setRight(new SubqueryExpressionSegment(new SubquerySegment(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n+        } else {\n+            ListExpression listExpression = new ListExpression();\n+            listExpression.setStartIndex(ctx.LP_().getSymbol().getStartIndex());\n+            listExpression.setStopIndex(ctx.RP_().getSymbol().getStopIndex());\n+            for (ExprContext each : ctx.expr()) {", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0Njk5NA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486946994", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:08:58Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-sqlserver/src/main/java/org/apache/shardingsphere/sql/parser/sqlserver/visitor/SQLServerVisitor.java", "diffHunk": "@@ -244,121 +241,141 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(ctx.logicalOperator().getText());\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n         }\n-        // TODO deal with XOR\n-        return visit(ctx.expr().get(0));\n+        NotExpression result = new NotExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setExpression((ExpressionSegment) visit(ctx.expr(0)));\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitBooleanPrimary(final BooleanPrimaryContext ctx) {\n+        if (null != ctx.IS()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+            result.setRight(new LiteralExpressionSegment(ctx.IS().getSymbol().getStopIndex() + 1, ctx.stop.getStopIndex(), new Interval(ctx.IS().getSymbol().getStopIndex() + 1,\n+                    ctx.stop.getStopIndex())));\n+            result.setOperator(\"IS\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.comparisonOperator() || null != ctx.SAFE_EQ_()) {\n             return createCompareSegment(ctx);\n         }\n-        if (null != ctx.predicate()) {\n-            return visit(ctx.predicate());\n-        }\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        //TODO deal with IS NOT? (TRUE | FALSE | UNKNOWN | NULL)\n-        return new CommonExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), ctx.getText());\n+        return visit(ctx.predicate());\n     }\n     \n     private ASTNode createCompareSegment(final BooleanPrimaryContext ctx) {\n-        ASTNode leftValue = visit(ctx.booleanPrimary());\n-        if (!(leftValue instanceof ColumnSegment)) {\n-            return leftValue;\n-        }\n-        PredicateRightValue rightValue = (PredicateRightValue) createPredicateRightValue(ctx);\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (ColumnSegment) leftValue, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx) {\n-        if (null != ctx.subquery()) {\n-            new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        ASTNode rightValue = visit(ctx.predicate());\n-        return createPredicateRightValue(ctx, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx, final ASTNode rightValue) {\n-        if (rightValue instanceof ColumnSegment) {\n-            return rightValue;\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+        if (null != ctx.predicate()) {\n+            result.setRight((ExpressionSegment) visit(ctx.predicate()));\n+        } else {\n+            result.setRight((ExpressionSegment) visit(ctx.subquery()));\n         }\n-        return rightValue instanceof SubquerySegment ? new PredicateCompareRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(), ctx.comparisonOperator().getText(),\n-                new SubqueryExpressionSegment((SubquerySegment) rightValue))\n-                : new PredicateCompareRightValue(ctx.predicate().start.getStartIndex(), ctx.predicate().stop.getStopIndex(), ctx.comparisonOperator().getText(), (ExpressionSegment) rightValue);\n+        String operator = null != ctx.SAFE_EQ_() ? ctx.SAFE_EQ_().getText() : ctx.comparisonOperator().getText();\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitPredicate(final PredicateContext ctx) {\n-        if (null != ctx.IN() && null == ctx.NOT()) {\n+        if (null != ctx.IN()) {\n             return createInSegment(ctx);\n         }\n-        if (null != ctx.BETWEEN() && null == ctx.NOT()) {\n+        if (null != ctx.BETWEEN()) {\n             return createBetweenSegment(ctx);\n         }\n-        if (1 == ctx.children.size()) {\n-            return visit(ctx.bitExpr(0));\n+        if (null != ctx.LIKE()) {\n+            return createBinaryOperationExpressionFromLike(ctx);\n         }\n-        return visitRemainPredicate(ctx);\n-    }\n-    \n-    private PredicateSegment createInSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        PredicateInRightValue predicateInRightValue = null != ctx.subquery() ? new PredicateInRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                getExpressionSegments(ctx))\n-                : new PredicateInRightValue(ctx.LP_().getSymbol().getStartIndex(), ctx.RP_().getSymbol().getStopIndex(), getExpressionSegments(ctx));\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, predicateInRightValue);\n+        return visit(ctx.bitExpr(0));\n     }\n     \n-    private Collection<ExpressionSegment> getExpressionSegments(final PredicateContext ctx) {\n-        Collection<ExpressionSegment> result = new LinkedList<>();\n-        if (null != ctx.subquery()) {\n-            SubqueryContext subquery = ctx.subquery();\n-            result.add(new SubqueryExpressionSegment(new SubquerySegment(subquery.getStart().getStartIndex(), subquery.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n-            return result;\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            result.add((ExpressionSegment) visit(each));\n+    private BinaryOperationExpression createBinaryOperationExpressionFromLike(final PredicateContext ctx) {\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        ListExpression listExpression = new ListExpression();\n+        for (SimpleExprContext each : ctx.simpleExpr()) {\n+            listExpression.getItems().add((ExpressionSegment) visit(each));\n         }\n+        result.setRight(listExpression);", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0NzAzMw==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486947033", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:09:05Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-sqlserver/src/main/java/org/apache/shardingsphere/sql/parser/sqlserver/visitor/SQLServerVisitor.java", "diffHunk": "@@ -244,121 +241,141 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n         if (null != ctx.logicalOperator()) {\n-            return new PredicateBuildUtils(visit(ctx.expr(0)), visit(ctx.expr(1)), ctx.logicalOperator().getText()).mergePredicate();\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));\n+            result.setOperator(ctx.logicalOperator().getText());\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n         }\n-        // TODO deal with XOR\n-        return visit(ctx.expr().get(0));\n+        NotExpression result = new NotExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setExpression((ExpressionSegment) visit(ctx.expr(0)));\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitBooleanPrimary(final BooleanPrimaryContext ctx) {\n+        if (null != ctx.IS()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+            result.setRight(new LiteralExpressionSegment(ctx.IS().getSymbol().getStopIndex() + 1, ctx.stop.getStopIndex(), new Interval(ctx.IS().getSymbol().getStopIndex() + 1,\n+                    ctx.stop.getStopIndex())));\n+            result.setOperator(\"IS\");\n+            String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+            result.setText(text);\n+            return result;\n+        }\n         if (null != ctx.comparisonOperator() || null != ctx.SAFE_EQ_()) {\n             return createCompareSegment(ctx);\n         }\n-        if (null != ctx.predicate()) {\n-            return visit(ctx.predicate());\n-        }\n-        if (null != ctx.subquery()) {\n-            return new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        //TODO deal with IS NOT? (TRUE | FALSE | UNKNOWN | NULL)\n-        return new CommonExpressionSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), ctx.getText());\n+        return visit(ctx.predicate());\n     }\n     \n     private ASTNode createCompareSegment(final BooleanPrimaryContext ctx) {\n-        ASTNode leftValue = visit(ctx.booleanPrimary());\n-        if (!(leftValue instanceof ColumnSegment)) {\n-            return leftValue;\n-        }\n-        PredicateRightValue rightValue = (PredicateRightValue) createPredicateRightValue(ctx);\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (ColumnSegment) leftValue, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx) {\n-        if (null != ctx.subquery()) {\n-            new SubquerySegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()));\n-        }\n-        ASTNode rightValue = visit(ctx.predicate());\n-        return createPredicateRightValue(ctx, rightValue);\n-    }\n-    \n-    private ASTNode createPredicateRightValue(final BooleanPrimaryContext ctx, final ASTNode rightValue) {\n-        if (rightValue instanceof ColumnSegment) {\n-            return rightValue;\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.booleanPrimary()));\n+        if (null != ctx.predicate()) {\n+            result.setRight((ExpressionSegment) visit(ctx.predicate()));\n+        } else {\n+            result.setRight((ExpressionSegment) visit(ctx.subquery()));\n         }\n-        return rightValue instanceof SubquerySegment ? new PredicateCompareRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(), ctx.comparisonOperator().getText(),\n-                new SubqueryExpressionSegment((SubquerySegment) rightValue))\n-                : new PredicateCompareRightValue(ctx.predicate().start.getStartIndex(), ctx.predicate().stop.getStopIndex(), ctx.comparisonOperator().getText(), (ExpressionSegment) rightValue);\n+        String operator = null != ctx.SAFE_EQ_() ? ctx.SAFE_EQ_().getText() : ctx.comparisonOperator().getText();\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n+        return result;\n     }\n     \n     @Override\n     public final ASTNode visitPredicate(final PredicateContext ctx) {\n-        if (null != ctx.IN() && null == ctx.NOT()) {\n+        if (null != ctx.IN()) {\n             return createInSegment(ctx);\n         }\n-        if (null != ctx.BETWEEN() && null == ctx.NOT()) {\n+        if (null != ctx.BETWEEN()) {\n             return createBetweenSegment(ctx);\n         }\n-        if (1 == ctx.children.size()) {\n-            return visit(ctx.bitExpr(0));\n+        if (null != ctx.LIKE()) {\n+            return createBinaryOperationExpressionFromLike(ctx);\n         }\n-        return visitRemainPredicate(ctx);\n-    }\n-    \n-    private PredicateSegment createInSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        PredicateInRightValue predicateInRightValue = null != ctx.subquery() ? new PredicateInRightValue(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(),\n-                getExpressionSegments(ctx))\n-                : new PredicateInRightValue(ctx.LP_().getSymbol().getStartIndex(), ctx.RP_().getSymbol().getStopIndex(), getExpressionSegments(ctx));\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, predicateInRightValue);\n+        return visit(ctx.bitExpr(0));\n     }\n     \n-    private Collection<ExpressionSegment> getExpressionSegments(final PredicateContext ctx) {\n-        Collection<ExpressionSegment> result = new LinkedList<>();\n-        if (null != ctx.subquery()) {\n-            SubqueryContext subquery = ctx.subquery();\n-            result.add(new SubqueryExpressionSegment(new SubquerySegment(subquery.getStart().getStartIndex(), subquery.getStop().getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n-            return result;\n-        }\n-        for (ExprContext each : ctx.expr()) {\n-            result.add((ExpressionSegment) visit(each));\n+    private BinaryOperationExpression createBinaryOperationExpressionFromLike(final PredicateContext ctx) {\n+        BinaryOperationExpression result = new BinaryOperationExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        ListExpression listExpression = new ListExpression();\n+        for (SimpleExprContext each : ctx.simpleExpr()) {\n+            listExpression.getItems().add((ExpressionSegment) visit(each));\n         }\n+        result.setRight(listExpression);\n+        String operator;\n+        operator = null != ctx.NOT() ? \"NOT LIKE\" : \"LIKE\";\n+        result.setOperator(operator);\n+        String text = ctx.start.getInputStream().getText(new Interval(ctx.start.getStartIndex(), ctx.stop.getStopIndex()));\n+        result.setText(text);\n         return result;\n     }\n     \n-    private PredicateSegment createBetweenSegment(final PredicateContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.bitExpr(0));\n-        ExpressionSegment between = (ExpressionSegment) visit(ctx.bitExpr(1));\n-        ExpressionSegment and = (ExpressionSegment) visit(ctx.predicate());\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, new PredicateBetweenRightValue(between.getStartIndex(), and.getStopIndex(), between, and));\n+    private InExpression createInSegment(final PredicateContext ctx) {\n+        InExpression result = new InExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.bitExpr(0)));\n+        if (null != ctx.subquery()) {\n+            result.setRight(new SubqueryExpressionSegment(new SubquerySegment(ctx.subquery().start.getStartIndex(), ctx.subquery().stop.getStopIndex(), (SelectStatement) visit(ctx.subquery()))));\n+        } else {\n+            ListExpression listExpression = new ListExpression();\n+            listExpression.setStartIndex(ctx.LP_().getSymbol().getStartIndex());\n+            listExpression.setStopIndex(ctx.RP_().getSymbol().getStopIndex());", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0Nzg2MQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486947861", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:10:43Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/main/java/org/apache/shardingsphere/sql/parser/sql/common/util/ExpressionBuildUtil.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.sql.common.util;\n+\n+import lombok.RequiredArgsConstructor;\n+import org.apache.shardingsphere.sql.parser.sql.common.constant.LogicalOperator;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.BinaryOperationExpression;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.ExpressionSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.AndPredicate;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.predicate.OrPredicateSegment;\n+\n+import java.util.Optional;\n+\n+@RequiredArgsConstructor\n+public final class ExpressionBuildUtil {\n+    \n+    private final ExpressionSegment expression;\n+    \n+    /**\n+     * Extract andPredicates.\n+     *\n+     * @return OrPredicateSegment.\n+     */\n+    public OrPredicateSegment extractAndPredicates() {\n+        OrPredicateSegment orPredicate = new OrPredicateSegment();\n+        if (expression instanceof BinaryOperationExpression) {\n+            String operator = ((BinaryOperationExpression) expression).getOperator();\n+            Optional<LogicalOperator> logicalOperator = LogicalOperator.valueFrom(operator);\n+            if (logicalOperator.isPresent() && LogicalOperator.OR == logicalOperator.get()) {\n+                ExpressionBuildUtil leftUtil = new ExpressionBuildUtil(((BinaryOperationExpression) expression).getLeft());\n+                ExpressionBuildUtil rightUtil = new ExpressionBuildUtil(((BinaryOperationExpression) expression).getRight());\n+                orPredicate.getAndPredicates().addAll(leftUtil.extractAndPredicates().getAndPredicates());\n+                orPredicate.getAndPredicates().addAll(rightUtil.extractAndPredicates().getAndPredicates());\n+            } else if (logicalOperator.isPresent() && LogicalOperator.AND == logicalOperator.get()) {\n+                ExpressionBuildUtil leftUtil = new ExpressionBuildUtil(((BinaryOperationExpression) expression).getLeft());\n+                ExpressionBuildUtil rightUtil = new ExpressionBuildUtil(((BinaryOperationExpression) expression).getRight());\n+                for (AndPredicate eachLeft : leftUtil.extractAndPredicates().getAndPredicates()) {", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0ODE4MQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486948181", "bodyText": "Consider merging this one with ExpressionBuildUtil.java", "author": "tristaZero", "createdAt": "2020-09-11T10:11:27Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/main/java/org/apache/shardingsphere/sql/parser/sql/common/util/ExpressionUtil.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.sql.common.util;\n+\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.column.ColumnSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.BetweenExpression;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.BinaryOperationExpression;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.ExpressionSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.dml.expr.InExpression;\n+\n+public final class ExpressionUtil {\n+    \n+    /**\n+     * Get left value if left value of expression is ColumnSegment.", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0ODYyNA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486948624", "bodyText": "Remove", "author": "tristaZero", "createdAt": "2020-09-11T10:12:17Z", "path": "shardingsphere-features/shardingsphere-encrypt/shardingsphere-encrypt-rewrite/src/main/java/org/apache/shardingsphere/encrypt/rewrite/condition/EncryptConditionEngine.java", "diffHunk": "@@ -65,8 +67,13 @@\n         if (!whereSegment.isPresent()) {\n             return Collections.emptyList();\n         }\n+    ", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTAyNA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486949024", "bodyText": "Refactoring", "author": "tristaZero", "createdAt": "2020-09-11T10:13:04Z", "path": "shardingsphere-features/shardingsphere-shadow/shardingsphere-shadow-route/src/main/java/org/apache/shardingsphere/shadow/route/engine/judge/impl/PreparedShadowDataSourceJudgeEngine.java", "diffHunk": "@@ -61,27 +63,46 @@ public boolean isShadow() {\n             }\n             return false;\n         }\n-        if (sqlStatementContext instanceof WhereAvailable) {\n-            Optional<WhereSegment> whereSegment = ((WhereAvailable) sqlStatementContext).getWhere();\n-            if (!whereSegment.isPresent()) {\n-                return false;\n-            }\n-            Collection<AndPredicate> andPredicates = whereSegment.get().getAndPredicates();\n-            for (AndPredicate andPredicate : andPredicates) {\n-                if (judgePredicateSegments(andPredicate.getPredicates())) {\n-                    return true;\n-                }\n+        if (!(sqlStatementContext instanceof WhereAvailable)) {\n+            return false;\n+        }\n+        Optional<WhereSegment> whereSegment = ((WhereAvailable) sqlStatementContext).getWhere();\n+        if (!whereSegment.isPresent()) {\n+            return false;\n+        }\n+        Collection<AndPredicate> andPredicates = new LinkedList<>();\n+        ExpressionSegment expression = whereSegment.get().getExpr();\n+        ExpressionBuildUtil util = new ExpressionBuildUtil(expression);\n+        andPredicates.addAll(util.extractAndPredicates().getAndPredicates());\n+        for (AndPredicate andPredicate : andPredicates) {\n+            if (judgePredicateSegments(andPredicate.getPredicates())) {\n+                return true;\n             }\n         }\n         return false;\n     }\n     \n-    private boolean judgePredicateSegments(final Collection<PredicateSegment> predicates) {\n-        for (PredicateSegment each : predicates) {\n-            if (each.getColumn().getIdentifier().getValue().equals(shadowRule.getColumn())) {\n-                Preconditions.checkArgument(each.getRightValue() instanceof PredicateCompareRightValue, \"must be PredicateCompareRightValue\");\n-                PredicateCompareRightValue rightValue = (PredicateCompareRightValue) each.getRightValue();\n-                int parameterMarkerIndex = ((ParameterMarkerExpressionSegment) rightValue.getExpression()).getParameterMarkerIndex();\n+    private boolean judgePredicateSegments(final Collection<ExpressionSegment> predicates) {\n+        for (ExpressionSegment each : predicates) {\n+            if (!(each instanceof BinaryOperationExpression)) {\n+                continue;\n+            }\n+            BinaryOperationExpression expression = (BinaryOperationExpression) each;\n+            ColumnSegment column = null;\n+            ExpressionSegment right = null;\n+            if (expression.getLeft() instanceof ColumnSegment) {\n+                column = (ColumnSegment) ((BinaryOperationExpression) each).getLeft();\n+                right = ((BinaryOperationExpression) each).getRight();\n+            }\n+            if (null == column) {\n+                continue;\n+            }", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk0OTg2NA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486949864", "bodyText": "Refactoring", "author": "tristaZero", "createdAt": "2020-09-11T10:14:52Z", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/condition/engine/WhereClauseShardingConditionEngine.java", "diffHunk": "@@ -98,22 +107,45 @@\n         return result;\n     }\n     \n-    private Map<Column, Collection<RouteValue>> createRouteValueMap(final SQLStatementContext sqlStatementContext, final AndPredicate andPredicate, final List<Object> parameters) {\n+    private Map<Column, Collection<RouteValue>> createRouteValueMap(final SQLStatementContext sqlStatementContext, final AndPredicate expressions, final List<Object> parameters) {\n         Map<Column, Collection<RouteValue>> result = new HashMap<>();\n-        for (PredicateSegment each : andPredicate.getPredicates()) {\n-            Optional<String> tableName = sqlStatementContext.getTablesContext().findTableName(each.getColumn(), schemaMetaData);\n-            if (!tableName.isPresent() || !shardingRule.isShardingColumn(each.getColumn().getIdentifier().getValue(), tableName.get())) {\n-                continue;\n+    \n+        for (ExpressionSegment each : expressions.getPredicates()) {\n+            Optional<RouteValue> routeValue = Optional.empty();\n+            Column column = null;\n+            if (each instanceof BinaryOperationExpression && ((BinaryOperationExpression) each).getLeft() instanceof ColumnSegment) {\n+                ColumnSegment columnSegment = (ColumnSegment) ((BinaryOperationExpression) each).getLeft();\n+                Optional<String> tableName = sqlStatementContext.getTablesContext().findTableName(columnSegment, schemaMetaData);\n+                if (tableName.isPresent() && shardingRule.isShardingColumn(columnSegment.getIdentifier().getValue(), tableName.get())) {", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1MDE0NA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486950144", "bodyText": "Refactoring", "author": "tristaZero", "createdAt": "2020-09-11T10:15:20Z", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/impl/ShardingUpdateStatementValidator.java", "diffHunk": "@@ -95,27 +93,35 @@ public void postValidate(final SQLStatement sqlStatement, final RouteResult rout\n     }\n     \n     private Optional<Object> getShardingValue(final WhereSegment whereSegment, final List<Object> parameters, final String shardingColumn) {\n-        for (AndPredicate each : whereSegment.getAndPredicates()) {\n-            return getShardingValue(each, parameters, shardingColumn);\n+        if (null != whereSegment) {\n+            return getShardingValue(whereSegment.getExpr(), parameters, shardingColumn);\n         }\n         return Optional.empty();\n     }\n     \n-    private Optional<Object> getShardingValue(final AndPredicate andPredicate, final List<Object> parameters, final String shardingColumn) {\n-        for (PredicateSegment each : andPredicate.getPredicates()) {\n-            if (!shardingColumn.equalsIgnoreCase(each.getColumn().getIdentifier().getValue())) {\n-                continue;\n+    private Optional<Object> getShardingValue(final ExpressionSegment expression, final List<Object> parameters, final String shardingColumn) {\n+        if (expression instanceof InExpression && ((InExpression) expression).getLeft() instanceof ColumnSegment) {\n+            ColumnSegment column = (ColumnSegment) ((InExpression) expression).getLeft();\n+            if (!shardingColumn.equalsIgnoreCase(column.getIdentifier().getValue())) {\n+                return getPredicateInShardingValue(((InExpression) expression).getRight(), parameters);\n             }\n-            PredicateRightValue rightValue = each.getRightValue();\n-            if (rightValue instanceof PredicateCompareRightValue) {\n-                ExpressionSegment segment = ((PredicateCompareRightValue) rightValue).getExpression();\n-                return getPredicateCompareShardingValue(segment, parameters);\n-            }\n-            if (rightValue instanceof PredicateInRightValue) {\n-                Collection<ExpressionSegment> segments = ((PredicateInRightValue) rightValue).getSqlExpressions();\n-                return getPredicateInShardingValue(segments, parameters);\n+        }\n+        if (!(expression instanceof BinaryOperationExpression)) {\n+            return Optional.empty();\n+        }\n+        String operator = ((BinaryOperationExpression) expression).getOperator();\n+        boolean compare = \">\".equalsIgnoreCase(operator) || \">=\".equalsIgnoreCase(operator) || \"=\".equalsIgnoreCase(operator) || \"<\".equalsIgnoreCase(operator) || \"<=\".equalsIgnoreCase(operator);\n+        if (compare && ((BinaryOperationExpression) expression).getLeft() instanceof ColumnSegment) {\n+            ColumnSegment column = (ColumnSegment) ((BinaryOperationExpression) expression).getLeft();\n+            if (shardingColumn.equalsIgnoreCase(column.getIdentifier().getValue())) {", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1MDQwMQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486950401", "bodyText": "Refactoring", "author": "tristaZero", "createdAt": "2020-09-11T10:15:53Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/main/java/org/apache/shardingsphere/sql/parser/binder/segment/select/pagination/engine/RowNumberPaginationContextEngine.java", "diffHunk": "@@ -51,27 +50,39 @@\n     /**\n      * Create pagination context.\n      * \n-     * @param andPredicates and predicates\n+     * @param where where condition\n      * @param projectionsContext projections context\n      * @param parameters SQL parameters\n      * @return pagination context\n      */\n-    public PaginationContext createPaginationContext(final Collection<AndPredicate> andPredicates, final ProjectionsContext projectionsContext, final List<Object> parameters) {\n+    public PaginationContext createPaginationContext(final ExpressionSegment where, final ProjectionsContext projectionsContext, final List<Object> parameters) {\n         Optional<String> rowNumberAlias = isRowNumberAlias(projectionsContext);\n         if (!rowNumberAlias.isPresent()) {\n             return new PaginationContext(null, null, parameters);\n         }\n-        Collection<PredicateSegment> rowNumberPredicates = getRowNumberPredicates(andPredicates, rowNumberAlias.get());\n+        Collection<BinaryOperationExpression> rowNumberPredicates = getRowNumberPredicates(where, rowNumberAlias.get());\n         return rowNumberPredicates.isEmpty() ? new PaginationContext(null, null, parameters) : createPaginationWithRowNumber(rowNumberPredicates, parameters);\n     }\n     \n-    private Collection<PredicateSegment> getRowNumberPredicates(final Collection<AndPredicate> andPredicates, final String rowNumberAlias) {\n-        Collection<PredicateSegment> result = new LinkedList<>();\n-        for (AndPredicate each : andPredicates) {\n-            for (PredicateSegment predicate : each.getPredicates()) {\n-                if (isRowNumberColumn(predicate, rowNumberAlias) && isCompareCondition(predicate)) {\n-                    result.add(predicate);\n-                }\n+    private Collection<BinaryOperationExpression> getRowNumberPredicates(final ExpressionSegment where, final String rowNumberAlias) {\n+        List<BinaryOperationExpression> result = new LinkedList<>();\n+        if (!(where instanceof BinaryOperationExpression)) {\n+            return result;\n+        }\n+        String operator = ((BinaryOperationExpression) where).getOperator();\n+        if (((BinaryOperationExpression) where).getLeft() instanceof ColumnSegment && isRowNumberColumn((ColumnSegment) ((BinaryOperationExpression) where).getLeft(), rowNumberAlias)\n+                && isCompareCondition(operator)) {\n+            result.add((BinaryOperationExpression) where);\n+            return result;\n+        }\n+        if (\"and\".equalsIgnoreCase(operator) || \"&&\".equalsIgnoreCase(operator) || \"||\".equalsIgnoreCase(operator) || \"or\".equalsIgnoreCase(operator)) {\n+            Collection<BinaryOperationExpression> left = getRowNumberPredicates(((BinaryOperationExpression) where).getLeft(), rowNumberAlias);", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1MDY5Ng==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486950696", "bodyText": "The function is needed.", "author": "tristaZero", "createdAt": "2020-09-11T10:16:30Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/main/java/org/apache/shardingsphere/sql/parser/binder/segment/select/pagination/engine/TopPaginationContextEngine.java", "diffHunk": "@@ -43,47 +41,57 @@\n      * Create pagination context.\n      * \n      * @param topProjectionSegment top projection segment\n-     * @param andPredicates and predicates\n+     * @param where where condition\n      * @param parameters SQL parameters\n      * @return pagination context\n      */\n-    public PaginationContext createPaginationContext(final TopProjectionSegment topProjectionSegment, final Collection<AndPredicate> andPredicates, final List<Object> parameters) {\n-        Optional<PredicateSegment> rowNumberPredicate = getRowNumberPredicate(andPredicates, topProjectionSegment.getAlias());\n+    public PaginationContext createPaginationContext(final TopProjectionSegment topProjectionSegment, final ExpressionSegment where, final List<Object> parameters) {\n+        Optional<ExpressionSegment> rowNumberPredicate = null != where ? getRowNumberPredicate(where, topProjectionSegment.getAlias()) : Optional.empty();\n         Optional<PaginationValueSegment> offset = rowNumberPredicate.isPresent() ? createOffsetWithRowNumber(rowNumberPredicate.get()) : Optional.empty();\n         PaginationValueSegment rowCount = topProjectionSegment.getTop();\n         return new PaginationContext(offset.orElse(null), rowCount, parameters);\n     }\n     \n-    private Optional<PredicateSegment> getRowNumberPredicate(final Collection<AndPredicate> andPredicates, final String rowNumberAlias) {\n-        for (AndPredicate each : andPredicates) {\n-            for (PredicateSegment predicate : each.getPredicates()) {\n-                if (isRowNumberColumn(predicate, rowNumberAlias) && isCompareCondition(predicate)) {\n-                    return Optional.of(predicate);\n-                }\n+    private Optional<ExpressionSegment> getRowNumberPredicate(final ExpressionSegment where, final String rowNumberAlias) {\n+        if (!(where instanceof BinaryOperationExpression)) {\n+            return Optional.empty();\n+        }\n+        String operator = ((BinaryOperationExpression) where).getOperator();\n+        if (((BinaryOperationExpression) where).getLeft() instanceof ColumnSegment && isRowNumberColumn((ColumnSegment) ((BinaryOperationExpression) where).getLeft(), rowNumberAlias)", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1MDk1NA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486950954", "bodyText": "Remove.", "author": "tristaZero", "createdAt": "2020-09-11T10:16:59Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/test/java/org/apache/shardingsphere/sql/parser/binder/segment/select/pagination/engine/TopPaginationContextEngineTest.java", "diffHunk": "@@ -76,25 +76,23 @@ public void assertCreatePaginationContextWhenRowNumberPredicatePresentAndOperato\n     public void assertCreatePaginationContextWhenPredicateInRightValue() {\n         String name = \"rowNumberAlias\";\n         ColumnSegment columnSegment = new ColumnSegment(0, 10, new IdentifierValue(name));\n-        PredicateSegment predicateSegment = new PredicateSegment(0, 10, columnSegment, new PredicateInRightValue(0, 10, Collections.emptyList()));\n-        AndPredicate andPredicate = new AndPredicate();\n-        andPredicate.getPredicates().add(predicateSegment);\n-        Collection<AndPredicate> andPredicates = Collections.singleton(andPredicate);\n-        PaginationContext paginationContext = topPaginationContextEngine.createPaginationContext(new TopProjectionSegment(0, 10, null, name), andPredicates, Collections.emptyList());\n+        InExpression inExpression = new InExpression();\n+        inExpression.setLeft(new ColumnSegment(0, 10, new IdentifierValue(name)));\n+        inExpression.setRight(new ListExpression());\n+        PaginationContext paginationContext = topPaginationContextEngine.createPaginationContext(new TopProjectionSegment(0, 10, null, name), inExpression, Collections.emptyList());\n         assertFalse(paginationContext.getOffsetSegment().isPresent());\n         assertFalse(paginationContext.getRowCountSegment().isPresent());\n     }\n     \n     @Test\n     public void assertCreatePaginationContextWhenParameterMarkerRowNumberValueSegment() {\n         String name = \"rowNumberAlias\";\n-        ColumnSegment columnSegment = new ColumnSegment(0, 10, new IdentifierValue(name));\n-        PredicateCompareRightValue predicateCompareRightValue = new PredicateCompareRightValue(0, 10, \">\", new ParameterMarkerExpressionSegment(0, 10, 0));\n-        PredicateSegment predicateSegment = new PredicateSegment(0, 10, columnSegment, predicateCompareRightValue);\n-        AndPredicate andPredicate = new AndPredicate();\n-        andPredicate.getPredicates().add(predicateSegment);\n-        Collection<AndPredicate> andPredicates = Collections.singleton(andPredicate);\n-        PaginationContext paginationContext = topPaginationContextEngine.createPaginationContext(new TopProjectionSegment(0, 10, null, name), andPredicates, Collections.singletonList(1));\n+        BinaryOperationExpression expression = new BinaryOperationExpression();\n+        expression.setOperator(\">\");\n+        expression.setRight(new ParameterMarkerExpressionSegment(0, 10, 0));\n+        expression.setLeft(new ColumnSegment(0, 10, new IdentifierValue(name)));\n+        ", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1MTA2MA==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486951060", "bodyText": "Remove.", "author": "tristaZero", "createdAt": "2020-09-11T10:17:11Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/test/java/org/apache/shardingsphere/sql/parser/binder/segment/select/pagination/engine/TopPaginationContextEngineTest.java", "diffHunk": "@@ -107,13 +105,12 @@ public void assertCreatePaginationContextWhenParameterMarkerRowNumberValueSegmen\n     \n     private void assertCreatePaginationContextWhenRowNumberPredicatePresentAndWithGivenOperator(final String operator) {\n         String name = \"rowNumberAlias\";\n-        ColumnSegment columnSegment = new ColumnSegment(0, 10, new IdentifierValue(name));\n-        PredicateCompareRightValue predicateCompareRightValue = new PredicateCompareRightValue(0, 10, operator, new LiteralExpressionSegment(0, 10, 100));\n-        PredicateSegment predicateSegment = new PredicateSegment(0, 10, columnSegment, predicateCompareRightValue);\n-        AndPredicate andPredicate = new AndPredicate();\n-        andPredicate.getPredicates().add(predicateSegment);\n-        Collection<AndPredicate> andPredicates = Collections.singleton(andPredicate);\n-        PaginationContext paginationContext = topPaginationContextEngine.createPaginationContext(new TopProjectionSegment(0, 10, null, name), andPredicates, Collections.emptyList());\n+        BinaryOperationExpression expression = new BinaryOperationExpression();\n+        expression.setOperator(operator);\n+        expression.setRight(new LiteralExpressionSegment(0, 10, 100));\n+        expression.setLeft(new ColumnSegment(0, 10, new IdentifierValue(name)));\n+        ", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1MTI0Mg==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486951242", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:17:31Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/MySQLVisitor.java", "diffHunk": "@@ -255,123 +254,173 @@ public final ASTNode visitExpr(final ExprContext ctx) {\n         if (null != ctx.booleanPrimary()) {\n             return visit(ctx.booleanPrimary());\n         }\n+        if (null != ctx.LP_()) {\n+            return visit(ctx.expr(0));\n+        }\n+        if (null != ctx.XOR()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.expr(0)));\n+            result.setRight((ExpressionSegment) visit(ctx.expr(1)));", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1MTY5NQ==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r486951695", "bodyText": "A function is needed here.", "author": "tristaZero", "createdAt": "2020-09-11T10:18:25Z", "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-postgresql/src/main/java/org/apache/shardingsphere/sql/parser/postgresql/visitor/PostgreSQLVisitor.java", "diffHunk": "@@ -250,24 +260,76 @@ public ASTNode visitColumnref(final ColumnrefContext ctx) {\n         return new ColumnSegment(ctx.colId().start.getStartIndex(), ctx.colId().stop.getStopIndex(), new IdentifierValue(ctx.colId().getText()));\n     }\n     \n-    private PredicateSegment createInSegment(final AExprContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.aExpr(0).cExpr().columnref());\n-        ASTNode predicateInRightValue = visit(ctx.inExpr());\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, (PredicateRightValue) predicateInRightValue);\n+    private InExpression createInSegment(final AExprContext ctx) {\n+        InExpression result = new InExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.aExpr(0)));\n+        result.setRight(visitInExpression(ctx.inExpr()));\n+        if (null != ctx.NOT()) {\n+            result.setNot(true);\n+        } else {\n+            result.setNot(false);\n+        }\n+        return result;\n     }\n     \n-    private PredicateSegment createBetweenSegment(final AExprContext ctx) {\n-        ColumnSegment column = (ColumnSegment) visit(ctx.aExpr().get(0));\n-        SQLSegment value = (SQLSegment) visit(ctx.bExpr());\n-        return new PredicateSegment(ctx.getStart().getStartIndex(), ctx.getStop().getStopIndex(), column, new PredicateBetweenRightValue(value.getStartIndex(), value.getStopIndex(),\n-                (ExpressionSegment) value, (ExpressionSegment) visit(ctx.aExpr(1))));\n+    private ExpressionSegment visitInExpression(final InExprContext ctx) {\n+        if (null != ctx.selectWithParens()) {\n+            SelectStatement select = (SelectStatement) visit(ctx.selectWithParens());\n+            SubquerySegment subquerySegment = new SubquerySegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex(), select);\n+            SubqueryExpressionSegment result = new SubqueryExpressionSegment(subquerySegment);\n+            return result;\n+        }\n+        return (ExpressionSegment) visit(ctx.exprList());\n+    }\n+    \n+    @Override\n+    public ASTNode visitExprList(final ExprListContext ctx) {\n+        ListExpression result = new ListExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        if (null != ctx.exprList()) {\n+            result.getItems().addAll(((ListExpression) visitExprList(ctx.exprList())).getItems());\n+        }\n+        result.getItems().add((ExpressionSegment) visit(ctx.aExpr()));\n+        return result;\n+    }\n+    \n+    private BetweenExpression createBetweenSegment(final AExprContext ctx) {\n+        BetweenExpression result = new BetweenExpression();\n+        result.setStartIndex(ctx.start.getStartIndex());\n+        result.setStopIndex(ctx.stop.getStopIndex());\n+        result.setLeft((ExpressionSegment) visit(ctx.aExpr(0)));\n+        result.setBetweenExpr((ExpressionSegment) visit(ctx.bExpr()));\n+        result.setAndExpr((ExpressionSegment) visit(ctx.aExpr(1)));\n+        if (null != ctx.NOT()) {\n+            result.setNot(true);\n+        }\n+        return result;\n     }\n     \n     @Override\n     public ASTNode visitBExpr(final BExprContext ctx) {\n         if (null != ctx.cExpr()) {\n             return visit(ctx.cExpr());\n         }\n+        if (null != ctx.TYPE_CAST_() || null != ctx.qualOp()) {\n+            BinaryOperationExpression result = new BinaryOperationExpression();\n+            result.setStartIndex(ctx.start.getStartIndex());\n+            result.setStopIndex(ctx.stop.getStopIndex());\n+            result.setLeft((ExpressionSegment) visit(ctx.bExpr(0)));\n+            if (null != ctx.TYPE_CAST_()) {\n+                result.setOperator(ctx.TYPE_CAST_().getText());\n+                result.setRight(new CommonExpressionSegment(ctx.typeName().start.getStartIndex(), ctx.typeName().stop.getStopIndex(), ctx.typeName().getText()));\n+            } else {", "originalCommit": "03ee18274ca59ed49cdd029e4d058316e255e5de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "773e451aa86107ef405fbda5fa2c1f144f2293f8", "url": "https://github.com/apache/shardingsphere/commit/773e451aa86107ef405fbda5fa2c1f144f2293f8", "message": "fix", "committedDate": "2020-09-11T11:13:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM0MzYzNw==", "url": "https://github.com/apache/shardingsphere/pull/7353#discussion_r487343637", "bodyText": "Remove", "author": "tristaZero", "createdAt": "2020-09-12T00:33:32Z", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/condition/engine/WhereClauseShardingConditionEngine.java", "diffHunk": "@@ -73,21 +78,25 @@\n         List<ShardingCondition> result = new ArrayList<>();\n         Optional<WhereSegment> whereSegment = ((WhereAvailable) sqlStatementContext).getWhere();\n         if (whereSegment.isPresent()) {\n-            result.addAll(createShardingConditions(sqlStatementContext, whereSegment.get().getAndPredicates(), parameters));\n+            result.addAll(createShardingConditions(sqlStatementContext, whereSegment.get().getExpr(), parameters));\n         }\n         Collection<WhereSegment> subqueryWhereSegments = sqlStatementContext.getSqlStatement() instanceof SelectStatement\n                 ? WhereSegmentExtractUtils.getSubqueryWhereSegments((SelectStatement) sqlStatementContext.getSqlStatement()) : Collections.emptyList();\n         for (WhereSegment each : subqueryWhereSegments) {\n-            Collection<ShardingCondition> subqueryShardingConditions = createShardingConditions(sqlStatementContext, each.getAndPredicates(), parameters);\n+            Collection<ShardingCondition> subqueryShardingConditions = createShardingConditions(sqlStatementContext, each.getExpr(), parameters);\n             if (!result.containsAll(subqueryShardingConditions)) {\n                 result.addAll(subqueryShardingConditions);\n             }\n         }\n         return result;\n     }\n     \n-    private Collection<ShardingCondition> createShardingConditions(final SQLStatementContext sqlStatementContext, final Collection<AndPredicate> andPredicates, final List<Object> parameters) {\n+    private Collection<ShardingCondition> createShardingConditions(final SQLStatementContext sqlStatementContext, final ExpressionSegment expressionSegment, final List<Object> parameters) {\n         Collection<ShardingCondition> result = new LinkedList<>();\n+    ", "originalCommit": "773e451aa86107ef405fbda5fa2c1f144f2293f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}