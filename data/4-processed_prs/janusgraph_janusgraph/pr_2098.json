{"pr_number": 2098, "pr_title": "Reduce guava usage [full build]", "pr_createdAt": "2020-04-25T04:12:40Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2098", "timeline": [{"oid": "e0fc8cff8d9d9c74ff9990740318d0394d5b3c06", "url": "https://github.com/JanusGraph/janusgraph/commit/e0fc8cff8d9d9c74ff9990740318d0394d5b3c06", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-25T05:05:55Z", "type": "forcePushed"}, {"oid": "56ed788f4e3c506ad3793e6f7b3ffaa59d8c0b5a", "url": "https://github.com/JanusGraph/janusgraph/commit/56ed788f4e3c506ad3793e6f7b3ffaa59d8c0b5a", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-25T06:21:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5NDUxOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r414994519", "bodyText": "There is no need for a new copy of the list because orders don't change in IndexSerializer where it is accessed. Thus I've changed this code to Collections.unmodifiableList(orders) to return a reference to orders wrapped in unmodifiableList instead of copying all elements to a new list.", "author": "porunov", "createdAt": "2020-04-25T06:25:58Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/query/graph/IndexQueryBuilder.java", "diffHunk": "@@ -121,8 +121,8 @@ public String getQuery() {\n         return query;\n     }\n \n-    public ImmutableList<Parameter<Order>> getOrders() {\n-        return ImmutableList.copyOf(orders);", "originalCommit": "56ed788f4e3c506ad3793e6f7b3ffaa59d8c0b5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "52ef5f7171442fd77169b542a3c320dafd8b9951", "url": "https://github.com/JanusGraph/janusgraph/commit/52ef5f7171442fd77169b542a3c320dafd8b9951", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-25T08:16:04Z", "type": "forcePushed"}, {"oid": "ad690063140ba3f6d61e995ef14dfe2e12160e54", "url": "https://github.com/JanusGraph/janusgraph/commit/ad690063140ba3f6d61e995ef14dfe2e12160e54", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-25T08:48:33Z", "type": "forcePushed"}, {"oid": "c9278f80a88c1cd7aad774ccc6adcdc087184a6f", "url": "https://github.com/JanusGraph/janusgraph/commit/c9278f80a88c1cd7aad774ccc6adcdc087184a6f", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-25T08:50:13Z", "type": "forcePushed"}, {"oid": "973473df31cdbd89f123a942c96a12bd2f940913", "url": "https://github.com/JanusGraph/janusgraph/commit/973473df31cdbd89f123a942c96a12bd2f940913", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-25T09:14:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MDg0OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415070848", "bodyText": "java 8 has Function.identity() too", "author": "mad", "createdAt": "2020-04-25T14:12:40Z", "path": "janusgraph-core/src/main/java/org/janusgraph/diskstorage/keycolumnvalue/KCVMutation.java", "diffHunk": "@@ -30,17 +30,19 @@\n \n public class KCVMutation extends Mutation<Entry,StaticBuffer> {\n \n+    public static final Function<StaticBuffer,StaticBuffer> IDENTITY_FUNCTION = key -> key;", "originalCommit": "973473df31cdbd89f123a942c96a12bd2f940913", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEzNDYwNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415134605", "bodyText": "fixed", "author": "porunov", "createdAt": "2020-04-25T20:09:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3MDg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3NDQ0Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415074443", "bodyText": "I think we should avoid stream API for work intensive place like this, some benchmark https://stackoverflow.com/questions/22658322/java-8-performance-of-streams-vs-collections shows slows performance vs vanilla java\nI run benchmark based from SO\n@OutputTimeUnit(TimeUnit.NANOSECONDS)\n@BenchmarkMode(Mode.AverageTime)\n@OperationsPerInvocation(StreamVsVanilla.N)\npublic class StreamVsVanilla {\n    public static final int N = 100000;\n\n    static List<String> sourceList = new ArrayList<>();\n\n    static {\n        for (int i = 0; i < N; i++) {\n            sourceList.add(\"hello\");\n        }\n    }\n\n    @Benchmark\n    public Set<String> vanilla() {\n        Set<String> adds = new HashSet<>();\n        for (final String s : sourceList) {\n            adds.add((String) Function.identity().apply(s));\n        }\n        return adds;\n    }\n\n    @Benchmark\n    public Set<String> stream() {\n        Function<String, String> identity = Function.identity();\n        Set<String> adds = sourceList.stream().map(identity).collect(Collectors.toSet());\n        return adds;\n    }\n}\n\nResult is\nBenchmark                Mode  Cnt   Score   Error  Units\nStreamVsVanilla.stream   avgt   25  10.169 \u00b1 0.576  ns/op\nStreamVsVanilla.vanilla  avgt   25   8.789 \u00b1 0.328  ns/op", "author": "mad", "createdAt": "2020-04-25T14:33:02Z", "path": "janusgraph-core/src/main/java/org/janusgraph/diskstorage/Mutation.java", "diffHunk": "@@ -149,15 +150,15 @@ public int getTotalMutations() {\n      */\n     public<V> void consolidate(Function<E,V> convertAdditions, Function<K,V> convertDeletions) {\n         if (hasDeletions() && hasAdditions()) {\n-            Set<V> adds = Sets.newHashSet(Iterables.transform(additions,convertAdditions));\n+            Set<V> adds = additions.stream().map(convertAdditions).collect(Collectors.toSet());", "originalCommit": "973473df31cdbd89f123a942c96a12bd2f940913", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEwODEyNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415108126", "bodyText": "Thanks a lot for checking it! I will change to vanilla version. Let me know if you think we need to change from stream api to vanilla anywhere else also.", "author": "porunov", "createdAt": "2020-04-25T17:38:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3NDQ0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTEzNDYxMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415134613", "bodyText": "fixed", "author": "porunov", "createdAt": "2020-04-25T20:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTA3NDQ0Mw=="}], "type": "inlineReview"}, {"oid": "522e2b554cb06ad5d63ee8bc75e1c0ac5940cb8f", "url": "https://github.com/JanusGraph/janusgraph/commit/522e2b554cb06ad5d63ee8bc75e1c0ac5940cb8f", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-25T20:06:36Z", "type": "forcePushed"}, {"oid": "708a869a3097e454a41dd21165382eabd560c31e", "url": "https://github.com/JanusGraph/janusgraph/commit/708a869a3097e454a41dd21165382eabd560c31e", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-25T20:08:50Z", "type": "forcePushed"}, {"oid": "f6083e198704e459112eb21320a76311d87bf71e", "url": "https://github.com/JanusGraph/janusgraph/commit/f6083e198704e459112eb21320a76311d87bf71e", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-25T23:45:27Z", "type": "forcePushed"}, {"oid": "27adaf9195904d83598bfeb56aef851b987a0841", "url": "https://github.com/JanusGraph/janusgraph/commit/27adaf9195904d83598bfeb56aef851b987a0841", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-26T00:17:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzNzEwNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415537106", "bodyText": "The StringBuilder/Iterator pattern appears tree times in this class, with very similar code for each. I suggest replacing this logic and use Java's included String.join. How about something like this:\nprivate static <E> String join(Stream<E> elements, Function<E,String> elementToString, String entrySeparator) {\n    Stream<String> convertedElements = elements.map(elementToString);\n    return String.join(entrySeparator, (Iterable<String>) convertedElements::iterator);\n}\nYou can then wrap this method for Inputs of type Map<?,?>, Object[] and Collection<?>.", "author": "rngcntr", "createdAt": "2020-04-27T06:12:44Z", "path": "janusgraph-driver/src/main/java/org/janusgraph/util/StringUtils.java", "diffHunk": "@@ -0,0 +1,74 @@\n+// Copyright 2020 JanusGraph Authors\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package org.janusgraph.util;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.Map;\n+\n+public class StringUtils {\n+\n+    public static String join(Map<?, ?> elements, String keyValueSeparator, String entriesSeparator){\n+        if(elements == null){\n+            return \"\";\n+        }\n+        Iterator<? extends Map.Entry<?, ?>> it = elements.entrySet().iterator();\n+        if(it.hasNext()){\n+            Map.Entry<?, ?> entry = it.next();\n+            StringBuilder stringBuilder = new StringBuilder();\n+            stringBuilder.append(entry.getKey()).append(keyValueSeparator).append(entry.getValue());\n+            while (it.hasNext()){\n+                entry = it.next();\n+                stringBuilder.append(entriesSeparator).append(entry.getKey()).append(keyValueSeparator).append(entry.getValue());", "originalCommit": "27adaf9195904d83598bfeb56aef851b987a0841", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA5NzM1OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416097359", "bodyText": "I don't know how can we use it to join(Map<?, ?> elements, String keyValueSeparator, String entriesSeparator) without redundant concatenations inside elementToString function (i.e.  entry -> entry.getKey() + entriesSeparator + entry.getValue()). So I will use this technique for 2 methods but will leave join(Map<?, ?> elements, String keyValueSeparator, String entriesSeparator) unattached", "author": "porunov", "createdAt": "2020-04-27T19:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzNzEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxNzQwNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416317404", "bodyText": "What exactly is redundant in your approach? If you are worried inefficient String concatenation with +, you can do String.join(keyValueSeparator, entry.getKey(), entry.getValue()) in the lambda function.", "author": "rngcntr", "createdAt": "2020-04-28T04:28:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzNzEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMyNzg4Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416327887", "bodyText": "String.join(keyValueSeparator, entry.getKey(), entry.getValue()) - is the same as entry.getKey() + keyValueSeparator + entry.getValue() - both approaches create a new concatenated string.\nThus, we are making many unnecessary short-lived new objects in heap.\nIn the current approach we are not creating unnecessary short-lived objects by putting all string values into the same string buffer which will create a single object after calling toString().\nTo be clear I am talking about this approach (which isn't sufficient due to unnecessary string concatenation): elements.map(entry -> String.join(keyValueSeparator, entry.getKey(), entry.getValue())).collect(Collectors.joining(separator));. For each entry we are making a new string concatenation instead of making a single concatenation in the end of the loop.", "author": "porunov", "createdAt": "2020-04-28T05:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzNzEwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ3Mzk0Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416473942", "bodyText": "resolved", "author": "rngcntr", "createdAt": "2020-04-28T09:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTUzNzEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODQ1Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415548453", "bodyText": "Nitpick: !sortKeyHashSet.retainAll(signature).isEmpty() does exactly what you are implementing here.", "author": "rngcntr", "createdAt": "2020-04-27T06:37:52Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/types/StandardRelationTypeMaker.java", "diffHunk": "@@ -79,8 +78,12 @@ private void checkGeneralArguments() {\n         checkSortKey(sortKey);\n         Preconditions.checkArgument(sortOrder==Order.ASC || hasSortKey(),\"Must define a sort key to use ordering\");\n         checkSignature(signature);\n-        Preconditions.checkArgument(Sets.intersection(Sets.newHashSet(sortKey), Sets.newHashSet(signature)).isEmpty(),\n-                \"Signature and sort key must be disjoined\");\n+        HashSet<PropertyKey> sortKeyHashSet = new HashSet<>(sortKey);\n+        for(PropertyKey propertyKey : signature){", "originalCommit": "27adaf9195904d83598bfeb56aef851b987a0841", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAzNTEyNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416035126", "bodyText": "The result might be similar but the implementation isn't same as it modifies one of collections and it isn't short-circuiting as this loop. I will use stream technique here signature.stream().anyMatch(sortKeyHashSet::contains) which is also short-circuiting and contains less code then vanilla java", "author": "porunov", "createdAt": "2020-04-27T18:06:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU0ODQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NDcwMg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415564702", "bodyText": "Nitpick: How about this?\nthis.propertyKeys = StreamSupport.stream(keys.spliterator, false)\n    .map(PropertyKey::longId)\n    .collect(Collectors.toCollection(HashSet::new));", "author": "rngcntr", "createdAt": "2020-04-27T07:10:24Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/database/management/ManagementSystem.java", "diffHunk": "@@ -946,13 +950,15 @@ private UpdateStatusTrigger(StandardJanusGraph graph, JanusGraphSchemaVertex ver\n             this.graph = graph;\n             this.schemaVertexId = vertex.longId();\n             this.newStatus = newStatus;\n-            this.propertyKeys = Sets.newHashSet(Iterables.transform(keys, new Function<PropertyKey, Long>() {\n+            Iterable<? extends Long> it = Iterables.transform(keys, new Function<PropertyKey, Long>() {", "originalCommit": "27adaf9195904d83598bfeb56aef851b987a0841", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAzODk1Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416038957", "bodyText": "Good point, as I noted in this PR I didn't go through all the code because it is hard to move all guava usages in once and I was planning to move all guava usages in chunks but I will move this part to stream api as you noted here.", "author": "porunov", "createdAt": "2020-04-27T18:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NDcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MDkwMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415570900", "bodyText": "Nit: StreamSupport.stream(configuration.getKeys().spliterator(), false)\nSee stackoverflow post", "author": "rngcntr", "createdAt": "2020-04-27T07:21:15Z", "path": "janusgraph-core/src/main/java/org/janusgraph/core/JanusGraphFactory.java", "diffHunk": "@@ -373,7 +373,9 @@ private static ReadConfiguration getLocalConfiguration(File file) {\n                                   Pattern.quote(INDEX_CONF_FILE.getName()) +  \")\"\n             + \")\");\n \n-            final Iterator<String> keysToMangle = Iterators.filter(configuration.getKeys(), key -> null != key && p.matcher(key).matches());\n+            final Iterator<String> keysToMangle = StreamSupport.stream(\n+                Spliterators.spliteratorUnknownSize(configuration.getKeys(), 0), false)", "originalCommit": "27adaf9195904d83598bfeb56aef851b987a0841", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA0NzE0Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416047146", "bodyText": "This is very helpful! I will change to direct spliterator call", "author": "porunov", "createdAt": "2020-04-27T18:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MDkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA1MDQyMg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416050422", "bodyText": "Ah, going into a code, I see that getKeys returns an itarator, so we are not able to call spliterator() as it isn't itarable.", "author": "porunov", "createdAt": "2020-04-27T18:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3MDkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3ODgwMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415578800", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        kcvs.mutateEntries(key, list, KCVSCache.NO_DELETIONS,tx);\n          \n          \n            \n                        kcvs.mutateEntries(key, Arrays.asList(cell), KCVSCache.NO_DELETIONS, tx);", "author": "rngcntr", "createdAt": "2020-04-27T07:34:27Z", "path": "janusgraph-core/src/main/java/org/janusgraph/diskstorage/log/kcvs/ExternalCachePersistor.java", "diffHunk": "@@ -38,7 +40,9 @@ public ExternalCachePersistor(KCVSCache kcvs, CacheTransaction tx) {\n     @Override\n     public void add(StaticBuffer key, Entry cell) {\n         try {\n-            kcvs.mutateEntries(key, Lists.newArrayList(cell), KCVSCache.NO_DELETIONS,tx);\n+            List<Entry> list = new ArrayList<>(1);\n+            list.add(cell);\n+            kcvs.mutateEntries(key, list, KCVSCache.NO_DELETIONS,tx);", "originalCommit": "27adaf9195904d83598bfeb56aef851b987a0841", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NDU3Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416064577", "bodyText": "From guava documentation newArrayList\n\nCreates a mutable ArrayList instance containing the given elements.\n\nFrom java docs Arrays.asList\n\nReturns a fixed-size list backed by the specified array\n\nAs an array cannot change its size, it can only replace it's elements by other elements but no addition or deletion are supported. So, new ArrayList and Arrays.asList are different lists. If some code will try to remove or add something into that list, we will get UnsupportedOperationException.", "author": "porunov", "createdAt": "2020-04-27T18:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3ODgwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxMzYxNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416313615", "bodyText": "Good to know! Thank you for pointing that out", "author": "rngcntr", "createdAt": "2020-04-28T04:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU3ODgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4NDAxMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415584011", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        deletions = new ArrayList<>(1);\n          \n          \n            \n                        deletions = Arrays.asList(column);", "author": "rngcntr", "createdAt": "2020-04-27T07:42:46Z", "path": "janusgraph-core/src/main/java/org/janusgraph/diskstorage/configuration/backend/KCVSConfiguration.java", "diffHunk": "@@ -134,7 +130,8 @@ public String toString() {\n             additions.add(StaticArrayEntry.of(column, val));\n         } else { //Deletion\n             additions = KeyColumnValueStore.NO_ADDITIONS;\n-            deletions = Lists.newArrayList(column);\n+            deletions = new ArrayList<>(1);", "originalCommit": "27adaf9195904d83598bfeb56aef851b987a0841", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NDg2MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416064860", "bodyText": "Same as #2098 (comment)", "author": "porunov", "createdAt": "2020-04-27T18:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4NDAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4NzY4Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415587683", "bodyText": "Nit: Maybe add a comment that the order of instructions matters here. Just do avoid bugs if anybody edits this code in the future.", "author": "rngcntr", "createdAt": "2020-04-27T07:48:27Z", "path": "janusgraph-core/src/main/java/org/janusgraph/diskstorage/configuration/MergedConfiguration.java", "diffHunk": "@@ -48,27 +44,22 @@ public boolean has(ConfigOption option, boolean includeRoot, String... umbrellaE\n     @Override\n     public Set<String> getContainedNamespaces(ConfigNamespace umbrella,\n             String... umbrellaElements) {\n-        ImmutableSet.Builder<String> b = ImmutableSet.builder();\n-        b.addAll(first.getContainedNamespaces(umbrella, umbrellaElements));\n-        b.addAll(second.getContainedNamespaces(umbrella, umbrellaElements));\n-        return b.build();\n+        Set<String> firstContainedNamespaces = first.getContainedNamespaces(umbrella, umbrellaElements);\n+        Set<String> secondContainedNamespaces = second.getContainedNamespaces(umbrella, umbrellaElements);\n+        Set<String> b = new HashSet<>(firstContainedNamespaces.size()+secondContainedNamespaces.size());\n+        b.addAll(firstContainedNamespaces);\n+        b.addAll(secondContainedNamespaces);\n+        return Collections.unmodifiableSet(b);\n     }\n     @Override\n     public Map<String, Object> getSubset(ConfigNamespace umbrella,\n             String... umbrellaElements) {\n-        ImmutableMap.Builder<String, Object> b = ImmutableMap.builder();\n         Map<String, Object> fm = first.getSubset(umbrella, umbrellaElements);\n         Map<String, Object> sm = second.getSubset(umbrella, umbrellaElements);\n-\n-        b.putAll(first.getSubset(umbrella, umbrellaElements));\n-\n-        for (Map.Entry<String, Object> secondEntry : sm.entrySet()) {\n-            if (!fm.containsKey(secondEntry.getKey())) {\n-                b.put(secondEntry);\n-            }\n-        }\n-\n-        return b.build();\n+        Map<String, Object> b = new HashMap<>(fm.size()+sm.size());\n+        b.putAll(sm);\n+        b.putAll(fm);", "originalCommit": "27adaf9195904d83598bfeb56aef851b987a0841", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU5Mjg1OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r415592858", "bodyText": "Is there any particular reason to go with LinkedHashSet here? Just asking.", "author": "rngcntr", "createdAt": "2020-04-27T07:56:08Z", "path": "janusgraph-core/src/main/java/org/janusgraph/diskstorage/StandardIndexProvider.java", "diffHunk": "@@ -14,39 +14,33 @@\n \n package org.janusgraph.diskstorage;\n \n-import com.google.common.collect.ImmutableList;\n-import com.google.common.collect.ImmutableMap;\n-\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n+import java.util.*;\n \n /**\n  * This enum is only intended for use by JanusGraph internals.\n  * It is subject to backwards-incompatible change.\n  */\n public enum StandardIndexProvider {\n     LUCENE(\"org.janusgraph.diskstorage.lucene.LuceneIndex\", \"lucene\"),\n-    ELASTICSEARCH(\"org.janusgraph.diskstorage.es.ElasticSearchIndex\", ImmutableList.of(\"elasticsearch\", \"es\")),\n+    ELASTICSEARCH(\"org.janusgraph.diskstorage.es.ElasticSearchIndex\", Arrays.asList(\"elasticsearch\", \"es\")),\n     SOLR(\"org.janusgraph.diskstorage.solr.SolrIndex\", \"solr\");\n \n+    private static final Set<String> ALL_SHORTHANDS;\n+    private static final Map<String, String> ALL_MANAGER_CLASSES;\n+\n     private final String providerName;\n-    private final ImmutableList<String> shorthands;\n+    private final Set<String> shorthands;\n \n     StandardIndexProvider(String providerName, String shorthand) {\n-        this(providerName, ImmutableList.of(shorthand));\n+        this(providerName, Collections.singleton(shorthand));\n     }\n \n-    StandardIndexProvider(String providerName, ImmutableList<String> shorthands) {\n+    StandardIndexProvider(String providerName, Collection<String> shorthands) {\n         this.providerName = providerName;\n-        this.shorthands = shorthands;\n+        this.shorthands = Collections.unmodifiableSet(new LinkedHashSet<>(shorthands));", "originalCommit": "27adaf9195904d83598bfeb56aef851b987a0841", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjA2NjczNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416066736", "bodyText": "Yes. We should have the same order here to avoid doc changes. Otherwise order in our doc will be changed", "author": "porunov", "createdAt": "2020-04-27T18:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU5Mjg1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxMjk3OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r416312978", "bodyText": "Alright, thanks!", "author": "rngcntr", "createdAt": "2020-04-28T04:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU5Mjg1OA=="}], "type": "inlineReview"}, {"oid": "4b8dd4e10a0d8f38e6c831aed3f4472707cfce24", "url": "https://github.com/JanusGraph/janusgraph/commit/4b8dd4e10a0d8f38e6c831aed3f4472707cfce24", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-27T19:45:29Z", "type": "forcePushed"}, {"oid": "67adfc0066708db8efe293b7904e18c93a5c0b65", "url": "https://github.com/JanusGraph/janusgraph/commit/67adfc0066708db8efe293b7904e18c93a5c0b65", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-27T19:53:14Z", "type": "forcePushed"}, {"oid": "be12be0554c2e347a77c8a509656267d64dd4cd0", "url": "https://github.com/JanusGraph/janusgraph/commit/be12be0554c2e347a77c8a509656267d64dd4cd0", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-04-30T01:36:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcwNzYxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r417707618", "bodyText": "We don't need immutable list here because the list isn't used anywhere and was used only for iterator creation. Thus, changed it to Stream.of(...).iterator()", "author": "porunov", "createdAt": "2020-04-30T01:38:35Z", "path": "janusgraph-core/src/main/java/org/janusgraph/core/JanusGraphEdge.java", "diffHunk": "@@ -76,13 +75,10 @@ default JanusGraphVertex inVertex() {\n \n     @Override\n     default Iterator<Vertex> vertices(Direction direction) {\n-        final List<Vertex> vertices;\n         if (direction==Direction.BOTH) {\n-            vertices = ImmutableList.of(vertex(Direction.OUT), vertex(Direction.IN));\n-        } else {\n-            vertices = ImmutableList.of(vertex(direction));\n+            return Stream.of((Vertex) vertex(Direction.OUT), vertex(Direction.IN)).iterator();\n         }\n-        return vertices.iterator();\n+        return Stream.of((Vertex) vertex(direction)).iterator();\n     }", "originalCommit": "be12be0554c2e347a77c8a509656267d64dd4cd0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcwODQ5Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r417708493", "bodyText": "No need making this map immutable because it is passed into the VertexMapJob and isn't used anywhere except VertexMapJob itself. Moreover the constructor  allows mutable maps to be passed (which is passed in FulgoraGraphComputer).", "author": "porunov", "createdAt": "2020-04-30T01:41:52Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/olap/computer/VertexMapJob.java", "diffHunk": "@@ -82,11 +82,11 @@ private VertexMapJob(IDManager idManager, FulgoraVertexMemory vertexMemory,\n \n     @Override\n     public VertexMapJob clone() {\n-        ImmutableMap.Builder<MapReduce, FulgoraMapEmitter> cloneMap = ImmutableMap.builder();\n+        Map<MapReduce, FulgoraMapEmitter> cloneMap = new HashMap<>(mapJobs.size());\n         for (Map.Entry<MapReduce, FulgoraMapEmitter> entry : mapJobs.entrySet()) {\n             cloneMap.put(entry.getKey().clone(), entry.getValue());\n         }\n-        return new VertexMapJob(idManager, vertexMemory, cloneMap.build());\n+        return new VertexMapJob(idManager, vertexMemory, cloneMap);\n     }", "originalCommit": "be12be0554c2e347a77c8a509656267d64dd4cd0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY4NTc2MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r418685760", "bodyText": "Why you removed this check?", "author": "farodin91", "createdAt": "2020-05-01T18:55:10Z", "path": "janusgraph-core/src/main/java/org/janusgraph/diskstorage/log/kcvs/KCVSLog.java", "diffHunk": "@@ -241,7 +241,7 @@ public KCVSLog(String name, KCVSLogManager manager, KeyColumnValueStore store, C\n         this.times = config.get(TIMESTAMP_PROVIDER);\n         this.keyConsistentOperations = config.get(LOG_KEY_CONSISTENT);\n         this.numBuckets = config.get(LOG_NUM_BUCKETS);\n-        Preconditions.checkArgument(numBuckets>=1 && numBuckets<=Integer.MAX_VALUE);\n+        Preconditions.checkArgument(numBuckets >= 1);", "originalCommit": "be12be0554c2e347a77c8a509656267d64dd4cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcwMTU3Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r418701573", "bodyText": "numBuckets is int. Any int value is always <=Integer.MAX_VALUE. So, this check is always true. I.e. this check has no sense.", "author": "porunov", "createdAt": "2020-05-01T19:33:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY4NTc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY4NjkzNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r418686934", "bodyText": "Is there no more elegant way?", "author": "farodin91", "createdAt": "2020-05-01T18:57:32Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/database/idassigner/placement/PropertyPlacementStrategy.java", "diffHunk": "@@ -89,8 +89,14 @@ private int getPartitionIDbyKey(JanusGraphVertex vertex) {\n                 \"PropertyPlacementStrategy has not been initialized correctly\");\n         assert idManager.getPartitionBound()<=Integer.MAX_VALUE;\n         int partitionBound = (int)idManager.getPartitionBound();\n-        final JanusGraphVertexProperty p = Iterables.getFirst(vertex.query().keys(key).properties(), null);\n-        if (p==null) return -1;\n+        Iterator<JanusGraphVertexProperty> it = vertex.query().keys(key).properties().iterator();", "originalCommit": "be12be0554c2e347a77c8a509656267d64dd4cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcxMzk3NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r418713974", "bodyText": "I don't know a better way without using Guava here.\nThe only code I could think of, is assigning null to p instead of returning -1 directly if there is nothing in the iterator.\nSomething like:\nIterator<JanusGraphVertexProperty> it = vertex.query().keys(key).properties().iterator();\nfinal JanusGraphVertexProperty p = it.hasNext()? it.next() : null;\nif (p==null){\n    return -1;\n}\n\nI don't see much difference here. p = it.hasNext()? it.next() : null; is 1 operation more then checking if(!it.hasNext()) return -1; but a little bit cleaner.\nWhat do you think about it?", "author": "porunov", "createdAt": "2020-05-01T20:04:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY4NjkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc0Njk4NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r418746984", "bodyText": "I like your new idea.", "author": "farodin91", "createdAt": "2020-05-01T21:32:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY4NjkzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc1NjkzMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r418756930", "bodyText": "Updated https://github.com/JanusGraph/janusgraph/compare/be12be0554c2e347a77c8a509656267d64dd4cd0..9792ca3d9a741e77f55edbb30ea4695c9d994c71", "author": "porunov", "createdAt": "2020-05-01T22:02:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY4NjkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY5MjYwNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r418692604", "bodyText": "Isn't the part .collect(Collectors.toSet())); dupilcated?", "author": "farodin91", "createdAt": "2020-05-01T19:11:11Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/types/system/SystemTypeManager.java", "diffHunk": "@@ -33,26 +35,25 @@\n \n     static {\n         synchronized (SystemTypeManager.class) {\n-            ImmutableMap.Builder<Long, SystemRelationType> idBuilder = ImmutableMap.builder();\n-            ImmutableMap.Builder<String, SystemRelationType> nameBuilder = ImmutableMap.builder();\n-            for (SystemRelationType et : new SystemRelationType[]{BaseKey.SchemaCategory, BaseKey.SchemaDefinitionDesc,\n-                    BaseKey.SchemaDefinitionProperty, BaseKey.SchemaName, BaseKey.SchemaUpdateTime,\n-                    BaseKey.VertexExists,\n-                    BaseLabel.VertexLabelEdge, BaseLabel.SchemaDefinitionEdge,\n-                    ImplicitKey.ID, ImplicitKey.JANUSGRAPHID, ImplicitKey.LABEL,\n-                    ImplicitKey.KEY, ImplicitKey.VALUE, ImplicitKey.ADJACENT_ID,\n-                    ImplicitKey.TIMESTAMP, ImplicitKey.TTL, ImplicitKey.VISIBILITY\n-                }) {\n+            SystemRelationType[] systemRelationTypes = new SystemRelationType[]{BaseKey.SchemaCategory, BaseKey.SchemaDefinitionDesc,\n+                BaseKey.SchemaDefinitionProperty, BaseKey.SchemaName, BaseKey.SchemaUpdateTime,\n+                BaseKey.VertexExists,\n+                BaseLabel.VertexLabelEdge, BaseLabel.SchemaDefinitionEdge,\n+                ImplicitKey.ID, ImplicitKey.JANUSGRAPHID, ImplicitKey.LABEL,\n+                ImplicitKey.KEY, ImplicitKey.VALUE, ImplicitKey.ADJACENT_ID,\n+                ImplicitKey.TIMESTAMP, ImplicitKey.TTL, ImplicitKey.VISIBILITY\n+            };\n+            Map<Long, SystemRelationType> idBuilder = new HashMap<>(systemRelationTypes.length);\n+            Map<String, SystemRelationType> nameBuilder = new HashMap<>(systemRelationTypes.length);\n+            for (SystemRelationType et : systemRelationTypes) {\n                 idBuilder.put(et.longId(), et);\n                 nameBuilder.put(et.name(),et);\n             }\n+            SYSTEM_TYPES_BY_ID = Collections.unmodifiableMap(idBuilder);\n+            SYSTEM_TYPES_BY_NAME = Collections.unmodifiableMap(nameBuilder);\n \n-            SYSTEM_TYPES_BY_ID = idBuilder.build();\n-            SYSTEM_TYPES_BY_NAME = nameBuilder.build();\n-\n-\n-            ADDITIONAL_RESERVED_NAMES = ImmutableSet.of(\n-                \"key\", \"vertex\", \"edge\", \"element\", \"property\", \"label\");\n+            ADDITIONAL_RESERVED_NAMES = Collections.unmodifiableSet(\n+                Stream.of(\"key\", \"vertex\", \"edge\", \"element\", \"property\", \"label\").collect(Collectors.toSet()));", "originalCommit": "be12be0554c2e347a77c8a509656267d64dd4cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcwNjIwNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2098#discussion_r418706205", "bodyText": "Not sure I correctly understand the question here. I don't see duplication here.\nCollections.unmodifiableSet is wrapping some Set into an unmodifiable wrapper. It doesn't add values into a new set. So, there is no way to construct unmodifiableSet if we don't have an underlying set which should be wrapped.\nImmutableSet.of - creates a new set with specified elements. So it is Immutable.\nCollections.unmodifiableSet - wraps an existing Set into unmodifiable Set. So, it is Mutable via underlying set but cannot be modified via unmodifiable set. As we are loosing a reference to an underlying set here, it means that this unmodifiable set becomes Immutable, because nobody will be able to change its value, as there is no access to underlying Set anymore.", "author": "porunov", "createdAt": "2020-05-01T19:44:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY5MjYwNA=="}], "type": "inlineReview"}, {"oid": "9792ca3d9a741e77f55edbb30ea4695c9d994c71", "url": "https://github.com/JanusGraph/janusgraph/commit/9792ca3d9a741e77f55edbb30ea4695c9d994c71", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-05-01T22:01:25Z", "type": "commit"}, {"oid": "9792ca3d9a741e77f55edbb30ea4695c9d994c71", "url": "https://github.com/JanusGraph/janusgraph/commit/9792ca3d9a741e77f55edbb30ea4695c9d994c71", "message": "Reduce guava usage [full build]\n\nRelated to #2033\n\nSigned-off-by: Oleksandr Porunov <alexandr.porunov@gmail.com>", "committedDate": "2020-05-01T22:01:25Z", "type": "forcePushed"}]}