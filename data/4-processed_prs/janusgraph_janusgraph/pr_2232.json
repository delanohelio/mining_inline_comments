{"pr_number": 2232, "pr_title": "Fix cached relation update hashcode change bug", "pr_createdAt": "2020-10-11T11:59:10Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2232", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1NzYxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2232#discussion_r502957618", "bodyText": "Nitpick. Don't assign null to the variable when it isn't needed to be assigned. I.e. change the code to:\nLong id;\nif (type.getConsistencyModifier() != ConsistencyModifier.FORK) {\n  id = longId();\n} else {\n  id = null;\n}\n\nI'm also OK with ternary operator if if{}else{} isn't suitable. I.e.:\nLong id = (type.getConsistencyModifier() != ConsistencyModifier.FORK) ? longId() : null;", "author": "porunov", "createdAt": "2020-10-11T19:45:46Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/relations/CacheEdge.java", "diffHunk": "@@ -87,9 +87,12 @@ private synchronized InternalRelation update() {\n         copyProperties(copy);\n         copy.remove();\n \n-        StandardEdge u = (StandardEdge) tx().addEdge(getVertex(0), getVertex(1), edgeLabel());\n-        if (type.getConsistencyModifier()!=ConsistencyModifier.FORK) u.setId(super.longId());\n-        u.setPreviousID(super.longId());\n+        Long id = null;\n+        if (type.getConsistencyModifier() != ConsistencyModifier.FORK) {\n+            id = longId();\n+        };", "originalCommit": "e9394b466ffc55b2c4c10d0970c3f5ca3971918a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzM3Njg3OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2232#discussion_r503376879", "bodyText": "Done, but may I know why?", "author": "li-boxuan", "createdAt": "2020-10-12T15:35:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM2Mjc4MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2232#discussion_r513362781", "bodyText": "Thanks! Assigning value to a variable which we know can be changed in the next operation and which isn't used before that operation is a redundant operation.", "author": "porunov", "createdAt": "2020-10-28T11:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM3MDMxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2232#discussion_r513370318", "bodyText": "I see. Are you speaking from a code style perspective? Then that would be make some sense to me. I would be surprised and interested if there is actually difference in runtime performance.", "author": "li-boxuan", "createdAt": "2020-10-28T11:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5NzQwNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2232#discussion_r513397406", "bodyText": "I don't know if JIT optimizes such cases or not, but from bytecode perspective there is a very tiny difference. It's almost not noticeable and most likely won't affect performance in real life but there is a difference from operations amount. I don't want to check the byte code of this class but lets see the bytecode difference in much smaller use case:\n/*\n0: aconst_null\n1: astore_1\n2: aload_0\n3: arraylength\n4: iconst_5\n5: if_icmple     13\n8: iconst_5\n9: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n12: astore_1\n13: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n16: aload_1\n17: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n20: return\n */\npublic static void main(String[] args) {\n\n    Integer s = null;\n\n    if(args.length > 5){\n        s = 5;\n    }\n\n    System.out.println(s);\n}\n\n/*\n0: aload_0\n1: arraylength\n2: iconst_5\n3: if_icmple     14\n6: iconst_5\n7: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;\n10: astore_1\n11: goto          16\n14: aconst_null\n15: astore_1\n16: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n19: aload_1\n20: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V\n23: return\n */\npublic static void main(String[] args) {\n\n    Integer s;\n\n    if(args.length > 5){\n        s = 5;\n    } else {\n        s = null;\n    }\n\n    System.out.println(s);\n}\n\nIn the first main method there are 13 operations in the main method. In the second main method we have 14 operations in the main method. We might assume that the second method will be executed slower than the first method because it has more operations but if we read them we clearly see that it's the opposite way.\nIn case args.length > 5 is false than we will execute 10 operations in the first method and 10 operations in the second method. So it's a tie when the if statement is false.\nIn case args.length > 5 is true than we will execute 13 operations in the first method and 12 operations in the second method (notice goto 16 operation). So in case if statement is true the second method will perform 1 operation less than the first method.\nIn conclusion: JIT compiler may optimize such use cases but I'm not sure about that. Comparing the performance for such a small difference for modern apps is a waste of time. In the real world most likely we won't see any performance difference in such a small use cases but it doesn't mean that we shouldn't care about redundant operations at all because they may decrease the performance and they just increase the code complexity.\nThat said, I don't push to use such style and I'm open for other opinions in case you have arguments to use the opposite style, I'm open to discuss that", "author": "porunov", "createdAt": "2020-10-28T12:19:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5NjY0Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2232#discussion_r513496643", "bodyText": "Very interesting analysis! I am also not sure if JIT compiler will optimize this. I agree that comparing the performance for such a small difference is not valuable, but since you have the byte code pasted, I'd also like to add some points:\n\nIn case args.length > 5 is true than we will execute 13 operations in the first method and 12 operations in the second method (notice goto 16 operation). So in case if statement is true the second method will perform 1 operation less than the first method.\n\nI agree the second method seems to save one operation, but I doubt if it will be actually faster than the first method. Reasons are:\n\ngoto operation MIGHT be slower than a normal operation since a jump probably does not leverage cache spatial locality well.\nCPU branch prediction MIGHT suffer more on goto operation when branch prediction fails. This is just my conjecture though.", "author": "li-boxuan", "createdAt": "2020-10-28T14:37:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1NzYxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0MzgwMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2232#discussion_r513543800", "bodyText": "Very good points!", "author": "porunov", "createdAt": "2020-10-28T15:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1NzYxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk1NzY2NQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/2232#discussion_r502957665", "bodyText": "Same here. Don't assign null when it isn't needed", "author": "porunov", "createdAt": "2020-10-11T19:46:14Z", "path": "janusgraph-core/src/main/java/org/janusgraph/graphdb/relations/CacheVertexProperty.java", "diffHunk": "@@ -71,8 +71,11 @@ private synchronized InternalRelation update() {\n         copyProperties(copy);\n         copy.remove();\n \n-        StandardVertexProperty u = (StandardVertexProperty) tx().addProperty(getVertex(0), propertyKey(), value());\n-        if (type.getConsistencyModifier()!= ConsistencyModifier.FORK) u.setId(longId());\n+        Long id = null;\n+        if (type.getConsistencyModifier() != ConsistencyModifier.FORK) {\n+            id = longId();\n+        };", "originalCommit": "e9394b466ffc55b2c4c10d0970c3f5ca3971918a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dcdefdbbb091c5da9fd6e1a8f59f87056f32b320", "url": "https://github.com/JanusGraph/janusgraph/commit/dcdefdbbb091c5da9fd6e1a8f59f87056f32b320", "message": "Fix cached relation update hashcode change bug\n\nWhen a CacheEdge or a CacheVertexProperty is updated, JanusGraph\ncreates a new edge/property with auto-generated longId, and then overrides\nit with the old id. Since AddedRelationsContainer implementation\nrelies on the longId as part of hash key, creating a new edge/property\nwith new longId can lead to a commit exception. This bug appears\nwhen a vertex property or an edge is updated and then deleted in the\nsame transaction.\n\nFixes #2138\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-12T00:52:09Z", "type": "forcePushed"}, {"oid": "dcdefdbbb091c5da9fd6e1a8f59f87056f32b320", "url": "https://github.com/JanusGraph/janusgraph/commit/dcdefdbbb091c5da9fd6e1a8f59f87056f32b320", "message": "Fix cached relation update hashcode change bug\n\nWhen a CacheEdge or a CacheVertexProperty is updated, JanusGraph\ncreates a new edge/property with auto-generated longId, and then overrides\nit with the old id. Since AddedRelationsContainer implementation\nrelies on the longId as part of hash key, creating a new edge/property\nwith new longId can lead to a commit exception. This bug appears\nwhen a vertex property or an edge is updated and then deleted in the\nsame transaction.\n\nFixes #2138\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-12T00:52:09Z", "type": "forcePushed"}, {"oid": "2ca11bc17e2cbbe3acdfe6870e7a0214562a6dd4", "url": "https://github.com/JanusGraph/janusgraph/commit/2ca11bc17e2cbbe3acdfe6870e7a0214562a6dd4", "message": "Fix cached relation update hashcode change bug\n\nWhen a CacheEdge or a CacheVertexProperty is updated, JanusGraph\ncreates a new edge/property with auto-generated longId, and then overrides\nit with the old id. Since AddedRelationsContainer implementation\nrelies on the longId as part of hash key, creating a new edge/property\nwith new longId can lead to a commit exception. This bug appears\nwhen a vertex property or an edge is updated and then deleted in the\nsame transaction.\n\nFixes #2138\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-13T15:12:35Z", "type": "forcePushed"}, {"oid": "99c8053c7507495bcc4fb4b05dccbc7e3c4e8821", "url": "https://github.com/JanusGraph/janusgraph/commit/99c8053c7507495bcc4fb4b05dccbc7e3c4e8821", "message": "Fix cached relation update hashcode change bug\n\nWhen a CacheEdge or a CacheVertexProperty is updated, JanusGraph\ncreates a new edge/property with auto-generated longId, and then overrides\nit with the old id. Since AddedRelationsContainer implementation\nrelies on the longId as part of hash key, creating a new edge/property\nwith new longId can lead to a commit exception. This bug appears\nwhen a vertex property or an edge is updated and then deleted in the\nsame transaction.\n\nFixes #2138\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-14T11:49:51Z", "type": "forcePushed"}, {"oid": "66661da749eb90100cfb086c42afb310ff601b99", "url": "https://github.com/JanusGraph/janusgraph/commit/66661da749eb90100cfb086c42afb310ff601b99", "message": "Fix cached relation update hashcode change bug\n\nWhen a CacheEdge or a CacheVertexProperty is updated, JanusGraph\ncreates a new edge/property with auto-generated longId, and then overrides\nit with the old id. Since AddedRelationsContainer implementation\nrelies on the longId as part of hash key, creating a new edge/property\nwith new longId can lead to a commit exception. This bug appears\nwhen a vertex property or an edge is updated and then deleted in the\nsame transaction.\n\nFixes #2138\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-18T03:47:26Z", "type": "commit"}, {"oid": "66661da749eb90100cfb086c42afb310ff601b99", "url": "https://github.com/JanusGraph/janusgraph/commit/66661da749eb90100cfb086c42afb310ff601b99", "message": "Fix cached relation update hashcode change bug\n\nWhen a CacheEdge or a CacheVertexProperty is updated, JanusGraph\ncreates a new edge/property with auto-generated longId, and then overrides\nit with the old id. Since AddedRelationsContainer implementation\nrelies on the longId as part of hash key, creating a new edge/property\nwith new longId can lead to a commit exception. This bug appears\nwhen a vertex property or an edge is updated and then deleted in the\nsame transaction.\n\nFixes #2138\n\nSigned-off-by: Boxuan Li <liboxuan@connect.hku.hk>", "committedDate": "2020-10-18T03:47:26Z", "type": "forcePushed"}]}