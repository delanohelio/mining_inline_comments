{"pr_number": 2294, "pr_title": "issue #2273 - implement variable length \"valuePosition\" in page storage", "pr_createdAt": "2020-12-21T16:20:24Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/2294", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNDA4OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r548824088", "bodyText": "Just a nitpick: we could use ByteBuffer.wrap(rawData, offset, Integer.BYTES).order(ByteOrder.BIG_ENDIAN) to explicitly set the endianness, or we could add an assertion to make sure order() is equivalent to BIG_ENDIAN.", "author": "li-boxuan", "createdAt": "2020-12-25T07:35:47Z", "path": "janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java", "diffHunk": "@@ -92,6 +93,30 @@ public static SharedEntryBuffer readFrom(DataInputStream in) throws IOException\n         }\n     }\n \n+    static int computeValPosSize(Entry e)\n+    {\n+        //this assumes that the key size will almost never be > 127 bytes,\n+        // thus most of the time saving 3 out of 4 bytes to store the value position within the buffer\n+        return e.getValuePosition() > 127 ? Integer.BYTES : 1;\n+    }\n+\n+    static int writeValPos(Entry e, byte[] rawData, int offset)\n+    {\n+        if (e.getValuePosition() <= 127) //\"column\" name length fits into one byte - should be 99.99% of cases\n+        {\n+            final byte entryValPos = (byte) e.getValuePosition();\n+            rawData[offset] = entryValPos;\n+            return 1;\n+        }\n+        else //doesn't fit in 1 byte - use full integer\n+        {\n+            //ByteBuffer is in BigENdian mode by default, so if we write -valuePosition,\n+            // 1st byte should have a negative value, indicating full int\n+            ByteBuffer.wrap(rawData, offset, Integer.BYTES).asIntBuffer().put(-e.getValuePosition());", "originalCommit": "a3674776e68e5eca45dd238c3bdbe350afe36757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE0ODMzOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549148338", "bodyText": "done", "author": "dk-github", "createdAt": "2020-12-27T18:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNDA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNjM0OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r548826348", "bodyText": "I think if you can change the signature of this method into\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                static int computeValPosSize(Entry e)\n          \n          \n            \n                static int computeValPosSize(int valPos)\n          \n      \n    \n    \n  \n\nthen it could be reused in BufferPage.java.", "author": "li-boxuan", "createdAt": "2020-12-25T07:49:37Z", "path": "janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPageUtils.java", "diffHunk": "@@ -92,6 +93,30 @@ public static SharedEntryBuffer readFrom(DataInputStream in) throws IOException\n         }\n     }\n \n+    static int computeValPosSize(Entry e)", "originalCommit": "a3674776e68e5eca45dd238c3bdbe350afe36757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE0NzgwNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549147806", "bodyText": "I could change it here, but not sure how it could help reuse it in BufferPage - here we have an \"unpacked\" entry and decide how we are going to pack, there we get the packed entry and need to find out how it WAS packed - so it needs to take the byte array etc...", "author": "dk-github", "createdAt": "2020-12-27T18:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNjM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE5NzgxNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549197817", "bodyText": "What I noticed is, in BufferPage.java, you always retrieve valPos before retrieving valPosSize. Since you have valPos available, you could call BufferPageUtils::computeValPosSize(int valPos) to retrieve valPosSize.\nThe caller in this class should then call computeValPosSize((array[start+i]).getValuePosition()) to retrieve valPosSize.", "author": "li-boxuan", "createdAt": "2020-12-28T02:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNjM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc4MDc4Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549780782", "bodyText": "ok, got you now - done", "author": "dk-github", "createdAt": "2020-12-29T17:08:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgyNjM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgzMDU4Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r548830586", "bodyText": "It took me some time to understand this method thoroughly. I think the usage of entryBuffer here is not straight-forward to understand, since you are kind of mixing the two use cases (reading and moving cursor v.s. purely reading) together in one method. Would be helpful if you can add some javadoc.", "author": "li-boxuan", "createdAt": "2020-12-25T08:16:18Z", "path": "janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java", "diffHunk": "@@ -111,24 +113,64 @@ private int getEntryEndOffset(final int index) {\n         }\n     }\n \n+    static int readValPos(byte[] rawData, int entryOffset, ByteBuffer entryBuffer)", "originalCommit": "a3674776e68e5eca45dd238c3bdbe350afe36757", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE0ODM3MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549148370", "bodyText": "done", "author": "dk-github", "createdAt": "2020-12-27T18:19:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODgzMDU4Ng=="}], "type": "inlineReview"}, {"oid": "010179f72dce076b5015dbcd85ac9c3c82403150", "url": "https://github.com/JanusGraph/janusgraph/commit/010179f72dce076b5015dbcd85ac9c3c82403150", "message": "issue #2273 - implement variable length \"valuePosition\" in page storage, to allow for Entry keys of arbitrary length, while not incurring unnecessary overhead (as 99% of keys are typically quite short)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2020-12-27T18:27:11Z", "type": "forcePushed"}, {"oid": "b2c46e3b346d781e04e4dcc6e28c7ad531c4e6dd", "url": "https://github.com/JanusGraph/janusgraph/commit/b2c46e3b346d781e04e4dcc6e28c7ad531c4e6dd", "message": "issue #2273 - implement variable length \"valuePosition\" in page storage, to allow for Entry keys of arbitrary length, while not incurring unnecessary overhead (as 99% of keys are typically quite short)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2020-12-29T17:07:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkxNTAyMw==", "url": "https://github.com/JanusGraph/janusgraph/pull/2294#discussion_r549915023", "bodyText": "nitpick: don't put the curly brace on a new line, to be consistent with the convention used in the codebase.", "author": "li-boxuan", "createdAt": "2020-12-30T02:31:43Z", "path": "janusgraph-inmemory/src/main/java/org/janusgraph/diskstorage/inmemory/BufferPage.java", "diffHunk": "@@ -111,24 +113,62 @@ private int getEntryEndOffset(final int index) {\n         }\n     }\n \n+    /**\n+     * This figures out how the \"valuePosition\" was stored (i.e. 1 byte or 4), reads it correctly,\n+     * and leaves the byte buffer (if given) at the beginning of the key value\n+     */\n+    static int readValPos(byte[] rawData, int entryOffset, ByteBuffer entryBuffer)\n+    {", "originalCommit": "b2c46e3b346d781e04e4dcc6e28c7ad531c4e6dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d936872df4c815ef524a4c78013d90f45a886af8", "url": "https://github.com/JanusGraph/janusgraph/commit/d936872df4c815ef524a4c78013d90f45a886af8", "message": "issue #2273 - implement variable length \"valuePosition\" in page storage, to allow for Entry keys of arbitrary length, while not incurring unnecessary overhead (as 99% of keys are typically quite short)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2021-01-07T22:46:10Z", "type": "forcePushed"}, {"oid": "f2b4431939055237b3e280ea7873bd53232731bd", "url": "https://github.com/JanusGraph/janusgraph/commit/f2b4431939055237b3e280ea7873bd53232731bd", "message": "issue #2273 - implement variable length \"valuePosition\" in page storage, to allow for Entry keys of arbitrary length, while not incurring unnecessary overhead (as 99% of keys are typically quite short)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2021-01-08T11:04:07Z", "type": "commit"}, {"oid": "f2b4431939055237b3e280ea7873bd53232731bd", "url": "https://github.com/JanusGraph/janusgraph/commit/f2b4431939055237b3e280ea7873bd53232731bd", "message": "issue #2273 - implement variable length \"valuePosition\" in page storage, to allow for Entry keys of arbitrary length, while not incurring unnecessary overhead (as 99% of keys are typically quite short)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2021-01-08T11:04:07Z", "type": "forcePushed"}]}