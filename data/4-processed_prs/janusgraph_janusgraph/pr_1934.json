{"pr_number": 1934, "pr_title": "Update in-memory backend documentation", "pr_createdAt": "2020-01-20T20:36:52Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/1934", "timeline": [{"oid": "a2bb322878bfe3500130fbf2355232880393f738", "url": "https://github.com/JanusGraph/janusgraph/commit/a2bb322878bfe3500130fbf2355232880393f738", "message": "[doc only] Updated in-memory backend documentation\n\nto explain possible production use cases, limitations and alternatives (issue #1929)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2020-01-20T20:39:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4NTg5Ng==", "url": "https://github.com/JanusGraph/janusgraph/pull/1934#discussion_r368785896", "bodyText": "Can you maybe use markdown ### syntax so that the generated doc website can show the table of contents correctly like https://docs.janusgraph.org/storage-backend/cassandra/#setup-cassandra-cluster?", "author": "li-boxuan", "createdAt": "2020-01-21T02:24:48Z", "path": "docs/storage-backend/inmemorybackend.md", "diffHunk": "@@ -16,18 +16,58 @@ graph = JanusGraphFactory.build().set('storage.backend', 'inmemory').open()\n ```\n \n There are no additional configuration options for the in-memory storage\n-backend. As the name suggests, this backend holds all data in memory.\n+backend. As the name suggests, this backend holds all data in memory, specifically\n+ in the heap space allocated to the java virtual machine running Janusgraph instance.\n+\n Shutting down the graph or terminating the process that hosts the\n JanusGraph graph will irrevocably delete all data from the graph. This\n backend is local to a particular JanusGraph graph instance and cannot be\n shared across multiple JanusGraph graphs.\n \n Ideal Use Case\n --------------\n+Rapid testing:", "originalCommit": "a2bb322878bfe3500130fbf2355232880393f738", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc1NjM3MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1934#discussion_r370756370", "bodyText": "done", "author": "dk-github", "createdAt": "2020-01-24T17:38:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4NTg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4ODcxMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1934#discussion_r368788711", "bodyText": "It is not very clear to me whether 'advanced indexing functionality' refers to any index, or mixed index (which requires a index backend, thus can be considered as 'advanced') only", "author": "li-boxuan", "createdAt": "2020-01-21T02:40:24Z", "path": "docs/storage-backend/inmemorybackend.md", "diffHunk": "@@ -16,18 +16,58 @@ graph = JanusGraphFactory.build().set('storage.backend', 'inmemory').open()\n ```\n \n There are no additional configuration options for the in-memory storage\n-backend. As the name suggests, this backend holds all data in memory.\n+backend. As the name suggests, this backend holds all data in memory, specifically\n+ in the heap space allocated to the java virtual machine running Janusgraph instance.\n+\n Shutting down the graph or terminating the process that hosts the\n JanusGraph graph will irrevocably delete all data from the graph. This\n backend is local to a particular JanusGraph graph instance and cannot be\n shared across multiple JanusGraph graphs.\n \n Ideal Use Case\n --------------\n+Rapid testing:\n \n-The in-memory storage backend was primarily developed to simplify\n+The in-memory storage backend was initially developed to simplify\n testing (for those tests that do not require persistence) and graph\n-exploration. The in-memory storage backend is NOT meant for production\n-use, large graphs, or high performance use cases. The in-memory storage\n-backend is not performance or memory optimized. All data is stored in\n-the heap space allocated to the Java virtual machine.\n+exploration. Automated testing and ad-hoc prototyping remains its main purpose within Janusgraph project.\n+\n+Production:\n+\n+The initial test-only implementation was further evolved to use a more compact\n+ in-memory representation, which made it suitable for production use in certain scenarios, such as \n+ Janusgraph engine being embedded into an application process, or spawned dynamically on demand, where:\n+- Ease of setup/configuration/maintenance/start up is important (just run Janusgraph from distribution jar, no management of clusters for backend DBs etc) \n+- Loss of data due to _unexpected_ death of host process is acceptable (the backend provides a simple mechanism for making fast snapshots to handle _expected_ restarts)\n+- Size of the graph data makes it possible to host it in a single JVM process (i.e. a few tens of Gigabytes max, unless you use a specialized JVM and hardware)\n+- Higher performance is required, but no expertise/resources available to tune more complex backends. Due to its memory-only nature, in-memory backend typically performs faster than disk-based ones, in queries using simple indices\n+and in graph modifications. However it is not specifically optimized for performance, and does not support advanced indexing functionality. ", "originalCommit": "a2bb322878bfe3500130fbf2355232880393f738", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYzNjE4Nw==", "url": "https://github.com/JanusGraph/janusgraph/pull/1934#discussion_r370636187", "bodyText": "it vaguely refers to both the fact that there is no in-memory index backend (and so no mixed indices if using just in-memory backend), and also the fact that simple indices are basically taking advantage of the order of the column and row keys, and basically do binary search. There are no fancy additional data structures for indices specifically, and there is no database whose native indexing can be utilised.", "author": "dk-github", "createdAt": "2020-01-24T13:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc4ODcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MDQ2NA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1934#discussion_r368790464", "bodyText": "Can you elaborate what 'store-level locking' is? Does it mean 'JanusGraphManagement.setConsistency(element, ConsistencyModifier.LOCK)' won't work for this backend?", "author": "li-boxuan", "createdAt": "2020-01-21T02:49:46Z", "path": "docs/storage-backend/inmemorybackend.md", "diffHunk": "@@ -16,18 +16,58 @@ graph = JanusGraphFactory.build().set('storage.backend', 'inmemory').open()\n ```\n \n There are no additional configuration options for the in-memory storage\n-backend. As the name suggests, this backend holds all data in memory.\n+backend. As the name suggests, this backend holds all data in memory, specifically\n+ in the heap space allocated to the java virtual machine running Janusgraph instance.\n+\n Shutting down the graph or terminating the process that hosts the\n JanusGraph graph will irrevocably delete all data from the graph. This\n backend is local to a particular JanusGraph graph instance and cannot be\n shared across multiple JanusGraph graphs.\n \n Ideal Use Case\n --------------\n+Rapid testing:\n \n-The in-memory storage backend was primarily developed to simplify\n+The in-memory storage backend was initially developed to simplify\n testing (for those tests that do not require persistence) and graph\n-exploration. The in-memory storage backend is NOT meant for production\n-use, large graphs, or high performance use cases. The in-memory storage\n-backend is not performance or memory optimized. All data is stored in\n-the heap space allocated to the Java virtual machine.\n+exploration. Automated testing and ad-hoc prototyping remains its main purpose within Janusgraph project.\n+\n+Production:\n+\n+The initial test-only implementation was further evolved to use a more compact\n+ in-memory representation, which made it suitable for production use in certain scenarios, such as \n+ Janusgraph engine being embedded into an application process, or spawned dynamically on demand, where:\n+- Ease of setup/configuration/maintenance/start up is important (just run Janusgraph from distribution jar, no management of clusters for backend DBs etc) \n+- Loss of data due to _unexpected_ death of host process is acceptable (the backend provides a simple mechanism for making fast snapshots to handle _expected_ restarts)\n+- Size of the graph data makes it possible to host it in a single JVM process (i.e. a few tens of Gigabytes max, unless you use a specialized JVM and hardware)\n+- Higher performance is required, but no expertise/resources available to tune more complex backends. Due to its memory-only nature, in-memory backend typically performs faster than disk-based ones, in queries using simple indices\n+and in graph modifications. However it is not specifically optimized for performance, and does not support advanced indexing functionality. \n+\n+Limitations:\n+\n+- Obviously the scalability is limited to the heap size of a single JVM, and no transparent resilience to failures is offered\n+- The backend offers store-level locking only, whereas a Janusgraph transaction typically changes multiple stores (e.g. vertex store and index store).", "originalCommit": "a2bb322878bfe3500130fbf2355232880393f738", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDYzOTc3Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/1934#discussion_r370639772", "bodyText": "It means that it can use java read-write lock to lock the individual store it modifies, for the duration of the modification, to prevent concurrent modifications on the same store. But it does not attempt to lock all the stores involved in one Janusgraph/backend transaction, and so individual store updates from parallel transactions being committed can interleave.\nSo say tx1 updates the index store, but before it can update the vertex store accordingly, tx2 updates the index store with its own data. As long as this data is completely different from the tx1's, this is actually fine and allows to reduce the lock contention significantly. But if they modify the same data - you can get \"ghost vertices\" or \"missing vertices\" etc.\nNote that naively implementing locking all the stores at the beginning of the transaction can lead to deadlocks unless they are locked in the same order, and can lead to high contention in case of big number of parallel transactions, because half of the stores are going to be locked all the time. Basically, implementing this correctly and efficiently would be akin to implementing a robust in-memory database engine, which is not the intent of this backend at all.", "author": "dk-github", "createdAt": "2020-01-24T13:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MDQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MTYwMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1934#discussion_r368791601", "bodyText": "Are those mechanisms documented somewhere? It would be nice to have a short description on how these mechanisms can be set up/activated.", "author": "li-boxuan", "createdAt": "2020-01-21T02:55:39Z", "path": "docs/storage-backend/inmemorybackend.md", "diffHunk": "@@ -16,18 +16,58 @@ graph = JanusGraphFactory.build().set('storage.backend', 'inmemory').open()\n ```\n \n There are no additional configuration options for the in-memory storage\n-backend. As the name suggests, this backend holds all data in memory.\n+backend. As the name suggests, this backend holds all data in memory, specifically\n+ in the heap space allocated to the java virtual machine running Janusgraph instance.\n+\n Shutting down the graph or terminating the process that hosts the\n JanusGraph graph will irrevocably delete all data from the graph. This\n backend is local to a particular JanusGraph graph instance and cannot be\n shared across multiple JanusGraph graphs.\n \n Ideal Use Case\n --------------\n+Rapid testing:\n \n-The in-memory storage backend was primarily developed to simplify\n+The in-memory storage backend was initially developed to simplify\n testing (for those tests that do not require persistence) and graph\n-exploration. The in-memory storage backend is NOT meant for production\n-use, large graphs, or high performance use cases. The in-memory storage\n-backend is not performance or memory optimized. All data is stored in\n-the heap space allocated to the Java virtual machine.\n+exploration. Automated testing and ad-hoc prototyping remains its main purpose within Janusgraph project.\n+\n+Production:\n+\n+The initial test-only implementation was further evolved to use a more compact\n+ in-memory representation, which made it suitable for production use in certain scenarios, such as \n+ Janusgraph engine being embedded into an application process, or spawned dynamically on demand, where:\n+- Ease of setup/configuration/maintenance/start up is important (just run Janusgraph from distribution jar, no management of clusters for backend DBs etc) \n+- Loss of data due to _unexpected_ death of host process is acceptable (the backend provides a simple mechanism for making fast snapshots to handle _expected_ restarts)\n+- Size of the graph data makes it possible to host it in a single JVM process (i.e. a few tens of Gigabytes max, unless you use a specialized JVM and hardware)\n+- Higher performance is required, but no expertise/resources available to tune more complex backends. Due to its memory-only nature, in-memory backend typically performs faster than disk-based ones, in queries using simple indices\n+and in graph modifications. However it is not specifically optimized for performance, and does not support advanced indexing functionality. \n+\n+Limitations:\n+\n+- Obviously the scalability is limited to the heap size of a single JVM, and no transparent resilience to failures is offered\n+- The backend offers store-level locking only, whereas a Janusgraph transaction typically changes multiple stores (e.g. vertex store and index store).\n+This means that in scenarios where data is modified in parallel transactions, care should be taken on application level to avoid conflicting updates.\n+At a high level, this means that you can modify unrelated parts of the graph in parallel, but you should avoid changing the same vertex or its edges in parallel\n+transactions.\n+- The backend does not guarantee a clean rollback once commit has started. Chances of a failure in the middle of commit to an in-memory data structure are low,\n+however this can happen - e.g. when a large heap nears saturation and the GC pause exceeds configured backend timeout.\n+- The data layout used by the backend can theoretically be susceptible to fragmentation in certain scenarios\n+ (with a lot of add/delete operations), thus reducing the amount of useful data that can be stored in a heap\n+  of specified size. The backend provides simple mechanisms to report fragmentation and defragment the storage if required.", "originalCommit": "a2bb322878bfe3500130fbf2355232880393f738", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDY0MjI3Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/1934#discussion_r370642272", "bodyText": "There currently is no support for activating these via configuration - one would have to have a little dig in the code to see how it can be invoked when needed. As and if some common patterns of how it can be applied for generic use case emerge - these patterns can be made configurable. For now, it can just be ignored, unless for a specific use case there is a suspicion that fragmentation might be a problem.", "author": "dk-github", "createdAt": "2020-01-24T13:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MTYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc5MjAzMA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1934#discussion_r368792030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Aerospike-based backend (not part of Janugraph but a separate project: https://github.com/Playtika/aerospike-janusgraph-storage-backend)\n          \n          \n            \n            - [Aerospike-based backend](https://github.com/Playtika/aerospike-janusgraph-storage-backend) (not part of Janugraph but a separate project)", "author": "li-boxuan", "createdAt": "2020-01-21T02:57:48Z", "path": "docs/storage-backend/inmemorybackend.md", "diffHunk": "@@ -16,18 +16,58 @@ graph = JanusGraphFactory.build().set('storage.backend', 'inmemory').open()\n ```\n \n There are no additional configuration options for the in-memory storage\n-backend. As the name suggests, this backend holds all data in memory.\n+backend. As the name suggests, this backend holds all data in memory, specifically\n+ in the heap space allocated to the java virtual machine running Janusgraph instance.\n+\n Shutting down the graph or terminating the process that hosts the\n JanusGraph graph will irrevocably delete all data from the graph. This\n backend is local to a particular JanusGraph graph instance and cannot be\n shared across multiple JanusGraph graphs.\n \n Ideal Use Case\n --------------\n+Rapid testing:\n \n-The in-memory storage backend was primarily developed to simplify\n+The in-memory storage backend was initially developed to simplify\n testing (for those tests that do not require persistence) and graph\n-exploration. The in-memory storage backend is NOT meant for production\n-use, large graphs, or high performance use cases. The in-memory storage\n-backend is not performance or memory optimized. All data is stored in\n-the heap space allocated to the Java virtual machine.\n+exploration. Automated testing and ad-hoc prototyping remains its main purpose within Janusgraph project.\n+\n+Production:\n+\n+The initial test-only implementation was further evolved to use a more compact\n+ in-memory representation, which made it suitable for production use in certain scenarios, such as \n+ Janusgraph engine being embedded into an application process, or spawned dynamically on demand, where:\n+- Ease of setup/configuration/maintenance/start up is important (just run Janusgraph from distribution jar, no management of clusters for backend DBs etc) \n+- Loss of data due to _unexpected_ death of host process is acceptable (the backend provides a simple mechanism for making fast snapshots to handle _expected_ restarts)\n+- Size of the graph data makes it possible to host it in a single JVM process (i.e. a few tens of Gigabytes max, unless you use a specialized JVM and hardware)\n+- Higher performance is required, but no expertise/resources available to tune more complex backends. Due to its memory-only nature, in-memory backend typically performs faster than disk-based ones, in queries using simple indices\n+and in graph modifications. However it is not specifically optimized for performance, and does not support advanced indexing functionality. \n+\n+Limitations:\n+\n+- Obviously the scalability is limited to the heap size of a single JVM, and no transparent resilience to failures is offered\n+- The backend offers store-level locking only, whereas a Janusgraph transaction typically changes multiple stores (e.g. vertex store and index store).\n+This means that in scenarios where data is modified in parallel transactions, care should be taken on application level to avoid conflicting updates.\n+At a high level, this means that you can modify unrelated parts of the graph in parallel, but you should avoid changing the same vertex or its edges in parallel\n+transactions.\n+- The backend does not guarantee a clean rollback once commit has started. Chances of a failure in the middle of commit to an in-memory data structure are low,\n+however this can happen - e.g. when a large heap nears saturation and the GC pause exceeds configured backend timeout.\n+- The data layout used by the backend can theoretically be susceptible to fragmentation in certain scenarios\n+ (with a lot of add/delete operations), thus reducing the amount of useful data that can be stored in a heap\n+  of specified size. The backend provides simple mechanisms to report fragmentation and defragment the storage if required.\n+  However scenarios where the level of fragmentation is high enough to be an issue are expected to be rare,\n+   and usually defragmentation is not required at all.\n+\n+Alternatives:\n+\n+Generally, except for the above class of use cases, there doesn't seem to be much point in specifically 100% in-memory-only backend.\n+Many of the other supported backends, based on mature key-value databases, \n+can be tuned to provide high performance and resiliency, plus advanced indexing capabilities etc \n+(provided that you have resources and expertise to host and tune them, or use them as a service).\n+However there are a few in-memory alternatives, such as (not exhaustive list, and in no particular order):\n+- BerkeleyJE backend configured with je.log.memOnly set to true \n+(care should be taken to avoid using it for scenarios with continuous write operations, even if the effective size of the data\n+ remains the same - continuous write operations can drive uncontrolled log growth, leading to OOM). \n+ The backend has dump/load capability, and supports compression.\n+- Aerospike-based backend (not part of Janugraph but a separate project: https://github.com/Playtika/aerospike-janusgraph-storage-backend)", "originalCommit": "a2bb322878bfe3500130fbf2355232880393f738", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f869a5e746c92a424abb3b97dcaeeba190fb5081", "url": "https://github.com/JanusGraph/janusgraph/commit/f869a5e746c92a424abb3b97dcaeeba190fb5081", "message": "[doc only] Updated in-memory backend documentation\n\nto explain possible production use cases, limitations and alternatives (issue #1929)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2020-01-24T14:06:56Z", "type": "commit"}, {"oid": "f869a5e746c92a424abb3b97dcaeeba190fb5081", "url": "https://github.com/JanusGraph/janusgraph/commit/f869a5e746c92a424abb3b97dcaeeba190fb5081", "message": "[doc only] Updated in-memory backend documentation\n\nto explain possible production use cases, limitations and alternatives (issue #1929)\n\nSigned-off-by: Dmitry Kovalev <dk.global@gmail.com>", "committedDate": "2020-01-24T14:06:56Z", "type": "forcePushed"}]}