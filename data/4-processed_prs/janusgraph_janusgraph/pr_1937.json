{"pr_number": 1937, "pr_title": "Explain usage of implicit keys for vertex-centric indexes", "pr_createdAt": "2020-01-24T10:55:05Z", "pr_url": "https://github.com/JanusGraph/janusgraph/pull/1937", "timeline": [{"oid": "633f08433f9fa2b04260e9ba8a7c497658bc2668", "url": "https://github.com/JanusGraph/janusgraph/commit/633f08433f9fa2b04260e9ba8a7c497658bc2668", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-01-24T10:58:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc1NTU1Mw==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r373755553", "bodyText": "You can use\nimport org.janusgraph.graphdb.types.system.ImplicitKey\nin the code block above. (e.g. see https://raw.githubusercontent.com/JanusGraph/janusgraph/master/docs/index-management/index-reindexing.md)", "author": "li-boxuan", "createdAt": "2020-02-01T03:52:53Z", "path": "docs/index-management/index-performance.md", "diffHunk": "@@ -466,15 +466,57 @@ increases. Often, such traversals can be rewritten as constrained\n traversals that can utilize a vertex-centric index to ensure acceptable\n performance at scale.\n \n+### Vertex-centric indexes on implicit keys\n+\n+In some cases it is relevant to find an edge based on properties of the adjacent vertex.\n+Let's say we want to find out whether or not Hercules has battled Cerberus.\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+g.V(h).out('battled').has('name', 'cerberus').limit(1).hasNext()\n+```\n+\n+A query like this can not use a vertex centric index because it filters on vertex properties rather than edge properties.\n+But by restructuring the query, we can achieve exactly this.\n+As both vertices are known, the vertex ids can be used to select the edge.\n+In contrast to the name \"Cebereus\", which is a property of the adjacent vertex, the id of this vertex is already saved within the connecting edge itself.\n+Although, this id is internal and therefore not explcitly visible as a property of the edge.\n+This can be solved by referring to the id as an `ImplicitKey`:\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+c = g.V().has('name', 'cerberus').next()\n+g.V(h).outE('battled').has(ImplicitKey.ADJACENT_ID.name(), c.id()).limit(1).hasNext()\n+```\n+\n+!!! note\n+    If the class ImplicitKey can not be found, use the fully qualified class name `org.janusgraph.graphdb.types.system.ImplicitKey` instead.", "originalCommit": "633f08433f9fa2b04260e9ba8a7c497658bc2668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxNTQwNQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r374515405", "bodyText": "I intended to do this, but I was unable to make this work from the gremlin console. Importing ImplicitKey seems to work based on the server's response. But later on I always get\nNo such property: ImplicitKey for class: Script12\nSo it looks like the class was not imported correctly. I'm pretty sure I'm just using groovy in the wrong way here. Can you reproduce this behaviour on your machine?", "author": "rngcntr", "createdAt": "2020-02-04T07:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc1NTU1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUyNTU1Mg==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r374525552", "bodyText": "Oh sorry, I have no idea about that... I have JanusGraph embedded in my Java application and it works well.", "author": "li-boxuan", "createdAt": "2020-02-04T08:16:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc1NTU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc1NTcxOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r373755718", "bodyText": "I think there is a trade-off here: it's true that there is no need to fetch every adjacent vertex anymore, but querying global index also brings overhead. If the degree of the vertex is small (in the extreme case, it only has one neighbor), then maybe the naive approach is more preferable. But I am not a JanusGraph developer so I am not 100% sure.", "author": "li-boxuan", "createdAt": "2020-02-01T03:56:13Z", "path": "docs/index-management/index-performance.md", "diffHunk": "@@ -466,15 +466,57 @@ increases. Often, such traversals can be rewritten as constrained\n traversals that can utilize a vertex-centric index to ensure acceptable\n performance at scale.\n \n+### Vertex-centric indexes on implicit keys\n+\n+In some cases it is relevant to find an edge based on properties of the adjacent vertex.\n+Let's say we want to find out whether or not Hercules has battled Cerberus.\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+g.V(h).out('battled').has('name', 'cerberus').limit(1).hasNext()\n+```\n+\n+A query like this can not use a vertex centric index because it filters on vertex properties rather than edge properties.\n+But by restructuring the query, we can achieve exactly this.\n+As both vertices are known, the vertex ids can be used to select the edge.\n+In contrast to the name \"Cebereus\", which is a property of the adjacent vertex, the id of this vertex is already saved within the connecting edge itself.\n+Although, this id is internal and therefore not explcitly visible as a property of the edge.\n+This can be solved by referring to the id as an `ImplicitKey`:\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+c = g.V().has('name', 'cerberus').next()\n+g.V(h).outE('battled').has(ImplicitKey.ADJACENT_ID.name(), c.id()).limit(1).hasNext()\n+```\n+\n+!!! note\n+    If the class ImplicitKey can not be found, use the fully qualified class name `org.janusgraph.graphdb.types.system.ImplicitKey` instead.\n+\n+Assuming there is a global index on the 'name' property, this already improves the performance a lot, because it's not necessary to fetch every adjacent vertex anymore.", "originalCommit": "633f08433f9fa2b04260e9ba8a7c497658bc2668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxODMzMQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r374518331", "bodyText": "I agree with you on this. The performance gain of this solution heavily depends on the degree of the vertex for which the query is run. But as with other sorts of indexes, this is a trade-off which the user has to decide on. While in some cases querying the global index can cause a performance reducing overhead, there are other cases with higher degree vertices where this practice can have a positive effect.\nI can't tell exactly at which degree this will start to take effect, because it depends mostly on environment factors like the storage backend or the overall size and structure of your graph.", "author": "rngcntr", "createdAt": "2020-02-04T07:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc1NTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA2ODkzNw==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r374068937", "bodyText": "Seeing this, I think we should implement a traversal strategy that allows JanusGraph to use this implicitly if simply hasId() is used. I would consider ImplicitKey as internal API of JanusGraph that users shouldn't directly use in their applications.", "author": "FlorianHockmann", "createdAt": "2020-02-03T12:12:28Z", "path": "docs/index-management/index-performance.md", "diffHunk": "@@ -466,15 +466,57 @@ increases. Often, such traversals can be rewritten as constrained\n traversals that can utilize a vertex-centric index to ensure acceptable\n performance at scale.\n \n+### Vertex-centric indexes on implicit keys\n+\n+In some cases it is relevant to find an edge based on properties of the adjacent vertex.\n+Let's say we want to find out whether or not Hercules has battled Cerberus.\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+g.V(h).out('battled').has('name', 'cerberus').limit(1).hasNext()\n+```\n+\n+A query like this can not use a vertex centric index because it filters on vertex properties rather than edge properties.\n+But by restructuring the query, we can achieve exactly this.\n+As both vertices are known, the vertex ids can be used to select the edge.\n+In contrast to the name \"Cebereus\", which is a property of the adjacent vertex, the id of this vertex is already saved within the connecting edge itself.\n+Although, this id is internal and therefore not explcitly visible as a property of the edge.\n+This can be solved by referring to the id as an `ImplicitKey`:\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+c = g.V().has('name', 'cerberus').next()\n+g.V(h).outE('battled').has(ImplicitKey.ADJACENT_ID.name(), c.id()).limit(1).hasNext()", "originalCommit": "633f08433f9fa2b04260e9ba8a7c497658bc2668", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNDY0OA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r374434648", "bodyText": "From a user's standpoint, I think this approach is very useful and I am starting using it (In my case, JanusGraph is embedded in my application). Having a traversal strategy is very nice, but it won't hurt to have this (temporarily).\nWhen using a gremlin query like g.V(h).outE('battled'), I found the response itself already contains the id of both endpoints. Since this id info is not concealed in the edge, I wouldn't really consider it as an internal API of JanusGraph.\nAnother concern is, g.V(h).outE('battled').has(ImplicitKey.ADJACENT_ID.name(), c.id()) can be even faster if vertex-centric index for ImplicitKey.ADJACENT_ID is built, as mentioned in this PR. If users are not expected to use ImplicitKey directly in their applications, how could they build vertex-centric index to accelerate the traversal here?", "author": "li-boxuan", "createdAt": "2020-02-04T01:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA2ODkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUyNzIwOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r374527209", "bodyText": "I'm with @li-boxuan here. Integrating ImplicitKey into hasId() is fine, but one still needs a way of creating the index in the first place. One could argue it's cleaner to provide a separate method for creating id based indexes rather than explicitly using ImplicitKey.\n@FlorianHockmann I will try to figure out whether or not hasId() already profits of having an manually created index on adjacent ids. I currently doubt this is the case but I'll have a closer look on it.", "author": "rngcntr", "createdAt": "2020-02-04T08:20:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA2ODkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU1NjIyOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r374556228", "bodyText": "It looks like indexes are not supported by hasId() yet:", "author": "rngcntr", "createdAt": "2020-02-04T09:25:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA2ODkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjE2ODU4MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r376168580", "bodyText": "@rngcntr Indeed they are not used for hasId step. Here is a related issue: #1525", "author": "porunov", "createdAt": "2020-02-07T01:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA2ODkzNw=="}], "type": "inlineReview"}, {"oid": "179ec01c3df81b65cc50402638c0401a60d238bb", "url": "https://github.com/JanusGraph/janusgraph/commit/179ec01c3df81b65cc50402638c0401a60d238bb", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-10T13:08:18Z", "type": "forcePushed"}, {"oid": "8bdbd363473212a04e7bd67f21f5dcd27f34977b", "url": "https://github.com/JanusGraph/janusgraph/commit/8bdbd363473212a04e7bd67f21f5dcd27f34977b", "message": "Add tests for previous commit [doc only]\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-11T12:35:12Z", "type": "forcePushed"}, {"oid": "d12a19afc3c044f0ad727fd7d029e3ac2bba66c5", "url": "https://github.com/JanusGraph/janusgraph/commit/d12a19afc3c044f0ad727fd7d029e3ac2bba66c5", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-12T08:13:59Z", "type": "forcePushed"}, {"oid": "171bb7001bb21c24e18474a1f83bdff5b6d023cb", "url": "https://github.com/JanusGraph/janusgraph/commit/171bb7001bb21c24e18474a1f83bdff5b6d023cb", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-12T08:17:50Z", "type": "forcePushed"}, {"oid": "335d4350a5fa8ea0a1665270390342a39c73a372", "url": "https://github.com/JanusGraph/janusgraph/commit/335d4350a5fa8ea0a1665270390342a39c73a372", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-12T08:18:23Z", "type": "forcePushed"}, {"oid": "6ec88f27a2805a3bae490fd636c9aaa963428572", "url": "https://github.com/JanusGraph/janusgraph/commit/6ec88f27a2805a3bae490fd636c9aaa963428572", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-12T08:23:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNTkwNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r379025906", "bodyText": "Not necessary to build this index explicitly. It is available automatically from storage layout. See column part of https://docs.janusgraph.org/advanced-topics/data-model/#individual-edge-layout", "author": "mad", "createdAt": "2020-02-13T18:00:13Z", "path": "docs/index-management/index-performance.md", "diffHunk": "@@ -466,13 +466,51 @@ increases. Often, such traversals can be rewritten as constrained\n traversals that can utilize a vertex-centric index to ensure acceptable\n performance at scale.\n \n+### Vertex-centric indexes on adjacent vertex ids\n+\n+In some cases it is relevant to find an edge based on properties of the adjacent vertex.\n+Let's say we want to find out whether or not Hercules has battled Cerberus.\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+g.V(h).out('battled').has('name', 'cerberus').limit(1).hasNext()\n+```\n+\n+A query like this can not use a vertex centric index because it filters on vertex properties rather than edge properties.\n+But by restructuring the query, we can achieve exactly this.\n+As both vertices are known, the vertex ids can be used to select the edge.\n+In contrast to the name \"Cebereus\", which is a property of the adjacent vertex, the id of this vertex is already saved within the connecting edge itself.\n+Therefore, this query runs much faster if hercules has battled many opponents:\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+c = g.V().has('name', 'cerberus').next()\n+g.V(h).outE('battled').where(inV().is(c)).limit(1).hasNext()\n+```\n+\n+Assuming there is a global index on the 'name' property, this already improves the performance a lot, because it's not necessary to fetch every adjacent vertex anymore.\n+But analog to other edge properties, a vertex-centric index can be used to further improve the performance:\n+```groovy\n+graph.tx().rollback()  //Never create new indexes while a transaction is active", "originalCommit": "6ec88f27a2805a3bae490fd636c9aaa963428572", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTI5MTIyOA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r379291228", "bodyText": "By 'this index' you mean the index on the adjacent ids?\nI see that the storage backend can efficiently retrieve edges by their column. But the column is composed of multiple values with only one of them being the adjacent id. I didn't know it's possible to access edges by only a part of their column.", "author": "rngcntr", "createdAt": "2020-02-14T07:55:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTMwNzMwNA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r379307304", "bodyText": "Alright, I had a closer look at it and I admit I somehow skipped performance testing index-aware queries without explicitly creating these indexes.\nAs a consequence, I don't see any point in this functionality anymore.", "author": "rngcntr", "createdAt": "2020-02-14T08:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTAyNTkwNg=="}], "type": "inlineReview"}, {"oid": "7ec49e7b06522c1b55f90ea93c8e9435c7d9816b", "url": "https://github.com/JanusGraph/janusgraph/commit/7ec49e7b06522c1b55f90ea93c8e9435c7d9816b", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-14T08:46:14Z", "type": "forcePushed"}, {"oid": "b7ccaa00958e50b12654654660534d178c5d1464", "url": "https://github.com/JanusGraph/janusgraph/commit/b7ccaa00958e50b12654654660534d178c5d1464", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-02-14T08:46:55Z", "type": "forcePushed"}, {"oid": "cc5566f6335dffd5a3d08c209b4105d198e70559", "url": "https://github.com/JanusGraph/janusgraph/commit/cc5566f6335dffd5a3d08c209b4105d198e70559", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-04-16T11:09:22Z", "type": "forcePushed"}, {"oid": "e0cf387b81aae71720f4c980c6704418d10e1600", "url": "https://github.com/JanusGraph/janusgraph/commit/e0cf387b81aae71720f4c980c6704418d10e1600", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-04-16T11:18:20Z", "type": "commit"}, {"oid": "e0cf387b81aae71720f4c980c6704418d10e1600", "url": "https://github.com/JanusGraph/janusgraph/commit/e0cf387b81aae71720f4c980c6704418d10e1600", "message": "Explain usage of implicit keys for vertex-centric indexes [doc only]\n\nResolves #1935\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-04-16T11:18:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU0Njc0MA==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r409546740", "bodyText": "(nitpick) I would leave out limit(1) to make the traversal easier to read. It should also not really matter for the performance here I guess.", "author": "FlorianHockmann", "createdAt": "2020-04-16T13:16:05Z", "path": "docs/index-management/index-performance.md", "diffHunk": "@@ -466,13 +466,46 @@ increases. Often, such traversals can be rewritten as constrained\n traversals that can utilize a vertex-centric index to ensure acceptable\n performance at scale.\n \n+### Using vertex-centric indexes on adjacent vertex ids\n+\n+In some cases it is relevant to find an edge based on properties of the adjacent vertex.\n+Let's say we want to find out whether or not Hercules has battled Cerberus.\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+g.V(h).out('battled').has('name', 'cerberus').limit(1).hasNext()", "originalCommit": "e0cf387b81aae71720f4c980c6704418d10e1600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU4Mzk4OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r409583989", "bodyText": "I'm not sure if this has an impact on performance. But for the sake of simplicity I can remove it from the query.", "author": "rngcntr", "createdAt": "2020-04-16T14:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU0Njc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU3NDMwNg==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r409574306", "bodyText": "name should be in \"`\", not in \"'\"", "author": "FlorianHockmann", "createdAt": "2020-04-16T13:53:46Z", "path": "docs/index-management/index-performance.md", "diffHunk": "@@ -466,13 +466,46 @@ increases. Often, such traversals can be rewritten as constrained\n traversals that can utilize a vertex-centric index to ensure acceptable\n performance at scale.\n \n+### Using vertex-centric indexes on adjacent vertex ids\n+\n+In some cases it is relevant to find an edge based on properties of the adjacent vertex.\n+Let's say we want to find out whether or not Hercules has battled Cerberus.\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+g.V(h).out('battled').has('name', 'cerberus').limit(1).hasNext()\n+```\n+\n+A query like this can not use a vertex centric index because it filters on vertex properties rather than edge properties.\n+But by restructuring the query, we can achieve exactly this.\n+As both vertices are known, the vertex ids can be used to select the edge.\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+c = g.V().has('name', 'cerberus').next()\n+```\n+\n+In contrast to the name \"Cebereus\", which is a property of the adjacent vertex, the id of this vertex is already saved within the connecting edge itself.\n+Therefore, this query runs much faster if hercules has battled many opponents:\n+```groovy\n+g.V(h).outE('battled').where(inV().is(c)).limit(1).hasNext()\n+```\n+\n+... or even shorter:\n+```groovy\n+g.V(h).out('battled').is(c).limit(1).hasNext()\n+```\n+\n+Assuming there is a global index on the 'name' property, this improves the performance a lot, because it's not necessary to fetch every adjacent vertex anymore.", "originalCommit": "e0cf387b81aae71720f4c980c6704418d10e1600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU3NDgxMg==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r409574812", "bodyText": "Please also wrap long lines.", "author": "FlorianHockmann", "createdAt": "2020-04-16T13:54:22Z", "path": "docs/index-management/index-performance.md", "diffHunk": "@@ -466,13 +466,46 @@ increases. Often, such traversals can be rewritten as constrained\n traversals that can utilize a vertex-centric index to ensure acceptable\n performance at scale.\n \n+### Using vertex-centric indexes on adjacent vertex ids\n+\n+In some cases it is relevant to find an edge based on properties of the adjacent vertex.\n+Let's say we want to find out whether or not Hercules has battled Cerberus.\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+g.V(h).out('battled').has('name', 'cerberus').limit(1).hasNext()\n+```\n+\n+A query like this can not use a vertex centric index because it filters on vertex properties rather than edge properties.\n+But by restructuring the query, we can achieve exactly this.\n+As both vertices are known, the vertex ids can be used to select the edge.\n+```groovy\n+h = g.V().has('name', 'hercules').next()\n+c = g.V().has('name', 'cerberus').next()\n+```\n+\n+In contrast to the name \"Cebereus\", which is a property of the adjacent vertex, the id of this vertex is already saved within the connecting edge itself.\n+Therefore, this query runs much faster if hercules has battled many opponents:\n+```groovy\n+g.V(h).outE('battled').where(inV().is(c)).limit(1).hasNext()\n+```\n+\n+... or even shorter:\n+```groovy\n+g.V(h).out('battled').is(c).limit(1).hasNext()\n+```\n+\n+Assuming there is a global index on the 'name' property, this improves the performance a lot, because it's not necessary to fetch every adjacent vertex anymore.", "originalCommit": "e0cf387b81aae71720f4c980c6704418d10e1600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU4NTQ5MQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r409585491", "bodyText": "I prefer to write one line per sentence. This way, later diffs are way easier to read.", "author": "rngcntr", "createdAt": "2020-04-16T14:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU3NDgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5MjA0OQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r409592049", "bodyText": "I understand your reasoning but I think that it's important to stay consistent across the docs and we currently wrap long lines so I prefer if we stick to this. You can still start a new line for each sentence but please also wrap lines of a single sentence if they are too long. (We might however add an .editorconfig to make these implicit conventions explicit.)", "author": "FlorianHockmann", "createdAt": "2020-04-16T14:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU3NDgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU5ODMxOQ==", "url": "https://github.com/JanusGraph/janusgraph/pull/1937#discussion_r409598319", "bodyText": "Accepted", "author": "rngcntr", "createdAt": "2020-04-16T14:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTU3NDgxMg=="}], "type": "inlineReview"}, {"oid": "2d438977bc899d8293257bff839ab9d40fff4083", "url": "https://github.com/JanusGraph/janusgraph/commit/2d438977bc899d8293257bff839ab9d40fff4083", "message": "Apply changes suggested by @FlorianHockmann [doc only]\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-04-16T14:25:26Z", "type": "commit"}, {"oid": "2d438977bc899d8293257bff839ab9d40fff4083", "url": "https://github.com/JanusGraph/janusgraph/commit/2d438977bc899d8293257bff839ab9d40fff4083", "message": "Apply changes suggested by @FlorianHockmann [doc only]\n\nSigned-off-by: Florian Grieskamp <florian.grieskamp@gdata.de>", "committedDate": "2020-04-16T14:25:26Z", "type": "forcePushed"}]}