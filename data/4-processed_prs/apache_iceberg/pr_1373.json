{"pr_number": 1373, "pr_title": "API: Implement SortOrder", "pr_createdAt": "2020-08-24T23:06:36Z", "pr_url": "https://github.com/apache/iceberg/pull/1373", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Mzk2NA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r475943964", "bodyText": "I think matching the behavior in PartitionSpec is the most reasonable way.", "author": "aokolnychyi", "createdAt": "2020-08-24T23:08:27Z", "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());", "originalCommit": "f7156637202b839243a6bddde9229ab8c7be93f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MDkxNg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479570916", "bodyText": "I wish we had reserved 0 for the unpartitioned spec. I'm happy to take that approach for sort order.", "author": "rdblue", "createdAt": "2020-08-28T23:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Mzk2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI2NDkxNQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481264915", "bodyText": "Sounds good, let's reserve it.", "author": "aokolnychyi", "createdAt": "2020-09-01T16:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Mzk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NDQzOQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r475944439", "bodyText": "This seems to get out of hand. We may want to switch to a builder here.", "author": "aokolnychyi", "createdAt": "2020-08-24T23:09:09Z", "path": "api/src/main/java/org/apache/iceberg/catalog/Catalog.java", "diffHunk": "@@ -58,9 +60,50 @@ Table createTable(\n       TableIdentifier identifier,\n       Schema schema,\n       PartitionSpec spec,\n+      SortOrder sortOrder,\n       String location,\n       Map<String, String> properties);\n \n+  /**\n+   * Create a table.\n+   *\n+   * @param identifier a table identifier\n+   * @param schema a schema\n+   * @param spec a partition spec\n+   * @param location a location for the table; leave null if unspecified\n+   * @param properties a string map of table properties\n+   * @return a Table instance\n+   * @throws AlreadyExistsException if the table already exists\n+   */\n+  default Table createTable(", "originalCommit": "f7156637202b839243a6bddde9229ab8c7be93f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU2MTA1Nw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476561057", "bodyText": "I think that would definitely make it a little cleaner here and in all of the related \"create\" methods", "author": "RussellSpitzer", "createdAt": "2020-08-25T16:00:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwNjY0Mg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477606642", "bodyText": "@rdsr @shardulm94 @rdblue what do you guys think?", "author": "aokolnychyi", "createdAt": "2020-08-26T21:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODgyMzgxMg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r478823812", "bodyText": "I'm +1. But this is a public API, we'd have to keep the current methods around though, marked as deprecated.", "author": "rdsr", "createdAt": "2020-08-28T04:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NjU3Ng==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479456576", "bodyText": "Yeah, I think we can map existing methods into the builder and keep the compatibility.", "author": "aokolnychyi", "createdAt": "2020-08-28T18:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NDgzMw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479574833", "bodyText": "We only double the number of implementations every time we add a new config option...\n+1 to a builder, I think that would be helpful.", "author": "rdblue", "createdAt": "2020-08-28T23:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NDQzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI2MzU5Nw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481263597", "bodyText": "Submitted PR #1409 for this.", "author": "aokolnychyi", "createdAt": "2020-09-01T16:10:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NDQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NTM1OA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r475945358", "bodyText": "This problem is not specific to SortOrder but also applies to PartitionSpec.", "author": "aokolnychyi", "createdAt": "2020-08-24T23:10:23Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -94,9 +105,15 @@ static TableMetadata newTableMetadata(Schema schema,\n     }\n     PartitionSpec freshSpec = specBuilder.build();\n \n+    // TODO: case sensitivity", "originalCommit": "f7156637202b839243a6bddde9229ab8c7be93f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3OTM2NA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479579364", "bodyText": "I don't think this would be a problem unless the schema passed in is not the schema used to create the spec or sort order. If it is the same, then the case sensitive check will always work. If not, then we could have an error when we can't find the name when rebuilding for the schema with fresh IDs.", "author": "rdblue", "createdAt": "2020-08-29T00:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NTM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwNjA1MA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481306050", "bodyText": "Agree. We could have this problem but on one layer above.", "author": "aokolnychyi", "createdAt": "2020-09-01T17:16:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0NTM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Nzk5MQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r475947991", "bodyText": "I did not default the null order as the SQL standard does not define this. Spark and Presto, as well as RDBMs, use different default null orderings.", "author": "aokolnychyi", "createdAt": "2020-08-24T23:14:06Z", "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());\n+\n+  private final Schema schema;\n+  private final int orderId;\n+  private final SortField[] fields;\n+\n+  private transient volatile List<SortField> fieldList;\n+\n+  private SortOrder(Schema schema, int orderId, List<SortField> fields) {\n+    this.schema = schema;\n+    this.orderId = orderId;\n+    this.fields = fields.toArray(new SortField[0]);\n+  }\n+\n+  public Schema schema() {\n+    return schema;\n+  }\n+\n+  public int orderId() {\n+    return orderId;\n+  }\n+\n+  public List<SortField> fields() {\n+    return lazyFieldList();\n+  }\n+\n+  public boolean isUnsorted() {\n+    return fields.length < 1;\n+  }\n+\n+  public boolean satisfies(SortOrder anotherSortOrder) {\n+    // any ordering satisfies an unsorted ordering\n+    if (anotherSortOrder.isUnsorted()) {\n+      return true;\n+    }\n+\n+    // this ordering cannot satisfy an ordering with more sort fields\n+    if (anotherSortOrder.fields.length > fields.length) {\n+      return false;\n+    }\n+\n+    // this ordering has either more or the same number of sort fields\n+    return IntStream.range(0, anotherSortOrder.fields.length)\n+        .allMatch(index -> fields[index].equals(anotherSortOrder.fields[index]));\n+  }\n+\n+  public boolean sameOrder(SortOrder anotherSortOrder) {\n+    return Arrays.equals(fields, anotherSortOrder.fields);\n+  }\n+\n+  private List<SortField> lazyFieldList() {\n+    if (fieldList == null) {\n+      synchronized (this) {\n+        if (fieldList == null) {\n+          this.fieldList = ImmutableList.copyOf(fields);\n+        }\n+      }\n+    }\n+    return fieldList;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"[\");\n+    for (SortField field : fields) {\n+      sb.append(\"\\n\");\n+      sb.append(\"  \").append(field);\n+    }\n+    if (fields.length > 0) {\n+      sb.append(\"\\n\");\n+    }\n+    sb.append(\"]\");\n+    return sb.toString();\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    if (this == other) {\n+      return true;\n+    } else if (other == null || getClass() != other.getClass()) {\n+      return false;\n+    }\n+\n+    SortOrder that = (SortOrder) other;\n+    return orderId == that.orderId && Arrays.equals(fields, that.fields);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return 31 * Integer.hashCode(orderId) + Arrays.hashCode(fields);\n+  }\n+\n+  public static SortOrder unsorted() {\n+    return UNSORTED_ORDER;\n+  }\n+\n+  public static Builder builderFor(Schema schema) {\n+    return new Builder(schema);\n+  }\n+\n+  public static class Builder {\n+    private final Schema schema;\n+    private final List<SortField> fields = Lists.newArrayList();\n+    private int orderId = 0;\n+    private boolean caseSensitive = true;\n+\n+    private Builder(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    public Builder asc(String name, NullOrder nullOrder) {", "originalCommit": "f7156637202b839243a6bddde9229ab8c7be93f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwOTI4MQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476509281", "bodyText": "I think even if other frameworks don't define this it's ok to have a default? Like If a user doesn't care then we should just make the decision for them right?", "author": "RussellSpitzer", "createdAt": "2020-08-25T14:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Nzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwNjkzNQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477606935", "bodyText": "Yeah, I'll be fine with picking a default value ourselves.", "author": "aokolnychyi", "createdAt": "2020-08-26T21:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Nzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3Mjk5NQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479572995", "bodyText": "What does Presto use? That seems like a reasonable choice. I'd like to avoid requiring field-level NullOrder when using this API.\nThat might be slightly annoying, since the builder pattern shouldn't rely on calling methods in a particular order. That is, I think that these two should produce the same sort order:\n// ORDER BY x ASC NULLS FIRST, y DESC NULLS FIRST\nSortOrder.builderFor(schema)\n    .asc(\"x\")\n    .desc(\"y\")\n    .nullsFirst()\n    .build();\n\n// ORDER BY x ASC NULLS FIRST, y DESC NULLS FIRST\nSortOrder.builderFor(schema)\n    .nullsFirst()\n    .asc(\"x\")\n    .desc(\"y\")\n    .build();", "author": "rdblue", "createdAt": "2020-08-28T23:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Nzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM4NTAwNw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r480385007", "bodyText": "Presto seems to behave differently than any other system. I wanted to follow Spark, Hive and MySQL until I saw a stale PR in Hive to switch to NULLS LAST by default. Having said that, I still propose to match Spark and MySQL and also allow setting a null order per column as that is possible in many systems.", "author": "aokolnychyi", "createdAt": "2020-08-31T20:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Nzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0ODE1Nw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r480448157", "bodyText": "That sounds good to me for the defaults. I'd still like to make it easy to use the default if you don't care, and easy to set the default for this sort order, like the examples above.", "author": "rdblue", "createdAt": "2020-08-31T22:48:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Nzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI4MzMwNg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481283306", "bodyText": "How commonly do we expect to see cases when users want to configure a null order for all columns through a global param? In most cases, the ordering will come from query engines in a form of expressions that have a null order per column. If users create a sort order manually and don't care, they can just skip null orders. I do get the use case of being able to set the default but my worry that it complicates the implementation. We will need to defer assigning a null order in asc/desc and iterate through sort columns in build and see whether we already assigned the null order for a particular column.", "author": "aokolnychyi", "createdAt": "2020-09-01T16:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Nzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI5NTEyNg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481295126", "bodyText": "Yeah, that's a fair argument. We can always add nullsFirst() and nullsLast() calls later and keep just the asc and desc calls for now.", "author": "rdblue", "createdAt": "2020-09-01T16:57:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Nzk5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjI0MDcwMQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r482240701", "bodyText": "Presto does NULLS LAST by default in both directions because we expect that users don't want to see nulls. Consider these queries:\nSELECT x FROM t ORDER BY x LIMIT 10;\nSELECT x FROM t ORDER BY x DESC LIMIT 10;\nIn both of these cases, the user likely wants to see some data, not a bunch of nulls. This behavior is allowed by the SQL standard:\n\nIf <null ordering> is not specified, then an implementation-defined <null ordering> is implicit. The implementation-defined default for <null ordering> shall not depend on the context outside of <sort specification list>.", "author": "electrum", "createdAt": "2020-09-02T17:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk0Nzk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MzYxNw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476483617", "bodyText": "I've usually seen this with \"Locale.ROOT\" to avoid the Turkish issues, I assume English works as well?", "author": "RussellSpitzer", "createdAt": "2020-08-25T14:16:03Z", "path": "api/src/main/java/org/apache/iceberg/NullOrder.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.util.Locale;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+public enum NullOrder {\n+  NULLS_FIRST(\"first\"), NULLS_LAST(\"last\");\n+\n+  private final String jsonValue;\n+\n+  NullOrder(String jsonValue) {\n+    this.jsonValue = jsonValue;\n+  }\n+\n+  public static NullOrder fromJsonValue(String jsonValue) {\n+    Preconditions.checkArgument(jsonValue != null, \"json value is null\");\n+    return NullOrder.valueOf(\"NULLS_\" + jsonValue.toUpperCase(Locale.ENGLISH));", "originalCommit": "f7156637202b839243a6bddde9229ab8c7be93f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwNzA0MA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477607040", "bodyText": "Yeah, should work too.", "author": "aokolnychyi", "createdAt": "2020-08-26T21:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MzYxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2OTk1OQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479569959", "bodyText": "Yeah, both work. I think we have mixed usage in the project. If the word is English, then it's okay to use this.", "author": "rdblue", "createdAt": "2020-08-28T23:11:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQ4MzYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwNDU0MQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476504541", "bodyText": "Could use guava Streams.zip here, skip a little bit of direct indexing but that's personal preference", "author": "RussellSpitzer", "createdAt": "2020-08-25T14:43:02Z", "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());\n+\n+  private final Schema schema;\n+  private final int orderId;\n+  private final SortField[] fields;\n+\n+  private transient volatile List<SortField> fieldList;\n+\n+  private SortOrder(Schema schema, int orderId, List<SortField> fields) {\n+    this.schema = schema;\n+    this.orderId = orderId;\n+    this.fields = fields.toArray(new SortField[0]);\n+  }\n+\n+  public Schema schema() {\n+    return schema;\n+  }\n+\n+  public int orderId() {\n+    return orderId;\n+  }\n+\n+  public List<SortField> fields() {\n+    return lazyFieldList();\n+  }\n+\n+  public boolean isUnsorted() {\n+    return fields.length < 1;\n+  }\n+\n+  public boolean satisfies(SortOrder anotherSortOrder) {\n+    // any ordering satisfies an unsorted ordering\n+    if (anotherSortOrder.isUnsorted()) {\n+      return true;\n+    }\n+\n+    // this ordering cannot satisfy an ordering with more sort fields\n+    if (anotherSortOrder.fields.length > fields.length) {\n+      return false;\n+    }\n+\n+    // this ordering has either more or the same number of sort fields\n+    return IntStream.range(0, anotherSortOrder.fields.length)", "originalCommit": "f7156637202b839243a6bddde9229ab8c7be93f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwNzExNw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477607117", "bodyText": "Let me check.", "author": "aokolnychyi", "createdAt": "2020-08-26T21:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwNDU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MTMxMQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479571311", "bodyText": "I'd rather not expand the use of Gauva. We could build our own zip easily enough.", "author": "rdblue", "createdAt": "2020-08-28T23:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwNDU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI2OTc1Mg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481269752", "bodyText": "Let's keep it as is then.", "author": "aokolnychyi", "createdAt": "2020-09-01T16:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjUwNDU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzY2NQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476557665", "bodyText": "I think when we return a Map of common classes we should describe what they represent, the Integer keys here I assume are Field numbers right?", "author": "RussellSpitzer", "createdAt": "2020-08-25T15:56:07Z", "path": "api/src/main/java/org/apache/iceberg/Table.java", "diffHunk": "@@ -65,6 +65,20 @@\n    */\n   Map<Integer, PartitionSpec> specs();\n \n+  /**\n+   * Return the {@link SortOrder sort order} for this table.\n+   *\n+   * @return this table's sort order\n+   */\n+  SortOrder sortOrder();\n+\n+  /**\n+   * Return a map of {@link SortOrder sort orders} for this table.", "originalCommit": "f7156637202b839243a6bddde9229ab8c7be93f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwNzMxMA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477607310", "bodyText": "It is a map from order id -> order. Let me add a comment.", "author": "aokolnychyi", "createdAt": "2020-08-26T21:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzY2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzcwMjgzMA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477702830", "bodyText": "Done.", "author": "aokolnychyi", "createdAt": "2020-08-26T23:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU1NzY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxNDU1Mg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476614552", "bodyText": "This block of changes 652 -668 Is confusing to me, could add some more comments? I'm mostly confused about when we add \"freshSortOrder\" , it looks like we ignore it entirely if an equivalent SortOrder is there?", "author": "RussellSpitzer", "createdAt": "2020-08-25T17:24:20Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -598,20 +649,38 @@ public TableMetadata buildReplacement(Schema updatedSchema, PartitionSpec update\n       builder.add(freshSpec);\n     }\n \n+    // determine the next order id\n+    int maxOrderId = sortOrders.stream().mapToInt(SortOrder::orderId).max().orElse(INITIAL_SORT_ORDER_ID);\n+    int nextOrderId = maxOrderId + 1;", "originalCommit": "f7156637202b839243a6bddde9229ab8c7be93f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYwNjMwNQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477606305", "bodyText": "I've matched the logic we have for PartitionSpec. If we have an equivalent partition spec, we use it. I'll add a comment.", "author": "aokolnychyi", "createdAt": "2020-08-26T21:42:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxNDU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NjkzMA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479586930", "bodyText": "This is used when we are running a REPLACE TABLE operation. We want to keep the history, but the schema and partition spec can be completely new. When the schema and partition spec are new, we assign fresh IDs to the schema and rebuild the partition spec (and sort order) to use the newly assigned IDs. That's why we use the freshSpec and freshSortOrder methods here as well as when creating new table metadata -- because we don't trust the IDs that were assigned in the schema that was passed in.\nI should note that when we update a schema, we also rebuild the specs and sort orders. But in those cases, the IDs aren't what we are changing. What may change are the fields in the schema. Fields could be renamed, or dropped. What we're primarily looking for is when a field is dropped. Then rebuilding the order or spec will hit a validation exception.", "author": "rdblue", "createdAt": "2020-08-29T00:54:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxNDU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxOTcxOA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r476619718", "bodyText": "Does this include tests for the serde to/from json?", "author": "RussellSpitzer", "createdAt": "2020-08-25T17:29:10Z", "path": "core/src/test/java/org/apache/iceberg/TestTableMetadata.java", "diffHunk": "@@ -35,6 +35,7 @@\n import org.apache.iceberg.TableMetadata.MetadataLogEntry;", "originalCommit": "f7156637202b839243a6bddde9229ab8c7be93f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5OTYzMg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477699632", "bodyText": "Yep.", "author": "aokolnychyi", "createdAt": "2020-08-26T23:47:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxOTcxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzcwMDk3OA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477700978", "bodyText": "This also tests backward compatibility.", "author": "aokolnychyi", "createdAt": "2020-08-26T23:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxOTcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5NDkzOA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477694938", "bodyText": "We are using this in Builder.", "author": "aokolnychyi", "createdAt": "2020-08-26T23:43:57Z", "path": "api/src/main/java/org/apache/iceberg/expressions/Expressions.java", "diffHunk": "@@ -251,7 +251,7 @@ public static Expression rewriteNot(Expression expr) {\n     return ExpressionVisitors.visit(expr, RewriteNot.get());\n   }\n \n-  static <T> NamedReference<T> ref(String name) {\n+  public static <T> NamedReference<T> ref(String name) {", "originalCommit": "453f49fc3d6643e8cd2ea17badb5df851b67c7b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTMwMQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479575301", "bodyText": "It should be fine to pass this in through the factory methods that accept Term, so it's okay to make it public.\nIt should have Javadoc, though. And it would be helpful to mention that this is equivalent to using the Expressions methods that accept String: The following are equivalent: equals(\"a\", 5) and equals(ref(\"a\"), 5)", "author": "rdblue", "createdAt": "2020-08-28T23:39:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5NDkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI4NDAyMw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481284023", "bodyText": "Will add.", "author": "aokolnychyi", "createdAt": "2020-09-01T16:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5NDkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5Njg5OA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477696898", "bodyText": "This place, probably, requires additional attention. I've added a test to TestReplaceTransaction.", "author": "aokolnychyi", "createdAt": "2020-08-26T23:45:17Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -598,20 +649,39 @@ public TableMetadata buildReplacement(Schema updatedSchema, PartitionSpec update\n       builder.add(freshSpec);\n     }\n \n+    // determine the next order id\n+    int maxOrderId = sortOrders.stream().mapToInt(SortOrder::orderId).max().orElse(INITIAL_SORT_ORDER_ID);\n+    int nextOrderId = maxOrderId + 1;\n+\n+    // rebuild the sort order using new column ids\n+    SortOrder freshSortOrder = freshSortOrder(nextOrderId, freshSchema, updatedSortOrder);\n+\n+    // if the order already exists, use the same ID. otherwise, use 1 more than the highest ID.\n+    Optional<SortOrder> sameSortOrder = sortOrders.stream()\n+        .filter(sortOrder -> sortOrder.sameOrder(freshSortOrder))\n+        .findAny();\n+    int orderId = sameSortOrder.map(SortOrder::orderId).orElse(nextOrderId);\n+\n+    ImmutableList.Builder<SortOrder> sortOrdersBuilder = ImmutableList.<SortOrder>builder().addAll(sortOrders);", "originalCommit": "453f49fc3d6643e8cd2ea17badb5df851b67c7b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5OTM2NA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r477699364", "bodyText": "I will add more tests here.", "author": "aokolnychyi", "createdAt": "2020-08-26T23:46:54Z", "path": "core/src/test/java/org/apache/iceberg/TestSortOrderParser.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import org.apache.iceberg.transforms.UnknownTransform;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.NullOrder.NULLS_FIRST;\n+import static org.apache.iceberg.SortDirection.DESC;\n+\n+public class TestSortOrderParser extends TableTestBase {", "originalCommit": "453f49fc3d6643e8cd2ea17badb5df851b67c7b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MDExMg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479570112", "bodyText": "What about toString/fromString? Instead of using jsonValue? Since it is just a simple string, there is no need to call out that it is intended for JSON.", "author": "rdblue", "createdAt": "2020-08-28T23:12:22Z", "path": "api/src/main/java/org/apache/iceberg/NullOrder.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.util.Locale;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+public enum NullOrder {\n+  NULLS_FIRST(\"first\"), NULLS_LAST(\"last\");\n+\n+  private final String jsonValue;\n+\n+  NullOrder(String jsonValue) {\n+    this.jsonValue = jsonValue;\n+  }\n+\n+  public static NullOrder fromJsonValue(String jsonValue) {", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MDU2NQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479570565", "bodyText": "I see toString is used for the SQL-ish representation. Maybe we should just embed this in a parser class instead of having them here.", "author": "rdblue", "createdAt": "2020-08-28T23:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MDExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI2NDM1NA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481264354", "bodyText": "Will move this logic to the parser.", "author": "aokolnychyi", "createdAt": "2020-09-01T16:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MDExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE5ODM5OQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r483198399", "bodyText": "Done.", "author": "aokolnychyi", "createdAt": "2020-09-03T19:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MDExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MTQ4OQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479571489", "bodyText": "Nit: I find it a bit less awkward to use a stream for these cases because it accepts a factory method:\nthis.fields = fields.stream().toArray(SortField[]::new);", "author": "rdblue", "createdAt": "2020-08-28T23:19:41Z", "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());\n+\n+  private final Schema schema;\n+  private final int orderId;\n+  private final SortField[] fields;\n+\n+  private transient volatile List<SortField> fieldList;\n+\n+  private SortOrder(Schema schema, int orderId, List<SortField> fields) {\n+    this.schema = schema;\n+    this.orderId = orderId;\n+    this.fields = fields.toArray(new SortField[0]);", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI2OTQ0Ng==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481269446", "bodyText": "Actually, Intellij highlights this and suggests to replace with fields.toArray(new SortField[0]). I am ok with both options but would prefer to avoid extra warnings.", "author": "aokolnychyi", "createdAt": "2020-09-01T16:15:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MTQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MjE5NQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479572195", "bodyText": "Should this delegate to sameOrder instead of checking fields directly?", "author": "rdblue", "createdAt": "2020-08-28T23:23:30Z", "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());\n+\n+  private final Schema schema;\n+  private final int orderId;\n+  private final SortField[] fields;\n+\n+  private transient volatile List<SortField> fieldList;\n+\n+  private SortOrder(Schema schema, int orderId, List<SortField> fields) {\n+    this.schema = schema;\n+    this.orderId = orderId;\n+    this.fields = fields.toArray(new SortField[0]);\n+  }\n+\n+  public Schema schema() {\n+    return schema;\n+  }\n+\n+  public int orderId() {\n+    return orderId;\n+  }\n+\n+  public List<SortField> fields() {\n+    return lazyFieldList();\n+  }\n+\n+  public boolean isUnsorted() {\n+    return fields.length < 1;\n+  }\n+\n+  public boolean satisfies(SortOrder anotherSortOrder) {\n+    // any ordering satisfies an unsorted ordering\n+    if (anotherSortOrder.isUnsorted()) {\n+      return true;\n+    }\n+\n+    // this ordering cannot satisfy an ordering with more sort fields\n+    if (anotherSortOrder.fields.length > fields.length) {\n+      return false;\n+    }\n+\n+    // this ordering has either more or the same number of sort fields\n+    return IntStream.range(0, anotherSortOrder.fields.length)\n+        .allMatch(index -> fields[index].equals(anotherSortOrder.fields[index]));\n+  }\n+\n+  public boolean sameOrder(SortOrder anotherSortOrder) {\n+    return Arrays.equals(fields, anotherSortOrder.fields);\n+  }\n+\n+  private List<SortField> lazyFieldList() {\n+    if (fieldList == null) {\n+      synchronized (this) {\n+        if (fieldList == null) {\n+          this.fieldList = ImmutableList.copyOf(fields);\n+        }\n+      }\n+    }\n+    return fieldList;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"[\");\n+    for (SortField field : fields) {\n+      sb.append(\"\\n\");\n+      sb.append(\"  \").append(field);\n+    }\n+    if (fields.length > 0) {\n+      sb.append(\"\\n\");\n+    }\n+    sb.append(\"]\");\n+    return sb.toString();\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    if (this == other) {\n+      return true;\n+    } else if (other == null || getClass() != other.getClass()) {\n+      return false;\n+    }\n+\n+    SortOrder that = (SortOrder) other;\n+    return orderId == that.orderId && Arrays.equals(fields, that.fields);", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI2OTg4MA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481269880", "bodyText": "Will update.", "author": "aokolnychyi", "createdAt": "2020-09-01T16:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MjE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE5ODQ5Mw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r483198493", "bodyText": "Done.", "author": "aokolnychyi", "createdAt": "2020-09-03T19:12:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3MjE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3Mzk3NA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479573974", "bodyText": "Probably worth a comment that states ValidationException is thrown by bind if binding fails so we can assume that boundTerm is defined correctly. (I just checked to make sure)", "author": "rdblue", "createdAt": "2020-08-28T23:32:44Z", "path": "api/src/main/java/org/apache/iceberg/SortOrder.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+import org.apache.iceberg.exceptions.ValidationException;\n+import org.apache.iceberg.expressions.BoundReference;\n+import org.apache.iceberg.expressions.BoundTerm;\n+import org.apache.iceberg.expressions.BoundTransform;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.Term;\n+import org.apache.iceberg.expressions.UnboundTerm;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.transforms.Transform;\n+import org.apache.iceberg.transforms.Transforms;\n+import org.apache.iceberg.types.Types;\n+\n+public class SortOrder implements Serializable {\n+  // TODO: shall we reserve 0 for the unsorted order? PartitionSpec does not guarantee it?\n+  private static final SortOrder UNSORTED_ORDER = new SortOrder(new Schema(), 0, Collections.emptyList());\n+\n+  private final Schema schema;\n+  private final int orderId;\n+  private final SortField[] fields;\n+\n+  private transient volatile List<SortField> fieldList;\n+\n+  private SortOrder(Schema schema, int orderId, List<SortField> fields) {\n+    this.schema = schema;\n+    this.orderId = orderId;\n+    this.fields = fields.toArray(new SortField[0]);\n+  }\n+\n+  public Schema schema() {\n+    return schema;\n+  }\n+\n+  public int orderId() {\n+    return orderId;\n+  }\n+\n+  public List<SortField> fields() {\n+    return lazyFieldList();\n+  }\n+\n+  public boolean isUnsorted() {\n+    return fields.length < 1;\n+  }\n+\n+  public boolean satisfies(SortOrder anotherSortOrder) {\n+    // any ordering satisfies an unsorted ordering\n+    if (anotherSortOrder.isUnsorted()) {\n+      return true;\n+    }\n+\n+    // this ordering cannot satisfy an ordering with more sort fields\n+    if (anotherSortOrder.fields.length > fields.length) {\n+      return false;\n+    }\n+\n+    // this ordering has either more or the same number of sort fields\n+    return IntStream.range(0, anotherSortOrder.fields.length)\n+        .allMatch(index -> fields[index].equals(anotherSortOrder.fields[index]));\n+  }\n+\n+  public boolean sameOrder(SortOrder anotherSortOrder) {\n+    return Arrays.equals(fields, anotherSortOrder.fields);\n+  }\n+\n+  private List<SortField> lazyFieldList() {\n+    if (fieldList == null) {\n+      synchronized (this) {\n+        if (fieldList == null) {\n+          this.fieldList = ImmutableList.copyOf(fields);\n+        }\n+      }\n+    }\n+    return fieldList;\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"[\");\n+    for (SortField field : fields) {\n+      sb.append(\"\\n\");\n+      sb.append(\"  \").append(field);\n+    }\n+    if (fields.length > 0) {\n+      sb.append(\"\\n\");\n+    }\n+    sb.append(\"]\");\n+    return sb.toString();\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    if (this == other) {\n+      return true;\n+    } else if (other == null || getClass() != other.getClass()) {\n+      return false;\n+    }\n+\n+    SortOrder that = (SortOrder) other;\n+    return orderId == that.orderId && Arrays.equals(fields, that.fields);\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return 31 * Integer.hashCode(orderId) + Arrays.hashCode(fields);\n+  }\n+\n+  public static SortOrder unsorted() {\n+    return UNSORTED_ORDER;\n+  }\n+\n+  public static Builder builderFor(Schema schema) {\n+    return new Builder(schema);\n+  }\n+\n+  public static class Builder {\n+    private final Schema schema;\n+    private final List<SortField> fields = Lists.newArrayList();\n+    private int orderId = 0;\n+    private boolean caseSensitive = true;\n+\n+    private Builder(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    public Builder asc(String name, NullOrder nullOrder) {\n+      return addSortField(Expressions.ref(name), SortDirection.ASC, nullOrder);\n+    }\n+\n+    public Builder asc(Term term, NullOrder nullOrder) {\n+      return addSortField(term, SortDirection.ASC, nullOrder);\n+    }\n+\n+    public Builder desc(String name, NullOrder nullOrder) {\n+      return addSortField(Expressions.ref(name), SortDirection.DESC, nullOrder);\n+    }\n+\n+    public Builder desc(Term term, NullOrder nullOrder) {\n+      return addSortField(term, SortDirection.DESC, nullOrder);\n+    }\n+\n+    public Builder withOrderId(int newOrderId) {\n+      this.orderId = newOrderId;\n+      return this;\n+    }\n+\n+    public Builder caseSensitive(boolean sortCaseSensitive) {\n+      this.caseSensitive = sortCaseSensitive;\n+      return this;\n+    }\n+\n+    Builder addSortField(Term term, SortDirection direction, NullOrder nullOrder) {\n+      Preconditions.checkArgument(term instanceof UnboundTerm, \"Term must be unbound\");\n+      BoundTerm<?> boundTerm = ((UnboundTerm<?>) term).bind(schema.asStruct(), caseSensitive);", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI4Mzg1Mg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481283852", "bodyText": "Will add.", "author": "aokolnychyi", "createdAt": "2020-09-01T16:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3Mzk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4OTk0Ng==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r483189946", "bodyText": "Done.", "author": "aokolnychyi", "createdAt": "2020-09-03T18:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3Mzk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTgyMw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479575823", "bodyText": "Should we have defaults for sortOrder and spec as well? It seems strange that we do this for properties, but not the others.", "author": "rdblue", "createdAt": "2020-08-28T23:42:06Z", "path": "core/src/main/java/org/apache/iceberg/BaseMetastoreCatalog.java", "diffHunk": "@@ -64,8 +65,8 @@ public Table createTable(\n       baseLocation = defaultWarehouseLocation(identifier);\n     }\n \n-    TableMetadata metadata = TableMetadata.newTableMetadata(\n-        schema, spec, baseLocation, properties == null ? Maps.newHashMap() : properties);\n+    Map<String, String> tableProps = properties != null ? properties : ImmutableMap.of();", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTg3Ng==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479575876", "bodyText": "(Not something we need to decide in this PR)", "author": "rdblue", "createdAt": "2020-08-28T23:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwMjExMw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481302113", "bodyText": "Yeah, I think that will be safe. Right now, we pass null for table properties in overloaded methods so we must handle it explicitly. But nothing prohibits a user from passing null for spec and sortOrder even though we properly default them in overloaded methods.", "author": "aokolnychyi", "createdAt": "2020-09-01T17:09:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTgyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwMzM5Mw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481303393", "bodyText": "I've created #1411.", "author": "aokolnychyi", "createdAt": "2020-09-01T17:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3NTgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODE5OA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479578198", "bodyText": "Do we need to write a transform if it is identity? It would be nice to omit this when it is identity.", "author": "rdblue", "createdAt": "2020-08-28T23:54:50Z", "path": "core/src/main/java/org/apache/iceberg/SortOrderParser.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.util.JsonUtil;\n+\n+public class SortOrderParser {\n+  private static final String ORDER_ID = \"order-id\";\n+  private static final String FIELDS = \"fields\";\n+  private static final String DIRECTION = \"direction\";\n+  private static final String NULL_ORDERING = \"null-order\";\n+  private static final String TRANSFORM = \"transform\";\n+  private static final String SOURCE_ID = \"source-id\";\n+\n+  private SortOrderParser() {\n+  }\n+\n+  public static void toJson(SortOrder sortOrder, JsonGenerator generator) throws IOException {\n+    generator.writeStartObject();\n+    generator.writeNumberField(ORDER_ID, sortOrder.orderId());\n+    generator.writeFieldName(FIELDS);\n+    toJsonFields(sortOrder, generator);\n+    generator.writeEndObject();\n+  }\n+\n+  private static void toJsonFields(SortOrder sortOrder, JsonGenerator generator) throws IOException {\n+    generator.writeStartArray();\n+    for (SortField field : sortOrder.fields()) {\n+      generator.writeStartObject();\n+      generator.writeStringField(TRANSFORM, field.transform().toString());", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwNDI4OQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481304289", "bodyText": "I am ok omitting but it will add extra logic and it will behave differently compared to PartitionSpec.", "author": "aokolnychyi", "createdAt": "2020-09-01T17:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODgwMQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479578801", "bodyText": "I think this needs to check whether json is null as well. That's a bug here and in PartitionSpecParser. If it is null because the field doesn't exist, then this will throw a NullPointerException instead of a good error message. I'm good with either checking here (json != null && json.isArray()) or in the method that calls this using json.has(FIELDS).", "author": "rdblue", "createdAt": "2020-08-28T23:58:15Z", "path": "core/src/main/java/org/apache/iceberg/SortOrderParser.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Iterator;\n+import java.util.Locale;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.util.JsonUtil;\n+\n+public class SortOrderParser {\n+  private static final String ORDER_ID = \"order-id\";\n+  private static final String FIELDS = \"fields\";\n+  private static final String DIRECTION = \"direction\";\n+  private static final String NULL_ORDERING = \"null-order\";\n+  private static final String TRANSFORM = \"transform\";\n+  private static final String SOURCE_ID = \"source-id\";\n+\n+  private SortOrderParser() {\n+  }\n+\n+  public static void toJson(SortOrder sortOrder, JsonGenerator generator) throws IOException {\n+    generator.writeStartObject();\n+    generator.writeNumberField(ORDER_ID, sortOrder.orderId());\n+    generator.writeFieldName(FIELDS);\n+    toJsonFields(sortOrder, generator);\n+    generator.writeEndObject();\n+  }\n+\n+  private static void toJsonFields(SortOrder sortOrder, JsonGenerator generator) throws IOException {\n+    generator.writeStartArray();\n+    for (SortField field : sortOrder.fields()) {\n+      generator.writeStartObject();\n+      generator.writeStringField(TRANSFORM, field.transform().toString());\n+      generator.writeNumberField(SOURCE_ID, field.sourceId());\n+      generator.writeStringField(DIRECTION, field.direction().toString().toLowerCase(Locale.ROOT));\n+      generator.writeStringField(NULL_ORDERING, field.nullOrder().jsonValue());\n+      generator.writeEndObject();\n+    }\n+    generator.writeEndArray();\n+  }\n+\n+  public static SortOrder fromJson(Schema schema, String json) {\n+    try {\n+      return fromJson(schema, JsonUtil.mapper().readValue(json, JsonNode.class));\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  public static SortOrder fromJson(Schema schema, JsonNode json) {\n+    Preconditions.checkArgument(json.isObject(), \"Cannot parse sort order from non-object: %s\", json);\n+    int orderId = JsonUtil.getInt(ORDER_ID, json);\n+    SortOrder.Builder builder = SortOrder.builderFor(schema).withOrderId(orderId);\n+    buildFromJsonFields(builder, json.get(FIELDS));\n+    return builder.build();\n+  }\n+\n+  private static void buildFromJsonFields(SortOrder.Builder builder, JsonNode json) {\n+    Preconditions.checkArgument(json.isArray(), \"Cannot parse partition order fields, not an array: %s\", json);", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwNDQ3Mw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481304473", "bodyText": "Will update.", "author": "aokolnychyi", "createdAt": "2020-09-01T17:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODgwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE5ODg1MA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r483198850", "bodyText": "Done on one level above.", "author": "aokolnychyi", "createdAt": "2020-09-03T19:12:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3ODgwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3OTExMA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479579110", "bodyText": "If we want to reserve unsorted, all we would do is change this to 1 and add checks for passing in an unsorted order.", "author": "rdblue", "createdAt": "2020-08-29T00:00:03Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -49,6 +50,7 @@\n   static final int DEFAULT_TABLE_FORMAT_VERSION = 1;\n   static final int SUPPORTED_TABLE_FORMAT_VERSION = 2;\n   static final int INITIAL_SPEC_ID = 0;\n+  static final int INITIAL_SORT_ORDER_ID = 0;", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE5ODkzNQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r483198935", "bodyText": "Reserved.", "author": "aokolnychyi", "createdAt": "2020-09-03T19:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU3OTExMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MDA0NQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479580045", "bodyText": "Should we also expose defaultSpecId directly? Normally, we use spec().specId().", "author": "rdblue", "createdAt": "2020-08-29T00:05:33Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -348,6 +375,22 @@ public int defaultSpecId() {\n     return defaultSpecId;\n   }\n \n+  public int defaultSortOrderId() {\n+    return defaultSortOrderId;\n+  }", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM4NzYyOQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r483387629", "bodyText": "I am following what we have for specs to be consisent.", "author": "aokolnychyi", "createdAt": "2020-09-04T05:01:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MjY1Ng==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479582656", "bodyText": "This class might be a good one for a builder as well...", "author": "rdblue", "createdAt": "2020-08-29T00:22:50Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadata.java", "diffHunk": "@@ -61,18 +63,27 @@ public static TableMetadata newTableMetadata(TableOperations ops,\n                                                PartitionSpec spec,\n                                                String location,\n                                                Map<String, String> properties) {\n-    return newTableMetadata(schema, spec, location, properties, DEFAULT_TABLE_FORMAT_VERSION);\n+    return newTableMetadata(schema, spec, SortOrder.unsorted(), location, properties, DEFAULT_TABLE_FORMAT_VERSION);", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMwNTYwNA==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r481305604", "bodyText": "Created #1412.", "author": "aokolnychyi", "createdAt": "2020-09-01T17:15:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MjY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NzczOQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r479587739", "bodyText": "Minor: This variable doesn't seem necessary.", "author": "rdblue", "createdAt": "2020-08-29T01:01:28Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadataParser.java", "diffHunk": "@@ -277,6 +286,22 @@ static TableMetadata fromJson(FileIO io, InputFile file, JsonNode node) {\n           schema, TableMetadata.INITIAL_SPEC_ID, node.get(PARTITION_SPEC)));\n     }\n \n+    JsonNode sortOrderArray = node.get(SORT_ORDERS);\n+    List<SortOrder> sortOrders;\n+    int defaultSortOrderId;\n+    if (sortOrderArray != null) {\n+      defaultSortOrderId = JsonUtil.getInt(DEFAULT_SORT_ORDER_ID, node);\n+      ImmutableList.Builder<SortOrder> sortOrdersBuilder = ImmutableList.builder();\n+      for (JsonNode sortOrder : sortOrderArray) {\n+        sortOrdersBuilder.add(SortOrderParser.fromJson(schema, sortOrder));\n+      }\n+      sortOrders = sortOrdersBuilder.build();\n+    } else {\n+      SortOrder defaultSortOrder = SortOrder.unsorted();", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4NDY2Mw==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r483184663", "bodyText": "That var is used in two lines below, I think it is a bit easier to read if we preassign it.", "author": "aokolnychyi", "createdAt": "2020-09-03T18:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4NzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxOTY3MQ==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r482619671", "bodyText": "If the SortOrder list is required by v2, then I think that we should add a check here that the table is v1. That way, we fail to read a table and force recovery if a v2 table doesn't have an order list.\nWe should probably also update the PartitionSpec logic above to do the same thing.", "author": "rdblue", "createdAt": "2020-09-03T00:35:21Z", "path": "core/src/main/java/org/apache/iceberg/TableMetadataParser.java", "diffHunk": "@@ -277,6 +286,22 @@ static TableMetadata fromJson(FileIO io, InputFile file, JsonNode node) {\n           schema, TableMetadata.INITIAL_SPEC_ID, node.get(PARTITION_SPEC)));\n     }\n \n+    JsonNode sortOrderArray = node.get(SORT_ORDERS);\n+    List<SortOrder> sortOrders;\n+    int defaultSortOrderId;\n+    if (sortOrderArray != null) {\n+      defaultSortOrderId = JsonUtil.getInt(DEFAULT_SORT_ORDER_ID, node);\n+      ImmutableList.Builder<SortOrder> sortOrdersBuilder = ImmutableList.builder();\n+      for (JsonNode sortOrder : sortOrderArray) {\n+        sortOrdersBuilder.add(SortOrderParser.fromJson(schema, sortOrder));\n+      }\n+      sortOrders = sortOrdersBuilder.build();\n+    } else {\n+      SortOrder defaultSortOrder = SortOrder.unsorted();", "originalCommit": "de19ccbbc2146f78e355193bcb998029aedf4cd3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4NTczMg==", "url": "https://github.com/apache/iceberg/pull/1373#discussion_r483185732", "bodyText": "I tried that but we need to adapt tests. So, I've created #1419 to address this in a follow-up.", "author": "aokolnychyi", "createdAt": "2020-09-03T18:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjYxOTY3MQ=="}], "type": "inlineReview"}, {"oid": "4e0501c1a9b8496c8f89df8eb5d2c5cb326ceea7", "url": "https://github.com/apache/iceberg/commit/4e0501c1a9b8496c8f89df8eb5d2c5cb326ceea7", "message": "API: Implement SortOrder", "committedDate": "2020-09-03T18:38:41Z", "type": "forcePushed"}, {"oid": "edbddb2fe791d363f1bd3dd1431dc9855c71806b", "url": "https://github.com/apache/iceberg/commit/edbddb2fe791d363f1bd3dd1431dc9855c71806b", "message": "API: Implement SortOrder", "committedDate": "2020-09-03T18:41:08Z", "type": "commit"}, {"oid": "edbddb2fe791d363f1bd3dd1431dc9855c71806b", "url": "https://github.com/apache/iceberg/commit/edbddb2fe791d363f1bd3dd1431dc9855c71806b", "message": "API: Implement SortOrder", "committedDate": "2020-09-03T18:41:08Z", "type": "forcePushed"}, {"oid": "449dd238672e1c35b27c9d3d74d450d34b27e959", "url": "https://github.com/apache/iceberg/commit/449dd238672e1c35b27c9d3d74d450d34b27e959", "message": "Minor updates", "committedDate": "2020-09-04T05:10:24Z", "type": "commit"}]}