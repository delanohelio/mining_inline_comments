{"pr_number": 1216, "pr_title": "[Python] create table support", "pr_createdAt": "2020-07-19T18:18:33Z", "pr_url": "https://github.com/apache/iceberg/pull/1216", "timeline": [{"oid": "68bcd7287b4a52fb604508459da5b18495a07aaa", "url": "https://github.com/apache/iceberg/commit/68bcd7287b4a52fb604508459da5b18495a07aaa", "message": "Python: create table support\n\nFirst step in write support for python.\n\nAdds support & tests for create on:\n* `HiveTables`\n* `FilesystemTables`", "committedDate": "2020-07-21T16:56:24Z", "type": "forcePushed"}, {"oid": "8aff14ff2ecab4a94d721b4ffe70885b90fec329", "url": "https://github.com/apache/iceberg/commit/8aff14ff2ecab4a94d721b4ffe70885b90fec329", "message": "Python: create table support\n\nFirst step in write support for python.\n\nAdds support & tests for create on:\n* `HiveTables`\n* `FilesystemTables`", "committedDate": "2020-07-21T17:02:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzc3NA==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467337774", "bodyText": "In load, the number of items returned is checked. Should that be done here as well?", "author": "rdblue", "createdAt": "2020-08-08T00:34:28Z", "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -16,28 +16,51 @@\n # under the License.\n \n from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n+from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n from .base_table import BaseTable\n+from .table_metadata import TableMetadata\n \n \n class BaseMetastoreTables(Tables):\n+    DOT = '.'\n \n     def __init__(self, conf):\n         self.conf = conf\n \n     def new_table_ops(self, conf, database, table):\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, database, table):\n+    def load(self, table_identifier):\n+        parts = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+        if len(parts) > 1:\n+            database = parts[0]\n+            table = parts[1]\n+        else:\n+            database = \"default\"\n+            table = parts[0]\n         ops = self.new_table_ops(self.conf, database, table)\n         if ops.current() is None:\n             raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n \n         return BaseTable(ops, \"{}.{}\".format(database, table))\n \n-    def create(self, schema, spec, table_identifier=None, database=None, table=None):\n-        raise RuntimeError(\"Not Yet Implemented\")\n+    def create(self, schema, table_identifier=None, spec=None, properties=None):\n+        database, table = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)", "originalCommit": "8aff14ff2ecab4a94d721b4ffe70885b90fec329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwOTc3OA==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475209778", "bodyText": "yes, fixed", "author": "rymurr", "createdAt": "2020-08-23T11:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzk5NQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467337995", "bodyText": "I'm getting a warning about PEP 8 and limiting lines to 120 chars. Is that something we want to do in Python?\nSeems to make sense to me to limit lines to 120.", "author": "rdblue", "createdAt": "2020-08-08T00:35:46Z", "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -16,28 +16,51 @@\n # under the License.\n \n from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n+from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n from .base_table import BaseTable\n+from .table_metadata import TableMetadata\n \n \n class BaseMetastoreTables(Tables):\n+    DOT = '.'\n \n     def __init__(self, conf):\n         self.conf = conf\n \n     def new_table_ops(self, conf, database, table):\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, database, table):\n+    def load(self, table_identifier):\n+        parts = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+        if len(parts) > 1:\n+            database = parts[0]\n+            table = parts[1]\n+        else:\n+            database = \"default\"\n+            table = parts[0]\n         ops = self.new_table_ops(self.conf, database, table)\n         if ops.current() is None:\n             raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n \n         return BaseTable(ops, \"{}.{}\".format(database, table))\n \n-    def create(self, schema, spec, table_identifier=None, database=None, table=None):\n-        raise RuntimeError(\"Not Yet Implemented\")\n+    def create(self, schema, table_identifier=None, spec=None, properties=None):\n+        database, table = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+        ops = self.new_table_ops(self.conf, database, table)\n+        if ops.current() is not None:\n+            raise AlreadyExistsException(\"Table already exists: \" + table_identifier)\n+\n+        base_location = self.default_warehouse_location(self.conf, database, table)\n+\n+        metadata = TableMetadata.new_table_metadata(ops, schema, spec, base_location, dict() if properties is None else properties)", "originalCommit": "8aff14ff2ecab4a94d721b4ffe70885b90fec329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwOTgxMQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475209811", "bodyText": "yeah, its strange it wasn't caught by flake8. Fixed now", "author": "rymurr", "createdAt": "2020-08-23T11:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzNzk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODYwMQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467338601", "bodyText": "Minor: if we add types, the docs are better. For example, changing this to table_identifier: str made it so that documentation for str.rsplit is found, at least in PyCharm. We should probably start adding types where it makes sense, like in the base class Tables.\nNot something we need to do in this commit, but it really helps reviewing.", "author": "rdblue", "createdAt": "2020-08-08T00:40:22Z", "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -16,28 +16,51 @@\n # under the License.\n \n from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n+from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n from .base_table import BaseTable\n+from .table_metadata import TableMetadata\n \n \n class BaseMetastoreTables(Tables):\n+    DOT = '.'\n \n     def __init__(self, conf):\n         self.conf = conf\n \n     def new_table_ops(self, conf, database, table):\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, database, table):\n+    def load(self, table_identifier):", "originalCommit": "8aff14ff2ecab4a94d721b4ffe70885b90fec329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwOTE0Mw==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475209143", "bodyText": "I agree, I have added types in places where this PR has made changes. Hopefully we can build full type coverage over time rather than having someone slog through the code base and add them individually", "author": "rymurr", "createdAt": "2020-08-23T11:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODg4NQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467338885", "bodyText": "I agree with using table_identifier here. Should we also rename it in load since the location is the table identifier for FS tables?", "author": "rdblue", "createdAt": "2020-08-08T00:42:19Z", "path": "python/iceberg/core/filesystem/filesystem_tables.py", "diffHunk": "@@ -36,15 +35,15 @@ def load(self, location):\n \n         return BaseTable(ops, location)\n \n-    def create(self, schema, table_identifier=None, spec=None, properties=None, location=None):\n+    def create(self, schema, table_identifier=None, spec=None, properties=None):", "originalCommit": "8aff14ff2ecab4a94d721b4ffe70885b90fec329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIwODQ2Nw==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475208467", "bodyText": "agreed, fixed", "author": "rymurr", "createdAt": "2020-08-23T11:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzMzODg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjE4Mw==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467342183", "bodyText": "Couldn't this just be if self.current_metadata_location? I think both None and \"\" evaluate to False in python if statements.", "author": "rdblue", "createdAt": "2020-08-08T01:06:59Z", "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:", "originalCommit": "8aff14ff2ecab4a94d721b4ffe70885b90fec329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIxMzI3MA==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475213270", "bodyText": "correct, fixed", "author": "rymurr", "createdAt": "2020-08-23T12:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjQ0OQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467342449", "bodyText": "I think you can probably embed this method in unlock. I think the doUnlock method in Java is only there because of the use of Optional for a lock id.", "author": "rdblue", "createdAt": "2020-08-08T01:09:20Z", "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:\n+            parameters[BaseMetastoreTableOperations.PREVIOUS_METADATA_LOCATION_PROP] = self.current_metadata_location\n+\n+        tbl.parameters = parameters\n+\n+    def unlock(self, lock_id):\n+        if lock_id:\n+            try:\n+                self.do_unlock(LockResponse(lock_id))\n+            except Exception as e:\n+                logging.warning(\"Failed to unlock {}.{}\".format(self.database, self.table), e)\n+\n+    def do_unlock(self, lock_id):", "originalCommit": "8aff14ff2ecab4a94d721b4ffe70885b90fec329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIxMzM2NQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475213365", "bodyText": "yup, fixed", "author": "rymurr", "createdAt": "2020-08-23T12:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjgwNA==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467342804", "bodyText": "Nit: I think timedOut would be a better name?", "author": "rdblue", "createdAt": "2020-08-08T01:11:47Z", "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:\n+            parameters[BaseMetastoreTableOperations.PREVIOUS_METADATA_LOCATION_PROP] = self.current_metadata_location\n+\n+        tbl.parameters = parameters\n+\n+    def unlock(self, lock_id):\n+        if lock_id:\n+            try:\n+                self.do_unlock(LockResponse(lock_id))\n+            except Exception as e:\n+                logging.warning(\"Failed to unlock {}.{}\".format(self.database, self.table), e)\n+\n+    def do_unlock(self, lock_id):\n+        with self._client as open_client:\n+            open_client.unlock(lock_id)\n+\n+    def acquire_lock(self):\n+        lock_component = LockComponent(LockType.EXCLUSIVE, LockLevel.TABLE, self.database, self.table)\n+\n+        lock_request = LockRequest([lock_component], user=getpass.getuser(), hostname=socket.gethostname())\n+        with self._client as open_client:\n+            lock_response = open_client.lock(lock_request)\n+\n+        state = lock_response.state\n+        lock_id = lock_response.lockid\n+        start = int(time.time())\n+        duration = 0\n+        timeout = False", "originalCommit": "8aff14ff2ecab4a94d721b4ffe70885b90fec329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIxMzM3NQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475213375", "bodyText": "agreed, fixed", "author": "rymurr", "createdAt": "2020-08-23T12:27:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0MjgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0Mzk2Nw==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r467343967", "bodyText": "Since this is identical to the fall through case, can this be pass instead?", "author": "rdblue", "createdAt": "2020-08-08T01:21:43Z", "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -50,10 +63,146 @@ def refresh(self):\n         return self.current()\n \n     def commit(self, base, metadata):\n-        raise NotImplementedError()\n+        new_metadata_location = self.write_new_metadata(metadata, self.version + 1)\n+\n+        threw = True\n+        lock_id = None\n+        try:\n+            lock_id = self.acquire_lock()\n+            if base is not None:\n+                with self._client as open_client:\n+                    tbl = open_client.get_table(self.database, self.table)\n+            else:\n+                current_time_millis = int(time.time())\n+                tbl = Table(self.table,\n+                            self.database,\n+                            getpass.getuser(),\n+                            current_time_millis // 1000,\n+                            current_time_millis // 1000,\n+                            sd=storage_descriptor(metadata),\n+                            tableType=\"EXTERNAL_TABLE\",\n+                            parameters={'EXTERNAL': 'TRUE'})\n+\n+            tbl.sd = storage_descriptor(metadata)\n+            metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n+            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            if base_metadata_location != metadata_location:\n+                raise CommitFailedException(\n+                    \"Base metadata location '%s' is not same as the current table metadata location '%s' for %s.%s\",\n+                    base_metadata_location, metadata_location, self.database, self.table)\n+\n+            self.set_parameters(new_metadata_location, tbl)\n+\n+            if base is not None:\n+                with self._client as open_client:\n+                    env_context = EnvironmentContext(\n+                        {\"DO_NOT_UPDATE_STATS\": \"true\"}\n+                    )\n+                    open_client.alter_table(self.database, self.table, tbl, env_context)\n+\n+            else:\n+                with self._client as open_client:\n+                    open_client.create_table(tbl)\n+            threw = False\n+        except AlreadyExistsException:\n+            raise IcebergAlreadyExistsException(\"Table already exists: {}.{}\".format(self.database, self.table))\n+        except TException as e:\n+            if e is not None and \"Table/View 'HIVE_LOCKS' does not exist\" in str(e):\n+                raise Exception(\"\"\"Failed to acquire locks from metastore because 'HIVE_LOCKS' doesn't\n+                                exist, this probably happened when using embedded metastore or doesn't create a\n+                                transactional meta table. To fix this, use an alternative metastore\"\"\", e)\n+\n+            raise Exception(\"Metastore operation failed for {}.{}\".format(self.database, self.table), e)\n+        finally:\n+            if threw:\n+                self.io().delete(new_metadata_location)\n+            self.unlock(lock_id)\n+\n+    def set_parameters(self, new_metadata_location, tbl):\n+        parameters = tbl.parameters\n+\n+        if not parameters:\n+            parameters = dict()\n+\n+        parameters[BaseMetastoreTableOperations.TABLE_TYPE_PROP] = \\\n+            BaseMetastoreTableOperations.ICEBERG_TABLE_TYPE_VALUE.upper()\n+        parameters[BaseMetastoreTableOperations.METADATA_LOCATION_PROP] = new_metadata_location\n+\n+        if self.current_metadata_location is not None and len(self.current_metadata_location) > 0:\n+            parameters[BaseMetastoreTableOperations.PREVIOUS_METADATA_LOCATION_PROP] = self.current_metadata_location\n+\n+        tbl.parameters = parameters\n+\n+    def unlock(self, lock_id):\n+        if lock_id:\n+            try:\n+                self.do_unlock(LockResponse(lock_id))\n+            except Exception as e:\n+                logging.warning(\"Failed to unlock {}.{}\".format(self.database, self.table), e)\n+\n+    def do_unlock(self, lock_id):\n+        with self._client as open_client:\n+            open_client.unlock(lock_id)\n+\n+    def acquire_lock(self):\n+        lock_component = LockComponent(LockType.EXCLUSIVE, LockLevel.TABLE, self.database, self.table)\n+\n+        lock_request = LockRequest([lock_component], user=getpass.getuser(), hostname=socket.gethostname())\n+        with self._client as open_client:\n+            lock_response = open_client.lock(lock_request)\n+\n+        state = lock_response.state\n+        lock_id = lock_response.lockid\n+        start = int(time.time())\n+        duration = 0\n+        timeout = False\n+        while not timeout and state == LockState.WAITING:\n+            with self._client as open_client:\n+                lock_response = open_client.check_lock(lock_response)\n+            state = lock_response.state\n+\n+            duration = int(time.time()) - start\n+            if duration > 3 * 60 * 1000:\n+                timeout = True\n+            else:\n+                time.sleep(0.05)\n+\n+        if timeout and state != LockState.ACQUIRED:\n+            raise CommitFailedException(\"Timed out after {} ms waiting for lock on {}.{}\".format(duration,\n+                                                                                                 self.database,\n+                                                                                                 self.table))\n+\n+        if state != LockState.ACQUIRED:\n+            raise CommitFailedException(\n+                \"Could not acquire the lock on {}.{}, lock request ended in state {}\".format(self.database, self.table,\n+                                                                                             state))\n+        return lock_id\n \n     def io(self):\n-        raise NotImplementedError()\n+        return get_fs(self.base_location, self.conf)\n \n     def close(self):\n         self._client.close()\n+\n+\n+def storage_descriptor(metadata):\n+    ser_de_info = SerDeInfo(serializationLib=\"org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe\")\n+    return StorageDescriptor(columns(metadata.schema),\n+                             metadata.location,\n+                             \"org.apache.hadoop.mapred.FileInputFormat\",\n+                             \"org.apache.hadoop.mapred.FileOutputFormat\",\n+                             serdeInfo=ser_de_info)\n+\n+\n+def columns(schema):\n+    return [FieldSchema(col.name, convert_hive_type(col.type), \"\") for col in schema.columns()]\n+\n+\n+def convert_hive_type(col_type):\n+    try:\n+        type_id = col_type.type_id.value['hive_name']\n+        if type_id is not None:\n+            return type_id\n+    except:  # NOQA\n+        raise NotImplementedError(\"Not yet implemented column type \" + col_type)", "originalCommit": "8aff14ff2ecab4a94d721b4ffe70885b90fec329", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTIxMzQ2NA==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475213464", "bodyText": "agreed", "author": "rymurr", "createdAt": "2020-08-23T12:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzM0Mzk2Nw=="}], "type": "inlineReview"}, {"oid": "616187d6de0a8c4485b4cf31d19932ac80278200", "url": "https://github.com/apache/iceberg/commit/616187d6de0a8c4485b4cf31d19932ac80278200", "message": "address code review comments and rebase", "committedDate": "2020-08-23T13:26:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1NzkyMw==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475757923", "bodyText": "I'm not sure I understand this comment. Will a mock object evaluate to False in an if?", "author": "rdblue", "createdAt": "2020-08-24T16:55:17Z", "path": "python/iceberg/core/base_metastore_tables.py", "diffHunk": "@@ -14,46 +14,40 @@\n # KIND, either express or implied.  See the License for the\n # specific language governing permissions and limitations\n # under the License.\n+from typing import Tuple\n \n-from iceberg.api import Tables\n-from iceberg.exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n-\n+from . import TableOperations\n from .base_table import BaseTable\n from .table_metadata import TableMetadata\n+from ..api import PartitionSpec, Schema, Table, Tables\n+from ..exceptions import AlreadyExistsException, CommitFailedException, NoSuchTableException\n \n \n class BaseMetastoreTables(Tables):\n-    DOT = '.'\n \n-    def __init__(self, conf):\n+    def __init__(self: \"BaseMetastoreTables\", conf: dict) -> None:\n         self.conf = conf\n \n-    def new_table_ops(self, conf, database, table):\n+    def new_table_ops(self: \"BaseMetastoreTables\", conf: dict, database: str, table: str) -> \"TableOperations\":\n         raise RuntimeError(\"Abstract Implementation\")\n \n-    def load(self, table_identifier):\n-        parts = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n-        if len(parts) > 1:\n-            database = parts[0]\n-            table = parts[1]\n-        else:\n-            database = \"default\"\n-            table = parts[0]\n+    def load(self: \"BaseMetastoreTables\", table_identifier: str) -> Table:\n+        database, table = _parse_table_identifier(table_identifier)\n         ops = self.new_table_ops(self.conf, database, table)\n-        if ops.current() is None:\n-            raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n-\n-        return BaseTable(ops, \"{}.{}\".format(database, table))\n+        if ops.current():\n+            return BaseTable(ops, \"{}.{}\".format(database, table))\n+        raise NoSuchTableException(\"Table does not exist: {}.{}\".format(database, table))\n \n-    def create(self, schema, table_identifier=None, spec=None, properties=None):\n-        database, table = table_identifier.rsplit(BaseMetastoreTables.DOT, 1)\n+    def create(self: \"BaseMetastoreTables\", schema: Schema, table_identifier: str, spec: PartitionSpec = None,\n+               properties: dict = None) -> Table:\n+        database, table = _parse_table_identifier(table_identifier)\n         ops = self.new_table_ops(self.conf, database, table)\n-        if ops.current() is not None:\n+        if ops.current() is not None:  # not None check here to ensure MagicMocks aren't treated as None", "originalCommit": "616187d6de0a8c4485b4cf31d19932ac80278200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MDczMQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475780731", "bodyText": "just wasn't mocked correctly, fixed now and removed the is not None check", "author": "rymurr", "createdAt": "2020-08-24T17:31:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1NzkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTY3NQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475759675", "bodyText": "I think this does need to be the metadata file location and not the table location.", "author": "rdblue", "createdAt": "2020-08-24T16:57:58Z", "path": "python/iceberg/hive/hive_table_operations.py", "diffHunk": "@@ -85,20 +89,20 @@ def commit(self, base, metadata):\n \n             tbl.sd = storage_descriptor(metadata)\n             metadata_location = tbl.parameters.get(BaseMetastoreTableOperations.METADATA_LOCATION_PROP, None)\n-            base_metadata_location = base.metadataFileLocation() if base is not None else None\n+            base_metadata_location = base.location if base else None", "originalCommit": "616187d6de0a8c4485b4cf31d19932ac80278200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MzMxNg==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475783316", "bodyText": "metadataFileLocation is the Java name, location is the Python name. Same value though.", "author": "rymurr", "createdAt": "2020-08-24T17:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4NjIxNw==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475786217", "bodyText": "That seems confusing to me. How do you get the table's base location in Python?", "author": "rdblue", "createdAt": "2020-08-24T17:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc5ODIzOQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475798239", "bodyText": "ahh, i see now. It appears that the Java and Python impls are a bit out of sync. Python doesn't use file at all, which is where java takes its location from. Will look at figuring out what happened there and update the PR this eve or tomorrow", "author": "rymurr", "createdAt": "2020-08-24T18:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3NDYyOQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r476274629", "bodyText": "should be good to go now @rdblue, we had missed a property in TableMetadata in python", "author": "rymurr", "createdAt": "2020-08-25T08:33:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc1OTY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MDk5Mw==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475780993", "bodyText": "I don't really like the idea of exposing hive types through Iceberg types natively.  Seems like we should externalize this and have a separate hive<->iceberg type mapping utility class/function.", "author": "danielcweeks", "createdAt": "2020-08-24T17:31:38Z", "path": "python/iceberg/api/types/type.py", "diffHunk": "@@ -22,22 +22,22 @@\n \n @unique\n class TypeID(Enum):\n-    BOOLEAN = {\"java_class\": \"Boolean.class\", \"python_class\": bool, \"id\": 1}\n-    INTEGER = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 2}\n-    LONG = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 3}\n-    FLOAT = {\"java_class\": \"Float.class\", \"python_class\": float, \"id\": 4}\n-    DOUBLE = {\"java_class\": \"Double.class\", \"python_class\": float, \"id\": 5}\n-    DATE = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 6}\n-    TIME = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 7}\n-    TIMESTAMP = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 8}\n-    STRING = {\"java_class\": \"CharSequence.class\", \"python_class\": str, \"id\": 9}\n-    UUID = {\"java_class\": \"java.util.UUID.class\", \"python_class\": uuid.UUID, \"id\": 10}\n-    FIXED = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytes, \"id\": 11}\n-    BINARY = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytearray, \"id\": 12}\n-    DECIMAL = {\"java_class\": \"BigDecimal.class\", \"python_class\": Decimal, \"id\": 13}\n-    STRUCT = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 14}\n-    LIST = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 15}\n-    MAP = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 16}\n+    BOOLEAN = {\"java_class\": \"Boolean.class\", \"python_class\": bool, \"id\": 1, \"hive_name\": 'boolean'}\n+    INTEGER = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 2, \"hive_name\": 'int'}\n+    LONG = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 3, \"hive_name\": 'bigint'}\n+    FLOAT = {\"java_class\": \"Float.class\", \"python_class\": float, \"id\": 4, \"hive_name\": 'float'}\n+    DOUBLE = {\"java_class\": \"Double.class\", \"python_class\": float, \"id\": 5, \"hive_name\": 'double'}\n+    DATE = {\"java_class\": \"Integer.class\", \"python_class\": int, \"id\": 6, \"hive_name\": 'date'}\n+    TIME = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 7, \"hive_name\": 'string'}\n+    TIMESTAMP = {\"java_class\": \"Long.class\", \"python_class\": int, \"id\": 8, \"hive_name\": 'timestamp'}\n+    STRING = {\"java_class\": \"CharSequence.class\", \"python_class\": str, \"id\": 9, \"hive_name\": 'string'}\n+    UUID = {\"java_class\": \"java.util.UUID.class\", \"python_class\": uuid.UUID, \"id\": 10, \"hive_name\": 'string'}\n+    FIXED = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytes, \"id\": 11, \"hive_name\": 'binary'}\n+    BINARY = {\"java_class\": \"ByteBuffer.class\", \"python_class\": bytearray, \"id\": 12, \"hive_name\": \"binary\"}\n+    DECIMAL = {\"java_class\": \"BigDecimal.class\", \"python_class\": Decimal, \"id\": 13, \"hive_name\": None}\n+    STRUCT = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 14, \"hive_name\": None}\n+    LIST = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 15, \"hive_name\": None}\n+    MAP = {\"java_class\": \"Void.class\", \"python_class\": None, \"id\": 16, \"hive_name\": None}", "originalCommit": "616187d6de0a8c4485b4cf31d19932ac80278200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4OTczMg==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r475789732", "bodyText": "agreed. thats a good point. Thats fixed.", "author": "rymurr", "createdAt": "2020-08-24T17:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MDk5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3NDIyMw==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r476574223", "bodyText": "I don't see this hive_name property used anywhere. Did you mean to remove these changes from types?", "author": "rdblue", "createdAt": "2020-08-25T16:20:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc4MDk5Mw=="}], "type": "inlineReview"}, {"oid": "a2763c41df37edfca1cb578a1dc7b7106d3dd324", "url": "https://github.com/apache/iceberg/commit/a2763c41df37edfca1cb578a1dc7b7106d3dd324", "message": "Python: create table support\n\nFirst step in write support for python.\n\nAdds support & tests for create on:\n* `HiveTables`\n* `FilesystemTables`", "committedDate": "2020-08-25T08:30:32Z", "type": "commit"}, {"oid": "b8522eb1417ec472ca422ef3bce644f758b40701", "url": "https://github.com/apache/iceberg/commit/b8522eb1417ec472ca422ef3bce644f758b40701", "message": "address code review comments and rebase", "committedDate": "2020-08-25T08:30:33Z", "type": "commit"}, {"oid": "131508fcedd954d30ad9e047e50f12116e85f62b", "url": "https://github.com/apache/iceberg/commit/131508fcedd954d30ad9e047e50f12116e85f62b", "message": "address next round of comments", "committedDate": "2020-08-25T08:30:34Z", "type": "commit"}, {"oid": "5ed48377a3a324902c80f121b408f772df38bda4", "url": "https://github.com/apache/iceberg/commit/5ed48377a3a324902c80f121b408f772df38bda4", "message": "add metadatalocation property", "committedDate": "2020-08-25T08:30:35Z", "type": "commit"}, {"oid": "5ed48377a3a324902c80f121b408f772df38bda4", "url": "https://github.com/apache/iceberg/commit/5ed48377a3a324902c80f121b408f772df38bda4", "message": "add metadatalocation property", "committedDate": "2020-08-25T08:30:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjU3NDY2MA==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r476574660", "bodyText": "Should we check that location is None to ensure that a user doesn't pass both a table identifier (location) and a different location?", "author": "rdblue", "createdAt": "2020-08-25T16:21:06Z", "path": "python/iceberg/core/filesystem/filesystem_tables.py", "diffHunk": "@@ -15,39 +15,39 @@\n # specific language governing permissions and limitations\n # under the License.\n \n-\n-from iceberg.api import Tables\n-from iceberg.exceptions import NoSuchTableException\n-\n from .filesystem_table_operations import FilesystemTableOperations\n+from .. import TableOperations\n from ..table_metadata import TableMetadata\n+from ...api import PartitionSpec, Schema, Table, Tables\n+from ...exceptions import NoSuchTableException\n \n \n class FilesystemTables(Tables):\n \n-    def __init__(self, conf=None):\n+    def __init__(self: \"FilesystemTables\", conf: dict = None) -> None:\n         self.conf = conf if conf is not None else dict()\n \n-    def load(self, location):\n+    def load(self: \"FilesystemTables\", table_identifier: str) -> Table:\n         from ..base_table import BaseTable\n-        ops = self.new_table_ops(location)\n+        ops = self.new_table_ops(table_identifier)\n         if ops.current() is None:\n-            raise NoSuchTableException(\"Table does not exist at location: %s\" % location)\n+            raise NoSuchTableException(\"Table does not exist at location: %s\" % table_identifier)\n \n-        return BaseTable(ops, location)\n+        return BaseTable(ops, table_identifier)\n \n-    def create(self, schema, table_identifier=None, spec=None, properties=None, location=None):\n+    def create(self: \"FilesystemTables\", schema: Schema, table_identifier: str, spec: PartitionSpec = None,\n+               properties: dict = None, location: str = None) -> Table:", "originalCommit": "5ed48377a3a324902c80f121b408f772df38bda4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bd0ab77bceb6b3aaf1c891d46d735e788972c60c", "url": "https://github.com/apache/iceberg/commit/bd0ab77bceb6b3aaf1c891d46d735e788972c60c", "message": "forgot to remove hive types", "committedDate": "2020-08-25T17:17:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxOTIyMQ==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r476619221", "bodyText": "This doesn't agree with what is enforced. I like that location must always be None in the code so it would be good to state that here. It would also be easier to read since it avoids \"should be not None\".", "author": "rdblue", "createdAt": "2020-08-25T17:28:20Z", "path": "python/iceberg/core/filesystem/filesystem_tables.py", "diffHunk": "@@ -37,7 +37,19 @@ def load(self: \"FilesystemTables\", table_identifier: str) -> Table:\n \n     def create(self: \"FilesystemTables\", schema: Schema, table_identifier: str, spec: PartitionSpec = None,\n                properties: dict = None, location: str = None) -> Table:\n+        \"\"\"\n+        Create a new table on the filesystem.\n+\n+        Note: it is expected that the filesystem has atomic operations to ensure consistency for metadata updates.\n+        Filesystems that don't have this guarantee could lead to data loss.\n+\n+        Only table_identifier or location should be not None. Will throw an error if both are not None.", "originalCommit": "4c3dae0c3fe8b18139a6d5e6597fade0773f4983", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYyMjI2MA==", "url": "https://github.com/apache/iceberg/pull/1216#discussion_r476622260", "bodyText": "yup, apologies. Changed my mind halfway through impl. Fixed now", "author": "rymurr", "createdAt": "2020-08-25T17:33:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYxOTIyMQ=="}], "type": "inlineReview"}, {"oid": "135eeb3d8fdf324fa0ad7e17c603cac9b7deb01f", "url": "https://github.com/apache/iceberg/commit/135eeb3d8fdf324fa0ad7e17c603cac9b7deb01f", "message": "clean up filesystem `create` operation", "committedDate": "2020-08-25T17:33:01Z", "type": "commit"}, {"oid": "135eeb3d8fdf324fa0ad7e17c603cac9b7deb01f", "url": "https://github.com/apache/iceberg/commit/135eeb3d8fdf324fa0ad7e17c603cac9b7deb01f", "message": "clean up filesystem `create` operation", "committedDate": "2020-08-25T17:33:01Z", "type": "forcePushed"}, {"oid": "5067e586db1e523c91f8d74d35f97a998eced9b4", "url": "https://github.com/apache/iceberg/commit/5067e586db1e523c91f8d74d35f97a998eced9b4", "message": "fix linter", "committedDate": "2020-08-26T14:16:39Z", "type": "commit"}]}