{"pr_number": 974, "pr_title": "Add unit tests for sequence number", "pr_createdAt": "2020-04-27T13:22:19Z", "pr_url": "https://github.com/apache/iceberg/pull/974", "timeline": [{"oid": "3a49d627abc7608f46dba9d8df5363771dcc6173", "url": "https://github.com/apache/iceberg/commit/3a49d627abc7608f46dba9d8df5363771dcc6173", "message": "Always assign sequence number for adding manifest", "committedDate": "2020-04-27T13:23:37Z", "type": "forcePushed"}, {"oid": "04622f30627c009ec1829eef47f7f8d4c936736d", "url": "https://github.com/apache/iceberg/commit/04622f30627c009ec1829eef47f7f8d4c936736d", "message": "Use wrapper for adding entries from added manifests", "committedDate": "2020-05-06T09:37:54Z", "type": "forcePushed"}, {"oid": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "url": "https://github.com/apache/iceberg/commit/95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "message": "Use wrapper for adding entries from added manifests", "committedDate": "2020-05-06T09:43:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MjM1Nw==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424092357", "bodyText": "These assertions should be improved. Each assertion should have context, like \"Current sequence number should match\", and the length of all lists should be validated with an assertion to catch unexpected additions\nSince this pattern is repeated, I'd recommend a helper method like validateManfiest and validateManifestEntries for the manifest list. And the entries can be validated using a new variation of validateManifestEntries that includes sequence numbers.", "author": "rdblue", "createdAt": "2020-05-12T23:34:30Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwMzg5Ng==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424503896", "bodyText": "OK, I add two helper function, one is used to verify data files in one manifest , another is used to verify data files in the table.", "author": "chenjunjiedada", "createdAt": "2020-05-13T14:55:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MjM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MjY3Mg==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424092672", "bodyText": "There should be two cases for this test. One with a default merge setting (no merging) and one with the min merge count changed.", "author": "rdblue", "createdAt": "2020-05-12T23:35:29Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNDU4MQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424504581", "bodyText": "Done", "author": "chenjunjiedada", "createdAt": "2020-05-13T14:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MjY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5Mjg0MA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424092840", "bodyText": "As I noted above, I think it would be cleaner to add sequence number of a variant of validateManifestEntries.", "author": "rdblue", "createdAt": "2020-05-12T23:36:00Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyNjA0Mg==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424526042", "bodyText": "ok", "author": "chenjunjiedada", "createdAt": "2020-05-13T15:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5Mjg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MzQ4Ng==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424093486", "bodyText": "This relies on ordering in the manifest list. Can you avoid assumptions like this?", "author": "rdblue", "createdAt": "2020-05-12T23:37:56Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNTMxMg==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424505312", "bodyText": "Sure, will use snapshot id to filter.", "author": "chenjunjiedada", "createdAt": "2020-05-13T14:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MzQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MzY0Ng==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424093646", "bodyText": "This shouldn't use transactions. There is no need for it in a simple conflict test.", "author": "rdblue", "createdAt": "2020-05-12T23:38:32Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNTQzOA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424505438", "bodyText": "OK.", "author": "chenjunjiedada", "createdAt": "2020-05-13T14:57:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5MzY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NDU1NA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424094554", "bodyText": "I think there is some confusion about what this is doing. This IllegalStateException indicates that one of the operations in a transaction was not committed, not that there was a conflict committing to the table. If you want to validate a conflict, then you need to set the number of retries to 0 so that the CommitFailedException is thrown.\nMost tests that validate a conflict call apply on the first change, then call commit on the conflicting change, and then call commit on the first change. Retry allows the commit to succeed, but the result of the commit will be different. In this case, you'd have a higher sequence number.", "author": "rdblue", "createdAt": "2020-05-12T23:41:34Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyNjE4NA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424526184", "bodyText": "Updated.", "author": "chenjunjiedada", "createdAt": "2020-05-13T15:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NDU1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NDcyMg==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424094722", "bodyText": "This should use table, not load.", "author": "rdblue", "createdAt": "2020-05-12T23:42:09Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNTk1OA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424505958", "bodyText": "OK.", "author": "chenjunjiedada", "createdAt": "2020-05-13T14:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NDcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NTQwNA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424095404", "bodyText": "There is no need for a thread pool test here, as long as the single-threaded tests are written correctly. We are not trying to test conflict detection -- instead we want to test what happens when there is a conflict and we can simulate that with a specific order of calls.", "author": "rdblue", "createdAt": "2020-05-12T23:44:15Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile, table.io(),\n+        table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path())) {\n+        Assert.assertEquals(table.currentSnapshot().sequenceNumber(), entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testConcurrentCommit() throws InterruptedException {\n+    ExecutorService threadPool = Executors.newFixedThreadPool(4);", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNjEwOQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424506109", "bodyText": "OK.", "author": "chenjunjiedada", "createdAt": "2020-05-13T14:58:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NTQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NTYyNQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424095625", "bodyText": "This section is more like what I would expect for this test.", "author": "rdblue", "createdAt": "2020-05-12T23:44:58Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NjE1MQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424096151", "bodyText": "When values are predictable, like sequence numbers, we usually want to test that they are specific values, not that they match some other variable. It would be better to test that FILE_C has sequence number 3.\nThis also needs to validate that FILE_D was committed first and has sequence number 2.", "author": "rdblue", "createdAt": "2020-05-12T23:46:37Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile, table.io(),\n+        table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path())) {\n+        Assert.assertEquals(table.currentSnapshot().sequenceNumber(), entry.sequenceNumber().longValue());", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwNjMxNA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424506314", "bodyText": "OK", "author": "chenjunjiedada", "createdAt": "2020-05-13T14:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NjE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NzAxMQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424097011", "bodyText": "This also needs to test that the table metadata's last sequence number is still 2. One way to do that is to validate that the next sequence number assigned is 3.", "author": "rdblue", "createdAt": "2020-05-12T23:49:17Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile, table.io(),\n+        table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path())) {\n+        Assert.assertEquals(table.currentSnapshot().sequenceNumber(), entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testConcurrentCommit() throws InterruptedException {\n+    ExecutorService threadPool = Executors.newFixedThreadPool(4);\n+    List<Callable<Void>> tasks = new ArrayList<>();\n+\n+    Callable<Void> write1 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newFastAppend().appendFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write2 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newAppend().appendFile(FILE_B).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write3 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newDelete().deleteFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write4 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newOverwrite().addFile(FILE_D).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    tasks.add(write1);\n+    tasks.add(write2);\n+    tasks.add(write3);\n+    tasks.add(write4);\n+    threadPool.invokeAll(tasks);\n+    threadPool.shutdown();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyNTY3Mw==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424525673", "bodyText": "OK.", "author": "chenjunjiedada", "createdAt": "2020-05-13T15:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5NzAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODQxOA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424098418", "bodyText": "This doesn't really test much because all of the transactions do not conflict and only contain one operation. I think there should be a few test cases (separate methods):\n\nA transaction with 1 operation\nA transaction with 2 operations\nA transaction with an operation that doesn't change the sequence number (like expiration)\nA transaction with 1 operation that must retry due to conflict", "author": "rdblue", "createdAt": "2020-05-12T23:54:09Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile, table.io(),\n+        table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path())) {\n+        Assert.assertEquals(table.currentSnapshot().sequenceNumber(), entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testConcurrentCommit() throws InterruptedException {\n+    ExecutorService threadPool = Executors.newFixedThreadPool(4);\n+    List<Callable<Void>> tasks = new ArrayList<>();\n+\n+    Callable<Void> write1 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newFastAppend().appendFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write2 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newAppend().appendFile(FILE_B).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write3 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newDelete().deleteFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write4 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newOverwrite().addFile(FILE_D).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    tasks.add(write1);\n+    tasks.add(write2);\n+    tasks.add(write3);\n+    tasks.add(write4);\n+    threadPool.invokeAll(tasks);\n+    threadPool.shutdown();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testMultipleTxnOperations() {", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwOTY3OQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424509679", "bodyText": "Done.", "author": "chenjunjiedada", "createdAt": "2020-05-13T15:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODY0Ng==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424098646", "bodyText": "This should always save the current snapshot ID just after a commit and fetch that snapshot by ID instead of accessing the position in a list.", "author": "rdblue", "createdAt": "2020-05-12T23:54:58Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile, table.io(),\n+        table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path())) {\n+        Assert.assertEquals(table.currentSnapshot().sequenceNumber(), entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testConcurrentCommit() throws InterruptedException {\n+    ExecutorService threadPool = Executors.newFixedThreadPool(4);\n+    List<Callable<Void>> tasks = new ArrayList<>();\n+\n+    Callable<Void> write1 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newFastAppend().appendFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write2 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newAppend().appendFile(FILE_B).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write3 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newDelete().deleteFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write4 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newOverwrite().addFile(FILE_D).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    tasks.add(write1);\n+    tasks.add(write2);\n+    tasks.add(write3);\n+    tasks.add(write4);\n+    threadPool.invokeAll(tasks);\n+    threadPool.shutdown();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testMultipleTxnOperations() {\n+    Snapshot snapshot;\n+    Transaction txn = table.newTransaction();\n+    txn.newOverwrite().addFile(FILE_A).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    Set<DataFile> toAddFiles = new HashSet<>();\n+    Set<DataFile> toDeleteFiles = new HashSet<>();\n+    toAddFiles.add(FILE_B);\n+    toDeleteFiles.add(FILE_A);\n+    txn.newRewrite().rewriteFiles(toDeleteFiles, toAddFiles).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newReplacePartitions().addFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(3, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newDelete().deleteFile(FILE_C).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(5, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    snapshot = table.currentSnapshot();\n+    txn = table.newTransaction();\n+    txn.newOverwrite().addFile(FILE_D).deleteFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(6, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.expireSnapshots().expireOlderThan(snapshot.timestampMillis()).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(6, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForCherryPicking() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // WAP commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .set(\"wap.id\", \"123456789\")\n+        .stageOnly()\n+        .commit();\n+\n+    Assert.assertEquals(\"the snapshot sequence number should be 1\", 1,\n+        table.currentSnapshot().sequenceNumber());\n+\n+    // pick the snapshot that's staged but not committed\n+    Snapshot wapSnapshot = readMetadata().snapshots().get(1);", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyNzM3OA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424527378", "bodyText": "I think we can not use currentSnapshot() to get staged snapshot. Can we?", "author": "chenjunjiedada", "createdAt": "2020-05-13T15:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODc5MA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424098790", "bodyText": "What is the purpose of a WAP ID? The commit is staged, so there is no reason to mix in WAP logic.", "author": "rdblue", "createdAt": "2020-05-12T23:55:25Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile, table.io(),\n+        table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path())) {\n+        Assert.assertEquals(table.currentSnapshot().sequenceNumber(), entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testConcurrentCommit() throws InterruptedException {\n+    ExecutorService threadPool = Executors.newFixedThreadPool(4);\n+    List<Callable<Void>> tasks = new ArrayList<>();\n+\n+    Callable<Void> write1 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newFastAppend().appendFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write2 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newAppend().appendFile(FILE_B).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write3 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newDelete().deleteFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write4 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newOverwrite().addFile(FILE_D).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    tasks.add(write1);\n+    tasks.add(write2);\n+    tasks.add(write3);\n+    tasks.add(write4);\n+    threadPool.invokeAll(tasks);\n+    threadPool.shutdown();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testMultipleTxnOperations() {\n+    Snapshot snapshot;\n+    Transaction txn = table.newTransaction();\n+    txn.newOverwrite().addFile(FILE_A).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    Set<DataFile> toAddFiles = new HashSet<>();\n+    Set<DataFile> toDeleteFiles = new HashSet<>();\n+    toAddFiles.add(FILE_B);\n+    toDeleteFiles.add(FILE_A);\n+    txn.newRewrite().rewriteFiles(toDeleteFiles, toAddFiles).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newReplacePartitions().addFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(3, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newDelete().deleteFile(FILE_C).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(5, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    snapshot = table.currentSnapshot();\n+    txn = table.newTransaction();\n+    txn.newOverwrite().addFile(FILE_D).deleteFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(6, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.expireSnapshots().expireOlderThan(snapshot.timestampMillis()).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(6, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForCherryPicking() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // WAP commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .set(\"wap.id\", \"123456789\")", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUxMDIyOQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424510229", "bodyText": "Removed.", "author": "chenjunjiedada", "createdAt": "2020-05-13T15:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODkwMQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424098901", "bodyText": "No need for WAP, just use stagedSnapshot.", "author": "rdblue", "createdAt": "2020-05-12T23:55:50Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile, table.io(),\n+        table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path())) {\n+        Assert.assertEquals(table.currentSnapshot().sequenceNumber(), entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testConcurrentCommit() throws InterruptedException {\n+    ExecutorService threadPool = Executors.newFixedThreadPool(4);\n+    List<Callable<Void>> tasks = new ArrayList<>();\n+\n+    Callable<Void> write1 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newFastAppend().appendFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write2 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newAppend().appendFile(FILE_B).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write3 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newDelete().deleteFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write4 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newOverwrite().addFile(FILE_D).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    tasks.add(write1);\n+    tasks.add(write2);\n+    tasks.add(write3);\n+    tasks.add(write4);\n+    threadPool.invokeAll(tasks);\n+    threadPool.shutdown();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testMultipleTxnOperations() {\n+    Snapshot snapshot;\n+    Transaction txn = table.newTransaction();\n+    txn.newOverwrite().addFile(FILE_A).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    Set<DataFile> toAddFiles = new HashSet<>();\n+    Set<DataFile> toDeleteFiles = new HashSet<>();\n+    toAddFiles.add(FILE_B);\n+    toDeleteFiles.add(FILE_A);\n+    txn.newRewrite().rewriteFiles(toDeleteFiles, toAddFiles).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newReplacePartitions().addFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(3, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newDelete().deleteFile(FILE_C).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(5, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    snapshot = table.currentSnapshot();\n+    txn = table.newTransaction();\n+    txn.newOverwrite().addFile(FILE_D).deleteFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(6, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.expireSnapshots().expireOlderThan(snapshot.timestampMillis()).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(6, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForCherryPicking() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // WAP commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .set(\"wap.id\", \"123456789\")\n+        .stageOnly()\n+        .commit();\n+\n+    Assert.assertEquals(\"the snapshot sequence number should be 1\", 1,\n+        table.currentSnapshot().sequenceNumber());\n+\n+    // pick the snapshot that's staged but not committed\n+    Snapshot wapSnapshot = readMetadata().snapshots().get(1);\n+\n+    Assert.assertEquals(\"the snapshot sequence number should be 2\", 2,\n+        wapSnapshot.sequenceNumber());", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyNzQ2Ng==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424527466", "bodyText": "ok", "author": "chenjunjiedada", "createdAt": "2020-05-13T15:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5ODkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5OTE2NQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424099165", "bodyText": "In addition to cherry picking, it would be great to have a test case for fast-forward, which would not change the sequence number.", "author": "rdblue", "createdAt": "2020-05-12T23:56:50Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile, table.io(),\n+        table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path())) {\n+        Assert.assertEquals(table.currentSnapshot().sequenceNumber(), entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testConcurrentCommit() throws InterruptedException {\n+    ExecutorService threadPool = Executors.newFixedThreadPool(4);\n+    List<Callable<Void>> tasks = new ArrayList<>();\n+\n+    Callable<Void> write1 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newFastAppend().appendFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write2 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newAppend().appendFile(FILE_B).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write3 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newDelete().deleteFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write4 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newOverwrite().addFile(FILE_D).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    tasks.add(write1);\n+    tasks.add(write2);\n+    tasks.add(write3);\n+    tasks.add(write4);\n+    threadPool.invokeAll(tasks);\n+    threadPool.shutdown();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testMultipleTxnOperations() {\n+    Snapshot snapshot;\n+    Transaction txn = table.newTransaction();\n+    txn.newOverwrite().addFile(FILE_A).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    Set<DataFile> toAddFiles = new HashSet<>();\n+    Set<DataFile> toDeleteFiles = new HashSet<>();\n+    toAddFiles.add(FILE_B);\n+    toDeleteFiles.add(FILE_A);\n+    txn.newRewrite().rewriteFiles(toDeleteFiles, toAddFiles).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newReplacePartitions().addFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(3, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newDelete().deleteFile(FILE_C).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(5, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    snapshot = table.currentSnapshot();\n+    txn = table.newTransaction();\n+    txn.newOverwrite().addFile(FILE_D).deleteFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(6, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.expireSnapshots().expireOlderThan(snapshot.timestampMillis()).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(6, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForCherryPicking() {", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwOTg0NQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424509845", "bodyText": "Done", "author": "chenjunjiedada", "createdAt": "2020-05-13T15:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5OTE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5OTM0NA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424099344", "bodyText": "This should also assert that the picked files also have the new sequence number.", "author": "rdblue", "createdAt": "2020-05-12T23:57:29Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.stream.Collectors;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForFastAppend() throws IOException {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(1, manifestFile.sequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(2, manifestFile.sequenceNumber());\n+\n+    manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newFastAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    Assert.assertEquals(3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForMergeAppend() throws IOException {\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+    table.newAppend().appendFile(FILE_A).commit();\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    table.newAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile manifestFile = writeManifest(FILE_C, FILE_D);\n+    table.newAppend().appendManifest(manifestFile).commit();\n+    Assert.assertEquals(3, table.currentSnapshot().sequenceNumber());\n+\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\", 3, manifestFile.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 2\", 2, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_C.path()) || entry.file().path().equals(FILE_D.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 3\", 3, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"the sequence number of snapshot should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().get(0);\n+    Assert.assertEquals(\"the sequence number of manifest should be 3\",\n+        3, newManifest.sequenceNumber());\n+\n+    for (ManifestEntry entry : ManifestFiles.read(newManifest,\n+        table.io(), table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_A.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 1, entry.sequenceNumber().longValue());\n+      }\n+\n+      if (entry.file().path().equals(FILE_B.path())) {\n+        Assert.assertEquals(\"the sequence number of data file should be 1\", 2, entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    Transaction txn = table.newTransaction();\n+\n+    txn.newFastAppend().appendFile(FILE_A).apply();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    AssertHelpers.assertThrows(\"Should failed due to conflict\",\n+        IllegalStateException.class, \"last operation has not committed\", txn::commitTransaction);\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    for (ManifestEntry entry : ManifestFiles.read(manifestFile, table.io(),\n+        table.ops().current().specsById()).entries()) {\n+      if (entry.file().path().equals(FILE_C.path())) {\n+        Assert.assertEquals(table.currentSnapshot().sequenceNumber(), entry.sequenceNumber().longValue());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void testConcurrentCommit() throws InterruptedException {\n+    ExecutorService threadPool = Executors.newFixedThreadPool(4);\n+    List<Callable<Void>> tasks = new ArrayList<>();\n+\n+    Callable<Void> write1 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newFastAppend().appendFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write2 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newAppend().appendFile(FILE_B).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write3 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newDelete().deleteFile(FILE_A).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    Callable<Void> write4 = () -> {\n+      Transaction txn = table.newTransaction();\n+      txn.newOverwrite().addFile(FILE_D).commit();\n+      txn.commitTransaction();\n+      return null;\n+    };\n+\n+    tasks.add(write1);\n+    tasks.add(write2);\n+    tasks.add(write3);\n+    tasks.add(write4);\n+    threadPool.invokeAll(tasks);\n+    threadPool.shutdown();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testMultipleTxnOperations() {\n+    Snapshot snapshot;\n+    Transaction txn = table.newTransaction();\n+    txn.newOverwrite().addFile(FILE_A).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(1, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    Set<DataFile> toAddFiles = new HashSet<>();\n+    Set<DataFile> toDeleteFiles = new HashSet<>();\n+    toAddFiles.add(FILE_B);\n+    toDeleteFiles.add(FILE_A);\n+    txn.newRewrite().rewriteFiles(toDeleteFiles, toAddFiles).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(2, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newReplacePartitions().addFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(3, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newDelete().deleteFile(FILE_C).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(4, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(5, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    snapshot = table.currentSnapshot();\n+    txn = table.newTransaction();\n+    txn.newOverwrite().addFile(FILE_D).deleteFile(FILE_C).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(6, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+\n+    txn = table.newTransaction();\n+    txn.expireSnapshots().expireOlderThan(snapshot.timestampMillis()).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(6, TestTables.load(tableDir, \"test\").currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testSequenceNumberForCherryPicking() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    // WAP commit\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .set(\"wap.id\", \"123456789\")\n+        .stageOnly()\n+        .commit();\n+\n+    Assert.assertEquals(\"the snapshot sequence number should be 1\", 1,\n+        table.currentSnapshot().sequenceNumber());\n+\n+    // pick the snapshot that's staged but not committed\n+    Snapshot wapSnapshot = readMetadata().snapshots().get(1);\n+\n+    Assert.assertEquals(\"the snapshot sequence number should be 2\", 2,\n+        wapSnapshot.sequenceNumber());\n+\n+    // table has new commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    Assert.assertEquals(\"the snapshot sequence number should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    // cherry-pick snapshot\n+    table.manageSnapshots().cherrypick(wapSnapshot.snapshotId()).commit();\n+\n+    Assert.assertEquals(\"the snapshot sequence number should be 4\",\n+        4, table.currentSnapshot().sequenceNumber());", "originalCommit": "95cd1f02828a0dd2a9b27b244aecd91ff37d4460", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyNzU2Nw==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r424527567", "bodyText": "OK", "author": "chenjunjiedada", "createdAt": "2020-05-13T15:26:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5OTM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyNjgwMw==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430026803", "bodyText": "I think this still needs to be updated.", "author": "rdblue", "createdAt": "2020-05-25T17:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5OTM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEzNjkwMg==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430136902", "bodyText": "The picked file is validated in the next line. Do you mean that\uff1f\nvalidateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(1, 4, 3));", "author": "chenjunjiedada", "createdAt": "2020-05-26T03:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5OTM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2MTE4Mg==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430561182", "bodyText": "Yeah, sorry I missed that.", "author": "rdblue", "createdAt": "2020-05-26T16:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA5OTM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyNjU0NQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430026545", "bodyText": "The motivation for #1038 was to cover more cases for each action. Instead of having one test case for FastAppend, we should add the necessary assertions to all FastAppend tests. That keeps the tests in one place and increases coverage of situations that validate sequence numbers.\nCould you make sure that the cases that you're testing here are covered by assertions in the FastAppend tests so we don't need this case?\nIdeally, I'd prefer to add assertions to all of the operation tests instead of this suite, but for now I think it would be reasonable to just update the cases in FastAppend and add the rest of this suite. We can replace test cases here with assertions in the right test suites over a few more PRs.", "author": "rdblue", "createdAt": "2020-05-25T17:25:47Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testFastAppend() throws IOException {", "originalCommit": "983bbcd11f01c6d055d1270cfc20c4668d45c6de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDE0MTEwOA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430141108", "bodyText": "This case could be coved by testEmptyTableAppend and testEmptyTableAppendManifest. Let me remove this.\nThe idea to move these unit tests to each operation test respectively sounds reasonable to me.  I will try to create some following PRs to clean this.", "author": "chenjunjiedada", "createdAt": "2020-05-26T03:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDAyNjU0NQ=="}], "type": "inlineReview"}, {"oid": "97d3b3d349e13874b13b965c4643f9a81866875d", "url": "https://github.com/apache/iceberg/commit/97d3b3d349e13874b13b965c4643f9a81866875d", "message": "remove duplicate unit test", "committedDate": "2020-05-26T03:46:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NjAyOA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430566028", "bodyText": "These tests should use the validation methods from TableTestBase instead of adding its own. This method causes the test cases in this PR to be confusing because sometimes the sequence number is for a delete. Instead, the test cases need to be very specific about metadata.\nAll the metadata for every change should be validated:\n\nEach operation that produces a sequence number should assert the number of changed manifests\nEach changed manifest should have its entries validated, including file status, snapshot id, and sequence number\nEach operation should validate the lastSequenceNumber in table metadata\nOperations that do not produce a sequence number should validate that the sequence number did not change using the last sequence number in table metadata.", "author": "rdblue", "createdAt": "2020-05-26T16:57:05Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testMergeAppend() throws IOException {\n+    table.newAppend().appendFile(FILE_A).commit();\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 1, files(FILE_A), seqs(1));\n+    table.newAppend().appendFile(FILE_B).commit();\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 2, files(FILE_B), seqs(2));\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m0.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_C)))\n+        .commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(1, 2, 3));\n+\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m1.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_D)))\n+        .commit();\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    validateManifestEntries(manifestFile, 4, files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+  }\n+\n+  @Test\n+  public void testRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"Snapshot sequence number should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    validateManifestEntries(newManifest, 3, files(FILE_A, FILE_B), seqs(1, 2));\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    AppendFiles appendA = table.newFastAppend();\n+    appendA.appendFile(FILE_A).apply();\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"0\")\n+        .commit();\n+\n+    table.ops().failCommits(1);\n+\n+    AssertHelpers.assertThrows(\"Should reject commit\",\n+        CommitFailedException.class, \"Injected failure\",\n+        () -> table.newFastAppend().appendFile(FILE_B).commit());\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"5\")\n+        .commit();\n+\n+    appendA.commit();\n+\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_D, FILE_C), seqs(1, 2, 3));\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+\n+    Assert.assertEquals(\"Table last sequence number should be 2\",\n+        2, table.operations().current().lastSequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_C).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        3, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testSingleTransaction() {\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_A).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testConcurrentTransaction() {\n+    Transaction txn1 = table.newTransaction();\n+    Transaction txn2 = table.newTransaction();\n+    Transaction txn3 = table.newTransaction();\n+    Transaction txn4 = table.newTransaction();\n+\n+    txn1.newFastAppend().appendFile(FILE_A).commit();\n+    txn3.newOverwrite().addFile(FILE_C).commit();\n+    txn4.newDelete().deleteFile(FILE_A).commit();\n+    txn2.newAppend().appendFile(FILE_B).commit();\n+\n+    txn1.commitTransaction();\n+    txn2.commitTransaction();\n+    txn3.commitTransaction();\n+    txn4.commitTransaction();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        4, table.currentSnapshot().sequenceNumber());\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(4, 2, 3));\n+  }\n+\n+  @Test\n+  public void testMultipleOperationsTransaction() {\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_A).commit();\n+    Set<DataFile> toAddFiles = new HashSet<>();\n+    Set<DataFile> toDeleteFiles = new HashSet<>();\n+    toAddFiles.add(FILE_B);\n+    toDeleteFiles.add(FILE_A);\n+    txn.newRewrite().rewriteFiles(toDeleteFiles, toAddFiles).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+    validateDataFiles(files(FILE_A, FILE_B), seqs(2, 2));\n+  }\n+\n+  @Test\n+  public void testExpirationInTransaction() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+    table.newAppend().appendFile(FILE_B).commit();\n+\n+    Transaction txn = table.newTransaction();\n+    txn.expireSnapshots().expireSnapshotId(snapshotId).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+    validateDataFiles(files(FILE_B), seqs(2));\n+  }\n+\n+  @Test\n+  public void testTransactionFailure() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"0\")\n+        .commit();\n+\n+    table.ops().failCommits(1);\n+\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_C).commit();\n+\n+    AssertHelpers.assertThrows(\"Transaction commit should fail\",\n+        CommitFailedException.class, \"Injected failure\", txn::commitTransaction);\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testCherryPicking() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should be 1\", 1,\n+        table.currentSnapshot().sequenceNumber());\n+\n+    // pick the snapshot that's staged but not committed\n+    Snapshot stagedSnapshot = readMetadata().snapshots().get(1);\n+\n+    Assert.assertEquals(\"Snapshot sequence number should be 2\", 2,\n+        stagedSnapshot.sequenceNumber());\n+\n+    // table has new commit\n+    table.newAppend()\n+        .appendFile(FILE_C)\n+        .commit();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    // cherry-pick snapshot\n+    table.manageSnapshots().cherrypick(stagedSnapshot.snapshotId()).commit();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should be 4\",\n+        4, table.currentSnapshot().sequenceNumber());\n+\n+\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(1, 4, 3));\n+  }\n+\n+  @Test\n+  public void testCherryPickFastForward() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .commit();\n+\n+    table.newAppend()\n+        .appendFile(FILE_B)\n+        .stageOnly()\n+        .commit();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should be 1\", 1,\n+        table.currentSnapshot().sequenceNumber());\n+\n+    // pick the snapshot that's staged but not committed\n+    Snapshot stagedSnapshot = readMetadata().snapshots().get(1);\n+\n+    Assert.assertEquals(\"Snapshot sequence number should be 2\", 2,\n+        stagedSnapshot.sequenceNumber());\n+\n+    // cherry-pick snapshot, this will fast forward\n+    table.manageSnapshots().cherrypick(stagedSnapshot.snapshotId()).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should be 2\",\n+        2, table.currentSnapshot().sequenceNumber());\n+\n+    validateDataFiles(files(FILE_A, FILE_B), seqs(1, 2));\n+  }\n+\n+  void validateDataFiles(Iterator<DataFile> files, Iterator<Long> expectedSeqs) {", "originalCommit": "97d3b3d349e13874b13b965c4643f9a81866875d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxMzY4MA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r431213680", "bodyText": "OK, will update accordingly.", "author": "chenjunjiedada", "createdAt": "2020-05-27T15:06:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NjAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NjgwNQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430566805", "bodyText": "This assertion validates that the table's current snapshot didn't change, not that the table did not assign as sequence number to the failed transaction. This should check TableMetadata.lastSequenceNumber instead.", "author": "rdblue", "createdAt": "2020-05-26T16:58:18Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testMergeAppend() throws IOException {\n+    table.newAppend().appendFile(FILE_A).commit();\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 1, files(FILE_A), seqs(1));\n+    table.newAppend().appendFile(FILE_B).commit();\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 2, files(FILE_B), seqs(2));\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m0.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_C)))\n+        .commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(1, 2, 3));\n+\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m1.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_D)))\n+        .commit();\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    validateManifestEntries(manifestFile, 4, files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+  }\n+\n+  @Test\n+  public void testRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"Snapshot sequence number should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    validateManifestEntries(newManifest, 3, files(FILE_A, FILE_B), seqs(1, 2));\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    AppendFiles appendA = table.newFastAppend();\n+    appendA.appendFile(FILE_A).apply();\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"0\")\n+        .commit();\n+\n+    table.ops().failCommits(1);\n+\n+    AssertHelpers.assertThrows(\"Should reject commit\",\n+        CommitFailedException.class, \"Injected failure\",\n+        () -> table.newFastAppend().appendFile(FILE_B).commit());\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"5\")\n+        .commit();\n+\n+    appendA.commit();\n+\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_D, FILE_C), seqs(1, 2, 3));\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+\n+    Assert.assertEquals(\"Table last sequence number should be 2\",\n+        2, table.operations().current().lastSequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_C).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        3, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testSingleTransaction() {\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_A).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testConcurrentTransaction() {\n+    Transaction txn1 = table.newTransaction();\n+    Transaction txn2 = table.newTransaction();\n+    Transaction txn3 = table.newTransaction();\n+    Transaction txn4 = table.newTransaction();\n+\n+    txn1.newFastAppend().appendFile(FILE_A).commit();\n+    txn3.newOverwrite().addFile(FILE_C).commit();\n+    txn4.newDelete().deleteFile(FILE_A).commit();\n+    txn2.newAppend().appendFile(FILE_B).commit();\n+\n+    txn1.commitTransaction();\n+    txn2.commitTransaction();\n+    txn3.commitTransaction();\n+    txn4.commitTransaction();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        4, table.currentSnapshot().sequenceNumber());\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(4, 2, 3));\n+  }\n+\n+  @Test\n+  public void testMultipleOperationsTransaction() {\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_A).commit();\n+    Set<DataFile> toAddFiles = new HashSet<>();\n+    Set<DataFile> toDeleteFiles = new HashSet<>();\n+    toAddFiles.add(FILE_B);\n+    toDeleteFiles.add(FILE_A);\n+    txn.newRewrite().rewriteFiles(toDeleteFiles, toAddFiles).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+    validateDataFiles(files(FILE_A, FILE_B), seqs(2, 2));\n+  }\n+\n+  @Test\n+  public void testExpirationInTransaction() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+    table.newAppend().appendFile(FILE_B).commit();\n+\n+    Transaction txn = table.newTransaction();\n+    txn.expireSnapshots().expireSnapshotId(snapshotId).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+    validateDataFiles(files(FILE_B), seqs(2));\n+  }\n+\n+  @Test\n+  public void testTransactionFailure() {\n+    table.newAppend()\n+        .appendFile(FILE_A)\n+        .appendFile(FILE_B)\n+        .commit();\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"0\")\n+        .commit();\n+\n+    table.ops().failCommits(1);\n+\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_C).commit();\n+\n+    AssertHelpers.assertThrows(\"Transaction commit should fail\",\n+        CommitFailedException.class, \"Injected failure\", txn::commitTransaction);\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());", "originalCommit": "97d3b3d349e13874b13b965c4643f9a81866875d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxMjQyMA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r431212420", "bodyText": "OK.", "author": "chenjunjiedada", "createdAt": "2020-05-27T15:04:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2NjgwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2ODA1Mw==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430568053", "bodyText": "The sequence number of FILE_A needs to be validated, along with the rest of the metadata for this commit. Transactions will still produce a snapshot for every operation, it will just swap the existing state for the final state.", "author": "rdblue", "createdAt": "2020-05-26T17:00:09Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testMergeAppend() throws IOException {\n+    table.newAppend().appendFile(FILE_A).commit();\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 1, files(FILE_A), seqs(1));\n+    table.newAppend().appendFile(FILE_B).commit();\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 2, files(FILE_B), seqs(2));\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m0.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_C)))\n+        .commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(1, 2, 3));\n+\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m1.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_D)))\n+        .commit();\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    validateManifestEntries(manifestFile, 4, files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+  }\n+\n+  @Test\n+  public void testRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"Snapshot sequence number should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    validateManifestEntries(newManifest, 3, files(FILE_A, FILE_B), seqs(1, 2));\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    AppendFiles appendA = table.newFastAppend();\n+    appendA.appendFile(FILE_A).apply();\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"0\")\n+        .commit();\n+\n+    table.ops().failCommits(1);\n+\n+    AssertHelpers.assertThrows(\"Should reject commit\",\n+        CommitFailedException.class, \"Injected failure\",\n+        () -> table.newFastAppend().appendFile(FILE_B).commit());\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"5\")\n+        .commit();\n+\n+    appendA.commit();\n+\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_D, FILE_C), seqs(1, 2, 3));\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+\n+    Assert.assertEquals(\"Table last sequence number should be 2\",\n+        2, table.operations().current().lastSequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_C).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        3, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testSingleTransaction() {\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_A).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testConcurrentTransaction() {\n+    Transaction txn1 = table.newTransaction();\n+    Transaction txn2 = table.newTransaction();\n+    Transaction txn3 = table.newTransaction();\n+    Transaction txn4 = table.newTransaction();\n+\n+    txn1.newFastAppend().appendFile(FILE_A).commit();\n+    txn3.newOverwrite().addFile(FILE_C).commit();\n+    txn4.newDelete().deleteFile(FILE_A).commit();\n+    txn2.newAppend().appendFile(FILE_B).commit();\n+\n+    txn1.commitTransaction();\n+    txn2.commitTransaction();\n+    txn3.commitTransaction();\n+    txn4.commitTransaction();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        4, table.currentSnapshot().sequenceNumber());\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(4, 2, 3));\n+  }\n+\n+  @Test\n+  public void testMultipleOperationsTransaction() {\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_A).commit();", "originalCommit": "97d3b3d349e13874b13b965c4643f9a81866875d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2ODQxNA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430568414", "bodyText": "This needs to validate the table's last sequence number.", "author": "rdblue", "createdAt": "2020-05-26T17:00:42Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testMergeAppend() throws IOException {\n+    table.newAppend().appendFile(FILE_A).commit();\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 1, files(FILE_A), seqs(1));\n+    table.newAppend().appendFile(FILE_B).commit();\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 2, files(FILE_B), seqs(2));\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m0.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_C)))\n+        .commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(1, 2, 3));\n+\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m1.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_D)))\n+        .commit();\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    validateManifestEntries(manifestFile, 4, files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+  }\n+\n+  @Test\n+  public void testRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"Snapshot sequence number should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    validateManifestEntries(newManifest, 3, files(FILE_A, FILE_B), seqs(1, 2));\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    AppendFiles appendA = table.newFastAppend();\n+    appendA.appendFile(FILE_A).apply();\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"0\")\n+        .commit();\n+\n+    table.ops().failCommits(1);\n+\n+    AssertHelpers.assertThrows(\"Should reject commit\",\n+        CommitFailedException.class, \"Injected failure\",\n+        () -> table.newFastAppend().appendFile(FILE_B).commit());\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"5\")\n+        .commit();\n+\n+    appendA.commit();\n+\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_D, FILE_C), seqs(1, 2, 3));\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+\n+    Assert.assertEquals(\"Table last sequence number should be 2\",\n+        2, table.operations().current().lastSequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_C).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        3, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testSingleTransaction() {\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_A).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testConcurrentTransaction() {\n+    Transaction txn1 = table.newTransaction();\n+    Transaction txn2 = table.newTransaction();\n+    Transaction txn3 = table.newTransaction();\n+    Transaction txn4 = table.newTransaction();\n+\n+    txn1.newFastAppend().appendFile(FILE_A).commit();\n+    txn3.newOverwrite().addFile(FILE_C).commit();\n+    txn4.newDelete().deleteFile(FILE_A).commit();\n+    txn2.newAppend().appendFile(FILE_B).commit();\n+\n+    txn1.commitTransaction();\n+    txn2.commitTransaction();\n+    txn3.commitTransaction();\n+    txn4.commitTransaction();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        4, table.currentSnapshot().sequenceNumber());\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(4, 2, 3));\n+  }\n+\n+  @Test\n+  public void testMultipleOperationsTransaction() {\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_A).commit();\n+    Set<DataFile> toAddFiles = new HashSet<>();\n+    Set<DataFile> toDeleteFiles = new HashSet<>();\n+    toAddFiles.add(FILE_B);\n+    toDeleteFiles.add(FILE_A);\n+    txn.newRewrite().rewriteFiles(toDeleteFiles, toAddFiles).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+    validateDataFiles(files(FILE_A, FILE_B), seqs(2, 2));\n+  }\n+\n+  @Test\n+  public void testExpirationInTransaction() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+    table.newAppend().appendFile(FILE_B).commit();\n+\n+    Transaction txn = table.newTransaction();\n+    txn.expireSnapshots().expireSnapshotId(snapshotId).commit();\n+    txn.commitTransaction();\n+\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());", "originalCommit": "97d3b3d349e13874b13b965c4643f9a81866875d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxMjE3Nw==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r431212177", "bodyText": "OK.", "author": "chenjunjiedada", "createdAt": "2020-05-27T15:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2ODQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2OTAzNA==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430569034", "bodyText": "The table state resulting from each transaction needs to be validated, not just the final state.", "author": "rdblue", "createdAt": "2020-05-26T17:01:54Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testMergeAppend() throws IOException {\n+    table.newAppend().appendFile(FILE_A).commit();\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 1, files(FILE_A), seqs(1));\n+    table.newAppend().appendFile(FILE_B).commit();\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 2, files(FILE_B), seqs(2));\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m0.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_C)))\n+        .commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(1, 2, 3));\n+\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m1.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_D)))\n+        .commit();\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    validateManifestEntries(manifestFile, 4, files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+  }\n+\n+  @Test\n+  public void testRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"Snapshot sequence number should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    validateManifestEntries(newManifest, 3, files(FILE_A, FILE_B), seqs(1, 2));\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    AppendFiles appendA = table.newFastAppend();\n+    appendA.appendFile(FILE_A).apply();\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"0\")\n+        .commit();\n+\n+    table.ops().failCommits(1);\n+\n+    AssertHelpers.assertThrows(\"Should reject commit\",\n+        CommitFailedException.class, \"Injected failure\",\n+        () -> table.newFastAppend().appendFile(FILE_B).commit());\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"5\")\n+        .commit();\n+\n+    appendA.commit();\n+\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_D, FILE_C), seqs(1, 2, 3));\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+\n+    Assert.assertEquals(\"Table last sequence number should be 2\",\n+        2, table.operations().current().lastSequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_C).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        3, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testSingleTransaction() {\n+    Transaction txn = table.newTransaction();\n+    txn.newAppend().appendFile(FILE_A).commit();\n+    txn.commitTransaction();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+  }\n+\n+  @Test\n+  public void testConcurrentTransaction() {\n+    Transaction txn1 = table.newTransaction();\n+    Transaction txn2 = table.newTransaction();\n+    Transaction txn3 = table.newTransaction();\n+    Transaction txn4 = table.newTransaction();\n+\n+    txn1.newFastAppend().appendFile(FILE_A).commit();\n+    txn3.newOverwrite().addFile(FILE_C).commit();\n+    txn4.newDelete().deleteFile(FILE_A).commit();\n+    txn2.newAppend().appendFile(FILE_B).commit();\n+\n+    txn1.commitTransaction();\n+    txn2.commitTransaction();\n+    txn3.commitTransaction();\n+    txn4.commitTransaction();", "originalCommit": "97d3b3d349e13874b13b965c4643f9a81866875d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTIxMjI0OQ==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r431212249", "bodyText": "OK.", "author": "chenjunjiedada", "createdAt": "2020-05-27T15:04:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2OTAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU2OTYzMg==", "url": "https://github.com/apache/iceberg/pull/974#discussion_r430569632", "bodyText": "Overall, this is a good test. But you do need to add validations for the rest of the metadata.", "author": "rdblue", "createdAt": "2020-05-26T17:03:00Z", "path": "core/src/test/java/org/apache/iceberg/TestSequenceNumberForV2Table.java", "diffHunk": "@@ -0,0 +1,328 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.iceberg.exceptions.CommitFailedException;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class TestSequenceNumberForV2Table extends TableTestBase {\n+\n+  public TestSequenceNumberForV2Table() {\n+    super(2);\n+  }\n+\n+  @Test\n+  public void testMergeAppend() throws IOException {\n+    table.newAppend().appendFile(FILE_A).commit();\n+    ManifestFile manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 1, files(FILE_A), seqs(1));\n+    table.newAppend().appendFile(FILE_B).commit();\n+    manifestFile = table.currentSnapshot().manifests().get(0);\n+    validateManifestEntries(manifestFile, 2, files(FILE_B), seqs(2));\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m0.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_C)))\n+        .commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C), seqs(1, 2, 3));\n+\n+    table.updateProperties()\n+        .set(TableProperties.MANIFEST_MIN_MERGE_COUNT, \"1\")\n+        .commit();\n+\n+    table.newAppend()\n+        .appendManifest(writeManifest(\"input-m1.avro\",\n+            manifestEntry(ManifestEntry.Status.ADDED, null, FILE_D)))\n+        .commit();\n+\n+    manifestFile = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+    validateManifestEntries(manifestFile, 4, files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+    validateDataFiles(files(FILE_A, FILE_B, FILE_C, FILE_D), seqs(1, 2, 3, 4));\n+  }\n+\n+  @Test\n+  public void testRewrite() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(2, table.currentSnapshot().sequenceNumber());\n+\n+    table.rewriteManifests().clusterBy(file -> \"\").commit();\n+    Assert.assertEquals(\"Snapshot sequence number should be 3\",\n+        3, table.currentSnapshot().sequenceNumber());\n+\n+    ManifestFile newManifest = table.currentSnapshot().manifests().stream()\n+        .filter(manifest -> manifest.snapshotId() == table.currentSnapshot().snapshotId())\n+        .collect(Collectors.toList()).get(0);\n+\n+    validateManifestEntries(newManifest, 3, files(FILE_A, FILE_B), seqs(1, 2));\n+  }\n+\n+  @Test\n+  public void testCommitConflict() {\n+    AppendFiles appendA = table.newFastAppend();\n+    appendA.appendFile(FILE_A).apply();\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"0\")\n+        .commit();\n+\n+    table.ops().failCommits(1);\n+\n+    AssertHelpers.assertThrows(\"Should reject commit\",\n+        CommitFailedException.class, \"Injected failure\",\n+        () -> table.newFastAppend().appendFile(FILE_B).commit());\n+\n+    table.updateProperties()\n+        .set(TableProperties.COMMIT_NUM_RETRIES, \"5\")\n+        .commit();\n+\n+    appendA.commit();\n+\n+    Assert.assertEquals(1, table.currentSnapshot().sequenceNumber());\n+\n+    AppendFiles appendFiles = table.newFastAppend().appendFile(FILE_C);\n+    appendFiles.apply();\n+    table.newFastAppend().appendFile(FILE_D).commit();\n+    appendFiles.commit();\n+\n+    validateDataFiles(files(FILE_A, FILE_D, FILE_C), seqs(1, 2, 3));\n+  }\n+\n+  @Test\n+  public void testRollBack() {\n+    table.newFastAppend().appendFile(FILE_A).commit();\n+    long snapshotId = table.currentSnapshot().snapshotId();\n+\n+    table.newFastAppend().appendFile(FILE_B).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        2, table.currentSnapshot().sequenceNumber());\n+\n+    table.manageSnapshots().rollbackTo(snapshotId).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        1, table.currentSnapshot().sequenceNumber());\n+\n+    Assert.assertEquals(\"Table last sequence number should be 2\",\n+        2, table.operations().current().lastSequenceNumber());\n+\n+    table.newFastAppend().appendFile(FILE_C).commit();\n+    Assert.assertEquals(\"Snapshot sequence number should match expected\",\n+        3, table.currentSnapshot().sequenceNumber());", "originalCommit": "97d3b3d349e13874b13b965c4643f9a81866875d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "10c8c8c3a31b5b6aca169b778597dff1c028a3e0", "url": "https://github.com/apache/iceberg/commit/10c8c8c3a31b5b6aca169b778597dff1c028a3e0", "message": "Always assign sequence number for adding manifest", "committedDate": "2020-06-01T03:06:39Z", "type": "commit"}, {"oid": "760157be43d591bd8c0f2977d77d5b1329317c08", "url": "https://github.com/apache/iceberg/commit/760157be43d591bd8c0f2977d77d5b1329317c08", "message": "revert changes for adding sequence number", "committedDate": "2020-06-01T03:06:39Z", "type": "commit"}, {"oid": "3f6fae3fc53baee44f6dab9dd5ea3387b793ae5d", "url": "https://github.com/apache/iceberg/commit/3f6fae3fc53baee44f6dab9dd5ea3387b793ae5d", "message": "Use wrapper for adding entries from added manifests", "committedDate": "2020-06-01T03:11:46Z", "type": "commit"}, {"oid": "20d55def5b4c79d8765b8562e184ec8afb902f31", "url": "https://github.com/apache/iceberg/commit/20d55def5b4c79d8765b8562e184ec8afb902f31", "message": "address comments", "committedDate": "2020-06-01T03:11:46Z", "type": "commit"}, {"oid": "ba27dd22bff27e3841cb46701c3113425a422f87", "url": "https://github.com/apache/iceberg/commit/ba27dd22bff27e3841cb46701c3113425a422f87", "message": "fix unit test", "committedDate": "2020-06-01T03:11:47Z", "type": "commit"}, {"oid": "9d848c423b707e3687af2a96c60d2d0c93441348", "url": "https://github.com/apache/iceberg/commit/9d848c423b707e3687af2a96c60d2d0c93441348", "message": "remove duplicate unit test", "committedDate": "2020-06-01T03:11:47Z", "type": "commit"}, {"oid": "17101489d445ba8688b8a69f5530f225c06f8d1b", "url": "https://github.com/apache/iceberg/commit/17101489d445ba8688b8a69f5530f225c06f8d1b", "message": "address comments", "committedDate": "2020-06-01T03:11:47Z", "type": "commit"}, {"oid": "798d95d51ac985b029e3c43cd889d13b4fa61bcd", "url": "https://github.com/apache/iceberg/commit/798d95d51ac985b029e3c43cd889d13b4fa61bcd", "message": "rebase to master", "committedDate": "2020-06-01T03:41:48Z", "type": "commit"}, {"oid": "798d95d51ac985b029e3c43cd889d13b4fa61bcd", "url": "https://github.com/apache/iceberg/commit/798d95d51ac985b029e3c43cd889d13b4fa61bcd", "message": "rebase to master", "committedDate": "2020-06-01T03:41:48Z", "type": "forcePushed"}]}