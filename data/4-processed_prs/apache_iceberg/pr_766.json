{"pr_number": 766, "pr_title": "Support in and notIn in ResidualVisitor", "pr_createdAt": "2020-02-02T00:16:23Z", "pr_url": "https://github.com/apache/iceberg/pull/766", "timeline": [{"oid": "6a66dcdad8b38d28c7cc23c02eaf3e37df47e013", "url": "https://github.com/apache/iceberg/commit/6a66dcdad8b38d28c7cc23c02eaf3e37df47e013", "message": "Support in and notIn in ResidualVisitor", "committedDate": "2020-02-02T00:15:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg3OTAzNg==", "url": "https://github.com/apache/iceberg/pull/766#discussion_r373879036", "bodyText": "The literal set can handle all types, so this can use contains instead of checking each value individually.", "author": "rdblue", "createdAt": "2020-02-02T22:04:16Z", "path": "api/src/main/java/org/apache/iceberg/expressions/ResidualEvaluator.java", "diffHunk": "@@ -195,6 +196,26 @@ public Expression or(Expression leftResult, Expression rightResult) {\n       return (cmp.compare(ref.eval(struct), lit.value()) != 0) ? alwaysTrue() : alwaysFalse();\n     }\n \n+    @Override\n+    public <T> Expression in(BoundReference<T> ref, Set<T> literalSet) {\n+      T val = ref.eval(struct);\n+      if (literalSet.stream().anyMatch(lit -> ref.comparator().compare(val, lit) == 0)) {", "originalCommit": "6a66dcdad8b38d28c7cc23c02eaf3e37df47e013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg3OTI4Mg==", "url": "https://github.com/apache/iceberg/pull/766#discussion_r373879282", "bodyText": "Can you also add cases to testUnpartitionedResiduals?", "author": "rdblue", "createdAt": "2020-02-02T22:07:50Z", "path": "api/src/test/java/org/apache/iceberg/transforms/TestResiduals.java", "diffHunk": "@@ -156,4 +158,46 @@ public void testUnpartitionedResiduals() {\n           expr, residualEvaluator.residualFor(Row.of()));\n     }\n   }\n+\n+  @Test", "originalCommit": "6a66dcdad8b38d28c7cc23c02eaf3e37df47e013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg3OTczMw==", "url": "https://github.com/apache/iceberg/pull/766#discussion_r373879733", "bodyText": "Can you also add tests for in and notIn with a timestamp (ts column) to date transform (day)?\nFor the in case, the residual for a date that contains one of the timestamps should be the original in predicate. If the date doesn't match one of the in predicate timestamp values, then it should be alwaysFalse. For notIn, if the date matches it should be the original notIn predicate and if it does not match, it should be alwaysTrue.", "author": "rdblue", "createdAt": "2020-02-02T22:14:30Z", "path": "api/src/test/java/org/apache/iceberg/transforms/TestResiduals.java", "diffHunk": "@@ -156,4 +158,46 @@ public void testUnpartitionedResiduals() {\n           expr, residualEvaluator.residualFor(Row.of()));\n     }\n   }\n+\n+  @Test\n+  public void testIn() {\n+    Schema schema = new Schema(\n+        Types.NestedField.optional(50, \"dateint\", Types.IntegerType.get()),\n+        Types.NestedField.optional(51, \"hour\", Types.IntegerType.get())\n+    );\n+\n+    PartitionSpec spec = PartitionSpec.builderFor(schema)\n+        .identity(\"dateint\")\n+        .build();\n+\n+    ResidualEvaluator resEval = ResidualEvaluator.of(spec,\n+        in(\"dateint\", 20170815, 20170816, 20170817), true);\n+\n+    Expression residual = resEval.residualFor(Row.of(20170815));\n+    Assert.assertEquals(\"Residual should be alwaysTrue\", alwaysTrue(), residual);\n+\n+    residual = resEval.residualFor(Row.of(20180815));\n+    Assert.assertEquals(\"Residual should be alwaysFalse\", alwaysFalse(), residual);\n+  }\n+\n+  @Test\n+  public void testNotIn() {", "originalCommit": "6a66dcdad8b38d28c7cc23c02eaf3e37df47e013", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e586ad404bf298c2779f90015aa3e250be8f1c17", "url": "https://github.com/apache/iceberg/commit/e586ad404bf298c2779f90015aa3e250be8f1c17", "message": "address the comments and add additional unit tests", "committedDate": "2020-02-05T06:26:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ2MjgwMQ==", "url": "https://github.com/apache/iceberg/pull/766#discussion_r375462801", "bodyText": "Nit: This doesn't require a newline.", "author": "rdblue", "createdAt": "2020-02-05T19:31:02Z", "path": "api/src/test/java/org/apache/iceberg/transforms/TestResiduals.java", "diffHunk": "@@ -156,4 +162,106 @@ public void testUnpartitionedResiduals() {\n           expr, residualEvaluator.residualFor(Row.of()));\n     }\n   }\n+\n+  @Test\n+  public void testIn() {\n+    Schema schema = new Schema(\n+        Types.NestedField.optional(50, \"dateint\", Types.IntegerType.get()),\n+        Types.NestedField.optional(51, \"hour\", Types.IntegerType.get())\n+    );\n+\n+    PartitionSpec spec = PartitionSpec.builderFor(schema)\n+        .identity(\"dateint\")\n+        .build();\n+\n+    ResidualEvaluator resEval = ResidualEvaluator.of(spec,\n+        in(\"dateint\", 20170815, 20170816, 20170817), true);\n+\n+    Expression residual = resEval.residualFor(Row.of(20170815));\n+    Assert.assertEquals(\"Residual should be alwaysTrue\", alwaysTrue(), residual);\n+\n+    residual = resEval.residualFor(Row.of(20180815));\n+    Assert.assertEquals(\"Residual should be alwaysFalse\", alwaysFalse(), residual);\n+  }\n+\n+  @Test\n+  public void testInTimestamp() {\n+    Schema schema = new Schema(\n+        Types.NestedField.optional(50, \"ts\", Types.TimestampType.withoutZone()),\n+        Types.NestedField.optional(51, \"dateint\", Types.IntegerType.get())\n+    );\n+\n+    Long date20191201 = (Long) Literal.of(\"2019-12-01T00:00:00.00000\")\n+        .to(Types.TimestampType.withoutZone()).value();\n+    Long date20191202 = (Long) Literal.of(\"2019-12-02T00:00:00.00000\")\n+        .to(Types.TimestampType.withoutZone()).value();\n+\n+    PartitionSpec spec = PartitionSpec.builderFor(schema)\n+        .day(\"ts\")\n+        .build();\n+\n+    Transform day = spec.getFieldsBySourceId(50).get(0).transform();\n+    Integer tsDay = (Integer) day.apply(date20191201);\n+\n+    Predicate pred = in(\"ts\", date20191201, date20191202);\n+    ResidualEvaluator resEval = ResidualEvaluator.of(spec,\n+        pred, true);", "originalCommit": "e586ad404bf298c2779f90015aa3e250be8f1c17", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}