{"pr_number": 1882, "pr_title": "Flink: fix projection NPE caused by timestamp type", "pr_createdAt": "2020-12-07T03:55:48Z", "pr_url": "https://github.com/apache/iceberg/pull/1882", "timeline": [{"oid": "a38062667532f32f4ca9ec0b6dabf799ae7edf84", "url": "https://github.com/apache/iceberg/commit/a38062667532f32f4ca9ec0b6dabf799ae7edf84", "message": "Flink: fix projection NPE caused by timestamp type", "committedDate": "2020-12-07T03:43:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI4NzMzOA==", "url": "https://github.com/apache/iceberg/pull/1882#discussion_r537287338", "bodyText": "I run this unit test under my host without the fixed null checks, and got this exception:\nTest testBasicProjection[format=parquet](org.apache.iceberg.flink.source.TestFlinkInputFormat) failed with:\njava.lang.NullPointerException\n\tat org.apache.iceberg.flink.data.FlinkParquetReaders$ReadBuilder.primitive(FlinkParquetReaders.java:197)\n\tat org.apache.iceberg.flink.data.FlinkParquetReaders$ReadBuilder.primitive(FlinkParquetReaders.java:73)\n\tat org.apache.iceberg.parquet.TypeWithSchemaVisitor.visit(TypeWithSchemaVisitor.java:52)\n\tat org.apache.iceberg.parquet.TypeWithSchemaVisitor.visitField(TypeWithSchemaVisitor.java:155)\n\tat org.apache.iceberg.parquet.TypeWithSchemaVisitor.visitFields(TypeWithSchemaVisitor.java:169)\n\tat org.apache.iceberg.parquet.TypeWithSchemaVisitor.visit(TypeWithSchemaVisitor.java:47)\n\tat org.apache.iceberg.flink.data.FlinkParquetReaders.buildReader(FlinkParquetReaders.java:68)\n\tat org.apache.iceberg.flink.source.RowDataIterator.lambda$newParquetIterable$1(RowDataIterator.java:126)\n\tat org.apache.iceberg.parquet.ReadConf.<init>(ReadConf.java:118)\n\tat org.apache.iceberg.parquet.ParquetReader.init(ParquetReader.java:66)\n\tat org.apache.iceberg.parquet.ParquetReader.iterator(ParquetReader.java:77)\n\tat org.apache.iceberg.flink.source.RowDataIterator.openTaskIterator(RowDataIterator.java:76)\n\tat org.apache.iceberg.flink.source.DataIterator.updateCurrentIterator(DataIterator.java:102)\n\tat org.apache.iceberg.flink.source.DataIterator.hasNext(DataIterator.java:84)\n\tat org.apache.iceberg.flink.source.FlinkInputFormat.reachedEnd(FlinkInputFormat.java:100)\n\tat org.apache.iceberg.flink.TestHelpers.readRowData(TestHelpers.java:91)\n\tat org.apache.iceberg.flink.TestHelpers.readRows(TestHelpers.java:105)\n\tat org.apache.iceberg.flink.source.TestFlinkInputFormat.runFormat(TestFlinkInputFormat.java:132)\n\tat org.apache.iceberg.flink.source.TestFlinkInputFormat.testBasicProjection(TestFlinkInputFormat.java:120)\n\tat java.lang.Thread.run(Thread.java:748)\nChecked the code,  it currently will build a parquet value reader like the following if only project the id and data field:\nRowDataReader\n         |--> UnboxedReader\n         |--> StringReader\n         |--> MillisToTimestampReader\n\nAlthough the MillisToTimestampReader won't read any real data when projecting id and data only.  Now we will change to fill it with a null reader,  I'm not quite sure whether there's other reason that we fill it with a default non-null reader in the previous design.   Still take a look for more details.\nThanks @chenjunjiedada for providing this corner case, I'm pretty sure we need to fix this( current way or just check the expected refs like the following)\ndiff --git a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkParquetReaders.java b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkParquetReaders.java\nindex 3c9bd5cd..4cb94d2b 100644\n--- a/flink/src/main/java/org/apache/iceberg/flink/data/FlinkParquetReaders.java\n+++ b/flink/src/main/java/org/apache/iceberg/flink/data/FlinkParquetReaders.java\n@@ -194,13 +194,13 @@ public class FlinkParquetReaders {\n           case INT_64:\n             return new ParquetValueReaders.UnboxedReader<>(desc);\n           case TIMESTAMP_MICROS:\n-            if (((Types.TimestampType) expected).shouldAdjustToUTC()) {\n+            if (expected != null && ((Types.TimestampType) expected).shouldAdjustToUTC()) {\n               return new MicrosToTimestampTzReader(desc);\n             } else {\n               return new MicrosToTimestampReader(desc);\n             }\n           case TIMESTAMP_MILLIS:\n-            if (((Types.TimestampType) expected).shouldAdjustToUTC()) {\n+            if (expected != null && ((Types.TimestampType) expected).shouldAdjustToUTC()) {\n               return new MillisToTimestampTzReader(desc);\n             } else {\n               return new MillisToTimestampReader(desc);", "author": "openinx", "createdAt": "2020-12-07T07:36:17Z", "path": "flink/src/test/java/org/apache/iceberg/flink/source/TestFlinkInputFormat.java", "diffHunk": "@@ -100,6 +100,33 @@ public void testNestedProjection() throws Exception {\n     assertRows(result, expected);\n   }\n \n+  @Test\n+  public void testBasicProjection() throws IOException {\n+    Schema writeSchema = new Schema(\n+        Types.NestedField.required(0, \"id\", Types.LongType.get()),\n+        Types.NestedField.optional(1, \"data\", Types.StringType.get()),\n+        Types.NestedField.optional(2, \"time\", Types.TimestampType.withZone())\n+    );\n+\n+    Table table = catalog.createTable(TableIdentifier.of(\"default\", \"t\"), writeSchema);\n+\n+    List<Record> writeRecords = RandomGenericData.generate(writeSchema, 2, 0L);\n+    new GenericAppenderHelper(table, fileFormat, TEMPORARY_FOLDER).appendToTable(writeRecords);\n+\n+    TableSchema projectedSchema = TableSchema.builder()\n+        .field(\"id\", DataTypes.BIGINT())\n+        .field(\"data\", DataTypes.STRING())\n+        .build();\n+    List<Row> result = runFormat(FlinkSource.forRowData().tableLoader(loader()).project(projectedSchema).buildFormat());", "originalCommit": "a38062667532f32f4ca9ec0b6dabf799ae7edf84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5MDg0MA==", "url": "https://github.com/apache/iceberg/pull/1882#discussion_r537490840", "bodyText": "@rdblue  What do you think about this ?", "author": "openinx", "createdAt": "2020-12-07T13:05:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI4NzMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY4NTc3OA==", "url": "https://github.com/apache/iceberg/pull/1882#discussion_r537685778", "bodyText": "I like the fix in this PR. If an expected type is not present, then it is fine to return null and to skip adding it to the field map in the struct method. I'd rather do that than return a different reader. At least that way, we don't create extra readers that won't be used anyway.", "author": "rdblue", "createdAt": "2020-12-07T17:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI4NzMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk4MDMxNg==", "url": "https://github.com/apache/iceberg/pull/1882#discussion_r537980316", "bodyText": "I'm okay about merging this patch.  One thing I think we may need to do is:  it's better to extend the TestRowProjection  to all file format ( parquet/orc etc),  currently we only test the avro read projections.\nMaybe it similar to the spark unit tests TestSparkReadProjection", "author": "openinx", "createdAt": "2020-12-08T02:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI4NzMzOA=="}], "type": "inlineReview"}]}