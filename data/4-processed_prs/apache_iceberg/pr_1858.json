{"pr_number": 1858, "pr_title": "Core: Add SortedPosDeleteWriter", "pr_createdAt": "2020-12-02T09:37:07Z", "pr_url": "https://github.com/apache/iceberg/pull/1858", "timeline": [{"oid": "d172c8d3598a9a969bc5430f54c100308a913bac", "url": "https://github.com/apache/iceberg/commit/d172c8d3598a9a969bc5430f54c100308a913bac", "message": "Core: Add SortedPosDeleteWriter", "committedDate": "2020-12-02T09:32:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc1ODgyOA==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r535758828", "bodyText": "I think if we delete them in natural order, sorting them or not in delete writer will result in the correct order. Do we want to initialize the index as 4 and decrement the counter to test the sorting logic?", "author": "yyanyy", "createdAt": "2020-12-04T01:02:22Z", "path": "data/src/test/java/org/apache/iceberg/io/TestGenericSortedPosDeleteWriter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DeleteFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.RowDelta;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.TableTestBase;\n+import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.data.GenericAppenderFactory;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.IcebergGenerics;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.data.avro.DataReader;\n+import org.apache.iceberg.data.parquet.GenericParquetReaders;\n+import org.apache.iceberg.encryption.EncryptedOutputFile;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.util.StructLikeSet;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public class TestGenericSortedPosDeleteWriter extends TableTestBase {\n+  private static final int FORMAT_V2 = 2;\n+\n+  private final FileFormat format;\n+\n+  private OutputFileFactory fileFactory;\n+  private Record gRecord;\n+\n+  @Parameterized.Parameters(name = \"FileFormat={0}\")\n+  public static Object[] parameters() {\n+    return new Object[][] {\n+        new Object[] {\"avro\"},\n+        new Object[] {\"parquet\"},\n+    };\n+  }\n+\n+  public TestGenericSortedPosDeleteWriter(String fileFormat) {\n+    super(FORMAT_V2);\n+    this.format = FileFormat.valueOf(fileFormat.toUpperCase(Locale.ENGLISH));\n+  }\n+\n+  @Before\n+  public void setupTable() throws IOException {\n+    this.tableDir = temp.newFolder();\n+    Assert.assertTrue(tableDir.delete());\n+\n+    this.metadataDir = new File(tableDir, \"metadata\");\n+    this.table = create(SCHEMA, PartitionSpec.unpartitioned());\n+    this.gRecord = GenericRecord.create(SCHEMA);\n+\n+    this.fileFactory = new OutputFileFactory(table.spec(), format, table.locationProvider(), table.io(),\n+        table.encryption(), 1, 1);\n+\n+    table.updateProperties()\n+        .defaultFormat(format)\n+        .commit();\n+  }\n+\n+  private EncryptedOutputFile createEncryptedOutputFile() {\n+    return fileFactory.newOutputFile();\n+  }\n+\n+  private DataFile prepareDataFile(FileAppenderFactory<Record> appenderFactory, List<Record> rowSet)\n+      throws IOException {\n+    DataWriter<Record> writer = appenderFactory.newDataWriter(createEncryptedOutputFile(), format, null);\n+    try (DataWriter<Record> closeableWriter = writer) {\n+      for (Record record : rowSet) {\n+        closeableWriter.add(record);\n+      }\n+    }\n+\n+    return writer.toDataFile();\n+  }\n+\n+  private Record createRow(Integer id, String data) {\n+    Record row = gRecord.copy();\n+    row.setField(\"id\", id);\n+    row.setField(\"data\", data);\n+    return row;\n+  }\n+\n+  private StructLikeSet expectedRowSet(Iterable<Record> records) {\n+    StructLikeSet set = StructLikeSet.create(table.schema().asStruct());\n+    records.forEach(set::add);\n+    return set;\n+  }\n+\n+  private StructLikeSet actualRowSet(String... columns) throws IOException {\n+    StructLikeSet set = StructLikeSet.create(table.schema().asStruct());\n+    try (CloseableIterable<Record> reader = IcebergGenerics.read(table).select(columns).build()) {\n+      reader.forEach(set::add);\n+    }\n+    return set;\n+  }\n+\n+  @Test\n+  public void testSortedPosDelete() throws IOException {\n+    List<Record> rowSet = Lists.newArrayList(\n+        createRow(0, \"aaa\"),\n+        createRow(1, \"bbb\"),\n+        createRow(2, \"ccc\"),\n+        createRow(3, \"ddd\"),\n+        createRow(4, \"eee\")\n+    );\n+\n+    FileAppenderFactory<Record> appenderFactory = new GenericAppenderFactory(table.schema(), table.spec(),\n+        null, null, null);\n+    DataFile dataFile = prepareDataFile(appenderFactory, rowSet);\n+\n+    SortedPosDeleteWriter<Record> writer = new SortedPosDeleteWriter<>(appenderFactory, fileFactory, format, null, 100);\n+    try (SortedPosDeleteWriter<Record> closeableWriter = writer) {\n+      for (int index = 0; index < rowSet.size(); index += 2) {", "originalCommit": "d172c8d3598a9a969bc5430f54c100308a913bac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc2MjgyMA==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r535762820", "bodyText": "Nit: wrapper.set?", "author": "yyanyy", "createdAt": "2020-12-04T01:13:05Z", "path": "core/src/main/java/org/apache/iceberg/io/SortedPosDeleteWriter.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.iceberg.DeleteFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionKey;\n+import org.apache.iceberg.deletes.PositionDeleteWriter;\n+import org.apache.iceberg.encryption.EncryptedOutputFile;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.types.Comparators;\n+import org.apache.iceberg.util.CharSequenceSet;\n+import org.apache.iceberg.util.CharSequenceWrapper;\n+\n+class SortedPosDeleteWriter<T> implements Closeable {\n+  private static final long DEFAULT_RECORDS_NUM_THRESHOLD = 100_000L;\n+\n+  private final Map<CharSequenceWrapper, List<PosValue<T>>> posDeletes = Maps.newHashMap();\n+  private final List<DeleteFile> completedFiles = Lists.newArrayList();\n+  private final Set<CharSequence> referencedDataFiles = CharSequenceSet.empty();\n+  private final PosValueComparator<T> posValueComparator = new PosValueComparator<>();\n+  private final CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(null);\n+\n+  private final FileAppenderFactory<T> appenderFactory;\n+  private final OutputFileFactory fileFactory;\n+  private final FileFormat format;\n+  private final PartitionKey partition;\n+  private final long recordsNumThreshold;\n+\n+  private int records = 0;\n+\n+  SortedPosDeleteWriter(FileAppenderFactory<T> appenderFactory,\n+                        OutputFileFactory fileFactory,\n+                        FileFormat format,\n+                        PartitionKey partition,\n+                        long recordsNumThreshold) {\n+    this.appenderFactory = appenderFactory;\n+    this.fileFactory = fileFactory;\n+    this.format = format;\n+    this.partition = partition;\n+    this.recordsNumThreshold = recordsNumThreshold;\n+  }\n+\n+  SortedPosDeleteWriter(FileAppenderFactory<T> appenderFactory,\n+                        OutputFileFactory fileFactory,\n+                        FileFormat format,\n+                        PartitionKey partition) {\n+    this(appenderFactory, fileFactory, format, partition, DEFAULT_RECORDS_NUM_THRESHOLD);\n+  }\n+\n+  public void delete(CharSequence path, long pos) {\n+    delete(path, pos, null);\n+  }\n+\n+  public void delete(CharSequence path, long pos, T row) {\n+    posDeletes.compute(CharSequenceWrapper.wrap(path), (k, v) -> {", "originalCommit": "d172c8d3598a9a969bc5430f54c100308a913bac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgzMDkwNg==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r535830906", "bodyText": "We could not use wrapper.set here  because we will put this item into map and if not then other paths also use wrapper.set to compare CharSequence then the key of map will be messed up.  It's safe to create a new CharSequenceWrapper here.", "author": "openinx", "createdAt": "2020-12-04T04:40:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc2MjgyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQzMzIwMQ==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r536433201", "bodyText": "You are right, forgot that we may put the key into map too.", "author": "yyanyy", "createdAt": "2020-12-04T22:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc2MjgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc2NTY2Mw==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r535765663", "bodyText": "Nit: could probably be positions.sort(Comparator.comparingLong(PosValue::pos))", "author": "yyanyy", "createdAt": "2020-12-04T01:20:51Z", "path": "core/src/main/java/org/apache/iceberg/io/SortedPosDeleteWriter.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.apache.iceberg.DeleteFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionKey;\n+import org.apache.iceberg.deletes.PositionDeleteWriter;\n+import org.apache.iceberg.encryption.EncryptedOutputFile;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.types.Comparators;\n+import org.apache.iceberg.util.CharSequenceSet;\n+import org.apache.iceberg.util.CharSequenceWrapper;\n+\n+class SortedPosDeleteWriter<T> implements Closeable {\n+  private static final long DEFAULT_RECORDS_NUM_THRESHOLD = 100_000L;\n+\n+  private final Map<CharSequenceWrapper, List<PosValue<T>>> posDeletes = Maps.newHashMap();\n+  private final List<DeleteFile> completedFiles = Lists.newArrayList();\n+  private final Set<CharSequence> referencedDataFiles = CharSequenceSet.empty();\n+  private final PosValueComparator<T> posValueComparator = new PosValueComparator<>();\n+  private final CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(null);\n+\n+  private final FileAppenderFactory<T> appenderFactory;\n+  private final OutputFileFactory fileFactory;\n+  private final FileFormat format;\n+  private final PartitionKey partition;\n+  private final long recordsNumThreshold;\n+\n+  private int records = 0;\n+\n+  SortedPosDeleteWriter(FileAppenderFactory<T> appenderFactory,\n+                        OutputFileFactory fileFactory,\n+                        FileFormat format,\n+                        PartitionKey partition,\n+                        long recordsNumThreshold) {\n+    this.appenderFactory = appenderFactory;\n+    this.fileFactory = fileFactory;\n+    this.format = format;\n+    this.partition = partition;\n+    this.recordsNumThreshold = recordsNumThreshold;\n+  }\n+\n+  SortedPosDeleteWriter(FileAppenderFactory<T> appenderFactory,\n+                        OutputFileFactory fileFactory,\n+                        FileFormat format,\n+                        PartitionKey partition) {\n+    this(appenderFactory, fileFactory, format, partition, DEFAULT_RECORDS_NUM_THRESHOLD);\n+  }\n+\n+  public void delete(CharSequence path, long pos) {\n+    delete(path, pos, null);\n+  }\n+\n+  public void delete(CharSequence path, long pos, T row) {\n+    posDeletes.compute(CharSequenceWrapper.wrap(path), (k, v) -> {\n+      if (v == null) {\n+        return Lists.newArrayList(PosValue.of(pos, row));\n+      } else {\n+        v.add(PosValue.of(pos, row));\n+        return v;\n+      }\n+    });\n+\n+    records += 1;\n+\n+    // TODO Flush buffer based on the policy that checking whether whole heap memory size exceed the threshold.\n+    if (records >= recordsNumThreshold) {\n+      flushBuffer();\n+    }\n+  }\n+\n+  public List<DeleteFile> complete() throws IOException {\n+    close();\n+\n+    return completedFiles;\n+  }\n+\n+  public Set<CharSequence> referencedDataFiles() {\n+    return referencedDataFiles;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    flushBuffer();\n+  }\n+\n+  private void flushBuffer() {\n+    if (posDeletes.isEmpty()) {\n+      return;\n+    }\n+\n+    // Create a new output file.\n+    EncryptedOutputFile outputFile;\n+    if (partition == null) {\n+      outputFile = fileFactory.newOutputFile();\n+    } else {\n+      outputFile = fileFactory.newOutputFile(partition);\n+    }\n+\n+    PositionDeleteWriter<T> writer = appenderFactory.newPosDeleteWriter(outputFile, format, partition);\n+    try (PositionDeleteWriter<T> closeableWriter = writer) {\n+      // Sort all the paths.\n+      CharSequence[] paths = new CharSequence[posDeletes.size()];\n+      int index = 0;\n+      for (CharSequenceWrapper charSequenceWrapper : posDeletes.keySet()) {\n+        paths[index] = charSequenceWrapper.get();\n+        index += 1;\n+      }\n+      Arrays.sort(paths, Comparators.charSequences());\n+\n+      // Write all the sorted <path, pos, row> triples.\n+      for (CharSequence path : paths) {\n+        List<PosValue<T>> positions = posDeletes.get(wrapper.set(path));\n+        positions.sort(posValueComparator);", "originalCommit": "d172c8d3598a9a969bc5430f54c100308a913bac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgzMTkyMw==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r535831923", "bodyText": "That sounds good.", "author": "openinx", "createdAt": "2020-12-04T04:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc2NTY2Mw=="}], "type": "inlineReview"}, {"oid": "d90e3ca5c1fce787297bcace51457ec5635ec51d", "url": "https://github.com/apache/iceberg/commit/d90e3ca5c1fce787297bcace51457ec5635ec51d", "message": "Minor fixes", "committedDate": "2020-12-04T04:50:54Z", "type": "commit"}, {"oid": "e35955ff1b0eca24aa345f71d4cc9fed3bfa64e6", "url": "https://github.com/apache/iceberg/commit/e35955ff1b0eca24aa345f71d4cc9fed3bfa64e6", "message": "Improve unit tests.", "committedDate": "2020-12-04T05:21:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxODU5OQ==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r536918599", "bodyText": "Using a multimap requires this to create a new CharSequenceWrapper for each delete, even though we expect a very small set of keys. I think it would be better to use a regular map so that a new wrapper is created for only the first delete in each file:\n  List<PosValue<T>> values = posDeletes.get(wrapper.set(path));\n  if (values != null) {\n    values.add(PosValue.of(pos, row));\n  } else {\n    posDeletes.put(CharSequenceWrapper.wrap(path), Lists.newArrayList(PosValue.of(pos, row)));\n  }\n  ...", "author": "rdblue", "createdAt": "2020-12-06T00:09:06Z", "path": "core/src/main/java/org/apache/iceberg/io/SortedPosDeleteWriter.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.iceberg.DeleteFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionKey;\n+import org.apache.iceberg.deletes.PositionDeleteWriter;\n+import org.apache.iceberg.encryption.EncryptedOutputFile;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.types.Comparators;\n+import org.apache.iceberg.util.CharSequenceSet;\n+import org.apache.iceberg.util.CharSequenceWrapper;\n+\n+class SortedPosDeleteWriter<T> implements Closeable {\n+  private static final long DEFAULT_RECORDS_NUM_THRESHOLD = 100_000L;\n+\n+  private final Multimap<CharSequenceWrapper, PosValue<T>> posDeletes =\n+      Multimaps.newMultimap(Maps.newHashMap(), Lists::newArrayList);\n+  private final List<DeleteFile> completedFiles = Lists.newArrayList();\n+  private final Set<CharSequence> referencedDataFiles = CharSequenceSet.empty();\n+  private final CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(null);\n+\n+  private final FileAppenderFactory<T> appenderFactory;\n+  private final OutputFileFactory fileFactory;\n+  private final FileFormat format;\n+  private final PartitionKey partition;\n+  private final long recordsNumThreshold;\n+\n+  private int records = 0;\n+\n+  SortedPosDeleteWriter(FileAppenderFactory<T> appenderFactory,\n+                        OutputFileFactory fileFactory,\n+                        FileFormat format,\n+                        PartitionKey partition,\n+                        long recordsNumThreshold) {\n+    this.appenderFactory = appenderFactory;\n+    this.fileFactory = fileFactory;\n+    this.format = format;\n+    this.partition = partition;\n+    this.recordsNumThreshold = recordsNumThreshold;\n+  }\n+\n+  SortedPosDeleteWriter(FileAppenderFactory<T> appenderFactory,\n+                        OutputFileFactory fileFactory,\n+                        FileFormat format,\n+                        PartitionKey partition) {\n+    this(appenderFactory, fileFactory, format, partition, DEFAULT_RECORDS_NUM_THRESHOLD);\n+  }\n+\n+  public void delete(CharSequence path, long pos) {\n+    delete(path, pos, null);\n+  }\n+\n+  public void delete(CharSequence path, long pos, T row) {\n+    posDeletes.put(CharSequenceWrapper.wrap(path), PosValue.of(pos, row));", "originalCommit": "e35955ff1b0eca24aa345f71d4cc9fed3bfa64e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzAyNDk5MQ==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r537024991", "bodyText": "Sounds great, it will avoid creating so many small CharSequenceWrapper objects because in most cases we have already an existing path in this in-memory map.", "author": "openinx", "createdAt": "2020-12-06T12:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxODU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxOTI0Nw==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r536919247", "bodyText": "Minor: This is called PosValue, but the values is always used as \"row\" so it would make more sense to call it PosRow or PosAndRow. That way references use posRow.row() rather than posValue.row().", "author": "rdblue", "createdAt": "2020-12-06T00:14:01Z", "path": "core/src/main/java/org/apache/iceberg/io/SortedPosDeleteWriter.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.iceberg.DeleteFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionKey;\n+import org.apache.iceberg.deletes.PositionDeleteWriter;\n+import org.apache.iceberg.encryption.EncryptedOutputFile;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.types.Comparators;\n+import org.apache.iceberg.util.CharSequenceSet;\n+import org.apache.iceberg.util.CharSequenceWrapper;\n+\n+class SortedPosDeleteWriter<T> implements Closeable {\n+  private static final long DEFAULT_RECORDS_NUM_THRESHOLD = 100_000L;\n+\n+  private final Multimap<CharSequenceWrapper, PosValue<T>> posDeletes =\n+      Multimaps.newMultimap(Maps.newHashMap(), Lists::newArrayList);\n+  private final List<DeleteFile> completedFiles = Lists.newArrayList();\n+  private final Set<CharSequence> referencedDataFiles = CharSequenceSet.empty();\n+  private final CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(null);\n+\n+  private final FileAppenderFactory<T> appenderFactory;\n+  private final OutputFileFactory fileFactory;\n+  private final FileFormat format;\n+  private final PartitionKey partition;\n+  private final long recordsNumThreshold;\n+\n+  private int records = 0;\n+\n+  SortedPosDeleteWriter(FileAppenderFactory<T> appenderFactory,\n+                        OutputFileFactory fileFactory,\n+                        FileFormat format,\n+                        PartitionKey partition,\n+                        long recordsNumThreshold) {\n+    this.appenderFactory = appenderFactory;\n+    this.fileFactory = fileFactory;\n+    this.format = format;\n+    this.partition = partition;\n+    this.recordsNumThreshold = recordsNumThreshold;\n+  }\n+\n+  SortedPosDeleteWriter(FileAppenderFactory<T> appenderFactory,\n+                        OutputFileFactory fileFactory,\n+                        FileFormat format,\n+                        PartitionKey partition) {\n+    this(appenderFactory, fileFactory, format, partition, DEFAULT_RECORDS_NUM_THRESHOLD);\n+  }\n+\n+  public void delete(CharSequence path, long pos) {\n+    delete(path, pos, null);\n+  }\n+\n+  public void delete(CharSequence path, long pos, T row) {\n+    posDeletes.put(CharSequenceWrapper.wrap(path), PosValue.of(pos, row));\n+    records += 1;\n+\n+    // TODO Flush buffer based on the policy that checking whether whole heap memory size exceed the threshold.\n+    if (records >= recordsNumThreshold) {\n+      flushBuffer();\n+    }\n+  }\n+\n+  public List<DeleteFile> complete() throws IOException {\n+    close();\n+\n+    return completedFiles;\n+  }\n+\n+  public Set<CharSequence> referencedDataFiles() {\n+    return referencedDataFiles;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    flushBuffer();\n+  }\n+\n+  private void flushBuffer() {\n+    if (posDeletes.isEmpty()) {\n+      return;\n+    }\n+\n+    // Create a new output file.\n+    EncryptedOutputFile outputFile;\n+    if (partition == null) {\n+      outputFile = fileFactory.newOutputFile();\n+    } else {\n+      outputFile = fileFactory.newOutputFile(partition);\n+    }\n+\n+    PositionDeleteWriter<T> writer = appenderFactory.newPosDeleteWriter(outputFile, format, partition);\n+    try (PositionDeleteWriter<T> closeableWriter = writer) {\n+      // Sort all the paths.\n+      List<CharSequence> paths = Lists.newArrayListWithCapacity(posDeletes.keySet().size());\n+      for (CharSequenceWrapper charSequenceWrapper : posDeletes.keySet()) {\n+        paths.add(charSequenceWrapper.get());\n+      }\n+      paths.sort(Comparators.charSequences());\n+\n+      // Write all the sorted <path, pos, row> triples.\n+      for (CharSequence path : paths) {\n+        List<PosValue<T>> positions = (List<PosValue<T>>) posDeletes.get(wrapper.set(path));\n+        positions.sort(Comparator.comparingLong(PosValue::pos));\n+\n+        positions.forEach(posValue -> closeableWriter.delete(path, posValue.pos(), posValue.row()));\n+      }\n+    } catch (IOException e) {\n+      throw new UncheckedIOException(\"Failed to write the sorted path/pos pairs to pos-delete file: \" +\n+          outputFile.encryptingOutputFile().location(), e);\n+    }\n+\n+    // Clear the buffered pos-deletions.\n+    posDeletes.clear();\n+    records = 0;\n+\n+    // Add the referenced data files.\n+    referencedDataFiles.addAll(writer.referencedDataFiles());\n+\n+    // Add the completed delete files.\n+    completedFiles.add(writer.toDeleteFile());\n+  }\n+\n+  private static class PosValue<R> {", "originalCommit": "e35955ff1b0eca24aa345f71d4cc9fed3bfa64e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkxOTM3OA==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r536919378", "bodyText": "There isn't really a buffer in this class, so this name doesn't make sense. How about using flushBufferedDeletes or simply flushDeletes?", "author": "rdblue", "createdAt": "2020-12-06T00:14:53Z", "path": "core/src/main/java/org/apache/iceberg/io/SortedPosDeleteWriter.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.iceberg.DeleteFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionKey;\n+import org.apache.iceberg.deletes.PositionDeleteWriter;\n+import org.apache.iceberg.encryption.EncryptedOutputFile;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.types.Comparators;\n+import org.apache.iceberg.util.CharSequenceSet;\n+import org.apache.iceberg.util.CharSequenceWrapper;\n+\n+class SortedPosDeleteWriter<T> implements Closeable {\n+  private static final long DEFAULT_RECORDS_NUM_THRESHOLD = 100_000L;\n+\n+  private final Multimap<CharSequenceWrapper, PosValue<T>> posDeletes =\n+      Multimaps.newMultimap(Maps.newHashMap(), Lists::newArrayList);\n+  private final List<DeleteFile> completedFiles = Lists.newArrayList();\n+  private final Set<CharSequence> referencedDataFiles = CharSequenceSet.empty();\n+  private final CharSequenceWrapper wrapper = CharSequenceWrapper.wrap(null);\n+\n+  private final FileAppenderFactory<T> appenderFactory;\n+  private final OutputFileFactory fileFactory;\n+  private final FileFormat format;\n+  private final PartitionKey partition;\n+  private final long recordsNumThreshold;\n+\n+  private int records = 0;\n+\n+  SortedPosDeleteWriter(FileAppenderFactory<T> appenderFactory,\n+                        OutputFileFactory fileFactory,\n+                        FileFormat format,\n+                        PartitionKey partition,\n+                        long recordsNumThreshold) {\n+    this.appenderFactory = appenderFactory;\n+    this.fileFactory = fileFactory;\n+    this.format = format;\n+    this.partition = partition;\n+    this.recordsNumThreshold = recordsNumThreshold;\n+  }\n+\n+  SortedPosDeleteWriter(FileAppenderFactory<T> appenderFactory,\n+                        OutputFileFactory fileFactory,\n+                        FileFormat format,\n+                        PartitionKey partition) {\n+    this(appenderFactory, fileFactory, format, partition, DEFAULT_RECORDS_NUM_THRESHOLD);\n+  }\n+\n+  public void delete(CharSequence path, long pos) {\n+    delete(path, pos, null);\n+  }\n+\n+  public void delete(CharSequence path, long pos, T row) {\n+    posDeletes.put(CharSequenceWrapper.wrap(path), PosValue.of(pos, row));\n+    records += 1;\n+\n+    // TODO Flush buffer based on the policy that checking whether whole heap memory size exceed the threshold.\n+    if (records >= recordsNumThreshold) {\n+      flushBuffer();\n+    }\n+  }\n+\n+  public List<DeleteFile> complete() throws IOException {\n+    close();\n+\n+    return completedFiles;\n+  }\n+\n+  public Set<CharSequence> referencedDataFiles() {\n+    return referencedDataFiles;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    flushBuffer();\n+  }\n+\n+  private void flushBuffer() {", "originalCommit": "e35955ff1b0eca24aa345f71d4cc9fed3bfa64e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyMDE2Nw==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r536920167", "bodyText": "Can you also add a test for passing a null row when the schema is provided to the appender factory? That should fail because when rows are passed, every row must be passed to ensure the stats are correct.", "author": "rdblue", "createdAt": "2020-12-06T00:20:55Z", "path": "data/src/test/java/org/apache/iceberg/io/TestGenericSortedPosDeleteWriter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DeleteFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.RowDelta;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.TableTestBase;\n+import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.data.GenericAppenderFactory;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.IcebergGenerics;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.data.avro.DataReader;\n+import org.apache.iceberg.data.parquet.GenericParquetReaders;\n+import org.apache.iceberg.encryption.EncryptedOutputFile;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.util.StructLikeSet;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public class TestGenericSortedPosDeleteWriter extends TableTestBase {\n+  private static final int FORMAT_V2 = 2;\n+\n+  private final FileFormat format;\n+\n+  private OutputFileFactory fileFactory;\n+  private Record gRecord;\n+\n+  @Parameterized.Parameters(name = \"FileFormat={0}\")\n+  public static Object[] parameters() {\n+    return new Object[][] {\n+        new Object[] {\"avro\"},\n+        new Object[] {\"parquet\"},\n+    };\n+  }\n+\n+  public TestGenericSortedPosDeleteWriter(String fileFormat) {\n+    super(FORMAT_V2);\n+    this.format = FileFormat.valueOf(fileFormat.toUpperCase(Locale.ENGLISH));\n+  }\n+\n+  @Before\n+  public void setupTable() throws IOException {\n+    this.tableDir = temp.newFolder();\n+    Assert.assertTrue(tableDir.delete());\n+\n+    this.metadataDir = new File(tableDir, \"metadata\");\n+    this.table = create(SCHEMA, PartitionSpec.unpartitioned());\n+    this.gRecord = GenericRecord.create(SCHEMA);\n+\n+    this.fileFactory = new OutputFileFactory(table.spec(), format, table.locationProvider(), table.io(),\n+        table.encryption(), 1, 1);\n+\n+    table.updateProperties()\n+        .defaultFormat(format)\n+        .commit();\n+  }\n+\n+  private EncryptedOutputFile createEncryptedOutputFile() {\n+    return fileFactory.newOutputFile();\n+  }\n+\n+  private DataFile prepareDataFile(FileAppenderFactory<Record> appenderFactory, List<Record> rowSet)\n+      throws IOException {\n+    DataWriter<Record> writer = appenderFactory.newDataWriter(createEncryptedOutputFile(), format, null);\n+    try (DataWriter<Record> closeableWriter = writer) {\n+      for (Record record : rowSet) {\n+        closeableWriter.add(record);\n+      }\n+    }\n+\n+    return writer.toDataFile();\n+  }\n+\n+  private Record createRow(Integer id, String data) {\n+    Record row = gRecord.copy();\n+    row.setField(\"id\", id);\n+    row.setField(\"data\", data);\n+    return row;\n+  }\n+\n+  private StructLikeSet expectedRowSet(Iterable<Record> records) {\n+    StructLikeSet set = StructLikeSet.create(table.schema().asStruct());\n+    records.forEach(set::add);\n+    return set;\n+  }\n+\n+  private StructLikeSet actualRowSet(String... columns) throws IOException {\n+    StructLikeSet set = StructLikeSet.create(table.schema().asStruct());\n+    try (CloseableIterable<Record> reader = IcebergGenerics.read(table).select(columns).build()) {\n+      reader.forEach(set::add);\n+    }\n+    return set;\n+  }\n+\n+  @Test\n+  public void testSortedPosDelete() throws IOException {", "originalCommit": "e35955ff1b0eca24aa345f71d4cc9fed3bfa64e6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzAyOTUwNA==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r537029504", "bodyText": "Make sense !", "author": "openinx", "createdAt": "2020-12-06T12:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyMDE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyMDMwMQ==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r536920301", "bodyText": "Thanks, this really helps when reading the test.", "author": "rdblue", "createdAt": "2020-12-06T00:21:45Z", "path": "data/src/test/java/org/apache/iceberg/io/TestGenericSortedPosDeleteWriter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DeleteFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.RowDelta;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.TableTestBase;\n+import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.data.GenericAppenderFactory;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.IcebergGenerics;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.data.avro.DataReader;\n+import org.apache.iceberg.data.parquet.GenericParquetReaders;\n+import org.apache.iceberg.encryption.EncryptedOutputFile;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.util.StructLikeSet;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public class TestGenericSortedPosDeleteWriter extends TableTestBase {\n+  private static final int FORMAT_V2 = 2;\n+\n+  private final FileFormat format;\n+\n+  private OutputFileFactory fileFactory;\n+  private Record gRecord;\n+\n+  @Parameterized.Parameters(name = \"FileFormat={0}\")\n+  public static Object[] parameters() {\n+    return new Object[][] {\n+        new Object[] {\"avro\"},\n+        new Object[] {\"parquet\"},\n+    };\n+  }\n+\n+  public TestGenericSortedPosDeleteWriter(String fileFormat) {\n+    super(FORMAT_V2);\n+    this.format = FileFormat.valueOf(fileFormat.toUpperCase(Locale.ENGLISH));\n+  }\n+\n+  @Before\n+  public void setupTable() throws IOException {\n+    this.tableDir = temp.newFolder();\n+    Assert.assertTrue(tableDir.delete());\n+\n+    this.metadataDir = new File(tableDir, \"metadata\");\n+    this.table = create(SCHEMA, PartitionSpec.unpartitioned());\n+    this.gRecord = GenericRecord.create(SCHEMA);\n+\n+    this.fileFactory = new OutputFileFactory(table.spec(), format, table.locationProvider(), table.io(),\n+        table.encryption(), 1, 1);\n+\n+    table.updateProperties()\n+        .defaultFormat(format)\n+        .commit();\n+  }\n+\n+  private EncryptedOutputFile createEncryptedOutputFile() {\n+    return fileFactory.newOutputFile();\n+  }\n+\n+  private DataFile prepareDataFile(FileAppenderFactory<Record> appenderFactory, List<Record> rowSet)\n+      throws IOException {\n+    DataWriter<Record> writer = appenderFactory.newDataWriter(createEncryptedOutputFile(), format, null);\n+    try (DataWriter<Record> closeableWriter = writer) {\n+      for (Record record : rowSet) {\n+        closeableWriter.add(record);\n+      }\n+    }\n+\n+    return writer.toDataFile();\n+  }\n+\n+  private Record createRow(Integer id, String data) {\n+    Record row = gRecord.copy();\n+    row.setField(\"id\", id);\n+    row.setField(\"data\", data);\n+    return row;\n+  }\n+\n+  private StructLikeSet expectedRowSet(Iterable<Record> records) {\n+    StructLikeSet set = StructLikeSet.create(table.schema().asStruct());\n+    records.forEach(set::add);\n+    return set;\n+  }\n+\n+  private StructLikeSet actualRowSet(String... columns) throws IOException {\n+    StructLikeSet set = StructLikeSet.create(table.schema().asStruct());\n+    try (CloseableIterable<Record> reader = IcebergGenerics.read(table).select(columns).build()) {\n+      reader.forEach(set::add);\n+    }\n+    return set;\n+  }\n+\n+  @Test\n+  public void testSortedPosDelete() throws IOException {\n+    List<Record> rowSet = Lists.newArrayList(\n+        createRow(0, \"aaa\"),\n+        createRow(1, \"bbb\"),\n+        createRow(2, \"ccc\"),\n+        createRow(3, \"ddd\"),\n+        createRow(4, \"eee\")\n+    );\n+\n+    FileAppenderFactory<Record> appenderFactory = new GenericAppenderFactory(table.schema(), table.spec(),\n+        null, null, null);\n+    DataFile dataFile = prepareDataFile(appenderFactory, rowSet);\n+\n+    SortedPosDeleteWriter<Record> writer = new SortedPosDeleteWriter<>(appenderFactory, fileFactory, format, null, 100);\n+    try (SortedPosDeleteWriter<Record> closeableWriter = writer) {\n+      for (int index = rowSet.size() - 1; index >= 0; index -= 2) {\n+        closeableWriter.delete(dataFile.path(), index);\n+      }\n+    }\n+\n+    List<DeleteFile> deleteFiles = writer.complete();\n+    Assert.assertEquals(1, deleteFiles.size());\n+    DeleteFile deleteFile = deleteFiles.get(0);\n+\n+    // Check whether the path-pos pairs are sorted as expected.\n+    Schema pathPosSchema = DeleteSchemaUtil.pathPosSchema();\n+    Record record = GenericRecord.create(pathPosSchema);\n+    List<Record> expectedDeletes = Lists.newArrayList(\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 0L),\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 2L),\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 4L)\n+    );\n+    Assert.assertEquals(expectedDeletes, readRecordsAsList(pathPosSchema, deleteFile.path()));\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .addDeletes(deleteFiles.get(0))\n+        .validateDataFilesExist(writer.referencedDataFiles())\n+        .validateDeletedFiles()\n+        .commit();\n+\n+    List<Record> expectedData = Lists.newArrayList(\n+        createRow(1, \"bbb\"),\n+        createRow(3, \"ddd\")\n+    );\n+    Assert.assertEquals(\"Should have the expected records\", expectedRowSet(expectedData), actualRowSet(\"*\"));\n+  }\n+\n+  @Test\n+  public void testSortedPosDeleteWithRow() throws IOException {\n+    List<Record> rowSet = Lists.newArrayList(\n+        createRow(0, \"aaa\"),\n+        createRow(1, \"bbb\"),\n+        createRow(2, \"ccc\"),\n+        createRow(3, \"ddd\"),\n+        createRow(4, \"eee\")\n+    );\n+\n+    FileAppenderFactory<Record> appenderFactory = new GenericAppenderFactory(table.schema(), table.spec(),\n+        null, null, table.schema());\n+    DataFile dataFile = prepareDataFile(appenderFactory, rowSet);\n+\n+    SortedPosDeleteWriter<Record> writer = new SortedPosDeleteWriter<>(appenderFactory, fileFactory, format, null, 100);\n+    try (SortedPosDeleteWriter<Record> closeableWriter = writer) {\n+      for (int index = rowSet.size() - 1; index >= 0; index -= 2) {\n+        closeableWriter.delete(dataFile.path(), index, rowSet.get(index)); // Write deletes with row.\n+      }\n+    }\n+\n+    List<DeleteFile> deleteFiles = writer.complete();\n+    Assert.assertEquals(1, deleteFiles.size());\n+    DeleteFile deleteFile = deleteFiles.get(0);\n+\n+    // Check whether the path-pos pairs are sorted as expected.\n+    Schema pathPosSchema = DeleteSchemaUtil.posDeleteSchema(table.schema());\n+    Record record = GenericRecord.create(pathPosSchema);\n+    List<Record> expectedDeletes = Lists.newArrayList(\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 0L, \"row\", createRow(0, \"aaa\")),\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 2L, \"row\", createRow(2, \"ccc\")),\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 4L, \"row\", createRow(4, \"eee\"))\n+    );\n+    Assert.assertEquals(expectedDeletes, readRecordsAsList(pathPosSchema, deleteFile.path()));\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .addDeletes(deleteFiles.get(0))\n+        .validateDataFilesExist(writer.referencedDataFiles())\n+        .validateDeletedFiles()\n+        .commit();\n+\n+    List<Record> expectedData = Lists.newArrayList(\n+        createRow(1, \"bbb\"),\n+        createRow(3, \"ddd\")\n+    );\n+    Assert.assertEquals(\"Should have the expected records\", expectedRowSet(expectedData), actualRowSet(\"*\"));\n+  }\n+\n+  @Test\n+  public void testMultipleFlush() throws IOException {\n+    FileAppenderFactory<Record> appenderFactory = new GenericAppenderFactory(table.schema(), table.spec(),\n+        null, null, null);\n+\n+    // It will produce 5 record lists, each list will write into a separate data file:\n+    // The 1th file has: <0  , val-0>   , <1  , val-1>   , ... , <99 , val-99>\n+    // The 2th file has: <100, val-100> , <101, val-101> , ... , <199, val-199>\n+    // The 3th file has: <200, val-200> , <201, val-201> , ... , <299, val-299>\n+    // The 4th file has: <300, val-300> , <301, val-301> , ... , <399, val-399>\n+    // The 5th file has: <400, val-400> , <401, val-401> , ... , <499, val-499>", "originalCommit": "e35955ff1b0eca24aa345f71d4cc9fed3bfa64e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjkyMDQ0MA==", "url": "https://github.com/apache/iceberg/pull/1858#discussion_r536920440", "bodyText": "This is ascending order.", "author": "rdblue", "createdAt": "2020-12-06T00:22:53Z", "path": "data/src/test/java/org/apache/iceberg/io/TestGenericSortedPosDeleteWriter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.io;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Locale;\n+import org.apache.iceberg.DataFile;\n+import org.apache.iceberg.DeleteFile;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.Files;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.RowDelta;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.TableTestBase;\n+import org.apache.iceberg.avro.Avro;\n+import org.apache.iceberg.data.GenericAppenderFactory;\n+import org.apache.iceberg.data.GenericRecord;\n+import org.apache.iceberg.data.IcebergGenerics;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.data.avro.DataReader;\n+import org.apache.iceberg.data.parquet.GenericParquetReaders;\n+import org.apache.iceberg.encryption.EncryptedOutputFile;\n+import org.apache.iceberg.parquet.Parquet;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.util.StructLikeSet;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)\n+public class TestGenericSortedPosDeleteWriter extends TableTestBase {\n+  private static final int FORMAT_V2 = 2;\n+\n+  private final FileFormat format;\n+\n+  private OutputFileFactory fileFactory;\n+  private Record gRecord;\n+\n+  @Parameterized.Parameters(name = \"FileFormat={0}\")\n+  public static Object[] parameters() {\n+    return new Object[][] {\n+        new Object[] {\"avro\"},\n+        new Object[] {\"parquet\"},\n+    };\n+  }\n+\n+  public TestGenericSortedPosDeleteWriter(String fileFormat) {\n+    super(FORMAT_V2);\n+    this.format = FileFormat.valueOf(fileFormat.toUpperCase(Locale.ENGLISH));\n+  }\n+\n+  @Before\n+  public void setupTable() throws IOException {\n+    this.tableDir = temp.newFolder();\n+    Assert.assertTrue(tableDir.delete());\n+\n+    this.metadataDir = new File(tableDir, \"metadata\");\n+    this.table = create(SCHEMA, PartitionSpec.unpartitioned());\n+    this.gRecord = GenericRecord.create(SCHEMA);\n+\n+    this.fileFactory = new OutputFileFactory(table.spec(), format, table.locationProvider(), table.io(),\n+        table.encryption(), 1, 1);\n+\n+    table.updateProperties()\n+        .defaultFormat(format)\n+        .commit();\n+  }\n+\n+  private EncryptedOutputFile createEncryptedOutputFile() {\n+    return fileFactory.newOutputFile();\n+  }\n+\n+  private DataFile prepareDataFile(FileAppenderFactory<Record> appenderFactory, List<Record> rowSet)\n+      throws IOException {\n+    DataWriter<Record> writer = appenderFactory.newDataWriter(createEncryptedOutputFile(), format, null);\n+    try (DataWriter<Record> closeableWriter = writer) {\n+      for (Record record : rowSet) {\n+        closeableWriter.add(record);\n+      }\n+    }\n+\n+    return writer.toDataFile();\n+  }\n+\n+  private Record createRow(Integer id, String data) {\n+    Record row = gRecord.copy();\n+    row.setField(\"id\", id);\n+    row.setField(\"data\", data);\n+    return row;\n+  }\n+\n+  private StructLikeSet expectedRowSet(Iterable<Record> records) {\n+    StructLikeSet set = StructLikeSet.create(table.schema().asStruct());\n+    records.forEach(set::add);\n+    return set;\n+  }\n+\n+  private StructLikeSet actualRowSet(String... columns) throws IOException {\n+    StructLikeSet set = StructLikeSet.create(table.schema().asStruct());\n+    try (CloseableIterable<Record> reader = IcebergGenerics.read(table).select(columns).build()) {\n+      reader.forEach(set::add);\n+    }\n+    return set;\n+  }\n+\n+  @Test\n+  public void testSortedPosDelete() throws IOException {\n+    List<Record> rowSet = Lists.newArrayList(\n+        createRow(0, \"aaa\"),\n+        createRow(1, \"bbb\"),\n+        createRow(2, \"ccc\"),\n+        createRow(3, \"ddd\"),\n+        createRow(4, \"eee\")\n+    );\n+\n+    FileAppenderFactory<Record> appenderFactory = new GenericAppenderFactory(table.schema(), table.spec(),\n+        null, null, null);\n+    DataFile dataFile = prepareDataFile(appenderFactory, rowSet);\n+\n+    SortedPosDeleteWriter<Record> writer = new SortedPosDeleteWriter<>(appenderFactory, fileFactory, format, null, 100);\n+    try (SortedPosDeleteWriter<Record> closeableWriter = writer) {\n+      for (int index = rowSet.size() - 1; index >= 0; index -= 2) {\n+        closeableWriter.delete(dataFile.path(), index);\n+      }\n+    }\n+\n+    List<DeleteFile> deleteFiles = writer.complete();\n+    Assert.assertEquals(1, deleteFiles.size());\n+    DeleteFile deleteFile = deleteFiles.get(0);\n+\n+    // Check whether the path-pos pairs are sorted as expected.\n+    Schema pathPosSchema = DeleteSchemaUtil.pathPosSchema();\n+    Record record = GenericRecord.create(pathPosSchema);\n+    List<Record> expectedDeletes = Lists.newArrayList(\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 0L),\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 2L),\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 4L)\n+    );\n+    Assert.assertEquals(expectedDeletes, readRecordsAsList(pathPosSchema, deleteFile.path()));\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .addDeletes(deleteFiles.get(0))\n+        .validateDataFilesExist(writer.referencedDataFiles())\n+        .validateDeletedFiles()\n+        .commit();\n+\n+    List<Record> expectedData = Lists.newArrayList(\n+        createRow(1, \"bbb\"),\n+        createRow(3, \"ddd\")\n+    );\n+    Assert.assertEquals(\"Should have the expected records\", expectedRowSet(expectedData), actualRowSet(\"*\"));\n+  }\n+\n+  @Test\n+  public void testSortedPosDeleteWithRow() throws IOException {\n+    List<Record> rowSet = Lists.newArrayList(\n+        createRow(0, \"aaa\"),\n+        createRow(1, \"bbb\"),\n+        createRow(2, \"ccc\"),\n+        createRow(3, \"ddd\"),\n+        createRow(4, \"eee\")\n+    );\n+\n+    FileAppenderFactory<Record> appenderFactory = new GenericAppenderFactory(table.schema(), table.spec(),\n+        null, null, table.schema());\n+    DataFile dataFile = prepareDataFile(appenderFactory, rowSet);\n+\n+    SortedPosDeleteWriter<Record> writer = new SortedPosDeleteWriter<>(appenderFactory, fileFactory, format, null, 100);\n+    try (SortedPosDeleteWriter<Record> closeableWriter = writer) {\n+      for (int index = rowSet.size() - 1; index >= 0; index -= 2) {\n+        closeableWriter.delete(dataFile.path(), index, rowSet.get(index)); // Write deletes with row.\n+      }\n+    }\n+\n+    List<DeleteFile> deleteFiles = writer.complete();\n+    Assert.assertEquals(1, deleteFiles.size());\n+    DeleteFile deleteFile = deleteFiles.get(0);\n+\n+    // Check whether the path-pos pairs are sorted as expected.\n+    Schema pathPosSchema = DeleteSchemaUtil.posDeleteSchema(table.schema());\n+    Record record = GenericRecord.create(pathPosSchema);\n+    List<Record> expectedDeletes = Lists.newArrayList(\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 0L, \"row\", createRow(0, \"aaa\")),\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 2L, \"row\", createRow(2, \"ccc\")),\n+        record.copy(\"file_path\", dataFile.path(), \"pos\", 4L, \"row\", createRow(4, \"eee\"))\n+    );\n+    Assert.assertEquals(expectedDeletes, readRecordsAsList(pathPosSchema, deleteFile.path()));\n+\n+    table.newRowDelta()\n+        .addRows(dataFile)\n+        .addDeletes(deleteFiles.get(0))\n+        .validateDataFilesExist(writer.referencedDataFiles())\n+        .validateDeletedFiles()\n+        .commit();\n+\n+    List<Record> expectedData = Lists.newArrayList(\n+        createRow(1, \"bbb\"),\n+        createRow(3, \"ddd\")\n+    );\n+    Assert.assertEquals(\"Should have the expected records\", expectedRowSet(expectedData), actualRowSet(\"*\"));\n+  }\n+\n+  @Test\n+  public void testMultipleFlush() throws IOException {\n+    FileAppenderFactory<Record> appenderFactory = new GenericAppenderFactory(table.schema(), table.spec(),\n+        null, null, null);\n+\n+    // It will produce 5 record lists, each list will write into a separate data file:\n+    // The 1th file has: <0  , val-0>   , <1  , val-1>   , ... , <99 , val-99>\n+    // The 2th file has: <100, val-100> , <101, val-101> , ... , <199, val-199>\n+    // The 3th file has: <200, val-200> , <201, val-201> , ... , <299, val-299>\n+    // The 4th file has: <300, val-300> , <301, val-301> , ... , <399, val-399>\n+    // The 5th file has: <400, val-400> , <401, val-401> , ... , <499, val-499>\n+    List<DataFile> dataFiles = Lists.newArrayList();\n+    for (int fileIndex = 0; fileIndex < 5; fileIndex++) {\n+      List<Record> recordList = Lists.newLinkedList();\n+      for (int recordIndex = 0; recordIndex < 100; recordIndex++) {\n+        int id = fileIndex * 100 + recordIndex;\n+        recordList.add(createRow(id, String.format(\"val-%s\", id)));\n+      }\n+\n+      // Write the records and generate the data file.\n+      dataFiles.add(prepareDataFile(appenderFactory, recordList));\n+    }\n+\n+    // Commit those data files to iceberg table.\n+    RowDelta rowDelta = table.newRowDelta();\n+    dataFiles.forEach(rowDelta::addRows);\n+    rowDelta.commit();\n+\n+    SortedPosDeleteWriter<Record> writer = new SortedPosDeleteWriter<>(appenderFactory, fileFactory, format, null, 50);\n+    try (SortedPosDeleteWriter<Record> closeableWriter = writer) {\n+      for (int pos = 0; pos < 100; pos++) { // Delete in DESC order.", "originalCommit": "e35955ff1b0eca24aa345f71d4cc9fed3bfa64e6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f104c335ea2be4034e76539e0240d67cfa36bb1e", "url": "https://github.com/apache/iceberg/commit/f104c335ea2be4034e76539e0240d67cfa36bb1e", "message": "Addressing comments.", "committedDate": "2020-12-06T12:48:56Z", "type": "commit"}, {"oid": "e3b1f2a29668e777780395995c5fd7435e3587b6", "url": "https://github.com/apache/iceberg/commit/e3b1f2a29668e777780395995c5fd7435e3587b6", "message": "Fix broken unit tests.", "committedDate": "2020-12-07T03:51:16Z", "type": "commit"}]}