{"pr_number": 1948, "pr_title": "Spark: Add SQL commands evolve partition specs", "pr_createdAt": "2020-12-16T22:53:42Z", "pr_url": "https://github.com/apache/iceberg/pull/1948", "timeline": [{"oid": "409686879d67ca3c101d4dd6809b7f3935ba5ad5", "url": "https://github.com/apache/iceberg/commit/409686879d67ca3c101d4dd6809b7f3935ba5ad5", "message": "Add SQL commands for ADD, DROP PARTITION FIELD.", "committedDate": "2020-12-16T22:51:52Z", "type": "commit"}, {"oid": "251fdf7ab61ea9e5e5f8f3da72b7c165abf274df", "url": "https://github.com/apache/iceberg/commit/251fdf7ab61ea9e5e5f8f3da72b7c165abf274df", "message": "Support dropping partitions by name.", "committedDate": "2020-12-16T23:04:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ3NDE5MA==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r545474190", "bodyText": "So, this seems really unlikely and I can't figure out a good way around it, but if someone had a \"add partition field\" as a column name doing a Spark alter table this would probably give a false positive, but that probably doesn't matter since even then most of the time the iceberg parser is a superset of the delegate parser. Does that sound right or am I off base with the assumption this block?", "author": "holdenk", "createdAt": "2020-12-17T23:32:40Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/parser/extensions/IcebergSparkSqlExtensionsParser.scala", "diffHunk": "@@ -94,13 +94,20 @@ class IcebergSparkSqlExtensionsParser(delegate: ParserInterface) extends ParserI\n    */\n   override def parsePlan(sqlText: String): LogicalPlan = {\n     val sqlTextAfterSubstitution = substitutor.substitute(sqlText)\n-    if (sqlTextAfterSubstitution.toLowerCase(Locale.ROOT).trim().startsWith(\"call\")) {\n+    if (isIcebergCommand(sqlTextAfterSubstitution)) {\n       parse(sqlTextAfterSubstitution) { parser => astBuilder.visit(parser.singleStatement()) }.asInstanceOf[LogicalPlan]\n     } else {\n       delegate.parsePlan(sqlText)\n     }\n   }\n \n+  private def isIcebergCommand(sqlText: String): Boolean = {\n+    val normalized = sqlText.toLowerCase(Locale.ROOT).trim()\n+    normalized.startsWith(\"call\") ||\n+        (normalized.startsWith(\"alter table\") && (\n+            normalized.contains(\"add partition field\") || normalized.contains(\"drop partition field\")))", "originalCommit": "251fdf7ab61ea9e5e5f8f3da72b7c165abf274df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxNDMwNg==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r545514306", "bodyText": "I think that the \"add partition\" syntax requires a partition \"spec\" that is something like (a=1, b=2) so the parentheses should prevent this from catching \"add partition\" commands.\nThat said, we used to fall back to the Spark parser whenever something couldn't be parsed by this parser. I'm not sure whether we want to move back to that or do something more complicated. One option is try the Iceberg parser, then the Spark parser, and then check the Spark parser's exception. If it complains about CALL or FIELD then the exception from the Iceberg parser should be used, otherwise it should re-throw Spark's exception.\n@RussellSpitzer, any ideas here?", "author": "rdblue", "createdAt": "2020-12-18T01:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ3NDE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTg4NjcyOQ==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r545886729", "bodyText": "I was thinking about this before and I didn't want it to be that specific. I think maybe a cool solution could be trying both, and checking which parser parsed the furthest. Each of our analysis exceptions should give a position, so we can just pick whoever parsed the most. How does that sound?", "author": "RussellSpitzer", "createdAt": "2020-12-18T14:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ3NDE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5MTIwMA==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r545991200", "bodyText": "That sounds reasonable to me, but I think we would want to make sure we have tests for it so we know if the heuristic starts to fail. Also, that should be a follow-up and not in this PR, right?", "author": "rdblue", "createdAt": "2020-12-18T17:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ3NDE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk5OTcxNA==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r545999714", "bodyText": "Not a deal breaker for me.", "author": "RussellSpitzer", "createdAt": "2020-12-18T18:05:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ3NDE5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNDkzOA==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r546004938", "bodyText": "Same, I don't think this needs to be addressed here, I was just bringing it up to make sure my understanding was correct.", "author": "holdenk", "createdAt": "2020-12-18T18:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ3NDE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwMjcxMg==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r546002712", "bodyText": "Did the apply method not resolve here? Wondering why we needed to modify the anonymous arg", "author": "RussellSpitzer", "createdAt": "2020-12-18T18:11:01Z", "path": "spark3-extensions/src/main/scala/org/apache/iceberg/spark/extensions/IcebergSparkSessionExtensions.scala", "diffHunk": "@@ -37,6 +37,6 @@ class IcebergSparkSessionExtensions extends (SparkSessionExtensions => Unit) {\n     // TODO: PullupCorrelatedPredicates should handle row-level operations\n     extensions.injectOptimizerRule { _ => PullupCorrelatedPredicatesInRowLevelOperations }\n     extensions.injectOptimizerRule { _ => RewriteDelete }\n-    extensions.injectPlannerStrategy { _ => ExtendedDataSourceV2Strategy }\n+    extensions.injectPlannerStrategy { spark => ExtendedDataSourceV2Strategy(spark) }", "originalCommit": "251fdf7ab61ea9e5e5f8f3da72b7c165abf274df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwNDU2Nw==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r546004567", "bodyText": "This follows what we do above, and it seemed reasonably clean to me. I guess we could just pass ExtendedDataSourceV2Strategy and have apply automatically called.", "author": "rdblue", "createdAt": "2020-12-18T18:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwMjcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxOTQzNQ==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r546019435", "bodyText": "Ah I was just following the pattern with injectOptimizer lines directly above", "author": "RussellSpitzer", "createdAt": "2020-12-18T18:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwMjcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxMTA1MA==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r546011050", "bodyText": "extra newline?", "author": "RussellSpitzer", "createdAt": "2020-12-18T18:25:25Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/DropPartitionFieldExec.scala", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.iceberg.spark.Spark3Util\n+import org.apache.iceberg.spark.source.SparkTable\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.connector.catalog.Identifier\n+import org.apache.spark.sql.connector.catalog.TableCatalog\n+import org.apache.spark.sql.connector.expressions.FieldReference\n+import org.apache.spark.sql.connector.expressions.IdentityTransform\n+import org.apache.spark.sql.connector.expressions.Transform\n+\n+case class DropPartitionFieldExec(\n+    catalog: TableCatalog,\n+    ident: Identifier,\n+    transform: Transform) extends V2CommandExec {\n+  import org.apache.spark.sql.connector.catalog.CatalogV2Implicits._\n+\n+  override lazy val output: Seq[Attribute] = Nil\n+\n+  override protected def run(): Seq[InternalRow] = {\n+    catalog.loadTable(ident) match {\n+      case iceberg: SparkTable =>\n+        val schema = iceberg.table.schema\n+        transform match {\n+          case IdentityTransform(FieldReference(parts)) if parts.size == 1 && schema.findField(parts.head) == null =>\n+            // the name is not present in the Iceberg schema, so it must be a partition field name, not a column name\n+            iceberg.table.updateSpec()\n+                .removeField(parts.head)\n+                .commit()\n+\n+          case _ =>\n+            iceberg.table.updateSpec()\n+                .removeField(Spark3Util.toIcebergTerm(transform))\n+                .commit()\n+        }\n+\n+", "originalCommit": "251fdf7ab61ea9e5e5f8f3da72b7c165abf274df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4de1fbb623ae9773b2698cab6bbc56dccad3c60b", "url": "https://github.com/apache/iceberg/commit/4de1fbb623ae9773b2698cab6bbc56dccad3c60b", "message": "Update DropPartitionFieldExec.scala", "committedDate": "2020-12-18T18:32:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNjIwNA==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r546016204", "bodyText": "I don't think you need the inner paren's here", "author": "RussellSpitzer", "createdAt": "2020-12-18T18:35:28Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/ExtendedDataSourceV2Strategy.scala", "diffHunk": "@@ -53,4 +76,18 @@ object ExtendedDataSourceV2Strategy extends Strategy {\n     }\n     new GenericInternalRow(values)\n   }\n+\n+  private object IcebergCatalogAndIdentifier {\n+    def unapply(identifier: Seq[String]): Option[(TableCatalog, Identifier)] = {\n+      val catalogAndIdentifier = Spark3Util.catalogAndIdentifier(spark, identifier.asJava)\n+      catalogAndIdentifier.catalog match {\n+        case icebergCatalog: SparkCatalog =>\n+          Some((icebergCatalog, catalogAndIdentifier.identifier))\n+        case icebergCatalog: SparkSessionCatalog[_] =>\n+          Some((icebergCatalog, catalogAndIdentifier.identifier))", "originalCommit": "251fdf7ab61ea9e5e5f8f3da72b7c165abf274df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxOTM4Mg==", "url": "https://github.com/apache/iceberg/pull/1948#discussion_r546019382", "bodyText": "I'm pretty sure they are needed. I've hit issues in the past with this, at least in Scala 2.11.", "author": "rdblue", "createdAt": "2020-12-18T18:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAxNjIwNA=="}], "type": "inlineReview"}]}