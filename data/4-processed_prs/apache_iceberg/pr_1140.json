{"pr_number": 1140, "pr_title": "ORC: skip non-iceberg columns when converting schema to Iceberg", "pr_createdAt": "2020-06-26T18:37:00Z", "pr_url": "https://github.com/apache/iceberg/pull/1140", "timeline": [{"oid": "9104949e6bd7c62a3203550b2d003c4849fc2875", "url": "https://github.com/apache/iceberg/commit/9104949e6bd7c62a3203550b2d003c4849fc2875", "message": "Skip columns without iceberg ids on schema conversion", "committedDate": "2020-06-23T17:24:37Z", "type": "commit"}, {"oid": "2970838dbc70a2eec8ce454c435aacfa0ac4c82c", "url": "https://github.com/apache/iceberg/commit/2970838dbc70a2eec8ce454c435aacfa0ac4c82c", "message": "Fix NPE on null list in ORC type visitor", "committedDate": "2020-06-25T18:30:08Z", "type": "commit"}, {"oid": "e74640c29b1dae917059e2cb201715c4344abce5", "url": "https://github.com/apache/iceberg/commit/e74640c29b1dae917059e2cb201715c4344abce5", "message": "Fix #1055 Use visitor to convert ORC schema to Iceberg\n\nThis change also skips columns that do not have an Iceberg ID attribute.", "committedDate": "2020-06-25T22:07:27Z", "type": "commit"}, {"oid": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "url": "https://github.com/apache/iceberg/commit/d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "message": "Add test for skipping non-iceberg columns in ORC", "committedDate": "2020-06-26T18:33:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUzODQyNA==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r446538424", "bodyText": "I think the javadoc on this method needs revision?", "author": "rdsr", "createdAt": "2020-06-27T15:37:25Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -214,10 +212,13 @@ public static Schema convert(TypeDescription orcSchema) {\n         \"Error in ORC file, children fields and names do not match.\");\n \n     List<Types.NestedField> icebergFields = Lists.newArrayListWithExpectedSize(children.size());\n-    AtomicInteger lastColumnId = new AtomicInteger(getMaxIcebergId(orcSchema));", "originalCommit": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE0NjQ0MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r447146441", "bodyText": "Done.", "author": "edgarRd", "createdAt": "2020-06-29T17:48:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUzODQyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0MDE1MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r446540151", "bodyText": "I wonder if this logic should be in the visitor impl, The visitor  superclass should only be concerned with traversal, IMO", "author": "rdsr", "createdAt": "2020-06-27T15:56:20Z", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaWithTypeVisitor.java", "diffHunk": "@@ -63,12 +68,20 @@\n     List<TypeDescription> fields = record.getChildren();\n     List<String> names = record.getFieldNames();\n     List<T> results = Lists.newArrayListWithExpectedSize(fields.size());\n-    for (TypeDescription field : fields) {\n-      int fieldId = ORCSchemaUtil.fieldId(field);\n-      Types.NestedField iField = struct != null ? struct.field(fieldId) : null;\n+    List<String> includedNames = Lists.newArrayListWithExpectedSize(names.size());\n+    for (int i = 0; i < fields.size(); ++i) {\n+      TypeDescription field = fields.get(i);\n+      String name = names.get(i);\n+      Optional<Integer> fieldId = ORCSchemaUtil.icebergID(field);", "originalCommit": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzMjEzNg==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r447132136", "bodyText": "I generally agree that the visitor should only be concerned with the traversal. However, in this case I think the requirement of having knowledge of the fieldId  was already embedded in this visitor due to traversing the Iceberg schema as well - which seems like it's assumed to be a full conversion of the TypeDescription, if a field was not found instead it would just fail the process.\nI think it'd be better to have a generic OrcSchemaVisitor without context on the Iceberg Schema.", "author": "edgarRd", "createdAt": "2020-06-29T17:23:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0MDE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0MDM0Ng==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r446540346", "bodyText": "Would it make sense to define an OrcSchemaVisitor visitor, similar to org.apache.iceberg.avro.AvroSchemaVisitor.  Here we are not making use of the Iceberg type parameter at all and that could be a little confusing.", "author": "rdsr", "createdAt": "2020-06-27T15:59:03Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +398,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaWithTypeVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {\n+      this.icebergToOrcMapping = icebergToOrcMapping;\n+    }\n \n-        return getIcebergType(icebergID, name, Types.StructType.of(fields), isRequired);\n+    @Override\n+    public Optional<Types.NestedField> record(Types.StructType iStruct, TypeDescription record, List<String> names,\n+                                              List<Optional<Types.NestedField>> fields) {\n+      boolean isRequired = isRequired(record);\n+      Optional<Integer> icebergIdOpt = icebergID(record);\n+      if (!icebergIdOpt.isPresent() || fields.size() == 0) {\n+        return Optional.empty();\n       }\n-      case LIST: {\n-        TypeDescription elementType = orcType.getChildren().get(0);\n-        Types.NestedField element = convertOrcToIceberg(elementType, \"element\", nextID);\n-\n-        Types.ListType listTypeWithElem = isRequired(elementType) ?\n-            Types.ListType.ofRequired(element.fieldId(), element.type()) :\n-            Types.ListType.ofOptional(element.fieldId(), element.type());\n-        return isRequired ?\n-            Types.NestedField.required(icebergID, name, listTypeWithElem) :\n-            Types.NestedField.optional(icebergID, name, listTypeWithElem);\n-      }\n-      case MAP: {\n-        TypeDescription keyType = orcType.getChildren().get(0);\n-        Types.NestedField key = convertOrcToIceberg(keyType, \"key\", nextID);\n-        TypeDescription valueType = orcType.getChildren().get(1);\n-        Types.NestedField value = convertOrcToIceberg(valueType, \"value\", nextID);\n \n-        Types.MapType mapTypeWithKV = isRequired(valueType) ?\n-            Types.MapType.ofRequired(key.fieldId(), value.fieldId(), key.type(), value.type()) :\n-            Types.MapType.ofOptional(key.fieldId(), value.fieldId(), key.type(), value.type());\n+      Types.StructType structType = Types.StructType.of(\n+          fields.stream().filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList()));\n+      return Optional.of(getIcebergType(icebergIdOpt.get(), icebergToOrcMapping.get(icebergIdOpt.get()).name(),\n+          structType, isRequired));\n+    }\n \n-        return getIcebergType(icebergID, name, mapTypeWithKV, isRequired);\n+    @Override\n+    public Optional<Types.NestedField> list(Types.ListType iList, TypeDescription array,\n+                                            Optional<Types.NestedField> element) {\n+      boolean isRequired = isRequired(array);\n+      Optional<Integer> icebergIdOpt = icebergID(array);\n+\n+      if (!icebergIdOpt.isPresent() || !element.isPresent()) {\n+        return Optional.empty();\n       }\n-      default:\n-        // We don't have an answer for union types.\n-        throw new IllegalArgumentException(\"Can't handle \" + orcType);\n+\n+      Types.NestedField foundElement = element.get();\n+      Types.ListType listTypeWithElem = isRequired(array.getChildren().get(0)) ?\n+          Types.ListType.ofRequired(foundElement.fieldId(), foundElement.type()) :\n+          Types.ListType.ofOptional(foundElement.fieldId(), foundElement.type());\n+      return Optional.of(getIcebergType(icebergIdOpt.get(),\n+          icebergToOrcMapping.get(icebergIdOpt.get()).name(), listTypeWithElem, isRequired));\n     }\n-  }\n \n-  private static int getMaxIcebergId(TypeDescription originalOrcSchema) {\n-    int maxId = icebergID(originalOrcSchema).orElse(0);\n-    final List<TypeDescription> children = Optional.ofNullable(originalOrcSchema.getChildren())\n-        .orElse(Collections.emptyList());\n-    for (TypeDescription child : children) {\n-      maxId = Math.max(maxId, getMaxIcebergId(child));\n+    @Override\n+    public Optional<Types.NestedField> map(Types.MapType iMap, TypeDescription map, Optional<Types.NestedField> key,\n+                                           Optional<Types.NestedField> value) {\n+      boolean isRequired = isRequired(map);\n+      Optional<Integer> icebergIdOpt = icebergID(map);\n+\n+      if (!icebergIdOpt.isPresent() || !key.isPresent() || !value.isPresent()) {\n+        return Optional.empty();\n+      }\n+\n+      Types.NestedField foundKey = key.get();\n+      Types.NestedField foundValue = value.get();\n+      Types.MapType mapTypeWithKV = isRequired(map.getChildren().get(1)) ?\n+          Types.MapType.ofRequired(foundKey.fieldId(), foundValue.fieldId(), foundKey.type(), foundValue.type()) :\n+          Types.MapType.ofOptional(foundKey.fieldId(), foundValue.fieldId(), foundKey.type(), foundValue.type());\n+\n+      return Optional.of(getIcebergType(icebergIdOpt.get(), icebergToOrcMapping.get(icebergIdOpt.get()).name(),\n+          mapTypeWithKV, isRequired));\n     }\n \n-    return maxId;\n+    @Override\n+    public Optional<Types.NestedField> primitive(Type.PrimitiveType iPrimitive, TypeDescription primitive) {", "originalCommit": "d66cb470ef45a25c2726bb1255fb3cf4bb981d2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEzMjM4OQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r447132389", "bodyText": "Yeah, I think I can add a OrcSchemaVisitor for this case.", "author": "edgarRd", "createdAt": "2020-06-29T17:23:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU0MDM0Ng=="}], "type": "inlineReview"}, {"oid": "170551c045aee18d167f4cef0c71563ab5a21235", "url": "https://github.com/apache/iceberg/commit/170551c045aee18d167f4cef0c71563ab5a21235", "message": "Update javadoc", "committedDate": "2020-06-29T16:47:01Z", "type": "commit"}, {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80", "url": "https://github.com/apache/iceberg/commit/693a7faf2f754dd7c268901e4ff2d392df365c80", "message": "Add OrcSchemaVisitor", "committedDate": "2020-06-29T17:49:19Z", "type": "commit"}, {"oid": "693a7faf2f754dd7c268901e4ff2d392df365c80", "url": "https://github.com/apache/iceberg/commit/693a7faf2f754dd7c268901e4ff2d392df365c80", "message": "Add OrcSchemaVisitor", "committedDate": "2020-06-29T17:49:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMTc3MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448021771", "bodyText": "Looks like this map is only used to get the ORC field name. Could it be an idToName map instead?", "author": "rdblue", "createdAt": "2020-06-30T22:49:51Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +405,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNjA5MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448026091", "bodyText": "Also, if field names are passed into the record visitor method, why is this needed? The visitor could use a before/after field callback to track names:\nprivate LinkedList<String> fieldNames;\n\npublic beforeField(String name, TypeDescription type) {\n   fieldNames.push(name);\n}\n\npublic afterField(String name, TypeDescription type) {\n  fieldNames.pop();\n}\n\nprivate Strign currentFieldName() {\n  return fieldNames.peek();\n}", "author": "rdblue", "createdAt": "2020-06-30T23:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMTc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMjQ5MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448022491", "bodyText": "I don't think it is necessary to call getIcebergType (which returns a NestedField?).\nIceberg added Types.NestedField.of() that accepts a boolean isOptional so you don't have to call just required or optional. That could be used in place of getIcebergType.", "author": "rdblue", "createdAt": "2020-06-30T22:51:51Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +405,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {\n+      this.icebergToOrcMapping = icebergToOrcMapping;\n+    }\n \n-        return getIcebergType(icebergID, name, Types.StructType.of(fields), isRequired);\n-      }\n-      case LIST: {\n-        TypeDescription elementType = orcType.getChildren().get(0);\n-        Types.NestedField element = convertOrcToIceberg(elementType, \"element\", nextID);\n-\n-        Types.ListType listTypeWithElem = isRequired(elementType) ?\n-            Types.ListType.ofRequired(element.fieldId(), element.type()) :\n-            Types.ListType.ofOptional(element.fieldId(), element.type());\n-        return isRequired ?\n-            Types.NestedField.required(icebergID, name, listTypeWithElem) :\n-            Types.NestedField.optional(icebergID, name, listTypeWithElem);\n+    @Override\n+    public Optional<Types.NestedField> record(TypeDescription record, List<String> names,\n+                                              List<Optional<Types.NestedField>> fields) {\n+      boolean isRequired = isRequired(record);\n+      Optional<Integer> icebergIdOpt = icebergID(record);\n+      if (!icebergIdOpt.isPresent() || fields.size() == 0) {\n+        return Optional.empty();\n       }\n-      case MAP: {\n-        TypeDescription keyType = orcType.getChildren().get(0);\n-        Types.NestedField key = convertOrcToIceberg(keyType, \"key\", nextID);\n-        TypeDescription valueType = orcType.getChildren().get(1);\n-        Types.NestedField value = convertOrcToIceberg(valueType, \"value\", nextID);\n \n-        Types.MapType mapTypeWithKV = isRequired(valueType) ?\n-            Types.MapType.ofRequired(key.fieldId(), value.fieldId(), key.type(), value.type()) :\n-            Types.MapType.ofOptional(key.fieldId(), value.fieldId(), key.type(), value.type());\n+      Types.StructType structType = Types.StructType.of(\n+          fields.stream().filter(Optional::isPresent).map(Optional::get).collect(Collectors.toList()));\n+      return Optional.of(getIcebergType(icebergIdOpt.get(), icebergToOrcMapping.get(icebergIdOpt.get()).name(),\n+          structType, isRequired));\n+    }\n+\n+    @Override\n+    public Optional<Types.NestedField> list(TypeDescription array,\n+                                            Optional<Types.NestedField> element) {\n+      boolean isRequired = isRequired(array);\n+      Optional<Integer> icebergIdOpt = icebergID(array);\n \n-        return getIcebergType(icebergID, name, mapTypeWithKV, isRequired);\n+      if (!icebergIdOpt.isPresent() || !element.isPresent()) {\n+        return Optional.empty();\n       }\n-      default:\n-        // We don't have an answer for union types.\n-        throw new IllegalArgumentException(\"Can't handle \" + orcType);\n+\n+      Types.NestedField foundElement = element.get();\n+      Types.ListType listTypeWithElem = isRequired(array.getChildren().get(0)) ?\n+          Types.ListType.ofRequired(foundElement.fieldId(), foundElement.type()) :\n+          Types.ListType.ofOptional(foundElement.fieldId(), foundElement.type());\n+      return Optional.of(getIcebergType(icebergIdOpt.get(),", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDE1Ng==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024156", "bodyText": "Should this also check that any of the fields are defined?\nif (!icebergIdOpt.isPresent() || !fields.stream().anyMatch(Optional::isPresent)) {\n  return Optional.empty();\n}", "author": "rdblue", "createdAt": "2020-06-30T22:56:38Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -403,114 +405,150 @@ private static boolean isRequired(TypeDescription orcType) {\n         Types.NestedField.optional(icebergID, name, type);\n   }\n \n-  private static Types.NestedField convertOrcToIceberg(TypeDescription orcType, String name,\n-                                                       TypeUtil.NextID nextID) {\n+  private static class OrcToIcebergVisitor extends OrcSchemaVisitor<Optional<Types.NestedField>> {\n \n-    final int icebergID = icebergID(orcType).orElseGet(nextID::get);\n-    final boolean isRequired = isRequired(orcType);\n+    private final Map<Integer, OrcField> icebergToOrcMapping;\n \n-    switch (orcType.getCategory()) {\n-      case BOOLEAN:\n-        return getIcebergType(icebergID, name, Types.BooleanType.get(), isRequired);\n-      case BYTE:\n-      case SHORT:\n-      case INT:\n-        return getIcebergType(icebergID, name, Types.IntegerType.get(), isRequired);\n-      case LONG:\n-        String longAttributeValue = orcType.getAttributeValue(ICEBERG_LONG_TYPE_ATTRIBUTE);\n-        LongType longType = longAttributeValue == null ? LongType.LONG : LongType.valueOf(longAttributeValue);\n-        switch (longType) {\n-          case TIME:\n-            return getIcebergType(icebergID, name, Types.TimeType.get(), isRequired);\n-          case LONG:\n-            return getIcebergType(icebergID, name, Types.LongType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Long type found in ORC type attribute\");\n-        }\n-      case FLOAT:\n-        return getIcebergType(icebergID, name, Types.FloatType.get(), isRequired);\n-      case DOUBLE:\n-        return getIcebergType(icebergID, name, Types.DoubleType.get(), isRequired);\n-      case STRING:\n-      case CHAR:\n-      case VARCHAR:\n-        return getIcebergType(icebergID, name, Types.StringType.get(), isRequired);\n-      case BINARY:\n-        String binaryAttributeValue = orcType.getAttributeValue(ICEBERG_BINARY_TYPE_ATTRIBUTE);\n-        BinaryType binaryType = binaryAttributeValue == null ? BinaryType.BINARY :\n-            BinaryType.valueOf(binaryAttributeValue);\n-        switch (binaryType) {\n-          case UUID:\n-            return getIcebergType(icebergID, name, Types.UUIDType.get(), isRequired);\n-          case FIXED:\n-            int fixedLength = Integer.parseInt(orcType.getAttributeValue(ICEBERG_FIELD_LENGTH));\n-            return getIcebergType(icebergID, name, Types.FixedType.ofLength(fixedLength), isRequired);\n-          case BINARY:\n-            return getIcebergType(icebergID, name, Types.BinaryType.get(), isRequired);\n-          default:\n-            throw new IllegalStateException(\"Invalid Binary type found in ORC type attribute\");\n-        }\n-      case DATE:\n-        return getIcebergType(icebergID, name, Types.DateType.get(), isRequired);\n-      case TIMESTAMP:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withoutZone(), isRequired);\n-      case TIMESTAMP_INSTANT:\n-        return getIcebergType(icebergID, name, Types.TimestampType.withZone(), isRequired);\n-      case DECIMAL:\n-        return getIcebergType(icebergID, name,\n-            Types.DecimalType.of(orcType.getPrecision(), orcType.getScale()),\n-            isRequired);\n-      case STRUCT: {\n-        List<String> fieldNames = orcType.getFieldNames();\n-        List<TypeDescription> fieldTypes = orcType.getChildren();\n-        List<Types.NestedField> fields = new ArrayList<>(fieldNames.size());\n-        for (int c = 0; c < fieldNames.size(); ++c) {\n-          String childName = fieldNames.get(c);\n-          TypeDescription type = fieldTypes.get(c);\n-          Types.NestedField field = convertOrcToIceberg(type, childName, nextID);\n-          fields.add(field);\n-        }\n+    OrcToIcebergVisitor(Map<Integer, OrcField> icebergToOrcMapping) {\n+      this.icebergToOrcMapping = icebergToOrcMapping;\n+    }\n \n-        return getIcebergType(icebergID, name, Types.StructType.of(fields), isRequired);\n-      }\n-      case LIST: {\n-        TypeDescription elementType = orcType.getChildren().get(0);\n-        Types.NestedField element = convertOrcToIceberg(elementType, \"element\", nextID);\n-\n-        Types.ListType listTypeWithElem = isRequired(elementType) ?\n-            Types.ListType.ofRequired(element.fieldId(), element.type()) :\n-            Types.ListType.ofOptional(element.fieldId(), element.type());\n-        return isRequired ?\n-            Types.NestedField.required(icebergID, name, listTypeWithElem) :\n-            Types.NestedField.optional(icebergID, name, listTypeWithElem);\n+    @Override\n+    public Optional<Types.NestedField> record(TypeDescription record, List<String> names,\n+                                              List<Optional<Types.NestedField>> fields) {\n+      boolean isRequired = isRequired(record);\n+      Optional<Integer> icebergIdOpt = icebergID(record);\n+      if (!icebergIdOpt.isPresent() || fields.size() == 0) {", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDI3NQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024275", "bodyText": "Instead of looping over children here, why not just call the visitor on the root orcSchema? Then you could check whether the record was present. If not, throw the exception.", "author": "rdblue", "createdAt": "2020-06-30T22:57:01Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -214,10 +213,13 @@ public static Schema convert(TypeDescription orcSchema) {\n         \"Error in ORC file, children fields and names do not match.\");\n \n     List<Types.NestedField> icebergFields = Lists.newArrayListWithExpectedSize(children.size());\n-    AtomicInteger lastColumnId = new AtomicInteger(getMaxIcebergId(orcSchema));\n-    for (int i = 0; i < children.size(); i++) {\n-      icebergFields.add(convertOrcToIceberg(children.get(i), childrenNames.get(i),\n-          lastColumnId::incrementAndGet));\n+    OrcToIcebergVisitor schemaConverter = new OrcToIcebergVisitor(icebergToOrcMapping(\"root\", orcSchema));\n+    for (TypeDescription child : orcSchema.getChildren()) {\n+      OrcToIcebergVisitor.visit(child, schemaConverter).ifPresent(icebergFields::add);", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4NTYyNg==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448685626", "bodyText": "The root struct of ORC does not have an Iceberg ID, hence this looping. I've moved this to a visitSchema method in the visitor that reuses the code of visitRecord.", "author": "edgarRd", "createdAt": "2020-07-02T00:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDQ2MA==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024460", "bodyText": "I wouldn't refer to the ID annotations as mappings. How about \"ORC schema does not contain Iceberg IDs\"?", "author": "rdblue", "createdAt": "2020-06-30T22:57:35Z", "path": "orc/src/main/java/org/apache/iceberg/orc/ORCSchemaUtil.java", "diffHunk": "@@ -214,10 +213,13 @@ public static Schema convert(TypeDescription orcSchema) {\n         \"Error in ORC file, children fields and names do not match.\");\n \n     List<Types.NestedField> icebergFields = Lists.newArrayListWithExpectedSize(children.size());\n-    AtomicInteger lastColumnId = new AtomicInteger(getMaxIcebergId(orcSchema));\n-    for (int i = 0; i < children.size(); i++) {\n-      icebergFields.add(convertOrcToIceberg(children.get(i), childrenNames.get(i),\n-          lastColumnId::incrementAndGet));\n+    OrcToIcebergVisitor schemaConverter = new OrcToIcebergVisitor(icebergToOrcMapping(\"root\", orcSchema));\n+    for (TypeDescription child : orcSchema.getChildren()) {\n+      OrcToIcebergVisitor.visit(child, schemaConverter).ifPresent(icebergFields::add);\n+    }\n+\n+    if (icebergFields.size() == 0) {\n+      throw new IllegalArgumentException(\"ORC schema has no Iceberg mappings\");", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyNDgwNA==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448024804", "bodyText": "Nit: does this need to be on a separate line?", "author": "rdblue", "createdAt": "2020-06-30T22:58:40Z", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcSchemaVisitor.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.orc;\n+\n+import java.util.List;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.orc.TypeDescription;\n+\n+/**\n+ * Generic visitor of an ORC Schema.\n+ */\n+public abstract class OrcSchemaVisitor<T> {\n+\n+  public static <T> T visit(TypeDescription schema, OrcSchemaVisitor<T> visitor) {\n+    switch (schema.getCategory()) {\n+      case STRUCT:\n+        return visitRecord(schema, visitor);\n+\n+      case UNION:\n+        throw new UnsupportedOperationException(\"Cannot handle \" + schema);\n+\n+      case LIST:\n+        return visitor.list(\n+            schema, visit(schema.getChildren().get(0), visitor));", "originalCommit": "693a7faf2f754dd7c268901e4ff2d392df365c80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "97c0fa447a8bd69eacd1e7883299973f07aa5351", "url": "https://github.com/apache/iceberg/commit/97c0fa447a8bd69eacd1e7883299973f07aa5351", "message": "Use Types.NestedField.of", "committedDate": "2020-07-01T00:39:27Z", "type": "commit"}, {"oid": "79ca745da71444298bd2121affac7e01fecebef9", "url": "https://github.com/apache/iceberg/commit/79ca745da71444298bd2121affac7e01fecebef9", "message": "PR review", "committedDate": "2020-07-01T01:13:08Z", "type": "commit"}, {"oid": "cf39a31bcde820e21db1734ae8a80521a2ece37f", "url": "https://github.com/apache/iceberg/commit/cf39a31bcde820e21db1734ae8a80521a2ece37f", "message": "Create method to visit ORC schema in OrcSchemaVisitor", "committedDate": "2020-07-01T02:00:30Z", "type": "commit"}, {"oid": "9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "url": "https://github.com/apache/iceberg/commit/9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "message": "Track field names in OrcSchemaVisitor", "committedDate": "2020-07-02T00:42:56Z", "type": "commit"}, {"oid": "9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "url": "https://github.com/apache/iceberg/commit/9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "message": "Track field names in OrcSchemaVisitor", "committedDate": "2020-07-02T00:42:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5Mjg1MQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r448692851", "bodyText": "I think this should create an Iceberg schema and assert the two are equal (structs implement equals, so you have to check assertEquals(expected.asStruct(), converted.asStruct()).", "author": "rdblue", "createdAt": "2020-07-02T01:05:59Z", "path": "orc/src/test/java/org/apache/iceberg/orc/TestORCSchemaUtil.java", "diffHunk": "@@ -209,4 +210,39 @@ public void testInvalidTypePromotions() {\n           ORCSchemaUtil.buildOrcProjection(evolveSchema, orcSchema);\n         });\n   }\n+\n+  @Test\n+  public void testSkipNonIcebergColumns() {\n+    TypeDescription schema = TypeDescription.createStruct();\n+    TypeDescription intCol = TypeDescription.createInt();\n+    intCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"1\");\n+    TypeDescription listCol = TypeDescription\n+        .createList(TypeDescription.createMap(TypeDescription.createString(), TypeDescription.createDate()));\n+    listCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"2\");\n+    schema.addField(\"intCol\", intCol);\n+    schema.addField(\"listCol\", listCol);\n+    TypeDescription stringKey = TypeDescription.createString();\n+    stringKey.setAttribute(ICEBERG_ID_ATTRIBUTE, \"3\");\n+    TypeDescription booleanVal = TypeDescription.createBoolean();\n+    booleanVal.setAttribute(ICEBERG_ID_ATTRIBUTE, \"4\");\n+    TypeDescription mapCol = TypeDescription.createMap(stringKey, booleanVal);\n+    mapCol.setAttribute(ICEBERG_ID_ATTRIBUTE, \"5\");\n+    schema.addField(\"mapCol\", mapCol);\n+\n+    Schema icebergSchema = ORCSchemaUtil.convert(schema);\n+    assertEquals(2, icebergSchema.asStruct().fields().size());", "originalCommit": "9a4f68aa7c5e877c85d17b62a3ca051a0a3d94f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3MjI4OQ==", "url": "https://github.com/apache/iceberg/pull/1140#discussion_r449172289", "bodyText": "Done. I've changed the test to compare structs.", "author": "edgarRd", "createdAt": "2020-07-02T17:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5Mjg1MQ=="}], "type": "inlineReview"}, {"oid": "eef07c6bc787ad6b9e8f20af4835f887063115f6", "url": "https://github.com/apache/iceberg/commit/eef07c6bc787ad6b9e8f20af4835f887063115f6", "message": "Compare schemas in test case", "committedDate": "2020-07-02T17:42:59Z", "type": "commit"}, {"oid": "ce01fe593b820bd045598391368cc9d8a4787bf2", "url": "https://github.com/apache/iceberg/commit/ce01fe593b820bd045598391368cc9d8a4787bf2", "message": "Move OrcToIcebergVisitor to separate file", "committedDate": "2020-07-02T17:43:34Z", "type": "commit"}, {"oid": "ce01fe593b820bd045598391368cc9d8a4787bf2", "url": "https://github.com/apache/iceberg/commit/ce01fe593b820bd045598391368cc9d8a4787bf2", "message": "Move OrcToIcebergVisitor to separate file", "committedDate": "2020-07-02T17:43:34Z", "type": "forcePushed"}]}