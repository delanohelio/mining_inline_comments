{"pr_number": 1288, "pr_title": "Update scan planning with DeleteFiles in each task", "pr_createdAt": "2020-08-04T01:45:04Z", "pr_url": "https://github.com/apache/iceberg/pull/1288", "timeline": [{"oid": "238da806888b8294ed6e17aedb0a1db91d449c5b", "url": "https://github.com/apache/iceberg/commit/238da806888b8294ed6e17aedb0a1db91d449c5b", "message": "Add deletes to FileScanTask.", "committedDate": "2020-08-04T01:41:08Z", "type": "commit"}, {"oid": "21402a2ddee157b0ecfb044c6249615d71861e0a", "url": "https://github.com/apache/iceberg/commit/21402a2ddee157b0ecfb044c6249615d71861e0a", "message": "Add DeleteFileIndex to provide access to delete files.", "committedDate": "2020-08-04T01:42:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc1MTQ0NQ==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r464751445", "bodyText": "This was missing and causing tests to fail because manifest entries are copied.", "author": "rdblue", "createdAt": "2020-08-04T01:47:32Z", "path": "core/src/main/java/org/apache/iceberg/GenericManifestEntry.java", "diffHunk": "@@ -45,6 +45,7 @@ private GenericManifestEntry(GenericManifestEntry<F> toCopy, boolean fullCopy) {\n     this.schema = toCopy.schema;\n     this.status = toCopy.status;\n     this.snapshotId = toCopy.snapshotId;\n+    this.sequenceNumber = toCopy.sequenceNumber;", "originalCommit": "21402a2ddee157b0ecfb044c6249615d71861e0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA5Njk3MQ==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465096971", "bodyText": "This is mostly for my understanding: is DeleteFile[] deletes  a mandatory builder param now for file scan tasks? If not, from a v1 / v2 compatibility standpoint would it make sense to add an overloaded constructor?", "author": "prodeezy", "createdAt": "2020-08-04T14:33:38Z", "path": "core/src/main/java/org/apache/iceberg/BaseFileScanTask.java", "diffHunk": "@@ -31,14 +31,17 @@\n \n class BaseFileScanTask implements FileScanTask {\n   private final DataFile file;\n+  private final DeleteFile[] deletes;\n   private final String schemaString;\n   private final String specString;\n   private final ResidualEvaluator residuals;\n \n   private transient PartitionSpec spec = null;\n \n-  BaseFileScanTask(DataFile file, String schemaString, String specString, ResidualEvaluator residuals) {\n+  BaseFileScanTask(DataFile file, DeleteFile[] deletes, String schemaString, String specString,", "originalCommit": "21402a2ddee157b0ecfb044c6249615d71861e0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIyMTIyNA==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465221224", "bodyText": "This implementation and constructor are internal and package-private. The public API is the FileScanTask interface. I went ahead and updated all of the places where we use this, so we don't need to have an overloaded constructor. I think it is better to do it this way so that we ensure that the parameter is always explicit and we aren't accidentally ignoring delete files anywhere.", "author": "rdblue", "createdAt": "2020-08-04T17:43:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTA5Njk3MQ=="}], "type": "inlineReview"}, {"oid": "c6f7155d2a1aab3a03e35910f2407ec8c3ed670a", "url": "https://github.com/apache/iceberg/commit/c6f7155d2a1aab3a03e35910f2407ec8c3ed670a", "message": "Add partition spec ID to DeleteFileIndex.", "committedDate": "2020-08-04T18:07:43Z", "type": "commit"}, {"oid": "0bb2ba1899ded7e0d8a7f1b755908293efe79f3d", "url": "https://github.com/apache/iceberg/commit/0bb2ba1899ded7e0d8a7f1b755908293efe79f3d", "message": "Make unpartitioned equality deletes apply globally.", "committedDate": "2020-08-04T18:49:47Z", "type": "commit"}, {"oid": "43a85a4d54c91d7f767f1fa89ecf718ae02cda84", "url": "https://github.com/apache/iceberg/commit/43a85a4d54c91d7f767f1fa89ecf718ae02cda84", "message": "Add more test cases.", "committedDate": "2020-08-04T21:03:25Z", "type": "commit"}, {"oid": "f8847ba353c36c07dfb9f0f4010815456bebebc1", "url": "https://github.com/apache/iceberg/commit/f8847ba353c36c07dfb9f0f4010815456bebebc1", "message": "Fix checkstyle.", "committedDate": "2020-08-04T21:06:35Z", "type": "commit"}, {"oid": "dbe8740dbd742f73e30ca4959767fef7a964720b", "url": "https://github.com/apache/iceberg/commit/dbe8740dbd742f73e30ca4959767fef7a964720b", "message": "Add more comments to DeleteFileIndex.", "committedDate": "2020-08-04T21:17:19Z", "type": "commit"}, {"oid": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8", "url": "https://github.com/apache/iceberg/commit/2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8", "message": "Fix checkstyle.", "committedDate": "2020-08-05T01:04:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NTk3Ng==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465865976", "bodyText": "nit: would it make sense to split this into two lines?", "author": "aokolnychyi", "createdAt": "2020-08-05T16:50:33Z", "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(\n+      () -> StructLikeWrapper.wrap(null));\n+\n+  DeleteFileIndex(long[] globalSeqs, DeleteFile[] globalDeletes,\n+                  Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition) {\n+    this.globalSeqs = globalSeqs;\n+    this.globalDeletes = globalDeletes;\n+    this.sortedDeletesByPartition = sortedDeletesByPartition;\n+  }\n+\n+  DeleteFile[] forEntry(int specId, ManifestEntry<DataFile> entry) {\n+    return forDataFile(specId, entry.sequenceNumber(), entry.file());\n+  }\n+\n+  DeleteFile[] forDataFile(int specId, long sequenceNumber, DataFile file) {\n+    Pair<long[], DeleteFile[]> partitionDeletes = sortedDeletesByPartition\n+        .get(Pair.of(specId, lookupWrapper.get().set(file.partition())));", "originalCommit": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMDc2OA==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465910768", "bodyText": "Will do.", "author": "rdblue", "createdAt": "2020-08-05T18:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg2NTk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDAxMQ==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465870011", "bodyText": "Do we need ThreadLocal as we plan jobs using multiple threads?", "author": "aokolnychyi", "createdAt": "2020-08-05T16:57:10Z", "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(", "originalCommit": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MTAxNg==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465871016", "bodyText": "Why we cannot just construct Pair in forDataFile using file.partition()?", "author": "aokolnychyi", "createdAt": "2020-08-05T16:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDAxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMDUwNw==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465910507", "bodyText": "We need to wrap file.partition() in an object that implements hashCode and equals consistently, or else PartitionKey and Record might get compared and not be considered equal.\nAll of the partitions in sortedDeletesByPartition are already wrapped, but we need a wrapper for the lookups. Because forEntry is usually called from a thread pool that is scanning manifests in parallel, we can't use the same wrapper. That's why we use a thread-local one.\nIdeally, we'd reuse the Pair as well, but it doesn't support that.", "author": "rdblue", "createdAt": "2020-08-05T18:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg3MDAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4MjcyMg==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465882722", "bodyText": "We iterate through delete files twice because we don't anticipate too many global delete files?", "author": "aokolnychyi", "createdAt": "2020-08-05T17:18:47Z", "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(\n+      () -> StructLikeWrapper.wrap(null));\n+\n+  DeleteFileIndex(long[] globalSeqs, DeleteFile[] globalDeletes,\n+                  Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition) {\n+    this.globalSeqs = globalSeqs;\n+    this.globalDeletes = globalDeletes;\n+    this.sortedDeletesByPartition = sortedDeletesByPartition;\n+  }\n+\n+  DeleteFile[] forEntry(int specId, ManifestEntry<DataFile> entry) {\n+    return forDataFile(specId, entry.sequenceNumber(), entry.file());\n+  }\n+\n+  DeleteFile[] forDataFile(int specId, long sequenceNumber, DataFile file) {\n+    Pair<long[], DeleteFile[]> partitionDeletes = sortedDeletesByPartition\n+        .get(Pair.of(specId, lookupWrapper.get().set(file.partition())));\n+\n+    if (partitionDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes);\n+    } else if (globalDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second());\n+    } else {\n+      return Stream.concat(\n+          Stream.of(limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes)),\n+          Stream.of(limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second()))\n+      ).toArray(DeleteFile[]::new);\n+    }\n+  }\n+\n+  private static DeleteFile[] limitBySequenceNumber(long sequenceNumber, long[] seqs, DeleteFile[] files) {\n+    if (files == null) {\n+      return NO_DELETE_FILES;\n+    }\n+\n+    int pos = Arrays.binarySearch(seqs, sequenceNumber);\n+    int start;\n+    if (pos < 0) {\n+      // the sequence number was not found, where it would be inserted is -(pos + 1)\n+      start = -(pos + 1);\n+    } else {\n+      // the sequence number was found, but may not be the first\n+      // find the first delete file with the given sequence number by decrementing the position\n+      start = pos;\n+      while (start > 0 && seqs[start - 1] >= sequenceNumber) {\n+        start -= 1;\n+      }\n+    }\n+\n+    return Arrays.copyOfRange(files, start, files.length);\n+  }\n+\n+  static Builder builderFor(FileIO io, Iterable<ManifestFile> deleteManifests) {\n+    return new Builder(io, Sets.newHashSet(deleteManifests));\n+  }\n+\n+  static class Builder {\n+    private final FileIO io;\n+    private final Set<ManifestFile> deleteManifests;\n+    private Map<Integer, PartitionSpec> specsById;\n+    private Expression dataFilter;\n+    private Expression partitionFilter;\n+    private boolean caseSensitive;\n+    private ExecutorService executorService;\n+\n+    Builder(FileIO io, Set<ManifestFile> deleteManifests) {\n+      this.io = io;\n+      this.deleteManifests = Sets.newHashSet(deleteManifests);\n+      this.specsById = null;\n+      this.dataFilter = Expressions.alwaysTrue();\n+      this.partitionFilter = Expressions.alwaysTrue();\n+      this.caseSensitive = true;\n+      this.executorService = null;\n+    }\n+\n+    Builder specsById(Map<Integer, PartitionSpec> newSpecsById) {\n+      this.specsById = newSpecsById;\n+      return this;\n+    }\n+\n+    Builder filterData(Expression newDataFilter) {\n+      this.dataFilter = Expressions.and(dataFilter, newDataFilter);\n+      return this;\n+    }\n+\n+    Builder filterPartitions(Expression newPartitionFilter) {\n+      this.partitionFilter = Expressions.and(partitionFilter, newPartitionFilter);\n+      return this;\n+    }\n+\n+    Builder caseSensitive(boolean newCaseSensitive) {\n+      this.caseSensitive = newCaseSensitive;\n+      return this;\n+    }\n+\n+    Builder planWith(ExecutorService newExecutorService) {\n+      this.executorService = newExecutorService;\n+      return this;\n+    }\n+\n+    DeleteFileIndex build() {\n+      // read all of the matching delete manifests in parallel and accumulate the matching files in a queue\n+      Queue<Pair<Integer, ManifestEntry<DeleteFile>>> deleteEntries = new ConcurrentLinkedQueue<>();\n+      Tasks.foreach(deleteManifestReaders())\n+          .stopOnFailure().throwFailureWhenFinished()\n+          .executeWith(executorService)\n+          .run(specIdAndReader -> {\n+            try (CloseableIterable<ManifestEntry<DeleteFile>> reader = specIdAndReader.second()) {\n+              for (ManifestEntry<DeleteFile> entry : reader) {\n+                // copy with stats for better filtering against data file stats\n+                deleteEntries.add(Pair.of(specIdAndReader.first(), entry.copy()));\n+              }\n+            } catch (IOException e) {\n+              throw new RuntimeIOException(\"Failed to close\", e);\n+            }\n+          });\n+\n+      // build a map from (specId, partition) to delete file entries\n+      ListMultimap<Pair<Integer, StructLikeWrapper>, ManifestEntry<DeleteFile>> deleteFilesByPartition =\n+          Multimaps.newListMultimap(Maps.newHashMap(), Lists::newArrayList);\n+      for (Pair<Integer, ManifestEntry<DeleteFile>> specIdAndEntry : deleteEntries) {\n+        int specId = specIdAndEntry.first();\n+        ManifestEntry<DeleteFile> entry = specIdAndEntry.second();\n+        deleteFilesByPartition.put(Pair.of(specId, StructLikeWrapper.wrap(entry.file().partition())), entry);\n+      }\n+\n+      // sort the entries in each map value by sequence number and split into sequence numbers and delete files lists\n+      Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition = Maps.newHashMap();\n+      // also, separate out equality deletes in an unpartitioned spec that should be applied globally\n+      long[] globalApplySeqs = null;\n+      DeleteFile[] globalDeletes = null;\n+      for (Pair<Integer, StructLikeWrapper> partition : deleteFilesByPartition.keySet()) {\n+        if (specsById.get(partition.first()).isUnpartitioned()) {\n+          Preconditions.checkState(globalDeletes == null, \"Detected multiple partition specs with no partitions\");\n+\n+          List<Pair<Long, DeleteFile>> eqFilesSortedBySeq = deleteFilesByPartition.get(partition).stream()", "originalCommit": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMzIwMA==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465913200", "bodyText": "That's right.", "author": "rdblue", "createdAt": "2020-08-05T18:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4MjcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4NDg1OQ==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465884859", "bodyText": "Why do we treat positional and equality deletes differently? Is it because the equality delete should not delete data in the snapshot it was added?", "author": "aokolnychyi", "createdAt": "2020-08-05T17:22:35Z", "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(\n+      () -> StructLikeWrapper.wrap(null));\n+\n+  DeleteFileIndex(long[] globalSeqs, DeleteFile[] globalDeletes,\n+                  Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition) {\n+    this.globalSeqs = globalSeqs;\n+    this.globalDeletes = globalDeletes;\n+    this.sortedDeletesByPartition = sortedDeletesByPartition;\n+  }\n+\n+  DeleteFile[] forEntry(int specId, ManifestEntry<DataFile> entry) {\n+    return forDataFile(specId, entry.sequenceNumber(), entry.file());\n+  }\n+\n+  DeleteFile[] forDataFile(int specId, long sequenceNumber, DataFile file) {\n+    Pair<long[], DeleteFile[]> partitionDeletes = sortedDeletesByPartition\n+        .get(Pair.of(specId, lookupWrapper.get().set(file.partition())));\n+\n+    if (partitionDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes);\n+    } else if (globalDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second());\n+    } else {\n+      return Stream.concat(\n+          Stream.of(limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes)),\n+          Stream.of(limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second()))\n+      ).toArray(DeleteFile[]::new);\n+    }\n+  }\n+\n+  private static DeleteFile[] limitBySequenceNumber(long sequenceNumber, long[] seqs, DeleteFile[] files) {\n+    if (files == null) {\n+      return NO_DELETE_FILES;\n+    }\n+\n+    int pos = Arrays.binarySearch(seqs, sequenceNumber);\n+    int start;\n+    if (pos < 0) {\n+      // the sequence number was not found, where it would be inserted is -(pos + 1)\n+      start = -(pos + 1);\n+    } else {\n+      // the sequence number was found, but may not be the first\n+      // find the first delete file with the given sequence number by decrementing the position\n+      start = pos;\n+      while (start > 0 && seqs[start - 1] >= sequenceNumber) {\n+        start -= 1;\n+      }\n+    }\n+\n+    return Arrays.copyOfRange(files, start, files.length);\n+  }\n+\n+  static Builder builderFor(FileIO io, Iterable<ManifestFile> deleteManifests) {\n+    return new Builder(io, Sets.newHashSet(deleteManifests));\n+  }\n+\n+  static class Builder {\n+    private final FileIO io;\n+    private final Set<ManifestFile> deleteManifests;\n+    private Map<Integer, PartitionSpec> specsById;\n+    private Expression dataFilter;\n+    private Expression partitionFilter;\n+    private boolean caseSensitive;\n+    private ExecutorService executorService;\n+\n+    Builder(FileIO io, Set<ManifestFile> deleteManifests) {\n+      this.io = io;\n+      this.deleteManifests = Sets.newHashSet(deleteManifests);\n+      this.specsById = null;\n+      this.dataFilter = Expressions.alwaysTrue();\n+      this.partitionFilter = Expressions.alwaysTrue();\n+      this.caseSensitive = true;\n+      this.executorService = null;\n+    }\n+\n+    Builder specsById(Map<Integer, PartitionSpec> newSpecsById) {\n+      this.specsById = newSpecsById;\n+      return this;\n+    }\n+\n+    Builder filterData(Expression newDataFilter) {\n+      this.dataFilter = Expressions.and(dataFilter, newDataFilter);\n+      return this;\n+    }\n+\n+    Builder filterPartitions(Expression newPartitionFilter) {\n+      this.partitionFilter = Expressions.and(partitionFilter, newPartitionFilter);\n+      return this;\n+    }\n+\n+    Builder caseSensitive(boolean newCaseSensitive) {\n+      this.caseSensitive = newCaseSensitive;\n+      return this;\n+    }\n+\n+    Builder planWith(ExecutorService newExecutorService) {\n+      this.executorService = newExecutorService;\n+      return this;\n+    }\n+\n+    DeleteFileIndex build() {\n+      // read all of the matching delete manifests in parallel and accumulate the matching files in a queue\n+      Queue<Pair<Integer, ManifestEntry<DeleteFile>>> deleteEntries = new ConcurrentLinkedQueue<>();\n+      Tasks.foreach(deleteManifestReaders())\n+          .stopOnFailure().throwFailureWhenFinished()\n+          .executeWith(executorService)\n+          .run(specIdAndReader -> {\n+            try (CloseableIterable<ManifestEntry<DeleteFile>> reader = specIdAndReader.second()) {\n+              for (ManifestEntry<DeleteFile> entry : reader) {\n+                // copy with stats for better filtering against data file stats\n+                deleteEntries.add(Pair.of(specIdAndReader.first(), entry.copy()));\n+              }\n+            } catch (IOException e) {\n+              throw new RuntimeIOException(\"Failed to close\", e);\n+            }\n+          });\n+\n+      // build a map from (specId, partition) to delete file entries\n+      ListMultimap<Pair<Integer, StructLikeWrapper>, ManifestEntry<DeleteFile>> deleteFilesByPartition =\n+          Multimaps.newListMultimap(Maps.newHashMap(), Lists::newArrayList);\n+      for (Pair<Integer, ManifestEntry<DeleteFile>> specIdAndEntry : deleteEntries) {\n+        int specId = specIdAndEntry.first();\n+        ManifestEntry<DeleteFile> entry = specIdAndEntry.second();\n+        deleteFilesByPartition.put(Pair.of(specId, StructLikeWrapper.wrap(entry.file().partition())), entry);\n+      }\n+\n+      // sort the entries in each map value by sequence number and split into sequence numbers and delete files lists\n+      Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition = Maps.newHashMap();\n+      // also, separate out equality deletes in an unpartitioned spec that should be applied globally\n+      long[] globalApplySeqs = null;\n+      DeleteFile[] globalDeletes = null;\n+      for (Pair<Integer, StructLikeWrapper> partition : deleteFilesByPartition.keySet()) {\n+        if (specsById.get(partition.first()).isUnpartitioned()) {\n+          Preconditions.checkState(globalDeletes == null, \"Detected multiple partition specs with no partitions\");\n+\n+          List<Pair<Long, DeleteFile>> eqFilesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .filter(entry -> entry.file().content() == FileContent.EQUALITY_DELETES)\n+              .map(entry ->\n+                  // a delete file is indexed by the sequence number it should be applied to\n+                  Pair.of(entry.sequenceNumber() - 1, entry.file()))\n+              .sorted(Comparator.comparingLong(Pair::first))\n+              .collect(Collectors.toList());\n+\n+          globalApplySeqs = eqFilesSortedBySeq.stream().mapToLong(Pair::first).toArray();\n+          globalDeletes = eqFilesSortedBySeq.stream().map(Pair::second).toArray(DeleteFile[]::new);\n+\n+          List<Pair<Long, DeleteFile>> posFilesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .filter(entry -> entry.file().content() == FileContent.POSITION_DELETES)\n+              .map(entry -> Pair.of(entry.sequenceNumber(), entry.file()))\n+              .sorted(Comparator.comparingLong(Pair::first))\n+              .collect(Collectors.toList());\n+\n+          long[] seqs = posFilesSortedBySeq.stream().mapToLong(Pair::first).toArray();\n+          DeleteFile[] files = posFilesSortedBySeq.stream().map(Pair::second).toArray(DeleteFile[]::new);\n+\n+          sortedDeletesByPartition.put(partition, Pair.of(seqs, files));\n+\n+        } else {\n+          List<Pair<Long, DeleteFile>> filesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .map(entry -> {\n+                // a delete file is indexed by the sequence number it should be applied to\n+                long applySeq = entry.sequenceNumber() -\n+                    (entry.file().content() == FileContent.EQUALITY_DELETES ? 1 : 0);", "originalCommit": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNDU2Nw==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465914567", "bodyText": "Exactly.\nIf you want to replace a row with an equality delete, then the delete must apply to data before the snapshot is committed. Otherwise, you'd delete the row that you're writing as a replacement because the delete is not targeted to a file/position within a partition.\nWe can support same-sequence-number deletes for positional deletes because they target specific rows in files. And, supporting this is how we can delete within a checkpoint for streaming use cases when we encounter the same record twice.", "author": "rdblue", "createdAt": "2020-08-05T18:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4NDg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4OTc5Ng==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465889796", "bodyText": "Does this cover cases when all delete files or none match? I think Arrays.copyOfRange will throw an exception if from > original.length.", "author": "aokolnychyi", "createdAt": "2020-08-05T17:31:11Z", "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(\n+      () -> StructLikeWrapper.wrap(null));\n+\n+  DeleteFileIndex(long[] globalSeqs, DeleteFile[] globalDeletes,\n+                  Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition) {\n+    this.globalSeqs = globalSeqs;\n+    this.globalDeletes = globalDeletes;\n+    this.sortedDeletesByPartition = sortedDeletesByPartition;\n+  }\n+\n+  DeleteFile[] forEntry(int specId, ManifestEntry<DataFile> entry) {\n+    return forDataFile(specId, entry.sequenceNumber(), entry.file());\n+  }\n+\n+  DeleteFile[] forDataFile(int specId, long sequenceNumber, DataFile file) {\n+    Pair<long[], DeleteFile[]> partitionDeletes = sortedDeletesByPartition\n+        .get(Pair.of(specId, lookupWrapper.get().set(file.partition())));\n+\n+    if (partitionDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes);\n+    } else if (globalDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second());\n+    } else {\n+      return Stream.concat(\n+          Stream.of(limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes)),\n+          Stream.of(limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second()))\n+      ).toArray(DeleteFile[]::new);\n+    }\n+  }\n+\n+  private static DeleteFile[] limitBySequenceNumber(long sequenceNumber, long[] seqs, DeleteFile[] files) {\n+    if (files == null) {\n+      return NO_DELETE_FILES;\n+    }\n+\n+    int pos = Arrays.binarySearch(seqs, sequenceNumber);\n+    int start;\n+    if (pos < 0) {\n+      // the sequence number was not found, where it would be inserted is -(pos + 1)\n+      start = -(pos + 1);", "originalCommit": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMzA3Ng==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465913076", "bodyText": "Yes, and the tests validate these cases.\nIf the sequence number is not found and less than all of the sequence numbers in the array, then the insert position is 0 and the pos returned is -(0 + 1) = -1. Converting back to a start position -(-1 + 1) = 0, so we copy the entire array. Similarly, if the sequence number is greater than all of the numbers in the array, the return values is length, which results in copyOfRange(files, length, length) and produces a 0-length array.", "author": "rdblue", "createdAt": "2020-08-05T18:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg4OTc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5MzE2MQ==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465893161", "bodyText": "To confirm: we will use partition predicates to prune delete manifests and data predicates to filter out delete files similarly to what we have for data file?", "author": "aokolnychyi", "createdAt": "2020-08-05T17:37:17Z", "path": "core/src/main/java/org/apache/iceberg/DeleteFileIndex.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg;\n+\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutorService;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.iceberg.exceptions.RuntimeIOException;\n+import org.apache.iceberg.expressions.Expression;\n+import org.apache.iceberg.expressions.Expressions;\n+import org.apache.iceberg.expressions.ManifestEvaluator;\n+import org.apache.iceberg.expressions.Projections;\n+import org.apache.iceberg.io.CloseableIterable;\n+import org.apache.iceberg.io.FileIO;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;\n+import org.apache.iceberg.relocated.com.google.common.collect.Lists;\n+import org.apache.iceberg.relocated.com.google.common.collect.Maps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;\n+import org.apache.iceberg.relocated.com.google.common.collect.Sets;\n+import org.apache.iceberg.util.Pair;\n+import org.apache.iceberg.util.StructLikeWrapper;\n+import org.apache.iceberg.util.Tasks;\n+\n+/**\n+ * An index of {@link DeleteFile delete files} by sequence number.\n+ * <p>\n+ * Use {@link #builderFor(FileIO, Iterable)} to construct an index, and {@link #forDataFile(int, long, DataFile)} or\n+ * {@link #forEntry(int, ManifestEntry)} to get the the delete files to apply to a given data file.\n+ */\n+class DeleteFileIndex {\n+  private static final DeleteFile[] NO_DELETE_FILES = new DeleteFile[0];\n+\n+  private final long[] globalSeqs;\n+  private final DeleteFile[] globalDeletes;\n+  private final Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition;\n+  private final ThreadLocal<StructLikeWrapper> lookupWrapper = ThreadLocal.withInitial(\n+      () -> StructLikeWrapper.wrap(null));\n+\n+  DeleteFileIndex(long[] globalSeqs, DeleteFile[] globalDeletes,\n+                  Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition) {\n+    this.globalSeqs = globalSeqs;\n+    this.globalDeletes = globalDeletes;\n+    this.sortedDeletesByPartition = sortedDeletesByPartition;\n+  }\n+\n+  DeleteFile[] forEntry(int specId, ManifestEntry<DataFile> entry) {\n+    return forDataFile(specId, entry.sequenceNumber(), entry.file());\n+  }\n+\n+  DeleteFile[] forDataFile(int specId, long sequenceNumber, DataFile file) {\n+    Pair<long[], DeleteFile[]> partitionDeletes = sortedDeletesByPartition\n+        .get(Pair.of(specId, lookupWrapper.get().set(file.partition())));\n+\n+    if (partitionDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes);\n+    } else if (globalDeletes == null) {\n+      return limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second());\n+    } else {\n+      return Stream.concat(\n+          Stream.of(limitBySequenceNumber(sequenceNumber, globalSeqs, globalDeletes)),\n+          Stream.of(limitBySequenceNumber(sequenceNumber, partitionDeletes.first(), partitionDeletes.second()))\n+      ).toArray(DeleteFile[]::new);\n+    }\n+  }\n+\n+  private static DeleteFile[] limitBySequenceNumber(long sequenceNumber, long[] seqs, DeleteFile[] files) {\n+    if (files == null) {\n+      return NO_DELETE_FILES;\n+    }\n+\n+    int pos = Arrays.binarySearch(seqs, sequenceNumber);\n+    int start;\n+    if (pos < 0) {\n+      // the sequence number was not found, where it would be inserted is -(pos + 1)\n+      start = -(pos + 1);\n+    } else {\n+      // the sequence number was found, but may not be the first\n+      // find the first delete file with the given sequence number by decrementing the position\n+      start = pos;\n+      while (start > 0 && seqs[start - 1] >= sequenceNumber) {\n+        start -= 1;\n+      }\n+    }\n+\n+    return Arrays.copyOfRange(files, start, files.length);\n+  }\n+\n+  static Builder builderFor(FileIO io, Iterable<ManifestFile> deleteManifests) {\n+    return new Builder(io, Sets.newHashSet(deleteManifests));\n+  }\n+\n+  static class Builder {\n+    private final FileIO io;\n+    private final Set<ManifestFile> deleteManifests;\n+    private Map<Integer, PartitionSpec> specsById;\n+    private Expression dataFilter;\n+    private Expression partitionFilter;\n+    private boolean caseSensitive;\n+    private ExecutorService executorService;\n+\n+    Builder(FileIO io, Set<ManifestFile> deleteManifests) {\n+      this.io = io;\n+      this.deleteManifests = Sets.newHashSet(deleteManifests);\n+      this.specsById = null;\n+      this.dataFilter = Expressions.alwaysTrue();\n+      this.partitionFilter = Expressions.alwaysTrue();\n+      this.caseSensitive = true;\n+      this.executorService = null;\n+    }\n+\n+    Builder specsById(Map<Integer, PartitionSpec> newSpecsById) {\n+      this.specsById = newSpecsById;\n+      return this;\n+    }\n+\n+    Builder filterData(Expression newDataFilter) {\n+      this.dataFilter = Expressions.and(dataFilter, newDataFilter);\n+      return this;\n+    }\n+\n+    Builder filterPartitions(Expression newPartitionFilter) {\n+      this.partitionFilter = Expressions.and(partitionFilter, newPartitionFilter);\n+      return this;\n+    }\n+\n+    Builder caseSensitive(boolean newCaseSensitive) {\n+      this.caseSensitive = newCaseSensitive;\n+      return this;\n+    }\n+\n+    Builder planWith(ExecutorService newExecutorService) {\n+      this.executorService = newExecutorService;\n+      return this;\n+    }\n+\n+    DeleteFileIndex build() {\n+      // read all of the matching delete manifests in parallel and accumulate the matching files in a queue\n+      Queue<Pair<Integer, ManifestEntry<DeleteFile>>> deleteEntries = new ConcurrentLinkedQueue<>();\n+      Tasks.foreach(deleteManifestReaders())\n+          .stopOnFailure().throwFailureWhenFinished()\n+          .executeWith(executorService)\n+          .run(specIdAndReader -> {\n+            try (CloseableIterable<ManifestEntry<DeleteFile>> reader = specIdAndReader.second()) {\n+              for (ManifestEntry<DeleteFile> entry : reader) {\n+                // copy with stats for better filtering against data file stats\n+                deleteEntries.add(Pair.of(specIdAndReader.first(), entry.copy()));\n+              }\n+            } catch (IOException e) {\n+              throw new RuntimeIOException(\"Failed to close\", e);\n+            }\n+          });\n+\n+      // build a map from (specId, partition) to delete file entries\n+      ListMultimap<Pair<Integer, StructLikeWrapper>, ManifestEntry<DeleteFile>> deleteFilesByPartition =\n+          Multimaps.newListMultimap(Maps.newHashMap(), Lists::newArrayList);\n+      for (Pair<Integer, ManifestEntry<DeleteFile>> specIdAndEntry : deleteEntries) {\n+        int specId = specIdAndEntry.first();\n+        ManifestEntry<DeleteFile> entry = specIdAndEntry.second();\n+        deleteFilesByPartition.put(Pair.of(specId, StructLikeWrapper.wrap(entry.file().partition())), entry);\n+      }\n+\n+      // sort the entries in each map value by sequence number and split into sequence numbers and delete files lists\n+      Map<Pair<Integer, StructLikeWrapper>, Pair<long[], DeleteFile[]>> sortedDeletesByPartition = Maps.newHashMap();\n+      // also, separate out equality deletes in an unpartitioned spec that should be applied globally\n+      long[] globalApplySeqs = null;\n+      DeleteFile[] globalDeletes = null;\n+      for (Pair<Integer, StructLikeWrapper> partition : deleteFilesByPartition.keySet()) {\n+        if (specsById.get(partition.first()).isUnpartitioned()) {\n+          Preconditions.checkState(globalDeletes == null, \"Detected multiple partition specs with no partitions\");\n+\n+          List<Pair<Long, DeleteFile>> eqFilesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .filter(entry -> entry.file().content() == FileContent.EQUALITY_DELETES)\n+              .map(entry ->\n+                  // a delete file is indexed by the sequence number it should be applied to\n+                  Pair.of(entry.sequenceNumber() - 1, entry.file()))\n+              .sorted(Comparator.comparingLong(Pair::first))\n+              .collect(Collectors.toList());\n+\n+          globalApplySeqs = eqFilesSortedBySeq.stream().mapToLong(Pair::first).toArray();\n+          globalDeletes = eqFilesSortedBySeq.stream().map(Pair::second).toArray(DeleteFile[]::new);\n+\n+          List<Pair<Long, DeleteFile>> posFilesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .filter(entry -> entry.file().content() == FileContent.POSITION_DELETES)\n+              .map(entry -> Pair.of(entry.sequenceNumber(), entry.file()))\n+              .sorted(Comparator.comparingLong(Pair::first))\n+              .collect(Collectors.toList());\n+\n+          long[] seqs = posFilesSortedBySeq.stream().mapToLong(Pair::first).toArray();\n+          DeleteFile[] files = posFilesSortedBySeq.stream().map(Pair::second).toArray(DeleteFile[]::new);\n+\n+          sortedDeletesByPartition.put(partition, Pair.of(seqs, files));\n+\n+        } else {\n+          List<Pair<Long, DeleteFile>> filesSortedBySeq = deleteFilesByPartition.get(partition).stream()\n+              .map(entry -> {\n+                // a delete file is indexed by the sequence number it should be applied to\n+                long applySeq = entry.sequenceNumber() -\n+                    (entry.file().content() == FileContent.EQUALITY_DELETES ? 1 : 0);\n+                return Pair.of(applySeq, entry.file());\n+              })\n+              .sorted(Comparator.comparingLong(Pair::first))\n+              .collect(Collectors.toList());\n+\n+          long[] seqs = filesSortedBySeq.stream().mapToLong(Pair::first).toArray();\n+          DeleteFile[] files = filesSortedBySeq.stream().map(Pair::second).toArray(DeleteFile[]::new);\n+\n+          sortedDeletesByPartition.put(partition, Pair.of(seqs, files));\n+        }\n+      }\n+\n+      return new DeleteFileIndex(globalApplySeqs, globalDeletes, sortedDeletesByPartition);\n+    }\n+\n+    private Iterable<Pair<Integer, CloseableIterable<ManifestEntry<DeleteFile>>>> deleteManifestReaders() {\n+      LoadingCache<Integer, ManifestEvaluator> evalCache = specsById == null ? null :\n+          Caffeine.newBuilder().build(specId -> {\n+            PartitionSpec spec = specsById.get(specId);\n+            return ManifestEvaluator.forPartitionFilter(\n+                Expressions.and(partitionFilter, Projections.inclusive(spec, caseSensitive).project(dataFilter)),\n+                spec, caseSensitive);\n+          });\n+\n+      Iterable<ManifestFile> matchingManifests = evalCache == null ? deleteManifests :\n+          Iterables.filter(deleteManifests, manifest ->\n+              manifest.content() == ManifestContent.DELETES &&\n+                  (manifest.hasAddedFiles() || manifest.hasDeletedFiles()) &&\n+                  evalCache.get(manifest.partitionSpecId()).eval(manifest));\n+\n+      return Iterables.transform(\n+          matchingManifests,\n+          manifest -> Pair.of(\n+              manifest.partitionSpecId(),\n+              ManifestFiles.readDeleteManifest(manifest, io, specsById)", "originalCommit": "2dc29b5b899b6313956cbd2a4055a2cd0b84f0b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxNTQ4NA==", "url": "https://github.com/apache/iceberg/pull/1288#discussion_r465915484", "bodyText": "Yes, that's why the same partition and data filters are passed to match delete files here, and why we use the same eval cache to filter delete manifests.\nWe can add more filtering eventually. For example, when we know what the stats columns for a positional delete file are, we can make sure that each data file is actually within that stats range for the filename column. But we'll add those later, since we don't have delete file readers/writers done quite yet.", "author": "rdblue", "createdAt": "2020-08-05T18:17:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTg5MzE2MQ=="}], "type": "inlineReview"}, {"oid": "557f899abcd07f26aa85213505f397521d3aa037", "url": "https://github.com/apache/iceberg/commit/557f899abcd07f26aa85213505f397521d3aa037", "message": "Fix readability in DeleteFileIndex.", "committedDate": "2020-08-05T18:36:46Z", "type": "commit"}]}