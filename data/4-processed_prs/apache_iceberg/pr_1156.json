{"pr_number": 1156, "pr_title": "Add Spark 3 SQL tests", "pr_createdAt": "2020-07-01T18:04:32Z", "pr_url": "https://github.com/apache/iceberg/pull/1156", "timeline": [{"oid": "d9da5e4c57d49dc590cd3b131941feec1e2183f4", "url": "https://github.com/apache/iceberg/commit/d9da5e4c57d49dc590cd3b131941feec1e2183f4", "message": "Spark: Add tests for create and alter table.", "committedDate": "2020-07-01T20:52:46Z", "type": "forcePushed"}, {"oid": "b88ec468f67a4edfc0e5532c7af68e5a621c37f2", "url": "https://github.com/apache/iceberg/commit/b88ec468f67a4edfc0e5532c7af68e5a621c37f2", "message": "Add write tests.", "committedDate": "2020-07-01T22:51:26Z", "type": "forcePushed"}, {"oid": "a2dafe1da7805681593c7f5fa2c673c6a3adaf11", "url": "https://github.com/apache/iceberg/commit/a2dafe1da7805681593c7f5fa2c673c6a3adaf11", "message": "Spark: Add tests for create, alter, insert, and select.", "committedDate": "2020-07-01T23:48:43Z", "type": "commit"}, {"oid": "d2bc1da8117de6923793ed456f55c3f205a289f4", "url": "https://github.com/apache/iceberg/commit/d2bc1da8117de6923793ed456f55c3f205a289f4", "message": "Add CTAS tests.", "committedDate": "2020-07-02T00:33:12Z", "type": "commit"}, {"oid": "d2bc1da8117de6923793ed456f55c3f205a289f4", "url": "https://github.com/apache/iceberg/commit/d2bc1da8117de6923793ed456f55c3f205a289f4", "message": "Add CTAS tests.", "committedDate": "2020-07-02T00:33:12Z", "type": "forcePushed"}, {"oid": "5c9b92954be103e71d2d965bdf8a29e68e9ed10e", "url": "https://github.com/apache/iceberg/commit/5c9b92954be103e71d2d965bdf8a29e68e9ed10e", "message": "Fix checkstyle and Hive replace table tests.", "committedDate": "2020-07-02T00:45:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4ODI4NA==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r448688284", "bodyText": "You can probably take this out of the if...else since it's repeated and has to be done on either case.", "author": "edgarRd", "createdAt": "2020-07-02T00:48:09Z", "path": "core/src/main/java/org/apache/iceberg/BaseMetastoreCatalog.java", "diffHunk": "@@ -110,9 +110,17 @@ public Transaction newReplaceTableTransaction(\n       throw new NoSuchTableException(\"No such table: \" + identifier);\n     }\n \n-    String baseLocation = location != null ? location : defaultWarehouseLocation(identifier);\n-    Map<String, String> tableProperties = properties != null ? properties : Maps.newHashMap();\n-    TableMetadata metadata = TableMetadata.newTableMetadata(schema, spec, baseLocation, tableProperties);\n+    TableMetadata metadata;\n+    if (ops.current() != null) {\n+      String baseLocation = location != null ? location : ops.current().location();\n+      Map<String, String> tableProperties = properties != null ? properties : Maps.newHashMap();\n+      metadata = ops.current().buildReplacement(schema, spec, baseLocation, tableProperties);\n+    } else {\n+      String baseLocation = location != null ? location : defaultWarehouseLocation(identifier);\n+      Map<String, String> tableProperties = properties != null ? properties : Maps.newHashMap();", "originalCommit": "d2bc1da8117de6923793ed456f55c3f205a289f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4OTQyNw==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r448689427", "bodyText": "Is the catalog case sensitive? If not, equalsIgnoreCase may need to be used.", "author": "edgarRd", "createdAt": "2020-07-02T00:52:35Z", "path": "hive/src/main/java/org/apache/iceberg/hive/HiveCatalog.java", "diffHunk": "@@ -347,6 +349,20 @@ protected boolean isValidIdentifier(TableIdentifier tableIdentifier) {\n     return tableIdentifier.namespace().levels().length == 1;\n   }\n \n+  private TableIdentifier removeCatalogName(TableIdentifier to) {\n+    if (isValidIdentifier(to)) {\n+      return to;\n+    }\n+\n+    // check if the identifier includes the catalog name and remove it\n+    if (to.namespace().levels().length == 2 && name().equals(to.namespace().level(0))) {", "originalCommit": "d2bc1da8117de6923793ed456f55c3f205a289f4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5MTYyMA==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r448691620", "bodyText": "Is any PartitionSpecwith 0 fields the unpartitioned spec or should it match a certain spec (like in the removed version)? Seems like the equals method takes fields and specId into the contract.", "author": "edgarRd", "createdAt": "2020-07-02T01:00:52Z", "path": "hive/src/test/java/org/apache/iceberg/hive/HiveCreateReplaceTableTest.java", "diffHunk": "@@ -155,7 +155,7 @@ public void testReplaceTableTxn() {\n     txn.commitTransaction();\n \n     Table table = catalog.loadTable(TABLE_IDENTIFIER);\n-    Assert.assertEquals(\"Partition spec should match\", PartitionSpec.unpartitioned(), table.spec());\n+    Assert.assertEquals(\"Partition spec should be unpartitioned\", 0, table.spec().fields().size());", "originalCommit": "5c9b92954be103e71d2d965bdf8a29e68e9ed10e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcwMzM1MQ==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r448703351", "bodyText": "Any partition spec with 0 fields is considered unpartitioned.", "author": "rdblue", "createdAt": "2020-07-02T01:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5MTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE5NDM0NA==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r449194344", "bodyText": "I should note that this needed to be updated because the spec's ID didn't match, causing the test to fail.\nPartitionSpec.unpartitioned() doesn't necessarily have the right ID for a given table. We primarily use it when creating tables, where the spec gets rebuilt and assigned the right ID.", "author": "rdblue", "createdAt": "2020-07-02T18:21:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5MTYyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2MzAwMA==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r449263000", "bodyText": "Yeah, I supposed that was the reason for the change (spec's ID not matching). Thanks for the context!", "author": "edgarRd", "createdAt": "2020-07-02T20:59:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5MTYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5NTk3Ng==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r448695976", "bodyText": "Should we add tests for the other file formats?", "author": "edgarRd", "createdAt": "2020-07-02T01:18:42Z", "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestCreateTable.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.sql;\n+\n+import java.io.File;\n+import java.util.Map;\n+import org.apache.iceberg.AssertHelpers;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.hadoop.HadoopCatalog;\n+import org.apache.iceberg.spark.SparkCatalogTestBase;\n+import org.apache.iceberg.types.Types;\n+import org.apache.iceberg.types.Types.NestedField;\n+import org.apache.iceberg.types.Types.StructType;\n+import org.apache.spark.sql.connector.catalog.TableCatalog;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Test;\n+\n+public class TestCreateTable extends SparkCatalogTestBase {\n+  public TestCreateTable(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+  }\n+\n+  @After\n+  public void dropTestTable() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+  }\n+\n+  @Test\n+  public void testCreateTable() {\n+    Assert.assertFalse(\"Table should not already exist\", validationCatalog.tableExists(tableIdent));\n+\n+    sql(\"CREATE TABLE %s (id BIGINT NOT NULL, data STRING) USING iceberg\", tableName);\n+\n+    Table table = validationCatalog.loadTable(tableIdent);\n+    Assert.assertNotNull(\"Should load the new table\", table);\n+\n+    StructType expectedSchema = StructType.of(\n+        NestedField.required(1, \"id\", Types.LongType.get()),\n+        NestedField.optional(2, \"data\", Types.StringType.get()));\n+    Assert.assertEquals(\"Should have the expected schema\", expectedSchema, table.schema().asStruct());\n+    Assert.assertEquals(\"Should not be partitioned\", 0, table.spec().fields().size());\n+    Assert.assertNull(\"Should not have the default format set\",\n+        table.properties().get(TableProperties.DEFAULT_FILE_FORMAT));\n+  }\n+\n+  @Test\n+  public void testCreateTableUsingParquet() {", "originalCommit": "5c9b92954be103e71d2d965bdf8a29e68e9ed10e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcwMzc0NQ==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r448703745", "bodyText": "This is just a test that the provider is passed through correctly when using a specific catalog. I probably wouldn't add a test for other formats here in the SQL tests, but I would in unit tests for the SparkCatalog.", "author": "rdblue", "createdAt": "2020-07-02T01:48:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY5NTk3Ng=="}], "type": "inlineReview"}, {"oid": "66b7904c769208e87470a4e2a0ca78200d7344d8", "url": "https://github.com/apache/iceberg/commit/66b7904c769208e87470a4e2a0ca78200d7344d8", "message": "Ensure the default database is created.", "committedDate": "2020-07-03T00:06:20Z", "type": "commit"}, {"oid": "06c137eb2364bb53394ac99bd96bcd54a5f40f9c", "url": "https://github.com/apache/iceberg/commit/06c137eb2364bb53394ac99bd96bcd54a5f40f9c", "message": "Add tests for DataFrameWriterV2 CTAS and RTAS.", "committedDate": "2020-07-03T00:17:34Z", "type": "commit"}, {"oid": "20e524752f62dfa5e9d375eee8d08804a591f809", "url": "https://github.com/apache/iceberg/commit/20e524752f62dfa5e9d375eee8d08804a591f809", "message": "Add DELETE FROM tests.", "committedDate": "2020-07-03T00:32:56Z", "type": "commit"}, {"oid": "5414590e56b325c3dc5051593de15cc383280fa1", "url": "https://github.com/apache/iceberg/commit/5414590e56b325c3dc5051593de15cc383280fa1", "message": "Fix review comments.", "committedDate": "2020-07-03T00:39:20Z", "type": "commit"}, {"oid": "b34455e58ac55c76c0a5283265d1aa8351a26d01", "url": "https://github.com/apache/iceberg/commit/b34455e58ac55c76c0a5283265d1aa8351a26d01", "message": "Fix checkstyle.", "committedDate": "2020-07-03T00:58:04Z", "type": "commit"}, {"oid": "58a9eb5672d2c807bf3b6bda61889ccc5a07428b", "url": "https://github.com/apache/iceberg/commit/58a9eb5672d2c807bf3b6bda61889ccc5a07428b", "message": "Remove work-around for SPARK-32168.", "committedDate": "2020-07-07T18:15:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcyOTcyMw==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r451729723", "bodyText": "This behavior is fixed in #1183. If this goes in first, I'll add the fix to that PR before merging.", "author": "rdblue", "createdAt": "2020-07-08T18:01:15Z", "path": "spark3/src/test/java/org/apache/iceberg/spark/sql/TestCreateTableAsSelect.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.sql;\n+\n+import java.util.Map;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;\n+import org.apache.iceberg.spark.SparkCatalogTestBase;\n+import org.apache.iceberg.types.Types;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.spark.sql.functions.col;\n+import static org.apache.spark.sql.functions.lit;\n+import static org.apache.spark.sql.functions.when;\n+\n+public class TestCreateTableAsSelect extends SparkCatalogTestBase {\n+\n+  private final String sourceName;\n+\n+  public TestCreateTableAsSelect(String catalogName, String implementation, Map<String, String> config) {\n+    super(catalogName, implementation, config);\n+    this.sourceName = tableName(\"source\");\n+\n+    sql(\"CREATE TABLE IF NOT EXISTS %s (id bigint NOT NULL, data string) \" +\n+        \"USING iceberg PARTITIONED BY (truncate(id, 3))\", sourceName);\n+    sql(\"INSERT INTO %s VALUES (1, 'a'), (2, 'b'), (3, 'c')\", sourceName);\n+  }\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", tableName);\n+  }\n+\n+  @Test\n+  public void testUnpartitionedCTAS() {\n+    sql(\"CREATE TABLE %s USING iceberg AS SELECT * FROM %s\", tableName, sourceName);\n+\n+    Schema expectedSchema = new Schema(\n+        Types.NestedField.optional(1, \"id\", Types.LongType.get()),\n+        Types.NestedField.optional(2, \"data\", Types.StringType.get())\n+    );\n+\n+    Table ctasTable = validationCatalog.loadTable(tableIdent);\n+\n+    Assert.assertEquals(\"Should have expected nullable schema\",\n+        expectedSchema.asStruct(), ctasTable.schema().asStruct());\n+    Assert.assertEquals(\"Should be an unpartitioned table\",\n+        0, ctasTable.spec().fields().size());\n+    assertEquals(\"Should have rows matching the source table\",\n+        sql(\"SELECT * FROM %s ORDER BY id\", sourceName),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testPartitionedCTAS() {\n+    sql(\"CREATE TABLE %s USING iceberg PARTITIONED BY (id) AS SELECT * FROM %s ORDER BY id\", tableName, sourceName);\n+\n+    Schema expectedSchema = new Schema(\n+        Types.NestedField.optional(1, \"id\", Types.LongType.get()),\n+        Types.NestedField.optional(2, \"data\", Types.StringType.get())\n+    );\n+\n+    PartitionSpec expectedSpec = PartitionSpec.builderFor(expectedSchema)\n+        .identity(\"id\")\n+        .build();\n+\n+    Table ctasTable = validationCatalog.loadTable(tableIdent);\n+\n+    Assert.assertEquals(\"Should have expected nullable schema\",\n+        expectedSchema.asStruct(), ctasTable.schema().asStruct());\n+    Assert.assertEquals(\"Should be partitioned by id\",\n+        expectedSpec, ctasTable.spec());\n+    assertEquals(\"Should have rows matching the source table\",\n+        sql(\"SELECT * FROM %s ORDER BY id\", sourceName),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+  }\n+\n+  @Test\n+  public void testRTAS() {\n+    sql(\"CREATE TABLE %s USING iceberg AS SELECT * FROM %s\", tableName, sourceName);\n+\n+    assertEquals(\"Should have rows matching the source table\",\n+        sql(\"SELECT * FROM %s ORDER BY id\", sourceName),\n+        sql(\"SELECT * FROM %s ORDER BY id\", tableName));\n+\n+    sql(\"REPLACE TABLE %s USING iceberg PARTITIONED BY (part) AS \" +\n+        \"SELECT id, data, CASE WHEN (id %% 2) = 0 THEN 'even' ELSE 'odd' END AS part \" +\n+        \"FROM %s ORDER BY 3, 1\", tableName, sourceName);\n+\n+    // spark_catalog does not use an atomic replace, so the table history and old spec is dropped\n+    // the other catalogs do use atomic replace, so the spec id is incremented\n+    boolean isAtomic = !\"spark_catalog\".equals(catalogName);", "originalCommit": "58a9eb5672d2c807bf3b6bda61889ccc5a07428b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzODAyOA==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r451838028", "bodyText": "I'm not clear on whether this really should be the right behavior.  Basically we're saying that a replace table will keep the existing location (as opposed to using defaults).  I suspect we don't have create or replace with location semantics, but this is making some assumptions that a replacement is somehow the same as the old.  If we were to go with id based pathing convention, this wouldn't work.\nI don't think this is an issue at this point, but it might make sense to push this down to the location provider.", "author": "danielcweeks", "createdAt": "2020-07-08T21:33:40Z", "path": "core/src/main/java/org/apache/iceberg/BaseMetastoreCatalog.java", "diffHunk": "@@ -110,9 +110,17 @@ public Transaction newReplaceTableTransaction(\n       throw new NoSuchTableException(\"No such table: \" + identifier);\n     }\n \n-    String baseLocation = location != null ? location : defaultWarehouseLocation(identifier);\n     Map<String, String> tableProperties = properties != null ? properties : Maps.newHashMap();\n-    TableMetadata metadata = TableMetadata.newTableMetadata(schema, spec, baseLocation, tableProperties);\n+\n+    TableMetadata metadata;\n+    if (ops.current() != null) {", "originalCommit": "58a9eb5672d2c807bf3b6bda61889ccc5a07428b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg2NjMzNQ==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r451866335", "bodyText": "I think this is correct because the REPLACE TABLE doesn't completely wipe out the old table. In most ways, it is the same table.\nCalling buildReplacement will replace the schema and partition spec so that the transaction can add a new snapshot. Table history, old snapshots, and existing table properties are kept so that you can inspect the table and don't need to add table configuration every time you run the SQL.\nWe could add a flag to turn off this behavior and wipe out the old by default, but I don't think that's what users really want. It makes sense for things like default format and other settings to persist across replace operations, so that table configuration and table operations are orthogonal.", "author": "rdblue", "createdAt": "2020-07-08T22:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzODAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg4MTA5OA==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r451881098", "bodyText": "ok, I guess that makes sense.  I assumed the semantics to be the same a transactional drop and create, but based on a little searching, it's much less clear than that.  For example, with db2 create or replace will actually retain all data (assuming if aligns with the new table definition) by default.\nI agree that preserving table properties make sense, but wouldn't this wipe out comments (which we may also want to preserve)", "author": "danielcweeks", "createdAt": "2020-07-08T23:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzODAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg5NTIxOA==", "url": "https://github.com/apache/iceberg/pull/1156#discussion_r451895218", "bodyText": "It would probably wipe out column comments. I'll have to fix that.", "author": "rdblue", "createdAt": "2020-07-09T00:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgzODAyOA=="}], "type": "inlineReview"}]}