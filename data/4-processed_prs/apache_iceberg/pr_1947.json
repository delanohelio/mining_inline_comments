{"pr_number": 1947, "pr_title": "Spark MERGE INTO Support (copy-on-write implementation)", "pr_createdAt": "2020-12-16T22:36:08Z", "pr_url": "https://github.com/apache/iceberg/pull/1947", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyMDIwNA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r544920204", "bodyText": "Do we need this node? It seems we rewrite the operation into ReplaceData, no?", "author": "aokolnychyi", "createdAt": "2020-12-17T09:01:40Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoProcessor\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+\n+case class MergeIntoExec(mergeIntoProcessor: MergeIntoProcessor,", "originalCommit": "9f021994411ac1701802ed4adcc8db4af1832d8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAwNzU0MQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r545007541", "bodyText": "Well, I overlooked that we use MergeInto node in RewriteMergeInto.", "author": "aokolnychyi", "createdAt": "2020-12-17T11:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyMDIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTAwNzY2Nw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r545007667", "bodyText": "I wonder whether we can use MapPartitions directly.", "author": "aokolnychyi", "createdAt": "2020-12-17T11:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyMDIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDczOQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r545520739", "bodyText": "I think that MergeIntoProcessor and this node should be merged. That's really a physical plan node and it is strange how it is created and passed through the logical plan.", "author": "rdblue", "createdAt": "2020-12-18T01:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyMDIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjY1NzMzNQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r546657335", "bodyText": "I agree with that. I think we can address this in the end. This bit is working and I'd focus on other things for now.", "author": "aokolnychyi", "createdAt": "2020-12-21T11:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDkyMDIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDk0MjY1Nw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r544942657", "bodyText": "nit: these vals can be private", "author": "aokolnychyi", "createdAt": "2020-12-17T09:35:20Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import java.util.UUID\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.{AnalysisException, SparkSession}\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner, JoinType}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2Relation, DataSourceV2ScanRelation}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+object RewriteMergeInto extends Rule[LogicalPlan]\n+  with PredicateHelper\n+  with Logging  {\n+  val ROW_ID_COL = \"_row_id_\"", "originalCommit": "9f021994411ac1701802ed4adcc8db4af1832d8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxNjEyMA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r545516120", "bodyText": "It would be helpful to group some of these plan nodes into sections, like in RewriteDelete where methods like buildFileFilterPlan and buildScanPlan give good context for what plans are being constructed and how they will be used.", "author": "rdblue", "createdAt": "2020-12-18T01:36:04Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import java.util.UUID\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.{AnalysisException, SparkSession}\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner, JoinType}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2Relation, DataSourceV2ScanRelation}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+object RewriteMergeInto extends Rule[LogicalPlan]\n+  with PredicateHelper\n+  with Logging  {\n+  val ROW_ID_COL = \"_row_id_\"\n+  val FILE_NAME_COL = \"_file_name_\"\n+  val SOURCE_ROW_PRESENT_COL = \"_source_row_present_\"\n+  val TARGET_ROW_PRESENT_COL = \"_target_row_present_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records\n+      case MergeIntoTable(target: DataSourceV2Relation,\n+                          source: LogicalPlan, cond, actions, notActions) =>\n+        // Find the files in target that matches the JOIN condition from source.\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)", "originalCommit": "9f021994411ac1701802ed4adcc8db4af1832d8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUxNzQwMA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r545517400", "bodyText": "As Anton noted, there needs to be validation that the assignments here (for both inserts and updates) match up with the targetOutputCols.", "author": "rdblue", "createdAt": "2020-12-18T01:40:03Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import java.util.UUID\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.{AnalysisException, SparkSession}\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner, JoinType}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2Relation, DataSourceV2ScanRelation}\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types._\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+object RewriteMergeInto extends Rule[LogicalPlan]\n+  with PredicateHelper\n+  with Logging  {\n+  val ROW_ID_COL = \"_row_id_\"\n+  val FILE_NAME_COL = \"_file_name_\"\n+  val SOURCE_ROW_PRESENT_COL = \"_source_row_present_\"\n+  val TARGET_ROW_PRESENT_COL = \"_target_row_present_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records\n+      case MergeIntoTable(target: DataSourceV2Relation,\n+                          source: LogicalPlan, cond, actions, notActions) =>\n+        // Find the files in target that matches the JOIN condition from source.\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+        val prunedTargetPlan = Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)\n+\n+        val writeInfo = newWriteInfo(target.schema)\n+        val mergeBuilder = target.table.asMergeable.newMergeBuilder(\"delete\", writeInfo)\n+        val targetTableScan =  buildScanPlan(target.table, target.output, mergeBuilder, prunedTargetPlan)\n+        val sourceTableProj = source.output ++ Seq(Alias(lit(true).expr, SOURCE_ROW_PRESENT_COL)())\n+        val targetTableProj = target.output ++ Seq(Alias(lit(true).expr, TARGET_ROW_PRESENT_COL)())\n+        val newTargetTableScan = Project(targetTableProj, targetTableScan)\n+        val newSourceTableScan = Project(sourceTableProj, source)\n+        val joinPlan = Join(newSourceTableScan, newTargetTableScan, FullOuter, Some(cond), JoinHint.NONE)\n+\n+        val mergeIntoProcessor = new MergeIntoProcessor(\n+          isSourceRowNotPresent = resolveExprs(Seq(col(SOURCE_ROW_PRESENT_COL).isNull.expr), joinPlan).head,\n+          isTargetRowNotPresent = resolveExprs(Seq(col(TARGET_ROW_PRESENT_COL).isNull.expr), joinPlan).head,\n+          matchedConditions = actions.map(resolveClauseCondition(_, joinPlan)),\n+          matchedOutputs = actions.map(actionOutput(_, targetOutputCols, joinPlan)),\n+          notMatchedConditions = notActions.map(resolveClauseCondition(_, joinPlan)),\n+          notMatchedOutputs = notActions.map(actionOutput(_, targetOutputCols, joinPlan)),\n+          targetOutput = resolveExprs(targetOutputCols :+ Literal(false), joinPlan),\n+          joinedAttributes = joinPlan.output\n+        )\n+\n+        val mergePlan = MergeInto(mergeIntoProcessor, target, joinPlan)\n+        val batchWrite = mergeBuilder.asWriteBuilder.buildForBatch()\n+        ReplaceData(target, batchWrite, mergePlan)\n+    }\n+  }\n+\n+  private def buildScanPlan(\n+      table: Table,\n+      output: Seq[AttributeReference],\n+      mergeBuilder: MergeBuilder,\n+      prunedTargetPlan: LogicalPlan): LogicalPlan = {\n+\n+    val scanBuilder = mergeBuilder.asScanBuilder\n+    val scan = scanBuilder.build()\n+    val scanRelation = DataSourceV2ScanRelation(table, scan, output)\n+\n+    scan match {\n+      case _: SupportsFileFilter =>\n+        val matchingFilePlan = buildFileFilterPlan(prunedTargetPlan)\n+        val dynamicFileFilter = DynamicFileFilter(scanRelation, matchingFilePlan)\n+        dynamicFileFilter\n+      case _ =>\n+        scanRelation\n+    }\n+  }\n+\n+  private def newWriteInfo(schema: StructType): LogicalWriteInfo = {\n+    val uuid = UUID.randomUUID()\n+    LogicalWriteInfoImpl(queryId = uuid.toString, schema, CaseInsensitiveStringMap.empty)\n+  }\n+\n+  private def buildFileFilterPlan(prunedTargetPlan: LogicalPlan): LogicalPlan = {\n+    val fileAttr = findOutputAttr(prunedTargetPlan, FILE_NAME_COL)\n+    Aggregate(Seq(fileAttr), Seq(fileAttr), prunedTargetPlan)\n+  }\n+\n+  private def findOutputAttr(plan: LogicalPlan, attrName: String): Attribute = {\n+    val resolver = SQLConf.get.resolver\n+    plan.output.find(attr => resolver(attr.name, attrName)).getOrElse {\n+      throw new AnalysisException(s\"Cannot find $attrName in ${plan.output}\")\n+    }\n+  }\n+\n+  private def resolveExprs(exprs: Seq[Expression], plan: LogicalPlan): Seq[Expression] = {\n+    val spark = SparkSession.active\n+    exprs.map { expr => resolveExpressionInternal(spark, expr, plan) }\n+  }\n+\n+  def getTargetOutputCols(target: DataSourceV2Relation): Seq[NamedExpression] = {\n+    target.schema.map { col =>\n+      target.output.find(attr => SQLConf.get.resolver(attr.name, col.name)).getOrElse {\n+        Alias(Literal(null, col.dataType), col.name)()\n+      }\n+    }\n+  }\n+\n+  def actionOutput(clause: MergeAction,\n+                   targetOutputCols: Seq[Expression],\n+                   plan: LogicalPlan): Seq[Expression] = {\n+    val exprs = clause match {\n+      case u: UpdateAction =>\n+        u.assignments.map(_.value) :+ Literal(false)\n+      case _: DeleteAction =>\n+        targetOutputCols :+ Literal(true)\n+      case i: InsertAction =>\n+        i.assignments.map(_.value) :+ Literal(false)", "originalCommit": "9f021994411ac1701802ed4adcc8db4af1832d8b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDQ0NA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r545520444", "bodyText": "This is essentially a physical plan node that is linked into both the physical plan and logical plan. I think it should be a normal physical plan node that is created in a strategy, just like other plans.\nThe main issue with the way this PR currently works is that it doesn't delegate enough to the rest of the Spark planner. All of the analysis is done during rewrite in the optimizer, for example. I think that this should be broken up into analysis rules to validate and update the MergeInto plan, the rewrite rule to build the optimizations and join, and a strategy to convert the logical plan into a MergeIntoExec. I think this should also have a validation rule that checks each action to ensure that the expressions for that action are correctly resolved.", "author": "rdblue", "createdAt": "2020-12-18T01:48:56Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/MergeInto.scala", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical\n+\n+import org.apache.spark.sql.Row\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions.col\n+\n+case class MergeInto(mergeIntoProcessor: MergeIntoProcessor,\n+                     targetRelation: DataSourceV2Relation,\n+                     child: LogicalPlan) extends UnaryNode {\n+  override def output: Seq[Attribute] = targetRelation.output\n+}\n+\n+class MergeIntoProcessor(isSourceRowNotPresent: Expression,\n+                         isTargetRowNotPresent: Expression,\n+                         matchedConditions: Seq[Expression],\n+                         matchedOutputs: Seq[Seq[Expression]],\n+                         notMatchedConditions: Seq[Expression],\n+                         notMatchedOutputs: Seq[Seq[Expression]],\n+                         targetOutput: Seq[Expression],\n+                         joinedAttributes: Seq[Attribute]) extends Serializable {", "originalCommit": "9f021994411ac1701802ed4adcc8db4af1832d8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTk4MDM4Mw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r545980383", "bodyText": "@rdblue Can you please explain the idea bit more, specifically the should be broken up into analysis rules to validate and update MergeInto plan . Currently, we produce the MergeInto logical plan in the optimizer phase ? So we have gone past analysis at this point right ? The input SQL has already been parsed and resolved using MergeIntoTable by spark at this point i.e all the mergeinto inputs have been resolved ?", "author": "dilipbiswal", "createdAt": "2020-12-18T17:29:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAwODIyOQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r546008229", "bodyText": "We need to make sure there are analysis rules that guarantee the assumptions in this class. One possible issue that jumped out to both @aokolnychyi and I was that this assumes the expressions for insert and update actions are correct for the output of this node. We need to make sure that is the case.\nOriginally, I asked on Slack how that validation was being done, but I saw Anton's comment about it and I thought that probably meant that it isn't being done. If there are already rules in Spark to resolve and validate the plan, then that's great but we need to identify them and make a note here that we're relying on those for correctness. I still suspect that there aren't rules in Spark doing this because this is running the analyzer on expressions.", "author": "rdblue", "createdAt": "2020-12-18T18:19:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjAzNDg2NA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r546034864", "bodyText": "@rdblue Sorry Ryan. I didn't notice your comment on slack until now. So currently in my understanding Spark's Analyzer ensures that the ResolveIntoTable is fully resolved.\ncode\nHowever, you are right that we don't do any semantics analysis on the plan currently. We should add it.", "author": "dilipbiswal", "createdAt": "2020-12-18T19:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDQ0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjI5MTUzNw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r546291537", "bodyText": "Thanks for pointing me to the code! Looks like I was looking into it at the time you were writing this, which is why my comment below was just a bit later. I think we're all on the same page now.", "author": "rdblue", "createdAt": "2020-12-19T22:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyMDQ0NA=="}], "type": "inlineReview"}, {"oid": "76ea61f0321a7b4de250e448722f7893bd52296f", "url": "https://github.com/apache/iceberg/commit/76ea61f0321a7b4de250e448722f7893bd52296f", "message": "Code review + base infrastructure", "committedDate": "2021-01-04T07:36:37Z", "type": "forcePushed"}, {"oid": "13889694c2fa750aae742ff207061ce40bf66504", "url": "https://github.com/apache/iceberg/commit/13889694c2fa750aae742ff207061ce40bf66504", "message": "Code review + base infrastructure", "committedDate": "2021-01-05T06:48:22Z", "type": "forcePushed"}, {"oid": "148744edd876f823e18bf4f9ae5f2a58f4c55f65", "url": "https://github.com/apache/iceberg/commit/148744edd876f823e18bf4f9ae5f2a58f4c55f65", "message": "Code review + base infrastructure", "committedDate": "2021-01-11T09:00:38Z", "type": "forcePushed"}, {"oid": "946bbded4eb82639a9e3db7fb90172dab827508c", "url": "https://github.com/apache/iceberg/commit/946bbded4eb82639a9e3db7fb90172dab827508c", "message": "Code review + base infrastructure", "committedDate": "2021-01-12T05:34:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODUyNTAyNw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558525027", "bodyText": "Shall we make these variables private?", "author": "aokolnychyi", "createdAt": "2021-01-15T19:06:04Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.PlanHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+\n+object RewriteMergeInto extends Rule[LogicalPlan] with PlanHelper with Logging  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODUyNTc1OQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558525759", "bodyText": "Does the comment apply? It looks like it is valid for DELETE but not really for MERGE.", "author": "aokolnychyi", "createdAt": "2021-01-15T19:07:02Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.PlanHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+\n+object RewriteMergeInto extends Rule[LogicalPlan] with PlanHelper with Logging  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA2NDA4NQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559064085", "bodyText": "@aokolnychyi cut-paste.. sorry, will remove.", "author": "dilipbiswal", "createdAt": "2021-01-17T01:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODUyNTc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODUyOTU1Ng==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558529556", "bodyText": "nit: I think matchedActions and notMatchedActions would be better names here.", "author": "aokolnychyi", "createdAt": "2021-01-15T19:11:23Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.PlanHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+\n+object RewriteMergeInto extends Rule[LogicalPlan] with PlanHelper with Logging  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records\n+      case MergeIntoTable(target: DataSourceV2Relation,\n+                          source: LogicalPlan, cond, actions, notActions) =>", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU0MTExNA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558541114", "bodyText": "@dilipbiswal, do we have to add MERGE operations to PullupCorrelatedPredicatesInRowLevelOperations? Could you test the current implementation with subqueries inside the merge as well as matched/not matched conditions?", "author": "aokolnychyi", "createdAt": "2021-01-15T19:24:15Z", "path": "spark3-extensions/src/main/scala/org/apache/iceberg/spark/extensions/IcebergSparkSessionExtensions.scala", "diffHunk": "@@ -43,6 +43,7 @@ class IcebergSparkSessionExtensions extends (SparkSessionExtensions => Unit) {\n     // TODO: PullupCorrelatedPredicates should handle row-level operations\n     extensions.injectOptimizerRule { _ => PullupCorrelatedPredicatesInRowLevelOperations }\n     extensions.injectOptimizerRule { _ => RewriteDelete }\n+    extensions.injectOptimizerRule { _ => RewriteMergeInto }", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA2NDUxNA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559064514", "bodyText": "@aokolnychyi will address this with a follow-up to not allow subqs and add tests to verify the same. Hope its okay.", "author": "dilipbiswal", "createdAt": "2021-01-17T01:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU0MTExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU0Nzc2Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558547762", "bodyText": "When I was working on UPDATE, I also created a parent trait for row-level ops.\nWhat about a more specific name, like RewriteRowLevelOperation or similar?", "author": "aokolnychyi", "createdAt": "2021-01-15T19:31:19Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/utils/PlanHelper.scala", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.spark.sql.catalyst.utils\n+\n+import java.util.UUID\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeReference, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, DynamicFileFilter, LogicalPlan}\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2ScanRelation}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+trait PlanHelper extends PredicateHelper {", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU0NzkxMQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558547911", "bodyText": "Shall we make these protected?", "author": "aokolnychyi", "createdAt": "2021-01-15T19:31:30Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/utils/PlanHelper.scala", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.spark.sql.catalyst.utils\n+\n+import java.util.UUID\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeReference, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, DynamicFileFilter, LogicalPlan}\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2ScanRelation}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+trait PlanHelper extends PredicateHelper {\n+  val FILE_NAME_COL = \"_file\"", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU0ODQ3Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558548472", "bodyText": "I think we better make methods inside this trait protected, not public.", "author": "aokolnychyi", "createdAt": "2021-01-15T19:32:10Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/utils/PlanHelper.scala", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.spark.sql.catalyst.utils\n+\n+import java.util.UUID\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeReference, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, DynamicFileFilter, LogicalPlan}\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2ScanRelation}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+trait PlanHelper extends PredicateHelper {", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU0OTI1NQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558549255", "bodyText": "This does not do predicate push down as we have for DELETE.\nCan we take the implementation from RewriteDelete?", "author": "aokolnychyi", "createdAt": "2021-01-15T19:33:16Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/utils/PlanHelper.scala", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.spark.sql.catalyst.utils\n+\n+import java.util.UUID\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeReference, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, DynamicFileFilter, LogicalPlan}\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2ScanRelation}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+trait PlanHelper extends PredicateHelper {\n+  val FILE_NAME_COL = \"_file\"\n+  val ROW_POS_COL = \"_pos\"\n+\n+  def buildScanPlan(table: Table,", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU1MjExMA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558552110", "bodyText": "We should probably pass it from the session like in AlignMergeIntoTable.", "author": "aokolnychyi", "createdAt": "2021-01-15T19:39:12Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/utils/PlanHelper.scala", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.spark.sql.catalyst.utils\n+\n+import java.util.UUID\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeReference, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, DynamicFileFilter, LogicalPlan}\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2ScanRelation}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+trait PlanHelper extends PredicateHelper {\n+  val FILE_NAME_COL = \"_file\"\n+  val ROW_POS_COL = \"_pos\"\n+\n+  def buildScanPlan(table: Table,\n+                    output: Seq[AttributeReference],\n+                    mergeBuilder: MergeBuilder,\n+                    prunedTargetPlan: LogicalPlan): LogicalPlan = {\n+\n+    val scanBuilder = mergeBuilder.asScanBuilder\n+    val scan = scanBuilder.build()\n+    val scanRelation = DataSourceV2ScanRelation(table, scan, toOutputAttrs(scan.readSchema(), output))\n+\n+    scan match {\n+      case filterable: SupportsFileFilter =>\n+        val matchingFilePlan = buildFileFilterPlan(prunedTargetPlan)\n+        val dynamicFileFilter = DynamicFileFilter(scanRelation, matchingFilePlan, filterable)\n+        dynamicFileFilter\n+      case _ =>\n+        scanRelation\n+    }\n+  }\n+\n+  private def buildFileFilterPlan(prunedTargetPlan: LogicalPlan): LogicalPlan = {\n+    val fileAttr = findOutputAttr(prunedTargetPlan, FILE_NAME_COL)\n+    Aggregate(Seq(fileAttr), Seq(fileAttr), prunedTargetPlan)\n+  }\n+\n+  def findOutputAttr(plan: LogicalPlan, attrName: String): Attribute = {\n+    val resolver = SQLConf.get.resolver", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2NjIyNg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558566226", "bodyText": "@dilipbiswal, could you move these tests to TestMerge that was introduced recently?", "author": "aokolnychyi", "createdAt": "2021-01-15T20:07:09Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestMergeIntoTable.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchTableException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.TableProperties.DEFAULT_FILE_FORMAT;\n+import static org.apache.iceberg.TableProperties.PARQUET_VECTORIZATION_ENABLED;\n+\n+public class TestMergeIntoTable extends SparkRowLevelOperationsTestBase {", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA5NDk1OQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559094959", "bodyText": "@aokolnychyi If you are ok, i want to create a final pr to remove this test case and merge to TestMerge since the other two prs also add tests to this class. I want them to rebase okay without much trouble. Let me know please.", "author": "dilipbiswal", "createdAt": "2021-01-17T08:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2NjIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzNDM0Ng==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559834346", "bodyText": "Sounds fine to me.", "author": "rdblue", "createdAt": "2021-01-18T23:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODU2NjIyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYyMDc4Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558620782", "bodyText": "This line should use merge, instead of delete now. It should be supported.", "author": "aokolnychyi", "createdAt": "2021-01-15T22:14:56Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.PlanHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+\n+object RewriteMergeInto extends Rule[LogicalPlan] with PlanHelper with Logging  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records\n+      case MergeIntoTable(target: DataSourceV2Relation,\n+                          source: LogicalPlan, cond, actions, notActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.\n+        val prunedTargetPlan = Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)\n+        val writeInfo = newWriteInfo(target.schema)\n+        val mergeBuilder = target.table.asMergeable.newMergeBuilder(\"delete\", writeInfo)", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYyNTgzNw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558625837", "bodyText": "Shall we make the helper methods private?", "author": "aokolnychyi", "createdAt": "2021-01-15T22:29:55Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.PlanHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+\n+object RewriteMergeInto extends Rule[LogicalPlan] with PlanHelper with Logging  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records\n+      case MergeIntoTable(target: DataSourceV2Relation,\n+                          source: LogicalPlan, cond, actions, notActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.\n+        val prunedTargetPlan = Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)\n+        val writeInfo = newWriteInfo(target.schema)\n+        val mergeBuilder = target.table.asMergeable.newMergeBuilder(\"delete\", writeInfo)\n+        val targetTableScan =  buildScanPlan(target.table, target.output, mergeBuilder, prunedTargetPlan)\n+\n+        // Construct an outer join to help track changes in source and target.\n+        // TODO : Optimize this to use LEFT ANTI or RIGHT OUTER when applicable.\n+        val sourceTableProj = source.output ++ Seq(Alias(lit(true).expr, ROW_FROM_SOURCE)())\n+        val targetTableProj = target.output ++ Seq(Alias(lit(true).expr, ROW_FROM_TARGET)())\n+        val newTargetTableScan = Project(targetTableProj, targetTableScan)\n+        val newSourceTableScan = Project(sourceTableProj, source)\n+        val joinPlan = Join(newSourceTableScan, newTargetTableScan, FullOuter, Some(cond), JoinHint.NONE)\n+\n+        // Construct the plan to replace the data based on the output of `MergeInto`\n+        val mergeParams = MergeIntoParams(\n+          isSourceRowNotPresent = IsNull(findOutputAttr(joinPlan, ROW_FROM_SOURCE)),\n+          isTargetRowNotPresent = IsNull(findOutputAttr(joinPlan, ROW_FROM_TARGET)),\n+          matchedConditions = actions.map(getClauseCondition),\n+          matchedOutputs = actions.map(actionOutput(_, targetOutputCols)),\n+          notMatchedConditions = notActions.map(getClauseCondition),\n+          notMatchedOutputs = notActions.map(actionOutput(_, targetOutputCols)),\n+          targetOutput = targetOutputCols :+ Literal(false),\n+          deleteOutput = targetOutputCols :+ Literal(true),\n+          joinedAttributes = joinPlan.output\n+        )\n+        val mergePlan = MergeInto(mergeParams, target, joinPlan)\n+        val batchWrite = mergeBuilder.asWriteBuilder.buildForBatch()\n+        ReplaceData(target, batchWrite, mergePlan)\n+    }\n+  }\n+\n+  def getTargetOutputCols(target: DataSourceV2Relation): Seq[NamedExpression] = {", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYyNjgzNA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558626834", "bodyText": "It is probably better to accept SQLConf in this rule like in AlignMergeIntoTable.", "author": "aokolnychyi", "createdAt": "2021-01-15T22:32:57Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.PlanHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+\n+object RewriteMergeInto extends Rule[LogicalPlan] with PlanHelper with Logging  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records\n+      case MergeIntoTable(target: DataSourceV2Relation,\n+                          source: LogicalPlan, cond, actions, notActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.\n+        val prunedTargetPlan = Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)\n+        val writeInfo = newWriteInfo(target.schema)\n+        val mergeBuilder = target.table.asMergeable.newMergeBuilder(\"delete\", writeInfo)\n+        val targetTableScan =  buildScanPlan(target.table, target.output, mergeBuilder, prunedTargetPlan)\n+\n+        // Construct an outer join to help track changes in source and target.\n+        // TODO : Optimize this to use LEFT ANTI or RIGHT OUTER when applicable.\n+        val sourceTableProj = source.output ++ Seq(Alias(lit(true).expr, ROW_FROM_SOURCE)())\n+        val targetTableProj = target.output ++ Seq(Alias(lit(true).expr, ROW_FROM_TARGET)())\n+        val newTargetTableScan = Project(targetTableProj, targetTableScan)\n+        val newSourceTableScan = Project(sourceTableProj, source)\n+        val joinPlan = Join(newSourceTableScan, newTargetTableScan, FullOuter, Some(cond), JoinHint.NONE)\n+\n+        // Construct the plan to replace the data based on the output of `MergeInto`\n+        val mergeParams = MergeIntoParams(\n+          isSourceRowNotPresent = IsNull(findOutputAttr(joinPlan, ROW_FROM_SOURCE)),\n+          isTargetRowNotPresent = IsNull(findOutputAttr(joinPlan, ROW_FROM_TARGET)),\n+          matchedConditions = actions.map(getClauseCondition),\n+          matchedOutputs = actions.map(actionOutput(_, targetOutputCols)),\n+          notMatchedConditions = notActions.map(getClauseCondition),\n+          notMatchedOutputs = notActions.map(actionOutput(_, targetOutputCols)),\n+          targetOutput = targetOutputCols :+ Literal(false),\n+          deleteOutput = targetOutputCols :+ Literal(true),\n+          joinedAttributes = joinPlan.output\n+        )\n+        val mergePlan = MergeInto(mergeParams, target, joinPlan)\n+        val batchWrite = mergeBuilder.asWriteBuilder.buildForBatch()\n+        ReplaceData(target, batchWrite, mergePlan)\n+    }\n+  }\n+\n+  def getTargetOutputCols(target: DataSourceV2Relation): Seq[NamedExpression] = {\n+    target.schema.map { col =>\n+      target.output.find(attr => SQLConf.get.resolver(attr.name, col.name)).getOrElse {", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYyNjk0NA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558626944", "bodyText": "Is this method actually used?", "author": "aokolnychyi", "createdAt": "2021-01-15T22:33:20Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.PlanHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+\n+object RewriteMergeInto extends Rule[LogicalPlan] with PlanHelper with Logging  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records\n+      case MergeIntoTable(target: DataSourceV2Relation,\n+                          source: LogicalPlan, cond, actions, notActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.\n+        val prunedTargetPlan = Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)\n+        val writeInfo = newWriteInfo(target.schema)\n+        val mergeBuilder = target.table.asMergeable.newMergeBuilder(\"delete\", writeInfo)\n+        val targetTableScan =  buildScanPlan(target.table, target.output, mergeBuilder, prunedTargetPlan)\n+\n+        // Construct an outer join to help track changes in source and target.\n+        // TODO : Optimize this to use LEFT ANTI or RIGHT OUTER when applicable.\n+        val sourceTableProj = source.output ++ Seq(Alias(lit(true).expr, ROW_FROM_SOURCE)())\n+        val targetTableProj = target.output ++ Seq(Alias(lit(true).expr, ROW_FROM_TARGET)())\n+        val newTargetTableScan = Project(targetTableProj, targetTableScan)\n+        val newSourceTableScan = Project(sourceTableProj, source)\n+        val joinPlan = Join(newSourceTableScan, newTargetTableScan, FullOuter, Some(cond), JoinHint.NONE)\n+\n+        // Construct the plan to replace the data based on the output of `MergeInto`\n+        val mergeParams = MergeIntoParams(\n+          isSourceRowNotPresent = IsNull(findOutputAttr(joinPlan, ROW_FROM_SOURCE)),\n+          isTargetRowNotPresent = IsNull(findOutputAttr(joinPlan, ROW_FROM_TARGET)),\n+          matchedConditions = actions.map(getClauseCondition),\n+          matchedOutputs = actions.map(actionOutput(_, targetOutputCols)),\n+          notMatchedConditions = notActions.map(getClauseCondition),\n+          notMatchedOutputs = notActions.map(actionOutput(_, targetOutputCols)),\n+          targetOutput = targetOutputCols :+ Literal(false),\n+          deleteOutput = targetOutputCols :+ Literal(true),\n+          joinedAttributes = joinPlan.output\n+        )\n+        val mergePlan = MergeInto(mergeParams, target, joinPlan)\n+        val batchWrite = mergeBuilder.asWriteBuilder.buildForBatch()\n+        ReplaceData(target, batchWrite, mergePlan)\n+    }\n+  }\n+\n+  def getTargetOutputCols(target: DataSourceV2Relation): Seq[NamedExpression] = {", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA2NTQ4OA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559065488", "bodyText": "@aokolnychyi will remove. Thanks !!", "author": "dilipbiswal", "createdAt": "2021-01-17T02:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYyNjk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODYyODA0MA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558628040", "bodyText": "nit: I like Spark's way of formatting like this a bit more:\ncase class MergeInto(\n    mergeIntoProcessor: ...\n    targetRelation: ...\n    child: ...)", "author": "aokolnychyi", "createdAt": "2021-01-15T22:36:39Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/plans/logical/MergeInto.scala", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.plans.logical\n+\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+\n+case class MergeInto(mergeIntoProcessor: MergeIntoParams,", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODY1MTIyNQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558651225", "bodyText": "I think comments here would help people who will maintain/contribute in the future.", "author": "aokolnychyi", "createdAt": "2021-01-15T23:18:43Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, BasePredicate, Expression, UnsafeProjection}\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+\n+case class MergeIntoExec(mergeIntoProcessor: MergeIntoParams,\n+                         @transient targetRelation: DataSourceV2Relation,\n+                         override val child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = targetRelation.output\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    child.execute().mapPartitions {\n+      processPartition(mergeIntoProcessor, _)\n+    }\n+  }\n+\n+  private def generateProjection(exprs: Seq[Expression], attrs: Seq[Attribute]): UnsafeProjection = {\n+    UnsafeProjection.create(exprs, attrs)\n+  }\n+\n+  private def generatePredicate(expr: Expression, attrs: Seq[Attribute]): BasePredicate = {\n+    GeneratePredicate.generate(expr, attrs)\n+  }\n+\n+  def applyProjection(predicates: Seq[BasePredicate],\n+                      projections: Seq[UnsafeProjection],\n+                      projectTargetCols: UnsafeProjection,\n+                      projectDeleteRow: UnsafeProjection,\n+                      inputRow: InternalRow,\n+                      targetRowNotPresent: Boolean): InternalRow = {\n+    // Find the first combination where the predicate evaluates to true\n+    val pair = (predicates zip projections).find {\n+      case (predicate, _) => predicate.eval(inputRow)\n+    }\n+\n+    // Now apply the appropriate projection to either :\n+    // - Insert a row into target\n+    // - Update a row of target\n+    // - Delete a row in target. The projected row will have the deleted bit set.\n+    pair match {\n+      case Some((_, projection)) =>\n+        projection.apply(inputRow)\n+      case None =>\n+        if (targetRowNotPresent) {\n+          projectDeleteRow.apply(inputRow)\n+        } else {\n+          projectTargetCols.apply(inputRow)\n+        }\n+    }\n+  }\n+\n+  def processPartition(params: MergeIntoParams,\n+                       rowIterator: Iterator[InternalRow]): Iterator[InternalRow] = {\n+    val joinedAttrs = params.joinedAttributes\n+    val isSourceRowNotPresentPred = generatePredicate(params.isSourceRowNotPresent, joinedAttrs)\n+    val isTargetRowNotPresentPred = generatePredicate(params.isTargetRowNotPresent, joinedAttrs)\n+    val matchedPreds = params.matchedConditions.map(generatePredicate(_, joinedAttrs))\n+    val matchedProjs = params.matchedOutputs.map(generateProjection(_, joinedAttrs))\n+    val notMatchedPreds = params.notMatchedConditions.map(generatePredicate(_, joinedAttrs))\n+    val notMatchedProjs = params.notMatchedOutputs.map(generateProjection(_, joinedAttrs))\n+    val projectTargetCols = generateProjection(params.targetOutput, joinedAttrs)\n+    val projectDeletedRow = generateProjection(params.deleteOutput, joinedAttrs)\n+\n+    def shouldDeleteRow(row: InternalRow): Boolean =\n+      row.getBoolean(params.targetOutput.size - 1)\n+\n+\n+    def processRow(inputRow: InternalRow): InternalRow = {", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODY1ODI1MA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558658250", "bodyText": "I think this will require further explanation. There will be up to 2 matched cases and we try to find the first one that matches? Does find guarantee the order of the traversal?", "author": "aokolnychyi", "createdAt": "2021-01-15T23:25:56Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, BasePredicate, Expression, UnsafeProjection}\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+\n+case class MergeIntoExec(mergeIntoProcessor: MergeIntoParams,\n+                         @transient targetRelation: DataSourceV2Relation,\n+                         override val child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = targetRelation.output\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    child.execute().mapPartitions {\n+      processPartition(mergeIntoProcessor, _)\n+    }\n+  }\n+\n+  private def generateProjection(exprs: Seq[Expression], attrs: Seq[Attribute]): UnsafeProjection = {\n+    UnsafeProjection.create(exprs, attrs)\n+  }\n+\n+  private def generatePredicate(expr: Expression, attrs: Seq[Attribute]): BasePredicate = {\n+    GeneratePredicate.generate(expr, attrs)\n+  }\n+\n+  def applyProjection(predicates: Seq[BasePredicate],\n+                      projections: Seq[UnsafeProjection],\n+                      projectTargetCols: UnsafeProjection,\n+                      projectDeleteRow: UnsafeProjection,\n+                      inputRow: InternalRow,\n+                      targetRowNotPresent: Boolean): InternalRow = {\n+    // Find the first combination where the predicate evaluates to true", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA1MzYwNw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559053607", "bodyText": "I think that find does guarantee the order and gives you the first one, which would be the first case that matches. I didn't see the syntax with multiple clauses and extra predicates in the SQL 2003 spec, so this might just be an extension that some implementations use. We should definitely check the semantics.", "author": "rdblue", "createdAt": "2021-01-16T23:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODY1ODI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA5Mjg3OA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559092878", "bodyText": "@aokolnychyi @rdblue\nIn my understanding, if we have overlapping conditions in two match branches i.e for example ..\nWHEN MATCHED AND id > 0 and id < 10  UPDATE *\nWHEN MATCHED AND id = 5  or id = 21 DELETE\nThen we will just honor the first match and so if a row comes with id = 5, then we will update. And if a row with id 21 is present, then we will delete.", "author": "dilipbiswal", "createdAt": "2021-01-17T07:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODY1ODI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcwOTMyMg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558709322", "bodyText": "The operation passed to the merge builder should be merge. And we will want to add tests that the isolation level is carried through correctly.", "author": "rdblue", "createdAt": "2021-01-16T00:28:36Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.PlanHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+\n+object RewriteMergeInto extends Rule[LogicalPlan] with PlanHelper with Logging  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records\n+      case MergeIntoTable(target: DataSourceV2Relation,\n+                          source: LogicalPlan, cond, actions, notActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.\n+        val prunedTargetPlan = Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)\n+        val writeInfo = newWriteInfo(target.schema)\n+        val mergeBuilder = target.table.asMergeable.newMergeBuilder(\"delete\", writeInfo)", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcwOTg1Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558709852", "bodyText": "Is there a better name than prunedTargetPlan? What about matchedRowsPlan?", "author": "rdblue", "createdAt": "2021-01-16T00:29:33Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.PlanHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+\n+object RewriteMergeInto extends Rule[LogicalPlan] with PlanHelper with Logging  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records\n+      case MergeIntoTable(target: DataSourceV2Relation,\n+                          source: LogicalPlan, cond, actions, notActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.\n+        val prunedTargetPlan = Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcxNDE4Nw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558714187", "bodyText": "I think that this will require a reference to the target table because _file needs to come from the target table and not the source table. Right now it works because the target table is the only one with _file defined, but I think we should plan on selecting the right column if there are duplicates. If I were to define a column _file in the source data, it may not work.", "author": "rdblue", "createdAt": "2021-01-16T00:37:14Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/utils/PlanHelper.scala", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.spark.sql.catalyst.utils\n+\n+import java.util.UUID\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeReference, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, DynamicFileFilter, LogicalPlan}\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2ScanRelation}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+trait PlanHelper extends PredicateHelper {\n+  val FILE_NAME_COL = \"_file\"\n+  val ROW_POS_COL = \"_pos\"\n+\n+  def buildScanPlan(table: Table,\n+                    output: Seq[AttributeReference],\n+                    mergeBuilder: MergeBuilder,\n+                    prunedTargetPlan: LogicalPlan): LogicalPlan = {\n+\n+    val scanBuilder = mergeBuilder.asScanBuilder\n+    val scan = scanBuilder.build()\n+    val scanRelation = DataSourceV2ScanRelation(table, scan, toOutputAttrs(scan.readSchema(), output))\n+\n+    scan match {\n+      case filterable: SupportsFileFilter =>\n+        val matchingFilePlan = buildFileFilterPlan(prunedTargetPlan)\n+        val dynamicFileFilter = DynamicFileFilter(scanRelation, matchingFilePlan, filterable)\n+        dynamicFileFilter\n+      case _ =>\n+        scanRelation\n+    }\n+  }\n+\n+  private def buildFileFilterPlan(prunedTargetPlan: LogicalPlan): LogicalPlan = {", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA2NTczOA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559065738", "bodyText": "@rdblue We will have issue if target has a column named _file as well, right ? I will mark it as a TODO and address in a follow-up, if its okay ? Need to think how to disambiguate this .. probably though a alias which checks for presence of the column and assigns a unique alias ?", "author": "dilipbiswal", "createdAt": "2021-01-17T02:13:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcxNDE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcxNzc1NQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558717755", "bodyText": "We want this scan to be shared by both the file filter plan and the scan relation. I think that means that this can't accept the matchedRowsPlan / prunedTargetPlan:\n\nWe don't want to plan the scan twice\nThe scan built by MergeBuilder is going to have _file and _pos automatically added. If we want to reference those, we should use this scan.\n\nThat means we'll have to add the inner join here, or pass the scanRelation to a function that produces the inner join. I think that's what @aokolnychyi was proposing in his version of this class.", "author": "rdblue", "createdAt": "2021-01-16T00:43:43Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/utils/PlanHelper.scala", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.spark.sql.catalyst.utils\n+\n+import java.util.UUID\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeReference, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, DynamicFileFilter, LogicalPlan}\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2ScanRelation}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+trait PlanHelper extends PredicateHelper {\n+  val FILE_NAME_COL = \"_file\"\n+  val ROW_POS_COL = \"_pos\"\n+\n+  def buildScanPlan(table: Table,\n+                    output: Seq[AttributeReference],\n+                    mergeBuilder: MergeBuilder,\n+                    prunedTargetPlan: LogicalPlan): LogicalPlan = {\n+\n+    val scanBuilder = mergeBuilder.asScanBuilder\n+    val scan = scanBuilder.build()\n+    val scanRelation = DataSourceV2ScanRelation(table, scan, toOutputAttrs(scan.readSchema(), output))", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcyMjM0NA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558722344", "bodyText": "Also, we will need to extract the predicates from the match condition that only reference the target table. Because the scan relation is built here, we need to push all predicates that can be used to filter the target table in this method. It should be a matter of checking which expressions contain only references in the target table's attribute set.\nWe may want to do this in a follow-up. If so, it would be good to add a TODO comment for it.", "author": "rdblue", "createdAt": "2021-01-16T00:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcxNzc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcyOTM1MQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558729351", "bodyText": "Nevermind on the second comment. Anton's update handles it.", "author": "rdblue", "createdAt": "2021-01-16T01:04:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcxNzc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcyMzY5Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558723692", "bodyText": "Could you use one import per line? That will help avoid git conflicts in the future.\nAlso, we don't use wildcard imports in Iceberg because it can cause conflicts and it isn't clear where symbols are coming from when reading PRs.", "author": "rdblue", "createdAt": "2021-01-16T00:54:09Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODcyNDU4MQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558724581", "bodyText": "If you replace lit(true).expr with an expression, then this doesn't need to pull in sql.functions._. I added a constant:\n  private val TRUE = Literal(true, BooleanType)", "author": "rdblue", "createdAt": "2021-01-16T00:55:48Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.internal.Logging\n+import org.apache.spark.sql.catalyst.expressions._\n+import org.apache.spark.sql.catalyst.plans.{FullOuter, Inner}\n+import org.apache.spark.sql.catalyst.plans.logical._\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.PlanHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.functions._\n+import org.apache.spark.sql.internal.SQLConf\n+\n+object RewriteMergeInto extends Rule[LogicalPlan] with PlanHelper with Logging  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      // rewrite all operations that require reading the table to delete records\n+      case MergeIntoTable(target: DataSourceV2Relation,\n+                          source: LogicalPlan, cond, actions, notActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.\n+        val prunedTargetPlan = Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)\n+        val writeInfo = newWriteInfo(target.schema)\n+        val mergeBuilder = target.table.asMergeable.newMergeBuilder(\"delete\", writeInfo)\n+        val targetTableScan =  buildScanPlan(target.table, target.output, mergeBuilder, prunedTargetPlan)\n+\n+        // Construct an outer join to help track changes in source and target.\n+        // TODO : Optimize this to use LEFT ANTI or RIGHT OUTER when applicable.\n+        val sourceTableProj = source.output ++ Seq(Alias(lit(true).expr, ROW_FROM_SOURCE)())", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODczNDY3MA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558734670", "bodyText": "Nit: to make this class more readable, we've been separating cases with a blank line.", "author": "rdblue", "createdAt": "2021-01-16T01:14:54Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/ExtendedDataSourceV2Strategy.scala", "diffHunk": "@@ -75,6 +76,8 @@ case class ExtendedDataSourceV2Strategy(spark: SparkSession) extends Strategy {\n     case ReplaceData(_, batchWrite, query) =>\n       ReplaceDataExec(batchWrite, planLater(query)) :: Nil\n \n+    case MergeInto(mergeIntoProcessor, targetRelation, child) =>\n+      MergeIntoExec(mergeIntoProcessor, targetRelation, planLater(child)) :: Nil", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODczNTE4MA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558735180", "bodyText": "Looks like this variable name wasn't updated when the processor was renamed to params.", "author": "rdblue", "createdAt": "2021-01-16T01:15:47Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, BasePredicate, Expression, UnsafeProjection}\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+\n+case class MergeIntoExec(mergeIntoProcessor: MergeIntoParams,", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODczODUwMQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558738501", "bodyText": "Why use a match here and not if (isSourceRowNotPresentPred.eval(inputRow))?\nIf you did that, it would be a bit cleaner:\n      if (isSourceRowNotPresentPred.eval(inputRow)) {\n        projectTargetCols.apply(inputRow)\n      } else if (isTargetRowNotPresentPred.eval(inputRow)) {\n        applyProjection(notMatchedPreds, notMatchedProjs, projectTargetCols,\n          projectDeletedRow, inputRow, true)\n      } else {\n        applyProjection(matchedPreds, matchedProjs, projectTargetCols,\n          projectDeletedRow, inputRow, false)\n      }", "author": "rdblue", "createdAt": "2021-01-16T01:21:57Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, BasePredicate, Expression, UnsafeProjection}\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+\n+case class MergeIntoExec(mergeIntoProcessor: MergeIntoParams,\n+                         @transient targetRelation: DataSourceV2Relation,\n+                         override val child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = targetRelation.output\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    child.execute().mapPartitions {\n+      processPartition(mergeIntoProcessor, _)\n+    }\n+  }\n+\n+  private def generateProjection(exprs: Seq[Expression], attrs: Seq[Attribute]): UnsafeProjection = {\n+    UnsafeProjection.create(exprs, attrs)\n+  }\n+\n+  private def generatePredicate(expr: Expression, attrs: Seq[Attribute]): BasePredicate = {\n+    GeneratePredicate.generate(expr, attrs)\n+  }\n+\n+  def applyProjection(predicates: Seq[BasePredicate],\n+                      projections: Seq[UnsafeProjection],\n+                      projectTargetCols: UnsafeProjection,\n+                      projectDeleteRow: UnsafeProjection,\n+                      inputRow: InternalRow,\n+                      targetRowNotPresent: Boolean): InternalRow = {\n+    // Find the first combination where the predicate evaluates to true\n+    val pair = (predicates zip projections).find {\n+      case (predicate, _) => predicate.eval(inputRow)\n+    }\n+\n+    // Now apply the appropriate projection to either :\n+    // - Insert a row into target\n+    // - Update a row of target\n+    // - Delete a row in target. The projected row will have the deleted bit set.\n+    pair match {\n+      case Some((_, projection)) =>\n+        projection.apply(inputRow)\n+      case None =>\n+        if (targetRowNotPresent) {\n+          projectDeleteRow.apply(inputRow)\n+        } else {\n+          projectTargetCols.apply(inputRow)\n+        }\n+    }\n+  }\n+\n+  def processPartition(params: MergeIntoParams,\n+                       rowIterator: Iterator[InternalRow]): Iterator[InternalRow] = {\n+    val joinedAttrs = params.joinedAttributes\n+    val isSourceRowNotPresentPred = generatePredicate(params.isSourceRowNotPresent, joinedAttrs)\n+    val isTargetRowNotPresentPred = generatePredicate(params.isTargetRowNotPresent, joinedAttrs)\n+    val matchedPreds = params.matchedConditions.map(generatePredicate(_, joinedAttrs))\n+    val matchedProjs = params.matchedOutputs.map(generateProjection(_, joinedAttrs))\n+    val notMatchedPreds = params.notMatchedConditions.map(generatePredicate(_, joinedAttrs))\n+    val notMatchedProjs = params.notMatchedOutputs.map(generateProjection(_, joinedAttrs))\n+    val projectTargetCols = generateProjection(params.targetOutput, joinedAttrs)\n+    val projectDeletedRow = generateProjection(params.deleteOutput, joinedAttrs)\n+\n+    def shouldDeleteRow(row: InternalRow): Boolean =\n+      row.getBoolean(params.targetOutput.size - 1)\n+\n+\n+    def processRow(inputRow: InternalRow): InternalRow = {\n+      isSourceRowNotPresentPred.eval(inputRow) match {", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MDE5NQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558740195", "bodyText": "It seems a bit odd to apply this projection because the target row will be deleted. It seems like we could use the same lazily-initialized row for every delete.", "author": "rdblue", "createdAt": "2021-01-16T01:25:11Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, BasePredicate, Expression, UnsafeProjection}\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+\n+case class MergeIntoExec(mergeIntoProcessor: MergeIntoParams,\n+                         @transient targetRelation: DataSourceV2Relation,\n+                         override val child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = targetRelation.output\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    child.execute().mapPartitions {\n+      processPartition(mergeIntoProcessor, _)\n+    }\n+  }\n+\n+  private def generateProjection(exprs: Seq[Expression], attrs: Seq[Attribute]): UnsafeProjection = {\n+    UnsafeProjection.create(exprs, attrs)\n+  }\n+\n+  private def generatePredicate(expr: Expression, attrs: Seq[Attribute]): BasePredicate = {\n+    GeneratePredicate.generate(expr, attrs)\n+  }\n+\n+  def applyProjection(predicates: Seq[BasePredicate],\n+                      projections: Seq[UnsafeProjection],\n+                      projectTargetCols: UnsafeProjection,\n+                      projectDeleteRow: UnsafeProjection,\n+                      inputRow: InternalRow,\n+                      targetRowNotPresent: Boolean): InternalRow = {\n+    // Find the first combination where the predicate evaluates to true\n+    val pair = (predicates zip projections).find {\n+      case (predicate, _) => predicate.eval(inputRow)\n+    }\n+\n+    // Now apply the appropriate projection to either :\n+    // - Insert a row into target\n+    // - Update a row of target\n+    // - Delete a row in target. The projected row will have the deleted bit set.\n+    pair match {\n+      case Some((_, projection)) =>\n+        projection.apply(inputRow)\n+      case None =>\n+        if (targetRowNotPresent) {\n+          projectDeleteRow.apply(inputRow)", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAzNDQzNw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559034437", "bodyText": "@rdblue I had thought about it. But couldn't think of a way to do it. How about, we create a materialized delete row once per partition like this :\nval deleteExpr = params.targetOutput.dropRight(1).map(e => Literal.default(e.dataType)) ++ Seq(Literal.create(true, BooleanType))\n    val deletedRow1 = UnsafeProjection.create(deleteExpr)\n    val deletedRow = deletedRow1.apply(null)\n\ndeteExpr will come from rewriteMergeInto just like its passed now. Here we will just create the InternalRow once and use it ? Will that work Ryan ?", "author": "dilipbiswal", "createdAt": "2021-01-16T20:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MDE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA1MzQxMA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559053410", "bodyText": "What if we just returned null instead?\nI think the problem is that this is trying to create one output for each input row, then filtering happens afterward. An extra column is added to signal that the row should be kept or not. But we don't need to copy the row if it is going to be removed. We also don't need to copy incoming target rows just to add a true at the end if they are going to be kept.\nSo what if we changed all of the delete cases to produce null instead?\nLet's not worry about this for now, but I'll open a PR after this is merged to simplify and avoid some of the copies.", "author": "rdblue", "createdAt": "2021-01-16T23:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MDE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA2NTk2OQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559065969", "bodyText": "@rdblue OK.", "author": "dilipbiswal", "createdAt": "2021-01-17T02:16:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MDE5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA2NjExNA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559066114", "bodyText": "@rdblue One thing to note is that, the output of the outer join is target cols + source cols. So we have to project out the necessary target columns, i think.", "author": "dilipbiswal", "createdAt": "2021-01-17T02:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MDE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MjM5MQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558742391", "bodyText": "These last two projections are only needed when notMatchedPreds or matchedPreds does not have a default case, i.e. lit(true).\nIn the rewrite, there is also a function, getClauseCondition, that fills in lit(true) if there is no clause condition. But I don't think that any predicates after the true condition are dropped.\nI think we could simplify the logic here and avoid extra clauses by ensuring that both matchedPreds and notMatchedPreds end with lit(true). Then this class would not need to account for the case where no predicate matches and we wouldn't have extra predicates passed through. Last, we wouldn't need the last two projections here or in MergeIntoParams because they would be added to notMatchedProjs or matchedProjs.", "author": "rdblue", "createdAt": "2021-01-16T01:28:55Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, BasePredicate, Expression, UnsafeProjection}\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+\n+case class MergeIntoExec(mergeIntoProcessor: MergeIntoParams,\n+                         @transient targetRelation: DataSourceV2Relation,\n+                         override val child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = targetRelation.output\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    child.execute().mapPartitions {\n+      processPartition(mergeIntoProcessor, _)\n+    }\n+  }\n+\n+  private def generateProjection(exprs: Seq[Expression], attrs: Seq[Attribute]): UnsafeProjection = {\n+    UnsafeProjection.create(exprs, attrs)\n+  }\n+\n+  private def generatePredicate(expr: Expression, attrs: Seq[Attribute]): BasePredicate = {\n+    GeneratePredicate.generate(expr, attrs)\n+  }\n+\n+  def applyProjection(predicates: Seq[BasePredicate],\n+                      projections: Seq[UnsafeProjection],\n+                      projectTargetCols: UnsafeProjection,\n+                      projectDeleteRow: UnsafeProjection,\n+                      inputRow: InternalRow,\n+                      targetRowNotPresent: Boolean): InternalRow = {\n+    // Find the first combination where the predicate evaluates to true\n+    val pair = (predicates zip projections).find {\n+      case (predicate, _) => predicate.eval(inputRow)\n+    }\n+\n+    // Now apply the appropriate projection to either :\n+    // - Insert a row into target\n+    // - Update a row of target\n+    // - Delete a row in target. The projected row will have the deleted bit set.\n+    pair match {\n+      case Some((_, projection)) =>\n+        projection.apply(inputRow)\n+      case None =>\n+        if (targetRowNotPresent) {\n+          projectDeleteRow.apply(inputRow)\n+        } else {\n+          projectTargetCols.apply(inputRow)\n+        }\n+    }\n+  }\n+\n+  def processPartition(params: MergeIntoParams,\n+                       rowIterator: Iterator[InternalRow]): Iterator[InternalRow] = {\n+    val joinedAttrs = params.joinedAttributes\n+    val isSourceRowNotPresentPred = generatePredicate(params.isSourceRowNotPresent, joinedAttrs)\n+    val isTargetRowNotPresentPred = generatePredicate(params.isTargetRowNotPresent, joinedAttrs)\n+    val matchedPreds = params.matchedConditions.map(generatePredicate(_, joinedAttrs))\n+    val matchedProjs = params.matchedOutputs.map(generateProjection(_, joinedAttrs))\n+    val notMatchedPreds = params.notMatchedConditions.map(generatePredicate(_, joinedAttrs))\n+    val notMatchedProjs = params.notMatchedOutputs.map(generateProjection(_, joinedAttrs))\n+    val projectTargetCols = generateProjection(params.targetOutput, joinedAttrs)\n+    val projectDeletedRow = generateProjection(params.deleteOutput, joinedAttrs)", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0NzE5OQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558747199", "bodyText": "I guess projectTargetCols would still be needed for the case where the source row isn't present, but it would still make this a little simpler. Especially the applyProjection method.", "author": "rdblue", "createdAt": "2021-01-16T01:37:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MjM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA5MjEwNg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559092106", "bodyText": "@rdblue\n\nprojectTargetCols represents the expression that needs to be applied on the output of outer join which has columns from both the tables to only project the target output columns plus the deleted flag set to false.\nprojectDeletedRow  does the same but with the \"deleted flag\". I think in the earlier comment we discussed possible ideas to optimize this (will address in follow-up)\n``matchedPredsandnotMatchedPred```  go hand in hand with their corresponding projections that is specified by the user in the WHEN MATCHED  and `WHEN NOT MATCHED` clauses.\n\nGiven this background, can you please explain your idea a little bit ?", "author": "dilipbiswal", "createdAt": "2021-01-17T07:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MjM5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMjkyOQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559832929", "bodyText": "Let's clear this up in a follow-up.", "author": "rdblue", "createdAt": "2021-01-18T23:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0MjM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0NTIyMA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558745220", "bodyText": "I think it would be better to create these pairs just once instead of in every row. After this change and moving the projections into action cases (see comment below), this method signature would be much simpler:\n  def applyProjection(\n      actions: Seq[(BasePredicate, UnsafeProjection)],\n      inputRow: InternalRow): InternalRow = {\n    val pair = actions.find {\n      case (predicate, _) => predicate.eval(inputRow)\n    }\n    ...\n  }", "author": "rdblue", "createdAt": "2021-01-16T01:34:05Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, BasePredicate, Expression, UnsafeProjection}\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.{SparkPlan, UnaryExecNode}\n+\n+case class MergeIntoExec(mergeIntoProcessor: MergeIntoParams,\n+                         @transient targetRelation: DataSourceV2Relation,\n+                         override val child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = targetRelation.output\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    child.execute().mapPartitions {\n+      processPartition(mergeIntoProcessor, _)\n+    }\n+  }\n+\n+  private def generateProjection(exprs: Seq[Expression], attrs: Seq[Attribute]): UnsafeProjection = {\n+    UnsafeProjection.create(exprs, attrs)\n+  }\n+\n+  private def generatePredicate(expr: Expression, attrs: Seq[Attribute]): BasePredicate = {\n+    GeneratePredicate.generate(expr, attrs)\n+  }\n+\n+  def applyProjection(predicates: Seq[BasePredicate],\n+                      projections: Seq[UnsafeProjection],\n+                      projectTargetCols: UnsafeProjection,\n+                      projectDeleteRow: UnsafeProjection,\n+                      inputRow: InternalRow,\n+                      targetRowNotPresent: Boolean): InternalRow = {\n+    // Find the first combination where the predicate evaluates to true\n+    val pair = (predicates zip projections).find {\n+      case (predicate, _) => predicate.eval(inputRow)\n+    }", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAzNTkwMw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559035903", "bodyText": "@rdblue Sorry ryan, you refer to some comment below ? But i don't see any comment below that relates to this particular comment. I understood the part about creating the pairs once. But i don't know how we can avoid passing the projections ?", "author": "dilipbiswal", "createdAt": "2021-01-16T20:25:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0NTIyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA1Mjk1MA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559052950", "bodyText": "This one: #1947 (comment)", "author": "rdblue", "createdAt": "2021-01-16T23:35:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0NTIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0Nzc0Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558747742", "bodyText": "Why is this passing an empty string?", "author": "rdblue", "createdAt": "2021-01-16T01:38:08Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestMergeIntoTable.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchTableException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.TableProperties.DEFAULT_FILE_FORMAT;\n+import static org.apache.iceberg.TableProperties.PARQUET_VECTORIZATION_ENABLED;\n+\n+public class TestMergeIntoTable extends SparkRowLevelOperationsTestBase {\n+  private final String sourceName;\n+  private final String targetName;\n+\n+  public TestMergeIntoTable(String catalogName, String implementation, Map<String, String> config,\n+                            String fileFormat, Boolean vectorized) {\n+    super(catalogName, implementation, config, fileFormat, vectorized);\n+    this.sourceName = tableName(\"source\");\n+    this.targetName = tableName(\"target\");\n+  }\n+\n+  @BeforeClass\n+  public static void setupSparkConf() {\n+    spark.conf().set(\"spark.sql.shuffle.partitions\", \"4\");\n+  }\n+\n+  protected Map<String, String> extraTableProperties() {\n+    return ImmutableMap.of(TableProperties.DELETE_MODE, \"copy-on-write\");\n+  }\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", targetName);\n+    sql(\"DROP TABLE IF EXISTS %s\", sourceName);\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertAllNonMatchingRows() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \\n\" +\n+                     \"USING \" + sourceName + \" AS source \\n\" +\n+                     \"ON target.id = source.id \\n\" +\n+                     \"WHEN NOT MATCHED THEN INSERT * \";\n+\n+    sql(sqlText, \"\");\n+    sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-1\"), row(2, \"emp-id-2\"), row(3, \"emp-id-3\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertOnlyMatchingRows() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \\n\" +\n+                     \"USING \" + sourceName + \" AS source \\n\" +\n+                     \"ON target.id = source.id \\n\" +\n+                     \"WHEN NOT MATCHED AND (source.id >= 2) THEN INSERT * \";\n+\n+    sql(sqlText, \"\");\n+    List<Object[]> res = sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(2, \"emp-id-2\"), row(3, \"emp-id-3\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testOnlyUpdate() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(targetName, new Employee(1, \"emp-id-one\"), new Employee(6, \"emp-id-6\"));\n+    append(sourceName, new Employee(2, \"emp-id-2\"), new Employee(1, \"emp-id-1\"), new Employee(6, \"emp-id-6\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \\n\" +\n+            \"USING \" + sourceName + \" AS source \\n\" +\n+            \"ON target.id = source.id \\n\" +\n+            \"WHEN MATCHED AND target.id = 1 THEN UPDATE SET * \";\n+\n+    sql(sqlText, \"\");\n+    List<Object[]> res = sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-1\"), row(6, \"emp-id-6\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testOnlyDelete() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(targetName, new Employee(1, \"emp-id-one\"), new Employee(6, \"emp-id-6\"));\n+    append(sourceName, new Employee(2, \"emp-id-2\"), new Employee(1, \"emp-id-1\"), new Employee(6, \"emp-id-6\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \\n\" +\n+            \"USING \" + sourceName + \" AS source \\n\" +\n+            \"ON target.id = source.id \\n\" +\n+            \"WHEN MATCHED AND target.id = 6 THEN DELETE\";\n+\n+    sql(sqlText, \"\");", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAzNTk3OQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559035979", "bodyText": "@rdblue Sorry.. don't know why i was doing it. Will remove.", "author": "dilipbiswal", "createdAt": "2021-01-16T20:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0Nzc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0NzkxNw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r558747917", "bodyText": "Why did you choose to include the newlines?", "author": "rdblue", "createdAt": "2021-01-16T01:38:29Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestMergeIntoTable.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchTableException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.TableProperties.DEFAULT_FILE_FORMAT;\n+import static org.apache.iceberg.TableProperties.PARQUET_VECTORIZATION_ENABLED;\n+\n+public class TestMergeIntoTable extends SparkRowLevelOperationsTestBase {\n+  private final String sourceName;\n+  private final String targetName;\n+\n+  public TestMergeIntoTable(String catalogName, String implementation, Map<String, String> config,\n+                            String fileFormat, Boolean vectorized) {\n+    super(catalogName, implementation, config, fileFormat, vectorized);\n+    this.sourceName = tableName(\"source\");\n+    this.targetName = tableName(\"target\");\n+  }\n+\n+  @BeforeClass\n+  public static void setupSparkConf() {\n+    spark.conf().set(\"spark.sql.shuffle.partitions\", \"4\");\n+  }\n+\n+  protected Map<String, String> extraTableProperties() {\n+    return ImmutableMap.of(TableProperties.DELETE_MODE, \"copy-on-write\");\n+  }\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", targetName);\n+    sql(\"DROP TABLE IF EXISTS %s\", sourceName);\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertAllNonMatchingRows() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \\n\" +\n+                     \"USING \" + sourceName + \" AS source \\n\" +\n+                     \"ON target.id = source.id \\n\" +\n+                     \"WHEN NOT MATCHED THEN INSERT * \";\n+\n+    sql(sqlText, \"\");\n+    sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-1\"), row(2, \"emp-id-2\"), row(3, \"emp-id-3\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertOnlyMatchingRows() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \\n\" +\n+                     \"USING \" + sourceName + \" AS source \\n\" +\n+                     \"ON target.id = source.id \\n\" +\n+                     \"WHEN NOT MATCHED AND (source.id >= 2) THEN INSERT * \";\n+\n+    sql(sqlText, \"\");\n+    List<Object[]> res = sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(2, \"emp-id-2\"), row(3, \"emp-id-3\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testOnlyUpdate() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(targetName, new Employee(1, \"emp-id-one\"), new Employee(6, \"emp-id-6\"));\n+    append(sourceName, new Employee(2, \"emp-id-2\"), new Employee(1, \"emp-id-1\"), new Employee(6, \"emp-id-6\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \\n\" +\n+            \"USING \" + sourceName + \" AS source \\n\" +\n+            \"ON target.id = source.id \\n\" +\n+            \"WHEN MATCHED AND target.id = 1 THEN UPDATE SET * \";\n+\n+    sql(sqlText, \"\");\n+    List<Object[]> res = sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-1\"), row(6, \"emp-id-6\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testOnlyDelete() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(targetName, new Employee(1, \"emp-id-one\"), new Employee(6, \"emp-id-6\"));\n+    append(sourceName, new Employee(2, \"emp-id-2\"), new Employee(1, \"emp-id-1\"), new Employee(6, \"emp-id-6\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \\n\" +", "originalCommit": "946bbded4eb82639a9e3db7fb90172dab827508c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTAzNjE1Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559036152", "bodyText": "@rdblue i guess, its not required. I thought if we print out the SQL as part of some error or debugging, it will just format better. I will remove the newlines.", "author": "dilipbiswal", "createdAt": "2021-01-16T20:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0NzkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA1MjkxOQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559052919", "bodyText": "I'm fine either way, it was just a surprise.", "author": "rdblue", "createdAt": "2021-01-16T23:34:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODc0NzkxNw=="}], "type": "inlineReview"}, {"oid": "9db80c8f340b2e9c3e11f19a0a687d411c8dbc29", "url": "https://github.com/apache/iceberg/commit/9db80c8f340b2e9c3e11f19a0a687d411c8dbc29", "message": "Spark MERGE INTO Support (copy-on-write implementation", "committedDate": "2021-01-17T08:17:29Z", "type": "commit"}, {"oid": "d82afba8da1da306791e82969c12fb6da0b2f0de", "url": "https://github.com/apache/iceberg/commit/d82afba8da1da306791e82969c12fb6da0b2f0de", "message": "Rebase + Scalastyle + cleancompile", "committedDate": "2021-01-17T08:17:29Z", "type": "commit"}, {"oid": "35f68137c102c9609754c83b8a11a462fd5a8e1f", "url": "https://github.com/apache/iceberg/commit/35f68137c102c9609754c83b8a11a462fd5a8e1f", "message": "Code review + base infrastructure", "committedDate": "2021-01-17T08:17:29Z", "type": "commit"}, {"oid": "c92a2d8e3854ee25d02c87477f33932aa4b6401e", "url": "https://github.com/apache/iceberg/commit/c92a2d8e3854ee25d02c87477f33932aa4b6401e", "message": "Code review comments", "committedDate": "2021-01-17T08:17:29Z", "type": "forcePushed"}, {"oid": "9cb2e86f1962fc02b65065253f5ab3c3c18ade09", "url": "https://github.com/apache/iceberg/commit/9cb2e86f1962fc02b65065253f5ab3c3c18ade09", "message": "Code review comments (Round-2)", "committedDate": "2021-01-17T08:46:12Z", "type": "commit"}, {"oid": "9cb2e86f1962fc02b65065253f5ab3c3c18ade09", "url": "https://github.com/apache/iceberg/commit/9cb2e86f1962fc02b65065253f5ab3c3c18ade09", "message": "Code review comments (Round-2)", "committedDate": "2021-01-17T08:46:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNDU2MA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559824560", "bodyText": "@dilipbiswal, this extraction is already done in the pushFilters method that @aokolnychyi implemented for delete. That's one reason why this also passes down target.output. The filters that are pushed down are the ones that only reference those attributes:\n    val tableAttrSet = AttributeSet(tableAttrs)\n    val predicates = splitConjunctivePredicates(cond).filter(_.references.subsetOf(tableAttrSet))\n    if (predicates.nonEmpty) {\n      val normalizedPredicates = DataSourceStrategy.normalizeExprs(predicates, tableAttrs)\n      PushDownUtils.pushFilters(scanBuilder, normalizedPredicates)\n    }", "author": "rdblue", "createdAt": "2021-01-18T22:46:52Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.analysis.Resolver\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.Expression\n+import org.apache.spark.sql.catalyst.expressions.InputFileName\n+import org.apache.spark.sql.catalyst.expressions.IsNull\n+import org.apache.spark.sql.catalyst.expressions.Literal\n+import org.apache.spark.sql.catalyst.plans.FullOuter\n+import org.apache.spark.sql.catalyst.plans.Inner\n+import org.apache.spark.sql.catalyst.plans.logical.DeleteAction\n+import org.apache.spark.sql.catalyst.plans.logical.InsertAction\n+import org.apache.spark.sql.catalyst.plans.logical.Join\n+import org.apache.spark.sql.catalyst.plans.logical.JoinHint\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.plans.logical.MergeAction\n+import org.apache.spark.sql.catalyst.plans.logical.MergeInto\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoTable\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.catalyst.plans.logical.ReplaceData\n+import org.apache.spark.sql.catalyst.plans.logical.UpdateAction\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.RewriteRowLevelOperationHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.BooleanType\n+\n+case class RewriteMergeInto(conf: SQLConf) extends Rule[LogicalPlan] with RewriteRowLevelOperationHelper  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+  private val TRUE_LITERAL = Literal(true, BooleanType)\n+  private val FALSE_LITERAL = Literal(false, BooleanType)\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def resolver: Resolver = conf.resolver\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      case MergeIntoTable(target: DataSourceV2Relation, source: LogicalPlan, cond, matchedActions, notMatchedActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.\n+        val writeInfo = newWriteInfo(target.schema)\n+        val mergeBuilder = target.table.asMergeable.newMergeBuilder(\"merge\", writeInfo)\n+        val matchingRowsPlanBuilder = (_: DataSourceV2ScanRelation) =>\n+          Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)\n+        // TODO - extract the local predicates that references the target from the join condition and\n+        // pass to buildScanPlan to ensure push-down.", "originalCommit": "9cb2e86f1962fc02b65065253f5ab3c3c18ade09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMDgyNA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559830824", "bodyText": "@rdblue Yeah.. i saw it Ryan. I checked the spark code and there is an additional check for deterministic status of the expression. Not sure for delete statement, we need this check or not ? Wanted to think through and discuss with you and Anton and thats why put a to-do.", "author": "dilipbiswal", "createdAt": "2021-01-18T23:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNDU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg0NTYxOA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559845618", "bodyText": "The only predicates that will be pushed are those that can be converted to Filter. I don't think any non-deterministic expressions can be converted so it should be fine.", "author": "rdblue", "createdAt": "2021-01-19T00:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNDU2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg0NTgxMA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559845810", "bodyText": "okay.", "author": "dilipbiswal", "createdAt": "2021-01-19T00:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNDU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNTMxMA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559825310", "bodyText": "This file is no longer used, so it can be removed.", "author": "rdblue", "createdAt": "2021-01-18T22:49:26Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/utils/PlanHelper.scala", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.spark.sql.catalyst.utils\n+\n+import java.util.UUID\n+import org.apache.spark.sql.AnalysisException\n+import org.apache.spark.sql.catalyst.expressions.{Attribute, AttributeReference, PredicateHelper}\n+import org.apache.spark.sql.catalyst.plans.logical.{Aggregate, DynamicFileFilter, LogicalPlan}\n+import org.apache.spark.sql.connector.catalog.Table\n+import org.apache.spark.sql.connector.iceberg.read.SupportsFileFilter\n+import org.apache.spark.sql.connector.iceberg.write.MergeBuilder\n+import org.apache.spark.sql.connector.write.{LogicalWriteInfo, LogicalWriteInfoImpl}\n+import org.apache.spark.sql.execution.datasources.v2.{DataSourceV2ScanRelation}\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.util.CaseInsensitiveStringMap\n+\n+trait PlanHelper extends PredicateHelper {", "originalCommit": "9cb2e86f1962fc02b65065253f5ab3c3c18ade09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgyNTk4Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559825982", "bodyText": "This can use TRUE_LITERAL.", "author": "rdblue", "createdAt": "2021-01-18T22:52:06Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.analysis.Resolver\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.Expression\n+import org.apache.spark.sql.catalyst.expressions.InputFileName\n+import org.apache.spark.sql.catalyst.expressions.IsNull\n+import org.apache.spark.sql.catalyst.expressions.Literal\n+import org.apache.spark.sql.catalyst.plans.FullOuter\n+import org.apache.spark.sql.catalyst.plans.Inner\n+import org.apache.spark.sql.catalyst.plans.logical.DeleteAction\n+import org.apache.spark.sql.catalyst.plans.logical.InsertAction\n+import org.apache.spark.sql.catalyst.plans.logical.Join\n+import org.apache.spark.sql.catalyst.plans.logical.JoinHint\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.plans.logical.MergeAction\n+import org.apache.spark.sql.catalyst.plans.logical.MergeInto\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoTable\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.catalyst.plans.logical.ReplaceData\n+import org.apache.spark.sql.catalyst.plans.logical.UpdateAction\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.RewriteRowLevelOperationHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.BooleanType\n+\n+case class RewriteMergeInto(conf: SQLConf) extends Rule[LogicalPlan] with RewriteRowLevelOperationHelper  {\n+  val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  val ROW_FROM_TARGET = \"_row_from_target_\"\n+  private val TRUE_LITERAL = Literal(true, BooleanType)\n+  private val FALSE_LITERAL = Literal(false, BooleanType)\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def resolver: Resolver = conf.resolver\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      case MergeIntoTable(target: DataSourceV2Relation, source: LogicalPlan, cond, matchedActions, notMatchedActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.\n+        val writeInfo = newWriteInfo(target.schema)\n+        val mergeBuilder = target.table.asMergeable.newMergeBuilder(\"merge\", writeInfo)\n+        val matchingRowsPlanBuilder = (_: DataSourceV2ScanRelation) =>\n+          Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)\n+        // TODO - extract the local predicates that references the target from the join condition and\n+        // pass to buildScanPlan to ensure push-down.\n+        val targetTableScan = buildScanPlan(target.table, target.output, mergeBuilder, None, matchingRowsPlanBuilder)\n+\n+        // Construct an outer join to help track changes in source and target.\n+        // TODO : Optimize this to use LEFT ANTI or RIGHT OUTER when applicable.\n+        val sourceTableProj = source.output ++ Seq(Alias(TRUE_LITERAL, ROW_FROM_SOURCE)())\n+        val targetTableProj = target.output ++ Seq(Alias(TRUE_LITERAL, ROW_FROM_TARGET)())\n+        val newTargetTableScan = Project(targetTableProj, targetTableScan)\n+        val newSourceTableScan = Project(sourceTableProj, source)\n+        val joinPlan = Join(newSourceTableScan, newTargetTableScan, FullOuter, Some(cond), JoinHint.NONE)\n+\n+        // Construct the plan to replace the data based on the output of `MergeInto`\n+        val mergeParams = MergeIntoParams(\n+          isSourceRowNotPresent = IsNull(findOutputAttr(joinPlan, ROW_FROM_SOURCE)),\n+          isTargetRowNotPresent = IsNull(findOutputAttr(joinPlan, ROW_FROM_TARGET)),\n+          matchedConditions = matchedActions.map(getClauseCondition),\n+          matchedOutputs = matchedActions.map(actionOutput(_, targetOutputCols)),\n+          notMatchedConditions = notMatchedActions.map(getClauseCondition),\n+          notMatchedOutputs = notMatchedActions.map(actionOutput(_, targetOutputCols)),\n+          targetOutput = targetOutputCols :+ FALSE_LITERAL,\n+          deleteOutput = targetOutputCols :+ TRUE_LITERAL,\n+          joinedAttributes = joinPlan.output\n+        )\n+        val mergePlan = MergeInto(mergeParams, target, joinPlan)\n+        val batchWrite = mergeBuilder.asWriteBuilder.buildForBatch()\n+        ReplaceData(target, batchWrite, mergePlan)\n+    }\n+  }\n+\n+  private def actionOutput(clause: MergeAction, targetOutputCols: Seq[Expression]): Seq[Expression] = {\n+    clause match {\n+      case u: UpdateAction =>\n+        u.assignments.map(_.value) :+ FALSE_LITERAL\n+      case _: DeleteAction =>\n+        targetOutputCols :+ TRUE_LITERAL\n+      case i: InsertAction =>\n+        i.assignments.map(_.value) :+ FALSE_LITERAL\n+    }\n+  }\n+\n+  private def getClauseCondition(clause: MergeAction): Expression = {\n+    clause.condition.getOrElse(Literal(true))", "originalCommit": "9cb2e86f1962fc02b65065253f5ab3c3c18ade09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "url": "https://github.com/apache/iceberg/commit/227a1081dfc460840c0c611a01d6eb5fed9de15f", "message": "Missed code review comments", "committedDate": "2021-01-18T22:58:47Z", "type": "commit"}, {"oid": "9f264b752cb6a1c81133985d139f3cdb4b42b008", "url": "https://github.com/apache/iceberg/commit/9f264b752cb6a1c81133985d139f3cdb4b42b008", "message": "More review", "committedDate": "2021-01-18T23:03:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMDc3Ng==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559830776", "bodyText": "This newline isn't needed. Lines up to 120 characters are allowed.", "author": "rdblue", "createdAt": "2021-01-18T23:11:03Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.analysis.Resolver\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.Expression\n+import org.apache.spark.sql.catalyst.expressions.InputFileName\n+import org.apache.spark.sql.catalyst.expressions.IsNull\n+import org.apache.spark.sql.catalyst.expressions.Literal\n+import org.apache.spark.sql.catalyst.plans.FullOuter\n+import org.apache.spark.sql.catalyst.plans.Inner\n+import org.apache.spark.sql.catalyst.plans.logical.DeleteAction\n+import org.apache.spark.sql.catalyst.plans.logical.InsertAction\n+import org.apache.spark.sql.catalyst.plans.logical.Join\n+import org.apache.spark.sql.catalyst.plans.logical.JoinHint\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.plans.logical.MergeAction\n+import org.apache.spark.sql.catalyst.plans.logical.MergeInto\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoTable\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.catalyst.plans.logical.ReplaceData\n+import org.apache.spark.sql.catalyst.plans.logical.UpdateAction\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.RewriteRowLevelOperationHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.BooleanType\n+\n+case class RewriteMergeInto(conf: SQLConf) extends Rule[LogicalPlan] with RewriteRowLevelOperationHelper  {\n+  private val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  private val ROW_FROM_TARGET = \"_row_from_target_\"\n+  private val TRUE_LITERAL = Literal(true, BooleanType)\n+  private val FALSE_LITERAL = Literal(false, BooleanType)\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def resolver: Resolver = conf.resolver\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      case MergeIntoTable(target: DataSourceV2Relation, source: LogicalPlan, cond, matchedActions, notMatchedActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMDc4Nw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559830787", "bodyText": "This plan must use the v2 scan relation. Otherwise, the _file column is not projected. This should be:\n    val matchingRowsPlanBuilder = (rel: DataSourceV2ScanRelation) =>\n        Join(source, rel, Inner, Some(cond), JoinHint.NONE)\nThen you can also remove newProjectCols and newTargetTable.", "author": "rdblue", "createdAt": "2021-01-18T23:11:06Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteMergeInto.scala", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.catalyst.optimizer\n+\n+import org.apache.spark.sql.catalyst.analysis.Resolver\n+import org.apache.spark.sql.catalyst.expressions.Alias\n+import org.apache.spark.sql.catalyst.expressions.Expression\n+import org.apache.spark.sql.catalyst.expressions.InputFileName\n+import org.apache.spark.sql.catalyst.expressions.IsNull\n+import org.apache.spark.sql.catalyst.expressions.Literal\n+import org.apache.spark.sql.catalyst.plans.FullOuter\n+import org.apache.spark.sql.catalyst.plans.Inner\n+import org.apache.spark.sql.catalyst.plans.logical.DeleteAction\n+import org.apache.spark.sql.catalyst.plans.logical.InsertAction\n+import org.apache.spark.sql.catalyst.plans.logical.Join\n+import org.apache.spark.sql.catalyst.plans.logical.JoinHint\n+import org.apache.spark.sql.catalyst.plans.logical.LogicalPlan\n+import org.apache.spark.sql.catalyst.plans.logical.MergeAction\n+import org.apache.spark.sql.catalyst.plans.logical.MergeInto\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoTable\n+import org.apache.spark.sql.catalyst.plans.logical.Project\n+import org.apache.spark.sql.catalyst.plans.logical.ReplaceData\n+import org.apache.spark.sql.catalyst.plans.logical.UpdateAction\n+import org.apache.spark.sql.catalyst.rules.Rule\n+import org.apache.spark.sql.catalyst.utils.RewriteRowLevelOperationHelper\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2Relation\n+import org.apache.spark.sql.execution.datasources.v2.DataSourceV2ScanRelation\n+import org.apache.spark.sql.internal.SQLConf\n+import org.apache.spark.sql.types.BooleanType\n+\n+case class RewriteMergeInto(conf: SQLConf) extends Rule[LogicalPlan] with RewriteRowLevelOperationHelper  {\n+  private val ROW_FROM_SOURCE = \"_row_from_source_\"\n+  private val ROW_FROM_TARGET = \"_row_from_target_\"\n+  private val TRUE_LITERAL = Literal(true, BooleanType)\n+  private val FALSE_LITERAL = Literal(false, BooleanType)\n+\n+  import org.apache.spark.sql.execution.datasources.v2.ExtendedDataSourceV2Implicits._\n+\n+  override def resolver: Resolver = conf.resolver\n+\n+  override def apply(plan: LogicalPlan): LogicalPlan = {\n+    plan resolveOperators {\n+      case MergeIntoTable(target: DataSourceV2Relation, source: LogicalPlan, cond, matchedActions, notMatchedActions) =>\n+        val targetOutputCols = target.output\n+        val newProjectCols = target.output ++ Seq(Alias(InputFileName(), FILE_NAME_COL)())\n+        val newTargetTable = Project(newProjectCols, target)\n+\n+        // Construct the plan to prune target based on join condition between source and\n+        // target.\n+        val writeInfo = newWriteInfo(target.schema)\n+        val mergeBuilder = target.table.asMergeable.newMergeBuilder(\"merge\", writeInfo)\n+        val matchingRowsPlanBuilder = (_: DataSourceV2ScanRelation) =>\n+          Join(source, newTargetTable, Inner, Some(cond), JoinHint.NONE)", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMTQ5NQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559831495", "bodyText": "You can solve this problem by passing the target table attrs from the DataSourceV2ScanRelation:\n    val matchingFilePlan = buildFileFilterPlan(scanRelation.output, matchingRowsPlanBuilder(scanRelation))\n  ...\n\n  private def buildFileFilterPlan(tableAttrs: Seq[AttributeReference], matchingRowsPlan: LogicalPlan): LogicalPlan = {\n    val fileAttr = findOutputAttr(tableAttrs, FILE_NAME_COL)\n    val agg = Aggregate(Seq(fileAttr), Seq(fileAttr), matchingRowsPlan)\n    Project(Seq(findOutputAttr(agg.output, FILE_NAME_COL)), agg)\n  }\n\n  protected def findOutputAttr(attrs: Seq[Attribute], attrName: String): Attribute = {\n    attrs.find(attr => resolver(attr.name, attrName)).getOrElse {\n      throw new AnalysisException(s\"Cannot find $attrName in $attrs\")\n    }\n  }", "author": "rdblue", "createdAt": "2021-01-18T23:14:49Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/utils/RewriteRowLevelOperationHelper.scala", "diffHunk": "@@ -103,6 +103,7 @@ trait RewriteRowLevelOperationHelper extends PredicateHelper with Logging {\n   }\n \n   private def buildFileFilterPlan(matchingRowsPlan: LogicalPlan): LogicalPlan = {\n+    // TODO: For merge-into make sure _file is resolved only from target table.", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMzU5NA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559833594", "bodyText": "@rdblue Don't we have an issue of the target table has a column named \"_file\" ? I was thinking we may need a way to solve it by creating a distinct co-relation name if _file is existing in the target relation's output ?", "author": "dilipbiswal", "createdAt": "2021-01-18T23:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMTQ5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg0NjM2Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559846362", "bodyText": "I think it should be fine. We should throw an exception if the table has a _file column, but that's something we can do later.", "author": "rdblue", "createdAt": "2021-01-19T00:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMTQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMTYxNQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559831615", "bodyText": "I don't think this change is needed because Anton's update already extracts the correct filters from cond.", "author": "rdblue", "createdAt": "2021-01-18T23:15:18Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/utils/RewriteRowLevelOperationHelper.scala", "diffHunk": "@@ -54,12 +54,12 @@ trait RewriteRowLevelOperationHelper extends PredicateHelper with Logging {\n       table: Table,\n       tableAttrs: Seq[AttributeReference],\n       mergeBuilder: MergeBuilder,\n-      cond: Expression,\n+      cond: Option[Expression] = None,\n       matchingRowsPlanBuilder: DataSourceV2ScanRelation => LogicalPlan): LogicalPlan = {\n \n     val scanBuilder = mergeBuilder.asScanBuilder\n \n-    pushFilters(scanBuilder, cond, tableAttrs)\n+    cond.map(pushFilters(scanBuilder, _, tableAttrs))", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzNzE1Nw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559837157", "bodyText": "@rdblue ok.. i will change it for now. We will discuss the deterministic thing later.", "author": "dilipbiswal", "createdAt": "2021-01-18T23:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMTYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMTk4Nw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559831987", "bodyText": "Style: this is a doc comment because it starts with /**. Usually, multi-line comments in code would use //   on each line.", "author": "rdblue", "createdAt": "2021-01-18T23:16:48Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.expressions.BasePredicate\n+import org.apache.spark.sql.catalyst.expressions.Expression\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.UnaryExecNode\n+\n+case class MergeIntoExec(\n+    mergeIntoParams: MergeIntoParams,\n+    @transient targetRelation: DataSourceV2Relation,\n+    override val child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = targetRelation.output\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    child.execute().mapPartitions {\n+      processPartition(mergeIntoParams, _)\n+    }\n+  }\n+\n+  private def generateProjection(exprs: Seq[Expression], attrs: Seq[Attribute]): UnsafeProjection = {\n+    UnsafeProjection.create(exprs, attrs)\n+  }\n+\n+  private def generatePredicate(expr: Expression, attrs: Seq[Attribute]): BasePredicate = {\n+    GeneratePredicate.generate(expr, attrs)\n+  }\n+\n+  def applyProjection(\n+     actions: Seq[(BasePredicate, UnsafeProjection)],\n+     projectTargetCols: UnsafeProjection,\n+     projectDeleteRow: UnsafeProjection,\n+     inputRow: InternalRow,\n+     targetRowNotPresent: Boolean): InternalRow = {\n+\n+    /**\n+     * Find the first combination where the predicate evaluates to true.\n+     * In case when there are overlapping condition in the MATCHED\n+     * clauses, for the first one that satisfies the predicate, the\n+     * corresponding action is applied. For example:\n+     *\n+     * WHEN MATCHED AND id > 1 AND id < 10 UPDATE *\n+     * WHEN MATCHED AND id = 5 OR id = 21 DELETE\n+     *\n+     * In above case, when id = 5, it applies both that matched predicates. In this\n+     * case the first one we see is applied.\n+     */", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzMzk2Nw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559833967", "bodyText": "Nit: could use filterNot(shouldDeleteRow) instead.", "author": "rdblue", "createdAt": "2021-01-18T23:25:32Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.expressions.BasePredicate\n+import org.apache.spark.sql.catalyst.expressions.Expression\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.UnaryExecNode\n+\n+case class MergeIntoExec(\n+    mergeIntoParams: MergeIntoParams,\n+    @transient targetRelation: DataSourceV2Relation,\n+    override val child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = targetRelation.output\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    child.execute().mapPartitions {\n+      processPartition(mergeIntoParams, _)\n+    }\n+  }\n+\n+  private def generateProjection(exprs: Seq[Expression], attrs: Seq[Attribute]): UnsafeProjection = {\n+    UnsafeProjection.create(exprs, attrs)\n+  }\n+\n+  private def generatePredicate(expr: Expression, attrs: Seq[Attribute]): BasePredicate = {\n+    GeneratePredicate.generate(expr, attrs)\n+  }\n+\n+  def applyProjection(\n+     actions: Seq[(BasePredicate, UnsafeProjection)],\n+     projectTargetCols: UnsafeProjection,\n+     projectDeleteRow: UnsafeProjection,\n+     inputRow: InternalRow,\n+     targetRowNotPresent: Boolean): InternalRow = {\n+\n+    /**\n+     * Find the first combination where the predicate evaluates to true.\n+     * In case when there are overlapping condition in the MATCHED\n+     * clauses, for the first one that satisfies the predicate, the\n+     * corresponding action is applied. For example:\n+     *\n+     * WHEN MATCHED AND id > 1 AND id < 10 UPDATE *\n+     * WHEN MATCHED AND id = 5 OR id = 21 DELETE\n+     *\n+     * In above case, when id = 5, it applies both that matched predicates. In this\n+     * case the first one we see is applied.\n+     */\n+\n+    val pair = actions.find {\n+      case (predicate, _) => predicate.eval(inputRow)\n+    }\n+\n+    // Now apply the appropriate projection to either :\n+    // - Insert a row into target\n+    // - Update a row of target\n+    // - Delete a row in target. The projected row will have the deleted bit set.\n+    pair match {\n+      case Some((_, projection)) =>\n+        projection.apply(inputRow)\n+      case None =>\n+        if (targetRowNotPresent) {\n+          projectDeleteRow.apply(inputRow)\n+        } else {\n+          projectTargetCols.apply(inputRow)\n+        }\n+    }\n+  }\n+\n+  def processPartition(\n+     params: MergeIntoParams,\n+     rowIterator: Iterator[InternalRow]): Iterator[InternalRow] = {\n+\n+    val joinedAttrs = params.joinedAttributes\n+    val isSourceRowNotPresentPred = generatePredicate(params.isSourceRowNotPresent, joinedAttrs)\n+    val isTargetRowNotPresentPred = generatePredicate(params.isTargetRowNotPresent, joinedAttrs)\n+    val matchedPreds = params.matchedConditions.map(generatePredicate(_, joinedAttrs))\n+    val matchedProjs = params.matchedOutputs.map(generateProjection(_, joinedAttrs))\n+    val notMatchedPreds = params.notMatchedConditions.map(generatePredicate(_, joinedAttrs))\n+    val notMatchedProjs = params.notMatchedOutputs.map(generateProjection(_, joinedAttrs))\n+    val projectTargetCols = generateProjection(params.targetOutput, joinedAttrs)\n+    val projectDeletedRow = generateProjection(params.deleteOutput, joinedAttrs)\n+    val nonMatchedPairs =   notMatchedPreds zip notMatchedProjs\n+    val matchedPairs = matchedPreds zip matchedProjs\n+\n+    def shouldDeleteRow(row: InternalRow): Boolean =\n+      row.getBoolean(params.targetOutput.size - 1)\n+\n+\n+    /**\n+     * This method is responsible for processing a input row to emit the resultant row with an\n+     * additional column that indicates whether the row is going to be included in the final\n+     * output of merge or not.\n+     * 1. If there is a target row for which there is no corresponding source row (join condition not met)\n+     *    - Only project the target columns with deleted flag set to false.\n+     * 2. If there is a source row for which there is no corresponding target row (join condition not met)\n+     *    - Apply the not matched actions (i.e INSERT actions) if non match conditions are met.\n+     * 3. If there is a source row for which there is a corresponding target row (join condition met)\n+     *    - Apply the matched actions (i.e DELETE or UPDATE actions) if match conditions are met.\n+     */\n+    def processRow(inputRow: InternalRow): InternalRow = {\n+      if (isSourceRowNotPresentPred.eval(inputRow)) {\n+        projectTargetCols.apply(inputRow)\n+      } else if (isTargetRowNotPresentPred.eval(inputRow)) {\n+        applyProjection(nonMatchedPairs, projectTargetCols, projectDeletedRow, inputRow, true)\n+      } else {\n+        applyProjection(matchedPairs, projectTargetCols, projectDeletedRow, inputRow, false)\n+      }\n+    }\n+\n+    rowIterator\n+      .map(processRow)\n+      .filter(!shouldDeleteRow(_))", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzNDQ1Mw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559834453", "bodyText": "This should be the merge equivalent.", "author": "rdblue", "createdAt": "2021-01-18T23:27:26Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestMergeIntoTable.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchTableException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.TableProperties.DEFAULT_FILE_FORMAT;\n+import static org.apache.iceberg.TableProperties.PARQUET_VECTORIZATION_ENABLED;\n+\n+public class TestMergeIntoTable extends SparkRowLevelOperationsTestBase {\n+  private final String sourceName;\n+  private final String targetName;\n+\n+  public TestMergeIntoTable(String catalogName, String implementation, Map<String, String> config,\n+                            String fileFormat, Boolean vectorized) {\n+    super(catalogName, implementation, config, fileFormat, vectorized);\n+    this.sourceName = tableName(\"source\");\n+    this.targetName = tableName(\"target\");\n+  }\n+\n+  @BeforeClass\n+  public static void setupSparkConf() {\n+    spark.conf().set(\"spark.sql.shuffle.partitions\", \"4\");\n+  }\n+\n+  protected Map<String, String> extraTableProperties() {\n+    return ImmutableMap.of(TableProperties.DELETE_MODE, \"copy-on-write\");", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f293356f830d1fe05056bfd820cc470b1de6110", "url": "https://github.com/apache/iceberg/commit/6f293356f830d1fe05056bfd820cc470b1de6110", "message": "Review - contd.", "committedDate": "2021-01-18T23:38:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzNzM4OA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559837388", "bodyText": "I don't think that there is a need to test this with both Hive and Hadoop catalogs or with all 3 formats, since the main thing that needs to be tested is conversion and Spark behavior. Also, this doesn't test partitioned tables at all. To fix those, I think this should customize parameters:\n  @Parameterized.Parameters(\n      name = \"catalogName = {0}, implementation = {1}, config = {2}, format = {3}, vectorized = {4}, partitioned = {5}\")\n  public static Object[][] parameters() {\n    return new Object[][] {\n        { \"testhive\", SparkCatalog.class.getName(),\n            ImmutableMap.of(\n                \"type\", \"hive\",\n                \"default-namespace\", \"default\"\n            ),\n            \"parquet\",\n            true,\n            false\n        },\n        { \"spark_catalog\", SparkSessionCatalog.class.getName(),\n            ImmutableMap.of(\n                \"type\", \"hive\",\n                \"default-namespace\", \"default\",\n                \"clients\", \"1\",\n                \"parquet-enabled\", \"false\",\n                \"cache-enabled\", \"false\" // Spark will delete tables using v1, leaving the cache out of sync\n            ),\n            \"parquet\",\n            false,\n            true\n        }\n    };\n  }\n\n  public TestMergeIntoTable(String catalogName, String implementation, Map<String, String> config,\n                            String fileFormat, Boolean vectorized, Boolean partitioned) {\n    super(catalogName, implementation, config, fileFormat, vectorized);\n    this.partitioned = partitioned;\n    this.sourceName = tableName(\"source\");\n    this.targetName = tableName(\"target\");\n  }\nI also added a partitioned boolean and moved all of the createAndInit calls into a @Before:\n  @Before\n  public void createTables() {\n    if (partitioned) {\n      createAndInitPartitionedTargetTable(targetName);\n    } else {\n      createAndInitUnPartitionedTargetTable(targetName);\n    }\n    createAndInitSourceTable(sourceName);\n  }\nWith those changes, tests run faster and cover partitioned tables.", "author": "rdblue", "createdAt": "2021-01-18T23:40:27Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestMergeIntoTable.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchTableException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.TableProperties.DEFAULT_FILE_FORMAT;\n+import static org.apache.iceberg.TableProperties.PARQUET_VECTORIZATION_ENABLED;\n+\n+public class TestMergeIntoTable extends SparkRowLevelOperationsTestBase {\n+  private final String sourceName;\n+  private final String targetName;\n+\n+  public TestMergeIntoTable(String catalogName, String implementation, Map<String, String> config,", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzOTk3Nw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559839977", "bodyText": "@rdblue Ryan, i had added the partitioning test cases in the grouby/sort pr ? I wasn't doing it via parameter as i was testing individual part and sort expressions. Can you please take a quick look ? I am thinking how those tests work with the proposed changes of creating tables in @before and also with the introduction of partition parameter.", "author": "dilipbiswal", "createdAt": "2021-01-18T23:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzNzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg0MjY2Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559842662", "bodyText": "Okay, sounds fine to me. Let's still make the parameter changes, but remove the partitioned parameter.", "author": "rdblue", "createdAt": "2021-01-19T00:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzNzM4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg0Mjk3Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559842972", "bodyText": "ok.. will do. thank you Ryan for doing such a thorough review. Really appreciate !!", "author": "dilipbiswal", "createdAt": "2021-01-19T00:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzNzM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzODUwMQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559838501", "bodyText": "Rather than embedding the names directly, you can pass them to the sql method, like removeTables does:\nsql(\"MERGE INTO %s AS target USING %s AS source ...\", targetName, sourceName);", "author": "rdblue", "createdAt": "2021-01-18T23:45:55Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestMergeIntoTable.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchTableException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.TableProperties.DEFAULT_FILE_FORMAT;\n+import static org.apache.iceberg.TableProperties.PARQUET_VECTORIZATION_ENABLED;\n+\n+public class TestMergeIntoTable extends SparkRowLevelOperationsTestBase {\n+  private final String sourceName;\n+  private final String targetName;\n+\n+  public TestMergeIntoTable(String catalogName, String implementation, Map<String, String> config,\n+                            String fileFormat, Boolean vectorized) {\n+    super(catalogName, implementation, config, fileFormat, vectorized);\n+    this.sourceName = tableName(\"source\");\n+    this.targetName = tableName(\"target\");\n+  }\n+\n+  @BeforeClass\n+  public static void setupSparkConf() {\n+    spark.conf().set(\"spark.sql.shuffle.partitions\", \"4\");\n+  }\n+\n+  protected Map<String, String> extraTableProperties() {\n+    return ImmutableMap.of(TableProperties.DELETE_MODE, \"copy-on-write\");\n+  }\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", targetName);\n+    sql(\"DROP TABLE IF EXISTS %s\", sourceName);\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertAllNonMatchingRows() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \" +\n+                     \"USING \" + sourceName + \" AS source \" +", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzODcxNQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559838715", "bodyText": "This select has no effect, can you remove it?", "author": "rdblue", "createdAt": "2021-01-18T23:46:58Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestMergeIntoTable.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchTableException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.TableProperties.DEFAULT_FILE_FORMAT;\n+import static org.apache.iceberg.TableProperties.PARQUET_VECTORIZATION_ENABLED;\n+\n+public class TestMergeIntoTable extends SparkRowLevelOperationsTestBase {\n+  private final String sourceName;\n+  private final String targetName;\n+\n+  public TestMergeIntoTable(String catalogName, String implementation, Map<String, String> config,\n+                            String fileFormat, Boolean vectorized) {\n+    super(catalogName, implementation, config, fileFormat, vectorized);\n+    this.sourceName = tableName(\"source\");\n+    this.targetName = tableName(\"target\");\n+  }\n+\n+  @BeforeClass\n+  public static void setupSparkConf() {\n+    spark.conf().set(\"spark.sql.shuffle.partitions\", \"4\");\n+  }\n+\n+  protected Map<String, String> extraTableProperties() {\n+    return ImmutableMap.of(TableProperties.DELETE_MODE, \"copy-on-write\");\n+  }\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", targetName);\n+    sql(\"DROP TABLE IF EXISTS %s\", sourceName);\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertAllNonMatchingRows() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \" +\n+                     \"USING \" + sourceName + \" AS source \" +\n+                     \"ON target.id = source.id \" +\n+                     \"WHEN NOT MATCHED THEN INSERT * \";\n+\n+    sql(sqlText);\n+    sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzOTQ2Ng==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559839466", "bodyText": "Looks like there are other cases where SELECT statements run but are not used. Can you remove all of them?", "author": "rdblue", "createdAt": "2021-01-18T23:50:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzODcxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzOTA3OQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559839079", "bodyText": "res is not used in this test or others. Can you remove this line?", "author": "rdblue", "createdAt": "2021-01-18T23:48:26Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestMergeIntoTable.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchTableException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.TableProperties.DEFAULT_FILE_FORMAT;\n+import static org.apache.iceberg.TableProperties.PARQUET_VECTORIZATION_ENABLED;\n+\n+public class TestMergeIntoTable extends SparkRowLevelOperationsTestBase {\n+  private final String sourceName;\n+  private final String targetName;\n+\n+  public TestMergeIntoTable(String catalogName, String implementation, Map<String, String> config,\n+                            String fileFormat, Boolean vectorized) {\n+    super(catalogName, implementation, config, fileFormat, vectorized);\n+    this.sourceName = tableName(\"source\");\n+    this.targetName = tableName(\"target\");\n+  }\n+\n+  @BeforeClass\n+  public static void setupSparkConf() {\n+    spark.conf().set(\"spark.sql.shuffle.partitions\", \"4\");\n+  }\n+\n+  protected Map<String, String> extraTableProperties() {\n+    return ImmutableMap.of(TableProperties.DELETE_MODE, \"copy-on-write\");\n+  }\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", targetName);\n+    sql(\"DROP TABLE IF EXISTS %s\", sourceName);\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertAllNonMatchingRows() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \" +\n+                     \"USING \" + sourceName + \" AS source \" +\n+                     \"ON target.id = source.id \" +\n+                     \"WHEN NOT MATCHED THEN INSERT * \";\n+\n+    sql(sqlText);\n+    sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-1\"), row(2, \"emp-id-2\"), row(3, \"emp-id-3\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertOnlyMatchingRows() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \" +\n+                     \"USING \" + sourceName + \" AS source \" +\n+                     \"ON target.id = source.id \" +\n+                     \"WHEN NOT MATCHED AND (source.id >= 2) THEN INSERT * \";\n+\n+    sql(sqlText);\n+    List<Object[]> res = sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzOTM5Mg==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559839392", "bodyText": "@rdblue sorry... had used this for debugging and forgot to remove it later.", "author": "dilipbiswal", "createdAt": "2021-01-18T23:49:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTgzOTA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg0MTU5Nw==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559841597", "bodyText": "The employee dep is identical for both records with id 6, so the assertion can't distinguish between the case where employee 6 is replaced or not. Could you update the original target data to emp-id-six and assert that it is unchanged because of the target.id = 1 requirement?", "author": "rdblue", "createdAt": "2021-01-19T00:00:44Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestMergeIntoTable.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchTableException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import static org.apache.iceberg.TableProperties.DEFAULT_FILE_FORMAT;\n+import static org.apache.iceberg.TableProperties.PARQUET_VECTORIZATION_ENABLED;\n+\n+public class TestMergeIntoTable extends SparkRowLevelOperationsTestBase {\n+  private final String sourceName;\n+  private final String targetName;\n+\n+  public TestMergeIntoTable(String catalogName, String implementation, Map<String, String> config,\n+                            String fileFormat, Boolean vectorized) {\n+    super(catalogName, implementation, config, fileFormat, vectorized);\n+    this.sourceName = tableName(\"source\");\n+    this.targetName = tableName(\"target\");\n+  }\n+\n+  @BeforeClass\n+  public static void setupSparkConf() {\n+    spark.conf().set(\"spark.sql.shuffle.partitions\", \"4\");\n+  }\n+\n+  protected Map<String, String> extraTableProperties() {\n+    return ImmutableMap.of(TableProperties.DELETE_MODE, \"copy-on-write\");\n+  }\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", targetName);\n+    sql(\"DROP TABLE IF EXISTS %s\", sourceName);\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertAllNonMatchingRows() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \" +\n+                     \"USING \" + sourceName + \" AS source \" +\n+                     \"ON target.id = source.id \" +\n+                     \"WHEN NOT MATCHED THEN INSERT * \";\n+\n+    sql(sqlText);\n+    sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-1\"), row(2, \"emp-id-2\"), row(3, \"emp-id-3\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertOnlyMatchingRows() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO \" + targetName + \" AS target \" +\n+                     \"USING \" + sourceName + \" AS source \" +\n+                     \"ON target.id = source.id \" +\n+                     \"WHEN NOT MATCHED AND (source.id >= 2) THEN INSERT * \";\n+\n+    sql(sqlText);\n+    List<Object[]> res = sql(\"SELECT * FROM %s ORDER BY id, dep\", targetName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(2, \"emp-id-2\"), row(3, \"emp-id-3\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testOnlyUpdate() throws NoSuchTableException {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+    append(targetName, new Employee(1, \"emp-id-one\"), new Employee(6, \"emp-id-6\"));", "originalCommit": "227a1081dfc460840c0c611a01d6eb5fed9de15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg0Mjc0MA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559842740", "bodyText": "Nit: extra newline.", "author": "rdblue", "createdAt": "2021-01-19T00:06:45Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.expressions.BasePredicate\n+import org.apache.spark.sql.catalyst.expressions.Expression\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.UnaryExecNode\n+\n+case class MergeIntoExec(\n+    mergeIntoParams: MergeIntoParams,\n+    @transient targetRelation: DataSourceV2Relation,\n+    override val child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = targetRelation.output\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    child.execute().mapPartitions {\n+      processPartition(mergeIntoParams, _)\n+    }\n+  }\n+\n+  private def generateProjection(exprs: Seq[Expression], attrs: Seq[Attribute]): UnsafeProjection = {\n+    UnsafeProjection.create(exprs, attrs)\n+  }\n+\n+  private def generatePredicate(expr: Expression, attrs: Seq[Attribute]): BasePredicate = {\n+    GeneratePredicate.generate(expr, attrs)\n+  }\n+\n+  def applyProjection(\n+     actions: Seq[(BasePredicate, UnsafeProjection)],\n+     projectTargetCols: UnsafeProjection,\n+     projectDeleteRow: UnsafeProjection,\n+     inputRow: InternalRow,\n+     targetRowNotPresent: Boolean): InternalRow = {\n+\n+\n+    // Find the first combination where the predicate evaluates to true.\n+    // In case when there are overlapping condition in the MATCHED\n+    // clauses, for the first one that satisfies the predicate, the\n+    // corresponding action is applied. For example:\n+    //\n+    // WHEN MATCHED AND id > 1 AND id < 10 UPDATE *\n+    // WHEN MATCHED AND id = 5 OR id = 21 DELETE\n+    //\n+    // In above case, when id = 5, it applies both that matched predicates. In this\n+    // case the first one we see is applied.\n+    //\n+\n+    val pair = actions.find {\n+      case (predicate, _) => predicate.eval(inputRow)\n+    }\n+\n+    // Now apply the appropriate projection to either :\n+    // - Insert a row into target\n+    // - Update a row of target\n+    // - Delete a row in target. The projected row will have the deleted bit set.\n+    pair match {\n+      case Some((_, projection)) =>\n+        projection.apply(inputRow)\n+      case None =>\n+        if (targetRowNotPresent) {\n+          projectDeleteRow.apply(inputRow)\n+        } else {\n+          projectTargetCols.apply(inputRow)\n+        }\n+    }\n+  }\n+\n+  def processPartition(\n+     params: MergeIntoParams,\n+     rowIterator: Iterator[InternalRow]): Iterator[InternalRow] = {\n+\n+    val joinedAttrs = params.joinedAttributes\n+    val isSourceRowNotPresentPred = generatePredicate(params.isSourceRowNotPresent, joinedAttrs)\n+    val isTargetRowNotPresentPred = generatePredicate(params.isTargetRowNotPresent, joinedAttrs)\n+    val matchedPreds = params.matchedConditions.map(generatePredicate(_, joinedAttrs))\n+    val matchedProjs = params.matchedOutputs.map(generateProjection(_, joinedAttrs))\n+    val notMatchedPreds = params.notMatchedConditions.map(generatePredicate(_, joinedAttrs))\n+    val notMatchedProjs = params.notMatchedOutputs.map(generateProjection(_, joinedAttrs))\n+    val projectTargetCols = generateProjection(params.targetOutput, joinedAttrs)\n+    val projectDeletedRow = generateProjection(params.deleteOutput, joinedAttrs)\n+    val nonMatchedPairs =   notMatchedPreds zip notMatchedProjs\n+    val matchedPairs = matchedPreds zip matchedProjs\n+\n+    def shouldDeleteRow(row: InternalRow): Boolean =\n+      row.getBoolean(params.targetOutput.size - 1)\n+", "originalCommit": "6f293356f830d1fe05056bfd820cc470b1de6110", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d7caece5de862437092fbbd58702f41fc66d8fdd", "url": "https://github.com/apache/iceberg/commit/d7caece5de862437092fbbd58702f41fc66d8fdd", "message": "Code review", "committedDate": "2021-01-19T01:00:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg2MjI3OQ==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559862279", "bodyText": "@dilipbiswal, this can be reverted as well.", "author": "rdblue", "createdAt": "2021-01-19T01:34:46Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/catalyst/optimizer/RewriteDelete.scala", "diffHunk": "@@ -56,7 +56,7 @@ case class RewriteDelete(conf: SQLConf) extends Rule[LogicalPlan] with RewriteRo\n       d\n \n     // rewrite all operations that require reading the table to delete records\n-    case DeleteFromTable(r: DataSourceV2Relation, Some(cond)) =>\n+    case DeleteFromTable(r: DataSourceV2Relation, optionalCond @ Some(cond)) =>", "originalCommit": "d7caece5de862437092fbbd58702f41fc66d8fdd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg2Mjc4OA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559862788", "bodyText": "Nit: no need for an empty comment and an empty line.", "author": "rdblue", "createdAt": "2021-01-19T01:36:52Z", "path": "spark3-extensions/src/main/scala/org/apache/spark/sql/execution/datasources/v2/MergeIntoExec.scala", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.spark.sql.execution.datasources.v2\n+\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.catalyst.expressions.Attribute\n+import org.apache.spark.sql.catalyst.expressions.BasePredicate\n+import org.apache.spark.sql.catalyst.expressions.Expression\n+import org.apache.spark.sql.catalyst.expressions.UnsafeProjection\n+import org.apache.spark.sql.catalyst.expressions.codegen.GeneratePredicate\n+import org.apache.spark.sql.catalyst.plans.logical.MergeIntoParams\n+import org.apache.spark.sql.execution.SparkPlan\n+import org.apache.spark.sql.execution.UnaryExecNode\n+\n+case class MergeIntoExec(\n+    mergeIntoParams: MergeIntoParams,\n+    @transient targetRelation: DataSourceV2Relation,\n+    override val child: SparkPlan) extends UnaryExecNode {\n+\n+  override def output: Seq[Attribute] = targetRelation.output\n+\n+  protected override def doExecute(): RDD[InternalRow] = {\n+    child.execute().mapPartitions {\n+      processPartition(mergeIntoParams, _)\n+    }\n+  }\n+\n+  private def generateProjection(exprs: Seq[Expression], attrs: Seq[Attribute]): UnsafeProjection = {\n+    UnsafeProjection.create(exprs, attrs)\n+  }\n+\n+  private def generatePredicate(expr: Expression, attrs: Seq[Attribute]): BasePredicate = {\n+    GeneratePredicate.generate(expr, attrs)\n+  }\n+\n+  def applyProjection(\n+     actions: Seq[(BasePredicate, UnsafeProjection)],\n+     projectTargetCols: UnsafeProjection,\n+     projectDeleteRow: UnsafeProjection,\n+     inputRow: InternalRow,\n+     targetRowNotPresent: Boolean): InternalRow = {\n+\n+\n+    // Find the first combination where the predicate evaluates to true.\n+    // In case when there are overlapping condition in the MATCHED\n+    // clauses, for the first one that satisfies the predicate, the\n+    // corresponding action is applied. For example:\n+    //\n+    // WHEN MATCHED AND id > 1 AND id < 10 UPDATE *\n+    // WHEN MATCHED AND id = 5 OR id = 21 DELETE\n+    //\n+    // In above case, when id = 5, it applies both that matched predicates. In this\n+    // case the first one we see is applied.\n+    //\n+", "originalCommit": "d7caece5de862437092fbbd58702f41fc66d8fdd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg2MzQ3MA==", "url": "https://github.com/apache/iceberg/pull/1947#discussion_r559863470", "bodyText": "Nit: it looks like there are unnecessary string literals. \" \" + \"MERGE ...\" can be updated to \" MERGE ...\".", "author": "rdblue", "createdAt": "2021-01-19T01:39:07Z", "path": "spark3-extensions/src/test/java/org/apache/iceberg/spark/extensions/TestMergeIntoTable.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.spark.extensions;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.iceberg.TableProperties;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableList;\n+import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;\n+import org.apache.iceberg.spark.SparkCatalog;\n+import org.apache.iceberg.spark.SparkSessionCatalog;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.catalyst.analysis.NoSuchTableException;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runners.Parameterized;\n+\n+import static org.apache.iceberg.TableProperties.DEFAULT_FILE_FORMAT;\n+import static org.apache.iceberg.TableProperties.PARQUET_VECTORIZATION_ENABLED;\n+\n+public class TestMergeIntoTable extends SparkRowLevelOperationsTestBase {\n+  private final String sourceName;\n+  private final String targetName;\n+\n+  @Parameterized.Parameters(\n+      name = \"catalogName = {0}, implementation = {1}, config = {2}, format = {3}, vectorized = {4}\")\n+  public static Object[][] parameters() {\n+    return new Object[][] {\n+        { \"testhive\", SparkCatalog.class.getName(),\n+            ImmutableMap.of(\n+                \"type\", \"hive\",\n+                \"default-namespace\", \"default\"\n+            ),\n+            \"parquet\",\n+            true\n+        },\n+        { \"spark_catalog\", SparkSessionCatalog.class.getName(),\n+            ImmutableMap.of(\n+                \"type\", \"hive\",\n+                \"default-namespace\", \"default\",\n+                \"clients\", \"1\",\n+                \"parquet-enabled\", \"false\",\n+                \"cache-enabled\", \"false\" // Spark will delete tables using v1, leaving the cache out of sync\n+            ),\n+            \"parquet\",\n+            false\n+        }\n+    };\n+  }\n+\n+  public TestMergeIntoTable(String catalogName, String implementation, Map<String, String> config,\n+                            String fileFormat, Boolean vectorized) {\n+    super(catalogName, implementation, config, fileFormat, vectorized);\n+    this.sourceName = tableName(\"source\");\n+    this.targetName = tableName(\"target\");\n+  }\n+\n+  @BeforeClass\n+  public static void setupSparkConf() {\n+    spark.conf().set(\"spark.sql.shuffle.partitions\", \"4\");\n+  }\n+\n+  protected Map<String, String> extraTableProperties() {\n+    return ImmutableMap.of(TableProperties.MERGE_MODE, TableProperties.MERGE_MODE_DEFAULT);\n+  }\n+\n+  @Before\n+  public void createTables() {\n+    createAndInitUnPartitionedTargetTable(targetName);\n+    createAndInitSourceTable(sourceName);\n+  }\n+\n+  @After\n+  public void removeTables() {\n+    sql(\"DROP TABLE IF EXISTS %s\", targetName);\n+    sql(\"DROP TABLE IF EXISTS %s\", sourceName);\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertAllNonMatchingRows() throws NoSuchTableException {\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO %s AS target \" +\n+                     \"USING %s AS source \" +\n+                     \"ON target.id = source.id \" +\n+                     \"WHEN NOT MATCHED THEN INSERT * \";\n+\n+    sql(sqlText, targetName, sourceName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-1\"), row(2, \"emp-id-2\"), row(3, \"emp-id-3\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testEmptyTargetInsertOnlyMatchingRows() throws NoSuchTableException {\n+    append(sourceName, new Employee(1, \"emp-id-1\"), new Employee(2, \"emp-id-2\"), new Employee(3, \"emp-id-3\"));\n+    String sqlText = \"MERGE INTO %s AS target \" +\n+                     \"USING %s AS source \" +\n+                     \"ON target.id = source.id \" +\n+                     \"WHEN NOT MATCHED AND (source.id >= 2) THEN INSERT * \";\n+\n+    sql(sqlText, targetName, sourceName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(2, \"emp-id-2\"), row(3, \"emp-id-3\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testOnlyUpdate() throws NoSuchTableException {\n+    append(targetName, new Employee(1, \"emp-id-one\"), new Employee(6, \"emp-id-six\"));\n+    append(sourceName, new Employee(2, \"emp-id-2\"), new Employee(1, \"emp-id-1\"), new Employee(6, \"emp-id-6\"));\n+    String sqlText = \"MERGE INTO %s AS target \" +\n+            \"USING %s AS source \" +\n+            \"ON target.id = source.id \" +\n+            \"WHEN MATCHED AND target.id = 1 THEN UPDATE SET * \";\n+\n+    sql(sqlText, targetName, sourceName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-1\"), row(6, \"emp-id-six\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testOnlyDelete() throws NoSuchTableException {\n+    append(targetName, new Employee(1, \"emp-id-one\"), new Employee(6, \"emp-id-6\"));\n+    append(sourceName, new Employee(2, \"emp-id-2\"), new Employee(1, \"emp-id-1\"), new Employee(6, \"emp-id-6\"));\n+    String sqlText = \"MERGE INTO %s AS target \" +\n+            \"USING %s AS source \" +\n+            \"ON target.id = source.id \" +\n+            \"WHEN MATCHED AND target.id = 6 THEN DELETE\";\n+\n+    sql(sqlText, targetName, sourceName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-one\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testAllCauses() throws NoSuchTableException {\n+    append(targetName, new Employee(1, \"emp-id-one\"), new Employee(6, \"emp-id-6\"));\n+    append(sourceName, new Employee(2, \"emp-id-2\"), new Employee(1, \"emp-id-1\"), new Employee(6, \"emp-id-6\"));\n+    String sqlText = \"MERGE INTO %s AS target \" +\n+                     \"USING %s AS source \" +\n+                     \"ON target.id = source.id \" +\n+                     \"WHEN MATCHED AND target.id = 1 THEN UPDATE SET * \" +\n+                     \"WHEN MATCHED AND target.id = 6 THEN DELETE \" +\n+                     \"WHEN NOT MATCHED AND source.id = 2 THEN INSERT * \";\n+\n+    sql(sqlText, targetName, sourceName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-1\"), row(2, \"emp-id-2\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testAllCausesWithExplicitColumnSpecification() throws NoSuchTableException {\n+    append(targetName, new Employee(1, \"emp-id-one\"), new Employee(6, \"emp-id-6\"));\n+    append(sourceName, new Employee(2, \"emp-id-2\"), new Employee(1, \"emp-id-1\"), new Employee(6, \"emp-id-6\"));\n+    String sqlText = \"MERGE INTO %s AS target \" +\n+            \"USING %s AS source \" +\n+            \"ON target.id = source.id \" +\n+            \"WHEN MATCHED AND target.id = 1 THEN UPDATE SET target.id = source.id, target.dep = source.dep \" +\n+            \"WHEN MATCHED AND target.id = 6 THEN DELETE \" +\n+            \"WHEN NOT MATCHED AND source.id = 2 THEN INSERT (target.id, target.dep) VALUES (source.id, source.dep) \";\n+\n+    sql(sqlText, targetName, sourceName);\n+    assertEquals(\"Should have expected rows\",\n+            ImmutableList.of(row(1, \"emp-id-1\"), row(2, \"emp-id-2\")),\n+            sql(\"SELECT * FROM %s ORDER BY id ASC NULLS LAST\", targetName));\n+  }\n+\n+  @Test\n+  public void testSourceCTE() throws NoSuchTableException {\n+    Assume.assumeFalse(catalogName.equalsIgnoreCase(\"testhadoop\"));\n+    Assume.assumeFalse(catalogName.equalsIgnoreCase(\"testhive\"));\n+\n+    append(targetName, new Employee(2, \"emp-id-two\"), new Employee(6, \"emp-id-6\"));\n+    append(sourceName, new Employee(2, \"emp-id-3\"), new Employee(1, \"emp-id-2\"), new Employee(5, \"emp-id-6\"));\n+    String sourceCTE = \"WITH cte1 AS (SELECT id + 1 AS id, dep FROM source)\";\n+    String sqlText = sourceCTE + \" \" + \"MERGE INTO %s AS target \" +", "originalCommit": "d7caece5de862437092fbbd58702f41fc66d8fdd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9fadc1d85e60d70f91b180bd5352903916cc13fb", "url": "https://github.com/apache/iceberg/commit/9fadc1d85e60d70f91b180bd5352903916cc13fb", "message": "More review", "committedDate": "2021-01-19T02:23:08Z", "type": "commit"}]}