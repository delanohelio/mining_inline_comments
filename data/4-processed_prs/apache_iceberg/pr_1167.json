{"pr_number": 1167, "pr_title": "ORC: Simplify logic to determine which columns have stats", "pr_createdAt": "2020-07-04T23:52:11Z", "pr_url": "https://github.com/apache/iceberg/pull/1167", "timeline": [{"oid": "eadac8d5da4f7911e4734f101c8756ee12f2aea9", "url": "https://github.com/apache/iceberg/commit/eadac8d5da4f7911e4734f101c8756ee12f2aea9", "message": "ORC: Simplify logic to determine which columns have stats.", "committedDate": "2020-07-04T23:48:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk2NTU5OA==", "url": "https://github.com/apache/iceberg/pull/1167#discussion_r449965598", "bodyText": "Just to verify, this would fail if there's any column that does not have an Iceberg ID. Is that preferred to skipping the metrics instead?", "author": "edgarRd", "createdAt": "2020-07-06T03:24:28Z", "path": "orc/src/main/java/org/apache/iceberg/orc/OrcMetrics.java", "diffHunk": "@@ -209,64 +206,17 @@ private static Metrics buildOrcMetrics(final long numOfRows, final TypeDescripti\n     return Optional.ofNullable(Conversions.toByteBuffer(column.type(), max));\n   }\n \n-  private static Set<TypeDescription> findColumnsInContainers(Schema schema,\n-                                                              TypeDescription orcSchema) {\n-    ColumnsInContainersVisitor visitor = new ColumnsInContainersVisitor();\n-    OrcSchemaWithTypeVisitor.visit(schema, orcSchema, visitor);\n-    return visitor.getColumnsInContainers();\n+  private static Set<Integer> statsColumns(TypeDescription schema) {\n+    return OrcSchemaVisitor.visit(schema, new StatsColumnsVisitor());\n   }\n \n-  private static class ColumnsInContainersVisitor extends OrcSchemaWithTypeVisitor<TypeDescription> {\n-\n-    private final Set<TypeDescription> columnsInContainers;\n-\n-    private ColumnsInContainersVisitor() {\n-      columnsInContainers = Sets.newHashSet();\n-    }\n-\n-    public Set<TypeDescription> getColumnsInContainers() {\n-      return columnsInContainers;\n-    }\n-\n-    private Set<TypeDescription> flatten(TypeDescription rootType) {\n-      if (rootType == null) {\n-        return ImmutableSet.of();\n-      }\n-\n-      final Set<TypeDescription> flatTypes = Sets.newHashSetWithExpectedSize(rootType.getMaximumId());\n-      final Queue<TypeDescription> queue = Queues.newLinkedBlockingQueue();\n-      queue.add(rootType);\n-      while (!queue.isEmpty()) {\n-        TypeDescription type = queue.remove();\n-        flatTypes.add(type);\n-        queue.addAll(Optional.ofNullable(type.getChildren()).orElse(ImmutableList.of()));\n-      }\n-      return flatTypes;\n-    }\n-\n-    @Override\n-    public TypeDescription record(Types.StructType iStruct, TypeDescription record,\n-                                  List<String> names, List<TypeDescription> fields) {\n-      return record;\n-    }\n-\n-    @Override\n-    public TypeDescription list(Types.ListType iList, TypeDescription array, TypeDescription element) {\n-      columnsInContainers.addAll(flatten(element));\n-      return array;\n-    }\n-\n-    @Override\n-    public TypeDescription map(Types.MapType iMap, TypeDescription map,\n-                    TypeDescription key, TypeDescription value) {\n-      columnsInContainers.addAll(flatten(key));\n-      columnsInContainers.addAll(flatten(value));\n-      return map;\n-    }\n-\n+  private static class StatsColumnsVisitor extends OrcSchemaVisitor<Set<Integer>> {\n     @Override\n-    public TypeDescription primitive(Type.PrimitiveType iPrimitive, TypeDescription primitive) {\n-      return primitive;\n+    public Set<Integer> record(TypeDescription record, List<String> names, List<Set<Integer>> fields) {\n+      ImmutableSet.Builder<Integer> result = ImmutableSet.builder();\n+      fields.stream().filter(Objects::nonNull).forEach(result::addAll);\n+      record.getChildren().stream().map(ORCSchemaUtil::fieldId).forEach(result::add);", "originalCommit": "eadac8d5da4f7911e4734f101c8756ee12f2aea9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ0ODg0NQ==", "url": "https://github.com/apache/iceberg/pull/1167#discussion_r450448845", "bodyText": "I think so. This is called when Iceberg wrote the file, so we should be able to assume the IDs are present, right?", "author": "rdblue", "createdAt": "2020-07-06T19:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk2NTU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ2MDQyOQ==", "url": "https://github.com/apache/iceberg/pull/1167#discussion_r450460429", "bodyText": "If the ORC files are written by Iceberg it should be fine. I was thinking for the case of importing existing ORC files although we'd need to implement name mapping fallback strategy.", "author": "edgarRd", "createdAt": "2020-07-06T20:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk2NTU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTk2MDA3Mw==", "url": "https://github.com/apache/iceberg/pull/1167#discussion_r475960073", "bodyText": "I think this breaks pretty much any import of non-Iceberg ORC tables via SparkTableUtil.", "author": "edgarRd", "createdAt": "2020-08-24T23:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTk2NTU5OA=="}], "type": "inlineReview"}]}