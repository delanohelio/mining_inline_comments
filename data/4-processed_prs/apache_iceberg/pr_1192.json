{"pr_number": 1192, "pr_title": "Implement Hive input format", "pr_createdAt": "2020-07-10T01:39:46Z", "pr_url": "https://github.com/apache/iceberg/pull/1192", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzMjk1Mg==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r453132952", "bodyText": "Looks like what's happening is the table location is used as the split's path so that Hive associates all splits with the same PartitionDesc that contains a TableDesc. Is that correct? If so, I think it would be better to add that as the comment. It's difficult to read the Hive code and figure out what's going on using just the pointers here.", "author": "rdblue", "createdAt": "2020-07-11T00:43:10Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergSplit.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.iceberg.mr.SerializationUtil;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplitContainer;\n+\n+// Hive requires file formats to return splits that are instances of `FileSplit`.\n+public class HiveIcebergSplit extends FileSplit implements IcebergSplitContainer {\n+\n+  private IcebergSplit innerSplit;\n+\n+  // The table location of the split allows Hive to map a split to a table and/or partition.\n+  // See calls to `getPartitionDescFromPathRecursively` in `CombineHiveInputFormat` or `HiveInputFormat`.\n+  private String tableLocation;", "originalCommit": "f46b38b081a8d2a3b6b439ab6368c29447808e1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU4NjA1Mg==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r454586052", "bodyText": "Hive uses the path name of the split to map it back to a PartitionDesc or TableDesc, which specify the relevant input format for reading the files belonging to that partition or table. That way, HiveInputFormat and CombineHiveInputFormat can read files with different input formats in the same MR job and combine compatible splits together.\nI'll update the comment.", "author": "guilload", "createdAt": "2020-07-14T19:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzMjk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzMzA0NQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r453133045", "bodyText": "I don't think these last two functions need to change?", "author": "rdblue", "createdAt": "2020-07-11T00:44:03Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/Container.java", "diffHunk": "@@ -21,48 +21,33 @@\n \n import java.io.DataInput;\n import java.io.DataOutput;\n+import java.io.IOException;\n import org.apache.hadoop.io.Writable;\n-import org.apache.iceberg.Schema;\n-import org.apache.iceberg.data.Record;\n \n /**\n- * Wraps an Iceberg Record in a Writable which Hive can use in the SerDe.\n+ * A simple container of objects that you can get and set.\n+ *\n+ * @param <T> the Java type of the object held by this container\n  */\n-public class IcebergWritable implements Writable {\n-\n-  private Record record;\n-  private Schema schema;\n-\n-  public IcebergWritable(Record record, Schema schema) {\n-    this.record = record;\n-    this.schema = schema;\n-  }\n+public class Container<T> implements Writable {\n \n-  @SuppressWarnings(\"checkstyle:HiddenField\")\n-  public void wrapRecord(Record record) {\n-    this.record = record;\n-  }\n-\n-  public Record record() {\n-    return record;\n-  }\n+  private T value;\n \n-  public Schema schema() {\n-    return schema;\n+  public T get() {\n+    return value;\n   }\n \n-  @SuppressWarnings(\"checkstyle:HiddenField\")\n-  public void wrapSchema(Schema schema) {\n-    this.schema = schema;\n+  public void set(T newValue) {\n+    this.value = newValue;\n   }\n \n   @Override\n-  public void write(DataOutput dataOutput) {\n-    throw new UnsupportedOperationException(\"write is not supported.\");\n+  public void readFields(DataInput in) throws IOException {\n+    throw new UnsupportedOperationException(\"readFields is not supported\");", "originalCommit": "f46b38b081a8d2a3b6b439ab6368c29447808e1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzMzQ1OA==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r453133458", "bodyText": "Could you update this to Java class of records constructed by Iceberg; default is {@link Record}?\nIt is odd that this currently states that T could be either A or B, but defaults to C.", "author": "rdblue", "createdAt": "2020-07-11T00:46:50Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/MapredIcebergInputFormat.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+import org.apache.hadoop.mapred.InputFormat;\n+import org.apache.hadoop.mapred.InputSplit;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.hadoop.mapred.RecordReader;\n+import org.apache.hadoop.mapred.Reporter;\n+import org.apache.hadoop.mapred.TaskAttemptContextImpl;\n+import org.apache.hadoop.mapred.TaskAttemptID;\n+import org.apache.hadoop.mapreduce.TaskAttemptContext;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplitContainer;\n+\n+/**\n+ * Generic Mrv1 InputFormat API for Iceberg.\n+ *\n+ * @param <T> T is the in memory data model which can either be Pig tuples, Hive rows. Default is Iceberg records", "originalCommit": "f46b38b081a8d2a3b6b439ab6368c29447808e1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzMzg0OA==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r453133848", "bodyText": "When would mapred.task.id be null? Should we throw an exception in that case?", "author": "rdblue", "createdAt": "2020-07-11T00:49:48Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/MapredIcebergInputFormat.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+import org.apache.hadoop.mapred.InputFormat;\n+import org.apache.hadoop.mapred.InputSplit;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.hadoop.mapred.RecordReader;\n+import org.apache.hadoop.mapred.Reporter;\n+import org.apache.hadoop.mapred.TaskAttemptContextImpl;\n+import org.apache.hadoop.mapred.TaskAttemptID;\n+import org.apache.hadoop.mapreduce.TaskAttemptContext;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplitContainer;\n+\n+/**\n+ * Generic Mrv1 InputFormat API for Iceberg.\n+ *\n+ * @param <T> T is the in memory data model which can either be Pig tuples, Hive rows. Default is Iceberg records\n+ */\n+public class MapredIcebergInputFormat<T> implements InputFormat<Void, Container<T>> {\n+\n+  private final org.apache.iceberg.mr.mapreduce.IcebergInputFormat<T> innerInputFormat;\n+\n+  public MapredIcebergInputFormat() {\n+    this.innerInputFormat = new org.apache.iceberg.mr.mapreduce.IcebergInputFormat<>();\n+  }\n+\n+  /**\n+   * Configures the {@code JobConf} to use the {@code MapredIcebergInputFormat} and\n+   * returns a helper to add further configuration.\n+   *\n+   * @param job the {@code JobConf} to configure\n+   */\n+  public static InputFormatConfig.ConfigBuilder configure(JobConf job) {\n+    job.setInputFormat(MapredIcebergInputFormat.class);\n+    return new InputFormatConfig.ConfigBuilder(job);\n+  }\n+\n+  @Override\n+  public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {\n+    return innerInputFormat.getSplits(getTaskAttemptContext(job))\n+                           .stream()\n+                           .map(InputSplit.class::cast)\n+                           .toArray(InputSplit[]::new);\n+  }\n+\n+  @Override\n+  public RecordReader<Void, Container<T>> getRecordReader(InputSplit split, JobConf job,\n+                                                          Reporter reporter) throws IOException {\n+    IcebergSplit icebergSplit = ((IcebergSplitContainer) split).icebergSplit();\n+    return new MapredIcebergRecordReader<>(innerInputFormat, icebergSplit, job, reporter);\n+  }\n+\n+  static TaskAttemptContext getTaskAttemptContext(JobConf job) {\n+    TaskAttemptID taskAttemptID = Optional.ofNullable(TaskAttemptID.forName(job.get(\"mapred.task.id\")))\n+                                          .orElse(new TaskAttemptID());", "originalCommit": "f46b38b081a8d2a3b6b439ab6368c29447808e1c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzNDkxMQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r453134911", "bodyText": "I'm guessing that this is because an attempt context is passed as a JobContext. Let's fix that problem and then we won't need to do this. The helpers I mentioned also demonstrate how to create a TaskAttemptContext from specific values.", "author": "rdblue", "createdAt": "2020-07-11T00:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzMzg0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyMTQ2NQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r456121465", "bodyText": "I looked into this and Hive (when spawning a local MR job) or YARN populates the mapreduce.task.id and mapreduce.task.attempt.id\" (among many other properties). So I changed this line to: TaskAttemptID.forName(job.get(\"mapreduce.task.attempt.id\"). Several input formats in the Hive codebase do the same.\nI believe it is not the responsibility of the input format to create a TaskAttemptID from scratch and setting the mapred{uce}* properties. The framework using the input format are responsible for that.\nDuring my tests, I've seen that the task attempt it is not set only when Hive uses the the file input format outside of a MR job (single fetch task). This is when we need to fallback to the default constructor.\nThe same logic applies for the JobContext object.", "author": "guilload", "createdAt": "2020-07-16T22:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzMzg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzEzNDY4NA==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r453134684", "bodyText": "getSplits accepts a JobContext and I think it makes sense to pass objects that are as close as possible to what the mapreduce framework would use. We have some helper methods in our branch for reading Hive tables from Spark's DSv2 that you might want to check out: https://github.com/Netflix/iceberg/blob/netflix-spark-2.4/metacat/src/main/java/com/netflix/iceberg/batch/MapReduceUtil.java.\nThose can help you create mapreduce objects after inspecting the mapred objects.", "author": "rdblue", "createdAt": "2020-07-11T00:56:18Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/MapredIcebergInputFormat.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+import org.apache.hadoop.mapred.InputFormat;\n+import org.apache.hadoop.mapred.InputSplit;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.hadoop.mapred.RecordReader;\n+import org.apache.hadoop.mapred.Reporter;\n+import org.apache.hadoop.mapred.TaskAttemptContextImpl;\n+import org.apache.hadoop.mapred.TaskAttemptID;\n+import org.apache.hadoop.mapreduce.TaskAttemptContext;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplitContainer;\n+\n+/**\n+ * Generic Mrv1 InputFormat API for Iceberg.\n+ *\n+ * @param <T> T is the in memory data model which can either be Pig tuples, Hive rows. Default is Iceberg records\n+ */\n+public class MapredIcebergInputFormat<T> implements InputFormat<Void, Container<T>> {\n+\n+  private final org.apache.iceberg.mr.mapreduce.IcebergInputFormat<T> innerInputFormat;\n+\n+  public MapredIcebergInputFormat() {\n+    this.innerInputFormat = new org.apache.iceberg.mr.mapreduce.IcebergInputFormat<>();\n+  }\n+\n+  /**\n+   * Configures the {@code JobConf} to use the {@code MapredIcebergInputFormat} and\n+   * returns a helper to add further configuration.\n+   *\n+   * @param job the {@code JobConf} to configure\n+   */\n+  public static InputFormatConfig.ConfigBuilder configure(JobConf job) {\n+    job.setInputFormat(MapredIcebergInputFormat.class);\n+    return new InputFormatConfig.ConfigBuilder(job);\n+  }\n+\n+  @Override\n+  public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {\n+    return innerInputFormat.getSplits(getTaskAttemptContext(job))", "originalCommit": "f46b38b081a8d2a3b6b439ab6368c29447808e1c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f3928c77ea2498fa363257ddec86ff5090288712", "url": "https://github.com/apache/iceberg/commit/f3928c77ea2498fa363257ddec86ff5090288712", "message": "Forward configuration settings to MR input format", "committedDate": "2020-07-14T01:57:38Z", "type": "forcePushed"}, {"oid": "5109c3934aee502ec541f9a1f5a2e8ed08339011", "url": "https://github.com/apache/iceberg/commit/5109c3934aee502ec541f9a1f5a2e8ed08339011", "message": "Forward configuration settings to MR input format", "committedDate": "2020-07-14T22:54:12Z", "type": "forcePushed"}, {"oid": "9351f1857b224b2a4a90296934d2513587b1245e", "url": "https://github.com/apache/iceberg/commit/9351f1857b224b2a4a90296934d2513587b1245e", "message": "Forward configuration settings to MR input format", "committedDate": "2020-07-14T23:00:39Z", "type": "forcePushed"}, {"oid": "23ad535e8206efb4bbb1bef1a9504051aa4ec80c", "url": "https://github.com/apache/iceberg/commit/23ad535e8206efb4bbb1bef1a9504051aa4ec80c", "message": "Forward configuration settings to MR input format", "committedDate": "2020-07-14T23:04:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDk2NzIyMQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r454967221", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                projection = projectedColumns.isEmpty() ? schema : projection.select(projectedColumns);\n          \n          \n            \n                projection = projectedColumns.isEmpty() ? schema : schema.select(projectedColumns);\n          \n      \n    \n    \n  \n\nShouldn't the code be like above? If not I get a NPE like this when running a HiveRunner test:\n       Caused by:\n                java.lang.NullPointerException\n                    at org.apache.iceberg.mr.hive.HiveIcebergInputFormat.getSplits(HiveIcebergInputFormat.java:58)\n                    at org.apache.hadoop.hive.ql.exec.FetchOperator.getNextSplits(FetchOperator.java:372)\n                    at org.apache.hadoop.hive.ql.exec.FetchOperator.getRecordReader(FetchOperator.java:304)\n                    at org.apache.hadoop.hive.ql.exec.FetchOperator.getNextRow(FetchOperator.java:459)\n                    ... 13 more", "author": "massdosage", "createdAt": "2020-07-15T10:58:42Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergInputFormat.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;\n+import org.apache.hadoop.hive.serde2.ColumnProjectionUtils;\n+import org.apache.hadoop.mapred.InputSplit;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.hadoop.mapred.RecordReader;\n+import org.apache.hadoop.mapred.Reporter;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.mr.mapred.Container;\n+import org.apache.iceberg.mr.mapred.MapredIcebergInputFormat;\n+import org.apache.iceberg.mr.mapred.TableResolver;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+public class HiveIcebergInputFormat extends MapredIcebergInputFormat<Record>\n+                                    implements CombineHiveInputFormat.AvoidSplitCombination {\n+\n+  private transient Table table;\n+  private transient Schema schema;\n+  private transient Schema projection;\n+\n+  @Override\n+  public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {\n+    table = TableResolver.resolveTableFromConfiguration(job);\n+    schema = table.schema();\n+\n+    List<String> projectedColumns = parseProjectedColumns(job);\n+    projection = projectedColumns.isEmpty() ? schema : projection.select(projectedColumns);", "originalCommit": "23ad535e8206efb4bbb1bef1a9504051aa4ec80c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c93671751cf5ded84fba084e784da444e7af05d", "url": "https://github.com/apache/iceberg/commit/7c93671751cf5ded84fba084e784da444e7af05d", "message": "Delete unused file", "committedDate": "2020-07-15T17:27:46Z", "type": "commit"}, {"oid": "b373262cf50391eb1b4d44d49bc3dcbc14b1e80a", "url": "https://github.com/apache/iceberg/commit/b373262cf50391eb1b4d44d49bc3dcbc14b1e80a", "message": "Forward configuration settings to MR input format", "committedDate": "2020-07-15T17:28:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM3MDIzOQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r454370239", "bodyText": "Can these properties ever be null?", "author": "rdsr", "createdAt": "2020-07-14T13:49:43Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergInputFormat.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;\n+import org.apache.hadoop.hive.serde2.ColumnProjectionUtils;\n+import org.apache.hadoop.mapred.InputSplit;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.hadoop.mapred.RecordReader;\n+import org.apache.hadoop.mapred.Reporter;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.mr.mapred.Container;\n+import org.apache.iceberg.mr.mapred.MapredIcebergInputFormat;\n+import org.apache.iceberg.mr.mapred.TableResolver;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+public class HiveIcebergInputFormat extends MapredIcebergInputFormat<Record>\n+                                    implements CombineHiveInputFormat.AvoidSplitCombination {\n+\n+  private transient Table table;\n+  private transient Schema schema;\n+  private transient Schema projection;\n+\n+  @Override\n+  public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {\n+    table = TableResolver.resolveTableFromConfiguration(job);\n+    schema = table.schema();\n+\n+    List<String> projectedColumns = parseProjectedColumns(job);\n+    projection = projectedColumns.isEmpty() ? schema : projection.select(projectedColumns);\n+\n+    forwardConfigSettings(job);\n+\n+    return Arrays.stream(super.getSplits(job, numSplits))\n+                 .map(split -> new HiveIcebergSplit((IcebergSplit) split, table.location()))\n+                 .toArray(InputSplit[]::new);\n+  }\n+\n+  @Override\n+  public RecordReader<Void, Container<Record>> getRecordReader(InputSplit split, JobConf job,\n+                                                               Reporter reporter) throws IOException {\n+    // Since Hive passes a copy of `job` in `getSplits`, we need to forward the conf settings again.\n+    forwardConfigSettings(job);\n+    return super.getRecordReader(split, job, reporter);\n+  }\n+\n+  @Override\n+  public boolean shouldSkipCombine(Path path, Configuration conf) {\n+    return true;\n+  }\n+\n+  /**\n+   * Forward configuration settings to the underlying MR input format.\n+   */\n+  private void forwardConfigSettings(JobConf job) {\n+    Preconditions.checkNotNull(table, \"Table cannot be null\");", "originalCommit": "f3928c77ea2498fa363257ddec86ff5090288712", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4OTE1MA==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r456089150", "bodyText": "Only if getRecordReader is called before getSplits. Happy to remove those checks if we judge them overkill.", "author": "guilload", "createdAt": "2020-07-16T21:30:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM3MDIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4NTg0Mw==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r455285843", "bodyText": "seems like conf  will not be null", "author": "rdsr", "createdAt": "2020-07-15T19:20:14Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergInputFormat.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;\n+import org.apache.hadoop.hive.serde2.ColumnProjectionUtils;\n+import org.apache.hadoop.mapred.InputSplit;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.hadoop.mapred.RecordReader;\n+import org.apache.hadoop.mapred.Reporter;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.mr.mapred.Container;\n+import org.apache.iceberg.mr.mapred.MapredIcebergInputFormat;\n+import org.apache.iceberg.mr.mapred.TableResolver;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+public class HiveIcebergInputFormat extends MapredIcebergInputFormat<Record>\n+                                    implements CombineHiveInputFormat.AvoidSplitCombination {\n+\n+  private transient Table table;\n+  private transient Schema schema;\n+  private transient Schema projection;\n+\n+  @Override\n+  public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {\n+    table = TableResolver.resolveTableFromConfiguration(job);\n+    schema = table.schema();\n+\n+    List<String> projectedColumns = parseProjectedColumns(job);\n+    projection = projectedColumns.isEmpty() ? schema : schema.select(projectedColumns);\n+\n+    forwardConfigSettings(job);\n+\n+    return Arrays.stream(super.getSplits(job, numSplits))\n+                 .map(split -> new HiveIcebergSplit((IcebergSplit) split, table.location()))\n+                 .toArray(InputSplit[]::new);\n+  }\n+\n+  @Override\n+  public RecordReader<Void, Container<Record>> getRecordReader(InputSplit split, JobConf job,\n+                                                               Reporter reporter) throws IOException {\n+    // Since Hive passes a copy of `job` in `getSplits`, we need to forward the conf settings again.\n+    forwardConfigSettings(job);\n+    return super.getRecordReader(split, job, reporter);\n+  }\n+\n+  @Override\n+  public boolean shouldSkipCombine(Path path, Configuration conf) {\n+    return true;\n+  }\n+\n+  /**\n+   * Forward configuration settings to the underlying MR input format.\n+   */\n+  private void forwardConfigSettings(JobConf job) {\n+    Preconditions.checkNotNull(table, \"Table cannot be null\");\n+    Preconditions.checkNotNull(schema, \"Schema cannot be null\");\n+    Preconditions.checkNotNull(projection, \"Projection cannot be null\");\n+\n+    // Once mapred.TableResolver and mapreduce.TableResolver use the same property for the location of the table\n+    // (TABLE_LOCATION vs. TABLE_PATH), this line can be removed: see https://github.com/apache/iceberg/issues/1155.\n+    job.set(InputFormatConfig.TABLE_PATH, table.location());\n+    job.set(InputFormatConfig.TABLE_SCHEMA, SchemaParser.toJson(schema));\n+    job.set(InputFormatConfig.READ_SCHEMA, SchemaParser.toJson(projection));\n+  }\n+\n+  private static List<String> parseProjectedColumns(Configuration conf) {\n+    if (conf == null) {", "originalCommit": "b373262cf50391eb1b4d44d49bc3dcbc14b1e80a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4NzUyNA==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r455287524", "bodyText": "Who is setting these configurations. IcebergStorageHandler?", "author": "rdsr", "createdAt": "2020-07-15T19:23:19Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergInputFormat.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;\n+import org.apache.hadoop.hive.serde2.ColumnProjectionUtils;\n+import org.apache.hadoop.mapred.InputSplit;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.hadoop.mapred.RecordReader;\n+import org.apache.hadoop.mapred.Reporter;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.SchemaParser;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.mr.mapred.Container;\n+import org.apache.iceberg.mr.mapred.MapredIcebergInputFormat;\n+import org.apache.iceberg.mr.mapred.TableResolver;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.relocated.com.google.common.base.Preconditions;\n+\n+public class HiveIcebergInputFormat extends MapredIcebergInputFormat<Record>\n+                                    implements CombineHiveInputFormat.AvoidSplitCombination {\n+\n+  private transient Table table;\n+  private transient Schema schema;\n+  private transient Schema projection;\n+\n+  @Override\n+  public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {\n+    table = TableResolver.resolveTableFromConfiguration(job);", "originalCommit": "b373262cf50391eb1b4d44d49bc3dcbc14b1e80a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4ODUyNA==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r456088524", "bodyText": "Currently, mapred.TableResolver copies the SerDe properties in the main configuration when called in IcebergSerDe. Down the road, IcebergStorageHandler should probably handle this so we can clean this up.", "author": "guilload", "createdAt": "2020-07-16T21:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4NzUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MzI1OQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r455293259", "bodyText": "is this null check required?", "author": "rdsr", "createdAt": "2020-07-15T19:33:35Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/MapredIcebergInputFormat.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+import org.apache.hadoop.mapred.InputFormat;\n+import org.apache.hadoop.mapred.InputSplit;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.hadoop.mapred.RecordReader;\n+import org.apache.hadoop.mapred.Reporter;\n+import org.apache.hadoop.mapred.TaskAttemptContextImpl;\n+import org.apache.hadoop.mapred.TaskAttemptID;\n+import org.apache.hadoop.mapreduce.Counter;\n+import org.apache.hadoop.mapreduce.JobContext;\n+import org.apache.hadoop.mapreduce.JobID;\n+import org.apache.hadoop.mapreduce.TaskAttemptContext;\n+import org.apache.hadoop.mapreduce.task.JobContextImpl;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplitContainer;\n+\n+/**\n+ * Generic MR v1 InputFormat API for Iceberg.\n+ *\n+ * @param <T> Java class of records constructed by Iceberg; default is {@link Record}\n+ */\n+public class MapredIcebergInputFormat<T> implements InputFormat<Void, Container<T>> {\n+\n+  private final org.apache.iceberg.mr.mapreduce.IcebergInputFormat<T> innerInputFormat;\n+\n+  public MapredIcebergInputFormat() {\n+    this.innerInputFormat = new org.apache.iceberg.mr.mapreduce.IcebergInputFormat<>();\n+  }\n+\n+  /**\n+   * Configures the {@code JobConf} to use the {@code MapredIcebergInputFormat} and\n+   * returns a helper to add further configuration.\n+   *\n+   * @param job the {@code JobConf} to configure\n+   */\n+  public static InputFormatConfig.ConfigBuilder configure(JobConf job) {\n+    job.setInputFormat(MapredIcebergInputFormat.class);\n+    return new InputFormatConfig.ConfigBuilder(job);\n+  }\n+\n+  @Override\n+  public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {\n+    return innerInputFormat.getSplits(newJobContext(job))\n+                           .stream()\n+                           .map(InputSplit.class::cast)\n+                           .toArray(InputSplit[]::new);\n+  }\n+\n+  @Override\n+  public RecordReader<Void, Container<T>> getRecordReader(InputSplit split, JobConf job,\n+                                                          Reporter reporter) throws IOException {\n+    IcebergSplit icebergSplit = ((IcebergSplitContainer) split).icebergSplit();\n+    return new MapredIcebergRecordReader<>(innerInputFormat, icebergSplit, job, reporter);\n+  }\n+\n+  private static final class MapredIcebergRecordReader<T> implements RecordReader<Void, Container<T>> {\n+\n+    private final org.apache.hadoop.mapreduce.RecordReader<Void, T> innerReader;\n+    private final long splitLength; // for getPos()\n+\n+    MapredIcebergRecordReader(org.apache.iceberg.mr.mapreduce.IcebergInputFormat<T> mapreduceInputFormat,\n+                              IcebergSplit split, JobConf job, Reporter reporter) throws IOException {\n+      TaskAttemptContext context = newTaskAttemptContext(job, reporter);\n+\n+      try {\n+        innerReader = mapreduceInputFormat.createRecordReader(split, context);\n+        innerReader.initialize(split, context);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        throw new RuntimeException(e);\n+      }\n+\n+      splitLength = split.getLength();\n+    }\n+\n+    @Override\n+    public boolean next(Void key, Container<T> value) throws IOException {\n+      try {\n+        if (innerReader.nextKeyValue()) {\n+          value.set(innerReader.getCurrentValue());\n+          return true;\n+        }\n+      } catch (InterruptedException ie) {\n+        Thread.currentThread().interrupt();\n+        throw new RuntimeException(ie);\n+      }\n+\n+      return false;\n+    }\n+\n+    @Override\n+    public Void createKey() {\n+      return null;\n+    }\n+\n+    @Override\n+    public Container<T> createValue() {\n+      return new Container<>();\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return (long) (splitLength * getProgress());\n+    }\n+\n+    @Override\n+    public float getProgress() throws IOException {\n+      if (innerReader == null) {", "originalCommit": "b373262cf50391eb1b4d44d49bc3dcbc14b1e80a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA5Mzc4OA==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r456093788", "bodyText": "Probably not, will remove.", "author": "guilload", "createdAt": "2020-07-16T21:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5MzI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NDM2Ng==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r455294366", "bodyText": "is JobContext.ID which maps to mapreduce.job.id an MRv2 setting and will not be set for Mrv1 jobs?", "author": "rdsr", "createdAt": "2020-07-15T19:35:39Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapred/MapredIcebergInputFormat.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.mapred;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+import org.apache.hadoop.mapred.InputFormat;\n+import org.apache.hadoop.mapred.InputSplit;\n+import org.apache.hadoop.mapred.JobConf;\n+import org.apache.hadoop.mapred.RecordReader;\n+import org.apache.hadoop.mapred.Reporter;\n+import org.apache.hadoop.mapred.TaskAttemptContextImpl;\n+import org.apache.hadoop.mapred.TaskAttemptID;\n+import org.apache.hadoop.mapreduce.Counter;\n+import org.apache.hadoop.mapreduce.JobContext;\n+import org.apache.hadoop.mapreduce.JobID;\n+import org.apache.hadoop.mapreduce.TaskAttemptContext;\n+import org.apache.hadoop.mapreduce.task.JobContextImpl;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.mr.InputFormatConfig;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplitContainer;\n+\n+/**\n+ * Generic MR v1 InputFormat API for Iceberg.\n+ *\n+ * @param <T> Java class of records constructed by Iceberg; default is {@link Record}\n+ */\n+public class MapredIcebergInputFormat<T> implements InputFormat<Void, Container<T>> {\n+\n+  private final org.apache.iceberg.mr.mapreduce.IcebergInputFormat<T> innerInputFormat;\n+\n+  public MapredIcebergInputFormat() {\n+    this.innerInputFormat = new org.apache.iceberg.mr.mapreduce.IcebergInputFormat<>();\n+  }\n+\n+  /**\n+   * Configures the {@code JobConf} to use the {@code MapredIcebergInputFormat} and\n+   * returns a helper to add further configuration.\n+   *\n+   * @param job the {@code JobConf} to configure\n+   */\n+  public static InputFormatConfig.ConfigBuilder configure(JobConf job) {\n+    job.setInputFormat(MapredIcebergInputFormat.class);\n+    return new InputFormatConfig.ConfigBuilder(job);\n+  }\n+\n+  @Override\n+  public InputSplit[] getSplits(JobConf job, int numSplits) throws IOException {\n+    return innerInputFormat.getSplits(newJobContext(job))\n+                           .stream()\n+                           .map(InputSplit.class::cast)\n+                           .toArray(InputSplit[]::new);\n+  }\n+\n+  @Override\n+  public RecordReader<Void, Container<T>> getRecordReader(InputSplit split, JobConf job,\n+                                                          Reporter reporter) throws IOException {\n+    IcebergSplit icebergSplit = ((IcebergSplitContainer) split).icebergSplit();\n+    return new MapredIcebergRecordReader<>(innerInputFormat, icebergSplit, job, reporter);\n+  }\n+\n+  private static final class MapredIcebergRecordReader<T> implements RecordReader<Void, Container<T>> {\n+\n+    private final org.apache.hadoop.mapreduce.RecordReader<Void, T> innerReader;\n+    private final long splitLength; // for getPos()\n+\n+    MapredIcebergRecordReader(org.apache.iceberg.mr.mapreduce.IcebergInputFormat<T> mapreduceInputFormat,\n+                              IcebergSplit split, JobConf job, Reporter reporter) throws IOException {\n+      TaskAttemptContext context = newTaskAttemptContext(job, reporter);\n+\n+      try {\n+        innerReader = mapreduceInputFormat.createRecordReader(split, context);\n+        innerReader.initialize(split, context);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        throw new RuntimeException(e);\n+      }\n+\n+      splitLength = split.getLength();\n+    }\n+\n+    @Override\n+    public boolean next(Void key, Container<T> value) throws IOException {\n+      try {\n+        if (innerReader.nextKeyValue()) {\n+          value.set(innerReader.getCurrentValue());\n+          return true;\n+        }\n+      } catch (InterruptedException ie) {\n+        Thread.currentThread().interrupt();\n+        throw new RuntimeException(ie);\n+      }\n+\n+      return false;\n+    }\n+\n+    @Override\n+    public Void createKey() {\n+      return null;\n+    }\n+\n+    @Override\n+    public Container<T> createValue() {\n+      return new Container<>();\n+    }\n+\n+    @Override\n+    public long getPos() throws IOException {\n+      return (long) (splitLength * getProgress());\n+    }\n+\n+    @Override\n+    public float getProgress() throws IOException {\n+      if (innerReader == null) {\n+        return 0;\n+      }\n+\n+      try {\n+        return innerReader.getProgress();\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        throw new RuntimeException(e);\n+      }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+      if (innerReader != null) {\n+        innerReader.close();\n+      }\n+    }\n+  }\n+\n+  private static JobContext newJobContext(JobConf job) {\n+    JobID jobID = Optional.ofNullable(JobID.forName(job.get(JobContext.ID)))", "originalCommit": "b373262cf50391eb1b4d44d49bc3dcbc14b1e80a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEwMDIzOQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r456100239", "bodyText": "From what I understand, the mapred.job.id and mapreduce.job.id properties are set by the callers. In practice, I've seen that Hive (when launching a MR job in local-mode) and YARN set the MRv2 properties only.\nI guess the MRv1 properties will be set only if the job is run as a MRv1 job, which should be very rare, right? Do we want to cover this case?", "author": "guilload", "createdAt": "2020-07-16T21:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NDM2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjgwNjEzNQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r456806135", "bodyText": "If JobContext.ID is set correctly for Hive then it should be fine!", "author": "rdsr", "createdAt": "2020-07-18T16:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5NDM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwNzIzNA==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r455307234", "bodyText": "Not sure if this is a big win, but can we have the Container<T> as an interface which can then be implemented by Mrv1Value and HiveIcebergSplit", "author": "rdsr", "createdAt": "2020-07-15T19:59:53Z", "path": "mr/src/main/java/org/apache/iceberg/mr/hive/HiveIcebergSplit.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.mapred.FileSplit;\n+import org.apache.iceberg.mr.SerializationUtil;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplit;\n+import org.apache.iceberg.mr.mapreduce.IcebergSplitContainer;\n+\n+// Hive requires file formats to return splits that are instances of `FileSplit`.\n+public class HiveIcebergSplit extends FileSplit implements IcebergSplitContainer {", "originalCommit": "b373262cf50391eb1b4d44d49bc3dcbc14b1e80a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA5MzUxMQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r456093511", "bodyText": "Container being implemented as a class allows to return a generic Container<T> in MapredIcebergInputFormat.createValue() and express MapredIcebergInputFormat<T> as a generic InputFormat<Void, Container<T>>.  I used DeprecatedParquetInputFormat as a reference.\nCan we do that with an interface?", "author": "guilload", "createdAt": "2020-07-16T21:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwNzIzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkzOTg1MQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r458939851", "bodyText": "I was thinking Mrv1Value would implement Container and HiveIcebergSplit would also implement Container, but that I guess seems not worthwhile for now.", "author": "rdsr", "createdAt": "2020-07-22T16:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwNzIzNA=="}], "type": "inlineReview"}, {"oid": "3cdd9f1a9a408d1cdbf574126b2f96db9bdf32be", "url": "https://github.com/apache/iceberg/commit/3cdd9f1a9a408d1cdbf574126b2f96db9bdf32be", "message": "Add HiveRunner tests", "committedDate": "2020-07-16T02:03:46Z", "type": "forcePushed"}, {"oid": "61859ccf41e42ce6e18a0d281115e04d2bb03273", "url": "https://github.com/apache/iceberg/commit/61859ccf41e42ce6e18a0d281115e04d2bb03273", "message": "Add HiveRunner tests", "committedDate": "2020-07-16T02:39:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA5NjYzNQ==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r456096635", "bodyText": "Hive keeps a cache of input format instance arounds (see HiveInputFormat) that breaks this logic so I've chosen to remove it for now.\nWe can re-implement this later but the logic will have to be a bit more robust.", "author": "guilload", "createdAt": "2020-07-16T21:46:58Z", "path": "mr/src/main/java/org/apache/iceberg/mr/mapreduce/IcebergInputFormat.java", "diffHunk": "@@ -100,11 +94,6 @@\n \n   @Override\n   public List<InputSplit> getSplits(JobContext context) {\n-    if (splits != null) {", "originalCommit": "61859ccf41e42ce6e18a0d281115e04d2bb03273", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "207a416f603d16fb5cebc9c70bf187e350712fb6", "url": "https://github.com/apache/iceberg/commit/207a416f603d16fb5cebc9c70bf187e350712fb6", "message": "Implement MapredIcebergInputFormat", "committedDate": "2020-07-16T22:02:30Z", "type": "commit"}, {"oid": "e5193186e1a05526870f8e822d5e1985512837af", "url": "https://github.com/apache/iceberg/commit/e5193186e1a05526870f8e822d5e1985512837af", "message": "Implement HiveIcebergInputFormat", "committedDate": "2020-07-16T22:02:30Z", "type": "commit"}, {"oid": "6f4fbe2eab62b7454f0ddbacf276a4532b9df684", "url": "https://github.com/apache/iceberg/commit/6f4fbe2eab62b7454f0ddbacf276a4532b9df684", "message": "Forward configuration settings to MR input format", "committedDate": "2020-07-16T22:02:30Z", "type": "commit"}, {"oid": "3b76337a3a198b07fd4140f5de972c1c72f6ca96", "url": "https://github.com/apache/iceberg/commit/3b76337a3a198b07fd4140f5de972c1c72f6ca96", "message": "Remove splits caching", "committedDate": "2020-07-16T22:02:30Z", "type": "commit"}, {"oid": "f535af0e18b322082e83e33dc31a44e13719ef83", "url": "https://github.com/apache/iceberg/commit/f535af0e18b322082e83e33dc31a44e13719ef83", "message": "Add HiveRunner tests", "committedDate": "2020-07-16T22:02:31Z", "type": "commit"}, {"oid": "f535af0e18b322082e83e33dc31a44e13719ef83", "url": "https://github.com/apache/iceberg/commit/f535af0e18b322082e83e33dc31a44e13719ef83", "message": "Add HiveRunner tests", "committedDate": "2020-07-16T22:02:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ0MDU3OA==", "url": "https://github.com/apache/iceberg/pull/1192#discussion_r458440578", "bodyText": "This should be Assert.assertEquals(3, descRows.size());", "author": "HotSushi", "createdAt": "2020-07-21T23:10:19Z", "path": "mr/src/test/java/org/apache/iceberg/mr/hive/TestHiveIcebergInputFormat.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iceberg.mr.hive;\n+\n+import com.klarna.hiverunner.HiveShell;\n+import com.klarna.hiverunner.StandaloneHiveRunner;\n+import com.klarna.hiverunner.annotations.HiveSQL;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.iceberg.FileFormat;\n+import org.apache.iceberg.PartitionSpec;\n+import org.apache.iceberg.Schema;\n+import org.apache.iceberg.Table;\n+import org.apache.iceberg.data.Record;\n+import org.apache.iceberg.hadoop.HadoopTables;\n+import org.apache.iceberg.mr.TestHelper;\n+import org.apache.iceberg.mr.mapred.IcebergSerDe;\n+import org.apache.iceberg.types.Types;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.junit.runner.RunWith;\n+\n+import static org.apache.iceberg.types.Types.NestedField.required;\n+\n+@RunWith(StandaloneHiveRunner.class)\n+public class TestHiveIcebergInputFormat {\n+\n+  @HiveSQL(files = {}, autoStart = true)\n+  private HiveShell shell;\n+\n+  @Rule\n+  public TemporaryFolder temp = new TemporaryFolder();\n+\n+  private static final Schema CUSTOMER_SCHEMA = new Schema(\n+          required(1, \"customer_id\", Types.LongType.get()),\n+          required(2, \"first_name\", Types.StringType.get())\n+  );\n+\n+  private static final List<Record> CUSTOMER_RECORDS = TestHelper.RecordsBuilder.newInstance(CUSTOMER_SCHEMA)\n+          .add(0L, \"Alice\")\n+          .add(1L, \"Bob\")\n+          .add(2L, \"Trudy\")\n+          .build();\n+\n+  private static final Schema ORDER_SCHEMA = new Schema(\n+          required(1, \"order_id\", Types.LongType.get()),\n+          required(2, \"customer_id\", Types.LongType.get()),\n+          required(3, \"total\", Types.DoubleType.get()));\n+\n+  private static final List<Record> ORDER_RECORDS = TestHelper.RecordsBuilder.newInstance(ORDER_SCHEMA)\n+          .add(100L, 0L, 11.11d)\n+          .add(101L, 0L, 22.22d)\n+          .add(102L, 1L, 33.33d)\n+          .build();\n+\n+  // before variables\n+  private HadoopTables tables;\n+  private Table customerTable;\n+  private Table orderTable;\n+\n+  @Before\n+  public void before() throws IOException {\n+    Configuration conf = new Configuration();\n+    tables = new HadoopTables(conf);\n+\n+    File customerLocation = temp.newFolder(\"customers\");\n+    Assert.assertTrue(customerLocation.delete());\n+\n+    TestHelper customerHelper = new TestHelper(\n+            conf, tables, CUSTOMER_SCHEMA, PartitionSpec.unpartitioned(), FileFormat.PARQUET, temp, customerLocation);\n+\n+    customerTable = customerHelper.createUnpartitionedTable();\n+    customerHelper.appendToTable(customerHelper.writeFile(null, CUSTOMER_RECORDS));\n+\n+    File orderLocation = temp.newFolder(\"orders\");\n+    Assert.assertTrue(orderLocation.delete());\n+\n+    TestHelper orderHelper = new TestHelper(\n+            conf, tables, ORDER_SCHEMA, PartitionSpec.unpartitioned(), FileFormat.PARQUET, temp, orderLocation);\n+\n+    orderTable = orderHelper.createUnpartitionedTable();\n+    orderHelper.appendToTable(orderHelper.writeFile(null, ORDER_RECORDS));\n+  }\n+\n+  @Test\n+  public void testScanEmptyTable() throws IOException {\n+    File emptyLocation = temp.newFolder(\"empty\");\n+    Assert.assertTrue(emptyLocation.delete());\n+\n+    Schema emptySchema = new Schema(required(1, \"empty\", Types.StringType.get()));\n+    Table emptyTable = tables.create(\n+            emptySchema, PartitionSpec.unpartitioned(), Collections.emptyMap(), emptyLocation.toString());\n+    createHiveTable(\"empty\", emptyTable.location());\n+\n+    List<Object[]> rows = shell.executeStatement(\"SELECT * FROM default.empty\");\n+    Assert.assertEquals(0, rows.size());\n+  }\n+\n+  @Test\n+  public void testScanTable() {\n+    createHiveTable(\"customers\", customerTable.location());\n+\n+    // Single fetch task: no MR job.\n+    List<Object[]> rows = shell.executeStatement(\"SELECT * FROM default.customers\");\n+\n+    Assert.assertEquals(3, rows.size());\n+    Assert.assertArrayEquals(new Object[] {0L, \"Alice\"}, rows.get(0));\n+    Assert.assertArrayEquals(new Object[] {1L, \"Bob\"}, rows.get(1));\n+    Assert.assertArrayEquals(new Object[] {2L, \"Trudy\"}, rows.get(2));\n+\n+    // Adding the ORDER BY clause will cause Hive to spawn a local MR job this time.\n+    List<Object[]> descRows = shell.executeStatement(\"SELECT * FROM default.customers ORDER BY customer_id DESC\");\n+\n+    Assert.assertEquals(3, rows.size());", "originalCommit": "f535af0e18b322082e83e33dc31a44e13719ef83", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}