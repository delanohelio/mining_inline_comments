{"pr_number": 1344, "pr_title": "Expire snapshots action without cache", "pr_createdAt": "2020-08-14T18:21:33Z", "pr_url": "https://github.com/apache/iceberg/pull/1344", "timeline": [{"oid": "0596f8a7a7ab1faf20b73c89fab0c0247e8a4e60", "url": "https://github.com/apache/iceberg/commit/0596f8a7a7ab1faf20b73c89fab0c0247e8a4e60", "message": "Removes Caching from ExpireSnapshotAction\n\nInstead of using a cache to preserve the state from before the\nexpireSnapshots command, we preserve the table metadata via a\nStaticTable reference. This reference doesn't change when the\nSnapshosts are expired and allows us to look up all the files\nreferenced by the prior version of the table without holding\neverything in memory.", "committedDate": "2020-08-19T19:22:59Z", "type": "commit"}, {"oid": "0596f8a7a7ab1faf20b73c89fab0c0247e8a4e60", "url": "https://github.com/apache/iceberg/commit/0596f8a7a7ab1faf20b73c89fab0c0247e8a4e60", "message": "Removes Caching from ExpireSnapshotAction\n\nInstead of using a cache to preserve the state from before the\nexpireSnapshots command, we preserve the table metadata via a\nStaticTable reference. This reference doesn't change when the\nSnapshosts are expired and allows us to look up all the files\nreferenced by the prior version of the table without holding\neverything in memory.", "committedDate": "2020-08-19T19:22:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI2NzIwNA==", "url": "https://github.com/apache/iceberg/pull/1344#discussion_r473267204", "bodyText": "We add these 2 arg versions so that we can specify metadata Json files directly, the single arg versions just use the current table state as before.", "author": "RussellSpitzer", "createdAt": "2020-08-19T19:25:30Z", "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -86,17 +90,22 @@ protected String metadataTableName(MetadataTableType type) {\n   }\n \n   protected Dataset<Row> buildValidDataFileDF(SparkSession spark) {\n-    String allDataFilesMetadataTable = metadataTableName(MetadataTableType.ALL_DATA_FILES);\n+    return buildValidDataFileDF(spark, table().toString());\n+  }\n+\n+  protected Dataset<Row> buildValidDataFileDF(SparkSession spark, String tableName) {\n+    String allDataFilesMetadataTable = metadataTableName(tableName, MetadataTableType.ALL_DATA_FILES);\n     return spark.read().format(\"iceberg\").load(allDataFilesMetadataTable).select(\"file_path\");\n   }\n \n-  protected Dataset<Row> buildManifestFileDF(SparkSession spark) {\n-    String allManifestsMetadataTable = metadataTableName(MetadataTableType.ALL_MANIFESTS);\n+  protected Dataset<Row> buildManifestFileDF(SparkSession spark, String tableName) {", "originalCommit": "0596f8a7a7ab1faf20b73c89fab0c0247e8a4e60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1MTczNw==", "url": "https://github.com/apache/iceberg/pull/1344#discussion_r473351737", "bodyText": "I think it is misleading to use snapshot here, since that term usually refers to a version of a table, not a table itself.", "author": "rdblue", "createdAt": "2020-08-19T21:43:13Z", "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -86,17 +90,22 @@ protected String metadataTableName(MetadataTableType type) {\n   }\n \n   protected Dataset<Row> buildValidDataFileDF(SparkSession spark) {\n-    String allDataFilesMetadataTable = metadataTableName(MetadataTableType.ALL_DATA_FILES);\n+    return buildValidDataFileDF(spark, table().toString());\n+  }\n+\n+  protected Dataset<Row> buildValidDataFileDF(SparkSession spark, String tableName) {\n+    String allDataFilesMetadataTable = metadataTableName(tableName, MetadataTableType.ALL_DATA_FILES);\n     return spark.read().format(\"iceberg\").load(allDataFilesMetadataTable).select(\"file_path\");\n   }\n \n-  protected Dataset<Row> buildManifestFileDF(SparkSession spark) {\n-    String allManifestsMetadataTable = metadataTableName(MetadataTableType.ALL_MANIFESTS);\n+  protected Dataset<Row> buildManifestFileDF(SparkSession spark, String tableName) {\n+    String allManifestsMetadataTable = metadataTableName(tableName, MetadataTableType.ALL_MANIFESTS);\n     return spark.read().format(\"iceberg\").load(allManifestsMetadataTable).selectExpr(\"path as file_path\");\n   }\n \n-  protected Dataset<Row> buildManifestListDF(SparkSession spark, Table table) {\n-    List<String> manifestLists = getManifestListPaths(table);\n+  protected Dataset<Row> buildManifestListDF(SparkSession spark, String tableName, TableOperations ops) {\n+    Table snapshot = new BaseTable(ops, tableName);", "originalCommit": "0596f8a7a7ab1faf20b73c89fab0c0247e8a4e60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2MDg5OQ==", "url": "https://github.com/apache/iceberg/pull/1344#discussion_r473360899", "bodyText": "True, I'll just switch it to table\nTable table = Table", "author": "RussellSpitzer", "createdAt": "2020-08-19T21:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1MTczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1NTIxMQ==", "url": "https://github.com/apache/iceberg/pull/1344#discussion_r473355211", "bodyText": "Minor: the metadata file location is passed to buildManifestFileDF and buildValidDataFileDF, but StaticTableOperations is passed into buildManifestListDF. I think it would make a more consistent API if the location were also passed to buildManifestListDF.\nI know that the difference is that the method accepts a Table and doesn't use a metadata table. But it would be a bit cleaner to pass the base Table and metadata location, then create the StaticTableOperations in that method rather than here.", "author": "rdblue", "createdAt": "2020-08-19T21:47:13Z", "path": "spark/src/main/java/org/apache/iceberg/actions/ExpireSnapshotsAction.java", "diffHunk": "@@ -147,49 +149,41 @@ public ExpireSnapshotsAction deleteWith(Consumer<String> newDeleteFunc) {\n \n   @Override\n   public ExpireSnapshotsActionResult execute() {\n-    Dataset<Row> originalFiles = null;\n-    try {\n-      // Metadata before Expiration\n-      originalFiles = buildValidFileDF().persist();\n-      // Action to trigger persist\n-      originalFiles.count();\n-\n-      // Perform Expiration\n-      ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n-      for (final Long id : expireSnapshotIdValues) {\n-        expireSnaps = expireSnaps.expireSnapshotId(id);\n-      }\n-\n-      if (expireOlderThanValue != null) {\n-        expireSnaps = expireSnaps.expireOlderThan(expireOlderThanValue);\n-      }\n-\n-      if (retainLastValue != null) {\n-        expireSnaps = expireSnaps.retainLast(retainLastValue);\n-      }\n-\n-      expireSnaps.commit();\n-\n-      // Metadata after Expiration\n-      Dataset<Row> validFiles = buildValidFileDF();\n-      Dataset<Row> filesToDelete = originalFiles.except(validFiles);\n-\n-      return deleteFiles(filesToDelete.toLocalIterator());\n-    } finally {\n-      if (originalFiles != null) {\n-        originalFiles.unpersist();\n-      }\n+    // Metadata before Expiration\n+    Dataset<Row>  originalFiles = buildValidFileDF(ops.current());\n+\n+    // Perform Expiration\n+    ExpireSnapshots expireSnaps = table.expireSnapshots().cleanExpiredFiles(false);\n+    for (final Long id : expireSnapshotIdValues) {\n+      expireSnaps = expireSnaps.expireSnapshotId(id);\n+    }\n+\n+    if (expireOlderThanValue != null) {\n+      expireSnaps = expireSnaps.expireOlderThan(expireOlderThanValue);\n+    }\n+\n+    if (retainLastValue != null) {\n+      expireSnaps = expireSnaps.retainLast(retainLastValue);\n     }\n+\n+    expireSnaps.commit();\n+\n+    // Metadata after Expiration\n+    Dataset<Row> validFiles = buildValidFileDF(ops.refresh());\n+    Dataset<Row> filesToDelete = originalFiles.except(validFiles);\n+\n+    return deleteFiles(filesToDelete.toLocalIterator());\n   }\n \n   private Dataset<Row> appendTypeString(Dataset<Row> ds, String type) {\n     return ds.select(new Column(\"file_path\"), functions.lit(type).as(\"file_type\"));\n   }\n \n-  private Dataset<Row> buildValidFileDF() {\n-    return appendTypeString(buildValidDataFileDF(spark), DATA_FILE)\n-        .union(appendTypeString(buildManifestFileDF(spark), MANIFEST))\n-        .union(appendTypeString(buildManifestListDF(spark, table), MANIFEST_LIST));\n+  private Dataset<Row> buildValidFileDF(TableMetadata metadata) {\n+    StaticTableOperations staticOps = new StaticTableOperations(metadata.metadataFileLocation(), table.io());", "originalCommit": "0596f8a7a7ab1faf20b73c89fab0c0247e8a4e60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU2NzAyNQ==", "url": "https://github.com/apache/iceberg/pull/1344#discussion_r473567025", "bodyText": "I think I understand what you are asking for here, but I'm not sure I like how it looks since I end up with two methods, one of which takes metadataFileLocation and one which takes \"Table\"\nThe metadataFileLocation version makes the StaticOps and BaseTable from them and passes to the table method,\nwhile the \"table\" method is used for the version used by Orphan files.\nTake a look  at the new version and see if we are on the same page", "author": "RussellSpitzer", "createdAt": "2020-08-20T03:32:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1NTIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1Njc1Nw==", "url": "https://github.com/apache/iceberg/pull/1344#discussion_r473356757", "bodyText": "What about changing getManifestListPaths to accept Iterable<Snapshot>? Then you wouldn't need to create a BaseTable out of a StaticTableOperations. Instead you could just pass staticOps.current().snapshots() here and table.snapshots() elsewhere.", "author": "rdblue", "createdAt": "2020-08-19T21:49:03Z", "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -86,17 +90,22 @@ protected String metadataTableName(MetadataTableType type) {\n   }\n \n   protected Dataset<Row> buildValidDataFileDF(SparkSession spark) {\n-    String allDataFilesMetadataTable = metadataTableName(MetadataTableType.ALL_DATA_FILES);\n+    return buildValidDataFileDF(spark, table().toString());\n+  }\n+\n+  protected Dataset<Row> buildValidDataFileDF(SparkSession spark, String tableName) {\n+    String allDataFilesMetadataTable = metadataTableName(tableName, MetadataTableType.ALL_DATA_FILES);\n     return spark.read().format(\"iceberg\").load(allDataFilesMetadataTable).select(\"file_path\");\n   }\n \n-  protected Dataset<Row> buildManifestFileDF(SparkSession spark) {\n-    String allManifestsMetadataTable = metadataTableName(MetadataTableType.ALL_MANIFESTS);\n+  protected Dataset<Row> buildManifestFileDF(SparkSession spark, String tableName) {\n+    String allManifestsMetadataTable = metadataTableName(tableName, MetadataTableType.ALL_MANIFESTS);\n     return spark.read().format(\"iceberg\").load(allManifestsMetadataTable).selectExpr(\"path as file_path\");\n   }\n \n-  protected Dataset<Row> buildManifestListDF(SparkSession spark, Table table) {\n-    List<String> manifestLists = getManifestListPaths(table);\n+  protected Dataset<Row> buildManifestListDF(SparkSession spark, String tableName, TableOperations ops) {\n+    Table snapshot = new BaseTable(ops, tableName);\n+    List<String> manifestLists = getManifestListPaths(snapshot);", "originalCommit": "0596f8a7a7ab1faf20b73c89fab0c0247e8a4e60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM2MDYyMg==", "url": "https://github.com/apache/iceberg/pull/1344#discussion_r473360622", "bodyText": "Sounds good to me", "author": "RussellSpitzer", "createdAt": "2020-08-19T21:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzM1Njc1Nw=="}], "type": "inlineReview"}, {"oid": "4919639492284a2c5ac315501032aa96d67ad00b", "url": "https://github.com/apache/iceberg/commit/4919639492284a2c5ac315501032aa96d67ad00b", "message": "Reviewer Comments\n\nRefactor parameters of getManifestLists, no longer requires Ops", "committedDate": "2020-08-20T03:02:47Z", "type": "commit"}, {"oid": "2f76828614fab5a8d8230655aa97eb7bd99f0e2e", "url": "https://github.com/apache/iceberg/commit/2f76828614fab5a8d8230655aa97eb7bd99f0e2e", "message": "Further Review Comments\n\nRefactor of buildManifestListsDF so that it matches the signatures of the other\nExpireSnapshot methods.", "committedDate": "2020-08-20T03:30:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU2NzI2NA==", "url": "https://github.com/apache/iceberg/pull/1344#discussion_r473567264", "bodyText": "You cannot pass a pure table name here since we aren't looking up the table using Spark, this path is for metadataFileLocation based tables only.", "author": "RussellSpitzer", "createdAt": "2020-08-20T03:33:28Z", "path": "spark/src/main/java/org/apache/iceberg/actions/BaseAction.java", "diffHunk": "@@ -86,27 +91,36 @@ protected String metadataTableName(MetadataTableType type) {\n   }\n \n   protected Dataset<Row> buildValidDataFileDF(SparkSession spark) {\n-    String allDataFilesMetadataTable = metadataTableName(MetadataTableType.ALL_DATA_FILES);\n+    return buildValidDataFileDF(spark, table().toString());\n+  }\n+\n+  protected Dataset<Row> buildValidDataFileDF(SparkSession spark, String tableName) {\n+    String allDataFilesMetadataTable = metadataTableName(tableName, MetadataTableType.ALL_DATA_FILES);\n     return spark.read().format(\"iceberg\").load(allDataFilesMetadataTable).select(\"file_path\");\n   }\n \n-  protected Dataset<Row> buildManifestFileDF(SparkSession spark) {\n-    String allManifestsMetadataTable = metadataTableName(MetadataTableType.ALL_MANIFESTS);\n+  protected Dataset<Row> buildManifestFileDF(SparkSession spark, String tableName) {\n+    String allManifestsMetadataTable = metadataTableName(tableName, MetadataTableType.ALL_MANIFESTS);\n     return spark.read().format(\"iceberg\").load(allManifestsMetadataTable).selectExpr(\"path as file_path\");\n   }\n \n   protected Dataset<Row> buildManifestListDF(SparkSession spark, Table table) {\n-    List<String> manifestLists = getManifestListPaths(table);\n+    List<String> manifestLists = getManifestListPaths(table.snapshots());\n     return spark.createDataset(manifestLists, Encoders.STRING()).toDF(\"file_path\");\n   }\n \n+  protected Dataset<Row> buildManifestListDF(SparkSession spark, String metadataFileLocation) {", "originalCommit": "2f76828614fab5a8d8230655aa97eb7bd99f0e2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}