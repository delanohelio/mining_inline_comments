{"pr_number": 1030, "pr_title": "issue #945 Add SPs support to PostgreSql and enable paremeterNameId and codesystemId caches", "pr_createdAt": "2020-05-06T02:18:30Z", "pr_url": "https://github.com/IBM/FHIR/pull/1030", "timeline": [{"oid": "335bdaf1e850695a9f4e48ede068365af57fa093", "url": "https://github.com/IBM/FHIR/commit/335bdaf1e850695a9f4e48ede068365af57fa093", "message": "Merge pull request #1017 from IBM/issue-945\n\nIssue 945", "committedDate": "2020-05-04T14:18:40Z", "type": "commit"}, {"oid": "27dc620d90c6831fe50ad359b89404a558fa84f9", "url": "https://github.com/IBM/FHIR/commit/27dc620d90c6831fe50ad359b89404a558fa84f9", "message": "Merge branch 'albert-master' into issue-945", "committedDate": "2020-05-06T00:26:10Z", "type": "commit"}, {"oid": "d14972b64e0253241270f3bd58dc1be318dd31bc", "url": "https://github.com/IBM/FHIR/commit/d14972b64e0253241270f3bd58dc1be318dd31bc", "message": "Merge pull request #1028 from IBM/issue-945\n\nIssue 945", "committedDate": "2020-05-06T00:26:22Z", "type": "commit"}, {"oid": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "url": "https://github.com/IBM/FHIR/commit/b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "message": "issue #945 SP support for postgresql inital code drop\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-05-06T02:17:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxNjgxMQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420716811", "bodyText": "I do not think this should be in place of createOrReplaceProcedure.  There should be a new method for createOrReplaceFunction. Functions are a common db mechanism, I think this should remain as 153, and a new element for createOrReplaceFunction should be added.", "author": "prb112", "createdAt": "2020-05-06T11:23:50Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -150,7 +150,22 @@ public void dropType(String schemaName, String typeName) {\n \n     @Override\n     public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n-        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+        final String objectName = DataDefinitionUtil.getQualifiedName(schemaName, procedureName);\n+        logger.info(\"Create or replace procedure \" + objectName);\n+\n+        // Build the create procedure DDL and apply it\n+        final StringBuilder ddl = new StringBuilder();\n+        ddl.append(\"CREATE OR REPLACE FUNCTION \");", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMTQwMA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421211400", "bodyText": "I would prefer to keep it simpler as it's now.\nI chose to use postgresql function(or fake stored procedure) instead of procedure simply because postgresql doesn't have out parameter support at present, when postgresql support out parameter, then we can just change it to a real stored procedure.", "author": "albertwang-ibm", "createdAt": "2020-05-07T03:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxNjgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxNzEwOA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420717108", "bodyText": "what does the line separator get you, a pretty print?", "author": "prb112", "createdAt": "2020-05-06T11:24:25Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -150,7 +150,22 @@ public void dropType(String schemaName, String typeName) {\n \n     @Override\n     public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {\n-        warnOnce(MessageKey.CREATE_PROC, \"Create procedure not supported in PostgreSql\");\n+        final String objectName = DataDefinitionUtil.getQualifiedName(schemaName, procedureName);\n+        logger.info(\"Create or replace procedure \" + objectName);\n+\n+        // Build the create procedure DDL and apply it\n+        final StringBuilder ddl = new StringBuilder();\n+        ddl.append(\"CREATE OR REPLACE FUNCTION \");\n+        ddl.append(objectName);\n+        ddl.append(System.lineSeparator());\n+        ddl.append(supplier.get());", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMTcxOA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421211718", "bodyText": "this is interesting, just followed the existing pattern, let me change this.", "author": "albertwang-ibm", "createdAt": "2020-05-07T03:04:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxNzEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxODcyNQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420718725", "bodyText": "merge 73, 74 to oneline", "author": "prb112", "createdAt": "2020-05-06T11:27:57Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlCodeSystemDAO.java", "diffHunk": "@@ -21,84 +23,95 @@\n  *\n  */\n public class PostgreSqlCodeSystemDAO extends CodeSystemDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlCodeSystemDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlCodeSystemDAO.class.getName();\n+    private static final String SQL_CALL_ADD_CODE_SYSTEM_ID = \"{CALL %s.add_code_system(?, ?)}\";\n \n     /**\n      * Public constructor\n      * @param c\n      * @param fsd\n      */\n-    public PostgreSqlCodeSystemDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlCodeSystemDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the system contained in the passed Parameter in the Code_Systems table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param systemName\n+     *\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n-    public int readOrAddCodeSystem(String codeSystem) throws FHIRPersistenceDataAccessException   {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getCodeSystemId(codeSystem);\n-\n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n-\n-                String INS = \"INSERT INTO code_systems (code_system_id, code_system_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, codeSystem);\n-                    stmt.executeUpdate();\n+    public int readOrAddCodeSystem(String systemName) throws FHIRPersistenceDataAccessException   {\n+        final String METHODNAME = \"readOrAddCodeSystem\";\n+        log.entering(CLASSNAME, METHODNAME);\n+\n+        int systemId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing code system id: name=\" + systemName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_CODE_SYSTEM_ID, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, systemName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read code system id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n+                systemId = stmt.getInt(2);\n             }\n-            catch (SQLException e) {\n-                if (\"23505\".equals(e.getSQLState())) {\n-                    // another thread snuck in and created the record, so we need to fetch the correct id\n-                    result = getCodeSystemId(codeSystem);\n-\n-                    if (result == null) {\n-                        // This would be truly weird, but we protect against it anyway\n-                        throw new IllegalStateException(\"No code system returned after duplicate found!\");\n-                    }\n-                }\n-                else {\n-                    throw new FHIRPersistenceDataAccessException(\"codeSystem=\" + codeSystem, e);\n-                }\n-            }\n-\n         }\n-\n-        // There's no way result can be null here, so we're OK returning an int\n-        return result;\n+        catch (Throwable e) {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxMjg4MA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421212880", "bodyText": "followed Robin's code style, let me change. :)", "author": "albertwang-ibm", "createdAt": "2020-05-07T03:09:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxODcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxODc4OQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420718789", "bodyText": "merge to one line", "author": "prb112", "createdAt": "2020-05-06T11:28:06Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlCodeSystemDAO.java", "diffHunk": "@@ -21,84 +23,95 @@\n  *\n  */\n public class PostgreSqlCodeSystemDAO extends CodeSystemDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlCodeSystemDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlCodeSystemDAO.class.getName();\n+    private static final String SQL_CALL_ADD_CODE_SYSTEM_ID = \"{CALL %s.add_code_system(?, ?)}\";\n \n     /**\n      * Public constructor\n      * @param c\n      * @param fsd\n      */\n-    public PostgreSqlCodeSystemDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlCodeSystemDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the system contained in the passed Parameter in the Code_Systems table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param systemName\n+     *\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n-    public int readOrAddCodeSystem(String codeSystem) throws FHIRPersistenceDataAccessException   {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getCodeSystemId(codeSystem);\n-\n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n-\n-                String INS = \"INSERT INTO code_systems (code_system_id, code_system_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, codeSystem);\n-                    stmt.executeUpdate();\n+    public int readOrAddCodeSystem(String systemName) throws FHIRPersistenceDataAccessException   {\n+        final String METHODNAME = \"readOrAddCodeSystem\";\n+        log.entering(CLASSNAME, METHODNAME);\n+\n+        int systemId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing code system id: name=\" + systemName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_CODE_SYSTEM_ID, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, systemName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read code system id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n+                systemId = stmt.getInt(2);\n             }\n-            catch (SQLException e) {\n-                if (\"23505\".equals(e.getSQLState())) {\n-                    // another thread snuck in and created the record, so we need to fetch the correct id\n-                    result = getCodeSystemId(codeSystem);\n-\n-                    if (result == null) {\n-                        // This would be truly weird, but we protect against it anyway\n-                        throw new IllegalStateException(\"No code system returned after duplicate found!\");\n-                    }\n-                }\n-                else {\n-                    throw new FHIRPersistenceDataAccessException(\"codeSystem=\" + codeSystem, e);\n-                }\n-            }\n-\n         }\n-\n-        // There's no way result can be null here, so we're OK returning an int\n-        return result;\n+        catch (Throwable e) {\n+            throw new FHIRPersistenceDataAccessException(errMsg,e);\n+        }\n+        finally {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxODk0NQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420718945", "bodyText": "merge to oneline", "author": "prb112", "createdAt": "2020-05-06T11:28:22Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlCodeSystemDAO.java", "diffHunk": "@@ -21,84 +23,95 @@\n  *\n  */\n public class PostgreSqlCodeSystemDAO extends CodeSystemDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlCodeSystemDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlCodeSystemDAO.class.getName();\n+    private static final String SQL_CALL_ADD_CODE_SYSTEM_ID = \"{CALL %s.add_code_system(?, ?)}\";\n \n     /**\n      * Public constructor\n      * @param c\n      * @param fsd\n      */\n-    public PostgreSqlCodeSystemDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlCodeSystemDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the system contained in the passed Parameter in the Code_Systems table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param systemName\n+     *\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n-    public int readOrAddCodeSystem(String codeSystem) throws FHIRPersistenceDataAccessException   {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getCodeSystemId(codeSystem);\n-\n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n-\n-                String INS = \"INSERT INTO code_systems (code_system_id, code_system_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, codeSystem);\n-                    stmt.executeUpdate();\n+    public int readOrAddCodeSystem(String systemName) throws FHIRPersistenceDataAccessException   {\n+        final String METHODNAME = \"readOrAddCodeSystem\";\n+        log.entering(CLASSNAME, METHODNAME);\n+\n+        int systemId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing code system id: name=\" + systemName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_CODE_SYSTEM_ID, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, systemName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read code system id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n+                systemId = stmt.getInt(2);\n             }\n-            catch (SQLException e) {\n-                if (\"23505\".equals(e.getSQLState())) {\n-                    // another thread snuck in and created the record, so we need to fetch the correct id\n-                    result = getCodeSystemId(codeSystem);\n-\n-                    if (result == null) {\n-                        // This would be truly weird, but we protect against it anyway\n-                        throw new IllegalStateException(\"No code system returned after duplicate found!\");\n-                    }\n-                }\n-                else {\n-                    throw new FHIRPersistenceDataAccessException(\"codeSystem=\" + codeSystem, e);\n-                }\n-            }\n-\n         }\n-\n-        // There's no way result can be null here, so we're OK returning an int\n-        return result;\n+        catch (Throwable e) {\n+            throw new FHIRPersistenceDataAccessException(errMsg,e);\n+        }\n+        finally {\n+            this.cleanup(null, getConnection());\n+            log.exiting(CLASSNAME, METHODNAME);\n+        }\n+        return systemId;\n     }\n \n     /**\n-     * Read the id for the named type\n-     * @param codeSystem\n-     * @return the database id, or null if the named record is not found\n-     * @throws FHIRPersistenceDataAccessException\n+     * Closes the passed PreparedStatement and Connection objects.\n+     * @param stmt\n+     * @param connection\n      */\n-    protected Integer getCodeSystemId(String codeSystem) throws FHIRPersistenceDataAccessException {\n-        Integer result;\n+    protected void cleanup(PreparedStatement stmt, Connection connection)  {\n+        final String METHODNAME = \"cleanup(PreparedStatement, Connection)\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        String sql1 = \"SELECT code_system_id FROM code_systems WHERE code_system_name = ?\";\n+        FHIRPersistenceDBCleanupException ce;\n \n-        try (PreparedStatement stmt = getConnection().prepareStatement(sql1)) {\n-            stmt.setString(1, codeSystem);\n-            ResultSet rs = stmt.executeQuery();\n-            if (rs.next()) {\n-                result = rs.getInt(1);\n+        if (stmt != null) {\n+            try {\n+                stmt.close();\n             }\n-            else {\n-                result = null;\n+            catch (Throwable e) {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxOTAxNQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420719015", "bodyText": "merge to oneline", "author": "prb112", "createdAt": "2020-05-06T11:28:31Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlCodeSystemDAO.java", "diffHunk": "@@ -21,84 +23,95 @@\n  *\n  */\n public class PostgreSqlCodeSystemDAO extends CodeSystemDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlCodeSystemDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlCodeSystemDAO.class.getName();\n+    private static final String SQL_CALL_ADD_CODE_SYSTEM_ID = \"{CALL %s.add_code_system(?, ?)}\";\n \n     /**\n      * Public constructor\n      * @param c\n      * @param fsd\n      */\n-    public PostgreSqlCodeSystemDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlCodeSystemDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the system contained in the passed Parameter in the Code_Systems table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param systemName\n+     *\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n-    public int readOrAddCodeSystem(String codeSystem) throws FHIRPersistenceDataAccessException   {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getCodeSystemId(codeSystem);\n-\n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n-\n-                String INS = \"INSERT INTO code_systems (code_system_id, code_system_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, codeSystem);\n-                    stmt.executeUpdate();\n+    public int readOrAddCodeSystem(String systemName) throws FHIRPersistenceDataAccessException   {\n+        final String METHODNAME = \"readOrAddCodeSystem\";\n+        log.entering(CLASSNAME, METHODNAME);\n+\n+        int systemId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing code system id: name=\" + systemName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_CODE_SYSTEM_ID, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, systemName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read code system id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n+                systemId = stmt.getInt(2);\n             }\n-            catch (SQLException e) {\n-                if (\"23505\".equals(e.getSQLState())) {\n-                    // another thread snuck in and created the record, so we need to fetch the correct id\n-                    result = getCodeSystemId(codeSystem);\n-\n-                    if (result == null) {\n-                        // This would be truly weird, but we protect against it anyway\n-                        throw new IllegalStateException(\"No code system returned after duplicate found!\");\n-                    }\n-                }\n-                else {\n-                    throw new FHIRPersistenceDataAccessException(\"codeSystem=\" + codeSystem, e);\n-                }\n-            }\n-\n         }\n-\n-        // There's no way result can be null here, so we're OK returning an int\n-        return result;\n+        catch (Throwable e) {\n+            throw new FHIRPersistenceDataAccessException(errMsg,e);\n+        }\n+        finally {\n+            this.cleanup(null, getConnection());\n+            log.exiting(CLASSNAME, METHODNAME);\n+        }\n+        return systemId;\n     }\n \n     /**\n-     * Read the id for the named type\n-     * @param codeSystem\n-     * @return the database id, or null if the named record is not found\n-     * @throws FHIRPersistenceDataAccessException\n+     * Closes the passed PreparedStatement and Connection objects.\n+     * @param stmt\n+     * @param connection\n      */\n-    protected Integer getCodeSystemId(String codeSystem) throws FHIRPersistenceDataAccessException {\n-        Integer result;\n+    protected void cleanup(PreparedStatement stmt, Connection connection)  {\n+        final String METHODNAME = \"cleanup(PreparedStatement, Connection)\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        String sql1 = \"SELECT code_system_id FROM code_systems WHERE code_system_name = ?\";\n+        FHIRPersistenceDBCleanupException ce;\n \n-        try (PreparedStatement stmt = getConnection().prepareStatement(sql1)) {\n-            stmt.setString(1, codeSystem);\n-            ResultSet rs = stmt.executeQuery();\n-            if (rs.next()) {\n-                result = rs.getInt(1);\n+        if (stmt != null) {\n+            try {\n+                stmt.close();\n             }\n-            else {\n-                result = null;\n+            catch (Throwable e) {\n+                ce =  new FHIRPersistenceDBCleanupException(\"Failure closing PreparedStatement.\",e);\n+                log.log(Level.SEVERE, ce.getMessage(), ce);\n             }\n         }\n-        catch (SQLException e) {\n-            throw new FHIRPersistenceDataAccessException(\"codeSystem=\" + codeSystem, e);\n+        if(connection != null && this.getConnection() == null) {\n+            try {\n+                connection.close();\n+            }\n+            catch (Throwable e) {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxOTU2NQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420719565", "bodyText": "Why are you forceabling closing this? It's part of a pool?", "author": "prb112", "createdAt": "2020-05-06T11:29:33Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlCodeSystemDAO.java", "diffHunk": "@@ -21,84 +23,95 @@\n  *\n  */\n public class PostgreSqlCodeSystemDAO extends CodeSystemDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlCodeSystemDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlCodeSystemDAO.class.getName();\n+    private static final String SQL_CALL_ADD_CODE_SYSTEM_ID = \"{CALL %s.add_code_system(?, ?)}\";\n \n     /**\n      * Public constructor\n      * @param c\n      * @param fsd\n      */\n-    public PostgreSqlCodeSystemDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlCodeSystemDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the system contained in the passed Parameter in the Code_Systems table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param systemName\n+     *\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n-    public int readOrAddCodeSystem(String codeSystem) throws FHIRPersistenceDataAccessException   {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getCodeSystemId(codeSystem);\n-\n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n-\n-                String INS = \"INSERT INTO code_systems (code_system_id, code_system_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, codeSystem);\n-                    stmt.executeUpdate();\n+    public int readOrAddCodeSystem(String systemName) throws FHIRPersistenceDataAccessException   {\n+        final String METHODNAME = \"readOrAddCodeSystem\";\n+        log.entering(CLASSNAME, METHODNAME);\n+\n+        int systemId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing code system id: name=\" + systemName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_CODE_SYSTEM_ID, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, systemName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read code system id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n+                systemId = stmt.getInt(2);\n             }\n-            catch (SQLException e) {\n-                if (\"23505\".equals(e.getSQLState())) {\n-                    // another thread snuck in and created the record, so we need to fetch the correct id\n-                    result = getCodeSystemId(codeSystem);\n-\n-                    if (result == null) {\n-                        // This would be truly weird, but we protect against it anyway\n-                        throw new IllegalStateException(\"No code system returned after duplicate found!\");\n-                    }\n-                }\n-                else {\n-                    throw new FHIRPersistenceDataAccessException(\"codeSystem=\" + codeSystem, e);\n-                }\n-            }\n-\n         }\n-\n-        // There's no way result can be null here, so we're OK returning an int\n-        return result;\n+        catch (Throwable e) {\n+            throw new FHIRPersistenceDataAccessException(errMsg,e);\n+        }\n+        finally {\n+            this.cleanup(null, getConnection());\n+            log.exiting(CLASSNAME, METHODNAME);\n+        }\n+        return systemId;\n     }\n \n     /**\n-     * Read the id for the named type\n-     * @param codeSystem\n-     * @return the database id, or null if the named record is not found\n-     * @throws FHIRPersistenceDataAccessException\n+     * Closes the passed PreparedStatement and Connection objects.\n+     * @param stmt\n+     * @param connection\n      */\n-    protected Integer getCodeSystemId(String codeSystem) throws FHIRPersistenceDataAccessException {\n-        Integer result;\n+    protected void cleanup(PreparedStatement stmt, Connection connection)  {\n+        final String METHODNAME = \"cleanup(PreparedStatement, Connection)\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        String sql1 = \"SELECT code_system_id FROM code_systems WHERE code_system_name = ?\";\n+        FHIRPersistenceDBCleanupException ce;\n \n-        try (PreparedStatement stmt = getConnection().prepareStatement(sql1)) {\n-            stmt.setString(1, codeSystem);\n-            ResultSet rs = stmt.executeQuery();\n-            if (rs.next()) {\n-                result = rs.getInt(1);\n+        if (stmt != null) {\n+            try {\n+                stmt.close();\n             }\n-            else {\n-                result = null;\n+            catch (Throwable e) {\n+                ce =  new FHIRPersistenceDBCleanupException(\"Failure closing PreparedStatement.\",e);\n+                log.log(Level.SEVERE, ce.getMessage(), ce);\n             }\n         }\n-        catch (SQLException e) {\n-            throw new FHIRPersistenceDataAccessException(\"codeSystem=\" + codeSystem, e);\n+        if(connection != null && this.getConnection() == null) {\n+            try {\n+                connection.close();", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxNDcwOQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421214709", "bodyText": "this doesn't really close the connection, just return it to the pool. it's the same as what did for DB2.", "author": "albertwang-ibm", "createdAt": "2020-05-07T03:16:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxOTU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxOTY1Mg==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420719652", "bodyText": "this method is confusing to me", "author": "prb112", "createdAt": "2020-05-06T11:29:42Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlCodeSystemDAO.java", "diffHunk": "@@ -21,84 +23,95 @@\n  *\n  */\n public class PostgreSqlCodeSystemDAO extends CodeSystemDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlCodeSystemDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlCodeSystemDAO.class.getName();\n+    private static final String SQL_CALL_ADD_CODE_SYSTEM_ID = \"{CALL %s.add_code_system(?, ?)}\";\n \n     /**\n      * Public constructor\n      * @param c\n      * @param fsd\n      */\n-    public PostgreSqlCodeSystemDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlCodeSystemDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the system contained in the passed Parameter in the Code_Systems table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param systemName\n+     *\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n-    public int readOrAddCodeSystem(String codeSystem) throws FHIRPersistenceDataAccessException   {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getCodeSystemId(codeSystem);\n-\n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n-\n-                String INS = \"INSERT INTO code_systems (code_system_id, code_system_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, codeSystem);\n-                    stmt.executeUpdate();\n+    public int readOrAddCodeSystem(String systemName) throws FHIRPersistenceDataAccessException   {\n+        final String METHODNAME = \"readOrAddCodeSystem\";\n+        log.entering(CLASSNAME, METHODNAME);\n+\n+        int systemId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing code system id: name=\" + systemName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_CODE_SYSTEM_ID, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, systemName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read code system id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n+                systemId = stmt.getInt(2);\n             }\n-            catch (SQLException e) {\n-                if (\"23505\".equals(e.getSQLState())) {\n-                    // another thread snuck in and created the record, so we need to fetch the correct id\n-                    result = getCodeSystemId(codeSystem);\n-\n-                    if (result == null) {\n-                        // This would be truly weird, but we protect against it anyway\n-                        throw new IllegalStateException(\"No code system returned after duplicate found!\");\n-                    }\n-                }\n-                else {\n-                    throw new FHIRPersistenceDataAccessException(\"codeSystem=\" + codeSystem, e);\n-                }\n-            }\n-\n         }\n-\n-        // There's no way result can be null here, so we're OK returning an int\n-        return result;\n+        catch (Throwable e) {\n+            throw new FHIRPersistenceDataAccessException(errMsg,e);\n+        }\n+        finally {\n+            this.cleanup(null, getConnection());\n+            log.exiting(CLASSNAME, METHODNAME);\n+        }\n+        return systemId;\n     }\n \n     /**\n-     * Read the id for the named type\n-     * @param codeSystem\n-     * @return the database id, or null if the named record is not found\n-     * @throws FHIRPersistenceDataAccessException\n+     * Closes the passed PreparedStatement and Connection objects.\n+     * @param stmt\n+     * @param connection\n      */\n-    protected Integer getCodeSystemId(String codeSystem) throws FHIRPersistenceDataAccessException {\n-        Integer result;\n+    protected void cleanup(PreparedStatement stmt, Connection connection)  {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxNzk0MQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421217941", "bodyText": "let me remove it.", "author": "albertwang-ibm", "createdAt": "2020-05-07T03:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcxOTY1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMDU3OA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420720578", "bodyText": "Add a different set and use the contains.\nCall it STORED_PROCEDURE_ENABLED and add to the set.\nThis is very hard to figure out if we constantly add.", "author": "prb112", "createdAt": "2020-05-06T11:31:42Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -638,7 +639,7 @@ protected void createFhirSchemas() {\n      * into the FHIR resource tables\n      */\n     protected void updateProcedures() {\n-        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType)) {\n+        if (!MULTITENANT_FEATURE_ENABLED.contains(dbType) || DbType.POSTGRESQL == dbType) {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxODE2OQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421218169", "bodyText": "good idea!", "author": "albertwang-ibm", "createdAt": "2020-05-07T03:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMDU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMTA3Mg==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420721072", "bodyText": "this is a repeated pattern, I'd suggest adding a single helper method available to all classes.", "author": "prb112", "createdAt": "2020-05-06T11:32:46Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/app/Main.java", "diffHunk": "@@ -651,7 +652,12 @@ protected void updateProcedures() {\n             try (Connection c = createConnection()) {\n                 try {\n                     JdbcTarget target = new JdbcTarget(c);\n-                    Db2Adapter adapter = new Db2Adapter(target);\n+                    IDatabaseAdapter adapter;", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTYxMTkzNw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421611937", "bodyText": "great point! changed to use existing function.", "author": "albertwang-ibm", "createdAt": "2020-05-07T15:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMTA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMTI4NQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420721285", "bodyText": "same line", "author": "prb112", "createdAt": "2020-05-06T11:33:14Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -6,75 +6,101 @@\n \n package com.ibm.fhir.persistence.jdbc.postgresql;\n \n+import java.sql.CallableStatement;\n import java.sql.Connection;\n import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n \n-import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBCleanupException;\n import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n \n public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlParameterNamesDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlParameterNamesDAO.class.getName();\n+    private static final String SQL_CALL_ADD_PARAMETER_NAME = \"{CALL %s.add_parameter_name(?, ?)}\";\n \n-    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlParameterNamesDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the name contained in the passed Parameter in the Parameter_Names table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param parameterName\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n     public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getParameterId(parameterName);\n+        final String METHODNAME = \"readOrAddParameterNameId\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n+        int parameterNameId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing search parameter name id: name=\" + parameterName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n \n-                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, parameterName);\n-                    stmt.executeUpdate();\n+        try {\n+            // TODO: schema should be known by application. Fix to avoid an extra round-trip.\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_PARAMETER_NAME, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, parameterName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read/store parameter name id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n-            } catch (SQLException e) {\n-                throw new FHIRPersistenceDataAccessException(\"Error while getting or inserting parameterName '\" + parameterName + \"'\", e);\n+                parameterNameId = stmt.getInt(2);\n             }\n         }\n-\n-        // cannot be null, so safe to return as an int\n-        return result;\n+        catch (Throwable e) {\n+            throw new FHIRPersistenceDataAccessException(errMsg,e);\n+        }\n+        finally {\n+            this.cleanup(null, getConnection());\n+            log.exiting(CLASSNAME, METHODNAME);\n+        }\n+        return parameterNameId;\n     }\n \n     /**\n-     * Read the id for the named type\n-     * @param parameterName\n-     * @return the database id, or null if the named record is not found\n-     * @throws FHIRPersistenceDataAccessException\n+     * Closes the passed PreparedStatement and Connection objects.\n+     * @param stmt\n+     * @param connection\n      */\n-    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n-        Integer result;\n+    protected void cleanup(PreparedStatement stmt, Connection connection)  {\n+        final String METHODNAME = \"cleanup(PreparedStatement, Connection)\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        String sql = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";\n+        FHIRPersistenceDBCleanupException ce;\n \n-        try (PreparedStatement stmt = getConnection().prepareStatement(sql)) {\n-            stmt.setString(1, parameterName);\n-            ResultSet rs = stmt.executeQuery();\n-            if (rs.next()) {\n-                result = rs.getInt(1);\n-            }  else {\n-                result = null;\n+        if (stmt != null) {\n+            try {\n+                stmt.close();\n+            }\n+            catch (Throwable e) {\n+                ce =  new FHIRPersistenceDBCleanupException(\"Failure closing PreparedStatement.\",e);\n+                log.log(Level.SEVERE, ce.getMessage(), ce);\n             }\n         }\n-        catch (SQLException x) {\n-            throw new FHIRPersistenceDataAccessException(\"parameterName=\" + parameterName, x);\n+        if(connection != null && this.getConnection() == null) {\n+            try {\n+                connection.close();\n+            }\n+            catch (Throwable e) {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMTM0MQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420721341", "bodyText": "same line", "author": "prb112", "createdAt": "2020-05-06T11:33:21Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -6,75 +6,101 @@\n \n package com.ibm.fhir.persistence.jdbc.postgresql;\n \n+import java.sql.CallableStatement;\n import java.sql.Connection;\n import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n \n-import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBCleanupException;\n import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n \n public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlParameterNamesDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlParameterNamesDAO.class.getName();\n+    private static final String SQL_CALL_ADD_PARAMETER_NAME = \"{CALL %s.add_parameter_name(?, ?)}\";\n \n-    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlParameterNamesDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the name contained in the passed Parameter in the Parameter_Names table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param parameterName\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n     public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getParameterId(parameterName);\n+        final String METHODNAME = \"readOrAddParameterNameId\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n+        int parameterNameId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing search parameter name id: name=\" + parameterName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n \n-                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, parameterName);\n-                    stmt.executeUpdate();\n+        try {\n+            // TODO: schema should be known by application. Fix to avoid an extra round-trip.\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_PARAMETER_NAME, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, parameterName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read/store parameter name id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n-            } catch (SQLException e) {\n-                throw new FHIRPersistenceDataAccessException(\"Error while getting or inserting parameterName '\" + parameterName + \"'\", e);\n+                parameterNameId = stmt.getInt(2);\n             }\n         }\n-\n-        // cannot be null, so safe to return as an int\n-        return result;\n+        catch (Throwable e) {\n+            throw new FHIRPersistenceDataAccessException(errMsg,e);\n+        }\n+        finally {\n+            this.cleanup(null, getConnection());\n+            log.exiting(CLASSNAME, METHODNAME);\n+        }\n+        return parameterNameId;\n     }\n \n     /**\n-     * Read the id for the named type\n-     * @param parameterName\n-     * @return the database id, or null if the named record is not found\n-     * @throws FHIRPersistenceDataAccessException\n+     * Closes the passed PreparedStatement and Connection objects.\n+     * @param stmt\n+     * @param connection\n      */\n-    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n-        Integer result;\n+    protected void cleanup(PreparedStatement stmt, Connection connection)  {\n+        final String METHODNAME = \"cleanup(PreparedStatement, Connection)\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        String sql = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";\n+        FHIRPersistenceDBCleanupException ce;\n \n-        try (PreparedStatement stmt = getConnection().prepareStatement(sql)) {\n-            stmt.setString(1, parameterName);\n-            ResultSet rs = stmt.executeQuery();\n-            if (rs.next()) {\n-                result = rs.getInt(1);\n-            }  else {\n-                result = null;\n+        if (stmt != null) {\n+            try {\n+                stmt.close();\n+            }\n+            catch (Throwable e) {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMTg4Nw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420721887", "bodyText": "once again, it's a pool, this is a confusing method, when is it called, why is it called, why is it used.\nThe preparedstatement should be autocloseable.\nIn fact in this case, I think it should be removed all together.", "author": "prb112", "createdAt": "2020-05-06T11:34:28Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -6,75 +6,101 @@\n \n package com.ibm.fhir.persistence.jdbc.postgresql;\n \n+import java.sql.CallableStatement;\n import java.sql.Connection;\n import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n \n-import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBCleanupException;\n import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n \n public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlParameterNamesDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlParameterNamesDAO.class.getName();\n+    private static final String SQL_CALL_ADD_PARAMETER_NAME = \"{CALL %s.add_parameter_name(?, ?)}\";\n \n-    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlParameterNamesDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the name contained in the passed Parameter in the Parameter_Names table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param parameterName\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n     public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getParameterId(parameterName);\n+        final String METHODNAME = \"readOrAddParameterNameId\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n+        int parameterNameId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing search parameter name id: name=\" + parameterName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n \n-                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, parameterName);\n-                    stmt.executeUpdate();\n+        try {\n+            // TODO: schema should be known by application. Fix to avoid an extra round-trip.\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_PARAMETER_NAME, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, parameterName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read/store parameter name id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n-            } catch (SQLException e) {\n-                throw new FHIRPersistenceDataAccessException(\"Error while getting or inserting parameterName '\" + parameterName + \"'\", e);\n+                parameterNameId = stmt.getInt(2);\n             }\n         }\n-\n-        // cannot be null, so safe to return as an int\n-        return result;\n+        catch (Throwable e) {\n+            throw new FHIRPersistenceDataAccessException(errMsg,e);\n+        }\n+        finally {\n+            this.cleanup(null, getConnection());\n+            log.exiting(CLASSNAME, METHODNAME);\n+        }\n+        return parameterNameId;\n     }\n \n     /**\n-     * Read the id for the named type\n-     * @param parameterName\n-     * @return the database id, or null if the named record is not found\n-     * @throws FHIRPersistenceDataAccessException\n+     * Closes the passed PreparedStatement and Connection objects.\n+     * @param stmt\n+     * @param connection\n      */\n-    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n-        Integer result;\n+    protected void cleanup(PreparedStatement stmt, Connection connection)  {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMDc2OA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421220768", "bodyText": "this doesn't really close the connection, just return the connection to the pool. it's the same in db2 codes. but seems no harm to just drop it here.", "author": "albertwang-ibm", "createdAt": "2020-05-07T03:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMTg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMTk1Ng==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420721956", "bodyText": "same line", "author": "prb112", "createdAt": "2020-05-06T11:34:35Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -6,75 +6,101 @@\n \n package com.ibm.fhir.persistence.jdbc.postgresql;\n \n+import java.sql.CallableStatement;\n import java.sql.Connection;\n import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n \n-import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBCleanupException;\n import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n \n public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlParameterNamesDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlParameterNamesDAO.class.getName();\n+    private static final String SQL_CALL_ADD_PARAMETER_NAME = \"{CALL %s.add_parameter_name(?, ?)}\";\n \n-    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlParameterNamesDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the name contained in the passed Parameter in the Parameter_Names table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param parameterName\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n     public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getParameterId(parameterName);\n+        final String METHODNAME = \"readOrAddParameterNameId\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n+        int parameterNameId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing search parameter name id: name=\" + parameterName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n \n-                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, parameterName);\n-                    stmt.executeUpdate();\n+        try {\n+            // TODO: schema should be known by application. Fix to avoid an extra round-trip.\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_PARAMETER_NAME, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, parameterName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read/store parameter name id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n-            } catch (SQLException e) {\n-                throw new FHIRPersistenceDataAccessException(\"Error while getting or inserting parameterName '\" + parameterName + \"'\", e);\n+                parameterNameId = stmt.getInt(2);\n             }\n         }\n-\n-        // cannot be null, so safe to return as an int\n-        return result;\n+        catch (Throwable e) {\n+            throw new FHIRPersistenceDataAccessException(errMsg,e);\n+        }\n+        finally {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMjAzMw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420722033", "bodyText": "same line", "author": "prb112", "createdAt": "2020-05-06T11:34:41Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -6,75 +6,101 @@\n \n package com.ibm.fhir.persistence.jdbc.postgresql;\n \n+import java.sql.CallableStatement;\n import java.sql.Connection;\n import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n \n-import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n+import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDBCleanupException;\n import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n \n public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlParameterNamesDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlParameterNamesDAO.class.getName();\n+    private static final String SQL_CALL_ADD_PARAMETER_NAME = \"{CALL %s.add_parameter_name(?, ?)}\";\n \n-    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlParameterNamesDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n     }\n \n+    /**\n+     * Calls a stored procedure to read the name contained in the passed Parameter in the Parameter_Names table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param parameterName\n+     * @return The generated id of the stored system.\n+     * @throws FHIRPersistenceDataAccessException\n+     */\n     @Override\n     public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getParameterId(parameterName);\n+        final String METHODNAME = \"readOrAddParameterNameId\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n+        int parameterNameId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing search parameter name id: name=\" + parameterName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n \n-                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, parameterName);\n-                    stmt.executeUpdate();\n+        try {\n+            // TODO: schema should be known by application. Fix to avoid an extra round-trip.\n+            currentSchema = getConnection().getSchema().trim();\n+            stmtString = String.format(SQL_CALL_ADD_PARAMETER_NAME, currentSchema);\n+            try (CallableStatement stmt = getConnection().prepareCall(stmtString)) {\n+                stmt.setString(1, parameterName);\n+                stmt.registerOutParameter(2, Types.INTEGER);\n+                dbCallStartTime = System.nanoTime();\n+                stmt.execute();\n+                dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+                if (log.isLoggable(Level.FINE)) {\n+                        log.fine(\"DB read/store parameter name id complete. executionTime=\" + dbCallDuration + \"ms\");\n                 }\n-            } catch (SQLException e) {\n-                throw new FHIRPersistenceDataAccessException(\"Error while getting or inserting parameterName '\" + parameterName + \"'\", e);\n+                parameterNameId = stmt.getInt(2);\n             }\n         }\n-\n-        // cannot be null, so safe to return as an int\n-        return result;\n+        catch (Throwable e) {", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMjUyOQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420722529", "bodyText": "it says postgres above, why does it state db2 on this line.", "author": "prb112", "createdAt": "2020-05-06T11:35:37Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirSchemaGenerator.java", "diffHunk": "@@ -367,31 +369,72 @@ public void buildSchema(PhysicalDataModel model) {\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_CODE_SYSTEM.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, codeSystemsTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_PARAMETER_NAME,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_PARAMETER_NAME.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, parameterNamesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_RESOURCE_TYPE,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_RESOURCE_TYPE.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_ANY_RESOURCE,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_ANY_RESOURCE.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        // Add stored procedures/functions for postgresql.\n+        pd = model.addProcedure(this.schemaName,\n+                ADD_CODE_SYSTEM,\n+                FhirSchemaConstants.INITIAL_VERSION,\n+                () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_CODE_SYSTEM.toLowerCase()\n+                        + \"_\" + DbType.POSTGRESQL.value() + \".sql\", null),\n+                Arrays.asList(fhirSequence, codeSystemsTable, allTablesComplete),\n+                procedurePrivileges, DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        pd = model.addProcedure(this.schemaName,\n+                ADD_PARAMETER_NAME,\n+                FhirSchemaConstants.INITIAL_VERSION,\n+                () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_PARAMETER_NAME.toLowerCase()\n+                        + \"_\" + DbType.POSTGRESQL.value() + \".sql\", null),\n+                Arrays.asList(fhirSequence, parameterNamesTable, allTablesComplete),\n+                procedurePrivileges, DbType.DB2);", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTIyOA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421221228", "bodyText": "typo error, fixed.", "author": "albertwang-ibm", "createdAt": "2020-05-07T03:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMjUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMjU1OA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420722558", "bodyText": "it says postgres above, why does it state db2 on this line.", "author": "prb112", "createdAt": "2020-05-06T11:35:41Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirSchemaGenerator.java", "diffHunk": "@@ -367,31 +369,72 @@ public void buildSchema(PhysicalDataModel model) {\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_CODE_SYSTEM.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, codeSystemsTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_PARAMETER_NAME,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_PARAMETER_NAME.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, parameterNamesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_RESOURCE_TYPE,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_RESOURCE_TYPE.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_ANY_RESOURCE,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_ANY_RESOURCE.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        // Add stored procedures/functions for postgresql.\n+        pd = model.addProcedure(this.schemaName,\n+                ADD_CODE_SYSTEM,\n+                FhirSchemaConstants.INITIAL_VERSION,\n+                () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_CODE_SYSTEM.toLowerCase()\n+                        + \"_\" + DbType.POSTGRESQL.value() + \".sql\", null),\n+                Arrays.asList(fhirSequence, codeSystemsTable, allTablesComplete),\n+                procedurePrivileges, DbType.DB2);", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMjYwMg==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420722602", "bodyText": "it says postgres above, why does it state db2 on this line.", "author": "prb112", "createdAt": "2020-05-06T11:35:49Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirSchemaGenerator.java", "diffHunk": "@@ -367,31 +369,72 @@ public void buildSchema(PhysicalDataModel model) {\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_CODE_SYSTEM.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, codeSystemsTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_PARAMETER_NAME,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_PARAMETER_NAME.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, parameterNamesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_RESOURCE_TYPE,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_RESOURCE_TYPE.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_ANY_RESOURCE,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_ANY_RESOURCE.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        // Add stored procedures/functions for postgresql.\n+        pd = model.addProcedure(this.schemaName,\n+                ADD_CODE_SYSTEM,\n+                FhirSchemaConstants.INITIAL_VERSION,\n+                () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_CODE_SYSTEM.toLowerCase()\n+                        + \"_\" + DbType.POSTGRESQL.value() + \".sql\", null),\n+                Arrays.asList(fhirSequence, codeSystemsTable, allTablesComplete),\n+                procedurePrivileges, DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        pd = model.addProcedure(this.schemaName,\n+                ADD_PARAMETER_NAME,\n+                FhirSchemaConstants.INITIAL_VERSION,\n+                () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_PARAMETER_NAME.toLowerCase()\n+                        + \"_\" + DbType.POSTGRESQL.value() + \".sql\", null),\n+                Arrays.asList(fhirSequence, parameterNamesTable, allTablesComplete),\n+                procedurePrivileges, DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        pd = model.addProcedure(this.schemaName,\n+                ADD_RESOURCE_TYPE,\n+                FhirSchemaConstants.INITIAL_VERSION,\n+                () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_RESOURCE_TYPE.toLowerCase()\n+                        + \"_\" + DbType.POSTGRESQL.value() + \".sql\", null),\n+                Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n+                procedurePrivileges, DbType.DB2);", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMjY0Ng==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420722646", "bodyText": "it says postgres above, why does it state db2 on this line.", "author": "prb112", "createdAt": "2020-05-06T11:35:54Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirSchemaGenerator.java", "diffHunk": "@@ -367,31 +369,72 @@ public void buildSchema(PhysicalDataModel model) {\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_CODE_SYSTEM.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, codeSystemsTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_PARAMETER_NAME,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_PARAMETER_NAME.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, parameterNamesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_RESOURCE_TYPE,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_RESOURCE_TYPE.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_ANY_RESOURCE,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_ANY_RESOURCE.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        // Add stored procedures/functions for postgresql.\n+        pd = model.addProcedure(this.schemaName,\n+                ADD_CODE_SYSTEM,\n+                FhirSchemaConstants.INITIAL_VERSION,\n+                () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_CODE_SYSTEM.toLowerCase()\n+                        + \"_\" + DbType.POSTGRESQL.value() + \".sql\", null),\n+                Arrays.asList(fhirSequence, codeSystemsTable, allTablesComplete),\n+                procedurePrivileges, DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        pd = model.addProcedure(this.schemaName,\n+                ADD_PARAMETER_NAME,\n+                FhirSchemaConstants.INITIAL_VERSION,\n+                () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_PARAMETER_NAME.toLowerCase()\n+                        + \"_\" + DbType.POSTGRESQL.value() + \".sql\", null),\n+                Arrays.asList(fhirSequence, parameterNamesTable, allTablesComplete),\n+                procedurePrivileges, DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        pd = model.addProcedure(this.schemaName,\n+                ADD_RESOURCE_TYPE,\n+                FhirSchemaConstants.INITIAL_VERSION,\n+                () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_RESOURCE_TYPE.toLowerCase()\n+                        + \"_\" + DbType.POSTGRESQL.value() + \".sql\", null),\n+                Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n+                procedurePrivileges, DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        pd = model.addProcedure(this.schemaName,\n+                ADD_ANY_RESOURCE,\n+                FhirSchemaConstants.INITIAL_VERSION,\n+                () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_ANY_RESOURCE.toLowerCase()\n+                        + \"_\" + DbType.POSTGRESQL.value() + \".sql\", null),\n+                Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n+                procedurePrivileges, DbType.DB2);", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMjc4OA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420722788", "bodyText": "This should be in a different method specific to functions.", "author": "prb112", "createdAt": "2020-05-06T11:36:10Z", "path": "fhir-persistence-schema/src/main/java/com/ibm/fhir/schema/control/FhirSchemaGenerator.java", "diffHunk": "@@ -367,31 +369,72 @@ public void buildSchema(PhysicalDataModel model) {\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_CODE_SYSTEM.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, codeSystemsTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_PARAMETER_NAME,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_PARAMETER_NAME.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, parameterNamesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_RESOURCE_TYPE,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_RESOURCE_TYPE.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n         pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n \n         pd = model.addProcedure(this.schemaName,\n                 ADD_ANY_RESOURCE,\n                 FhirSchemaConstants.INITIAL_VERSION,\n                 () -> SchemaGeneratorUtil.readTemplate(adminSchemaName, schemaName, ADD_ANY_RESOURCE.toLowerCase() + \".sql\", null),\n                 Arrays.asList(fhirSequence, resourceTypesTable, allTablesComplete),\n-                procedurePrivileges);\n+                procedurePrivileges,\n+                DbType.DB2);\n+        pd.addTag(SCHEMA_GROUP_TAG, FHIRDATA_GROUP);\n+\n+        // Add stored procedures/functions for postgresql.", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyMTYyNw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421221627", "bodyText": "as answered above, want to keep it simpler for now, we may just need to change to use the real postgresql stored procedure in the future when it support out parameter.", "author": "albertwang-ibm", "createdAt": "2020-05-07T03:45:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMjc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMjk5Nw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420722997", "bodyText": "please remove this.\nyou NEVER get here anymore.", "author": "prb112", "createdAt": "2020-05-06T11:36:33Z", "path": "fhir-persistence-schema/src/main/resources/add_any_resource.sql", "diffHunk": "@@ -44,6 +44,11 @@ BEGIN\n --  DECLARE CONTINUE HANDLER FOR NOT FOUND          SET v_not_found = 1;\n   DECLARE CONTINUE HANDLER FOR c_duplicate        SET v_duplicate = 1;\n \n+  -- Stop right here if we don't have a valid tenant\n+  IF (fhir_admin.sv_tenant_id IS NULL) THEN\n+  \tSIGNAL SQLSTATE '99401' SET MESSAGE_TEXT = 'NOT AUTHORIZED: INVALID TENANT ID OR TENANT KEY';\n+  END IF;", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMzM1OA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420723358", "bodyText": "add copyright", "author": "prb112", "createdAt": "2020-05-06T11:37:17Z", "path": "fhir-persistence-schema/src/main/resources/add_any_resource_postgresql.sql", "diffHunk": "@@ -0,0 +1,178 @@\n+( IN p_resource_type                 VARCHAR( 36),", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMzYyMw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420723623", "bodyText": "add copyright", "author": "prb112", "createdAt": "2020-05-06T11:37:47Z", "path": "fhir-persistence-schema/src/main/resources/add_code_system_postgresql.sql", "diffHunk": "@@ -0,0 +1,23 @@\n+( IN p_code_system_name  VARCHAR(255),", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMzcxNQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420723715", "bodyText": "Add copyright", "author": "prb112", "createdAt": "2020-05-06T11:37:59Z", "path": "fhir-persistence-schema/src/main/resources/add_parameter_name_postgresql.sql", "diffHunk": "@@ -0,0 +1,22 @@\n+( IN p_parameter_name    VARCHAR(255),", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMzc5Ng==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420723796", "bodyText": "formatting", "author": "prb112", "createdAt": "2020-05-06T11:38:09Z", "path": "fhir-persistence-schema/src/main/resources/add_parameter_name_postgresql.sql", "diffHunk": "@@ -0,0 +1,22 @@\n+( IN p_parameter_name    VARCHAR(255),\n+     OUT p_parameter_name_id     INT)\n+    LANGUAGE plpgsql\n+     AS $$\n+BEGIN\n+\t\n+\tSELECT parameter_name_id INTO p_parameter_name_id", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyMzkzNg==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420723936", "bodyText": "please REMOVE this", "author": "prb112", "createdAt": "2020-05-06T11:38:25Z", "path": "fhir-persistence-schema/src/main/resources/add_resource_type.sql", "diffHunk": "@@ -19,6 +19,11 @@ BEGIN\n   DECLARE CONTINUE HANDLER FOR NOT FOUND          SET v_not_found = 1;\n   DECLARE CONTINUE HANDLER FOR c_duplicate        SET v_duplicate = 1;\n \n+  -- Stop right here if we don't have a valid tenant", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNDA0Mw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420724043", "bodyText": "copyright", "author": "prb112", "createdAt": "2020-05-06T11:38:37Z", "path": "fhir-persistence-schema/src/main/resources/add_resource_type_postgresql.sql", "diffHunk": "@@ -0,0 +1,22 @@\n+( IN p_resource_type     VARCHAR(255),", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNDc3Mw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420724773", "bodyText": "I like the semantics. makes it much cleaner.", "author": "prb112", "createdAt": "2020-05-06T11:39:56Z", "path": "fhir-persistence-schema/src/main/resources/add_parameter_name_postgresql.sql", "diffHunk": "@@ -0,0 +1,22 @@\n+( IN p_parameter_name    VARCHAR(255),\n+     OUT p_parameter_name_id     INT)\n+    LANGUAGE plpgsql\n+     AS $$\n+BEGIN\n+\t\n+\tSELECT parameter_name_id INTO p_parameter_name_id\n+    FROM {{SCHEMA_NAME}}.parameter_names\n+    WHERE parameter_name = p_parameter_name;\n+    \n+    IF p_parameter_name_id IS NULL\n+    THEN\n+      SELECT NEXTVAL('{{SCHEMA_NAME}}.fhir_ref_sequence') INTO p_parameter_name_id;\n+      INSERT INTO {{SCHEMA_NAME}}.parameter_names (parameter_name_id, parameter_name)\n+         VALUES (p_parameter_name_id, p_parameter_name) ON CONFLICT DO NOTHING;", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNDg5NA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420724894", "bodyText": "formatting", "author": "prb112", "createdAt": "2020-05-06T11:40:09Z", "path": "fhir-persistence-schema/src/main/resources/add_code_system_postgresql.sql", "diffHunk": "@@ -0,0 +1,23 @@\n+( IN p_code_system_name  VARCHAR(255),\n+     OUT p_code_system_id        INT)\n+    LANGUAGE plpgsql\n+    AS $$\n+  \n+  BEGIN\n+  \n+\tSELECT code_system_id INTO p_code_system_id", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNjI4MQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420726281", "bodyText": "throws don't match.", "author": "prb112", "createdAt": "2020-05-06T11:43:08Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -78,13 +82,104 @@ public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry\n      * @throws FHIRPersistenceDBConnectException\n      * @throws FHIRPersistenceVersionIdMismatchException", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ2MTE1MA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421461150", "bodyText": "yeah, good catch, better to be consistent with the codes, even though the exceptions are detailed sub-classes of FHIRPersistenceException from inside the function.", "author": "albertwang-ibm", "createdAt": "2020-05-07T12:22:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNjI4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNjMwNA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420726304", "bodyText": "Why is this here?  prior methodology?", "author": "prb112", "createdAt": "2020-05-06T11:43:11Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -78,13 +82,104 @@ public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry\n      * @throws FHIRPersistenceDBConnectException\n      * @throws FHIRPersistenceVersionIdMismatchException\n      */\n+//    @Override", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNjUyNA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420726524", "bodyText": "signature doesnt' match since the ParameterDao is passed in", "author": "prb112", "createdAt": "2020-05-06T11:43:36Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -78,13 +82,104 @@ public PostgreSqlResourceDAO(TransactionSynchronizationRegistry trxSynchRegistry\n      * @throws FHIRPersistenceDBConnectException\n      * @throws FHIRPersistenceVersionIdMismatchException\n      */\n+//    @Override\n+//    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+//            throws FHIRPersistenceException {\n+//        final String METHODNAME = \"insert\";\n+//        logger.entering(CLASSNAME, METHODNAME);\n+//\n+//        Connection connection = null;\n+//        Integer resourceTypeId;\n+//        Timestamp lastUpdated;\n+//        boolean acquiredFromCache;\n+//        long dbCallStartTime;\n+//        double dbCallDuration;\n+//\n+//        try {\n+//            connection = this.getConnection();\n+//\n+//            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n+//            this.parameterNameDAO = new PostgreSqlParameterNamesDAO(connection, fhirRefSequenceDAO);\n+//            this.codeSystemDAO = new PostgreSqlCodeSystemDAO(connection, fhirRefSequenceDAO);\n+//\n+//            // Get resourceTypeId from ResourceTypesCache first.\n+//            resourceTypeId = ResourceTypesCache.getResourceTypeId(resource.getResourceType());\n+//            // If no found, then get resourceTypeId from local newResourceTypeIds in case this id is already in newResourceTypeIds\n+//            // but has not been updated to ResourceTypesCache yet. newResourceTypeIds is updated to ResourceTypesCache only when the\n+//            // current transaction is committed.\n+//            if (resourceTypeId == null) {\n+//                resourceTypeId = getResourceTypeIdFromCandidatorsCache(resource.getResourceType());\n+//            }\n+//\n+//            if (resourceTypeId == null) {\n+//                acquiredFromCache = false;\n+//                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+//                this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n+//            } else {\n+//                acquiredFromCache = true;\n+//            }\n+//\n+//            if (logger.isLoggable(Level.FINE)) {\n+//                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+//                         \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n+//            }\n+//\n+//            lastUpdated = resource.getLastUpdated();\n+//            dbCallStartTime = System.nanoTime();\n+//\n+//            final String sourceKey = UUID.randomUUID().toString();\n+//\n+//            long resourceId = this.storeResource(resource.getResourceType(),\n+//                parameters,\n+//                resource.getLogicalId(),\n+//                resource.getData(),\n+//                lastUpdated,\n+//                resource.isDeleted(),\n+//                sourceKey,\n+//                resource.getVersionId(),\n+//                connection\n+//                );\n+//            dbCallDuration = (System.nanoTime() - dbCallStartTime)/1e6;\n+//\n+//            resource.setId(resourceId);\n+//            if (logger.isLoggable(Level.FINE)) {\n+//                logger.fine(\"Successfully inserted Resource. id=\" + resource.getId() + \" executionTime=\" + dbCallDuration + \"ms\");\n+//            }\n+//        } catch(FHIRPersistenceDBConnectException | FHIRPersistenceDataAccessException e) {\n+//            throw e;\n+//        } catch(SQLIntegrityConstraintViolationException e) {\n+//            FHIRPersistenceFKVException fx = new FHIRPersistenceFKVException(\"Encountered FK violation while inserting Resource.\");\n+//            throw severe(logger, fx, e);\n+//        } catch(SQLException e) {\n+//            if (\"99001\".equals(e.getSQLState())) {\n+//                // this is just a concurrency update, so there's no need to log the SQLException here\n+//                throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n+//            } else {\n+//                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+//                throw severe(logger, fx, e);\n+//            }\n+//        } catch(Throwable e) {\n+//            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n+//            throw severe(logger, fx, e);\n+//        } finally {\n+//            this.cleanup(null, connection);\n+//            logger.exiting(CLASSNAME, METHODNAME);\n+//        }\n+//\n+//        return resource;\n+//    }\n+\n+\n     @Override\n-    public Resource  insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n+    public Resource insert(Resource resource, List<ExtractedParameterValue> parameters, ParameterDAO parameterDao)\n             throws FHIRPersistenceException {\n-        final String METHODNAME = \"insert\";\n+        final String METHODNAME = \"insert(Resource, List<ExtractedParameterValue>\";", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNjg1OA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420726858", "bodyText": "this is very strange to me", "author": "prb112", "createdAt": "2020-05-06T11:44:17Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -143,14 +253,14 @@ public Resource  insert(Resource resource, List<ExtractedParameterValue> paramet\n                 // this is just a concurrency update, so there's no need to log the SQLException here\n                 throw new FHIRPersistenceVersionIdMismatchException(\"Encountered version id mismatch while inserting Resource\");\n             } else {\n-                FHIRPersistenceException fx = new FHIRPersistenceException(\"SQLException encountered while inserting Resource.\");\n+                FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"SQLException encountered while inserting Resource.\");\n                 throw severe(logger, fx, e);\n             }\n         } catch(Throwable e) {\n             FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(\"Failure inserting Resource.\");\n             throw severe(logger, fx, e);\n         } finally {\n-            this.cleanup(null, connection);\n+            this.cleanup(stmt, connection);", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNzcxNQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421227715", "bodyText": "do the cleanup same as DB2 codes, it just returns the connection to the pool", "author": "albertwang-ibm", "createdAt": "2020-05-07T04:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNjg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyNzY0Mw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420727643", "bodyText": "removal candidate?", "author": "prb112", "createdAt": "2020-05-06T11:45:42Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -191,241 +301,241 @@ public Resource  insert(Resource resource, List<ExtractedParameterValue> paramet\n      * @return the resource_id for the entry we created\n      * @throws Exception\n      */\n-    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,\n-        String p_source_key, Integer p_version, Connection conn) throws Exception {\n-\n-        final String METHODNAME = \"storeResource() for \" + tablePrefix + \" resource\";\n-        logger.entering(CLASSNAME, METHODNAME);\n-\n-        Long v_logical_resource_id = null;\n-        Long v_current_resource_id = null;\n-        Long v_resource_id = null;\n-        Integer v_resource_type_id = null;\n-        boolean v_new_resource = false;\n-        boolean v_not_found = false;\n-        boolean v_duplicate = false;\n-        int v_version = 0;\n-        int v_insert_version = 0;\n-\n-        String v_resource_type = tablePrefix;\n-\n-        // Map the resource type name to the normalized id value in the database\n-        v_resource_type_id = getResourceTypeId(v_resource_type, conn);\n-        if (v_resource_type_id == null) {\n-            // programming error, as this should've been created earlier\n-            throw new IllegalStateException(\"resource type not found: \" + v_resource_type);\n-        }\n-\n-        // Get a lock at the system-wide logical resource level.\n-        final String SELECT_FOR_UPDATE = \"SELECT logical_resource_id FROM logical_resources WHERE resource_type_id = ? AND logical_id = ? FOR UPDATE\";\n-        try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n-            stmt.setInt(1, v_resource_type_id);\n-            stmt.setString(2, p_logical_id);\n-            ResultSet rs = stmt.executeQuery();\n-            if (rs.next()) {\n-                v_logical_resource_id = rs.getLong(1);\n-            } else {\n-                v_not_found = true;\n-                v_logical_resource_id = -1L; // just to be careful\n-            }\n-        }\n-\n-        // Create the logical resource if we don't have it already\n-        if (v_not_found) {\n-            // grab the id we want to use for the new logical resource instance\n-            final String sql2 = \"SELECT nextval('fhir_sequence')\";\n-            try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n-                ResultSet res = stmt.executeQuery();\n-                if (res.next()) {\n-                    v_logical_resource_id = res.getLong(1);\n-                } else {\n-                    // not going to happen, unless someone butchers the statement being executed\n-                    throw new IllegalStateException(\"VALUES failed to return a row: \" + sql2);\n-                }\n-            }\n-\n-            try {\n-                // insert the system-wide logical resource record.\n-                final String sql3 = \"INSERT INTO logical_resources (logical_resource_id, resource_type_id, logical_id) VALUES (?, ?, ?)\";\n-                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n-                    // bind parameters\n-                    stmt.setLong(1, v_logical_resource_id);\n-                    stmt.setInt(2, v_resource_type_id);\n-                    stmt.setString(3, p_logical_id);\n-                    stmt.executeUpdate();\n-                }\n-            } catch (SQLException e) {\n-                if (translator.isDuplicate(e)) {\n-                    v_duplicate = true;\n-                }  else {\n-                    throw e;\n-                }\n-            }\n-\n-            /**\n-             * remember that we have a concurrent system...so there is a possibility\n-             * that another thread snuck in before us and created the logical resource. This\n-             * is easy to handle, just turn around and read it\n-             */\n-            if (v_duplicate) {\n-                try (PreparedStatement stmt = conn.prepareStatement(SELECT_FOR_UPDATE)) {\n-                    // bind parameters\n-                    stmt.setInt(1, v_resource_type_id);\n-                    stmt.setString(2, p_logical_id);\n-                    ResultSet res = stmt.executeQuery();\n-                    if (res.next()) {\n-                        v_logical_resource_id = res.getLong(1);\n-                    } else {\n-                        // Extremely unlikely as we should never delete logical resource records\n-                        throw new IllegalStateException(\"Logical resource was deleted: \" + tablePrefix + \"/\" + p_logical_id);\n-                    }\n-                }\n-            } else {\n-                v_new_resource = true;\n-\n-                // Insert the resource-specific logical resource record. Remember that logical_id is denormalized\n-                // so it gets stored again here for convenience\n-                final String sql3 = \"INSERT INTO \" + tablePrefix + \"_logical_resources (logical_resource_id, logical_id) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n-                    // bind parameters\n-                    stmt.setLong(1, v_logical_resource_id);\n-                    stmt.setString(2, p_logical_id);\n-                    stmt.executeUpdate();\n-                }\n-            }\n-        }\n-\n-        if (!v_new_resource) {\n-            // existing resource.  We need to know the current version from the\n-            // resource-specific logical resources table.\n-            final String sql3 = \"SELECT current_resource_id FROM \" + tablePrefix + \"_logical_resources WHERE logical_resource_id = ?\";\n-            try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n-                stmt.setLong(1, v_logical_resource_id);\n-                ResultSet rs = stmt.executeQuery();\n-                if (rs.next()) {\n-                    v_current_resource_id = rs.getLong(1);\n-                } else {\n-                    // This database is broken, because we shouldn't have logical_resource records without\n-                    // corresponding resource-specific logical_resource records.\n-                    throw new SQLException(\"Logical_id record '\" + p_logical_id + \"' missing for resource \" + tablePrefix);\n-                }\n-            }\n-\n-            // so if we are storing a specific version, do a quick check to make\n-            // sure that this version doesn't currently exist. This is only done when processing\n-            // replication messages which might be duplicated. We want the operation to be idempotent,\n-            // so if the resource already exists, we don't need to do anything else.\n-\n-            if (p_version != null) {\n-                final String sqlStmt = \"SELECT resource_id FROM \" + tablePrefix + \"_resources dr WHERE dr.logical_resource_id = ? AND dr.version_id = ?\";\n-                try (PreparedStatement stmt = conn.prepareStatement(sqlStmt)) {\n-                    // bind parameters\n-                    stmt.setLong(1, v_logical_resource_id);\n-                    stmt.setLong(2, p_version);\n-                    ResultSet res = stmt.executeQuery();\n-                    if (res.next()) {\n-                        // this version of this resource already exists, so we bail out right away\n-                        v_resource_id = res.getLong(1);\n-                        return v_resource_id;\n-                    }\n-                }\n-            }\n-\n-            // Grab the version value for the current version (identified by v_current_resource_id)\n-            final String sql4 = \"SELECT version_id FROM \" + tablePrefix + \"_resources WHERE resource_id = ?\";\n-            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n-                stmt.setLong(1, v_current_resource_id);\n-                ResultSet res = stmt.executeQuery();\n-                if (res.next()) {\n-                    v_version = res.getInt(1);\n-                } else {\n-                    throw new IllegalStateException(\"current resource not found: \"\n-                            + tablePrefix + \"_resources.resource_id=\" + v_current_resource_id);\n-                }\n-            }\n-\n-            //If we have been passed a version number, this means that this is a replicated\n-            //resource, and so we only need to delete parameters if the given version is\n-            // later than the current version\n-            if (p_version == null || p_version > v_version) {\n-                // existing resource, so need to delete all its parameters\n-                // delete composites first, or else the foreign keys there restrict deletes on referenced tables\n-                deleteFromParameterTable(conn, tablePrefix + \"_composites\", v_logical_resource_id);\n-                deleteFromParameterTable(conn, tablePrefix + \"_str_values\", v_logical_resource_id);\n-                deleteFromParameterTable(conn, tablePrefix + \"_number_values\", v_logical_resource_id);\n-                deleteFromParameterTable(conn, tablePrefix + \"_date_values\", v_logical_resource_id);\n-                deleteFromParameterTable(conn, tablePrefix + \"_latlng_values\", v_logical_resource_id);\n-                deleteFromParameterTable(conn, tablePrefix + \"_token_values\", v_logical_resource_id);\n-                deleteFromParameterTable(conn, tablePrefix + \"_quantity_values\", v_logical_resource_id);\n-            }\n-        }\n-\n-        // Persist the data using the given version number if required\n-        if (p_version != null) {\n-            v_insert_version = p_version;\n-        } else {\n-            // remember we have a write (update) lock on the logical version, so we can safely calculate\n-            // the next version value here\n-            v_insert_version = v_version + 1;\n-\n-        }\n-\n-        /**\n-         * Create the new resource version.\n-         * uses last_updated time from the app-server, so we have consistency between the various DAOs\n-         */\n-        String sql2 = \"SELECT nextval('fhir_sequence')\";\n-        try (PreparedStatement stmt = conn.prepareStatement(sql2)) {\n-            ResultSet res = stmt.executeQuery();\n-            if (res.next()) {\n-                v_resource_id = res.getLong(1); //Assign result of the above query\n-            } else {\n-                // unlikely\n-                throw new IllegalStateException(\"no row returned: \" + sql2);\n-            }\n-        }\n-\n-        // Finally we get to the big resource data insert\n-        String sql3 = \"INSERT INTO \" + tablePrefix + \"_resources (resource_id, logical_resource_id, version_id, data, last_updated, is_deleted) \"\n-                + \"VALUES (?,?,?,?,?,?)\";\n-        try (PreparedStatement stmt = conn.prepareStatement(sql3)) {\n-            // bind parameters\n-            stmt.setLong(1, v_resource_id);\n-            stmt.setLong(2, v_logical_resource_id);\n-            stmt.setInt(3, v_insert_version);\n-            stmt.setBytes(4, p_payload);\n-            stmt.setTimestamp(5, p_last_updated, UTC);\n-            stmt.setString(6, p_is_deleted ? \"Y\" : \"N\");\n-            stmt.executeUpdate();\n-        }\n-\n-        if (p_version == null || p_version > v_version) {\n-            //only update the logical resource if the resource we are adding supercedes the\n-            //current resource\n-            String sql4 = \"UPDATE \" + tablePrefix + \"_logical_resources SET current_resource_id = ? WHERE logical_resource_id = ?\";\n-            try (PreparedStatement stmt = conn.prepareStatement(sql4)) {\n-                // bind parameters\n-                stmt.setLong(1, v_resource_id);\n-                stmt.setLong(2, v_logical_resource_id);\n-                stmt.executeUpdate();\n-            }\n-\n-            // To keep things simple for the postgresql use-case, we just use a visitor to\n-            // handle inserts of parameters directly in the resource parameter tables.\n-            // Note we don't get any parameters for the resource soft-delete operation\n-            if (parameters != null) {\n-                // postgresql doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n-                try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n-                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n-                    for (ExtractedParameterValue p: parameters) {\n-                        p.accept(pvd);\n-                    }\n-                }\n-            }\n-        }\n-        logger.exiting(CLASSNAME, METHODNAME);\n-        return v_resource_id;\n-    }\n+//    public long storeResource(String tablePrefix, List<ExtractedParameterValue> parameters, String p_logical_id, byte[] p_payload, Timestamp p_last_updated, boolean p_is_deleted,", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyODM1NQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r420728355", "bodyText": "really strange to me.", "author": "prb112", "createdAt": "2020-05-06T11:47:05Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -479,17 +589,62 @@ public int getOrCreateResourceType(String resourceTypeName, Connection conn) thr\n \n         // Create the resource if we don't have it already (set by the continue handler)\n         if (result == null) {\n-            result = fhirRefSequenceDAO.nextValue();\n-\n-            final String INS = \"INSERT INTO resource_types (resource_type_id, resource_type) VALUES (?, ?)\";\n-            try (PreparedStatement stmt = conn.prepareStatement(INS)) {\n-                // bind parameters\n-                stmt.setInt(1, result);\n-                stmt.setString(2, resourceTypeName);\n-                stmt.executeUpdate();\n+            try {\n+                result = fhirRefSequenceDAO.nextValue();\n+                final String INS = \"INSERT INTO resource_types (resource_type_id, resource_type) VALUES (?, ?)\";\n+                try (PreparedStatement stmt = conn.prepareStatement(INS)) {\n+                    // bind parameters\n+                    stmt.setInt(1, result);\n+                    stmt.setString(2, resourceTypeName);\n+                    stmt.executeUpdate();\n+                }\n+            } catch (SQLException e) {\n+                throw e;\n             }\n         }\n \n         return result;\n     }\n+\n+\n+    @Override\n+    public Integer readResourceTypeId(String resourceType) throws FHIRPersistenceDBConnectException, FHIRPersistenceDataAccessException  {\n+        final String METHODNAME = \"readResourceTypeId\";\n+        logger.entering(CLASSNAME, METHODNAME);\n+\n+        Connection connection = null;\n+        CallableStatement stmt = null;\n+        Integer resourceTypeId = null;\n+        String currentSchema;\n+        String stmtString;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n+\n+        try {\n+            connection = this.getConnection();\n+            currentSchema = connection.getSchema().trim();\n+            stmtString = String.format(SQL_READ_RESOURCE_TYPE, currentSchema);\n+            stmt = connection.prepareCall(stmtString);\n+            stmt.setString(1, resourceType);\n+            stmt.registerOutParameter(2, Types.INTEGER);\n+            dbCallStartTime = System.nanoTime();\n+            stmt.execute();\n+            dbCallDuration = (System.nanoTime()-dbCallStartTime)/1e6;\n+            if (logger.isLoggable(Level.FINER)) {\n+                logger.finer(\"DB read resource type id complete. executionTime=\" + dbCallDuration + \"ms\");\n+            }\n+            resourceTypeId = stmt.getInt(2);\n+        } catch(FHIRPersistenceDBConnectException e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            final String errMsg = \"Failure storing Resource type name id: name=\" + resourceType;\n+            FHIRPersistenceDataAccessException fx = new FHIRPersistenceDataAccessException(errMsg);\n+            throw severe(logger, fx, e);\n+        } finally {\n+            this.cleanup(stmt, connection);", "originalCommit": "b7ab6c3e372bbdc19b7224fb24966c4e461154c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIyNzg0Mg==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421227842", "bodyText": "same as in db2 codes.", "author": "albertwang-ibm", "createdAt": "2020-05-07T04:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcyODM1NQ=="}], "type": "inlineReview"}, {"oid": "81ed39c897f68e68efa55901be929721cba5d33c", "url": "https://github.com/IBM/FHIR/commit/81ed39c897f68e68efa55901be929721cba5d33c", "message": "issue #945 remove changes to DB2 SPs\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-05-06T16:06:15Z", "type": "commit"}, {"oid": "a33a5fba1b62504c0c52918853ce048c9275c36f", "url": "https://github.com/IBM/FHIR/commit/a33a5fba1b62504c0c52918853ce048c9275c36f", "message": "Merge pull request #1034 from IBM/issue-945\n\nIssue 945", "committedDate": "2020-05-06T16:07:27Z", "type": "commit"}, {"oid": "fb66eed2b4f878145556c1ddb8fd51ea481604cf", "url": "https://github.com/IBM/FHIR/commit/fb66eed2b4f878145556c1ddb8fd51ea481604cf", "message": "Merge pull request #1037 from IBM/issue-945\n\nIssue 945 - sync with master", "committedDate": "2020-05-06T18:33:12Z", "type": "commit"}, {"oid": "49cc2920a957bfc31c7d6490751e089d8afd2165", "url": "https://github.com/IBM/FHIR/commit/49cc2920a957bfc31c7d6490751e089d8afd2165", "message": "issue #945 enable caches for postgresql and derby\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-05-07T01:59:41Z", "type": "commit"}, {"oid": "191abc117e55d6f9c38cec7cc1fb8d8e95f3f927", "url": "https://github.com/IBM/FHIR/commit/191abc117e55d6f9c38cec7cc1fb8d8e95f3f927", "message": "issue #945 update 1 per review comments\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-05-07T04:13:01Z", "type": "commit"}, {"oid": "2f31e8de502ff9aeaf5937f4cd20903a1ac1b440", "url": "https://github.com/IBM/FHIR/commit/2f31e8de502ff9aeaf5937f4cd20903a1ac1b440", "message": "issue #945 update 2 per review comments\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-05-07T12:32:53Z", "type": "commit"}, {"oid": "dccb3972d197e99b3a9b93dddb5f21d3b56e6b0e", "url": "https://github.com/IBM/FHIR/commit/dccb3972d197e99b3a9b93dddb5f21d3b56e6b0e", "message": "issue #945 update schema procedure tool for pgsql\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-05-07T15:56:44Z", "type": "commit"}, {"oid": "b9320124879c57b243f085c591275ccb7131bbcc", "url": "https://github.com/IBM/FHIR/commit/b9320124879c57b243f085c591275ccb7131bbcc", "message": "issue #945 minor code style updates\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-05-07T16:11:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NDg4MA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421664880", "bodyText": "If there isn't going to be a split. I suggest changing the name of this to addProcedureAndFunctions", "author": "prb112", "createdAt": "2020-05-07T17:16:32Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/model/PhysicalDataModel.java", "diffHunk": "@@ -247,8 +247,8 @@ public void removeTenantPartitions(IDatabaseAdapter adapter, String schemaName,\n      * @return\n      */\n     public ProcedureDef addProcedure(String schemaName, String objectName, int version, Supplier<String> templateProvider,", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3ODQ2MA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421678460", "bodyText": "Ok, good point, let me change", "author": "albertwang-ibm", "createdAt": "2020-05-07T17:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NDg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2NTM4OA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421665388", "bodyText": "I suggest changing the interface to createOrReplaceProcedureAndFunctions", "author": "prb112", "createdAt": "2020-05-07T17:17:26Z", "path": "fhir-database-utils/src/main/java/com/ibm/fhir/database/utils/postgresql/PostgreSqlAdapter.java", "diffHunk": "@@ -150,7 +150,24 @@ public void dropType(String schemaName, String typeName) {\n \n     @Override\n     public void createOrReplaceProcedure(String schemaName, String procedureName, Supplier<String> supplier) {", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2ODMxOQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421668319", "bodyText": ", 2020", "author": "prb112", "createdAt": "2020-05-07T17:22:27Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ParameterDAOImpl.java", "diffHunk": "@@ -7,19 +7,25 @@\n package com.ibm.fhir.persistence.jdbc.dao.impl;", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2OTEzNg==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421669136", "bodyText": "same line as previous close", "author": "prb112", "createdAt": "2020-05-07T17:23:48Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ParameterDAOImpl.java", "diffHunk": "@@ -110,16 +116,28 @@ public ParameterDAOImpl(Connection managedConnection) {\n      */\n     @Override\n     public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDBConnectException, FHIRPersistenceDataAccessException  {\n-        final String METHODNAME = \"readParameterNameId\";\n+        final String METHODNAME = \"readOrAddParameterNameId\";\n         log.entering(CLASSNAME, METHODNAME);\n \n         Connection connection = null;\n \n         try {\n             connection = this.getConnection();\n-            ParameterNameDAO pnd = new ParameterNameDAOImpl(connection);\n+            String dbProductName = connection.getMetaData().getDatabaseProductName().toLowerCase();\n+            ParameterNameDAO pnd;\n+            if (dbProductName.equals(DbType.POSTGRESQL.value())) {\n+                pnd = new PostgreSqlParameterNamesDAO(connection);\n+            } else if (dbProductName.contains(DbType.DERBY.value())) {\n+                pnd = new DerbyParameterNamesDAO(connection);\n+            } else {\n+                pnd = new ParameterNameDAOImpl(connection);\n+            }\n+\n             return pnd.readOrAddParameterNameId(parameterName);\n         }\n+        catch (SQLException e) {", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2OTIwMA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421669200", "bodyText": "same line as previous", "author": "prb112", "createdAt": "2020-05-07T17:23:56Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ParameterDAOImpl.java", "diffHunk": "@@ -137,15 +155,27 @@ public int readOrAddParameterNameId(String parameterName) throws FHIRPersistence\n      */\n     @Override\n     public int readOrAddCodeSystemId(String codeSystemName) throws FHIRPersistenceDBConnectException, FHIRPersistenceDataAccessException   {\n-        final String METHODNAME = \"storeCodeSystemId\";\n+        final String METHODNAME = \"readOrAddCodeSystemId\";\n         log.entering(CLASSNAME, METHODNAME);\n \n         Connection connection = null;\n         try {\n             connection = this.getConnection();\n-            CodeSystemDAO csd = new CodeSystemDAOImpl(connection);\n+            String dbProductName = connection.getMetaData().getDatabaseProductName().toLowerCase();\n+            CodeSystemDAO csd;\n+            if (dbProductName.equals(DbType.POSTGRESQL.value())) {\n+                csd = new PostgreSqlCodeSystemDAO(connection);\n+            } else if (dbProductName.contains(DbType.DERBY.value())) {\n+                csd = new DerbyCodeSystemDAO(connection);\n+            } else {\n+                csd = new CodeSystemDAOImpl(connection);\n+            }\n+\n             return csd.readOrAddCodeSystem(codeSystemName);\n         }\n+        catch (SQLException e) {", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2OTc2NA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421669764", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // If no found, then get ParameterNameId from local newParameterNameIds in case this id is already in newParameterNameIds\n          \n          \n            \n                    // If not found, then get ParameterNameId from local newParameterNameIds in case this id is already in newParameterNameIds", "author": "prb112", "createdAt": "2020-05-07T17:24:54Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ParameterDAOImpl.java", "diffHunk": "@@ -216,6 +246,19 @@ public void addParameterNamesCacheCandidate(String parameterName, Integer parame\n \n     }\n \n+\n+    protected  Integer getParameterNameIdFromCaches(String parameterName) {\n+        // Get ParameterNameId from ParameterNameIdCache first.\n+        Integer parameterNameId = ParameterNamesCache.getParameterNameId(parameterName);\n+        // If no found, then get ParameterNameId from local newParameterNameIds in case this id is already in newParameterNameIds", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5effe479f2dd32a2e5707f6d2f656a5dfff7d752", "url": "https://github.com/IBM/FHIR/commit/5effe479f2dd32a2e5707f6d2f656a5dfff7d752", "message": "issue #945 update schema tool\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-05-07T17:25:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MDQ5NQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421670495", "bodyText": ", 2020", "author": "prb112", "createdAt": "2020-05-07T17:26:05Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/dao/impl/ParameterNameDAOImpl.java", "diffHunk": "@@ -22,21 +22,21 @@\n /**", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MDk0OA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421670948", "bodyText": ", 2020", "author": "prb112", "createdAt": "2020-05-07T17:26:46Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/DerbyCodeSystemDAO.java", "diffHunk": "@@ -28,47 +28,45 @@\n      * @param c\n      * @param fsd\n      */\n-    public DerbyCodeSystemDAO(Connection c, FhirRefSequenceDAO fsd) {", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MTI1NA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421671254", "bodyText": ", 2020", "author": "prb112", "createdAt": "2020-05-07T17:27:17Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/DerbyParameterNamesDAO.java", "diffHunk": "@@ -21,23 +21,24 @@\n  */\n public class DerbyParameterNamesDAO extends ParameterNameDAOImpl {\n     private final FhirRefSequenceDAO fhirRefSequenceDAO;\n-    \n-    public DerbyParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MTc4OQ==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421671789", "bodyText": "why does codeSystemCacheAdapter now get the parameterDao?", "author": "prb112", "createdAt": "2020-05-07T17:28:12Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/derby/DerbyResourceDAO.java", "diffHunk": "@@ -437,7 +423,7 @@ public long storeResource(String tablePrefix, List<ExtractedParameterValue> para\n             if (parameters != null) {\n                 // Derby doesn't support partitioned multi-tenancy, so we disable it on the DAO:\n                 try (ParameterVisitorBatchDAO pvd = new ParameterVisitorBatchDAO(conn, null, tablePrefix, false, v_logical_resource_id, 100,\n-                    new ParameterNameCacheAdapter(parameterNameDAO), new CodeSystemCacheAdapter(codeSystemDAO))) {\n+                    new ParameterNameCacheAdapter(parameterDao), new CodeSystemCacheAdapter(parameterDao))) {", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY4NjA4MA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421686080", "bodyText": "the parameterDao is actually a wrap for both parameterNameDAO and codeSystemDAO, the the cache implemenation is done inside parameterDao.  very interesting implementation.", "author": "albertwang-ibm", "createdAt": "2020-05-07T17:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MTc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MjYwNw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421672607", "bodyText": "I think logically this should go in the catch block.", "author": "prb112", "createdAt": "2020-05-07T17:29:23Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlCodeSystemDAO.java", "diffHunk": "@@ -21,84 +21,59 @@\n  *\n  */\n public class PostgreSqlCodeSystemDAO extends CodeSystemDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlCodeSystemDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlCodeSystemDAO.class.getName();\n+    private static final String SQL_CALL_ADD_CODE_SYSTEM_ID = \"{CALL %s.add_code_system(?, ?)}\";\n \n     /**\n      * Public constructor\n      * @param c\n      * @param fsd\n      */\n-    public PostgreSqlCodeSystemDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlCodeSystemDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n-    }\n-\n-    @Override\n-    public int readOrAddCodeSystem(String codeSystem) throws FHIRPersistenceDataAccessException   {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getCodeSystemId(codeSystem);\n-\n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n-\n-                String INS = \"INSERT INTO code_systems (code_system_id, code_system_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, codeSystem);\n-                    stmt.executeUpdate();\n-                }\n-            }\n-            catch (SQLException e) {\n-                if (\"23505\".equals(e.getSQLState())) {\n-                    // another thread snuck in and created the record, so we need to fetch the correct id\n-                    result = getCodeSystemId(codeSystem);\n-\n-                    if (result == null) {\n-                        // This would be truly weird, but we protect against it anyway\n-                        throw new IllegalStateException(\"No code system returned after duplicate found!\");\n-                    }\n-                }\n-                else {\n-                    throw new FHIRPersistenceDataAccessException(\"codeSystem=\" + codeSystem, e);\n-                }\n-            }\n-\n-        }\n-\n-        // There's no way result can be null here, so we're OK returning an int\n-        return result;\n     }\n \n     /**\n-     * Read the id for the named type\n-     * @param codeSystem\n-     * @return the database id, or null if the named record is not found\n+     * Calls a stored procedure to read the system contained in the passed Parameter in the Code_Systems table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n+     * @param systemName\n+     *\n+     * @return The generated id of the stored system.\n      * @throws FHIRPersistenceDataAccessException\n      */\n-    protected Integer getCodeSystemId(String codeSystem) throws FHIRPersistenceDataAccessException {\n-        Integer result;\n-\n-        String sql1 = \"SELECT code_system_id FROM code_systems WHERE code_system_name = ?\";\n-\n-        try (PreparedStatement stmt = getConnection().prepareStatement(sql1)) {\n-            stmt.setString(1, codeSystem);\n-            ResultSet rs = stmt.executeQuery();\n-            if (rs.next()) {\n-                result = rs.getInt(1);\n-            }\n-            else {\n-                result = null;\n+    @Override\n+    public int readOrAddCodeSystem(String systemName) throws FHIRPersistenceDataAccessException   {\n+        final String METHODNAME = \"readOrAddCodeSystem\";\n+        log.entering(CLASSNAME, METHODNAME);\n+\n+        int systemId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing code system id: name=\" + systemName;", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY4NzYxNw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421687617", "bodyText": "I agree", "author": "albertwang-ibm", "createdAt": "2020-05-07T17:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MjYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MzIwNA==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421673204", "bodyText": "It should be set by the connection.\nWe can enforce this as part of the creation of the datasource", "author": "prb112", "createdAt": "2020-05-07T17:30:22Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlParameterNamesDAO.java", "diffHunk": "@@ -6,75 +6,63 @@\n \n package com.ibm.fhir.persistence.jdbc.postgresql;\n \n+import java.sql.CallableStatement;\n import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n+import java.sql.Types;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n \n-import com.ibm.fhir.persistence.jdbc.dao.api.FhirRefSequenceDAO;\n import com.ibm.fhir.persistence.jdbc.dao.impl.ParameterNameDAOImpl;\n import com.ibm.fhir.persistence.jdbc.exception.FHIRPersistenceDataAccessException;\n \n public class PostgreSqlParameterNamesDAO extends ParameterNameDAOImpl {\n-    private final FhirRefSequenceDAO fhirRefSequenceDAO;\n+    private static final Logger log = Logger.getLogger(PostgreSqlParameterNamesDAO.class.getName());\n+    private static final String CLASSNAME = PostgreSqlParameterNamesDAO.class.getName();\n+    private static final String SQL_CALL_ADD_PARAMETER_NAME = \"{CALL %s.add_parameter_name(?, ?)}\";\n \n-    public PostgreSqlParameterNamesDAO(Connection c, FhirRefSequenceDAO fsd) {\n+    public PostgreSqlParameterNamesDAO(Connection c) {\n         super(c);\n-        this.fhirRefSequenceDAO = fsd;\n-    }\n-\n-    @Override\n-    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n-        // As the system is concurrent, we have to handle cases where another thread\n-        // might create the entry after we selected and found nothing\n-        Integer result = getParameterId(parameterName);\n-\n-        // Create the resource if we don't have it already (set by the continue handler)\n-        if (result == null) {\n-            try {\n-                result = fhirRefSequenceDAO.nextValue();\n-\n-                final String INS = \"INSERT INTO parameter_names (parameter_name_id, parameter_name) VALUES (?, ?)\";\n-                try (PreparedStatement stmt = getConnection().prepareStatement(INS)) {\n-                    // bind parameters\n-                    stmt.setInt(1, result);\n-                    stmt.setString(2, parameterName);\n-                    stmt.executeUpdate();\n-                }\n-            } catch (SQLException e) {\n-                throw new FHIRPersistenceDataAccessException(\"Error while getting or inserting parameterName '\" + parameterName + \"'\", e);\n-            }\n-        }\n-\n-        // cannot be null, so safe to return as an int\n-        return result;\n     }\n \n     /**\n-     * Read the id for the named type\n+     * Calls a stored procedure to read the name contained in the passed Parameter in the Parameter_Names table.\n+     * If it's not in the DB, it will be stored and a unique id will be returned.\n      * @param parameterName\n-     * @return the database id, or null if the named record is not found\n+     * @return The generated id of the stored system.\n      * @throws FHIRPersistenceDataAccessException\n      */\n-    protected Integer getParameterId(String parameterName) throws FHIRPersistenceDataAccessException {\n-        Integer result;\n+    @Override\n+    public int readOrAddParameterNameId(String parameterName) throws FHIRPersistenceDataAccessException  {\n+        final String METHODNAME = \"readOrAddParameterNameId\";\n+        log.entering(CLASSNAME, METHODNAME);\n \n-        String sql = \"SELECT parameter_name_id FROM parameter_names WHERE parameter_name = ?\";\n+        int parameterNameId;\n+        String currentSchema;\n+        String stmtString;\n+        String errMsg = \"Failure storing search parameter name id: name=\" + parameterName;\n+        long dbCallStartTime;\n+        double dbCallDuration;\n \n-        try (PreparedStatement stmt = getConnection().prepareStatement(sql)) {\n-            stmt.setString(1, parameterName);\n-            ResultSet rs = stmt.executeQuery();\n-            if (rs.next()) {\n-                result = rs.getInt(1);\n-            }  else {\n-                result = null;\n+        try {\n+            // TODO: schema should be known by application. Fix to avoid an extra round-trip.", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY4ODE3Mw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421688173", "bodyText": "agree, we can improve this in future PR.", "author": "albertwang-ibm", "createdAt": "2020-05-07T17:55:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MzIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MzM5Nw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421673397", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ### Update the stored procedures for FHIRDATA (and not FHIR_ADMIN) (Db2 and PostgreSQL)\n          \n          \n            \n            ### Update the stored procedures and functions for FHIRDATA (and not FHIR_ADMIN) (Db2 and PostgreSQL)", "author": "prb112", "createdAt": "2020-05-07T17:30:41Z", "path": "fhir-persistence-schema/README.md", "diffHunk": "@@ -195,14 +195,25 @@ Note, you may want to add a tenant key when a key is lost or needs to be changed\n \n Use `--tenant-key-file tenant.key.file` to direct the action to read the tenant-key from file.  If the file exists the tenant key (up to 44 characters is read from the file.  If the file does not exist, the generated tenantKey is written out to the file.\n \n-### Update the stored procedures for FHIRDATA (and not FHIR_ADMIN) (Db2 only)\n+### Update the stored procedures for FHIRDATA (and not FHIR_ADMIN) (Db2 and PostgreSQL)", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MzkzNg==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421673936", "bodyText": "Nice the function doing a lot of work.", "author": "prb112", "createdAt": "2020-05-07T17:31:37Z", "path": "fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/postgresql/PostgreSqlResourceDAO.java", "diffHunk": "@@ -93,43 +90,54 @@ public Resource  insert(Resource resource, List<ExtractedParameterValue> paramet\n \n         try {\n             connection = this.getConnection();\n-\n-            this.fhirRefSequenceDAO = new FhirRefSequenceDAOImpl(connection);\n-            this.parameterNameDAO = new PostgreSqlParameterNamesDAO(connection, fhirRefSequenceDAO);\n-            this.codeSystemDAO = new PostgreSqlCodeSystemDAO(connection, fhirRefSequenceDAO);\n-\n             resourceTypeId = getResourceTypeIdFromCaches(resource.getResourceType());\n             if (resourceTypeId == null) {\n                 acquiredFromCache = false;\n-                resourceTypeId = getOrCreateResourceType(resource.getResourceType(), connection);\n+                resourceTypeId = this.readResourceTypeId(resource.getResourceType());\n                 this.addResourceTypeCacheCandidate(resource.getResourceType(), resourceTypeId);\n             } else {\n                 acquiredFromCache = true;\n             }\n-\n-            if (logger.isLoggable(Level.FINE)) {\n-                logger.fine(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n+            if (logger.isLoggable(Level.FINER)) {\n+                logger.finer(\"resourceType=\" + resource.getResourceType() + \"  resourceTypeId=\" + resourceTypeId +\n                          \"  acquiredFromCache=\" + acquiredFromCache + \"  tenantDatastoreCacheName=\" + ResourceTypesCache.getCacheNameForTenantDatastore());\n             }\n \n+            // TODO avoid the round-trip and use the configured data schema name\n+            currentSchema = connection.getSchema().trim();\n+            stmtString = String.format(SQL_INSERT_WITH_PARAMETERS, currentSchema);\n+            stmt = connection.prepareCall(stmtString);\n+            stmt.setString(1, resource.getResourceType());\n+            stmt.setString(2, resource.getLogicalId());\n+            stmt.setBytes(3, resource.getData());", "originalCommit": "b9320124879c57b243f085c591275ccb7131bbcc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY4OTM0Nw==", "url": "https://github.com/IBM/FHIR/pull/1030#discussion_r421689347", "bodyText": "yeah", "author": "albertwang-ibm", "createdAt": "2020-05-07T17:57:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY3MzkzNg=="}], "type": "inlineReview"}, {"oid": "4f22d7c0d87041ebba81e57c25f70f60dd94ce5f", "url": "https://github.com/IBM/FHIR/commit/4f22d7c0d87041ebba81e57c25f70f60dd94ce5f", "message": "issue #945 updates per review  comments\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-05-07T18:24:21Z", "type": "commit"}, {"oid": "cedffdd0df3fe17ac4d6bb16fd5ca9647b19a041", "url": "https://github.com/IBM/FHIR/commit/cedffdd0df3fe17ac4d6bb16fd5ca9647b19a041", "message": "issue #945 log change\n\nSigned-off-by: Albert Wang <xuwang@us.ibm.com>", "committedDate": "2020-05-07T19:25:24Z", "type": "commit"}]}