{"pr_number": 1476, "pr_title": "fhir-bucket bulk loader initial merge", "pr_createdAt": "2020-09-04T13:23:02Z", "pr_url": "https://github.com/IBM/FHIR/pull/1476", "timeline": [{"oid": "321fbf0df215f8863263a3dff98d8c262ebef990", "url": "https://github.com/IBM/FHIR/commit/321fbf0df215f8863263a3dff98d8c262ebef990", "message": "issue #1402 bulk loading of resources for performance\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-13T15:01:24Z", "type": "commit"}, {"oid": "403a77e29aec945fb5b692d113eed591e2d00c19", "url": "https://github.com/IBM/FHIR/commit/403a77e29aec945fb5b692d113eed591e2d00c19", "message": "issue #1402 preliminary support for both json and ndjson\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-14T03:43:45Z", "type": "commit"}, {"oid": "7d88db8afbb53f7fec9fe824c15cb40bf56f244c", "url": "https://github.com/IBM/FHIR/commit/7d88db8afbb53f7fec9fe824c15cb40bf56f244c", "message": "issue #1402 handle loader instance failure and restart and store generated ids\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-14T21:47:26Z", "type": "commit"}, {"oid": "c9bd8ca0128179734378bdb6efc902d3f197a5ec", "url": "https://github.com/IBM/FHIR/commit/c9bd8ca0128179734378bdb6efc902d3f197a5ec", "message": "issue #1402 correctly record number of errors for each bundle/object\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-16T04:06:48Z", "type": "commit"}, {"oid": "2db4b5498bef7aaa721870a4078ac3a7db58ba45", "url": "https://github.com/IBM/FHIR/commit/2db4b5498bef7aaa721870a4078ac3a7db58ba45", "message": "issue 1424 start investigation of scale out persistence layers\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-18T21:03:10Z", "type": "commit"}, {"oid": "40c2a2cab380b18ea4ffaf8132807594814c5b86", "url": "https://github.com/IBM/FHIR/commit/40c2a2cab380b18ea4ffaf8132807594814c5b86", "message": "issue #1402 save logical ids from bundles and better tracking of stats\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-23T18:27:16Z", "type": "commit"}, {"oid": "508ebc5b2d3cc84a610e86314357d7a0065f582c", "url": "https://github.com/IBM/FHIR/commit/508ebc5b2d3cc84a610e86314357d7a0065f582c", "message": "issue #1402 fixed PostgreSQL support for FHIRBUCKET schema\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-24T04:08:17Z", "type": "commit"}, {"oid": "aadee881fe987ebb71fa6a76023ef63488362785", "url": "https://github.com/IBM/FHIR/commit/aadee881fe987ebb71fa6a76023ef63488362785", "message": "issue #1402 fixed timestampdiff for postgres, and capture and record operational outcome errors from FHIR\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-24T21:51:36Z", "type": "commit"}, {"oid": "11484ecb9c9414273e7fb2070f7b557749791bcb", "url": "https://github.com/IBM/FHIR/commit/11484ecb9c9414273e7fb2070f7b557749791bcb", "message": "issue #1402 better tracking of individual load attempts and new incremental-exact mode\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-26T15:43:53Z", "type": "commit"}, {"oid": "6b192a17af4efdcb920dd5e8839f69372b13c5c9", "url": "https://github.com/IBM/FHIR/commit/6b192a17af4efdcb920dd5e8839f69372b13c5c9", "message": "issue #1402 prototype for scale-out persistence with cassandra\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-27T18:19:00Z", "type": "commit"}, {"oid": "bc83587eab152190df654d3ac145f6ecb4ecd085", "url": "https://github.com/IBM/FHIR/commit/bc83587eab152190df654d3ac145f6ecb4ecd085", "message": "issue #1402 use deterministic order for job allocation\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-28T20:34:27Z", "type": "commit"}, {"oid": "9698b69a71dea1bb6b76fd1eb267ce9a0207c7fa", "url": "https://github.com/IBM/FHIR/commit/9698b69a71dea1bb6b76fd1eb267ce9a0207c7fa", "message": "Merge remote-tracking branch 'origin/master' into robin-proto", "committedDate": "2020-08-29T03:21:07Z", "type": "commit"}, {"oid": "c14662b54f64be2b0bad6712b66bfbc5cfe7ef01", "url": "https://github.com/IBM/FHIR/commit/c14662b54f64be2b0bad6712b66bfbc5cfe7ef01", "message": "issue #1402 improved concurrency model for JSON and NDJSON files together\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-31T03:57:30Z", "type": "commit"}, {"oid": "edb7aca256b9eb567457264d4f66117aefbf11ff", "url": "https://github.com/IBM/FHIR/commit/edb7aca256b9eb567457264d4f66117aefbf11ff", "message": "issue #1402 prototype work for cassandra persistence store\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-31T03:59:41Z", "type": "commit"}, {"oid": "8a448b8b089a44dd362694f5028c5b315589f6dc", "url": "https://github.com/IBM/FHIR/commit/8a448b8b089a44dd362694f5028c5b315589f6dc", "message": "issue #1402 README cleanup\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-31T04:06:02Z", "type": "commit"}, {"oid": "e3c19573021dde1f8342d7e69ea8e4586912a54b", "url": "https://github.com/IBM/FHIR/commit/e3c19573021dde1f8342d7e69ea8e4586912a54b", "message": "issue #1402 Use logging.properties configuration\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-08-31T15:02:43Z", "type": "commit"}, {"oid": "f087bc13f2f0a99a96524081ff12aa71daeb8d3a", "url": "https://github.com/IBM/FHIR/commit/f087bc13f2f0a99a96524081ff12aa71daeb8d3a", "message": "issue #1402 support no hostname verification for cloud envs\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-01T17:36:09Z", "type": "commit"}, {"oid": "bb1d616d41ed3209c0809cb0921c829a045acae6", "url": "https://github.com/IBM/FHIR/commit/bb1d616d41ed3209c0809cb0921c829a045acae6", "message": "Merge remote-tracking branch 'origin/master' into robin-proto", "committedDate": "2020-09-01T17:37:56Z", "type": "commit"}, {"oid": "fef6d10ef68b6c35f9d3a7b8afa219e8eace26bd", "url": "https://github.com/IBM/FHIR/commit/fef6d10ef68b6c35f9d3a7b8afa219e8eace26bd", "message": "issue #1402 improved load management of large bundles and httpclient version now 4.5.12\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T12:57:33Z", "type": "commit"}, {"oid": "7e19b5c10a1f3f53a5d033079def9c91999d75b5", "url": "https://github.com/IBM/FHIR/commit/7e19b5c10a1f3f53a5d033079def9c91999d75b5", "message": "Merge remote-tracking branch 'origin/master' into robin-proto", "committedDate": "2020-09-04T12:59:19Z", "type": "commit"}, {"oid": "4bf31ea191348ce301e977956918a4d20a1a07e8", "url": "https://github.com/IBM/FHIR/commit/4bf31ea191348ce301e977956918a4d20a1a07e8", "message": "issue #1402 fhir-persistence-scout is experimental so removed from modules\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T13:07:57Z", "type": "commit"}, {"oid": "05b27fd00a2f45cd469c0fa570707d273be46cb9", "url": "https://github.com/IBM/FHIR/commit/05b27fd00a2f45cd469c0fa570707d273be46cb9", "message": "issue #1402 fixed Charset handling for Java 8\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T13:57:43Z", "type": "commit"}, {"oid": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "url": "https://github.com/IBM/FHIR/commit/d049d1228b4a41e37360ff28da2a2168f3df0e0f", "message": "issue #1402 fixed Charset handling for Java 8/11\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T14:56:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5MDc3Mw==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483690773", "bodyText": "no closing of the code element ```", "author": "prb112", "createdAt": "2020-09-04T15:29:08Z", "path": "fhir-bucket/README.md", "diffHunk": "@@ -0,0 +1,308 @@\n+## Synthetic Data Loader\n+Scans cloud object storage buckets and uploads data using the FHIR REST API\n+\n+### Background\n+\n+Synthea is a project for generating \"synthetic\" patient/population data for healthcare applications.\n+It generates realistic data based on census statistics and a lot of configuration.\n+It supports generating data in FHIR R4 \n+\n+This \"fhir-bucket\" project will help you upload Synthea-generated data to a FHIR R4 server.\n+\n+To facilitate high-volume load scenarios, multiple instances of the application can be run and their work coordinated so that each file is loaded exactly once.\n+\n+The loader records the identities of the created resources. These identities can be used in other test and load generator applications to access the data.\n+\n+### Steps\n+\n+1. Follow the steps at https://github.com/synthetichealth/synthea to clone and install Synthea\n+2. Configure Synthea to generate FHIR R4 resources\n+3. Generate a bunch of patients\n+4. Clone this repo and set it up with Maven/Eclipse\n+5. Configure the truststore with root certs required to trust connections to your FHIR server, cloud object store and tracking database\n+5. Tweak fhir.properties to point at your target FHIR server\n+6. Tweak cos.properties to point at your COS bucket\n+7. Tweak db.properties to point at your tracking database\n+8. Execute Main.class as described in the Running section below\n+\n+\n+### Configuration\n+\n+#### The cos.properties file\n+\n+```\n+# the IBM COS API key or S3 access key.\n+cos.api.key=\n+\n+# the IBM COS service instance id or S3 secret key.\n+cos.srvinstid=\n+\n+# the IBM COS or S3 End point URL.\n+cos.endpoint.url=\n+\n+# the IBM COS or S3 location.\n+cos.location=\n+\n+# the IBM COS or S3 bucket name to import from.\n+cos.bucket.name=\n+\n+# if use IBM credential(Y/N), default(Y).\n+cos.credential.ibm=Y\n+\n+# COS network timeouts\n+cos.request.timeout=60000\n+cos.socket.timeout=60000\n+\n+# The number of COS keys (items) to fetch per read\n+cos.max.keys=1000\n+```\n+\n+#### The db2.properties file\n+\n+```\n+db.host=<DB2-HOST-NAME>\n+db.port=<DB2-PORT>\n+db.database=<DB2-DATABASE>\n+user=<DB2-USER>\n+password=<DB2-PASSWORD>\n+sslConnection=true\n+sslTrustStoreLocation=/path/to/dbTruststore.p12\n+sslTrustStorePassword=<TRUSTSTORE-PASSWORD>\n+currentSchema=FHIRBUCKET\n+```\n+\n+#### The derby.properties file\n+\n+Db2 is the preferred database for hosting the fhir-bucket schema. Derby can, however, be used for development. The derby.properties file must be configured as follows:\n+\n+```\n+db.database=derby/bucketDB\n+db.create=Y\n+```\n+\n+\n+#### The postgres.properties file\n+\n+\n+\n+The name of the Derby database can be anything (without spaces) but must be contained within a folder called \"derby\".\n+\n+### Schema Deployment\n+\n+As a one-time activity, create the schema objects using the following command:\n+\n+```\n+#!/bin/bash\n+\n+JAR=\"~/git/FHIR/fhir-bucket/target/fhir-bucket-4.4.0-SNAPSHOT-cli.jar\"\n+\n+java -jar \"${JAR}\"               \\\n+  --db-type db2                  \\\n+  --db-properties db2.properties \\\n+  --create-schema\n+```\n+\n+If using a local Derby instance:\n+\n+```\n+#!/bin/bash\n+\n+JAR=\"~/git/FHIR/fhir-bucket/target/fhir-bucket-4.4.0-SNAPSHOT-cli.jar\"\n+\n+java -jar \"${JAR}\"                 \\\n+  --db-type derby                  \\\n+  --db-properties derby.properties \\\n+  --create-schema\n+```\n+\n+If using a local PostgreSQL instance:\n+\n+```\n+#!/bin/bash\n+\n+JAR=\"~/git/FHIR/fhir-bucket/target/fhir-bucket-4.4.0-SNAPSHOT-cli.jar\"\n+\n+java -jar \"${JAR}\"                    \\\n+  --db-type postgresql                \\\n+  --db-properties postgres.properties \\\n+  --create-schema\n+```\n+\n+This tracking database can be shared with the instance used by FHIR, but for proper performance testing it should be on a separate host. The standard schema for the tables is FHIRBUCKET.\n+\n+\n+### Running\n+\n+The following script can be used to run the bucket loader from a local build:\n+\n+```\n+#!/bin/bash\n+\n+JAR=\"~/git/FHIR/fhir-bucket/target/fhir-bucket-4.4.0-SNAPSHOT-cli.jar\"\n+\n+java -jar \"${JAR}\"                  \\\n+  --db-type db2                     \\\n+  --db-properties db2.properties    \\\n+  --cos-properties cos.properties   \\\n+  --fhir-properties fhir.properties \\\n+  --bucket example-bucket           \\\n+  --tenant-name example-tenant      \\\n+  --file-type NDJSON                \\\n+  --max-concurrent-fhir-requests 40 \\\n+  --max-concurrent-json-files 10    \\\n+  --max-concurrent-ndjson-files 1   \\\n+  --connection-pool-size 20         \\\n+  --incremental\n+```\n+\n+To run using Derby, change the relevant arguments to:\n+\n+```\n+...\n+  --db-type derby                   \\\n+  --db-properties derby.properties  \\\n+...\n+```\n+\n+To run using PostgreSQL, change the relevant arguments to:\n+\n+```\n+...\n+  --db-type postgresql                 \\\n+  --db-properties postgres.properties  \\\n+...\n+```\n+\n+| command-line options |\n+| ------- |\n+| `--incremental` </br> If the loader is stopped or fails before a bundle completes, the bundle will be reclaimed by another loader instance after the heartbeat timeout expires (60s). If the `--incremental` option is specified, the loader skips lines already processed in the NDJSON file. This is reasonably quick but is approximate, and may end up skipping rows due to threaded processing when the loader terminated. |\n+| `--incremental-exact` </br> the FHIRBUCKET tracking database is checked for every line in the NDJSON to see if any resources have been recorded for it, and if so, processing will be skipped. |\n+| `--db-type type` </br> where `type` is one of: db2, derby, postgresql. Specifies the type of database to use for the FHIRBUCKET tracking data. |\n+| `--db-properties properties-file` </br>  Connection properties file for the database |\n+| `--cos-properties properties-file` </br>  Connection properties file for COS | \n+| `--fhir-properties properties-file` </br> Connection properties file for the FHIR server |\n+| `--bucket cos-bucket-name` </br> The bucket name in COS |\n+| `--tenant-name fhir-tenant-name` </br> The IBM FHIR Server tenant name|\n+| `--file-type file-type` </br> One of: JSON, NDJSON. Used to limit the discovery scan to a particular type of file/entry |       \n+| `--max-concurrent-ndjson-files pool-size` </br> The maximum number of NDJSON files to read in parallel. Typically a small number, like the default which is 1. |\n+| `--max-concurrent-json-files pool-size` </br> The maximum number of JSON files to read in parallel. Each JSON file translates to a single FHIR request, which may be a single resource, or a bundle with many resources. |\n+| `--max-concurrent-fhir-requests pool-size` </br> The maximum number concurrent FHIR requests. For example, an NDJSON file may contain millions of records. Although a single NDJSON file is read sequentially, each resource (row) can be processed in parallel, up to this limit |\n+| `--connection-pool-size pool-size` </br> The maximum size of the database connection pool. Threads will block and wait if the current number of active connections exceeds this value |\n+| `--recycle-seconds seconds` </br> Artificially force discovered entries to be reloaded some time after they have been loaded successfully. This permits the loader to be set up in a continuous mode of operation, where the resource bundles are loaded over and over again, generating new resources to fill the target system with lots of data. The processing times for each load is tracked, so this can be used to look for regression.\n+| `--cos-scan-interval-ms millis` </br> The number of milliseconds to wait before scanning the COS bucket again to discover new entries |\n+| `--path-prefix prefix` </br> Limit the discovery scan to keys with the given prefix. |\n+| `--pool-shutdown-timeout-seconds seconds` </br> How many seconds to wait for the resource pool to shutdown when the loader has been asked to terminate. This value should be slightly longer than the Liberty transaction timeout.\n+| `--create-schema` </br> Creates a new or updates an existing database schema. The program will exit after the schema operations have completed.|\n+\n+\n+\n+\n+### Internals\n+\n+The purpose of fhir-bucket is to exercise the ingestion capability of the IBM FHIR Server (or any FHIR Server, for that matter). It scans IBM Cloud Object Store using the S3 connector and registers each matching entry in a tracking database.\n+\n+This tracking database is used to allocate these discovered entries (resource bundles) to loaders with free capacity. Several loader instances (JVMs) can be run in parallel and will coordinate their work using the common tracking database.\n+\n+When an instance of the fhir-bucket loader starts, it registers itself by creating a new entry in the loader_instances table. It periodically updates the heartbeat_tstamp of this record to publicize its liveness. Periodically, loader instances will perform a liveness check, looking for any other instances with an old heartbeat_tstamp. If the timestamp is considered too old, then the respective loader instance is considered to have failed. Any jobs it was running or had been assigned are cleared so that they can be picked up by another loader instance and hopefully completed successfully (see ClearStaleAllocations class).\n+\n+The COS scanner periodically scans COS to look for new items. It also checks each current item to see if the signature (size, modified time or etag hash) has changed. If a change is detected, the version number is incremented and any current allocation is cleared (recinded).\n+\n+The job allocation is performed by a thread in the `CosReader` class. This thread loops, asking the database to assign it new work when the loader has free capacity (see the AllocateJobs class). If the database assigns fewer jobs than the available capacity, this indicates we've run out of work to do so the loop will sleep for a short while before asking again so as not to overload the database.\n+\n+Each time a bundle is allocated to a loader for processing, a new record in RESOURCE_BUNDLE_LOADS is created. Any logical ids or errors generated during the processing of the bundle are recorded against the specific RESOURCE_BUNDLE_LOADS record. This permits tracking of multiple loads of the same bundle over time. The same bundle may be loaded multiple times if previous loads did not complete, or if recycling is enabled.\n+\n+Processing of files/entries from COS is performed with two thread pools. The first thread pool is used to parallelize the processing of individual files. This is useful when there are large numbers of files, e.g. one per patient.\n+\n+The second thread pool is used to process resources read from a file/entry. This is useful when the entries are NDJSON files which may contain millions of entries. The reader reads and validates each resource then submits the resource to the thread pool to parallelize the calls to FHIR.\n+\n+Limits are placed on the number of files/entries which can be allocated to a particular instance, as well as the number of resources which are currently inflight waiting to be processed. This is important to avoid unbounded memory growth. The goal is to keep the thread pool as busy as possible without consuming too much memory by reading and queueing too many resources (the assumption is that the fhir-bucket loader can read and validate resources more quickly than the FHIR server can process them).\n+\n+If the resource is a Bundle, then FHIR returns a bundle containing the newly assigned logical ids of every resource created from that bundle. Each of these logical ids is recorded in the LOGICAL_RESOURCES table in the tracking database.\n+\n+If the resource file/entry is not a Bundle, then FHIR returns the newly assigned logical id in the Location header. This value is also stored in the LOGICAL_RESOURCES table in the tracking database.\n+\n+\n+### Metrics\n+\n+The FHIRBUCKET schema tracks some useful statistics captured during the load runs which can be used to analyze performance.\n+\n+#### Schema\n+\n+| Table Name | Description |\n+| ---------- | ----------- |\n+| loader_instances | Each time a loader starts up it is allocated a unique loader_instances record |\n+| bucket_paths | The bucket name and item path up to the last / to avoid repeating the long path string for every item |\n+| resource_bundles | Represents a JSON or NDJSON file found in COS |\n+| resource_bundle_loads | Records each attempt to load a particular bundle |\n+| resource_bundle_errors | records errors by line. Includes HTTP response if available |\n+| resource_types | The FHIR model resource names |\n+| logical_resources | Holds the logical id for every resource created by the FHIR server |\n+\n+See the com.ibm.fhir.bucket.persistence.FhirBucketSchema class for details (columns and relationships) on the above tables.\n+\n+The `resource_bundle_loads` table contains timestamp fields marking the start and end of processing. The end time is only updated if the bundle is completed before the loader is stopped. \n+\n+Each `logical_resources` record contains a `created_tstamp` column which marks the time when the record was created in the FHIRBUCKET database.\n+\n+\n+\n+#### Db2 Analytic Queries\n+\n+To compute an approximate resources-per-second rate for each NDJSON bundle:\n+```\n+SET CURRENT SCHEMA FHIRBUCKET;\n+\n+SELECT loader_instance_id, substr(object_name, 1, 24) object_name, resource_type, resource_count, resource_count / run_seconds AS resources_per_second,\n+       timestampdiff(2, bundle_end - bundle_start) bundle_duration\n+  FROM (\n+       SELECT lr.loader_instance_id, resource_type_id, rb.object_name, count(*) AS resource_count,\n+              timestampdiff(2, max(lr.created_tstamp) - min(lr.created_tstamp)) run_seconds,\n+              min(rb.load_started) bundle_start,\n+              max(rb.load_completed) bundle_end\n+         FROM logical_resources lr,\n+              resource_bundles rb\n+        WHERE lr.loader_instance_id IS NOT NULL\n+          AND rb.resource_bundle_id = lr.resource_bundle_id\n+          AND rb.load_completed IS NOT NULL\n+     GROUP BY lr.loader_instance_id, resource_type_id, rb.object_name\n+     ) lr,\n+       resource_types rt\n+ WHERE rt.resource_type_id = lr.resource_type_id\n+   AND lr.run_seconds > 0\n+;\n+```\n+\n+The resource rate is calculated using the first and last creation timestamps from the logical_resources table.\n+\n+#### PostgreSQL Analytic Queries\n+\n+PostgreSQL uses a different mechanism for calculating the gap between two timestamps:\n+\n+```\n+SELECT abs(EXTRACT(EPOCH FROM end - start)) AS gap_in_seconds\n+  FROM ...\n+```\n+\n+The resource rate approximation query therefore becomes:\n+\n+```\n+SET search_path=FHIRBUCKET,PUBLIC;\n+\n+SELECT loader_instance_id, substr(object_name, 1, 24) object_name, resource_type, resource_count, resource_count / run_seconds AS resources_per_second,\n+       EXTRACT(EPOCH FROM bundle_end - bundle_start) AS bundle_duration\n+  FROM (\n+       SELECT lr.loader_instance_id, resource_type_id, rb.object_name, count(*) AS resource_count,\n+              EXTRACT(EPOCH FROM max(lr.created_tstamp) - min(lr.created_tstamp)) AS run_seconds,\n+              min(rb.load_started) bundle_start,\n+              max(rb.load_completed) bundle_end\n+         FROM logical_resources lr,\n+              resource_bundles rb\n+        WHERE lr.loader_instance_id IS NOT NULL\n+          AND rb.resource_bundle_id = lr.resource_bundle_id\n+          AND rb.load_completed IS NOT NULL\n+     GROUP BY lr.loader_instance_id, resource_type_id, rb.object_name\n+     ) lr,\n+       resource_types rt\n+ WHERE rt.resource_type_id = lr.resource_type_id\n+   AND lr.run_seconds > 0\n+;", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0MzE4NQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483743185", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T16:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5MDc3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0OTcwNg==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483749706", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5MDc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5MzI2OA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483693268", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            FROM xxxxx\n          \n          \n            \n            # ----------------------------------------------------------------------------\n          \n          \n            \n            # (C) Copyright IBM Corp. 2020\n          \n          \n            \n            #\n          \n          \n            \n            # SPDX-License-Identifier: Apache-2.0\n          \n          \n            \n            # ----------------------------------------------------------------------------\n          \n          \n            \n            FROM xxxxx", "author": "prb112", "createdAt": "2020-09-04T15:31:56Z", "path": "fhir-bucket/Dockerfile", "diffHunk": "@@ -0,0 +1,13 @@\n+FROM xxxxx", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5MzQ3OQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483693479", "bodyText": "any special meaning for xxxxx", "author": "prb112", "createdAt": "2020-09-04T15:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5MzI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0OTUzMQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483749531", "bodyText": "removed the file", "author": "punktilious", "createdAt": "2020-09-04T17:03:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5MzI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5NTUwMA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483695500", "bodyText": "small recommendation for future\n#!/usr/bin/env bash\nthis ensures the environment finds bash, it's not a guarantee on all systems that it is under /bin/bash (for example upcoming releases of macos)", "author": "prb112", "createdAt": "2020-09-04T15:34:25Z", "path": "fhir-bucket/README.md", "diffHunk": "@@ -0,0 +1,308 @@\n+## Synthetic Data Loader\n+Scans cloud object storage buckets and uploads data using the FHIR REST API\n+\n+### Background\n+\n+Synthea is a project for generating \"synthetic\" patient/population data for healthcare applications.\n+It generates realistic data based on census statistics and a lot of configuration.\n+It supports generating data in FHIR R4 \n+\n+This \"fhir-bucket\" project will help you upload Synthea-generated data to a FHIR R4 server.\n+\n+To facilitate high-volume load scenarios, multiple instances of the application can be run and their work coordinated so that each file is loaded exactly once.\n+\n+The loader records the identities of the created resources. These identities can be used in other test and load generator applications to access the data.\n+\n+### Steps\n+\n+1. Follow the steps at https://github.com/synthetichealth/synthea to clone and install Synthea\n+2. Configure Synthea to generate FHIR R4 resources\n+3. Generate a bunch of patients\n+4. Clone this repo and set it up with Maven/Eclipse\n+5. Configure the truststore with root certs required to trust connections to your FHIR server, cloud object store and tracking database\n+5. Tweak fhir.properties to point at your target FHIR server\n+6. Tweak cos.properties to point at your COS bucket\n+7. Tweak db.properties to point at your tracking database\n+8. Execute Main.class as described in the Running section below\n+\n+\n+### Configuration\n+\n+#### The cos.properties file\n+\n+```\n+# the IBM COS API key or S3 access key.\n+cos.api.key=\n+\n+# the IBM COS service instance id or S3 secret key.\n+cos.srvinstid=\n+\n+# the IBM COS or S3 End point URL.\n+cos.endpoint.url=\n+\n+# the IBM COS or S3 location.\n+cos.location=\n+\n+# the IBM COS or S3 bucket name to import from.\n+cos.bucket.name=\n+\n+# if use IBM credential(Y/N), default(Y).\n+cos.credential.ibm=Y\n+\n+# COS network timeouts\n+cos.request.timeout=60000\n+cos.socket.timeout=60000\n+\n+# The number of COS keys (items) to fetch per read\n+cos.max.keys=1000\n+```\n+\n+#### The db2.properties file\n+\n+```\n+db.host=<DB2-HOST-NAME>\n+db.port=<DB2-PORT>\n+db.database=<DB2-DATABASE>\n+user=<DB2-USER>\n+password=<DB2-PASSWORD>\n+sslConnection=true\n+sslTrustStoreLocation=/path/to/dbTruststore.p12\n+sslTrustStorePassword=<TRUSTSTORE-PASSWORD>\n+currentSchema=FHIRBUCKET\n+```\n+\n+#### The derby.properties file\n+\n+Db2 is the preferred database for hosting the fhir-bucket schema. Derby can, however, be used for development. The derby.properties file must be configured as follows:\n+\n+```\n+db.database=derby/bucketDB\n+db.create=Y\n+```\n+\n+\n+#### The postgres.properties file\n+\n+\n+\n+The name of the Derby database can be anything (without spaces) but must be contained within a folder called \"derby\".\n+\n+### Schema Deployment\n+\n+As a one-time activity, create the schema objects using the following command:\n+\n+```\n+#!/bin/bash", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0MjM4Nw==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483742387", "bodyText": "Indeed. Old habits.", "author": "punktilious", "createdAt": "2020-09-04T16:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5NTUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1MDU0Mw==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483750543", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5NTUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5OTk1Mg==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483699952", "bodyText": "build/security/asoc.sh\nplease update this file with -not -iname 'fhir-bucket-*-cli.jar'", "author": "prb112", "createdAt": "2020-09-04T15:39:14Z", "path": "fhir-bucket/pom.xml", "diffHunk": "@@ -0,0 +1,109 @@\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <artifactId>fhir-bucket</artifactId>", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0NTE3Mg==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483745172", "bodyText": "done", "author": "punktilious", "createdAt": "2020-09-04T16:53:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY5OTk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMTIwOQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483701209", "bodyText": "I suggest changing to fhir not fhir_dstu2", "author": "prb112", "createdAt": "2020-09-04T15:40:37Z", "path": "fhir-bucket/Dockerfile", "diffHunk": "@@ -0,0 +1,13 @@\n+FROM xxxxx\n+\n+COPY synthea-2.4.0-shaded.jar .\n+COPY target/synthea-uploader-0.0.1-SNAPSHOT-shaded.jar .\n+COPY cloudflare.truststore .\n+\n+RUN echo \"x.x.x.x   fhir-service\" >> /etc/hosts\n+\n+ENV LANG en_US.UTF-8\n+\n+RUN sed -i 's/override_install_langs=en_US.utf8/#override_install_langs=en_US.utf8/g' /etc/yum.conf\n+\n+CMD java -jar synthea-2.4.0-shaded.jar -p 1000 -o false && java -Djavax.net.ssl.trustStore=clientTruststore.jks -jar synthea-uploader-0.0.1-SNAPSHOT-shaded.jar output/fhir_dstu2/", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0MTc5MQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483741791", "bodyText": "actually the Dockerfile here isn't required at all. I'll remove it.", "author": "punktilious", "createdAt": "2020-09-04T16:45:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMTIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMTU3Ng==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483701576", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Constants for BulkExportImport.\n          \n          \n            \n             * Constants for FHIR Bucket.", "author": "prb112", "createdAt": "2020-09-04T15:40:59Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/api/Constants.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.bucket.api;\n+\n+/**\n+ * Constants for BulkExportImport.", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0NjA5Ng==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483746096", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T16:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMTU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMTgwMw==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483701803", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String DEFAULT_COS_BUCKETNAME = \"fhir-bulkImExport-Connectathon\";\n          \n          \n            \n                public static final String DEFAULT_COS_BUCKETNAME = \"fhir-bulkImExport-Connectathon\";\n          \n      \n    \n    \n  \n\nmaybe we drop this?", "author": "prb112", "createdAt": "2020-09-04T15:41:15Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/api/Constants.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.bucket.api;\n+\n+/**\n+ * Constants for BulkExportImport.\n+ *\n+ */\n+public class Constants {\n+\n+    public static final String DEFAULT_FHIR_TENANT = \"default\";\n+    public static final String DEFAULT_COS_BUCKETNAME = \"fhir-bulkImExport-Connectathon\";", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0NjM0NQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483746345", "bodyText": "definitely", "author": "punktilious", "createdAt": "2020-09-04T16:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMTgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwMzI0MQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483703241", "bodyText": "smart addition", "author": "prb112", "createdAt": "2020-09-04T15:42:56Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/client/FhirClient.java", "diffHunk": "@@ -0,0 +1,504 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.bucket.client;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyManagementException;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.NoHttpResponseException;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.UserTokenHandler;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpRequestBase;\n+import org.apache.http.config.Registry;\n+import org.apache.http.config.RegistryBuilder;\n+import org.apache.http.config.SocketConfig;\n+import org.apache.http.conn.ConnectionKeepAliveStrategy;\n+import org.apache.http.conn.socket.ConnectionSocketFactory;\n+import org.apache.http.conn.socket.PlainConnectionSocketFactory;\n+import org.apache.http.conn.ssl.NoopHostnameVerifier;\n+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.DefaultConnectionReuseStrategy;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.pool.PoolStats;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.ssl.SSLContextBuilder;\n+import org.apache.http.util.EntityUtils;\n+\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.parser.FHIRParser;\n+import com.ibm.fhir.model.parser.exception.FHIRParserException;\n+import com.ibm.fhir.model.resource.Resource;\n+\n+/**\n+ * Handles pooled HTTP/S connections to a FHIR server. Derived from the\n+ * former High Volume Ingestion Tool (HVIT) which is known to scale to\n+ * a large number of client connections.\n+ */\n+public class FhirClient {\n+\n+    private static final Logger logger = Logger.getLogger(FhirClient.class.getName());\n+    private static final String USER_AGENT = \"FHIR_BUCKET_LOADER\";", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNDkwMg==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483704902", "bodyText": "I think we have a setting that we can flip between FHIR and the RFC lastmodified.  In case you hit an issue with the format.", "author": "prb112", "createdAt": "2020-09-04T15:44:47Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/client/FhirClient.java", "diffHunk": "@@ -0,0 +1,504 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.bucket.client;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.StandardCharsets;\n+import java.security.KeyManagementException;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.Base64;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Function;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.SSLContext;\n+\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.HttpStatus;\n+import org.apache.http.NoHttpResponseException;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.UserTokenHandler;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.client.methods.HttpPost;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpRequestBase;\n+import org.apache.http.config.Registry;\n+import org.apache.http.config.RegistryBuilder;\n+import org.apache.http.config.SocketConfig;\n+import org.apache.http.conn.ConnectionKeepAliveStrategy;\n+import org.apache.http.conn.socket.ConnectionSocketFactory;\n+import org.apache.http.conn.socket.PlainConnectionSocketFactory;\n+import org.apache.http.conn.ssl.NoopHostnameVerifier;\n+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;\n+import org.apache.http.entity.ContentType;\n+import org.apache.http.entity.StringEntity;\n+import org.apache.http.impl.DefaultConnectionReuseStrategy;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;\n+import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n+import org.apache.http.pool.PoolStats;\n+import org.apache.http.protocol.HttpContext;\n+import org.apache.http.ssl.SSLContextBuilder;\n+import org.apache.http.util.EntityUtils;\n+\n+import com.ibm.fhir.database.utils.api.DataAccessException;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.parser.FHIRParser;\n+import com.ibm.fhir.model.parser.exception.FHIRParserException;\n+import com.ibm.fhir.model.resource.Resource;\n+\n+/**\n+ * Handles pooled HTTP/S connections to a FHIR server. Derived from the\n+ * former High Volume Ingestion Tool (HVIT) which is known to scale to\n+ * a large number of client connections.\n+ */\n+public class FhirClient {\n+\n+    private static final Logger logger = Logger.getLogger(FhirClient.class.getName());\n+    private static final String USER_AGENT = \"FHIR_BUCKET_LOADER\";\n+\n+    // Connection pool managing FHIR server HTTPS connections\n+    private PoolingHttpClientConnectionManager connManager;\n+    \n+    // HTTP client used to POST/PUT/GET FHIR server requests\n+    private CloseableHttpClient client;\n+    private String[] enabledCiphers;\n+\n+    // connection properties encapsulated in an adapter for easy access\n+    private final ClientPropertyAdapter propertyAdapter;\n+\n+    // The common headers we use which are shared across all threads\n+    private final Map<String,String> headers = new ConcurrentHashMap<String, String>();\n+    \n+    /**\n+     * Public constructor\n+     * @param cpa\n+     */\n+    public FhirClient(ClientPropertyAdapter cpa) {\n+        this.propertyAdapter = cpa;\n+    }\n+\n+    /**\n+     * Add the given key/value as a header\n+     * @param key\n+     * @param value\n+     */\n+    public void addHeader(String key, String value) {\n+        this.headers.put(key, value);\n+    }\n+    \n+    /**\n+     * Initialize the SSL connection pool after all the required field values have been injected\n+     */\n+    public void init(String tenantName) {\n+        if (connManager != null) {\n+            throw new IllegalStateException(\"Already initialied\");\n+        }\n+\n+        \n+        String enabledCiphersValue = propertyAdapter.getEnabledCiphers();\n+        if (enabledCiphersValue != null && !enabledCiphersValue.isEmpty()) {\n+            enabledCiphers = enabledCiphersValue.split(\",\");\n+        }\n+\n+        ConnectionKeepAliveStrategy connKeepAliveStrategy = new ConnectionKeepAliveStrategy() {\n+\n+            @Override\n+            public long getKeepAliveDuration(HttpResponse response, HttpContext context) {\n+                return 60000*60;\n+            }\n+        };\n+        \n+        try {\n+            // SSLContext sslContext = SSLContexts.custom().build();\n+            \n+            SSLContextBuilder sslContextBuilder = SSLContextBuilder.create();\n+            // sslContextBuilder.loadKeyMaterial(new File(keystoreFilename), keystorePass.toCharArray(), keyPass.toCharArray());\n+            sslContextBuilder.loadTrustMaterial(new File(propertyAdapter.getTruststore()), propertyAdapter.getTruststorePass().toCharArray());\n+            SSLContext sslContext = sslContextBuilder.build();\n+\n+            // For dev/test setups, allow connections to a FHIR server using a hostname\n+            // other than localhost\n+            HostnameVerifier hnv;\n+            if (propertyAdapter.isDisableHostnameVerification()) {\n+                hnv = new NoopHostnameVerifier();\n+            } else {\n+                hnv = SSLConnectionSocketFactory.getDefaultHostnameVerifier();\n+            }\n+            SSLConnectionSocketFactory factory = new SSLConnectionSocketFactory(sslContext, new String[]{\"TLSv1.2\"}, enabledCiphers, hnv);\n+\n+            Registry<ConnectionSocketFactory> registry = RegistryBuilder.<ConnectionSocketFactory>create()\n+                    .register(\"http\", PlainConnectionSocketFactory.getSocketFactory())\n+                    .register(\"https\",factory).build();\n+\n+            connManager = new PoolingHttpClientConnectionManager(registry);\n+            connManager.setMaxTotal(propertyAdapter.getPoolConnectionsMax());\n+            connManager.setDefaultMaxPerRoute(propertyAdapter.getPoolConnectionsMax());\n+            connManager.setValidateAfterInactivity(60000);\n+            connManager.setDefaultSocketConfig(SocketConfig.custom().build());\n+            \n+            client = obtainCloseableHttpClient(connKeepAliveStrategy);\n+        } \n+        catch (KeyManagementException e) {\n+            throw new IllegalStateException(\"Failed to initialize connection manager\", e);\n+        } \n+        catch (NoSuchAlgorithmException e) {\n+            throw new IllegalStateException(\"Failed to initialize connection manager\", e);\n+        }        \n+        catch (IOException x) {\n+            throw new IllegalStateException(\"Failed to initialize connection manager\", x);\n+        }\n+        catch (CertificateException x) {\n+            throw new IllegalStateException(\"Failed to initialize connection manager\", x);\n+        }\n+        catch (KeyStoreException x) {\n+            throw new IllegalStateException(\"Failed to initialize connection manager\", x);\n+        }\n+\n+        if (tenantName != null) {\n+            this.headers.put(Headers.TENANT_HEADER, tenantName);\n+        }\n+\n+        // For now, we only talk JSON with the FHIR server\n+        this.headers.put(Headers.ACCEPT_HEADER, ContentType.APPLICATION_JSON.getMimeType());\n+        this.headers.put(Headers.CONTENT_TYPE_HEADER, ContentType.APPLICATION_JSON.getMimeType());\n+        this.headers.put(\"Prefer\", \"return=representation\");\n+\n+        String user = propertyAdapter.getFhirServerUser();\n+        String pass = propertyAdapter.getFhirServerPass();\n+        if (user != null && pass != null) {\n+            // Set up basic auth\n+            String b64 = Base64.getEncoder().encodeToString(user.concat(\":\").concat(pass).getBytes());\n+            headers.put(Headers.AUTH_HEADER, \"Basic \".concat(b64));\n+        }\n+    }\n+    \n+    /**\n+     * Add our headers to the request\n+     * @param request\n+     */\n+    private void addHeadersTo(final HttpRequestBase request) {\n+        // inject each header into the request\n+        headers.entrySet().stream().forEach(e -> request.addHeader(e.getKey(), e.getValue())); \n+    }\n+    \n+    private String buildTargetPath(String resourceName) {\n+        StringBuilder result = new StringBuilder();\n+\n+        result.append(\"https://\");\n+        result.append(propertyAdapter.fhirServerHost());\n+        result.append(\":\");\n+        result.append(propertyAdapter.fhirServerPort());\n+        result.append(propertyAdapter.fhirServerEndpoint());\n+        \n+        if (resourceName != null) {\n+            result.append(resourceName);\n+        }\n+        \n+        return result.toString();\n+    }\n+    \n+    public FhirServerResponse get(String url, Function<Reader, Resource> fn) {\n+        \n+        String target = buildTargetPath(url);\n+        if (logger.isLoggable(Level.FINE)){\n+            logger.fine(\"REQUEST GET \"+ target);\n+        }\n+\n+        HttpGet getRequest = new HttpGet(target);\n+        addHeadersTo(getRequest);\n+        \n+        for (int i = 1; ; i++) {\n+            try {\n+                long startTime = System.nanoTime();\n+                HttpResponse response = client.execute(getRequest);\n+                if(logger.isLoggable(Level.FINE)){\n+                    Header responseHeaders[] = response.getAllHeaders();\n+                    \n+                    StringBuilder msg = new StringBuilder();\n+                    msg.append(\"Response HTTP Headers: \");\n+                    for (Header responseHeader : responseHeaders) {\n+                        msg.append(System.lineSeparator());\n+                        msg.append(\"\\t\" + responseHeader.getName() + \": \" + responseHeader.getValue());\n+                    }\n+                    logger.fine(msg.toString());\n+                }\n+                return buildResponse(response, startTime, true);\n+            } catch (NoHttpResponseException e) {\n+                logger.warning(\"Encountered an org.apache.http.NoHttpResponseException during GET request. \" + e);\n+                logger.warning(\"GET URL: \"+target);\n+                logger.warning(\"Will retry this request for the Nth time. N = \" + i);\n+            } catch (IOException e) {\n+                logger.severe(\"Error while executing the GET request. \" + e);\n+                logger.warning(\"GET URL: \"+target);\n+                logger.warning(\"Skipping this request.\");\n+                return null;\n+            }\n+        }        \n+    }\n+    \n+    /**\n+     * Issue a POST request at the given url\n+     * @param sUrl\n+     * @param body\n+     * @return\n+     */\n+    public FhirServerResponse post(String url, String body) {\n+        String target = buildTargetPath(url);\n+        if(logger.isLoggable(Level.FINE)) {\n+            logger.fine(\"REQUEST POST \"+ target);\n+        }\n+        \n+        try {\n+            HttpPost postRequest = new HttpPost(target);\n+            postRequest.setEntity(new StringEntity(body));\n+            addHeadersTo(postRequest);\n+            \n+            if(logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"REQUEST POST BODY - \" + body);\n+            }\n+            \n+            long startTime = System.currentTimeMillis();\n+            HttpResponse response = client.execute(postRequest);\n+            \n+            // Log details of the response if required\n+            if(logger.isLoggable(Level.FINE)) {\n+                Header responseHeaders[] = response.getAllHeaders();\n+                \n+                StringBuilder msg = new StringBuilder();\n+                msg.append(\"Response HTTP Headers: \");\n+                for (Header responseHeader : responseHeaders) {\n+                    msg.append(System.lineSeparator());\n+                    msg.append(\"\\t\" + responseHeader.getName() + \": \" + responseHeader.getValue());\n+                }\n+                logger.fine(msg.toString());\n+            }\n+\n+            // If we are posting a bundle, then we need to parse the response entity\n+            boolean isBundle = url.isEmpty();\n+            return buildResponse(response, startTime, isBundle);\n+            \n+        } catch (UnsupportedEncodingException e) {\n+            logger.severe(\"Can't encode json string into entity. \"+e);\n+            logger.warning(\"POST URL: \"+target+\"\\nRequest Body: \"+body);\n+            throw new IllegalStateException(\"FHIR client configuration error\");\n+        } catch (ClientProtocolException e) {\n+            logger.severe(\"Error while executing the POST request. \"+e);\n+            logger.warning(\"POST URL: \"+target+\"\\nRequest Body: \"+body);\n+            throw new DataAccessException(\"FHIR server connection failed\");\n+        } catch (IOException e) {\n+            logger.severe(\"Error while executing the POST request. \"+e);\n+            logger.warning(\"POST URL: \"+target+\"\\nRequest Body: \"+body);\n+            throw new DataAccessException(\"FHIR server connection failed\");\n+        }\n+    }\n+    \n+    public FhirServerResponse put(String url, Map<String, String> headers, String body) {\n+        String target = buildTargetPath(url);\n+\n+        if (logger.isLoggable(Level.FINE)) {\n+            logger.fine(\"REQUEST PUT \"+target);\n+        }\n+        \n+        try {\n+            HttpPut putRequest = new HttpPut(target);\n+            putRequest.setEntity(new StringEntity(body));\n+            addHeadersTo(putRequest);\n+            \n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"REQUEST PUT BODY - \" + body);\n+            }\n+            \n+            long startTime = System.currentTimeMillis();\n+            HttpResponse response = client.execute(putRequest);\n+            if (logger.isLoggable(Level.FINE)) {\n+                Header responseHeaders[] = response.getAllHeaders();\n+                logger.fine(\"Response HTTP Headers: \");\n+                for (Header responseHeader : responseHeaders) {\n+                    logger.fine(\"\\t\" + responseHeader.getName() + \": \" + responseHeader.getValue());\n+                }\n+            }\n+            return buildResponse(response, startTime, false);\n+            \n+        } catch (UnsupportedEncodingException e) {\n+            logger.severe(\"Can't encode json string into entity. \"+e);\n+            logger.warning(\"PUT URL: \"+target+\"\\nRequest Body: \"+body);\n+        } catch (ClientProtocolException e) {\n+            logger.severe(\"Error while executing the PUT request. \"+e);\n+            logger.warning(\"PUT URL: \"+target+\"\\nRequest Body: \"+body);\n+        } catch (IOException e) {\n+            logger.severe(\"Error while executing the PUT request. \"+e);\n+            logger.warning(\"PUT URL: \"+target+\"\\nRequest Body: \"+body);\n+        }\n+        \n+        return null;\n+    }\n+    \n+    public void shutdown() {\n+        if (client != null) {\n+            try {\n+                connManager.shutdown();\n+                client.close();\n+            } catch (IOException e) {\n+                throw new IllegalStateException(\"Unable to shutdown HTTP clients and Connection Manager successfully. \", e);\n+            }\n+        }\n+        \n+    }\n+\n+    /**\n+     * Get statistics from the internal HTTP connection manager\n+     * @return\n+     */\n+    public PoolStats getPoolInformation() {\n+        if (connManager != null) {\n+            return connManager.getTotalStats();\n+        } \n+        \n+        return null;\n+    }\n+\n+    /**\n+     * Construct a FhirServerResponse from the FHIR server {@link HttpResponse}\n+     * @param response\n+     * @param startTime\n+     * @return\n+     */\n+    private FhirServerResponse buildResponse(HttpResponse response, long startTime, boolean processResponseEntity) {\n+        FhirServerResponse sr = new FhirServerResponse();\n+        \n+        int status = response.getStatusLine().getStatusCode();\n+        sr.setStatusCode(status);\n+        sr.setStatusMessage(response.getStatusLine().getReasonPhrase());\n+\n+        HttpEntity entity = response.getEntity();\n+        try {\n+            if (status == HttpStatus.SC_OK || status == HttpStatus.SC_CREATED) {\n+                if (processResponseEntity) {\n+                    processEntity(sr, entity);\n+                } else if (response.getFirstHeader(\"Location\") != null) {\n+                    // Single resource case, no response body, just the URL returned in the Location header\n+                    sr.setLocationHeader(response.getFirstHeader(\"Location\").getValue());\n+                } else {\n+                    logger.warning(\"No body or Location header in response\");\n+                }\n+            } else if (status == HttpStatus.SC_BAD_REQUEST) {\n+                processOperationalOutcome(sr, entity);\n+            } else {\n+                logger.warning(\"Unexpected server response: \" + status + \" \" + response.getStatusLine().getReasonPhrase());\n+            }\n+        } finally {\n+            consume(entity);\n+            long endTime = System.nanoTime();\n+            sr.setResponseTime((int)(endTime-startTime));\n+        }\n+        \n+            // Last-Modified: 2018-11-26T05:07:00.954Z\n+            // TODO\n+//            Header lastModifiedHeader = response.getFirstHeader(\"Last-Modified\");\n+//            if (lastModifiedHeader != null) {\n+//                sr.setLastModified(TimeUtil.getFhirTime(lastModifiedHeader.getValue()));", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1MTg0NQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483751845", "bodyText": "I'm not using this at the moment, but noted for when I add this. Hopefully we have some utility code which already handles this, if not I create something.", "author": "punktilious", "createdAt": "2020-09-04T17:08:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNDkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwODg3MQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483708871", "bodyText": "I think I missed the intent of this class.  To be implemented?", "author": "prb112", "createdAt": "2020-09-04T15:51:56Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/scanner/DirectoryScanner.java", "diffHunk": "@@ -0,0 +1,10 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package com.ibm.fhir.bucket.scanner;\n+\n+public class DirectoryScanner {", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1Mjg2OQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483752869", "bodyText": "An artifact of my brain as I was thinking how best to scan through the COS tree (wondering if we might need to parallelize scanning of different branches of the tree). Not needed, so I'll remove.", "author": "punktilious", "createdAt": "2020-09-04T17:10:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwODg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwOTUyNA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483709524", "bodyText": "useful or extraneous now?", "author": "prb112", "createdAt": "2020-09-04T15:53:01Z", "path": "fhir-bucket/src/main/java/com/ibm/fhir/bucket/scanner/ResourceHandler.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.bucket.scanner;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import org.apache.http.HttpStatus;\n+\n+import com.ibm.fhir.bucket.api.ResourceBundleError;\n+import com.ibm.fhir.bucket.api.ResourceEntry;\n+import com.ibm.fhir.bucket.api.ResourceIdValue;\n+import com.ibm.fhir.bucket.client.FhirClient;\n+import com.ibm.fhir.bucket.client.FhirServerResponse;\n+import com.ibm.fhir.bucket.client.PostResource;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.generator.FHIRGenerator;\n+import com.ibm.fhir.model.generator.exception.FHIRGeneratorException;\n+import com.ibm.fhir.model.resource.Bundle;\n+import com.ibm.fhir.model.resource.Bundle.Entry.Response;\n+import com.ibm.fhir.model.resource.Resource;\n+\n+/**\n+ * Calls the FHIR REST API to create resources, supported by a thread pool\n+ */\n+public class ResourceHandler {\n+    private static final Logger logger = Logger.getLogger(ResourceHandler.class.getName());\n+    private static final int BATCH_SIZE = 200;\n+    \n+    // Nanos in a millisecond\n+    private static final long NANOS_MS = 1000000;\n+\n+    // The number of concurrent FHIR requests we allow\n+    private final int maxConcurrentFhirRequests;\n+    \n+    // The thread pool\n+    private final ExecutorService pool;\n+\n+    // Client for making FHIR server requests\n+    private final FhirClient fhirClient;\n+    \n+    // flow control so we don't overload the thread pool queue\n+    private final Lock lock = new ReentrantLock();\n+    private final Condition capacityCondition = lock.newCondition();\n+    \n+    // how many resources are currently queued or being processed\n+    private int inflight;\n+    \n+    // flag used to handle shutdown\n+    private volatile boolean running = true;\n+\n+    // Access to the FHIR bucket persistence layer to record logical ids\n+    private final DataAccess dataAccess;\n+    \n+    /**\n+     * Public constructor\n+     * @param poolSize\n+     */\n+    public ResourceHandler(ExecutorService commonPool, int maxConcurrentFhirRequests, FhirClient fc, DataAccess dataAccess) {\n+        this.maxConcurrentFhirRequests = maxConcurrentFhirRequests;\n+        this.fhirClient = fc;\n+        this.pool = commonPool;\n+        this.dataAccess = dataAccess;\n+    }\n+\n+    /**\n+     * Tell the ResourceHandler to shut down processing\n+     */\n+    public void signalStop() {\n+        if (running) {\n+            logger.info(\"Shutting down resource handler\");\n+            this.running = false;\n+        }\n+        \n+        // Wake up anything which may be blocked\n+        lock.lock();\n+        try {\n+            capacityCondition.signalAll();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+    \n+    /**\n+     * Shut down all resource processing\n+     */\n+    public void waitForStop() {\n+        signalStop();\n+        \n+        // We don't own the pool, so we don't wait for it to shut down\n+    }\n+\n+    /**\n+     * Add the resource entry to the thread-pool for processing, subject to the\n+     * rate limiting we have to make sure memory consumption is kept in check\n+     * @param entry\n+     * @return\n+     */\n+    public boolean process(ResourceEntry entry) {\n+        boolean result = false;\n+\n+        lock.lock();\n+        try {\n+            while (running && inflight >= maxConcurrentFhirRequests) {\n+                capacityCondition.await();\n+            }\n+            \n+            if (running) {\n+                inflight += entry.getCost(); // Grab the capacity while we're locked\n+                entry.getJob().addEntry(); // Add to row count so we can track when the job completes\n+                result = true;\n+            }\n+        } catch (InterruptedException x) {\n+            logger.info(\"Interrupted while waiting for capacity\");\n+        }\n+        finally {\n+            lock.unlock();\n+        }\n+\n+        // only submit to the pool if we have permission\n+        if (running && result) {\n+            pool.submit(() -> {\n+                try {\n+                    processThr(entry);\n+                } catch (Exception x) {\n+                    // don't let exceptions propagate to the thread-pool\n+                    logger.log(Level.SEVERE, entry.toString(), x);\n+                } finally {\n+                    lock.lock();\n+                    try {\n+                        // Free up the capacity consumed by this entry\n+                        inflight -= entry.getCost();\n+                        capacityCondition.signalAll();\n+                    } finally {\n+                        lock.unlock();\n+                    }\n+                }\n+            });\n+        }\n+        \n+        return result;\n+    }\n+    \n+    /**\n+     * Process the resource in the thread pool\n+     * @param resource\n+     */\n+    public void processThr(ResourceEntry re) {\n+        \n+        boolean success = false;\n+        try {\n+            Resource resource = re.getResource();\n+            final String resourceType = resource.getClass().getSimpleName();\n+            if (logger.isLoggable(Level.FINE)) {\n+                logger.fine(\"Processing resource: \" + resourceType);\n+            }\n+            \n+            // Build a post request for the resource and send to FHIR\n+            long start = System.nanoTime();\n+            PostResource post = new PostResource(resource);\n+            FhirServerResponse response = post.run(fhirClient);\n+            long end = System.nanoTime();\n+            switch (response.getStatusCode()) {\n+            case HttpStatus.SC_OK:\n+            case HttpStatus.SC_CREATED:\n+                String locn = response.getLocationHeader();\n+                if (response.getResource() != null) {\n+                    // Process the response bundle\n+                    success = processResponseResource(re, response.getResource());\n+                } else if (locn != null) {\n+                    if (locn.startsWith(\"https://\")) {\n+                        // the response was empty, so in this case we need to extract the id from\n+                        // the location header\n+                        int responseTimeMs = (int)((end - start) / NANOS_MS);\n+                        success = processLocation(re, locn, responseTimeMs);\n+                    } else {\n+                        logger.warning(\"FHIR bad location format [\" + re.toString() + \"]: \" + \n+                                locn);\n+                    }\n+                    \n+                } else {\n+                    logger.warning(\"FHIR request id not found [\" + re.toString() + \"]: \" + \n+                            response.getStatusCode() + \" \" + response.getStatusMessage());\n+                }\n+                break;\n+            default:\n+                logger.warning(\"FHIR request failed [\" + re.toString() + \"]: \" + \n+                        response.getStatusCode() + \" \" + response.getStatusMessage());\n+                processBadRequest(re, response);\n+                break;\n+            }\n+        } catch (Throwable x) {\n+            // don't let any exceptions propagate into the thread pool\n+            logger.log(Level.SEVERE, re.toString(), x);\n+        } finally {\n+            // Signal the processing is complete for this entry\n+            re.getJob().operationComplete(success);\n+        }\n+    }\n+\n+    /**\n+     * Process the bundle we received in the FHIR POST response to extract all the ids\n+     * Synthetic example:\n+        {           \n+            \"entry\": [\n+                {\n+                    \"response\": {\n+                        \"etag\": \"W/\\\"1\\\"\",\n+                        \"id\": \"1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309\",\n+                        \"lastModified\": \"2020-08-20T17:22:12.554128Z\",\n+                        \"location\": \"Patient/1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309/_history/1\",\n+                        \"status\": \"201\"\n+                    }\n+                },\n+                {\n+                    \"response\": {\n+                        \"etag\": \"W/\\\"1\\\"\",\n+                        \"id\": \"1740ce47574-fb9b6b7e-15a4-4abc-bc33-f6b4fdb3d1e3\",\n+                        \"lastModified\": \"2020-08-20T17:22:12.980788Z\",\n+                        \"location\": \"Organization/1740ce47574-fb9b6b7e-15a4-4abc-bc33-f6b4fdb3d1e3/_history/1\",\n+                        \"status\": \"201\"\n+                    }\n+                },\n+                ...\n+            ],  \n+            \"resourceType\": \"Bundle\",\n+            \"type\": \"transaction-response\"\n+        }\n+     * \n+     * @param bundle\n+     * @return\n+     */\n+    private boolean processResponseResource(ResourceEntry re, Resource resource) {\n+        boolean result;\n+        \n+        if (Bundle.class.isAssignableFrom(resource.getClass())) {\n+            Bundle bundle = resource.as(Bundle.class);\n+            result = processResponseBundle(re, bundle);\n+        } else {\n+            logger.severe(\"Resource is not a bundle. Skipping: \" + resource.getClass().getSimpleName());\n+            result = false;\n+        }\n+        \n+        \n+        return result;\n+    }\n+    \n+    private boolean processResponseBundle(ResourceEntry re, Bundle bundle) {\n+        \n+        // Extract the location from every entry in the bundle. Collect them\n+        // together so that we can make a single batch insert into the database\n+        // which is going to be a lot more efficient than individual inserts\n+        List<ResourceIdValue> idValues = new ArrayList<>();\n+        for (Bundle.Entry entry: bundle.getEntry()) {\n+            Response response = entry.getResponse();\n+            if (response != null) {\n+                if (response.getLocation() != null && response.getLocation().getValue() != null) {\n+                    String locn = response.getLocation().getValue();\n+                    logger.info(\"New resource: \" + locn);\n+                    ResourceIdValue rid = getResourceIdValue(locn);\n+                    if (rid != null) {\n+                        idValues.add(rid);\n+                    }\n+                }\n+            }\n+        }\n+\n+        processResourceIdValues(re, idValues);\n+        return idValues.size() > 0;\n+    }\n+\n+    /**\n+     * Process the list of resource ids as a batch\n+     * @param re\n+     * @param idValues\n+     * @return\n+     */\n+    private void processResourceIdValues(ResourceEntry re, List<ResourceIdValue> idValues) {\n+        dataAccess.recordLogicalIds(re.getJob().getResourceBundleLoadId(), re.getLineNumber(), idValues, BATCH_SIZE);\n+    }\n+    /**\n+     * Parse the location to create a {@link ResourceIdValue} DTO object.\n+     * The location can take one of two forms:\n+     *   \"Patient/1740ce473c9-aecca6ca-6824-44a0-a8d8-4cfd230e0309/_history/1\"\n+     *   \"https://localhost:9443/fhir-server/api/v4/DiagnosticReport/173eed87a99-605de23b-266d-4b4d-b64f-31e769fda112/_history/1\"\n+     * @param location\n+     * @return\n+     */\n+    private ResourceIdValue getResourceIdValue(String location) {\n+        ResourceIdValue result;\n+    \n+        String[] parts = location.split(\"/\");\n+        if (parts.length == 10) {\n+            String resourceType = parts[6];\n+            String id = parts[7];\n+            result = new ResourceIdValue(resourceType, id);\n+        } else if (parts.length == 4) {\n+            String resourceType = parts[0];\n+            String id = parts[1];\n+            result = new ResourceIdValue(resourceType, id);\n+        } else {\n+            result = null;\n+        }\n+        \n+        return result;\n+    }\n+    \n+    private boolean processLocation(ResourceEntry re, String location, int responseTimeMs) {\n+        boolean result = false;\n+        // the response was empty, so in this case we need to extract the id from\n+        // the location header, which means cracking the string into parts:\n+        // https://localhost:9443/fhir-server/api/v4/DiagnosticReport/173eed87a99-605de23b-266d-4b4d-b64f-31e769fda112/_history/1\n+        String[] parts = location.split(\"/\");\n+        if (parts.length == 10) {\n+            String resourceType = parts[6];\n+            String id = parts[7];\n+            logger.info(\"[\" +re.toString() + \"] new \" + resourceType + \"/\" + id + \" [took \" + responseTimeMs + \" ms]\");\n+            dataAccess.recordLogicalId(resourceType, id, re.getJob().getResourceBundleLoadId(), re.getLineNumber(), responseTimeMs);\n+            result = true;\n+        }\n+        \n+        return result;\n+    }\n+\n+    /**\n+     * Record the error in the database\n+     * @param re\n+     * @param response\n+     */\n+    protected void processBadRequest(ResourceEntry re, FhirServerResponse response) {\n+        \n+        if (logger.isLoggable(Level.FINE)) {\n+            // dump the resource and full operational outcome to the log\n+            logger.fine(re.getJob().getObjectKey() + \"[\" + re.getLineNumber() + \"]: \"\n+                + resourceToString(re.getResource()));\n+            logger.fine(re.getJob().getObjectKey() + \"[\" + re.getLineNumber() + \"]: \"\n+                + response.getOperationalOutcomeText());\n+        }\n+        \n+        List<ResourceBundleError> errors = new ArrayList<>();\n+        errors.add(new ResourceBundleError(re.getLineNumber(), response.getOperationalOutcomeText(), \n+            response.getResponseTime(), response.getStatusCode(), response.getStatusMessage()));\n+        \n+        dataAccess.recordErrors(re.getJob().getResourceBundleLoadId(), re.getLineNumber(), errors);\n+    }\n+\n+    /**\n+     * Render the resource as a string (for logging)\n+     * @param resource\n+     * @return\n+     */\n+    private String resourceToString(Resource resource) {\n+        ByteArrayOutputStream os = new ByteArrayOutputStream(4096);\n+        try {\n+            FHIRGenerator.generator(Format.JSON, false).generate(resource, os);\n+            return new String(os.toByteArray(), StandardCharsets.UTF_8);\n+        } catch (FHIRGeneratorException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    /**\n+     * \n+     */\n+    public void init() {\n+    }", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NDc4MQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483754781", "bodyText": "My style. I tend to have init() methods on major classes to support initialization after dependencies have been injected. But in this case, everything gets set up in the constructor, so we're not really injecting anything. I'll leave for now, but may remove if it's really not useful next time I'm refactoring.", "author": "punktilious", "createdAt": "2020-09-04T17:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwOTUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMDA5Mg==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483710092", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            SET CURRENT SCHEMA FHIRBUCKET;\n          \n          \n            \n            -------------------------------------------------------------------------------\n          \n          \n            \n            -- (C) Copyright IBM Corp. 2020\n          \n          \n            \n            --\n          \n          \n            \n            -- SPDX-License-Identifier: Apache-2.0\n          \n          \n            \n            -------------------------------------------------------------------------------\n          \n          \n            \n             SET CURRENT SCHEMA FHIRBUCKET;", "author": "prb112", "createdAt": "2020-09-04T15:54:06Z", "path": "fhir-bucket/src/main/resources/stats/bundle_rate.sql", "diffHunk": "@@ -0,0 +1,20 @@\n+SET CURRENT SCHEMA FHIRBUCKET;", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NTY0OQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483755649", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:17:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMDA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMDQ3MA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483710470", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            select e.line_number, e.http_status_code, e.http_status_text\n          \n          \n            \n            -------------------------------------------------------------------------------\n          \n          \n            \n            -- (C) Copyright IBM Corp. 2020\n          \n          \n            \n            --\n          \n          \n            \n            -- SPDX-License-Identifier: Apache-2.0\n          \n          \n            \n            -------------------------------------------------------------------------------\n          \n          \n            \n            select e.line_number, e.http_status_code, e.http_status_text", "author": "prb112", "createdAt": "2020-09-04T15:54:45Z", "path": "fhir-bucket/src/main/resources/stats/get_errors.sql", "diffHunk": "@@ -0,0 +1,8 @@\n+select e.line_number, e.http_status_code, e.http_status_text", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NzQ3Mw==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483757473", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMDQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMDU1Ng==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483710556", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            SET CURRENT SCHEMA FHIRBUCKET;\n          \n          \n            \n            -------------------------------------------------------------------------------\n          \n          \n            \n            -- (C) Copyright IBM Corp. 2020\n          \n          \n            \n            --\n          \n          \n            \n            -- SPDX-License-Identifier: Apache-2.0\n          \n          \n            \n            -------------------------------------------------------------------------------\n          \n          \n            \n            SET CURRENT SCHEMA FHIRBUCKET;", "author": "prb112", "createdAt": "2020-09-04T15:54:57Z", "path": "fhir-bucket/src/main/resources/stats/stats.sql", "diffHunk": "@@ -0,0 +1,14 @@\n+SET CURRENT SCHEMA FHIRBUCKET;", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NTY5MA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483755690", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzEyOQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483713129", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.watson.health.fhir.persistence.FHIRPersistenceFactory#getInstance()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-09-04T15:59:45Z", "path": "fhir-persistence-scout/src/main/java/com/ibm/fhir/persistence/scout/FHIRPersistenceScoutFactory.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scout;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceNotSupportedException;\n+\n+/**\n+ * Factory for creating FHIRPersistence instances using Cloudant as the underlying\n+ * datastore.\n+ * @author rarnold\n+ *\n+ */\n+public class FHIRPersistenceScoutFactory implements FHIRPersistenceFactory {\n+    private static final Logger logger = Logger.getLogger(FHIRPersistenceScoutFactory.class.getName());\n+    \n+    /* (non-Javadoc)\n+     * @see com.ibm.watson.health.fhir.persistence.FHIRPersistenceFactory#getInstance()\n+     */", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0OTEyOQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483749129", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzEyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzE5NA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483713194", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @author rarnold", "author": "prb112", "createdAt": "2020-09-04T15:59:53Z", "path": "fhir-persistence-scout/src/main/java/com/ibm/fhir/persistence/scout/FHIRPersistenceScoutFactory.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * (C) Copyright IBM Corp. 2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scout;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceFactory;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceNotSupportedException;\n+\n+/**\n+ * Factory for creating FHIRPersistence instances using Cloudant as the underlying\n+ * datastore.\n+ * @author rarnold", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0ODM2NQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483748365", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzM2MA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483713360", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @author Robin Arnold", "author": "prb112", "createdAt": "2020-09-04T16:00:11Z", "path": "fhir-persistence-scout/src/main/java/com/ibm/fhir/persistence/scout/FHIRPersistenceScoutImpl.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * (C) Copyright IBM Corp. 2017,2018,2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scout;\n+\n+import static com.ibm.fhir.config.FHIRConfiguration.PROPERTY_UPDATE_CREATE_ENABLED;\n+import static com.ibm.fhir.model.type.String.string;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.text.MessageFormat;\n+import java.time.ZoneOffset;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.Map.Entry;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.datastax.oss.driver.api.core.CqlSession;\n+import com.datastax.oss.driver.api.core.CqlSessionBuilder;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.core.FHIRUtilities;\n+import com.ibm.fhir.database.utils.common.GetSequenceNextValueDAO;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.generator.FHIRGenerator;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.resource.SearchParameter;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.SearchParameter.Component;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Element;\n+import com.ibm.fhir.model.type.Id;\n+import com.ibm.fhir.model.type.Instant;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.SearchParamType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.visitor.Visitable;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.FHIRPathSystemValue;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.MultiResourceResult;\n+import com.ibm.fhir.persistence.SingleResourceResult;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.scout.SearchParameters;\n+import com.ibm.fhir.persistence.scout.SearchParameters.ParameterBlock;\n+import com.ibm.fhir.persistence.scout.SearchParameters.StrValue;\n+import com.ibm.fhir.persistence.scout.SearchParameters.StrValueList;\n+import com.ibm.fhir.persistence.scout.SearchParameters.TokenValue;\n+import com.ibm.fhir.persistence.scout.SearchParameters.TokenValueList;\n+import com.ibm.fhir.persistence.scout.cql.DatasourceSessions;\n+import com.ibm.fhir.search.SearchConstants.Type;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.date.DateTimeHandler;\n+import com.ibm.fhir.search.util.SearchUtil;\n+\n+/**\n+ * Scalable persistence layer, storing resources in Cassandra and the corresponding\n+ * indexes in Redis.\n+ * @author Robin Arnold", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NTc3MA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483755770", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:17:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzQ2NA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483713464", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                /* (non-Javadoc)\n          \n          \n            \n                 * @see com.ibm.fhir.persistence.FHIRPersistence#isDeleteSupported()\n          \n          \n            \n                 */", "author": "prb112", "createdAt": "2020-09-04T16:00:23Z", "path": "fhir-persistence-scout/src/main/java/com/ibm/fhir/persistence/scout/FHIRPersistenceScoutImpl.java", "diffHunk": "@@ -0,0 +1,471 @@\n+/**\n+ * (C) Copyright IBM Corp. 2017,2018,2019\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scout;\n+\n+import static com.ibm.fhir.config.FHIRConfiguration.PROPERTY_UPDATE_CREATE_ENABLED;\n+import static com.ibm.fhir.model.type.String.string;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.URL;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.sql.Timestamp;\n+import java.text.MessageFormat;\n+import java.time.ZoneOffset;\n+import java.time.temporal.TemporalAccessor;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.UUID;\n+import java.util.Map.Entry;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+import java.util.zip.GZIPOutputStream;\n+\n+import javax.transaction.TransactionSynchronizationRegistry;\n+\n+import com.datastax.oss.driver.api.core.CqlSession;\n+import com.datastax.oss.driver.api.core.CqlSessionBuilder;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.ibm.fhir.config.FHIRConfigHelper;\n+import com.ibm.fhir.config.FHIRConfiguration;\n+import com.ibm.fhir.config.FHIRRequestContext;\n+import com.ibm.fhir.config.PropertyGroup;\n+import com.ibm.fhir.core.FHIRUtilities;\n+import com.ibm.fhir.database.utils.common.GetSequenceNextValueDAO;\n+import com.ibm.fhir.model.format.Format;\n+import com.ibm.fhir.model.generator.FHIRGenerator;\n+import com.ibm.fhir.model.resource.OperationOutcome;\n+import com.ibm.fhir.model.resource.Resource;\n+import com.ibm.fhir.model.resource.SearchParameter;\n+import com.ibm.fhir.model.resource.OperationOutcome.Issue;\n+import com.ibm.fhir.model.resource.SearchParameter.Component;\n+import com.ibm.fhir.model.type.CodeableConcept;\n+import com.ibm.fhir.model.type.Element;\n+import com.ibm.fhir.model.type.Id;\n+import com.ibm.fhir.model.type.Instant;\n+import com.ibm.fhir.model.type.Meta;\n+import com.ibm.fhir.model.type.code.IssueSeverity;\n+import com.ibm.fhir.model.type.code.IssueType;\n+import com.ibm.fhir.model.type.code.SearchParamType;\n+import com.ibm.fhir.model.util.FHIRUtil;\n+import com.ibm.fhir.model.visitor.Visitable;\n+import com.ibm.fhir.path.FHIRPathNode;\n+import com.ibm.fhir.path.FHIRPathSystemValue;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator;\n+import com.ibm.fhir.path.evaluator.FHIRPathEvaluator.EvaluationContext;\n+import com.ibm.fhir.persistence.FHIRPersistence;\n+import com.ibm.fhir.persistence.FHIRPersistenceTransaction;\n+import com.ibm.fhir.persistence.MultiResourceResult;\n+import com.ibm.fhir.persistence.SingleResourceResult;\n+import com.ibm.fhir.persistence.context.FHIRPersistenceContext;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceException;\n+import com.ibm.fhir.persistence.exception.FHIRPersistenceResourceDeletedException;\n+import com.ibm.fhir.persistence.scout.SearchParameters;\n+import com.ibm.fhir.persistence.scout.SearchParameters.ParameterBlock;\n+import com.ibm.fhir.persistence.scout.SearchParameters.StrValue;\n+import com.ibm.fhir.persistence.scout.SearchParameters.StrValueList;\n+import com.ibm.fhir.persistence.scout.SearchParameters.TokenValue;\n+import com.ibm.fhir.persistence.scout.SearchParameters.TokenValueList;\n+import com.ibm.fhir.persistence.scout.cql.DatasourceSessions;\n+import com.ibm.fhir.search.SearchConstants.Type;\n+import com.ibm.fhir.search.context.FHIRSearchContext;\n+import com.ibm.fhir.search.date.DateTimeHandler;\n+import com.ibm.fhir.search.util.SearchUtil;\n+\n+/**\n+ * Scalable persistence layer, storing resources in Cassandra and the corresponding\n+ * indexes in Redis.\n+ * @author Robin Arnold\n+ */\n+public class FHIRPersistenceScoutImpl implements FHIRPersistence {\n+    private static final Logger logger = Logger.getLogger(FHIRPersistenceScoutImpl.class.getName());\n+    private static final String CLASSNAME = FHIRPersistenceScoutImpl.class.getName();\n+    private static final Logger log = Logger.getLogger(CLASSNAME);\n+        \n+    public static final String TRX_SYNCH_REG_JNDI_NAME = \"java:comp/TransactionSynchronizationRegistry\";\n+    \n+    // TODO. Shouldn't be necessary\n+    private static final int MAX_NUM_OF_COMPOSITE_COMPONENTS = 3;\n+    \n+    private TransactionSynchronizationRegistry trxSynchRegistry;\n+    \n+    private boolean updateCreateEnabled;\n+    \n+    private List<OperationOutcome.Issue> supplementalIssues = new ArrayList<>();\n+    \n+\n+    /**\n+     * Constructor for use when running as web application in WLP. \n+     * @throws Exception \n+     */\n+    public FHIRPersistenceScoutImpl() throws Exception {\n+        super();\n+        final String METHODNAME = \"FHIRPersistenceCloudantImpl()\";\n+        log.entering(CLASSNAME, METHODNAME);\n+        \n+        PropertyGroup fhirConfig = FHIRConfiguration.getInstance().loadConfiguration();\n+        this.updateCreateEnabled = fhirConfig.getBooleanProperty(PROPERTY_UPDATE_CREATE_ENABLED, Boolean.TRUE);\n+        log.exiting(CLASSNAME, METHODNAME);\n+    }\n+    \n+    /**\n+     * Constructor for use when running standalone, outside of any web container.\n+     * @throws Exception \n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    public FHIRPersistenceScoutImpl(Properties configProps) throws Exception {\n+        final String METHODNAME = \"FHIRPersistenceCloudantImpl(Properties)\";\n+        log.entering(CLASSNAME, METHODNAME);\n+        \n+        this.updateCreateEnabled = Boolean.parseBoolean(configProps.getProperty(\"updateCreateEnabled\"));\n+        \n+        log.exiting(CLASSNAME, METHODNAME);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see com.ibm.fhir.persistence.FHIRPersistence#isDeleteSupported()\n+     */", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NTg0OA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483755848", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxMzQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNzAxNQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483717015", "bodyText": "Update in the code for the future? marking just to confirm", "author": "prb112", "createdAt": "2020-09-04T16:07:23Z", "path": "fhir-persistence-scout/src/main/java/com/ibm/fhir/persistence/scout/cql/InsertParameterBlock.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scout.cql;\n+\n+import com.datastax.oss.driver.api.core.CqlSession;\n+import com.ibm.fhir.persistence.scout.SearchParameters.ParameterBlock;\n+\n+/**\n+ * CQL command to insert the parameter block using the resource logical id as the key\n+ */\n+public class InsertParameterBlock {\n+    \n+    private final ParameterBlock parameterBlock;\n+    private final byte[] payload;\n+    \n+    public InsertParameterBlock(ParameterBlock pb, byte[] payload) {\n+        this.parameterBlock = pb;\n+        this.payload = payload;\n+    }\n+\n+    /**\n+     * Run the command against the given session\n+     * @param s\n+     */\n+    public void run(CqlSession s) {\n+        ", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NjE2NA==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483756164", "bodyText": "Yes, this is a work in progress, but sharing to give others visibility.", "author": "punktilious", "createdAt": "2020-09-04T17:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNzAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNzk3Mw==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483717973", "bodyText": "should we add a copyright here?", "author": "prb112", "createdAt": "2020-09-04T16:09:26Z", "path": "fhir-persistence-scout/src/main/protobuf/SearchParameters.proto", "diffHunk": "@@ -0,0 +1,91 @@\n+syntax = \"proto3\";", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NjY5Mg==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483756692", "bodyText": "fixed", "author": "punktilious", "createdAt": "2020-09-04T17:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNzk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxODEyMQ==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483718121", "bodyText": "no op?", "author": "prb112", "createdAt": "2020-09-04T16:09:43Z", "path": "fhir-persistence-scout/src/test/java/com/ibm/fhir/persistence/scale/test/ConfigTest.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * (C) Copyright IBM Corp. 2020\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package com.ibm.fhir.persistence.scale.test;\n+\n+import org.testng.annotations.Test;\n+\n+/**\n+ *\n+ */\n+public class ConfigTest {\n+\n+    @Test\n+    public void test1() {\n+        ", "originalCommit": "d049d1228b4a41e37360ff28da2a2168f3df0e0f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NjQ2Mw==", "url": "https://github.com/IBM/FHIR/pull/1476#discussion_r483756463", "bodyText": "work in progress", "author": "punktilious", "createdAt": "2020-09-04T17:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxODEyMQ=="}], "type": "inlineReview"}, {"oid": "af882132deb9317ed3a35af66bf927a48d862add", "url": "https://github.com/IBM/FHIR/commit/af882132deb9317ed3a35af66bf927a48d862add", "message": "issue #1402 address pull request code review comments\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T17:23:04Z", "type": "commit"}, {"oid": "dd0629db54468331e19416da2dd1cbae75607829", "url": "https://github.com/IBM/FHIR/commit/dd0629db54468331e19416da2dd1cbae75607829", "message": "issue #1402 force fhir-bucket tests to be single-threaded\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T18:32:46Z", "type": "commit"}, {"oid": "542f22b887941c2ffcab4df73aa7dbc790686f2d", "url": "https://github.com/IBM/FHIR/commit/542f22b887941c2ffcab4df73aa7dbc790686f2d", "message": "issue #1402 use negative timeout for test to avoid potential clock jitter issue\n\nSigned-off-by: Robin Arnold <robin.arnold23@ibm.com>", "committedDate": "2020-09-04T19:09:27Z", "type": "commit"}]}