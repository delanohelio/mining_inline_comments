{"pr_number": 764, "pr_title": "Issue 744", "pr_createdAt": "2020-03-06T17:46:03Z", "pr_url": "https://github.com/IBM/FHIR/pull/764", "timeline": [{"oid": "e58b387d874dd4f07a5c9dd081c5f1d56a869681", "url": "https://github.com/IBM/FHIR/commit/e58b387d874dd4f07a5c9dd081c5f1d56a869681", "message": "IBM FHIR Server - DB2 Multitenancy Guide #744\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-03-06T17:44:14Z", "type": "commit"}, {"oid": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "url": "https://github.com/IBM/FHIR/commit/8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "message": "IBM FHIR Server - DB2 Multitenancy Guide #744\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-03-06T17:45:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3MTk1OA==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389071958", "bodyText": "how to rotate the keys?  does this mean we can run the com.ibm.fhir.schema.app.Main app multiple times to add new tenant keys for the same tenant name? and these multiple keys can work at the same time...", "author": "albertwang-ibm", "createdAt": "2020-03-06T18:33:49Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3NDMwMQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389074301", "bodyText": "That's right. You create a new one, and you can remove the unused one.", "author": "prb112", "createdAt": "2020-03-06T18:38:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA3MTk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTYzMg==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389081632", "bodyText": "on each tenant's schema or on \"each tenant schema\"?\ne.g, we have FHIRDATA and FHIRDATA2 schemas in CDT, so we have 2 tenant schemas there. and tenants can be created in each of these 2 tenant schema...  so, we don't really update the schema per tenant ...", "author": "albertwang-ibm", "createdAt": "2020-03-06T18:54:04Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to each tenant's schema. \n+", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MzU2Mw==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389083563", "bodyText": "The code actually supports this feature.  We just chose not to take this step in CDT.", "author": "prb112", "createdAt": "2020-03-06T18:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA5MDI2Ng==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389090266", "bodyText": "en... this is interesting... Is it \"TableSpace\" as OBJECT_TYPE and tenant name or id as OBJECT_NAME if we choose to upgrade schema for a certain tenant only?\nBTW, I noticed that schemaName is not really used in allocateTenant(String adminSchemaName, String schemaName, String tenantName, String tenantKey, String tenantSalt, String idSequenceName) ...", "author": "albertwang-ibm", "createdAt": "2020-03-06T19:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNjE1NQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389116155", "bodyText": "OBJECT_NAME is not a tenant_name.  It's inferred based\nYeah - that's right allocateTenant actually figures it out in the query.", "author": "prb112", "createdAt": "2020-03-06T20:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMTY4NQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389921685", "bodyText": "I had the same question and I'm still confused.  The code supports updating the tables on a per-schema basis right?  Which might be a single tenant or might be many tenants?", "author": "lmsurpre", "createdAt": "2020-03-09T19:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4MTYxOQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390281619", "bodyText": "e.g, we have FHIRDATA and FHIRDATA2 schemas in CDT, so we have 2 tenant schemas there. and tenants can be created in each of these 2 tenant schema... so, we don't really update the schema per tenant ...\n\nWell.  Let me clarify... the code technically supports it.  We're just breaking the model by removing columns and changing indices.  It does support independent updates.  We also support independent schemas.\nI've changed the words and given a few cases where this is true.", "author": "prb112", "createdAt": "2020-03-10T12:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NDE5Ng==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390284196", "bodyText": "en... this is interesting... Is it \"TableSpace\" as OBJECT_TYPE and tenant name or id as OBJECT_NAME if we choose to upgrade schema for a certain tenant only?\nan OBJECT_TYPE is one of the types\n\n[db2inst1@c1ed9e48d0ab ~]$ db2 \"SELECT DISTINCT OBJECT_TYPE FROM FHIR_ADMIN.VERSION_HISTORY\"\nOBJECT_TYPE\nPROCEDURE\nSEQUENCE\nTABLE\nTABLESPACE\nVARIABLE\n5 record(s) selected.\nWe only pass in the tenant_id and run an updateSchema action.\n\nBTW, I noticed that schemaName is not really used in allocateTenant(String adminSchemaName, String schemaName, String tenantName, String tenantKey, String tenantSalt, String idSequenceName) ...\nYes, this is correct... the actions taken in each part of the fhir-persistence-schema does not necessarily use all inputs.", "author": "prb112", "createdAt": "2020-03-10T12:40:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTYzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI4NDg3MA==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390284870", "bodyText": "I had the same question and I'm still confused. The code supports updating the tables on a per-schema basis right? Which might be a single tenant or might be many tenants?\n\nIt's actually not the design... it's just how we've done it that has broken the contract.  Robin did an always add approach, don't take away... This has resulted in an update independent approach.  We can support it, however, we haven't followed it.\nI've elaborated in the document explaining.", "author": "prb112", "createdAt": "2020-03-10T12:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4MTYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4Mzc3OQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389083779", "bodyText": "does this mean we can not query the total number of Patients across all the tenants in one sql, and we have to set tenant id and query them one by one and the do the sum...", "author": "albertwang-ibm", "createdAt": "2020-03-06T18:58:41Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to each tenant's schema. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| SCHEMA_NAME | VARCHAR | 64 | No | The name of the schema where the object resides|\n+| OBJECT_TYPE | VARCHAR | 16 | No | The type of the object - Procedure, Sequence, Table, TableSpace, Variable |\n+| OBJECT_NAME | VARCHAR | 64 | No | The name of the object in the schema |\n+| VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n+| APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n+\n+### Schema: Tenant-Specific\n+\n+The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNTE4OQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389115189", "bodyText": "Yes - in a multi-tenant schema.", "author": "prb112", "createdAt": "2020-03-06T19:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4Mzc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMjU1OQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389922559", "bodyText": "I've always had this question too...\nIs there some way to grant cross-tenant capabilities to an admin role?\nSeems like that could be useful, although I guess its designed to prevent that (for security reasons)...", "author": "lmsurpre", "createdAt": "2020-03-09T19:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4Mzc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3ODMzNQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390278335", "bodyText": "I've elaborated, as this is working as designed and intentional.  I added a paragraph explaining HOW one would accomplish it, and how the restrictions are enforced.", "author": "prb112", "createdAt": "2020-03-10T12:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4Mzc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4NDc2Ng==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389084766", "bodyText": "using DB2 DB backup tool?  just curious how to tell it which tenant to backup if use the DB2 tools ...", "author": "albertwang-ibm", "createdAt": "2020-03-06T19:00:46Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to each tenant's schema. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| SCHEMA_NAME | VARCHAR | 64 | No | The name of the schema where the object resides|\n+| OBJECT_TYPE | VARCHAR | 16 | No | The type of the object - Procedure, Sequence, Table, TableSpace, Variable |\n+| OBJECT_NAME | VARCHAR | 64 | No | The name of the object in the schema |\n+| VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n+| APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n+\n+### Schema: Tenant-Specific\n+\n+The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+\n+Tenants are never able to see each other's data, each user is only able to see a single tenant's data. \n+\n+Each tenant's data is able to be moved, backedup, restored or exported a tenant-at-a-time.  This approach allows tenant independent restore points.\n+", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNTM4NA==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389115384", "bodyText": "it's based on partition and tablespace.", "author": "prb112", "createdAt": "2020-03-06T19:59:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4NDc2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk2NDgyOA==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389964828", "bodyText": "I've elaborated on line 76 (in next commit)", "author": "prb112", "createdAt": "2020-03-09T21:13:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4NDc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNTAzNA==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389925034", "bodyText": "Maybe worth mentioning the distinction between these tables here?\n_LOGICAL_RESOURCES has one record per logical resource;\n_RESOURCES has one record for each version of each logical resource\nI think \"root resource\" makes sense in the case of _LOGICAL_RESOURCES, but I'm not sure about _RESOURCES.", "author": "lmsurpre", "createdAt": "2020-03-09T19:53:37Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to each tenant's schema. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| SCHEMA_NAME | VARCHAR | 64 | No | The name of the schema where the object resides|\n+| OBJECT_TYPE | VARCHAR | 16 | No | The type of the object - Procedure, Sequence, Table, TableSpace, Variable |\n+| OBJECT_NAME | VARCHAR | 64 | No | The name of the object in the schema |\n+| VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n+| APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n+\n+### Schema: Tenant-Specific\n+\n+The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+\n+Tenants are never able to see each other's data, each user is only able to see a single tenant's data. \n+\n+Each tenant's data is able to be moved, backedup, restored or exported a tenant-at-a-time.  This approach allows tenant independent restore points.\n+\n+The isolated data supports tenant independent query plan caches, scaling and disambiguating tenant specific disk and space usage. The performance metrics are tenant specific, and diagnostics are tenant specific. \n+\n+**Table: Resources**\n+\n+Each resource is contains a root RESOURCE and LOGICAL RESOURCE, such as VISIONPRESCRIPTION:", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMDc5NA==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390030794", "bodyText": "added", "author": "prb112", "createdAt": "2020-03-10T00:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyNTAzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzMTUwNQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389931505", "bodyText": "Not sure if I'm misreading this or not, but just to clarify:  there is a global LOGICAL_RESOURCES table, but no global RESOURCES table.  And by \"global\" we just mean it tracks all resources...it still has per-tenant row-based access control like all the others.", "author": "lmsurpre", "createdAt": "2020-03-09T20:06:38Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to each tenant's schema. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| SCHEMA_NAME | VARCHAR | 64 | No | The name of the schema where the object resides|\n+| OBJECT_TYPE | VARCHAR | 16 | No | The type of the object - Procedure, Sequence, Table, TableSpace, Variable |\n+| OBJECT_NAME | VARCHAR | 64 | No | The name of the object in the schema |\n+| VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n+| APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n+\n+### Schema: Tenant-Specific\n+\n+The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+\n+Tenants are never able to see each other's data, each user is only able to see a single tenant's data. \n+\n+Each tenant's data is able to be moved, backedup, restored or exported a tenant-at-a-time.  This approach allows tenant independent restore points.\n+\n+The isolated data supports tenant independent query plan caches, scaling and disambiguating tenant specific disk and space usage. The performance metrics are tenant specific, and diagnostics are tenant specific. \n+\n+**Table: Resources**\n+\n+Each resource is contains a root RESOURCE and LOGICAL RESOURCE, such as VISIONPRESCRIPTION:\n+\n+```\n+VISIONPRESCRIPTION_RESOURCES\n+VISIONPRESCRIPTION_LOGICAL_RESOURCES\n+```\n+\n+These values are mapped to specific FHIR Search value types, supporting parameter searches: \n+\n+```\n+VISIONPRESCRIPTION_COMPOSITES\n+VISIONPRESCRIPTION_DATE_VALUES\n+VISIONPRESCRIPTION_LATLNG_VALUES\n+VISIONPRESCRIPTION_NUMBER_VALUES\n+VISIONPRESCRIPTION_QUANTITY_VALUES\n+VISIONPRESCRIPTION_STR_VALUES\n+VISIONPRESCRIPTION_TOKEN_VALUES\n+```\n+\n+There are also global tables which enable a global search using the logical_resource and resource.  ", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyOTQ3MQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390029471", "bodyText": "yes - that's right - and the global is still per tenant.  I'll elaborate a bit more on 101. (actually a lot)...", "author": "prb112", "createdAt": "2020-03-10T00:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzMTUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzMjgyOQ==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389932829", "bodyText": "Consider adding this point:\nFor Db2 on Cloud, it uses Db2 native encryption.  This means there is a single key that encrypts all the tenants.  There is currently no way to encrypt each tenant's tablespace with a different key.", "author": "lmsurpre", "createdAt": "2020-03-09T20:09:15Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to each tenant's schema. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| SCHEMA_NAME | VARCHAR | 64 | No | The name of the schema where the object resides|\n+| OBJECT_TYPE | VARCHAR | 16 | No | The type of the object - Procedure, Sequence, Table, TableSpace, Variable |\n+| OBJECT_NAME | VARCHAR | 64 | No | The name of the object in the schema |\n+| VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n+| APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n+\n+### Schema: Tenant-Specific\n+\n+The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+\n+Tenants are never able to see each other's data, each user is only able to see a single tenant's data. \n+\n+Each tenant's data is able to be moved, backedup, restored or exported a tenant-at-a-time.  This approach allows tenant independent restore points.\n+\n+The isolated data supports tenant independent query plan caches, scaling and disambiguating tenant specific disk and space usage. The performance metrics are tenant specific, and diagnostics are tenant specific. \n+\n+**Table: Resources**\n+\n+Each resource is contains a root RESOURCE and LOGICAL RESOURCE, such as VISIONPRESCRIPTION:\n+\n+```\n+VISIONPRESCRIPTION_RESOURCES\n+VISIONPRESCRIPTION_LOGICAL_RESOURCES\n+```\n+\n+These values are mapped to specific FHIR Search value types, supporting parameter searches: \n+\n+```\n+VISIONPRESCRIPTION_COMPOSITES\n+VISIONPRESCRIPTION_DATE_VALUES\n+VISIONPRESCRIPTION_LATLNG_VALUES\n+VISIONPRESCRIPTION_NUMBER_VALUES\n+VISIONPRESCRIPTION_QUANTITY_VALUES\n+VISIONPRESCRIPTION_STR_VALUES\n+VISIONPRESCRIPTION_TOKEN_VALUES\n+```\n+\n+There are also global tables which enable a global search using the logical_resource and resource.  \n+\n+Each row is secured using DB2 Row Permission. The Stored Procedure is the ONLY way for a user to set the variable, which is used in the DB2 Row Permission. \n+\n+Each tenant's data is encrypted. ", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyOTc0Ng==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390029746", "bodyText": "done", "author": "prb112", "createdAt": "2020-03-10T00:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzMjgyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNDAzMA==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389934030", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - All objects in schema FHIRADMIN are owned by user FHIRADMIN\n          \n          \n            \n            - All objects in schema FHIR_ADMIN are owned by user FHIRADMIN", "author": "lmsurpre", "createdAt": "2020-03-09T20:11:34Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to each tenant's schema. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| SCHEMA_NAME | VARCHAR | 64 | No | The name of the schema where the object resides|\n+| OBJECT_TYPE | VARCHAR | 16 | No | The type of the object - Procedure, Sequence, Table, TableSpace, Variable |\n+| OBJECT_NAME | VARCHAR | 64 | No | The name of the object in the schema |\n+| VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n+| APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n+\n+### Schema: Tenant-Specific\n+\n+The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+\n+Tenants are never able to see each other's data, each user is only able to see a single tenant's data. \n+\n+Each tenant's data is able to be moved, backedup, restored or exported a tenant-at-a-time.  This approach allows tenant independent restore points.\n+\n+The isolated data supports tenant independent query plan caches, scaling and disambiguating tenant specific disk and space usage. The performance metrics are tenant specific, and diagnostics are tenant specific. \n+\n+**Table: Resources**\n+\n+Each resource is contains a root RESOURCE and LOGICAL RESOURCE, such as VISIONPRESCRIPTION:\n+\n+```\n+VISIONPRESCRIPTION_RESOURCES\n+VISIONPRESCRIPTION_LOGICAL_RESOURCES\n+```\n+\n+These values are mapped to specific FHIR Search value types, supporting parameter searches: \n+\n+```\n+VISIONPRESCRIPTION_COMPOSITES\n+VISIONPRESCRIPTION_DATE_VALUES\n+VISIONPRESCRIPTION_LATLNG_VALUES\n+VISIONPRESCRIPTION_NUMBER_VALUES\n+VISIONPRESCRIPTION_QUANTITY_VALUES\n+VISIONPRESCRIPTION_STR_VALUES\n+VISIONPRESCRIPTION_TOKEN_VALUES\n+```\n+\n+There are also global tables which enable a global search using the logical_resource and resource.  \n+\n+Each row is secured using DB2 Row Permission. The Stored Procedure is the ONLY way for a user to set the variable, which is used in the DB2 Row Permission. \n+\n+Each tenant's data is encrypted. \n+\n+Offboarding a tenant's data is accomplished using dettach/drop partition, and subsequently dropping the tablespace. \n+\n+**Stored Procedure: FHIR_ADMIN.SET_TENANT**\n+\n+The FHIR_ADMIN.SET_TENANT is used at the beginning of a connection to the IBM FHIR Server's multi-tenant schema. The SET_TENANT takes as input: tenant_name VARCHAR(36), tenant_key  VARCHAR(44).  The content outputs a connection specific variable `fhir_admin.sv_tenant_id` with the `tenant.mt_id`, which is automatically applied to the INSERT,SELECT,UPDATE,DELETE.  Only tenant's with status ALLOCATED are allowed to execute the actions.\n+\n+To use the stored procedure from the db2 administrative console. \n+\n+* Map Tenant and Key to Tenant ID (Stored Procedure) - `CALL FHIR_ADMIN.set_tenant('a-tenant-name', 'BLAH_BLAH');`\n+* Show the value set for the session - `VALUES fhir_admin.sv_tenant_id;`\n+* Execute the query, such as `SELECT * FROM FHIRDATA.MEDICATION_RESOURCES`\n+\n+**Schema: Permissions**\n+\n+The Multi-tenant schema sets the following permissions: \n+- All objects in schema FHIRADMIN are owned by user FHIRADMIN", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNjcyNw==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389936727", "bodyText": "Also, the FHIRADMIN user name is just an example, right?  I don't think the fhir-persistence-schema Main program actually creates this user...does it just uses whatever you've configured?\nLocally, I just use db2inst1.  For Db2 on Cloud, I've just used the default bluadmin user for this part...", "author": "lmsurpre", "createdAt": "2020-03-09T20:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNDAzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyOTg5Mg==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390029892", "bodyText": "Fixed", "author": "prb112", "createdAt": "2020-03-10T00:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNDAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNDg3Mw==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389934873", "bodyText": "Pretty sure I switched these over to FHIRSERVER a while back.  This is to distinguish it from the default user of the FHIR APIs which is FHIRUser.\nPlease help me squash all references to FHIRUSER as a user of the db.", "author": "lmsurpre", "createdAt": "2020-03-09T20:13:17Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to each tenant's schema. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| SCHEMA_NAME | VARCHAR | 64 | No | The name of the schema where the object resides|\n+| OBJECT_TYPE | VARCHAR | 16 | No | The type of the object - Procedure, Sequence, Table, TableSpace, Variable |\n+| OBJECT_NAME | VARCHAR | 64 | No | The name of the object in the schema |\n+| VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n+| APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n+\n+### Schema: Tenant-Specific\n+\n+The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+\n+Tenants are never able to see each other's data, each user is only able to see a single tenant's data. \n+\n+Each tenant's data is able to be moved, backedup, restored or exported a tenant-at-a-time.  This approach allows tenant independent restore points.\n+\n+The isolated data supports tenant independent query plan caches, scaling and disambiguating tenant specific disk and space usage. The performance metrics are tenant specific, and diagnostics are tenant specific. \n+\n+**Table: Resources**\n+\n+Each resource is contains a root RESOURCE and LOGICAL RESOURCE, such as VISIONPRESCRIPTION:\n+\n+```\n+VISIONPRESCRIPTION_RESOURCES\n+VISIONPRESCRIPTION_LOGICAL_RESOURCES\n+```\n+\n+These values are mapped to specific FHIR Search value types, supporting parameter searches: \n+\n+```\n+VISIONPRESCRIPTION_COMPOSITES\n+VISIONPRESCRIPTION_DATE_VALUES\n+VISIONPRESCRIPTION_LATLNG_VALUES\n+VISIONPRESCRIPTION_NUMBER_VALUES\n+VISIONPRESCRIPTION_QUANTITY_VALUES\n+VISIONPRESCRIPTION_STR_VALUES\n+VISIONPRESCRIPTION_TOKEN_VALUES\n+```\n+\n+There are also global tables which enable a global search using the logical_resource and resource.  \n+\n+Each row is secured using DB2 Row Permission. The Stored Procedure is the ONLY way for a user to set the variable, which is used in the DB2 Row Permission. \n+\n+Each tenant's data is encrypted. \n+\n+Offboarding a tenant's data is accomplished using dettach/drop partition, and subsequently dropping the tablespace. \n+\n+**Stored Procedure: FHIR_ADMIN.SET_TENANT**\n+\n+The FHIR_ADMIN.SET_TENANT is used at the beginning of a connection to the IBM FHIR Server's multi-tenant schema. The SET_TENANT takes as input: tenant_name VARCHAR(36), tenant_key  VARCHAR(44).  The content outputs a connection specific variable `fhir_admin.sv_tenant_id` with the `tenant.mt_id`, which is automatically applied to the INSERT,SELECT,UPDATE,DELETE.  Only tenant's with status ALLOCATED are allowed to execute the actions.\n+\n+To use the stored procedure from the db2 administrative console. \n+\n+* Map Tenant and Key to Tenant ID (Stored Procedure) - `CALL FHIR_ADMIN.set_tenant('a-tenant-name', 'BLAH_BLAH');`\n+* Show the value set for the session - `VALUES fhir_admin.sv_tenant_id;`\n+* Execute the query, such as `SELECT * FROM FHIRDATA.MEDICATION_RESOURCES`\n+\n+**Schema: Permissions**\n+\n+The Multi-tenant schema sets the following permissions: \n+- All objects in schema FHIRADMIN are owned by user FHIRADMIN\n+- All objects in schema FHIRDATA are owned by user FHIRADMIN\n+- GRANT EXECUTE ON FHIRADMIN.SET_TENANT TO FHIRUSER;\n+- GRANT READ ON FHIRADMIN.SV_TENANT_ID TO FHIRUSER;\n+- GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE_TYPE TO FHIRUSER;\n+- GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE TO FHIRUSER;\n+- GRANT SELECT,INSERT,UPDATE,DELETE ON FHIRDATA.PATIENT_RESOURCES TO FHIRUSER;", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNTEwNA==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389935104", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - GRANT EXECUTE ON FHIRADMIN.SET_TENANT TO FHIRUSER;\n          \n          \n            \n            - GRANT READ ON FHIRADMIN.SV_TENANT_ID TO FHIRUSER;\n          \n          \n            \n            - GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE_TYPE TO FHIRUSER;\n          \n          \n            \n            - GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE TO FHIRUSER;\n          \n          \n            \n            - GRANT SELECT,INSERT,UPDATE,DELETE ON FHIRDATA.PATIENT_RESOURCES TO FHIRUSER;\n          \n          \n            \n            - GRANT EXECUTE ON FHIRADMIN.SET_TENANT TO FHIRSERVER;\n          \n          \n            \n            - GRANT READ ON FHIRADMIN.SV_TENANT_ID TO FHIRSERVER;\n          \n          \n            \n            - GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE_TYPE TO FHIRSERVER;\n          \n          \n            \n            - GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE TO FHIRSERVER;\n          \n          \n            \n            - GRANT SELECT,INSERT,UPDATE,DELETE ON FHIRDATA.PATIENT_RESOURCES TO FHIRSERVER;", "author": "lmsurpre", "createdAt": "2020-03-09T20:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNDg3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMDIxNw==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390030217", "bodyText": "Fixed all over", "author": "prb112", "createdAt": "2020-03-10T00:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNDg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNzIwMw==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389937203", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            FHIR User is granted a minimum set of priveleges. \n          \n          \n            \n            FHIRSERVER is granted a minimum set of privileges.", "author": "lmsurpre", "createdAt": "2020-03-09T20:17:45Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to each tenant's schema. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| SCHEMA_NAME | VARCHAR | 64 | No | The name of the schema where the object resides|\n+| OBJECT_TYPE | VARCHAR | 16 | No | The type of the object - Procedure, Sequence, Table, TableSpace, Variable |\n+| OBJECT_NAME | VARCHAR | 64 | No | The name of the object in the schema |\n+| VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n+| APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n+\n+### Schema: Tenant-Specific\n+\n+The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+\n+Tenants are never able to see each other's data, each user is only able to see a single tenant's data. \n+\n+Each tenant's data is able to be moved, backedup, restored or exported a tenant-at-a-time.  This approach allows tenant independent restore points.\n+\n+The isolated data supports tenant independent query plan caches, scaling and disambiguating tenant specific disk and space usage. The performance metrics are tenant specific, and diagnostics are tenant specific. \n+\n+**Table: Resources**\n+\n+Each resource is contains a root RESOURCE and LOGICAL RESOURCE, such as VISIONPRESCRIPTION:\n+\n+```\n+VISIONPRESCRIPTION_RESOURCES\n+VISIONPRESCRIPTION_LOGICAL_RESOURCES\n+```\n+\n+These values are mapped to specific FHIR Search value types, supporting parameter searches: \n+\n+```\n+VISIONPRESCRIPTION_COMPOSITES\n+VISIONPRESCRIPTION_DATE_VALUES\n+VISIONPRESCRIPTION_LATLNG_VALUES\n+VISIONPRESCRIPTION_NUMBER_VALUES\n+VISIONPRESCRIPTION_QUANTITY_VALUES\n+VISIONPRESCRIPTION_STR_VALUES\n+VISIONPRESCRIPTION_TOKEN_VALUES\n+```\n+\n+There are also global tables which enable a global search using the logical_resource and resource.  \n+\n+Each row is secured using DB2 Row Permission. The Stored Procedure is the ONLY way for a user to set the variable, which is used in the DB2 Row Permission. \n+\n+Each tenant's data is encrypted. \n+\n+Offboarding a tenant's data is accomplished using dettach/drop partition, and subsequently dropping the tablespace. \n+\n+**Stored Procedure: FHIR_ADMIN.SET_TENANT**\n+\n+The FHIR_ADMIN.SET_TENANT is used at the beginning of a connection to the IBM FHIR Server's multi-tenant schema. The SET_TENANT takes as input: tenant_name VARCHAR(36), tenant_key  VARCHAR(44).  The content outputs a connection specific variable `fhir_admin.sv_tenant_id` with the `tenant.mt_id`, which is automatically applied to the INSERT,SELECT,UPDATE,DELETE.  Only tenant's with status ALLOCATED are allowed to execute the actions.\n+\n+To use the stored procedure from the db2 administrative console. \n+\n+* Map Tenant and Key to Tenant ID (Stored Procedure) - `CALL FHIR_ADMIN.set_tenant('a-tenant-name', 'BLAH_BLAH');`\n+* Show the value set for the session - `VALUES fhir_admin.sv_tenant_id;`\n+* Execute the query, such as `SELECT * FROM FHIRDATA.MEDICATION_RESOURCES`\n+\n+**Schema: Permissions**\n+\n+The Multi-tenant schema sets the following permissions: \n+- All objects in schema FHIRADMIN are owned by user FHIRADMIN\n+- All objects in schema FHIRDATA are owned by user FHIRADMIN\n+- GRANT EXECUTE ON FHIRADMIN.SET_TENANT TO FHIRUSER;\n+- GRANT READ ON FHIRADMIN.SV_TENANT_ID TO FHIRUSER;\n+- GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE_TYPE TO FHIRUSER;\n+- GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE TO FHIRUSER;\n+- GRANT SELECT,INSERT,UPDATE,DELETE ON FHIRDATA.PATIENT_RESOURCES TO FHIRUSER;\n+\n+FHIRADMIN owns all schema objects. \n+FHIR User is granted a minimum set of priveleges. ", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMDA0Ng==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390030046", "bodyText": "fixed", "author": "prb112", "createdAt": "2020-03-10T00:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNzIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNzk2OA==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r389937968", "bodyText": "please update diagram to use FHIRSERVER instead of FHIRUSER as the db user", "author": "lmsurpre", "createdAt": "2020-03-09T20:19:17Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,140 @@\n+# The IBM FHIR Server - DB2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's DB2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to each tenant's schema. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| SCHEMA_NAME | VARCHAR | 64 | No | The name of the schema where the object resides|\n+| OBJECT_TYPE | VARCHAR | 16 | No | The type of the object - Procedure, Sequence, Table, TableSpace, Variable |\n+| OBJECT_NAME | VARCHAR | 64 | No | The name of the object in the schema |\n+| VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n+| APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n+\n+### Schema: Tenant-Specific\n+\n+The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+\n+Tenants are never able to see each other's data, each user is only able to see a single tenant's data. \n+\n+Each tenant's data is able to be moved, backedup, restored or exported a tenant-at-a-time.  This approach allows tenant independent restore points.\n+\n+The isolated data supports tenant independent query plan caches, scaling and disambiguating tenant specific disk and space usage. The performance metrics are tenant specific, and diagnostics are tenant specific. \n+\n+**Table: Resources**\n+\n+Each resource is contains a root RESOURCE and LOGICAL RESOURCE, such as VISIONPRESCRIPTION:\n+\n+```\n+VISIONPRESCRIPTION_RESOURCES\n+VISIONPRESCRIPTION_LOGICAL_RESOURCES\n+```\n+\n+These values are mapped to specific FHIR Search value types, supporting parameter searches: \n+\n+```\n+VISIONPRESCRIPTION_COMPOSITES\n+VISIONPRESCRIPTION_DATE_VALUES\n+VISIONPRESCRIPTION_LATLNG_VALUES\n+VISIONPRESCRIPTION_NUMBER_VALUES\n+VISIONPRESCRIPTION_QUANTITY_VALUES\n+VISIONPRESCRIPTION_STR_VALUES\n+VISIONPRESCRIPTION_TOKEN_VALUES\n+```\n+\n+There are also global tables which enable a global search using the logical_resource and resource.  \n+\n+Each row is secured using DB2 Row Permission. The Stored Procedure is the ONLY way for a user to set the variable, which is used in the DB2 Row Permission. \n+\n+Each tenant's data is encrypted. \n+\n+Offboarding a tenant's data is accomplished using dettach/drop partition, and subsequently dropping the tablespace. \n+\n+**Stored Procedure: FHIR_ADMIN.SET_TENANT**\n+\n+The FHIR_ADMIN.SET_TENANT is used at the beginning of a connection to the IBM FHIR Server's multi-tenant schema. The SET_TENANT takes as input: tenant_name VARCHAR(36), tenant_key  VARCHAR(44).  The content outputs a connection specific variable `fhir_admin.sv_tenant_id` with the `tenant.mt_id`, which is automatically applied to the INSERT,SELECT,UPDATE,DELETE.  Only tenant's with status ALLOCATED are allowed to execute the actions.\n+\n+To use the stored procedure from the db2 administrative console. \n+\n+* Map Tenant and Key to Tenant ID (Stored Procedure) - `CALL FHIR_ADMIN.set_tenant('a-tenant-name', 'BLAH_BLAH');`\n+* Show the value set for the session - `VALUES fhir_admin.sv_tenant_id;`\n+* Execute the query, such as `SELECT * FROM FHIRDATA.MEDICATION_RESOURCES`\n+\n+**Schema: Permissions**\n+\n+The Multi-tenant schema sets the following permissions: \n+- All objects in schema FHIRADMIN are owned by user FHIRADMIN\n+- All objects in schema FHIRDATA are owned by user FHIRADMIN\n+- GRANT EXECUTE ON FHIRADMIN.SET_TENANT TO FHIRUSER;\n+- GRANT READ ON FHIRADMIN.SV_TENANT_ID TO FHIRUSER;\n+- GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE_TYPE TO FHIRUSER;\n+- GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE TO FHIRUSER;\n+- GRANT SELECT,INSERT,UPDATE,DELETE ON FHIRDATA.PATIENT_RESOURCES TO FHIRUSER;\n+\n+FHIRADMIN owns all schema objects. \n+FHIR User is granted a minimum set of priveleges. \n+SET_TENANT is the only way to write the SV_TENANT_ID. \n+\n+The diagram outlines the relationships between the administrative and tenant schema. \n+![permissions-overview.png](permissions-overview.png)", "originalCommit": "8c8b90d9efdd52e57bc42fa3a808aeac28406a2c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMTQ1Nw==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390031457", "bodyText": "done", "author": "prb112", "createdAt": "2020-03-10T00:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkzNzk2OA=="}], "type": "inlineReview"}, {"oid": "77c6fc8819d310b0245e49b137ab50d5bc83e31d", "url": "https://github.com/IBM/FHIR/commit/77c6fc8819d310b0245e49b137ab50d5bc83e31d", "message": "IBM FHIR Server - DB2 Multitenancy Guide #744\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-03-10T12:43:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDMxMzQ3MA==", "url": "https://github.com/IBM/FHIR/pull/764#discussion_r390313470", "bodyText": "Above we say the table name is FHIR_ADMIN but the username is FHIRADMIN\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            FHIR_ADMIN owns all schema objects. \n          \n          \n            \n            FHIRADMIN owns all schema objects.", "author": "lmsurpre", "createdAt": "2020-03-10T13:31:50Z", "path": "fhir-persistence-schema/docs/DB2MultiTenancy.md", "diffHunk": "@@ -0,0 +1,175 @@\n+# The IBM FHIR Server - Db2 Multi-Tenancy\n+\n+This document outlines the schema design and implementation for the IBM FHIR Server's Db2 Multi-tenancy feature. \n+\n+The Multi-tenancy feature has two main areas of focus: \n+- Tenant Provisioning  \n+- Security\n+\n+## Multi-Tenancy Schema Design\n+\n+The design has an administrative schema and at least one tenant schema. Each tenant schema is in a separate tenant specific tablespace. \n+\n+### Schema: Administrative\n+\n+The administrative schema's name is FHIR_ADMIN.  FHIR_ADMIN has \n+- three tables: TENANTS, TENANT_KEYS, VERSION_HISTORY\n+- one sequence: FHIR_ADMIN.TENANT_SEQUENCE\n+- one stored procedure: SET_TENANT\n+\n+The tables have supporting indicies and privileges. \n+\n+**Table: TENANTS**\n+\n+The Tenants table maps a given tenant to the Multi-Tenant ID (MT_ID) for the given tenant.  The MT_ID is subsequently used to restrict row access based on the matching value. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Unique ID identifying the Tenant's ID|\n+| TENANT_NAME | VARCHAR | 36 | No | The name of the tenant |\n+| TENANT_STATUS | VARCHAR | 16 | No | The status of the Tenant|\n+\n+MT_ID is the value used to assign ROW Access Control in the Multi-Tenant schema. The MT_ID is assigned from the FHIR_ADMIN.TENANT_SEQUENCE.  The value is to 1 to 9999, with no cycles. \n+\n+Tenant Status is one of the following: \n+| Status | Purpose |\n+|----------|---------------------------------------------|\n+| PROVISIONING | Indicates the tenant schema is in the process of adding a set of tenant tables/partitions |\n+| ALLOCATED | Indicates the process of creating the tenant schema is finished, and the schema is ready for use. Only allocated tenants are available for use in the `fhir-persistence-jdbc` code |\n+| FROZEN | Indicates the previous tenant data is not to be used, and the tenant data is in the process of being removed |\n+| DROPPED | Indicates the previous tenant data is now removed |\n+| FREE | Indicates a set of tables is provisioned, and available to be allocated to a specific tenant |\n+\n+**Table: TENANT_KEYS**\n+\n+The Tenant Keys table stores a hashed version of the tenant specific key. Upon creating a session and calling the SET_TENANT procedure, the SET_TENANT queries the incoming key against the TENANT_KEYS database to map to a specific tenant MT_ID. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| TENANT_KEY_ID | Integer | 4 | No | The ID is from the sequence, and is used to identify the unique entry in the row |\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| TENANT_SALT | VARCHAR | 44 | No | A 32 byte random value used as a salt when computing the SHA-256 tenant hash |\n+| TENANT_HASH | VARBINARY | 32 | No | Each tenant's data is encrypted. |\n+\n+The tenant_key is a 32 byte random value created when the tenant is provisioned. This is a secret, and must be passed by the client to the database in order to obtain access to a tenant. A tenant may have multiple tenant keys to support key rotation. An example of the tenant key is `GQUHRi0ETFw0Xe+p1VtVDki4JFZs885bGM35hXRyq/E=`\n+\n+Multiple keys per tenant are supported, and key rotation includes adding, and then subsequently removing prior keys. \n+\n+**Table: VERSION_HISTORY**\n+\n+The VERSION_HISTORY table enables Tenant version isolation, so upgrades and patches are separately applied to the schema the tenant belongs. Specifically, if the tenant shares the table definitions with another client, the patching is applied to both tenants at the same time.  If the tenant has a specific schema, the table definitions may be updated independent of each other. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| SCHEMA_NAME | VARCHAR | 64 | No | The name of the schema where the object resides|\n+| OBJECT_TYPE | VARCHAR | 16 | No | The type of the object - Procedure, Sequence, Table, TableSpace, Variable |\n+| OBJECT_NAME | VARCHAR | 64 | No | The name of the object in the schema |\n+| VERSION | INTEGER | 4 | No | The version starting at one and incrementing with every version change |\n+| APPLIED | TIMESTAMP | 10 | No | The time of the latest object update |\n+\n+### Schema: Tenant-Specific\n+\n+The Tenant specific data is partitioned and isolated in a customer specific tablespace.  The tenant data is not mixed with other tenant data physically using the tablespace isolation. \n+\n+Tenants are never able to see each other's data, each user is only able to see a single tenant's data. The IBM FHIR Server uses the [CREATE PERMISSION statement](https://www.ibm.com/support/knowledgecenter/SSHRBY/com.ibm.swg.im.dashdb.sql.ref.doc/doc/r0057429.html) to create a row permission that specifies a condition under which rows of the table can be accessed. \n+\n+The condition to access the content is based on the SQL variable FHIR_ADMIN.SV_TENANT_ID joined with each table's MT_ID (multi-tenant id). If you need to query all tenants, you need to write a specific stored procedure to loop over the tenant_ids and query the table with each variable set with each tenant_id, and aggregate in the stored procedure. \n+\n+Each tenant's data is able to be moved, backedup, restored or exported a tenant-at-a-time.  This approach allows tenant independent restore points, using [DB2 11.1: Backing up partitioned databases](https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.admin.ha.doc/doc/t0051366.html)\n+\n+The isolated data supports tenant independent query plan caches, scaling and disambiguating tenant specific disk and space usage. The performance metrics are tenant specific, and diagnostics are tenant specific. \n+\n+**Table: Resources**\n+\n+Each resource is contains a RESOURCE and LOGICAL RESOURCE table. `_LOGICAL_RESOURCES` has one record per logical resource.  `_RESOURCES` has one record for each version of each logical resource. \n+\n+For example, VISIONPRESCRIPTION has: \n+\n+```\n+VISIONPRESCRIPTION_RESOURCES\n+VISIONPRESCRIPTION_LOGICAL_RESOURCES\n+```\n+\n+These values are mapped to specific FHIR Search value types, supporting parameter searches: \n+\n+```\n+VISIONPRESCRIPTION_COMPOSITES\n+VISIONPRESCRIPTION_DATE_VALUES\n+VISIONPRESCRIPTION_LATLNG_VALUES\n+VISIONPRESCRIPTION_NUMBER_VALUES\n+VISIONPRESCRIPTION_QUANTITY_VALUES\n+VISIONPRESCRIPTION_STR_VALUES\n+VISIONPRESCRIPTION_TOKEN_VALUES\n+```\n+\n+There are also additional tables to support search: `LOGICAL_RESOURCE`, `RESOURCE_TYPES` and `PARAMETER_NAMES` These tables are paritioned, and are specific for each tenant. \n+\n+**Table: Global: LOGICAL_RESOURCE**\n+\n+This table facilitates global search optimizations. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| LOGICAL_RESOURCE_ID | Integer | 8 | No | The ID is from the sequence, and is used to identify the unique entry in the specific Resource row |\n+| RESOURCE_TYPE_ID | VARCHAR | 44 | No | Associates a Resource with a Resource Type using the value from the Resource Types table |\n+| LOGICAL_ID | VARCHAR | 255 | No | The unique tenant specific UUID assigned to the Resource |\n+\n+**Table: Global: RESOURCE_TYPES**\n+\n+The tenant specific table of resources, which are mapped to bigints as FKs to optimize global search. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| RESOURCE_TYPE_ID | Integer | 4 | No | A unique Identifier identifying the type of the resource |\n+| RESOURCE_TYPE | VARCHAR | 32 | No | Each ResourceType |\n+\n+**Table: Global: PARAMETER_NAMES**\n+\n+The PARAMETER_NAMES table registers, for each tenant, a mapping from the Search Parameter `code` to an `integer`, which is used in the values table to uniquely identify the parameter name.  The parameters are only registered on extraction (Create, Update), and not populated on Search. \n+\n+| Column Name | Data Type | Length | Null | Purpose |\n+|----------|---------------|---------------|---------------|---------------------------------------------|\n+| MT_ID | Integer | 4 | No | Matches to the MT_ID in the TENANTS table |\n+| PARAMETER_NAME_ID | INTEGER | 4 | No | A unique integer for each parameter, and is stored along with the value in the Parameters VALUES table for each resource |\n+| PARAMETER_NAME | VARCHAR | 255 | No | The Parameter name which actually maps to the FHIR SearchParameter `code` |\n+\n+Each row is secured using Db2 Row Permission. The Stored Procedure is the ONLY way for a user to set the variable, which is used in the Db2 Row Permission. \n+\n+Each tenant's data is encrypted.  For Db2 on Cloud, it uses Db2 native encryption. This means there is a single key that encrypts all the tenants. There is currently no way to encrypt each tenant's tablespace with a different key.\n+\n+Offboarding a tenant's data is accomplished using dettach/drop partition, and subsequently dropping the tablespace. \n+\n+**Stored Procedure: FHIR_ADMIN.SET_TENANT**\n+\n+The FHIR_ADMIN.SET_TENANT is used at the beginning of a connection to the IBM FHIR Server's multi-tenant schema. The SET_TENANT takes as input: tenant_name VARCHAR(36), tenant_key  VARCHAR(44).  The content outputs a connection specific variable `fhir_admin.sv_tenant_id` with the `tenant.mt_id`, which is automatically applied to the INSERT,SELECT,UPDATE,DELETE.  Only tenant's with status ALLOCATED are allowed to execute the actions.\n+\n+To use the stored procedure from the Db2 administrative console. \n+\n+* Map Tenant and Key to Tenant ID (Stored Procedure) - `CALL FHIR_ADMIN.set_tenant('a-tenant-name', 'BLAH_BLAH');`\n+* Show the value set for the session - `VALUES fhir_admin.sv_tenant_id;`\n+* Execute the query, such as `SELECT * FROM FHIRDATA.MEDICATION_RESOURCES`\n+\n+**Schema: Permissions**\n+\n+The Multi-tenant schema sets the following permissions: \n+- All objects in schema FHIR_ADMIN are owned by user FHIRADMIN\n+- All objects in schema FHIRDATA are owned by user FHIRADMIN\n+- GRANT EXECUTE ON FHIR_ADMIN.SET_TENANT TO FHIRSERVER;\n+- GRANT READ ON FHIR_ADMIN.SV_TENANT_ID TO FHIRSERVER;\n+- GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE_TYPE TO FHIRSERVER;\n+- GRANT EXECUTE ON FHIRDATA.ADD_RESOURCE TO FHIRSERVER;\n+- GRANT SELECT,INSERT,UPDATE,DELETE ON FHIRDATA.PATIENT_RESOURCES TO FHIRSERVER;\n+\n+FHIR_ADMIN owns all schema objects. ", "originalCommit": "77c6fc8819d310b0245e49b137ab50d5bc83e31d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "72677b1af7520a28c918c784f2417da56ada5c53", "url": "https://github.com/IBM/FHIR/commit/72677b1af7520a28c918c784f2417da56ada5c53", "message": "Update fhir-persistence-schema/docs/DB2MultiTenancy.md\r\n\r\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>\n\nCo-Authored-By: Lee Surprenant <lmsurpre@us.ibm.com>", "committedDate": "2020-03-10T13:32:55Z", "type": "commit"}, {"oid": "a583218aea4e5251c0948760dab97f7c4ced5701", "url": "https://github.com/IBM/FHIR/commit/a583218aea4e5251c0948760dab97f7c4ced5701", "message": "Update fhir-persistence-schema/docs/DB2MultiTenancy.md\n\nSigned-off-by: Paul Bastide <pbastide@us.ibm.com>", "committedDate": "2020-03-10T13:46:50Z", "type": "commit"}]}