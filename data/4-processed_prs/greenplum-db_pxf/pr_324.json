{"pr_number": 324, "pr_title": "Parquet: Right trim char types during insert", "pr_createdAt": "2020-04-01T02:10:18Z", "pr_url": "https://github.com/greenplum-db/pxf/pull/324", "timeline": [{"oid": "9fe2b935ca790a8adf1a9fa65a6626ae52fee51d", "url": "https://github.com/greenplum-db/pxf/commit/9fe2b935ca790a8adf1a9fa65a6626ae52fee51d", "message": "Parquet: Right trim char types during insert\n\nCurrently, there is an issue when inserting parquet data with char types\nwhen they are padded. For example,\n\n    CREATE WRITABLE EXTERNAL TABLE foo (id int, code char(5))\n    LOCATION ('pxf://bucket/path?PROFILE=s3:parquet&SERVER=s3')\n    FORMAT 'CUSTOM' (formatter='pxfwritable_export');\n\n    INSERT INTO foo VALUE (1, '95126'), (2, '9'), (3, '9');\n\nThis will cause postgres to right pad tuples 2 and 3 with whitespace\nafter the char '9', which will be sent to PXF Server as '9    ', and\nwe'll store it as such in a parquet file. However, this is inconsistent\nwith Hive's behavior and it is also causing issues with predicate\npushdown. Queries like the following will produce no tuples:\n\n    SELECT * FROM foo WHERE code = '9';\n\nWith this patch, we right-trim values of type char coming from Greenplum\nbefore storing them to parquet. This brings us on-par with the way Hive\nstores char types and it fixes predicate pushdown.", "committedDate": "2020-04-01T13:16:36Z", "type": "forcePushed"}, {"oid": "860639778db699f6908721f746dc273087634b25", "url": "https://github.com/greenplum-db/pxf/commit/860639778db699f6908721f746dc273087634b25", "message": "Parquet: Right trim char types during insert\n\nCurrently, there is an issue when inserting parquet data with char types\nwhen they are padded. For example,\n\n    CREATE WRITABLE EXTERNAL TABLE foo (id int, code char(5))\n    LOCATION ('pxf://bucket/path?PROFILE=s3:parquet&SERVER=s3')\n    FORMAT 'CUSTOM' (formatter='pxfwritable_export');\n\n    INSERT INTO foo VALUE (1, '95126'), (2, '9'), (3, '9');\n\nThis will cause postgres to right pad tuples 2 and 3 with whitespace\nafter the char '9', which will be sent to PXF Server as '9    ', and\nwe'll store it as such in a parquet file. However, this is inconsistent\nwith Hive's behavior and it is also causing issues with predicate\npushdown. Queries like the following will produce no tuples:\n\n    SELECT * FROM foo WHERE code = '9';\n\nWith this patch, we right-trim values of type char coming from Greenplum\nbefore storing them to parquet. This brings us on-par with the way Hive\nstores char types and it fixes predicate pushdown.", "committedDate": "2020-04-01T13:25:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5ODY5NA==", "url": "https://github.com/greenplum-db/pxf/pull/324#discussion_r401798694", "bodyText": "would be nice to have a query that also uses WHERE c1 = 'a  ' to make sure if a user specifies a padded value we can handle that as well.", "author": "denalex", "createdAt": "2020-04-01T17:48:38Z", "path": "automation/tincrepo/main/pxf/features/parquet/padded_char_pushdown/expected/query01.ans", "diffHunk": "@@ -0,0 +1,54 @@\n+-- start_ignore\n+-- end_ignore\n+-- @description query01 for pushing down predicates of type char that were\n+-- padded during write. Hive right trims values for type char, for example\n+-- when a value 'a  ' is inserted into a Hive table stored as parquet, Hive will\n+-- only store 'a' in the parquet file.\n+-- Display on for output consistency between GPDB 5 and 6\n+\\x on\n+Expanded display is on.\n+\\pset format unaligned\n+Output format is unaligned.\n+SELECT s1, s2, n1, d1, dc1, f, bg, b, tn, sml, vc1, c1, bin FROM parquet_view WHERE c1 = 'a' OR c1 = e'b\\t' OR c1 = e'c\\n' ORDER BY s1;", "originalCommit": "860639778db699f6908721f746dc273087634b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyODczNA==", "url": "https://github.com/greenplum-db/pxf/pull/324#discussion_r401828734", "bodyText": "good point, but I'm pretty sure it won't be handled. Should we trim the predicate? Or should we add an OR for these predicates on the server side ( c1 = 'a ' OR c1 = 'a' )", "author": "frankgh", "createdAt": "2020-04-01T18:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc5ODY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMzc1MA==", "url": "https://github.com/greenplum-db/pxf/pull/324#discussion_r401803750", "bodyText": "assertEquals(\"\", Utilities.rightTrimWhiteSpace(\"\"));", "author": "denalex", "createdAt": "2020-04-01T17:56:57Z", "path": "server/pxf-api/src/test/java/org/greenplum/pxf/api/utilities/UtilitiesTest.java", "diffHunk": "@@ -168,6 +168,20 @@ public boolean isThreadSafe() {\n         }\n     }\n \n+    @Test\n+    public void testRightTrimWhitespace() {\n+        assertNull(Utilities.rightTrimWhiteSpace(null));", "originalCommit": "860639778db699f6908721f746dc273087634b25", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMDEzOQ==", "url": "https://github.com/greenplum-db/pxf/pull/324#discussion_r401800139", "bodyText": "Interesting to me that we need to check if field.val is a String. What's the reason?", "author": "oliverralbertini", "createdAt": "2020-04-01T17:51:01Z", "path": "server/pxf-hdfs/src/main/java/org/greenplum/pxf/plugins/hdfs/ParquetResolver.java", "diffHunk": "@@ -90,7 +91,19 @@ public OneRow setFields(List<OneField> record) throws IOException {\n         validateSchema();\n         Group group = groupFactory.newGroup();\n         for (int i = 0; i < record.size(); i++) {\n-            fillGroup(i, record.get(i), group, schema.getType(i));\n+            OneField field = record.get(i);\n+            ColumnDescriptor columnDescriptor = context.getTupleDescription().get(i);\n+\n+            /*\n+             * We need to right trim the incoming value from Greenplum. This is\n+             * consistent with the behaviour in Hive, where char fields are right\n+             * trimmed during write. Note that String and varchar Hive types are\n+             * not right trimmed. Hive does not trim tabs or newlines\n+             */\n+            if (columnDescriptor.getDataType() == DataType.BPCHAR && field.val instanceof String) {", "originalCommit": "860639778db699f6908721f746dc273087634b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNjQwNA==", "url": "https://github.com/greenplum-db/pxf/pull/324#discussion_r401826404", "bodyText": "because field.val is of Object type", "author": "frankgh", "createdAt": "2020-04-01T18:35:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgwMDEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNTg2MQ==", "url": "https://github.com/greenplum-db/pxf/pull/324#discussion_r401815861", "bodyText": "I would be more in favor of this:\npublic static String rightTrimWhiteSpace(String s) {\n        if (s == null) return null;\n        return s.replaceAll(\" +$\", \"\");\n    }", "author": "oliverralbertini", "createdAt": "2020-04-01T18:17:40Z", "path": "server/pxf-api/src/main/java/org/greenplum/pxf/api/utilities/Utilities.java", "diffHunk": "@@ -332,4 +330,31 @@ public static boolean isSecurityEnabled(Configuration configuration) {\n         return SecurityUtil.getAuthenticationMethod(configuration) !=\n                 UserGroupInformation.AuthenticationMethod.SIMPLE;\n     }\n+\n+    /**\n+     * Right trim whitespace on a string (it does not trim tabs)\n+     * <p>\n+     *     <ul>\n+     *         <li>null returns null</li>\n+     *         <li>\"abc\" returns \"abc\"</li>\n+     *         <li>\" abc\" returns \" abc\"</li>\n+     *         <li>\"abc \" returns \"abc\"</li>\n+     *         <li>\"    \" returns \"\"</li>\n+     *         <li>\"abc \\t \" returns \"abc \\t\"</li>\n+     *         <li>\"abc \\t\\t\" returns \"abc \\t\\t\"</li>\n+     *     </ul>\n+     * </p>\n+     *\n+     * @param s the string\n+     * @return the right trimmed string\n+     */\n+    public static String rightTrimWhiteSpace(String s) {\n+        if (s == null) return null;\n+        int length = s.length();\n+        while (length > 0 && s.charAt(length - 1) == ' ') length--;\n+\n+        if (length == s.length()) return s;\n+        if (length == 0) return \"\";\n+        return s.substring(0, length);\n+    }", "originalCommit": "860639778db699f6908721f746dc273087634b25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNjgzMA==", "url": "https://github.com/greenplum-db/pxf/pull/324#discussion_r401816830", "bodyText": "Do we need tests in UtilitiesTest.java?", "author": "oliverralbertini", "createdAt": "2020-04-01T18:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNTg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgyNjA4Mg==", "url": "https://github.com/greenplum-db/pxf/pull/324#discussion_r401826082", "bodyText": "I'm not a huge fan of regex. We have tests in UtilitiesTest.java as part of the PR.", "author": "frankgh", "createdAt": "2020-04-01T18:34:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTgxNTg2MQ=="}], "type": "inlineReview"}, {"oid": "2bb5ba0d978c98c9e626545391ff843e23a270c9", "url": "https://github.com/greenplum-db/pxf/commit/2bb5ba0d978c98c9e626545391ff843e23a270c9", "message": "Parquet: Transform char predicates with trailing whitespace\n\nWhen a predicate for a char type has trailing whitespace we transform\nthe query to c1 = 'a  ' to (c1 = 'a  ' OR c1 = 'a'). This allows us to\npush the original predicate, but also it provides consistency with the\nway we are storing char types in parquet. When the operator is a not\nequals the query is transformed from c1 <> 'a  ' to (c1 <> 'a  ' AND c1\n<> 'a').\n\nRenamed the SupportedParquetPrimitiveTypePruner class to\nParquetOperatorPrunerAndTransformer to take into account the new\nfunctionality of the class.", "committedDate": "2020-04-01T22:06:14Z", "type": "forcePushed"}, {"oid": "23790594295c919af4e705242a867d41649a2f5a", "url": "https://github.com/greenplum-db/pxf/commit/23790594295c919af4e705242a867d41649a2f5a", "message": "Parquet: Right trim char types during insert\n\nCurrently, there is an issue when inserting parquet data with char types\nwhen they are padded. For example,\n\n    CREATE WRITABLE EXTERNAL TABLE foo (id int, code char(5))\n    LOCATION ('pxf://bucket/path?PROFILE=s3:parquet&SERVER=s3')\n    FORMAT 'CUSTOM' (formatter='pxfwritable_export');\n\n    INSERT INTO foo VALUE (1, '95126'), (2, '9'), (3, '9');\n\nThis will cause postgres to right pad tuples 2 and 3 with whitespace\nafter the char '9', which will be sent to PXF Server as '9    ', and\nwe'll store it as such in a parquet file. However, this is inconsistent\nwith Hive's behavior and it is also causing issues with predicate\npushdown. Queries like the following will produce no tuples:\n\n    SELECT * FROM foo WHERE code = '9';\n\nWith this patch, we right-trim values of type char coming from Greenplum\nbefore storing them to parquet. This brings us on-par with the way Hive\nstores char types and it fixes predicate pushdown.", "committedDate": "2020-04-01T22:40:10Z", "type": "commit"}, {"oid": "9fcd266d35a2b6351e7caad36f7e8d9e3a974024", "url": "https://github.com/greenplum-db/pxf/commit/9fcd266d35a2b6351e7caad36f7e8d9e3a974024", "message": "Parquet: Transform char predicates with trailing whitespace\n\nWhen a predicate for a char type has trailing whitespace we transform\nthe query to c1 = 'a  ' to (c1 = 'a  ' OR c1 = 'a'). This allows us to\npush the original predicate, but also it provides consistency with the\nway we are storing char types in parquet. When the operator is a not\nequals the query is transformed from c1 <> 'a  ' to (c1 <> 'a  ' AND c1\n<> 'a').\n\nRenamed the SupportedParquetPrimitiveTypePruner class to\nParquetOperatorPrunerAndTransformer to take into account the new\nfunctionality of the class.", "committedDate": "2020-04-01T22:44:07Z", "type": "commit"}, {"oid": "9fcd266d35a2b6351e7caad36f7e8d9e3a974024", "url": "https://github.com/greenplum-db/pxf/commit/9fcd266d35a2b6351e7caad36f7e8d9e3a974024", "message": "Parquet: Transform char predicates with trailing whitespace\n\nWhen a predicate for a char type has trailing whitespace we transform\nthe query to c1 = 'a  ' to (c1 = 'a  ' OR c1 = 'a'). This allows us to\npush the original predicate, but also it provides consistency with the\nway we are storing char types in parquet. When the operator is a not\nequals the query is transformed from c1 <> 'a  ' to (c1 <> 'a  ' AND c1\n<> 'a').\n\nRenamed the SupportedParquetPrimitiveTypePruner class to\nParquetOperatorPrunerAndTransformer to take into account the new\nfunctionality of the class.", "committedDate": "2020-04-01T22:44:07Z", "type": "forcePushed"}]}