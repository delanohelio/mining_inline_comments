{"pr_number": 3044, "pr_title": "NMS-12736: Add documentation for TcpListener", "pr_createdAt": "2020-06-23T19:05:03Z", "pr_url": "https://github.com/OpenNMS/opennms/pull/3044", "timeline": [{"oid": "17e28101c0e2ee5793ba978cde67c574ca989f9b", "url": "https://github.com/OpenNMS/opennms/commit/17e28101c0e2ee5793ba978cde67c574ca989f9b", "message": "NMS-12666: Updating Developer's Guide\n\nNMS-12666: In addressing a different Jira issue, I thought I needed to work in the Developer's Guide. After fixing some other issues with the guide including typos and broken links, I realized I need to address the other issue in the Admin Guide.", "committedDate": "2020-06-22T21:04:25Z", "type": "commit"}, {"oid": "5dd4b201ab709e84fff4afa9f6f48df78f70c17c", "url": "https://github.com/OpenNMS/opennms/commit/5dd4b201ab709e84fff4afa9f6f48df78f70c17c", "message": "NMS-12736: document tcplistener\n\nNMS-12736: Adding examples of tcplistener as per customer request.", "committedDate": "2020-06-22T21:51:38Z", "type": "commit"}, {"oid": "77112ec5ea2b5fd8e604540bccac3e4a68092601", "url": "https://github.com/OpenNMS/opennms/commit/77112ec5ea2b5fd8e604540bccac3e4a68092601", "message": "NMS-12736: tcplistener doc updates\n\nNMS-12736: tcplistener doc updates", "committedDate": "2020-06-23T15:03:09Z", "type": "commit"}, {"oid": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "url": "https://github.com/OpenNMS/opennms/commit/79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "message": "NMS-12736 - document TCPlistener\n\nNMS-12736: added examples on configuring TCPlistener in BMP and IPFIX.", "committedDate": "2020-06-23T19:02:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxMTI4Mw==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445011283", "bodyText": "Is this true? As far I remember we have parsers on the Minion as described here: https://docs.opennms.org/opennms/releases/26.1.1/guide-admin/guide-admin.html#_push_sensor_data_through_minion\n@fooker can you verify this here?", "author": "indigo423", "createdAt": "2020-06-24T16:13:16Z", "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/introduction.adoc", "diffHunk": "@@ -2,68 +2,80 @@\n // Allow GitHub image rendering\n :imagesdir: ../../images\n \n-The telemetry daemon (telemetryd) provides an extensible framework that can be used to handle sensor data pushed to _{opennms-product-name}_.\n-The framework can be used to implement support for a variety of applications which use different protocols to transfer metrics.\n-Using _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n+The telemetry daemon (telemetryd) provides an extensible framework you can use to handle sensor data pushed to _{opennms-product-name}_.\n+Use the framework to support applications that use different protocols to transfer metrics.\n+With _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n \n .Generic component overview of components in telemetryd\n image::telemetryd/telemetryd-overview.png[]\n \n The configuration is split in two parts.\n-_Listeners_ and attached _Parsers_ on one side, are responsible for receiving telemetry data transported over a specific protocol and parse the protocol according to its specification.\n+_Listeners_ and attached _Parsers_ on one side, receive telemetry data transported over a specific protocol and parse the protocol according to its specification.\n On the other side, _Adapters_ pick up the parsed data and enrich it before persisting it.\n \n-_Queues_ are used to transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n+_Queues_ transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n \n === _Listeners_ and _Parsers_\n-_Listeners_ are responsible for receiving sensor data from some external source and hand them off to _Parsers_ which handles the transport protocol format and extracts the transported data.\n+_Listeners_ receive sensor data from an external source and hand them off to _Parsers_, which handle the transport protocol format and extract the transported data.\n \n A _Listener_ does the transport protocol handling like opening a socket and accepting incoming connections.\n-The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extract all available information out of the received message.\n+The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extracts all available information out of the received message.\n For further processing, the extracted data is handed over to the configured queue.\n \n-For example: A _Listener_ may open a UDP socket for receiving packets and a assigned _Parser_ parses the incoming IPFix packets.\n+For example: a _Listener_ may open a UDP socket for receiving packets and an assigned _Parser_ parses the incoming IPFIX packets.\n \n-_Parsers_ and _Listeners_ must work together in a tight manner.\n-Therefore they can not be combined in any possible combination.\n-Which _Parser_ is supported by which _Listener_ is described in the documentation of each _Parser_ accordingly.\n+_Parsers_ and _Listeners_ must work together closely.\n+Therefore, they can not be combined in any random way.\n+Which _Parser_ is supported by which _Listener_ is described in the documentation of each respective _Parser_.\n \n-TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. It specifies the maximum delta in seconds between exporter and Minion timestamps. If violated an alarm will be generated for the exporting device. The default value is 0, so clock skew detection is disabled. Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events. The default is `3600` seconds, so every hour an event will be sent.\n+TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. \n+It specifies the maximum delta in seconds between exporter and Minion time stamps. \n+If violated, an alarm will be generated for the exporting device. \n+The default value is 0, so clock skew detection is disabled. \n+Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events.\n+The default is `3600` seconds, so every hour an event will be sent.\n+\n+==== Working with Minions\n+While {opennms-product-name} can operate as both a listener and a parser, Minion cannot.\n+A Minion receives data (listens). \n+Listeners on Minion must use parsers on {opennms-product-name} or Sentinel to process the data. ", "originalCommit": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxNjcwNQ==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445816705", "bodyText": "@indigo423 has a point there. The listeners and parsers run on the minion whereas the adapters are executed on the sentinel. The main opennms instance can be both.", "author": "fooker", "createdAt": "2020-06-25T20:23:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxMTI4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE4Njg2OA==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r446186868", "bodyText": "Thanks for clarifying. Am updating the documentation.", "author": "Bonrob2", "createdAt": "2020-06-26T13:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxMTI4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxNDExOA==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445014118", "bodyText": "line break", "author": "indigo423", "createdAt": "2020-06-24T16:17:53Z", "path": "opennms-doc/guide-development/src/asciidoc/text/docs/include-source.adoc", "diffHunk": "@@ -6,15 +6,15 @@\n === Code Snippets\n \n You can include code snippets, configuration- or source code files in the documentation.\n-You can enable syntax highlighting by providing the given language parameter, this will work on source code or configuration.\n+You can enable syntax highlighting by providing the given language parameter. This will work on source code or configuration.", "originalCommit": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxNTQ2Mw==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445815463", "bodyText": "While being here already, it is quite a strange place to mentioned it here. This feature is only supported by the netflow and ipfix parsers.", "author": "fooker", "createdAt": "2020-06-25T20:21:02Z", "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/introduction.adoc", "diffHunk": "@@ -2,68 +2,80 @@\n // Allow GitHub image rendering\n :imagesdir: ../../images\n \n-The telemetry daemon (telemetryd) provides an extensible framework that can be used to handle sensor data pushed to _{opennms-product-name}_.\n-The framework can be used to implement support for a variety of applications which use different protocols to transfer metrics.\n-Using _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n+The telemetry daemon (telemetryd) provides an extensible framework you can use to handle sensor data pushed to _{opennms-product-name}_.\n+Use the framework to support applications that use different protocols to transfer metrics.\n+With _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n \n .Generic component overview of components in telemetryd\n image::telemetryd/telemetryd-overview.png[]\n \n The configuration is split in two parts.\n-_Listeners_ and attached _Parsers_ on one side, are responsible for receiving telemetry data transported over a specific protocol and parse the protocol according to its specification.\n+_Listeners_ and attached _Parsers_ on one side, receive telemetry data transported over a specific protocol and parse the protocol according to its specification.\n On the other side, _Adapters_ pick up the parsed data and enrich it before persisting it.\n \n-_Queues_ are used to transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n+_Queues_ transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n \n === _Listeners_ and _Parsers_\n-_Listeners_ are responsible for receiving sensor data from some external source and hand them off to _Parsers_ which handles the transport protocol format and extracts the transported data.\n+_Listeners_ receive sensor data from an external source and hand them off to _Parsers_, which handle the transport protocol format and extract the transported data.\n \n A _Listener_ does the transport protocol handling like opening a socket and accepting incoming connections.\n-The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extract all available information out of the received message.\n+The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extracts all available information out of the received message.\n For further processing, the extracted data is handed over to the configured queue.\n \n-For example: A _Listener_ may open a UDP socket for receiving packets and a assigned _Parser_ parses the incoming IPFix packets.\n+For example: a _Listener_ may open a UDP socket for receiving packets and an assigned _Parser_ parses the incoming IPFIX packets.\n \n-_Parsers_ and _Listeners_ must work together in a tight manner.\n-Therefore they can not be combined in any possible combination.\n-Which _Parser_ is supported by which _Listener_ is described in the documentation of each _Parser_ accordingly.\n+_Parsers_ and _Listeners_ must work together closely.\n+Therefore, they can not be combined in any random way.\n+Which _Parser_ is supported by which _Listener_ is described in the documentation of each respective _Parser_.\n \n-TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. It specifies the maximum delta in seconds between exporter and Minion timestamps. If violated an alarm will be generated for the exporting device. The default value is 0, so clock skew detection is disabled. Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events. The default is `3600` seconds, so every hour an event will be sent.\n+TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. ", "originalCommit": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE4ODIzOA==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r446188238", "bodyText": "I will remove it from here, add to netflow and ipfix sections.", "author": "Bonrob2", "createdAt": "2020-06-26T13:36:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxNTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxNTcwMQ==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445815701", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If violated, an alarm will be generated for the exporting device. \n          \n          \n            \n            If exceeded, an alarm will be generated for the exporting device.", "author": "fooker", "createdAt": "2020-06-25T20:21:29Z", "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/introduction.adoc", "diffHunk": "@@ -2,68 +2,80 @@\n // Allow GitHub image rendering\n :imagesdir: ../../images\n \n-The telemetry daemon (telemetryd) provides an extensible framework that can be used to handle sensor data pushed to _{opennms-product-name}_.\n-The framework can be used to implement support for a variety of applications which use different protocols to transfer metrics.\n-Using _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n+The telemetry daemon (telemetryd) provides an extensible framework you can use to handle sensor data pushed to _{opennms-product-name}_.\n+Use the framework to support applications that use different protocols to transfer metrics.\n+With _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n \n .Generic component overview of components in telemetryd\n image::telemetryd/telemetryd-overview.png[]\n \n The configuration is split in two parts.\n-_Listeners_ and attached _Parsers_ on one side, are responsible for receiving telemetry data transported over a specific protocol and parse the protocol according to its specification.\n+_Listeners_ and attached _Parsers_ on one side, receive telemetry data transported over a specific protocol and parse the protocol according to its specification.\n On the other side, _Adapters_ pick up the parsed data and enrich it before persisting it.\n \n-_Queues_ are used to transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n+_Queues_ transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n \n === _Listeners_ and _Parsers_\n-_Listeners_ are responsible for receiving sensor data from some external source and hand them off to _Parsers_ which handles the transport protocol format and extracts the transported data.\n+_Listeners_ receive sensor data from an external source and hand them off to _Parsers_, which handle the transport protocol format and extract the transported data.\n \n A _Listener_ does the transport protocol handling like opening a socket and accepting incoming connections.\n-The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extract all available information out of the received message.\n+The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extracts all available information out of the received message.\n For further processing, the extracted data is handed over to the configured queue.\n \n-For example: A _Listener_ may open a UDP socket for receiving packets and a assigned _Parser_ parses the incoming IPFix packets.\n+For example: a _Listener_ may open a UDP socket for receiving packets and an assigned _Parser_ parses the incoming IPFIX packets.\n \n-_Parsers_ and _Listeners_ must work together in a tight manner.\n-Therefore they can not be combined in any possible combination.\n-Which _Parser_ is supported by which _Listener_ is described in the documentation of each _Parser_ accordingly.\n+_Parsers_ and _Listeners_ must work together closely.\n+Therefore, they can not be combined in any random way.\n+Which _Parser_ is supported by which _Listener_ is described in the documentation of each respective _Parser_.\n \n-TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. It specifies the maximum delta in seconds between exporter and Minion timestamps. If violated an alarm will be generated for the exporting device. The default value is 0, so clock skew detection is disabled. Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events. The default is `3600` seconds, so every hour an event will be sent.\n+TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. \n+It specifies the maximum delta in seconds between exporter and Minion time stamps. \n+If violated, an alarm will be generated for the exporting device. ", "originalCommit": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxNjg5OA==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445816898", "bodyText": "Is there something missing?", "author": "fooker", "createdAt": "2020-06-25T20:23:56Z", "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/introduction.adoc", "diffHunk": "@@ -2,68 +2,80 @@\n // Allow GitHub image rendering\n :imagesdir: ../../images\n \n-The telemetry daemon (telemetryd) provides an extensible framework that can be used to handle sensor data pushed to _{opennms-product-name}_.\n-The framework can be used to implement support for a variety of applications which use different protocols to transfer metrics.\n-Using _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n+The telemetry daemon (telemetryd) provides an extensible framework you can use to handle sensor data pushed to _{opennms-product-name}_.\n+Use the framework to support applications that use different protocols to transfer metrics.\n+With _telemetryd_, operators can define listeners supporting different protocols to receive the telemetry data and adapters transferring the received data into generic formats like flows or performance data.\n \n .Generic component overview of components in telemetryd\n image::telemetryd/telemetryd-overview.png[]\n \n The configuration is split in two parts.\n-_Listeners_ and attached _Parsers_ on one side, are responsible for receiving telemetry data transported over a specific protocol and parse the protocol according to its specification.\n+_Listeners_ and attached _Parsers_ on one side, receive telemetry data transported over a specific protocol and parse the protocol according to its specification.\n On the other side, _Adapters_ pick up the parsed data and enrich it before persisting it.\n \n-_Queues_ are used to transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n+_Queues_ transport the parsed telemetry data from _Parsers_ to _Adapters_ by binding a specific _Parser_ to a specific _Adapter_.\n \n === _Listeners_ and _Parsers_\n-_Listeners_ are responsible for receiving sensor data from some external source and hand them off to _Parsers_ which handles the transport protocol format and extracts the transported data.\n+_Listeners_ receive sensor data from an external source and hand them off to _Parsers_, which handle the transport protocol format and extract the transported data.\n \n A _Listener_ does the transport protocol handling like opening a socket and accepting incoming connections.\n-The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extract all available information out of the received message.\n+The received messages are then passed to the parser configured for the _Listener_ which parses the concrete protocol implementation and extracts all available information out of the received message.\n For further processing, the extracted data is handed over to the configured queue.\n \n-For example: A _Listener_ may open a UDP socket for receiving packets and a assigned _Parser_ parses the incoming IPFix packets.\n+For example: a _Listener_ may open a UDP socket for receiving packets and an assigned _Parser_ parses the incoming IPFIX packets.\n \n-_Parsers_ and _Listeners_ must work together in a tight manner.\n-Therefore they can not be combined in any possible combination.\n-Which _Parser_ is supported by which _Listener_ is described in the documentation of each _Parser_ accordingly.\n+_Parsers_ and _Listeners_ must work together closely.\n+Therefore, they can not be combined in any random way.\n+Which _Parser_ is supported by which _Listener_ is described in the documentation of each respective _Parser_.\n \n-TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. It specifies the maximum delta in seconds between exporter and Minion timestamps. If violated an alarm will be generated for the exporting device. The default value is 0, so clock skew detection is disabled. Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events. The default is `3600` seconds, so every hour an event will be sent.\n+TIP: You can provide the parameter `maxClockSkew` in your parser definition to enable clock skew detection for exporters. \n+It specifies the maximum delta in seconds between exporter and Minion time stamps. \n+If violated, an alarm will be generated for the exporting device. \n+The default value is 0, so clock skew detection is disabled. \n+Furthermore, a parameter `clockSkewEventRate` can be used to rate-limit clock skew events.\n+The default is `3600` seconds, so every hour an event will be sent.\n+\n+==== Working with Minions\n+While {opennms-product-name} can operate as both a listener and a parser, Minion cannot.\n+A Minion receives data (listens). \n+Listeners on Minion must use parsers on {opennms-product-name} or Sentinel to process the data. \n+\n+Be aware that", "originalCommit": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE4ODg0NQ==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r446188845", "bodyText": "deleted.", "author": "Bonrob2", "createdAt": "2020-06-26T13:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxNjg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxODg4Nw==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445818887", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.common.parser.ForwardParser\n          \n          \n            \n            admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.bmp.parser.BmpParser", "author": "fooker", "createdAt": "2020-06-25T20:27:57Z", "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/protocols/bmp.adoc", "diffHunk": "@@ -32,6 +32,25 @@ The BMP Parser accepts BMP connections from router packets using a <<telemetryd-\n | `bulkhead.maxWaitDurationMs`  | Limits the amount of time to wait for a saturated bulkhead (in milliseconds). | no       | 5 Minutes\n |===\n \n+===== Configure BMP Listener on a Minion\n+\n+To enable and configure a _TCP Listener_ for BMP on Minion, connect to the _Karaf Console_ and set the following properties:\n+\n+[source]\n+----\n+$ ssh -p 8201 admin@localhost\n+...\n+admin@minion()> config:edit --alias tcp-5000 --factory org.opennms.features.telemetry.listeners\n+admin@minion()> config:property-set name BMP\n+admin@minion()> config:property-set class-name org.opennms.netmgt.telemetry.listeners.TcpListener\n+admin@minion()> config:property-set parameters.port 50000\n+admin@minion()> config:property-set parsers.0.name BMP \n+admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.common.parser.ForwardParser", "originalCommit": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxOTcyNg==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445819726", "bodyText": "Isn't \"timestamp\" a single word as it's used as a technical term?", "author": "fooker", "createdAt": "2020-06-25T20:29:40Z", "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/protocols/ipfix.adoc", "diffHunk": "@@ -25,8 +24,8 @@ The IPFIX UDP Parser supports protocol detection.\n [options=\"header, autowidth\"]\n |===\n | Parameter             | Description                                                                    | Required | Default value\n-| `templateTimeout`     | Templates must be re-declared in the given duration or they will be dropped    | no       | 30 minutes\n-| `maxClockSkew`        | The maximum delta in seconds between exporter and Minion timestamps.       | no       | 0\n+| `templateTimeout`     | Templates must be redeclared in the given duration or they will be dropped.    | no       | 30 minutes\n+| `maxClockSkew`        | The maximum delta in seconds between exporter and Minion time stamps.       | no       | 0", "originalCommit": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5NjQyMQ==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r446196421", "bodyText": "I prefer one word, and that's what the Oxford dictionary specifies, but Webster's has two words. (I've been trying to use one dictionary as a standard, and chose Webster's because it is American.) I'll go back to one word, though, as I see that's what Wikipedia uses and it seems to be industry standard. Thanks for pointing this out.\nNow, if we can persuade the Americans to use Canadian/British spelling I can go back to including the letter \"u\" to words like favourite, labour, arbour, honour, etc. :-)", "author": "Bonrob2", "createdAt": "2020-06-26T13:50:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgxOTcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgyMDA1Ng==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r445820056", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.common.parser.ForwardParser\n          \n          \n            \n            admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.netflow.parser.IpfixTcpParser", "author": "fooker", "createdAt": "2020-06-25T20:30:20Z", "path": "opennms-doc/guide-admin/src/asciidoc/text/telemetryd/protocols/ipfix.adoc", "diffHunk": "@@ -48,12 +47,31 @@ The IPFIX TCP Parser accepts packets received by a <<telemetryd-listener-tcp, TC\n \n This parser does not currently have any configurable parameters.\n \n+===== Configure IPFIX Listener on a Minion\n+\n+To enable and configure a _TCP Listener_ for IPFIX on Minion, connect to the _Karaf Console_ and set the following properties:\n+\n+[source]\n+----\n+$ ssh -p 8201 admin@localhost\n+...\n+admin@minion()> config:edit --alias tcp-5000 --factory org.opennms.features.telemetry.listeners\n+admin@minion()> config:property-set name IPFIX\n+admin@minion()> config:property-set class-name org.opennms.netmgt.telemetry.listeners.TcpListener\n+admin@minion()> config:property-set parameters.port 50000\n+admin@minion()> config:property-set parsers.0.name IPFIX \n+admin@minion()> config:property-set parsers.0.class-name org.opennms.netmgt.telemetry.protocols.common.parser.ForwardParser", "originalCommit": "79b01bdcdde6bef1d7cdac586797ffb85cf5b845", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIzNjEyNg==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r446236126", "bodyText": "to clarify, shouldn't \"netflow\" be \"ipfix\"", "author": "Bonrob2", "createdAt": "2020-06-26T14:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgyMDA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM3MTcyNA==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r446371724", "bodyText": "No, it all sits in the netflow package. Ipfix is netflow v10 but renamed as netflow is a Cisco product and ipfix is an open standard.", "author": "fooker", "createdAt": "2020-06-26T19:31:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgyMDA1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxMjIyNA==", "url": "https://github.com/OpenNMS/opennms/pull/3044#discussion_r446412224", "bodyText": "Ok. Thanks. Updated!", "author": "Bonrob2", "createdAt": "2020-06-26T21:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgyMDA1Ng=="}], "type": "inlineReview"}, {"oid": "35fb26b4841669cf7dc96e532dd26ce9ba241397", "url": "https://github.com/OpenNMS/opennms/commit/35fb26b4841669cf7dc96e532dd26ce9ba241397", "message": "NMS-12736: add docs for TCP listener\n\nNMS-12736: updated tcp listener documentatation based on PR feedback.", "committedDate": "2020-06-26T15:10:23Z", "type": "commit"}, {"oid": "373f959a47be944e737cbb0d9560798da793f55b", "url": "https://github.com/OpenNMS/opennms/commit/373f959a47be944e737cbb0d9560798da793f55b", "message": "NMS-12736: updated developer guide\n\nNMS-12736: updated developer guide to address feedback. Line space break.", "committedDate": "2020-06-26T15:15:34Z", "type": "commit"}, {"oid": "640853180783cb0a14df572e898c9dec1aec311c", "url": "https://github.com/OpenNMS/opennms/commit/640853180783cb0a14df572e898c9dec1aec311c", "message": "NMS-12736:tcplistener doc updates\n\nNMS-12736:tcplistener updates - to address feedback from Dustin.", "committedDate": "2020-06-26T21:11:56Z", "type": "commit"}]}