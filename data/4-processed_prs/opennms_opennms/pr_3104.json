{"pr_number": 3104, "pr_title": "NMS-12676: Basic Service tracker and integration", "pr_createdAt": "2020-08-10T08:25:24Z", "pr_url": "https://github.com/OpenNMS/opennms/pull/3104", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc2NzA1NQ==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r467767055", "bodyText": "typo, missing t in perspectiveLocations", "author": "christianpape", "createdAt": "2020-08-10T08:50:50Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -114,275 +118,347 @@\n     private final MonitoredServiceDao monSvcDao;\n     private final LocationAwarePollerClient locationAwarePollerClient;\n     private final LocationSpecificStatusDao locationSpecificStatusDao;\n+    private final ApplicationDao applicationDao;\n     private final CollectionAgentFactory collectionAgentFactory;\n     private final PersisterFactory persisterFactory;\n     private final EventForwarder eventForwarder;\n     private final ThresholdingService thresholdingService;\n+    private final ServiceTracker<Set<RemotePolledService>> serviceTracker;\n \n-    Scheduler scheduler;\n+    @VisibleForTesting\n+    final Scheduler scheduler;\n \n     public RemotePollerd(final SessionUtils sessionUtils,\n                          final MonitoringLocationDao monitoringLocationDao,\n                          final PollerConfig pollerConfig,\n                          final MonitoredServiceDao monSvcDao,\n                          final LocationAwarePollerClient locationAwarePollerClient,\n                          final LocationSpecificStatusDao locationSpecificStatusDao,\n+                         final ApplicationDao applicationDao,\n                          final CollectionAgentFactory collectionAgentFactory,\n                          final PersisterFactory persisterFactory,\n                          final EventForwarder eventForwarder,\n-                         final ThresholdingService thresholdingService) {\n+                         final ThresholdingService thresholdingService) throws SchedulerException {\n         this.sessionUtils = Objects.requireNonNull(sessionUtils);\n         this.monitoringLocationDao = Objects.requireNonNull(monitoringLocationDao);\n         this.pollerConfig = Objects.requireNonNull(pollerConfig);\n         this.monSvcDao = Objects.requireNonNull(monSvcDao);\n         this.locationAwarePollerClient = Objects.requireNonNull(locationAwarePollerClient);\n         this.locationSpecificStatusDao = Objects.requireNonNull(locationSpecificStatusDao);\n+        this.applicationDao = Objects.requireNonNull(applicationDao);\n         this.collectionAgentFactory = Objects.requireNonNull(collectionAgentFactory);\n         this.persisterFactory = Objects.requireNonNull(persisterFactory);\n         this.eventForwarder = Objects.requireNonNull(eventForwarder);\n         this.thresholdingService = Objects.requireNonNull(thresholdingService);\n-    }\n \n-    @Override\n-    public void start() throws Exception {\n         this.scheduler = new StdSchedulerFactory().getScheduler();\n-        this.scheduler.start();\n-        this.scheduler.getListenerManager().addSchedulerListener(new SchedulerListenerSupport() {\n-            @Override\n-            public void schedulerError(String msg, SchedulerException cause) {\n-                LOG.error(\"Unexpected error during poll: {}\", msg, cause);\n-            }\n-        });\n \n-        this.scheduleAllServices();\n+        this.serviceTracker = new ServiceTracker<>(pollerConfig,\n+                                                   null,\n+                                                   this::filterService,\n+                                                   this::addService,\n+                                                   this::delService);\n     }\n \n-    @Override\n-    public void destroy() throws Exception {\n-        if (this.scheduler != null) {\n-            this.scheduler.shutdown();\n-            this.scheduler = null;\n+    private Optional<Set<RemotePolledService>> filterService(final ServiceTracker.Service service) {\n+        // Get the monitored service entitiy\n+        final OnmsMonitoredService monitoredService = this.monSvcDao.get(service.getNodeId(), service.getIpAddress(), service.getServiceName());\n+        if (monitoredService == null) {\n+            return Optional.empty();\n         }\n-    }\n-    \n-    /**\n-     * One or more polling packages may be assigned to monitoring locations via the UI\n-     * From there we retrieve the matching packages stored in etc/poller-configuration.xml\n-     * Using the package definition, we retrieve all matching ifservices\n-     */\n-    public void scheduleAllServices() {\n-        final Map<String, List<RemotePolledService>> servicesByPackage = new HashMap<>();\n-\n-        LOG.info(\"Scheduling all services...\");\n-        sessionUtils.withReadOnlyTransaction(() -> {\n-            for (OnmsMonitoringLocation location : monitoringLocationDao.findAll()) {\n-                final List<String> pollingPackageNames = new ArrayList(); // TODO: Patrick // location.getPollingPackageNames();\n-                LOG.debug(\"Location '{}' has polling packages: {}\", location.getLocationName(), pollingPackageNames);\n-                for (String pollingPackageName : pollingPackageNames) {\n-                    final List<RemotePolledService> servicesForPackage = servicesByPackage.computeIfAbsent(pollingPackageName, (pkgName) -> getServicesForPackage(location, pkgName));\n-\n-                    for (RemotePolledService polledService : servicesForPackage) {\n-                        try {\n-                            scheduleService(location.getLocationName(), polledService);\n-                        } catch (SchedulerException e) {\n-                            LOG.warn(\"Failed to schedule {}.\", polledService, e);\n-                        }\n-                    }\n-                }\n-            }\n-            return null;\n-        });\n-    }\n \n-    private Map<JobKey, RemotePolledService> getMapOfScheduledServices(final String locationName) {\n-        final Map<JobKey, RemotePolledService> mapOfScheduledServices = new TreeMap<>();\n-        try {\n-            for(final JobKey jobKey : scheduler.getJobKeys(GroupMatcher.jobGroupEquals(locationName))) {\n-                try {\n-                    final JobDetail jobDetail = scheduler.getJobDetail(jobKey);\n-\n-                    if (locationName.equals(jobDetail.getJobDataMap().get(RemotePollJob.LOCATION_NAME)) &&\n-                        jobDetail.getJobDataMap().get(RemotePollJob.REMOTE_POLLER_BACKEND) == this) {\n-                        mapOfScheduledServices.put(jobKey, (RemotePolledService) jobDetail.getJobDataMap().get(RemotePollJob.POLLED_SERVICE));\n-                    }\n-                } catch (SchedulerException e) {\n-                    LOG.warn(\"Failed to retrieve job details {}.\", jobKey, e);\n-                }\n-            }\n-        } catch (SchedulerException e) {\n-            LOG.warn(\"Failed to query scheduled jobs.\", e);\n+        // Get all perspective locations from which the service is monitored via its assigned applications\n+        final List<OnmsMonitoringLocation> perspeciveLocations = this.applicationDao.getPerspeciveLocationsForService(service.getNodeId(), service.getIpAddress(), service.getServiceName());", "originalCommit": "75080f06877767e026473417409c8dd10a6ab162", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc3MDIxOQ==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r467770219", "bodyText": "typo again, prespective -> perspective", "author": "christianpape", "createdAt": "2020-08-10T08:57:10Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -114,275 +118,347 @@\n     private final MonitoredServiceDao monSvcDao;\n     private final LocationAwarePollerClient locationAwarePollerClient;\n     private final LocationSpecificStatusDao locationSpecificStatusDao;\n+    private final ApplicationDao applicationDao;\n     private final CollectionAgentFactory collectionAgentFactory;\n     private final PersisterFactory persisterFactory;\n     private final EventForwarder eventForwarder;\n     private final ThresholdingService thresholdingService;\n+    private final ServiceTracker<Set<RemotePolledService>> serviceTracker;\n \n-    Scheduler scheduler;\n+    @VisibleForTesting\n+    final Scheduler scheduler;\n \n     public RemotePollerd(final SessionUtils sessionUtils,\n                          final MonitoringLocationDao monitoringLocationDao,\n                          final PollerConfig pollerConfig,\n                          final MonitoredServiceDao monSvcDao,\n                          final LocationAwarePollerClient locationAwarePollerClient,\n                          final LocationSpecificStatusDao locationSpecificStatusDao,\n+                         final ApplicationDao applicationDao,\n                          final CollectionAgentFactory collectionAgentFactory,\n                          final PersisterFactory persisterFactory,\n                          final EventForwarder eventForwarder,\n-                         final ThresholdingService thresholdingService) {\n+                         final ThresholdingService thresholdingService) throws SchedulerException {\n         this.sessionUtils = Objects.requireNonNull(sessionUtils);\n         this.monitoringLocationDao = Objects.requireNonNull(monitoringLocationDao);\n         this.pollerConfig = Objects.requireNonNull(pollerConfig);\n         this.monSvcDao = Objects.requireNonNull(monSvcDao);\n         this.locationAwarePollerClient = Objects.requireNonNull(locationAwarePollerClient);\n         this.locationSpecificStatusDao = Objects.requireNonNull(locationSpecificStatusDao);\n+        this.applicationDao = Objects.requireNonNull(applicationDao);\n         this.collectionAgentFactory = Objects.requireNonNull(collectionAgentFactory);\n         this.persisterFactory = Objects.requireNonNull(persisterFactory);\n         this.eventForwarder = Objects.requireNonNull(eventForwarder);\n         this.thresholdingService = Objects.requireNonNull(thresholdingService);\n-    }\n \n-    @Override\n-    public void start() throws Exception {\n         this.scheduler = new StdSchedulerFactory().getScheduler();\n-        this.scheduler.start();\n-        this.scheduler.getListenerManager().addSchedulerListener(new SchedulerListenerSupport() {\n-            @Override\n-            public void schedulerError(String msg, SchedulerException cause) {\n-                LOG.error(\"Unexpected error during poll: {}\", msg, cause);\n-            }\n-        });\n \n-        this.scheduleAllServices();\n+        this.serviceTracker = new ServiceTracker<>(pollerConfig,\n+                                                   null,\n+                                                   this::filterService,\n+                                                   this::addService,\n+                                                   this::delService);\n     }\n \n-    @Override\n-    public void destroy() throws Exception {\n-        if (this.scheduler != null) {\n-            this.scheduler.shutdown();\n-            this.scheduler = null;\n+    private Optional<Set<RemotePolledService>> filterService(final ServiceTracker.Service service) {\n+        // Get the monitored service entitiy\n+        final OnmsMonitoredService monitoredService = this.monSvcDao.get(service.getNodeId(), service.getIpAddress(), service.getServiceName());\n+        if (monitoredService == null) {\n+            return Optional.empty();\n         }\n-    }\n-    \n-    /**\n-     * One or more polling packages may be assigned to monitoring locations via the UI\n-     * From there we retrieve the matching packages stored in etc/poller-configuration.xml\n-     * Using the package definition, we retrieve all matching ifservices\n-     */\n-    public void scheduleAllServices() {\n-        final Map<String, List<RemotePolledService>> servicesByPackage = new HashMap<>();\n-\n-        LOG.info(\"Scheduling all services...\");\n-        sessionUtils.withReadOnlyTransaction(() -> {\n-            for (OnmsMonitoringLocation location : monitoringLocationDao.findAll()) {\n-                final List<String> pollingPackageNames = new ArrayList(); // TODO: Patrick // location.getPollingPackageNames();\n-                LOG.debug(\"Location '{}' has polling packages: {}\", location.getLocationName(), pollingPackageNames);\n-                for (String pollingPackageName : pollingPackageNames) {\n-                    final List<RemotePolledService> servicesForPackage = servicesByPackage.computeIfAbsent(pollingPackageName, (pkgName) -> getServicesForPackage(location, pkgName));\n-\n-                    for (RemotePolledService polledService : servicesForPackage) {\n-                        try {\n-                            scheduleService(location.getLocationName(), polledService);\n-                        } catch (SchedulerException e) {\n-                            LOG.warn(\"Failed to schedule {}.\", polledService, e);\n-                        }\n-                    }\n-                }\n-            }\n-            return null;\n-        });\n-    }\n \n-    private Map<JobKey, RemotePolledService> getMapOfScheduledServices(final String locationName) {\n-        final Map<JobKey, RemotePolledService> mapOfScheduledServices = new TreeMap<>();\n-        try {\n-            for(final JobKey jobKey : scheduler.getJobKeys(GroupMatcher.jobGroupEquals(locationName))) {\n-                try {\n-                    final JobDetail jobDetail = scheduler.getJobDetail(jobKey);\n-\n-                    if (locationName.equals(jobDetail.getJobDataMap().get(RemotePollJob.LOCATION_NAME)) &&\n-                        jobDetail.getJobDataMap().get(RemotePollJob.REMOTE_POLLER_BACKEND) == this) {\n-                        mapOfScheduledServices.put(jobKey, (RemotePolledService) jobDetail.getJobDataMap().get(RemotePollJob.POLLED_SERVICE));\n-                    }\n-                } catch (SchedulerException e) {\n-                    LOG.warn(\"Failed to retrieve job details {}.\", jobKey, e);\n-                }\n-            }\n-        } catch (SchedulerException e) {\n-            LOG.warn(\"Failed to query scheduled jobs.\", e);\n+        // Get all perspective locations from which the service is monitored via its assigned applications\n+        final List<OnmsMonitoringLocation> perspeciveLocations = this.applicationDao.getPerspeciveLocationsForService(service.getNodeId(), service.getIpAddress(), service.getServiceName());\n+        if (perspeciveLocations.isEmpty()) {\n+            return Optional.empty();\n         }\n \n-        return mapOfScheduledServices;\n-    }\n-\n-    // TODO: Patrick: should this be updateScheduledServicesForApplication() going forward?\n-    private void updateScheduledServicesForLocation(final OnmsMonitoringLocation location) {\n-        final List<String> pollingPackageNames =new ArrayList(); // TODO: Patrick // location.getPollingPackageNames();\n-        final Map<String, List<RemotePolledService>> servicesByPackage = new HashMap<>();\n-        LOG.debug(\"Location '{}' has polling packages: {}\", location.getLocationName(), pollingPackageNames);\n-\n-        final Set<RemotePolledService> servicesToBeScheduled = new HashSet<>();\n-\n-        for (final String pollingPackageName : pollingPackageNames) {\n-            servicesToBeScheduled.addAll(servicesByPackage.computeIfAbsent(pollingPackageName, (pkgName) -> getServicesForPackage(location, pkgName)));\n+        // Get the polling package for the service\n+        final Package pkg = this.pollerConfig.getFirstRemotePackageMatch(InetAddressUtils.str(service.getIpAddress()));\n+        if (pkg == null) {\n+            return Optional.empty();\n         }\n \n-        final Map<JobKey, RemotePolledService> mapOfScheduledServices = getMapOfScheduledServices(location.getLocationName());\n-        final Set<RemotePolledService> scheduledServices = mapOfScheduledServices.entrySet().stream().map(e -> e.getValue()).collect(Collectors.toSet());\n-\n-        // remove services that will not be scheduled anymore\n-        for (final Map.Entry<JobKey, RemotePolledService> entry : mapOfScheduledServices.entrySet()) {\n-            if (!servicesToBeScheduled.contains(entry.getValue())) {\n-                try {\n-                    scheduler.deleteJob(entry.getKey());\n-                } catch (SchedulerException e) {\n-                    LOG.warn(\"Failed to delete job {} for service {}.\", entry.getKey(), entry.getValue(), e);\n-                }\n-            }\n+        // Find the service (and the pattern parameters) for the service name\n+        final Optional<Package.ServiceMatch> serviceMatch = pkg.findService(service.getServiceName());\n+        if (!serviceMatch.isPresent()) {\n+            return Optional.empty();\n         }\n \n-        // add missing services that are not scheduled yet\n-        for (final RemotePolledService polledService : servicesToBeScheduled) {\n-            if (!scheduledServices.contains(polledService)) {\n-                try {\n-                    scheduleService(location.getLocationName(), polledService);\n-                } catch (SchedulerException e) {\n-                    LOG.warn(\"Failed to schedule {}.\", polledService, e);\n-                }\n-            }\n+        // Find the monitor implementation for the service name\n+        final ServiceMonitor serviceMonitor = this.pollerConfig.getServiceMonitor(serviceMatch.get().service.getName());\n+        if (serviceMonitor == null) {\n+            return Optional.empty();\n         }\n+\n+        // Build remote polled services for each location\n+        return Optional.of(perspeciveLocations.stream()\n+                                              .map(OnmsMonitoringLocation::getLocationName)\n+                                              .map(perspectiveLocation -> new RemotePolledService(monitoredService,\n+                                                                                                  pkg,\n+                                                                                                  serviceMatch.get(),\n+                                                                                                  serviceMonitor,\n+                                                                                                  perspectiveLocation))\n+                          .collect(Collectors.toSet()));\n     }\n \n-    public void handleConfigurationChangedForLocation(final String locationName) {\n-        LOG.info(\"Re-scheduling all services for location '{}'...\", locationName);\n+    private void addService(final ServiceTracker.ServiceEntry<Set<RemotePolledService>> entry) {\n+        entry.getElement().forEach(remotePolledService -> {\n+            final JobKey key = buildJobKey(remotePolledService);\n+\n+            final JobDetail job = JobBuilder\n+                    .newJob(RemotePollJob.class)\n+                    .withIdentity(key)\n+                    .setJobData(new JobDataMap(ImmutableMap.builder()\n+                                                           .put(RemotePollJob.POLLED_SERVICE, remotePolledService)\n+                                                           .put(RemotePollJob.REMOTE_POLLER_BACKEND, this)\n+                                                           .build()))\n+                    .build();\n+\n+            final Trigger trigger = TriggerBuilder\n+                    .newTrigger()\n+                    .withSchedule(SimpleScheduleBuilder.simpleSchedule()\n+                                                       .withIntervalInMilliseconds(remotePolledService.getService().getInterval())\n+                                                       .repeatForever())\n+                    .build();\n+\n+            LOG.debug(\"Scheduling service named {} at location {} with interval {}ms\", remotePolledService.getService().getName(),\n+                      remotePolledService.getPerspectiveLocation(), remotePolledService.getService().getInterval());\n \n-        sessionUtils.withReadOnlyTransaction(() -> {\n-            updateScheduledServicesForLocation(monitoringLocationDao.get(locationName));\n-            return null;\n+            try {\n+                this.scheduler.scheduleJob(job, trigger);\n+            } catch (final SchedulerException e) {\n+                LOG.error(\"Failed to schedule {} ({}).\", remotePolledService, key, e);\n+            }\n         });\n     }\n \n+    private void delService(final ServiceTracker.ServiceEntry<Set<RemotePolledService>> entry) {\n+        entry.getElement().forEach(remotePolledService -> {\n+            final JobKey key = buildJobKey(remotePolledService);\n \n-    public void handleConfigurationChanged() {\n-        try {\n-            this.pollerConfig.update();\n-        } catch (IOException e) {\n-            LOG.warn(\"Error reloading poller-configuration.xml\");\n-        }\n-\n-        LOG.info(\"Re-scheduling all services...\");\n-        sessionUtils.withReadOnlyTransaction(() -> {\n-            for (final OnmsMonitoringLocation location : monitoringLocationDao.findAll()) {\n-                updateScheduledServicesForLocation(location);\n+            try {\n+                this.scheduler.deleteJob(key);\n+            } catch (final SchedulerException e) {\n+                LOG.error(\"Failed to un-schedule {} ({}).\", remotePolledService, key, e);\n             }\n-            return null;\n         });\n     }\n+    \n+    @Override\n+    public void start() throws Exception {\n+        this.serviceTracker.start();\n \n-    private static String getJobIdentity(RemotePolledService polledService) {\n-        return String.format(\"job-%s-%s\", polledService.getPkg().getName(), polledService.getMonSvc().getId());\n-    }\n+        this.scheduler.start();\n+        this.scheduler.getListenerManager().addSchedulerListener(new SchedulerListenerSupport() {\n+            @Override\n+            public void schedulerError(String msg, SchedulerException cause) {\n+                LOG.error(\"Unexpected error during poll: {}\", msg, cause);\n+            }\n+        });\n \n-    private static String getTriggerIdentity(RemotePolledService polledService) {\n-        return String.format(\"trigger-%s-%s\", polledService.getPkg().getName(), polledService.getMonSvc().getId());\n     }\n \n-    private void scheduleService(String locationName, RemotePolledService polledService) throws SchedulerException {\n-        JobDetail job = JobBuilder\n-                .newJob(RemotePollJob.class)\n-                .withIdentity(getJobIdentity(polledService), locationName)\n-                .build();\n-\n-        job.getJobDataMap().put(RemotePollJob.LOCATION_NAME, locationName);\n-        job.getJobDataMap().put(RemotePollJob.POLLED_SERVICE, polledService);\n-        job.getJobDataMap().put(RemotePollJob.REMOTE_POLLER_BACKEND, this);\n-\n-        Trigger trigger = TriggerBuilder\n-                .newTrigger()\n-                .withIdentity(getTriggerIdentity(polledService), locationName)\n-                .withSchedule(SimpleScheduleBuilder.simpleSchedule()\n-                        .withIntervalInMilliseconds(polledService.getService().getInterval())\n-                        .repeatForever())\n-                .build();\n-\n-        LOG.debug(\"Scheduling service named {} at location {} with interval {}ms\", polledService.getService().getName(),\n-                locationName, polledService.getService().getInterval());\n-        scheduler.scheduleJob(job, trigger);\n+    @Override\n+    public void destroy() throws Exception {\n+        if (this.scheduler != null) {\n+            this.scheduler.shutdown();\n+        }\n+    }\n+    \n+//    /**\n+//     * One or more polling packages may be assigned to monitoring locations via the UI\n+//     * From there we retrieve the matching packages stored in etc/poller-configuration.xml\n+//     * Using the package definition, we retrieve all matching ifservices\n+//     */\n+//    public void scheduleAllServices() {\n+//        final Map<String, List<RemotePolledService>> servicesByPackage = new HashMap<>();\n+//\n+//        LOG.info(\"Scheduling all services...\");\n+//        sessionUtils.withReadOnlyTransaction(() -> {\n+//            for (OnmsMonitoringLocation location : monitoringLocationDao.findAll()) {\n+//                final List<String> pollingPackageNames = new ArrayList(); // TODO: Patrick // location.getPollingPackageNames();\n+//                LOG.debug(\"Location '{}' has polling packages: {}\", location.getLocationName(), pollingPackageNames);\n+//                for (String pollingPackageName : pollingPackageNames) {\n+//                    final List<RemotePolledService> servicesForPackage = servicesByPackage.computeIfAbsent(pollingPackageName, (pkgName) -> getServicesForPackage(location, pkgName));\n+//\n+//                    for (RemotePolledService polledService : servicesForPackage) {\n+//                        try {\n+//                            scheduleService(location.getLocationName(), polledService);\n+//                        } catch (SchedulerException e) {\n+//                            LOG.warn(\"Failed to schedule {}.\", polledService, e);\n+//                        }\n+//                    }\n+//                }\n+//            }\n+//            return null;\n+//        });\n+//    }\n+//\n+//    private Map<JobKey, RemotePolledService> getMapOfScheduledServices(final String locationName) {\n+//        final Map<JobKey, RemotePolledService> mapOfScheduledServices = new TreeMap<>();\n+//        try {\n+//            for(final JobKey jobKey : scheduler.getJobKeys(GroupMatcher.jobGroupEquals(locationName))) {\n+//                try {\n+//                    final JobDetail jobDetail = scheduler.getJobDetail(jobKey);\n+//\n+//                    if (locationName.equals(jobDetail.getJobDataMap().get(RemotePollJob.LOCATION_NAME)) &&\n+//                        jobDetail.getJobDataMap().get(RemotePollJob.REMOTE_POLLER_BACKEND) == this) {\n+//                        mapOfScheduledServices.put(jobKey, (RemotePolledService) jobDetail.getJobDataMap().get(RemotePollJob.POLLED_SERVICE));\n+//                    }\n+//                } catch (SchedulerException e) {\n+//                    LOG.warn(\"Failed to retrieve job details {}.\", jobKey, e);\n+//                }\n+//            }\n+//        } catch (SchedulerException e) {\n+//            LOG.warn(\"Failed to query scheduled jobs.\", e);\n+//        }\n+//\n+//        return mapOfScheduledServices;\n+//    }\n+//\n+//    // TODO: Patrick: should this be updateScheduledServicesForApplication() going forward?\n+//    private void updateScheduledServicesForLocation(final OnmsMonitoringLocation location) {\n+//        final List<String> pollingPackageNames =new ArrayList(); // TODO: Patrick // location.getPollingPackageNames();\n+//        final Map<String, List<RemotePolledService>> servicesByPackage = new HashMap<>();\n+//        LOG.debug(\"Location '{}' has polling packages: {}\", location.getLocationName(), pollingPackageNames);\n+//\n+//        final Set<RemotePolledService> servicesToBeScheduled = new HashSet<>();\n+//\n+//        for (final String pollingPackageName : pollingPackageNames) {\n+//            servicesToBeScheduled.addAll(servicesByPackage.computeIfAbsent(pollingPackageName, (pkgName) -> getServicesForPackage(location, pkgName)));\n+//        }\n+//\n+//        final Map<JobKey, RemotePolledService> mapOfScheduledServices = getMapOfScheduledServices(location.getLocationName());\n+//        final Set<RemotePolledService> scheduledServices = mapOfScheduledServices.entrySet().stream().map(e -> e.getValue()).collect(Collectors.toSet());\n+//\n+//        // remove services that will not be scheduled anymore\n+//        for (final Map.Entry<JobKey, RemotePolledService> entry : mapOfScheduledServices.entrySet()) {\n+//            if (!servicesToBeScheduled.contains(entry.getValue())) {\n+//                try {\n+//                    scheduler.deleteJob(entry.getKey());\n+//                } catch (SchedulerException e) {\n+//                    LOG.warn(\"Failed to delete job {} for service {}.\", entry.getKey(), entry.getValue(), e);\n+//                }\n+//            }\n+//        }\n+//\n+//        // add missing services that are not scheduled yet\n+//        for (final RemotePolledService polledService : servicesToBeScheduled) {\n+//            if (!scheduledServices.contains(polledService)) {\n+//                try {\n+//                    scheduleService(location.getLocationName(), polledService);\n+//                } catch (SchedulerException e) {\n+//                    LOG.warn(\"Failed to schedule {}.\", polledService, e);\n+//                }\n+//            }\n+//        }\n+//    }\n+//\n+//    public void handleConfigurationChangedForLocation(final String locationName) {\n+//        LOG.info(\"Re-scheduling all services for location '{}'...\", locationName);\n+//\n+//        sessionUtils.withReadOnlyTransaction(() -> {\n+//            updateScheduledServicesForLocation(monitoringLocationDao.get(locationName));\n+//            return null;\n+//        });\n+//    }\n+//\n+//\n+//    public void handleConfigurationChanged() {\n+//        try {\n+//            this.pollerConfig.update();\n+//        } catch (IOException e) {\n+//            LOG.warn(\"Error reloading poller-configuration.xml\");\n+//        }\n+//\n+//        LOG.info(\"Re-scheduling all services...\");\n+//        sessionUtils.withReadOnlyTransaction(() -> {\n+//            for (final OnmsMonitoringLocation location : monitoringLocationDao.findAll()) {\n+//                updateScheduledServicesForLocation(location);\n+//            }\n+//            return null;\n+//        });\n+//    }\n+\n+    private static JobKey buildJobKey(RemotePolledService remotePolledService) {\n+        final String name = String.format(\"prespective-%s-%s-%s\", remotePolledService.getPkg().getName(), remotePolledService.getMonSvc().getId(), remotePolledService.getPerspectiveLocation());", "originalCommit": "75080f06877767e026473417409c8dd10a6ab162", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc3Mjg4Mg==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r467772882", "bodyText": "typo, Perspecive -> Perspective", "author": "christianpape", "createdAt": "2020-08-10T09:02:19Z", "path": "opennms-dao-api/src/main/java/org/opennms/netmgt/dao/api/ApplicationDao.java", "diffHunk": "@@ -70,4 +73,6 @@\n     List<MonitoredServiceStatusEntity> getAlarmStatus();\n \n     List<MonitoredServiceStatusEntity> getAlarmStatus(List<OnmsApplication> applications);\n+\n+    List<OnmsMonitoringLocation> getPerspeciveLocationsForService(final int nodeId, final InetAddress ipAddress, final String serviceName);", "originalCommit": "75080f06877767e026473417409c8dd10a6ab162", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzc4MjU5OQ==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r467782599", "bodyText": "typo", "author": "christianpape", "createdAt": "2020-08-10T09:21:54Z", "path": "opennms-dao/src/main/java/org/opennms/netmgt/dao/hibernate/ApplicationDaoHibernate.java", "diffHunk": "@@ -145,4 +147,15 @@ public OnmsApplication findByName(final String name) {\n \t\t}\n \t\treturn entityList;\n \t}\n+\n+\tpublic List<OnmsMonitoringLocation> getPerspeciveLocationsForService(final int nodeId, final InetAddress ipAddress, final String serviceName) {\n+\t\treturn (List<OnmsMonitoringLocation>) getHibernateTemplate().find(\"select distinct perspeciveLocation \" +\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \"from OnmsMonitoredService service \" +\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \"join service.applications application \" +\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \"join application.perspectiveLocations perspeciveLocation \" +", "originalCommit": "75080f06877767e026473417409c8dd10a6ab162", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b1514c9e1414d0cd325a23a4a8d44292aad6801", "url": "https://github.com/OpenNMS/opennms/commit/3b1514c9e1414d0cd325a23a4a8d44292aad6801", "message": "NMS-12676: Some progress", "committedDate": "2020-08-14T10:46:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxMzAyNw==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r470713027", "bodyText": "why not deleteService()?", "author": "patrick-schweizer", "createdAt": "2020-08-14T15:58:15Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -118,336 +117,253 @@\n     private final SessionUtils sessionUtils;\n     private final MonitoringLocationDao monitoringLocationDao;\n     private final PollerConfig pollerConfig;\n-    private final MonitoredServiceDao monSvcDao;\n+    private final MonitoredServiceDao monitoredServiceDao;\n     private final LocationAwarePollerClient locationAwarePollerClient;\n     private final LocationSpecificStatusDao locationSpecificStatusDao;\n+    private final ApplicationDao applicationDao;\n     private final CollectionAgentFactory collectionAgentFactory;\n     private final PersisterFactory persisterFactory;\n     private final EventForwarder eventForwarder;\n     private final ThresholdingService thresholdingService;\n     private final EventDao eventDao;\n     private final OutageDao outageDao;\n \n-    Scheduler scheduler;\n+    private final ServiceTracker<Set<RemotePolledService>> serviceTracker;\n+\n+    @VisibleForTesting\n+    final Scheduler scheduler;\n \n     public RemotePollerd(final SessionUtils sessionUtils,\n                          final MonitoringLocationDao monitoringLocationDao,\n                          final PollerConfig pollerConfig,\n-                         final MonitoredServiceDao monSvcDao,\n+                         final MonitoredServiceDao monitoredServiceDao,\n                          final LocationAwarePollerClient locationAwarePollerClient,\n                          final LocationSpecificStatusDao locationSpecificStatusDao,\n+                         final ApplicationDao applicationDao,\n                          final CollectionAgentFactory collectionAgentFactory,\n                          final PersisterFactory persisterFactory,\n                          final EventForwarder eventForwarder,\n                          final ThresholdingService thresholdingService,\n                          final EventDao eventDao,\n-                         final OutageDao outageDao) {\n+                         final OutageDao outageDao) throws SchedulerException {\n         this.sessionUtils = Objects.requireNonNull(sessionUtils);\n         this.monitoringLocationDao = Objects.requireNonNull(monitoringLocationDao);\n         this.pollerConfig = Objects.requireNonNull(pollerConfig);\n-        this.monSvcDao = Objects.requireNonNull(monSvcDao);\n+        this.monitoredServiceDao = Objects.requireNonNull(monitoredServiceDao);\n         this.locationAwarePollerClient = Objects.requireNonNull(locationAwarePollerClient);\n         this.locationSpecificStatusDao = Objects.requireNonNull(locationSpecificStatusDao);\n+        this.applicationDao = Objects.requireNonNull(applicationDao);\n         this.collectionAgentFactory = Objects.requireNonNull(collectionAgentFactory);\n         this.persisterFactory = Objects.requireNonNull(persisterFactory);\n         this.eventForwarder = Objects.requireNonNull(eventForwarder);\n         this.thresholdingService = Objects.requireNonNull(thresholdingService);\n         this.eventDao = Objects.requireNonNull(eventDao);\n         this.outageDao = Objects.requireNonNull(outageDao);\n-    }\n \n-    @Override\n-    public void start() throws Exception {\n         this.scheduler = new StdSchedulerFactory().getScheduler();\n-        this.scheduler.start();\n-        this.scheduler.getListenerManager().addSchedulerListener(new SchedulerListenerSupport() {\n-            @Override\n-            public void schedulerError(String msg, SchedulerException cause) {\n-                LOG.error(\"Unexpected error during poll: {}\", msg, cause);\n-            }\n-        });\n \n-        this.scheduleAllServices();\n+        this.serviceTracker = new ServiceTracker<>(pollerConfig,\n+                                                   new QueryManager(this.monitoredServiceDao),\n+                                                   this::filterService,\n+                                                   this::addService,\n+                                                   this::delService);\n     }\n \n-    @Override\n-    public void destroy() throws Exception {\n-        if (this.scheduler != null) {\n-            this.scheduler.shutdown();\n-            this.scheduler = null;\n-        }\n-    }\n-    \n-    /**\n-     * One or more polling packages may be assigned to monitoring locations via the UI\n-     * From there we retrieve the matching packages stored in etc/poller-configuration.xml\n-     * Using the package definition, we retrieve all matching ifservices\n-     */\n-    public void scheduleAllServices() {\n-        final Map<String, List<RemotePolledService>> servicesByPackage = new HashMap<>();\n-\n-        LOG.info(\"Scheduling all services...\");\n-        sessionUtils.withReadOnlyTransaction(() -> {\n-            for (OnmsMonitoringLocation location : monitoringLocationDao.findAll()) {\n-                final List<String> pollingPackageNames = new ArrayList(); // TODO: Patrick // location.getPollingPackageNames();\n-                LOG.debug(\"Location '{}' has polling packages: {}\", location.getLocationName(), pollingPackageNames);\n-                for (String pollingPackageName : pollingPackageNames) {\n-                    final List<RemotePolledService> servicesForPackage = servicesByPackage.computeIfAbsent(pollingPackageName, (pkgName) -> getServicesForPackage(location, pkgName));\n-\n-                    for (RemotePolledService polledService : servicesForPackage) {\n-                        try {\n-                            scheduleService(location.getLocationName(), polledService);\n-                        } catch (SchedulerException e) {\n-                            LOG.warn(\"Failed to schedule {}.\", polledService, e);\n-                        }\n-                    }\n-                }\n+    private Optional<Set<RemotePolledService>> filterService(final ServiceTracker.Service service) {\n+        return this.sessionUtils.withReadOnlyTransaction(() -> {\n+            // Get the monitored service entitiy\n+            final OnmsMonitoredService monitoredService = this.monitoredServiceDao.get(service.nodeId, service.ipAddress, service.serviceName);\n+            if (monitoredService == null) {\n+                return Optional.empty();\n             }\n-            return null;\n-        });\n-    }\n \n-    private Map<JobKey, RemotePolledService> getMapOfScheduledServices(final String locationName) {\n-        final Map<JobKey, RemotePolledService> mapOfScheduledServices = new TreeMap<>();\n-        try {\n-            for(final JobKey jobKey : scheduler.getJobKeys(GroupMatcher.jobGroupEquals(locationName))) {\n-                try {\n-                    final JobDetail jobDetail = scheduler.getJobDetail(jobKey);\n-\n-                    if (locationName.equals(jobDetail.getJobDataMap().get(RemotePollJob.LOCATION_NAME)) &&\n-                        jobDetail.getJobDataMap().get(RemotePollJob.REMOTE_POLLER_BACKEND) == this) {\n-                        mapOfScheduledServices.put(jobKey, (RemotePolledService) jobDetail.getJobDataMap().get(RemotePollJob.POLLED_SERVICE));\n-                    }\n-                } catch (SchedulerException e) {\n-                    LOG.warn(\"Failed to retrieve job details {}.\", jobKey, e);\n-                }\n+            final OnmsIpInterface ipInterface = monitoredService.getIpInterface();\n+            final OnmsNode node = ipInterface.getNode();\n+\n+            // Get all perspective locations from which the service is monitored via its assigned applications\n+            final List<OnmsMonitoringLocation> perspectiveLocations = this.applicationDao.getPerspectiveLocationsForService(service.nodeId, service.ipAddress, service.serviceName);\n+            if (perspectiveLocations.isEmpty()) {\n+                return Optional.empty();\n             }\n-        } catch (SchedulerException e) {\n-            LOG.warn(\"Failed to query scheduled jobs.\", e);\n-        }\n \n-        return mapOfScheduledServices;\n-    }\n+            // Get the polling package for the service\n+            final Package pkg = this.pollerConfig.getFirstRemotePackageMatch(InetAddressUtils.str(service.ipAddress));\n+            if (pkg == null) {\n+                return Optional.empty();\n+            }\n \n-    // TODO: Patrick: should this be updateScheduledServicesForApplication() going forward?\n-    private void updateScheduledServicesForLocation(final OnmsMonitoringLocation location) {\n-        final List<String> pollingPackageNames =new ArrayList(); // TODO: Patrick // location.getPollingPackageNames();\n-        final Map<String, List<RemotePolledService>> servicesByPackage = new HashMap<>();\n-        LOG.debug(\"Location '{}' has polling packages: {}\", location.getLocationName(), pollingPackageNames);\n+            // Find the service (and the pattern parameters) for the service name\n+            final Optional<Package.ServiceMatch> serviceMatch = pkg.findService(service.serviceName);\n+            if (!serviceMatch.isPresent()) {\n+                return Optional.empty();\n+            }\n \n-        final Set<RemotePolledService> servicesToBeScheduled = new HashSet<>();\n+            // Find the monitor implementation for the service name\n+            final ServiceMonitor serviceMonitor = this.pollerConfig.getServiceMonitor(serviceMatch.get().service.getName());\n+            if (serviceMonitor == null) {\n+                return Optional.empty();\n+            }\n \n-        for (final String pollingPackageName : pollingPackageNames) {\n-            servicesToBeScheduled.addAll(servicesByPackage.computeIfAbsent(pollingPackageName, (pkgName) -> getServicesForPackage(location, pkgName)));\n-        }\n+            final RrdRepository rrdRepository = new RrdRepository();\n+            rrdRepository.setStep(this.pollerConfig.getStep(pkg));\n+            rrdRepository.setHeartBeat(rrdRepository.getStep() * 2);\n+            rrdRepository.setRraList(this.pollerConfig.getRRAList(pkg));\n \n-        final Map<JobKey, RemotePolledService> mapOfScheduledServices = getMapOfScheduledServices(location.getLocationName());\n-        final Set<RemotePolledService> scheduledServices = mapOfScheduledServices.entrySet().stream().map(e -> e.getValue()).collect(Collectors.toSet());\n+            final String rrdRepositoryDir = getServiceParameter(serviceMatch.get().service, \"rrd-repository\");\n+            rrdRepository.setRrdBaseDir(new File(rrdRepositoryDir));\n \n-        // remove services that will not be scheduled anymore\n-        for (final Map.Entry<JobKey, RemotePolledService> entry : mapOfScheduledServices.entrySet()) {\n-            if (!servicesToBeScheduled.contains(entry.getValue())) {\n-                try {\n-                    scheduler.deleteJob(entry.getKey());\n-                } catch (SchedulerException e) {\n-                    LOG.warn(\"Failed to delete job {} for service {}.\", entry.getKey(), entry.getValue(), e);\n-                }\n+            // Create the thresholding session for this poller\n+            final ThresholdingSession thresholdingSession;\n+            try {\n+                thresholdingSession = this.thresholdingService.createSession(service.nodeId,\n+                                                                             InetAddressUtils.str(service.ipAddress),\n+                                                                             service.serviceName,\n+                                                                             rrdRepository,\n+                                                                             new ServiceParameters(Collections.emptyMap()));\n+            } catch (final ThresholdInitializationException e) {\n+                LOG.error(\"Failed to create thresholding session\", e);\n+                return Optional.empty();\n             }\n-        }\n \n-        // add missing services that are not scheduled yet\n-        for (final RemotePolledService polledService : servicesToBeScheduled) {\n-            if (!scheduledServices.contains(polledService)) {\n-                try {\n-                    scheduleService(location.getLocationName(), polledService);\n-                } catch (SchedulerException e) {\n-                    LOG.warn(\"Failed to schedule {}.\", polledService, e);\n-                }\n-            }\n-        }\n+            // Build remote polled services for each location\n+            return Optional.of(perspectiveLocations.stream()\n+                                                   .map(OnmsMonitoringLocation::getLocationName)\n+                                                   .map(perspectiveLocation -> new RemotePolledService(service,\n+                                                                                                       node.getForeignSource(),\n+                                                                                                       node.getForeignId(),\n+                                                                                                       node.getLabel(),\n+                                                                                                       pkg,\n+                                                                                                       serviceMatch.get(),\n+                                                                                                       serviceMonitor,\n+                                                                                                       perspectiveLocation,\n+                                                                                                       node.getLocation().getLocationName(),\n+                                                                                                       rrdRepository,\n+                                                                                                       thresholdingSession))\n+                                                   .collect(Collectors.toSet()));\n+        });\n     }\n \n-    public void handleConfigurationChangedForLocation(final String locationName) {\n-        LOG.info(\"Re-scheduling all services for location '{}'...\", locationName);\n+    private void addService(final ServiceTracker.ServiceEntry<Set<RemotePolledService>> entry) {\n+        entry.getElement().forEach(remotePolledService -> {\n+            final JobKey key = buildJobKey(remotePolledService);\n+\n+            final JobDetail job = JobBuilder\n+                    .newJob(RemotePollJob.class)\n+                    .withIdentity(key)\n+                    .setJobData(new JobDataMap(ImmutableMap.builder()\n+                                                           .put(RemotePollJob.POLLED_SERVICE, remotePolledService)\n+                                                           .put(RemotePollJob.REMOTE_POLLER_BACKEND, this)\n+                                                           .build()))\n+                    .build();\n+\n+            final Trigger trigger = TriggerBuilder\n+                    .newTrigger()\n+                    .withSchedule(SimpleScheduleBuilder.simpleSchedule()\n+                                                       .withIntervalInMilliseconds(remotePolledService.getServiceConfig().getInterval())\n+                                                       .repeatForever())\n+                    .build();\n+\n+            LOG.debug(\"Scheduling service named {} at location {} with interval {}ms\", remotePolledService.getServiceName(),\n+                      remotePolledService.getPerspectiveLocation(), remotePolledService.getServiceConfig().getInterval());\n \n-        sessionUtils.withReadOnlyTransaction(() -> {\n-            updateScheduledServicesForLocation(monitoringLocationDao.get(locationName));\n-            return null;\n+            try {\n+                this.scheduler.scheduleJob(job, trigger);\n+            } catch (final SchedulerException e) {\n+                LOG.error(\"Failed to schedule {} ({}).\", remotePolledService, key, e);\n+            }\n         });\n     }\n \n+    private void delService(final ServiceTracker.ServiceEntry<Set<RemotePolledService>> entry) {", "originalCommit": "73d5600b5b3a02d81f6d6cc1a2c90e37f9ce5ac0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc3MzIyOQ==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r470773229", "bodyText": "I agree, call it deleteService() or removeService()", "author": "christianpape", "createdAt": "2020-08-14T17:59:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcxMzAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczODMwOQ==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r470738309", "bodyText": "+1 on using readable variables - makes the code much easier to read...", "author": "patrick-schweizer", "createdAt": "2020-08-14T16:48:00Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/RemotePollerd.java", "diffHunk": "@@ -483,16 +399,20 @@ public void saveResponseTimeData(final String locationName, final RemotePolledSe\n         final CollectionSetDTO collectionSetDTO = collectionSetBuilder.build();\n \n         collectionSetDTO.visit(this.persisterFactory.createPersister(new ServiceParameters(Collections.emptyMap()),\n-                                                                         repository,\n+                                                                         polledService.getRrdRepository(),\n                                                                          false,\n                                                                          true,\n                                                                          true));\n \n-        remotePolledService.applyThresholds(thresholdingService, collectionSetDTO, remotePolledService.getMonitoredService(), dsName, repository);\n+        try {\n+            polledService.getThresholdingSession().accept(collectionSetDTO);\n+        } catch (final Throwable e) {\n+            LOG.error(\"Failed to threshold on {} for {} because of an exception\", polledService, dsName, e);\n+        }\n     }\n \n-    private String getServiceParameter(final Service svc, final String key) {\n-        for(final Parameter parm : pollerConfig.parameters(svc)) {\n+    private String getServiceParameter(final Service service, final String key) {", "originalCommit": "73d5600b5b3a02d81f6d6cc1a2c90e37f9ce5ac0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczOTM0NA==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r470739344", "bodyText": "there are quite some lines of commented code in this class. Not sure if you want to remove right away or do you still need it for a later refactoring?", "author": "patrick-schweizer", "createdAt": "2020-08-14T16:49:56Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/ServiceTracker.java", "diffHunk": "@@ -0,0 +1,483 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2002-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.remotepollerng;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.opennms.core.utils.ConfigFileConstants;\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.config.PollerConfig;\n+import org.opennms.netmgt.events.api.EventConstants;\n+import org.opennms.netmgt.events.api.ThreadAwareEventListener;\n+import org.opennms.netmgt.events.api.annotations.EventHandler;\n+import org.opennms.netmgt.events.api.annotations.EventListener;\n+import org.opennms.netmgt.events.api.model.IEvent;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+@EventListener(name = \"remotepollerd\")\n+public final class ServiceTracker<E> implements ThreadAwareEventListener {\n+    private static final Logger LOG = LoggerFactory.getLogger(ServiceTracker.class);\n+\n+    private final PollerConfig config;\n+\n+    private final QueryManager queryManager;\n+\n+    private final Network<E> network;\n+\n+    private final Function<Service, Optional<E>> filterService;\n+\n+    private final Consumer<ServiceEntry<E>> addService;\n+    private final Consumer<ServiceEntry<E>> delService;\n+\n+    public ServiceTracker(final PollerConfig config,\n+                          final QueryManager queryManager,\n+                          final Function<Service, Optional<E>> filterService,\n+                          final Consumer<ServiceEntry<E>> addService,\n+                          final Consumer<ServiceEntry<E>> delService) {\n+        this.config = Objects.requireNonNull(config);\n+        this.queryManager = Objects.requireNonNull(queryManager);\n+        this.network = new Network<>();\n+        this.filterService = Objects.requireNonNull(filterService);\n+        this.addService = Objects.requireNonNull(addService);\n+        this.delService = Objects.requireNonNull(delService);\n+    }\n+\n+    public void start() {\n+        // Build initial network\n+        for (final Service service : this.queryManager.findServices()) {\n+            final Optional<E> element = this.filterService.apply(service);\n+            if (!element.isPresent()) { // TODO fooker: this smells\n+                continue;\n+            }\n+\n+            if (this.network.add(service, element.get())) {\n+                this.addService.accept(new ServiceEntry<>(service, element.get())); // TODO fooker: this smells\n+            } else {\n+                LOG.debug(\"Service already known: {}\", service);\n+                throw new IllegalStateException();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int getNumThreads() {\n+        // TODO fooker: Make this configurable as in Alarmd?\n+        return 1;\n+    }\n+\n+    private void rescheduleNodeServices(final IEvent event, final boolean rescheduleExisting) {\n+        final Node node = Node.fromEvent(event);\n+\n+        this.config.rebuildPackageIpListMap();\n+        this.serviceReschedule(node, rescheduleExisting);\n+    }\n+\n+    public void rescheduleAllServices() {\n+        this.config.rebuildPackageIpListMap();\n+\n+        this.network.nodes().forEach(node -> this.serviceReschedule(node, true));\n+    }\n+\n+    private void serviceReschedule(final Node node,\n+                                   final boolean rescheduleExisting) {\n+//        Date closeDate = sourceEvent.getTime();\n+\n+        final Set<Service> databaseServices = Sets.newHashSet(this.queryManager.findServicesByNode(node));\n+        final Set<Service> trackedServices = this.network.findByNode(node).map(ServiceEntry::getService).collect(Collectors.toSet());\n+\n+        // Remove the services being tracked but not in database\n+        for (final Service service : Sets.difference(trackedServices, databaseServices)) {\n+            this.network.remove(service)\n+                        .ifPresent(this.delService);\n+\n+            // this.getQueryManager().closeOutagesForService(sourceEvent, nodeId, closeDate, polledService);\n+        }\n+\n+        // Remove remaining services if existing services should be rescheduled\n+        if (rescheduleExisting) {\n+            for (final Service service : trackedServices) {\n+                this.network.remove(service)\n+                            .ifPresent(this.delService);\n+            }\n+        }\n+\n+        // Add all services from database back to scheduling\n+        for (final Service service : databaseServices) {\n+            final Optional<E> element = this.filterService.apply(service);\n+            if (!element.isPresent()) { // TODO fooker: this smells\n+                continue;\n+            }\n+\n+            if (this.network.add(service, element.get())) {\n+                this.addService.accept(new ServiceEntry<>(service, element.get())); // TODO fooker: this smells\n+            }\n+        }\n+    }\n+\n+    @EventHandler(ueis = {EventConstants.NODE_GAINED_SERVICE_EVENT_UEI,\n+                          EventConstants.RESUME_POLLING_SERVICE_EVENT_UEI})\n+    public void nodeGainedServiceHandler(final IEvent event) {\n+        final Service service = Service.fromEvent(event);\n+\n+        final Optional<E> element = this.filterService.apply(service);\n+        if (!element.isPresent()) { // TODO fooker: this smells\n+            return;\n+        }\n+\n+        if (!this.network.add(service, element.get())) {\n+            LOG.debug(\"Service already known: {}\", service);\n+            return;\n+        }\n+\n+        this.addService.accept(new ServiceEntry<>(service, element.get())); // TODO fooker: this smells\n+    }\n+\n+    @EventHandler(uei = EventConstants.INTERFACE_REPARENTED_EVENT_UEI)\n+    public void interfaceReparentedHandler(final IEvent event) {\n+        final Node oldNode = new Node(Integer.parseInt(event.getParm(EventConstants.PARM_OLD_NODEID).getValue().getContent()));\n+        final Node newNode = new Node(Integer.parseInt(event.getParm(EventConstants.PARM_NEW_NODEID).getValue().getContent()));\n+\n+        final InetAddress ipAddress = InetAddressUtils.addr(event.getInterface());\n+\n+        final Interface oldInterface = oldNode.iface(ipAddress);\n+        final Interface newInterface = newNode.iface(ipAddress);\n+\n+        // Remove interface from old node and add to new one\n+        this.network.remove(oldInterface).forEach(this.delService.andThen(oldEntry -> {\n+            final Service newService = newInterface.service(oldEntry.service.serviceName);\n+\n+            final Optional<E> newElement = this.filterService.apply(newService);\n+            if (!newElement.isPresent()) { // TODO fooker: this smells\n+                return;\n+            }\n+\n+            if (this.network.add(newService, newElement.get())) {\n+                LOG.debug(\"Service already known: {}\", newService);\n+                return;\n+            }\n+\n+            this.addService.accept(new ServiceEntry<>(newService, newElement.get())); // TODO fooker: this smells\n+        }));\n+    }\n+\n+    @EventHandler(uei = EventConstants.SUSPEND_POLLING_SERVICE_EVENT_UEI)\n+    public void nodeRemovePollableServiceHandler(final IEvent event) {\n+        final Service service = Service.fromEvent(event);\n+\n+        final Optional<ServiceEntry<E>> entry = this.network.remove(service);\n+        if (!entry.isPresent()) { // TODO fooker: this smells\n+            LOG.debug(\"Service not know: {}\", service);\n+            return;\n+        }\n+\n+        entry.ifPresent(this.delService);\n+\n+    }\n+\n+    @EventHandler(ueis = {EventConstants.NODE_DELETED_EVENT_UEI,\n+                          EventConstants.DUP_NODE_DELETED_EVENT_UEI})\n+    public void nodeDeletedHandler(final IEvent event) {\n+        final Node node = Node.fromEvent(event);\n+\n+//        this.getQueryManager().closeOutagesForNode(event.getTime(), event.getDbid(), node.nodeId);", "originalCommit": "73d5600b5b3a02d81f6d6cc1a2c90e37f9ce5ac0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc0MDE1MQ==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r470740151", "bodyText": "remove?", "author": "patrick-schweizer", "createdAt": "2020-08-14T16:51:29Z", "path": "features/remotepollerng/daemon/src/test/java/org/opennms/netmgt/remotepollerng/RemotePollerdIT.java", "diffHunk": "@@ -205,92 +211,105 @@ public void afterTransaction() throws Exception {\n         this.remotePollerd.destroy();\n         this.databasePopulator.resetDatabase();\n     }\n-    private void reloadRemotePollerd() {\n-        EventBuilder ebldr = new EventBuilder(EventConstants.RELOAD_DAEMON_CONFIG_UEI, \"test\");\n-        ebldr.addParam(EventConstants.PARM_DAEMON_NAME, RemotePollerd.NAME);\n-        this.eventIpcManager.sendNow(ebldr.getEvent());\n-    }\n \n-    private void changePollingPackages(final String locationName, final String ... packages) {\n-        final OnmsMonitoringLocation onmsMonitoringLocation = this.databasePopulator.getMonitoringLocationDao().get(locationName);\n-        // TODO: Patrick onmsMonitoringLocation.setPollingPackageNames(Lists.newArrayList(packages));\n-        this.databasePopulator.getMonitoringLocationDao().update(onmsMonitoringLocation);\n+    private void sendReloadRemotePollerdEvent() {\n+        this.eventIpcManager.sendNowSync(new EventBuilder(EventConstants.RELOAD_DAEMON_CONFIG_UEI, \"test\")\n+                                                 .addParam(EventConstants.PARM_DAEMON_NAME, RemotePollerd.NAME)\n+                                                 .getEvent());\n     }\n \n-    private void sendPollingPackageAssociationChanged(final String locationName) {\n-        final EventBuilder ebldr = new EventBuilder(EventConstants.POLLER_PACKAGE_LOCATION_ASSOCIATION_CHANGED_EVENT_UEI, \"test\");\n-        ebldr.addParam(EventConstants.PARM_LOCATION, locationName);\n-        this.eventIpcManager.sendNow(ebldr.getEvent());\n-    }\n+//    private void changePollingPackages(final String locationName, final String ... packages) {", "originalCommit": "73d5600b5b3a02d81f6d6cc1a2c90e37f9ce5ac0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc0MDY1NQ==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r470740655", "bodyText": "add a TODO to clean up the test later?", "author": "patrick-schweizer", "createdAt": "2020-08-14T16:52:30Z", "path": "features/remotepollerng/daemon/src/test/java/org/opennms/netmgt/remotepollerng/ServiceTrackerIT.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.remotepollerng;\n+\n+import static com.spotify.hamcrest.pojo.IsPojo.pojo;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertThat;\n+\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.opennms.core.test.OpenNMSJUnit4ClassRunner;\n+import org.opennms.core.test.db.annotations.JUnitTemporaryDatabase;\n+import org.opennms.netmgt.config.PollerConfigFactory;\n+import org.opennms.netmgt.dao.DatabasePopulator;\n+import org.opennms.netmgt.dao.mock.MockEventIpcManager;\n+import org.opennms.netmgt.events.api.AnnotationBasedEventListenerAdapter;\n+import org.opennms.netmgt.events.api.EventConstants;\n+import org.opennms.netmgt.events.api.EventSubscriptionService;\n+import org.opennms.netmgt.model.events.EventBuilder;\n+import org.opennms.test.JUnitConfigurationEnvironment;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.transaction.AfterTransaction;\n+import org.springframework.test.context.transaction.BeforeTransaction;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Sets;\n+\n+@RunWith(OpenNMSJUnit4ClassRunner.class)\n+@ContextConfiguration(locations = {\n+        \"classpath:/META-INF/opennms/applicationContext-soa.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-daemon.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-commonConfigs.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-dao.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-databasePopulator.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-testRemotePollerDaemon.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-shared.xml\",\n+        \"classpath:/META-INF/opennms/mockEventIpcManager.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-minimal-conf.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-thresholding.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-testPostgresBlobStore.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-testThresholdingDaos.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-testPollerConfigDaos.xml\",\n+        \"classpath:/META-INF/opennms/applicationContext-rpc-utils.xml\",\n+})\n+@JUnitConfigurationEnvironment\n+@JUnitTemporaryDatabase(reuseDatabase = false)\n+@Ignore\n+public class ServiceTrackerIT {\n+\n+//    @Autowired", "originalCommit": "73d5600b5b3a02d81f6d6cc1a2c90e37f9ce5ac0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc0MTA0Mg==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r470741042", "bodyText": "add your to the TODO as to easier filter whose TODO it is?", "author": "patrick-schweizer", "createdAt": "2020-08-14T16:53:21Z", "path": "opennms-base-assembly/src/main/filtered/etc/events/opennms.remote.poller.events.xml", "diffHunk": "@@ -30,6 +30,7 @@\n     </event>\n \n     <event>\n+        <!-- TODO: Renmove me -->", "originalCommit": "73d5600b5b3a02d81f6d6cc1a2c90e37f9ce5ac0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDc3NTczNw==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r470775737", "bodyText": "Nice. That was a lot of work.", "author": "christianpape", "createdAt": "2020-08-14T18:04:34Z", "path": "features/remotepollerng/daemon/src/test/java/org/opennms/netmgt/remotepollerng/RemotePollerdIT.java", "diffHunk": "@@ -97,7 +98,6 @@\n })\n @JUnitConfigurationEnvironment\n @JUnitTemporaryDatabase(reuseDatabase = false)\n-@Ignore // TODO: Patrick: rewrite test after we have finalized how it should look like...\n public class RemotePollerdIT implements InitializingBean {", "originalCommit": "73d5600b5b3a02d81f6d6cc1a2c90e37f9ce5ac0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4cabd66ba53035b07750e04a45beb2e0b063d7fa", "url": "https://github.com/OpenNMS/opennms/commit/4cabd66ba53035b07750e04a45beb2e0b063d7fa", "message": "NMS-12676: Basic Service tracker and integration", "committedDate": "2020-08-18T10:33:56Z", "type": "commit"}, {"oid": "a6a0ebc5af873f55b72db7d69ebc3d76b7a14542", "url": "https://github.com/OpenNMS/opennms/commit/a6a0ebc5af873f55b72db7d69ebc3d76b7a14542", "message": "NMS-12676: Some progress", "committedDate": "2020-08-18T10:33:58Z", "type": "commit"}, {"oid": "a0a2ed9811ea4ab43033a88d593ab989bb563ddb", "url": "https://github.com/OpenNMS/opennms/commit/a0a2ed9811ea4ab43033a88d593ab989bb563ddb", "message": "NMS-12676: Some progress", "committedDate": "2020-08-18T10:33:58Z", "type": "commit"}, {"oid": "23166433ff14b942ee3a3d1ca89576f167fae1d6", "url": "https://github.com/OpenNMS/opennms/commit/23166433ff14b942ee3a3d1ca89576f167fae1d6", "message": "NMS-12676: More tests", "committedDate": "2020-08-19T18:26:21Z", "type": "commit"}, {"oid": "23166433ff14b942ee3a3d1ca89576f167fae1d6", "url": "https://github.com/OpenNMS/opennms/commit/23166433ff14b942ee3a3d1ca89576f167fae1d6", "message": "NMS-12676: More tests", "committedDate": "2020-08-19T18:26:21Z", "type": "forcePushed"}, {"oid": "1899ca27978ff172684e15eceeb5c3e219482eca", "url": "https://github.com/OpenNMS/opennms/commit/1899ca27978ff172684e15eceeb5c3e219482eca", "message": "NMS-12676: More cleanup", "committedDate": "2020-08-20T12:37:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2MTY2OA==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r473961668", "bodyText": "I suggest to name it like the bean property .add(\"IpAddress\", this.ipAddress)", "author": "christianpape", "createdAt": "2020-08-20T13:18:20Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/ServiceTracker.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2002-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.remotepollerng;\n+\n+import java.net.InetAddress;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.config.PollerConfig;\n+import org.opennms.netmgt.events.api.EventConstants;\n+import org.opennms.netmgt.events.api.ThreadAwareEventListener;\n+import org.opennms.netmgt.events.api.annotations.EventHandler;\n+import org.opennms.netmgt.events.api.annotations.EventListener;\n+import org.opennms.netmgt.events.api.model.IEvent;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+@EventListener(name = \"remotepollerd\")\n+public final class ServiceTracker<E> implements ThreadAwareEventListener {\n+    private static final Logger LOG = LoggerFactory.getLogger(ServiceTracker.class);\n+\n+    private final PollerConfig config;\n+\n+    private final QueryManager queryManager;\n+\n+    private final Network<E> network;\n+\n+    private final Function<Service, Optional<E>> filterService;\n+\n+    private final Consumer<ServiceEntry<E>> addService;\n+    private final Consumer<ServiceEntry<E>> deleteService;\n+\n+    public ServiceTracker(final PollerConfig config,\n+                          final QueryManager queryManager,\n+                          final Function<Service, Optional<E>> filterService,\n+                          final Consumer<ServiceEntry<E>> addService,\n+                          final Consumer<ServiceEntry<E>> deleteService) {\n+        this.config = Objects.requireNonNull(config);\n+        this.queryManager = Objects.requireNonNull(queryManager);\n+        this.network = new Network<>();\n+        this.filterService = Objects.requireNonNull(filterService);\n+        this.addService = Objects.requireNonNull(addService);\n+        this.deleteService = Objects.requireNonNull(deleteService);\n+    }\n+\n+    public void start() {\n+        // Build initial network\n+        for (final Service service : this.queryManager.findServices()) {\n+            final Optional<E> element = this.filterService.apply(service);\n+            if (!element.isPresent()) { // TODO fooker: this smells\n+                continue;\n+            }\n+\n+            if (this.network.add(service, element.get())) {\n+                this.addService.accept(new ServiceEntry<>(service, element.get())); // TODO fooker: this smells\n+            } else {\n+                LOG.debug(\"Service already known: {}\", service);\n+                throw new IllegalStateException();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int getNumThreads() {\n+        // TODO fooker: Make this configurable as in Alarmd?\n+        return 1;\n+    }\n+\n+    private void rescheduleNodeServices(final IEvent event, final boolean rescheduleExisting) {\n+        final Node node = Node.fromEvent(event);\n+\n+        this.config.rebuildPackageIpListMap();\n+        this.serviceReschedule(node, rescheduleExisting);\n+    }\n+\n+    public void rescheduleAllServices() {\n+        this.config.rebuildPackageIpListMap();\n+\n+        this.network.nodes().forEach(node -> this.serviceReschedule(node, true));\n+    }\n+\n+    public void rescheduleService(final Service service) {\n+        this.network.remove(service)\n+                    .ifPresent(this.deleteService);\n+\n+        this.filterService.apply(service).ifPresent(element -> {\n+            if (this.network.add(service, element)) {\n+                this.addService.accept(new ServiceEntry<>(service, element));\n+            }\n+        });\n+    }\n+\n+    private void serviceReschedule(final Node node,\n+                                   final boolean rescheduleExisting) {\n+        final Set<Service> databaseServices = Sets.newHashSet(this.queryManager.findServicesByNode(node));\n+        final Set<Service> trackedServices = this.network.findByNode(node).map(ServiceEntry::getService).collect(Collectors.toSet());\n+\n+        // Remove the services being tracked but not in database\n+        for (final Service service : Sets.difference(trackedServices, databaseServices)) {\n+            this.network.remove(service)\n+                        .ifPresent(this.deleteService);\n+        }\n+\n+        // Remove remaining services if existing services should be rescheduled\n+        if (rescheduleExisting) {\n+            for (final Service service : trackedServices) {\n+                this.network.remove(service)\n+                            .ifPresent(this.deleteService);\n+            }\n+        }\n+\n+        // Add all services from database back to scheduling\n+        for (final Service service : databaseServices) {\n+            final Optional<E> element = this.filterService.apply(service);\n+            if (!element.isPresent()) { // TODO fooker: this smells\n+                continue;\n+            }\n+\n+            if (this.network.add(service, element.get())) {\n+                this.addService.accept(new ServiceEntry<>(service, element.get())); // TODO fooker: this smells\n+            }\n+        }\n+    }\n+\n+    @EventHandler(ueis = {EventConstants.NODE_GAINED_SERVICE_EVENT_UEI,\n+                          EventConstants.RESUME_POLLING_SERVICE_EVENT_UEI})\n+    public void nodeGainedServiceHandler(final IEvent event) {\n+        final Service service = Service.fromEvent(event);\n+\n+        final Optional<E> element = this.filterService.apply(service);\n+        if (!element.isPresent()) { // TODO fooker: this smells\n+            return;\n+        }\n+\n+        if (!this.network.add(service, element.get())) {\n+            LOG.debug(\"Service already known: {}\", service);\n+            return;\n+        }\n+\n+        this.addService.accept(new ServiceEntry<>(service, element.get())); // TODO fooker: this smells\n+    }\n+\n+    @EventHandler(uei = EventConstants.INTERFACE_REPARENTED_EVENT_UEI)\n+    public void interfaceReparentedHandler(final IEvent event) {\n+        final Node oldNode = new Node(Integer.parseInt(event.getParm(EventConstants.PARM_OLD_NODEID).getValue().getContent()));\n+        final Node newNode = new Node(Integer.parseInt(event.getParm(EventConstants.PARM_NEW_NODEID).getValue().getContent()));\n+\n+        final InetAddress ipAddress = InetAddressUtils.addr(event.getInterface());\n+\n+        final Interface oldInterface = oldNode.iface(ipAddress);\n+        final Interface newInterface = newNode.iface(ipAddress);\n+\n+        // Remove interface from old node and add to new one\n+        this.network.remove(oldInterface).forEach(this.deleteService.andThen(oldEntry -> {\n+            final Service newService = newInterface.service(oldEntry.service.serviceName);\n+\n+            final Optional<E> newElement = this.filterService.apply(newService);\n+            if (!newElement.isPresent()) { // TODO fooker: this smells\n+                return;\n+            }\n+\n+            if (this.network.add(newService, newElement.get())) {\n+                LOG.debug(\"Service already known: {}\", newService);\n+                return;\n+            }\n+\n+            this.addService.accept(new ServiceEntry<>(newService, newElement.get())); // TODO fooker: this smells\n+        }));\n+    }\n+\n+    @EventHandler(uei = EventConstants.SUSPEND_POLLING_SERVICE_EVENT_UEI)\n+    public void nodeRemovePollableServiceHandler(final IEvent event) {\n+        final Service service = Service.fromEvent(event);\n+\n+        final Optional<ServiceEntry<E>> entry = this.network.remove(service);\n+        if (!entry.isPresent()) { // TODO fooker: this smells\n+            LOG.debug(\"Service not know: {}\", service);\n+            return;\n+        }\n+\n+        entry.ifPresent(this.deleteService);\n+\n+    }\n+\n+    @EventHandler(ueis = {EventConstants.NODE_DELETED_EVENT_UEI,\n+                          EventConstants.DUP_NODE_DELETED_EVENT_UEI})\n+    public void nodeDeletedHandler(final IEvent event) {\n+        final Node node = Node.fromEvent(event);\n+\n+        this.network.remove(node)\n+                    .forEach(this.deleteService);\n+    }\n+\n+    @EventHandler(uei = EventConstants.INTERFACE_DELETED_EVENT_UEI)\n+    public void interfaceDeletedHandler(final IEvent event) {\n+        final Interface iface = Interface.fromEvent(event);\n+\n+        this.network.remove(iface)\n+                    .forEach(this.deleteService);\n+    }\n+\n+    @EventHandler(uei = EventConstants.SERVICE_DELETED_EVENT_UEI)\n+    public void serviceDeletedHandler(final IEvent event) {\n+        final Service service = Service.fromEvent(event);\n+\n+        final Optional<ServiceEntry<E>> entry = this.network.remove(service);\n+        if (!entry.isPresent()) { // TODO fooker: this smells\n+            LOG.debug(\"Service not know: {}\", service);\n+            return;\n+        }\n+\n+        entry.ifPresent(this.deleteService);\n+    }\n+\n+    // TODO fooker: do we care about scheduled outages?\n+//    @EventHandler(uei = EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI)\n+//    public void scheduledOutagesChangeHandler(final IEvent event) {\n+//        try {\n+//            this.config.update();\n+//            getPoller().getPollOutagesDao().reload();\n+//        } catch (Throwable e) {\n+//            LOG.error(\"Failed to reload PollerConfigFactory\", e);\n+//        }\n+//        getPoller().refreshServicePackages();\n+//    }\n+\n+    @EventHandler(uei = EventConstants.NODE_CATEGORY_MEMBERSHIP_CHANGED_EVENT_UEI)\n+    public void nodeCategoryMembershipChangedHandler(final IEvent event) {\n+        this.rescheduleNodeServices(event, false);\n+    }\n+\n+    @EventHandler(uei = EventConstants.NODE_LOCATION_CHANGED_EVENT_UEI)\n+    public void nodeLocationChangedHandler(final IEvent event) {\n+        this.rescheduleNodeServices(event, true);\n+    }\n+\n+    @EventHandler(uei = EventConstants.ASSET_INFO_CHANGED_EVENT_UEI)\n+    public void assetInfoChangedHandler(final IEvent event) {\n+        this.rescheduleNodeServices(event, false);\n+    }\n+\n+    public interface QueryManager {\n+        List<Service> findServices();\n+        List<Service> findServicesByNode(final Node node);\n+    }\n+\n+    private static class Network<E> {\n+        private final Map<Integer, Map<InetAddress, Map<String, E>>> services;\n+\n+        private Network() {\n+            this.services = Maps.newConcurrentMap();\n+        }\n+\n+        private static <E> Stream<ServiceEntry<E>> flatten(final Map<InetAddress, Map<String, E>> services, final Node node) {\n+            return services.entrySet().stream()\n+                           .flatMap(e -> flatten(e.getValue(), node.iface(e.getKey())));\n+        }\n+\n+        private static <E> Stream<ServiceEntry<E>> flatten(final Map<String, E> services, final Interface iface) {\n+            return services.entrySet().stream()\n+                           .map(e -> new ServiceEntry<>(iface.service(e.getKey()), e.getValue()));\n+        }\n+\n+        private Map<InetAddress, Map<String, E>> node(final Node node) {\n+            return this.services.computeIfAbsent(node.nodeId, key -> Maps.newConcurrentMap());\n+        }\n+\n+        private Map<String, E> iface(final Interface iface) {\n+            return this.node(iface.node())\n+                       .computeIfAbsent(iface.ipAddress, key -> Maps.newConcurrentMap());\n+        }\n+\n+        public Stream<Node> nodes() {\n+            return this.services.keySet().stream()\n+                                .map(Node::new);\n+        }\n+\n+        public boolean add(final Service service, final E element) {\n+            return this.iface(service.iface())\n+                       .put(service.serviceName, element) == null;\n+        }\n+\n+        public Stream<ServiceEntry<E>> remove(final Node node) {\n+            return flatten(this.services.remove(node.nodeId), node);\n+        }\n+\n+        public Stream<ServiceEntry<E>> remove(final Interface iface) {\n+            return flatten(this.node(iface.node())\n+                               .remove(iface.ipAddress), iface);\n+        }\n+\n+        public Optional<ServiceEntry<E>> remove(final Service service) {\n+            return Optional.ofNullable(this.iface(service.iface())\n+                                           .remove(service.serviceName))\n+                    .map(element -> new ServiceEntry<>(service, element));\n+        }\n+\n+        public Stream<ServiceEntry<E>> findByNode(final Node node) {\n+            return flatten(this.node(node), node);\n+        }\n+\n+        public Stream<ServiceEntry<E>> findByInterface(final Interface iface) {\n+            return flatten(this.iface(iface), iface);\n+        }\n+    }\n+\n+    public static class Node {\n+        public final int nodeId;\n+\n+        public Node(final int nodeId) {\n+            this.nodeId = nodeId;\n+        }\n+\n+        public static Node fromEvent(final IEvent event) {\n+            final int nodeId = event.getNodeid().intValue();\n+\n+            return new Node(nodeId);\n+        }\n+\n+        public Interface iface(final InetAddress ipAddress) {\n+            return new Interface(this.nodeId, ipAddress);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return MoreObjects.toStringHelper(this)\n+                              .add(\"nodeId\", this.nodeId)\n+                              .toString();\n+        }\n+    }\n+\n+    public static class Interface {\n+        public final int nodeId;\n+        public final InetAddress ipAddress;\n+\n+        public Interface(final int nodeId, final InetAddress ipAddress) {\n+            this.nodeId = nodeId;\n+            this.ipAddress = Objects.requireNonNull(ipAddress);\n+        }\n+\n+        public static Interface fromEvent(final IEvent event) {\n+            final int nodeId = event.getNodeid().intValue();\n+            final String ipAddress = event.getInterface();\n+\n+            return new Interface(nodeId, InetAddressUtils.addr(ipAddress));\n+        }\n+\n+        public Node node() {\n+            return new Node(this.nodeId);\n+        }\n+\n+        public Service service(final String serviceName) {\n+            return new Service(this.nodeId, this.ipAddress, serviceName);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return MoreObjects.toStringHelper(this)\n+                              .add(\"nodeId\", this.nodeId)\n+                              .add(\"address\", this.ipAddress)", "originalCommit": "1899ca27978ff172684e15eceeb5c3e219482eca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAzNTUwNw==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r474035507", "bodyText": "\ud83d\udc4d", "author": "patrick-schweizer", "createdAt": "2020-08-20T14:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2MTY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2MTg3Mw==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r473961873", "bodyText": "same here", "author": "christianpape", "createdAt": "2020-08-20T13:18:39Z", "path": "features/remotepollerng/daemon/src/main/java/org/opennms/netmgt/remotepollerng/ServiceTracker.java", "diffHunk": "@@ -0,0 +1,479 @@\n+/*******************************************************************************\n+ * This file is part of OpenNMS(R).\n+ *\n+ * Copyright (C) 2002-2020 The OpenNMS Group, Inc.\n+ * OpenNMS(R) is Copyright (C) 1999-2020 The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is a registered trademark of The OpenNMS Group, Inc.\n+ *\n+ * OpenNMS(R) is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Affero General Public License as published\n+ * by the Free Software Foundation, either version 3 of the License,\n+ * or (at your option) any later version.\n+ *\n+ * OpenNMS(R) is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU Affero General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Affero General Public License\n+ * along with OpenNMS(R).  If not, see:\n+ *      http://www.gnu.org/licenses/\n+ *\n+ * For more information contact:\n+ *     OpenNMS(R) Licensing <license@opennms.org>\n+ *     http://www.opennms.org/\n+ *     http://www.opennms.com/\n+ *******************************************************************************/\n+\n+package org.opennms.netmgt.remotepollerng;\n+\n+import java.net.InetAddress;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.opennms.core.utils.InetAddressUtils;\n+import org.opennms.netmgt.config.PollerConfig;\n+import org.opennms.netmgt.events.api.EventConstants;\n+import org.opennms.netmgt.events.api.ThreadAwareEventListener;\n+import org.opennms.netmgt.events.api.annotations.EventHandler;\n+import org.opennms.netmgt.events.api.annotations.EventListener;\n+import org.opennms.netmgt.events.api.model.IEvent;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.collect.Maps;\n+import com.google.common.collect.Sets;\n+\n+@EventListener(name = \"remotepollerd\")\n+public final class ServiceTracker<E> implements ThreadAwareEventListener {\n+    private static final Logger LOG = LoggerFactory.getLogger(ServiceTracker.class);\n+\n+    private final PollerConfig config;\n+\n+    private final QueryManager queryManager;\n+\n+    private final Network<E> network;\n+\n+    private final Function<Service, Optional<E>> filterService;\n+\n+    private final Consumer<ServiceEntry<E>> addService;\n+    private final Consumer<ServiceEntry<E>> deleteService;\n+\n+    public ServiceTracker(final PollerConfig config,\n+                          final QueryManager queryManager,\n+                          final Function<Service, Optional<E>> filterService,\n+                          final Consumer<ServiceEntry<E>> addService,\n+                          final Consumer<ServiceEntry<E>> deleteService) {\n+        this.config = Objects.requireNonNull(config);\n+        this.queryManager = Objects.requireNonNull(queryManager);\n+        this.network = new Network<>();\n+        this.filterService = Objects.requireNonNull(filterService);\n+        this.addService = Objects.requireNonNull(addService);\n+        this.deleteService = Objects.requireNonNull(deleteService);\n+    }\n+\n+    public void start() {\n+        // Build initial network\n+        for (final Service service : this.queryManager.findServices()) {\n+            final Optional<E> element = this.filterService.apply(service);\n+            if (!element.isPresent()) { // TODO fooker: this smells\n+                continue;\n+            }\n+\n+            if (this.network.add(service, element.get())) {\n+                this.addService.accept(new ServiceEntry<>(service, element.get())); // TODO fooker: this smells\n+            } else {\n+                LOG.debug(\"Service already known: {}\", service);\n+                throw new IllegalStateException();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int getNumThreads() {\n+        // TODO fooker: Make this configurable as in Alarmd?\n+        return 1;\n+    }\n+\n+    private void rescheduleNodeServices(final IEvent event, final boolean rescheduleExisting) {\n+        final Node node = Node.fromEvent(event);\n+\n+        this.config.rebuildPackageIpListMap();\n+        this.serviceReschedule(node, rescheduleExisting);\n+    }\n+\n+    public void rescheduleAllServices() {\n+        this.config.rebuildPackageIpListMap();\n+\n+        this.network.nodes().forEach(node -> this.serviceReschedule(node, true));\n+    }\n+\n+    public void rescheduleService(final Service service) {\n+        this.network.remove(service)\n+                    .ifPresent(this.deleteService);\n+\n+        this.filterService.apply(service).ifPresent(element -> {\n+            if (this.network.add(service, element)) {\n+                this.addService.accept(new ServiceEntry<>(service, element));\n+            }\n+        });\n+    }\n+\n+    private void serviceReschedule(final Node node,\n+                                   final boolean rescheduleExisting) {\n+        final Set<Service> databaseServices = Sets.newHashSet(this.queryManager.findServicesByNode(node));\n+        final Set<Service> trackedServices = this.network.findByNode(node).map(ServiceEntry::getService).collect(Collectors.toSet());\n+\n+        // Remove the services being tracked but not in database\n+        for (final Service service : Sets.difference(trackedServices, databaseServices)) {\n+            this.network.remove(service)\n+                        .ifPresent(this.deleteService);\n+        }\n+\n+        // Remove remaining services if existing services should be rescheduled\n+        if (rescheduleExisting) {\n+            for (final Service service : trackedServices) {\n+                this.network.remove(service)\n+                            .ifPresent(this.deleteService);\n+            }\n+        }\n+\n+        // Add all services from database back to scheduling\n+        for (final Service service : databaseServices) {\n+            final Optional<E> element = this.filterService.apply(service);\n+            if (!element.isPresent()) { // TODO fooker: this smells\n+                continue;\n+            }\n+\n+            if (this.network.add(service, element.get())) {\n+                this.addService.accept(new ServiceEntry<>(service, element.get())); // TODO fooker: this smells\n+            }\n+        }\n+    }\n+\n+    @EventHandler(ueis = {EventConstants.NODE_GAINED_SERVICE_EVENT_UEI,\n+                          EventConstants.RESUME_POLLING_SERVICE_EVENT_UEI})\n+    public void nodeGainedServiceHandler(final IEvent event) {\n+        final Service service = Service.fromEvent(event);\n+\n+        final Optional<E> element = this.filterService.apply(service);\n+        if (!element.isPresent()) { // TODO fooker: this smells\n+            return;\n+        }\n+\n+        if (!this.network.add(service, element.get())) {\n+            LOG.debug(\"Service already known: {}\", service);\n+            return;\n+        }\n+\n+        this.addService.accept(new ServiceEntry<>(service, element.get())); // TODO fooker: this smells\n+    }\n+\n+    @EventHandler(uei = EventConstants.INTERFACE_REPARENTED_EVENT_UEI)\n+    public void interfaceReparentedHandler(final IEvent event) {\n+        final Node oldNode = new Node(Integer.parseInt(event.getParm(EventConstants.PARM_OLD_NODEID).getValue().getContent()));\n+        final Node newNode = new Node(Integer.parseInt(event.getParm(EventConstants.PARM_NEW_NODEID).getValue().getContent()));\n+\n+        final InetAddress ipAddress = InetAddressUtils.addr(event.getInterface());\n+\n+        final Interface oldInterface = oldNode.iface(ipAddress);\n+        final Interface newInterface = newNode.iface(ipAddress);\n+\n+        // Remove interface from old node and add to new one\n+        this.network.remove(oldInterface).forEach(this.deleteService.andThen(oldEntry -> {\n+            final Service newService = newInterface.service(oldEntry.service.serviceName);\n+\n+            final Optional<E> newElement = this.filterService.apply(newService);\n+            if (!newElement.isPresent()) { // TODO fooker: this smells\n+                return;\n+            }\n+\n+            if (this.network.add(newService, newElement.get())) {\n+                LOG.debug(\"Service already known: {}\", newService);\n+                return;\n+            }\n+\n+            this.addService.accept(new ServiceEntry<>(newService, newElement.get())); // TODO fooker: this smells\n+        }));\n+    }\n+\n+    @EventHandler(uei = EventConstants.SUSPEND_POLLING_SERVICE_EVENT_UEI)\n+    public void nodeRemovePollableServiceHandler(final IEvent event) {\n+        final Service service = Service.fromEvent(event);\n+\n+        final Optional<ServiceEntry<E>> entry = this.network.remove(service);\n+        if (!entry.isPresent()) { // TODO fooker: this smells\n+            LOG.debug(\"Service not know: {}\", service);\n+            return;\n+        }\n+\n+        entry.ifPresent(this.deleteService);\n+\n+    }\n+\n+    @EventHandler(ueis = {EventConstants.NODE_DELETED_EVENT_UEI,\n+                          EventConstants.DUP_NODE_DELETED_EVENT_UEI})\n+    public void nodeDeletedHandler(final IEvent event) {\n+        final Node node = Node.fromEvent(event);\n+\n+        this.network.remove(node)\n+                    .forEach(this.deleteService);\n+    }\n+\n+    @EventHandler(uei = EventConstants.INTERFACE_DELETED_EVENT_UEI)\n+    public void interfaceDeletedHandler(final IEvent event) {\n+        final Interface iface = Interface.fromEvent(event);\n+\n+        this.network.remove(iface)\n+                    .forEach(this.deleteService);\n+    }\n+\n+    @EventHandler(uei = EventConstants.SERVICE_DELETED_EVENT_UEI)\n+    public void serviceDeletedHandler(final IEvent event) {\n+        final Service service = Service.fromEvent(event);\n+\n+        final Optional<ServiceEntry<E>> entry = this.network.remove(service);\n+        if (!entry.isPresent()) { // TODO fooker: this smells\n+            LOG.debug(\"Service not know: {}\", service);\n+            return;\n+        }\n+\n+        entry.ifPresent(this.deleteService);\n+    }\n+\n+    // TODO fooker: do we care about scheduled outages?\n+//    @EventHandler(uei = EventConstants.SCHEDOUTAGES_CHANGED_EVENT_UEI)\n+//    public void scheduledOutagesChangeHandler(final IEvent event) {\n+//        try {\n+//            this.config.update();\n+//            getPoller().getPollOutagesDao().reload();\n+//        } catch (Throwable e) {\n+//            LOG.error(\"Failed to reload PollerConfigFactory\", e);\n+//        }\n+//        getPoller().refreshServicePackages();\n+//    }\n+\n+    @EventHandler(uei = EventConstants.NODE_CATEGORY_MEMBERSHIP_CHANGED_EVENT_UEI)\n+    public void nodeCategoryMembershipChangedHandler(final IEvent event) {\n+        this.rescheduleNodeServices(event, false);\n+    }\n+\n+    @EventHandler(uei = EventConstants.NODE_LOCATION_CHANGED_EVENT_UEI)\n+    public void nodeLocationChangedHandler(final IEvent event) {\n+        this.rescheduleNodeServices(event, true);\n+    }\n+\n+    @EventHandler(uei = EventConstants.ASSET_INFO_CHANGED_EVENT_UEI)\n+    public void assetInfoChangedHandler(final IEvent event) {\n+        this.rescheduleNodeServices(event, false);\n+    }\n+\n+    public interface QueryManager {\n+        List<Service> findServices();\n+        List<Service> findServicesByNode(final Node node);\n+    }\n+\n+    private static class Network<E> {\n+        private final Map<Integer, Map<InetAddress, Map<String, E>>> services;\n+\n+        private Network() {\n+            this.services = Maps.newConcurrentMap();\n+        }\n+\n+        private static <E> Stream<ServiceEntry<E>> flatten(final Map<InetAddress, Map<String, E>> services, final Node node) {\n+            return services.entrySet().stream()\n+                           .flatMap(e -> flatten(e.getValue(), node.iface(e.getKey())));\n+        }\n+\n+        private static <E> Stream<ServiceEntry<E>> flatten(final Map<String, E> services, final Interface iface) {\n+            return services.entrySet().stream()\n+                           .map(e -> new ServiceEntry<>(iface.service(e.getKey()), e.getValue()));\n+        }\n+\n+        private Map<InetAddress, Map<String, E>> node(final Node node) {\n+            return this.services.computeIfAbsent(node.nodeId, key -> Maps.newConcurrentMap());\n+        }\n+\n+        private Map<String, E> iface(final Interface iface) {\n+            return this.node(iface.node())\n+                       .computeIfAbsent(iface.ipAddress, key -> Maps.newConcurrentMap());\n+        }\n+\n+        public Stream<Node> nodes() {\n+            return this.services.keySet().stream()\n+                                .map(Node::new);\n+        }\n+\n+        public boolean add(final Service service, final E element) {\n+            return this.iface(service.iface())\n+                       .put(service.serviceName, element) == null;\n+        }\n+\n+        public Stream<ServiceEntry<E>> remove(final Node node) {\n+            return flatten(this.services.remove(node.nodeId), node);\n+        }\n+\n+        public Stream<ServiceEntry<E>> remove(final Interface iface) {\n+            return flatten(this.node(iface.node())\n+                               .remove(iface.ipAddress), iface);\n+        }\n+\n+        public Optional<ServiceEntry<E>> remove(final Service service) {\n+            return Optional.ofNullable(this.iface(service.iface())\n+                                           .remove(service.serviceName))\n+                    .map(element -> new ServiceEntry<>(service, element));\n+        }\n+\n+        public Stream<ServiceEntry<E>> findByNode(final Node node) {\n+            return flatten(this.node(node), node);\n+        }\n+\n+        public Stream<ServiceEntry<E>> findByInterface(final Interface iface) {\n+            return flatten(this.iface(iface), iface);\n+        }\n+    }\n+\n+    public static class Node {\n+        public final int nodeId;\n+\n+        public Node(final int nodeId) {\n+            this.nodeId = nodeId;\n+        }\n+\n+        public static Node fromEvent(final IEvent event) {\n+            final int nodeId = event.getNodeid().intValue();\n+\n+            return new Node(nodeId);\n+        }\n+\n+        public Interface iface(final InetAddress ipAddress) {\n+            return new Interface(this.nodeId, ipAddress);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return MoreObjects.toStringHelper(this)\n+                              .add(\"nodeId\", this.nodeId)\n+                              .toString();\n+        }\n+    }\n+\n+    public static class Interface {\n+        public final int nodeId;\n+        public final InetAddress ipAddress;\n+\n+        public Interface(final int nodeId, final InetAddress ipAddress) {\n+            this.nodeId = nodeId;\n+            this.ipAddress = Objects.requireNonNull(ipAddress);\n+        }\n+\n+        public static Interface fromEvent(final IEvent event) {\n+            final int nodeId = event.getNodeid().intValue();\n+            final String ipAddress = event.getInterface();\n+\n+            return new Interface(nodeId, InetAddressUtils.addr(ipAddress));\n+        }\n+\n+        public Node node() {\n+            return new Node(this.nodeId);\n+        }\n+\n+        public Service service(final String serviceName) {\n+            return new Service(this.nodeId, this.ipAddress, serviceName);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return MoreObjects.toStringHelper(this)\n+                              .add(\"nodeId\", this.nodeId)\n+                              .add(\"address\", this.ipAddress)\n+                              .toString();\n+        }\n+    }\n+\n+    public static class Service {\n+        public final int nodeId;\n+        public final InetAddress ipAddress;\n+        public final String serviceName;\n+\n+        public Service(final int nodeId,\n+                       final InetAddress ipAddress,\n+                       final String serviceName) {\n+            this.nodeId = nodeId;\n+            this.ipAddress = Objects.requireNonNull(ipAddress);\n+            this.serviceName = Objects.requireNonNull(serviceName);\n+        }\n+\n+        public static Service fromEvent(final IEvent event) {\n+            final int nodeId = event.getNodeid().intValue();\n+            final String ipAddress = event.getInterface();\n+            final String serviceName = event.getService();\n+\n+            return new Service(nodeId, InetAddressUtils.addr(ipAddress), serviceName);\n+        }\n+\n+        public Node node() {\n+            return new Node(this.nodeId);\n+        }\n+\n+        public Interface iface() {\n+            return new Interface(this.nodeId, this.ipAddress);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) {\n+                return true;\n+            }\n+            if (!(o instanceof Service)) {\n+                return false;\n+            }\n+\n+            final Service service = (Service) o;\n+            return Objects.equals(this.nodeId, service.nodeId) &&\n+                   Objects.equals(this.ipAddress, service.ipAddress) &&\n+                   Objects.equals(this.serviceName, service.serviceName);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(this.nodeId, this.ipAddress, this.serviceName);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return MoreObjects.toStringHelper(this)\n+                              .add(\"nodeId\", this.nodeId)\n+                              .add(\"address\", this.ipAddress)", "originalCommit": "1899ca27978ff172684e15eceeb5c3e219482eca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAzNTYyMg==", "url": "https://github.com/OpenNMS/opennms/pull/3104#discussion_r474035622", "bodyText": "\ud83d\udc4d", "author": "patrick-schweizer", "createdAt": "2020-08-20T14:40:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2MTg3Mw=="}], "type": "inlineReview"}, {"oid": "21a961b95c2d561ea128dd666890486ace89a18e", "url": "https://github.com/OpenNMS/opennms/commit/21a961b95c2d561ea128dd666890486ace89a18e", "message": "NMS-12676: Review chanes", "committedDate": "2020-08-21T07:24:14Z", "type": "commit"}]}