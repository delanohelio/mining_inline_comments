{"pr_number": 7178, "pr_title": "IQSS/7177 enhance metrics api", "pr_createdAt": "2020-08-11T03:02:21Z", "pr_url": "https://github.com/IQSS/dataverse/pull/7178", "timeline": [{"oid": "dbb8a0199ff229598173b7c78dc44e99162d7681", "url": "https://github.com/IQSS/dataverse/commit/dbb8a0199ff229598173b7c78dc44e99162d7681", "message": "try retrieving selected contenttype", "committedDate": "2020-08-27T17:04:33Z", "type": "commit"}, {"oid": "5e9a0b715af57c6374ab60080a79e41fa199636a", "url": "https://github.com/IQSS/dataverse/commit/5e9a0b715af57c6374ab60080a79e41fa199636a", "message": "handle return type selection better and add csv filenames\n\nConflicts:\n\tsrc/main/java/edu/harvard/iq/dataverse/api/Metrics.java", "committedDate": "2020-08-27T17:08:39Z", "type": "commit"}, {"oid": "b13e70ae0c880a996b73a8382cdf0965277a5553", "url": "https://github.com/IQSS/dataverse/commit/b13e70ae0c880a996b73a8382cdf0965277a5553", "message": "formatting only", "committedDate": "2020-08-27T17:08:52Z", "type": "commit"}, {"oid": "28760d4791bb830a2e985cf9ec24c50ec45747dc", "url": "https://github.com/IQSS/dataverse/commit/28760d4791bb830a2e985cf9ec24c50ec45747dc", "message": "update rsync call to use new ok() method", "committedDate": "2020-08-27T17:09:02Z", "type": "commit"}, {"oid": "f87fd532bb7085e2367dd098f1b088b0d1f68979", "url": "https://github.com/IQSS/dataverse/commit/f87fd532bb7085e2367dd098f1b088b0d1f68979", "message": "fix return contentype logic", "committedDate": "2020-08-27T17:09:11Z", "type": "commit"}, {"oid": "c6402caa829de41cdef0dbd56d8ce7f146ace416", "url": "https://github.com/IQSS/dataverse/commit/c6402caa829de41cdef0dbd56d8ce7f146ace416", "message": "prefer csv when client doesn't care", "committedDate": "2020-08-27T17:09:19Z", "type": "commit"}, {"oid": "e578fec359808fc891049da9b600ad65b346b383", "url": "https://github.com/IQSS/dataverse/commit/e578fec359808fc891049da9b600ad65b346b383", "message": "reverse order in variant request", "committedDate": "2020-08-27T17:09:28Z", "type": "commit"}, {"oid": "282c77e8fc099c725fe02721b9650bda5f64df5d", "url": "https://github.com/IQSS/dataverse/commit/282c77e8fc099c725fe02721b9650bda5f64df5d", "message": "add db update script", "committedDate": "2020-08-27T17:09:44Z", "type": "commit"}, {"oid": "781e105ab9bbb266108976a551e411e6da8a65a7", "url": "https://github.com/IQSS/dataverse/commit/781e105ab9bbb266108976a551e411e6da8a65a7", "message": "update db update script name", "committedDate": "2020-08-27T17:12:44Z", "type": "commit"}, {"oid": "944dcd010951963a06914c21701449f02201794b", "url": "https://github.com/IQSS/dataverse/commit/944dcd010951963a06914c21701449f02201794b", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2020-08-31T14:22:06Z", "type": "commit"}, {"oid": "454b2b6490ff6702ed773183a57fc405f021a213", "url": "https://github.com/IQSS/dataverse/commit/454b2b6490ff6702ed773183a57fc405f021a213", "message": "missed updates", "committedDate": "2020-08-31T14:30:08Z", "type": "commit"}, {"oid": "38cd06457a85388bfc41652f8510ca5852fad51d", "url": "https://github.com/IQSS/dataverse/commit/38cd06457a85388bfc41652f8510ca5852fad51d", "message": "make update idempotent", "committedDate": "2020-09-01T19:06:11Z", "type": "commit"}, {"oid": "97bbfc54ea5e549d8018a64548425ab0c6a21857", "url": "https://github.com/IQSS/dataverse/commit/97bbfc54ea5e549d8018a64548425ab0c6a21857", "message": "filedownloads api endpoint", "committedDate": "2020-09-09T18:46:45Z", "type": "commit"}, {"oid": "1335ea49d50d4318d68a928486c17029612b1fcc", "url": "https://github.com/IQSS/dataverse/commit/1335ea49d50d4318d68a928486c17029612b1fcc", "message": "id is Integer", "committedDate": "2020-09-09T18:46:56Z", "type": "commit"}, {"oid": "f592b2f72625750327cb1ce61f6ee8f89cb98f90", "url": "https://github.com/IQSS/dataverse/commit/f592b2f72625750327cb1ce61f6ee8f89cb98f90", "message": "fix csv download", "committedDate": "2020-09-09T18:47:02Z", "type": "commit"}, {"oid": "44ab11c980dce9ce9fd694307b2ff13744e60a1d", "url": "https://github.com/IQSS/dataverse/commit/44ab11c980dce9ce9fd694307b2ff13744e60a1d", "message": "add unique and toMonth file download options", "committedDate": "2020-09-09T18:47:09Z", "type": "commit"}, {"oid": "9c22bd0807621a16e111c3c23641d3fc9a6d3ae9", "url": "https://github.com/IQSS/dataverse/commit/9c22bd0807621a16e111c3c23641d3fc9a6d3ae9", "message": "most counts first", "committedDate": "2020-09-09T18:47:15Z", "type": "commit"}, {"oid": "4e708fa748141945d917ce7306c679ff5ffeb947", "url": "https://github.com/IQSS/dataverse/commit/4e708fa748141945d917ce7306c679ff5ffeb947", "message": "add missing csv downloads", "committedDate": "2020-09-09T18:47:20Z", "type": "commit"}, {"oid": "620c4226a4556e63ac5f90c348cba2e95d492126", "url": "https://github.com/IQSS/dataverse/commit/620c4226a4556e63ac5f90c348cba2e95d492126", "message": "another csv add", "committedDate": "2020-09-09T18:47:25Z", "type": "commit"}, {"oid": "e4965d10414abbf8a1793b3c693aa18eeb39ed8d", "url": "https://github.com/IQSS/dataverse/commit/e4965d10414abbf8a1793b3c693aa18eeb39ed8d", "message": "don't show 0 total count dates in timeseries", "committedDate": "2020-09-10T18:13:19Z", "type": "commit"}, {"oid": "435a6d2e6cf040861143d14c6dc3c509e016b490", "url": "https://github.com/IQSS/dataverse/commit/435a6d2e6cf040861143d14c6dc3c509e016b490", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2020-10-06T15:18:24Z", "type": "commit"}, {"oid": "b249c8757306d829bd374881df615fbde0e6f3ea", "url": "https://github.com/IQSS/dataverse/commit/b249c8757306d829bd374881df615fbde0e6f3ea", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2020-10-08T18:36:48Z", "type": "commit"}, {"oid": "88dc2958082b6094bc4abccac30adf6158988435", "url": "https://github.com/IQSS/dataverse/commit/88dc2958082b6094bc4abccac30adf6158988435", "message": "debug log causes failure with no dataverse sent", "committedDate": "2020-10-12T15:47:33Z", "type": "commit"}, {"oid": "d3d401bb0b7a43e3c8795e659d8a1dfc2212c1f2", "url": "https://github.com/IQSS/dataverse/commit/d3d401bb0b7a43e3c8795e659d8a1dfc2212c1f2", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2020-10-20T18:15:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzNjY1NQ==", "url": "https://github.com/IQSS/dataverse/pull/7178#discussion_r510436655", "bodyText": "I assume this isn't supposed to say \"foo.bar\" but I doubt it's a big deal.", "author": "pdurbin", "createdAt": "2020-10-22T20:27:33Z", "path": "src/main/resources/db/migration/V5.0.0.1__7177-newmetrics.sql", "diffHunk": "@@ -0,0 +1,13 @@\n+\n+alter table metric add column if not exists dataverse_id bigint;\n+\n+DO $$\n+BEGIN\n+\n+  BEGIN\n+    alter table metric add constraint fk_metric_dataverse_id FOREIGN KEY (dataverse_id) REFERENCES dataverse(id);\n+  EXCEPTION\n+    WHEN duplicate_object THEN RAISE NOTICE 'Table constraint foo.bar already exists';", "originalCommit": "d3d401bb0b7a43e3c8795e659d8a1dfc2212c1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MTk5Nw==", "url": "https://github.com/IQSS/dataverse/pull/7178#discussion_r510451997", "bodyText": ":-) - caught at cut/paste !", "author": "qqmyers", "createdAt": "2020-10-22T20:56:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzNjY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzNzQwNQ==", "url": "https://github.com/IQSS/dataverse/pull/7178#discussion_r510437405", "bodyText": "This method doesn't handle arbitrary JSON. Maybe rename to flatJsonToCsv? And add some docs on when to use it?", "author": "pdurbin", "createdAt": "2020-10-22T20:29:00Z", "path": "src/main/java/edu/harvard/iq/dataverse/util/FileUtil.java", "diffHunk": "@@ -1901,4 +1903,16 @@ public static boolean isFileAlreadyUploaded(DataFile dataFile, Map checksumMapNe\n         return false;\n     }\n \n+    public static String jsonToCSV(JsonArray jsonArray, String... headers) {", "originalCommit": "d3d401bb0b7a43e3c8795e659d8a1dfc2212c1f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MDQxMw==", "url": "https://github.com/IQSS/dataverse/pull/7178#discussion_r510440413", "bodyText": "I'm used to the \"orDie\" methods working including the original findDataverseOrDie to work in certain way, to work on unpublished things, to throw a WrappedResponse when it can't be found. Since this method only returns published dataverses maybe it could be renamed? This is just a passing thought. I can also live with it with the current name.", "author": "pdurbin", "createdAt": "2020-10-22T20:34:42Z", "path": "src/main/java/edu/harvard/iq/dataverse/api/Metrics.java", "diffHunk": "@@ -26,404 +41,836 @@\n  */\n @Path(\"info/metrics\")\n public class Metrics extends AbstractApiBean {\n+    private static final Logger logger = Logger.getLogger(Metrics.class.getName());\n \n     /** Dataverses */\n-    \n+\n     @GET\n     @Path(\"dataverses\")\n-    public Response getDataversesAllTime(@Context UriInfo uriInfo) {\n-        return getDataversesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    public Response getDataversesAllTime(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDataversesToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"dataverses/toMonth\")\n-    public Response getDataversesToMonthCurrent(@Context UriInfo uriInfo) {\n-        return getDataversesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    @Path(\"dataverses/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDataversesTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"dataverses\";\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+\n+            jsonArray = metricsSvc.getDataversesTimeSeries(uriInfo, d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"dataverses.timeseries.csv\");\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/toMonth/{yyyymm}\")\n-    public Response getDataversesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getDataversesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"dataversesToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.dataversesToMonth(sanitizedyyyymm);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, jsonString));\n-            }\n+        String metricName = \"dataversesToMonth\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n \n-        //TODO: Eventually the catch in each endpoint should be more specific\n-        //          and more general errors should be logged.\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.dataversesToMonth(sanitizedyyyymm, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n+\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/pastDays/{days}\")\n-    public Response getDataversesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getDataversesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"dataversesPastDays\";\n-        \n-        if(days < 1) {\n+\n+        if (days < 1) {\n             return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n         }\n-        try {\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null, d));\n \n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.dataversesPastDays(days);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), null, jsonString));\n-            }\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.dataversesPastDays(days, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), null, d, jsonObj.toString()));\n+        }\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        return ok(jsonObj);\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n-        }\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/byCategory\")\n-    public Response getDataversesByCategory(@Context UriInfo uriInfo) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDataversesByCategory(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"dataversesByCategory\";\n \n-        try {\n-            String jsonArrayString = metricsSvc.returnUnexpiredCacheAllTime(metricName, null);\n+        String metricName = \"dataversesByCategory\";\n \n-            if (null == jsonArrayString) { //run query and save\n-                JsonArrayBuilder jsonArrayBuilder = MetricsUtil.dataversesByCategoryToJson(metricsSvc.dataversesByCategory());\n-                jsonArrayString = jsonArrayBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, null, null, jsonArrayString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n \n-            return ok(MetricsUtil.stringToJsonArrayBuilder(jsonArrayString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = MetricsUtil.dataversesByCategoryToJson(metricsSvc.dataversesByCategory(d)).build();\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n         }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.CATEGORY, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"dataverses.byCategory.csv\");\n     }\n-    \n+\n     @GET\n     @Path(\"dataverses/bySubject\")\n-    public Response getDataversesBySubject(@Context UriInfo uriInfo) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDataversesBySubject(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"dataversesBySubject\";\n-        \n-        try {\n-            String jsonArrayString = metricsSvc.returnUnexpiredCacheAllTime(metricName, null);\n \n-            if (null == jsonArrayString) { //run query and save\n-                JsonArrayBuilder jsonArrayBuilder = MetricsUtil.dataversesBySubjectToJson(metricsSvc.dataversesBySubject());\n-                jsonArrayString = jsonArrayBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, null, null, jsonArrayString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = MetricsUtil.dataversesBySubjectToJson(metricsSvc.dataversesBySubject(d)).build();\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n \n-            return ok(MetricsUtil.stringToJsonArrayBuilder(jsonArrayString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n         }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.SUBJECT, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"dataverses.bySubject.csv\");\n     }\n-    \n+\n     /** Datasets */\n-    \n+\n     @GET\n     @Path(\"datasets\")\n-    public Response getDatasetsAllTime(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation) {\n-        return getDatasetsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation);\n+    public Response getDatasetsAllTime(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDatasetsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation, parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"datasets/toMonth\")\n-    public Response getDatasetsToMonthCurrent(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation) {\n-        return getDatasetsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation);\n+    @Path(\"datasets/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDatasetsTimeSeriest(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"datasets\";\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+\n+            jsonArray = metricsSvc.getDatasetsTimeSeries(uriInfo, dataLocation, d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datasets.timeseries.csv\");\n     }\n \n     @GET\n     @Path(\"datasets/toMonth/{yyyymm}\")\n-    public Response getDatasetsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"dataLocation\"});\n+    public Response getDatasetsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"datasetsToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.datasetsToMonth(sanitizedyyyymm, validDataLocation);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, jsonString));\n-            }\n+        String metricName = \"datasetsToMonth\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation, d));\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.datasetsToMonth(sanitizedyyyymm, validDataLocation, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n+\n     }\n-    \n+\n     @GET\n     @Path(\"datasets/pastDays/{days}\")\n-    public Response getDatasetsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"dataLocation\") String dataLocation) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"dataLocation\"});\n+    public Response getDatasetsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"datasetsPastDays\";\n-        \n-        if(days < 1) {\n+\n+        if (days < 1) {\n             return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n         }\n-        try {\n-            String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), validDataLocation);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.datasetsPastDays(days, validDataLocation);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), validDataLocation, jsonString));\n-            }\n-\n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), validDataLocation, d));\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.datasetsPastDays(days, validDataLocation, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), validDataLocation, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n+\n     }\n-    \n+\n     @GET\n     @Path(\"datasets/bySubject\")\n-    public Response getDatasetsBySubject(@Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation) {\n-        return getDatasetsBySubjectToMonth(uriInfo, MetricsUtil.getCurrentMonth(), dataLocation);\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDatasetsBySubject(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDatasetsBySubjectToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), dataLocation, parentAlias);\n     }\n-  \n+\n     @GET\n     @Path(\"datasets/bySubject/toMonth/{yyyymm}\")\n-    public Response getDatasetsBySubjectToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"dataLocation\"});\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDatasetsBySubjectToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"dataLocation\") String dataLocation, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"dataLocation\", \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"datasetsBySubjectToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n-            String jsonArrayString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation);\n-            \n-            if (null == jsonArrayString) { //run query and save\n-                JsonArrayBuilder jsonArrayBuilder = MetricsUtil.datasetsBySubjectToJson(metricsSvc.datasetsBySubjectToMonth(sanitizedyyyymm, validDataLocation));\n-                jsonArrayString = jsonArrayBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, jsonArrayString));\n-            }\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        String validDataLocation = MetricsUtil.validateDataLocationStringType(dataLocation);\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, validDataLocation, d));\n \n-            return ok(MetricsUtil.stringToJsonArrayBuilder(jsonArrayString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = MetricsUtil.datasetsBySubjectToJson(metricsSvc.datasetsBySubjectToMonth(sanitizedyyyymm, validDataLocation, d)).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, validDataLocation, d, jsonArray.toString()));\n         }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.SUBJECT, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datasets.bySubject.csv\");\n     }\n-    \n+\n     /** Files */\n     @GET\n     @Path(\"files\")\n-    public Response getFilesAllTime(@Context UriInfo uriInfo) {\n-        return getFilesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    public Response getFilesAllTime(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getFilesToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"files/toMonth\")\n-    public Response getFilesToMonthCurrent(@Context UriInfo uriInfo) {\n-        return getFilesToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    @Path(\"files/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFilesTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"files\";\n+\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+\n+            jsonArray = metricsSvc.filesTimeSeries(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datafiles.timeseries.csv\");\n     }\n \n     @GET\n     @Path(\"files/toMonth/{yyyymm}\")\n-    public Response getFilesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getFilesToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n-        String metricName = \"filesToMonth\";\n \n-        try {\n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.filesToMonth(sanitizedyyyymm);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, jsonString));\n-            }\n+        String metricName = \"filesToMonth\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        logger.fine(\"yyyymm: \" + sanitizedyyyymm);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+        logger.fine(\"Returned\");\n+        if (null == jsonObj) { // run query and save\n+            logger.fine(\"Getting filesToMonth : \" + sanitizedyyyymm + \" dvId=\" + ((d==null) ? \"not sent\" : d.getId()));\n+            Long count = metricsSvc.filesToMonth(sanitizedyyyymm, d);\n+            logger.fine(\"count = \" + count);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n         }\n+\n+        return ok(jsonObj);\n     }\n-    \n+\n     @GET\n     @Path(\"files/pastDays/{days}\")\n-    public Response getFilesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getFilesPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-            \n+\n         String metricName = \"filesPastDays\";\n-        \n-        if(days < 1) {\n+\n+        if (days < 1) {\n             return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n         }\n+\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null, d));\n+\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.filesPastDays(days, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+\n+    }\n+\n+    @GET\n+    @Path(\"/files/byType/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFilesByTypeTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n         try {\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null);\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"filesByType\";\n \n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.filesPastDays(days);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), null, jsonString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.filesByTypeTimeSeries(d, true);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.CONTENTTYPE, MetricsUtil.COUNT, MetricsUtil.SIZE), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datafiles.byType.timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"/files/byType\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFilesByType(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"filesByType\";\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = metricsSvc.filesByType(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n         }\n+\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.CONTENTTYPE, MetricsUtil.COUNT, MetricsUtil.SIZE), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"datafiles.byType.csv\");\n     }\n \n     /** Downloads */\n-    \n+\n     @GET\n     @Path(\"downloads\")\n-    public Response getDownloadsAllTime(@Context UriInfo uriInfo) {\n-        return getDownloadsToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    public Response getDownloadsAllTime(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDownloadsToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n     }\n-    \n-    @Deprecated //for better path\n+\n     @GET\n-    @Path(\"downloads/toMonth\")\n-    public Response getDownloadsToMonthCurrent(@Context UriInfo uriInfo) {\n-        return getDownloadsToMonth(uriInfo, MetricsUtil.getCurrentMonth());\n+    @Path(\"downloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"downloads\";\n+\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.downloadsTimeSeries(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"downloads.timeseries.csv\");\n     }\n \n     @GET\n     @Path(\"downloads/toMonth/{yyyymm}\")\n-    public Response getDownloadsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm) {                \n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    public Response getDownloadsToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-        \n+\n         String metricName = \"downloadsToMonth\";\n-        \n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonObj) { // run query and save\n+            Long count;\n+            try {\n+                count = metricsSvc.downloadsToMonth(sanitizedyyyymm, d);\n+            } catch (ParseException e) {\n+                return error(BAD_REQUEST, \"Unable to parse supplied date: \" + e.getLocalizedMessage());\n+            }\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+    }\n+\n+    @GET\n+    @Path(\"downloads/pastDays/{days}\")\n+    public Response getDownloadsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"downloadsPastDays\";\n+\n+        if (days < 1) {\n+            return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n+        }\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null, d));\n+\n+        if (null == jsonObj) { // run query and save\n+            Long count = metricsSvc.downloadsPastDays(days, d);\n+            jsonObj = MetricsUtil.countToJson(count).build();\n+            metricsSvc.save(new Metric(metricName, String.valueOf(days), null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+    }\n+\n+    @GET\n+    @Path(\"makeDataCount/{metric}\")\n+    public Response getMakeDataCountMetricCurrentMonth(@Context UriInfo uriInfo, @PathParam(\"metric\") String metricSupplied, @QueryParam(\"country\") String country, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getMakeDataCountMetricToMonth(uriInfo, metricSupplied, MetricsUtil.getCurrentMonth(), country, parentAlias);\n+    }\n+\n+    @GET\n+    @Path(\"makeDataCount/{metric}/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getMakeDataCountMetricTimeSeries(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"metric\") String metricSupplied, @QueryParam(\"country\") String country, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        MakeDataCountUtil.MetricType metricType = null;\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\", \"country\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        try {\n+            metricType = MakeDataCountUtil.MetricType.fromString(metricSupplied);\n+        } catch (IllegalArgumentException ex) {\n+            return error(Response.Status.BAD_REQUEST, ex.getMessage());\n+        }\n+        String metricName = \"MDC-\" + metricType.toString() + ((country == null) ? \"\" : \"-\" + country);\n+\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.mdcMetricTimeSeries(metricType, country, d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"makeDataCount.\" + metricType.toString() + \".timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"makeDataCount/{metric}/toMonth/{yyyymm}\")\n+    public Response getMakeDataCountMetricToMonth(@Context UriInfo uriInfo, @PathParam(\"metric\") String metricSupplied, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"country\") String country, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        MakeDataCountUtil.MetricType metricType = null;\n         try {\n-            \n-            String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n-            String jsonString = metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null);\n-\n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.downloadsToMonth(sanitizedyyyymm);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, jsonString));\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\", \"country\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        try {\n+            metricType = MakeDataCountUtil.MetricType.fromString(metricSupplied);\n+        } catch (IllegalArgumentException ex) {\n+            return error(Response.Status.BAD_REQUEST, ex.getMessage());\n+        }\n+        if (country != null) {\n+            country = country.toLowerCase();\n+\n+            if (!MakeDataCountUtil.isValidCountryCode(country)) {\n+                return error(Response.Status.BAD_REQUEST, \"Country must be one of the ISO 1366 Country Codes\");\n             }\n+        }\n+        String metricName = \"MDC-\" + metricType.toString() + ((country == null) ? \"\" : \"-\" + country);\n+\n+        String sanitizedyyyymm = null;\n+        if (yyyymm != null) {\n+            sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        }\n+\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        if (null == jsonObj) { // run query and save\n+            jsonObj = metricsSvc.getMDCDatasetMetrics(metricType, sanitizedyyyymm, country, d);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n+        }\n+\n+        return ok(jsonObj);\n+    }\n+    \n+    @GET\n+    @Path(\"filedownloads\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFileDownloadsAllTime(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getFileDownloadsToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+    \n+    @GET\n+    @Path(\"filedownloads/toMonth/{yyyymm}\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFileDownloadsToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n         }\n+\n+        String metricName = \"fileDownloads\";\n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonArray jsonArr = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonArr) { // run query and save\n+            jsonArr = metricsSvc.fileDownloads(sanitizedyyyymm, d, false);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonArr.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArr);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArr, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"filedownloads.csv\");\n     }\n     \n     @GET\n-    @Path(\"downloads/pastDays/{days}\")\n-    public Response getDownloadsPastDays(@Context UriInfo uriInfo, @PathParam(\"days\") int days) {\n-        try { \n-            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[]{\"\"});\n+    @Path(\"filedownloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getFileDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n         } catch (IllegalArgumentException ia) {\n             return error(BAD_REQUEST, ia.getLocalizedMessage());\n         }\n-                \n-        String metricName = \"downloadsPastDays\";\n-        \n-        if(days < 1) {\n-            return error(BAD_REQUEST, \"Invalid parameter for number of days.\");\n+        String metricName = \"fileDownloads\";\n+\n+        JsonArray jsonArr = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArr) { // run query and save\n+            // Only handling published right now\n+            jsonArr = metricsSvc.fileDownloadsTimeSeries(d, false);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArr.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArr);\n         }\n+        return ok(FileUtil.jsonToCSV(jsonArr, MetricsUtil.DATE, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"filedownloads.timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"uniquedownloads\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueDownloadsAllTime(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getUniqueDownloadsToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+\n+    @GET\n+    @Path(\"uniquedownloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n         try {\n-            String jsonString = metricsSvc.returnUnexpiredCacheDayBased(metricName, String.valueOf(days), null);\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"uniqueDownloads\";\n \n-            if (null == jsonString) { //run query and save\n-                Long count = metricsSvc.downloadsPastDays(days);\n-                JsonObjectBuilder jsonObjBuilder = MetricsUtil.countToJson(count);\n-                jsonString = jsonObjBuilder.build().toString();\n-                metricsSvc.save(new Metric(metricName, String.valueOf(days), null, jsonString));\n-            }\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.uniqueDownloadsTimeSeries(d);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquedownloads.timeseries.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"uniquedownloads/toMonth/{yyyymm}\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueDownloadsToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"uniqueDownloads\";\n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonArray) { // run query and save\n+            jsonArray = metricsSvc.uniqueDatasetDownloads(sanitizedyyyymm, d);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonArray.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquedownloads.csv\");\n+    }\n+\n+    @GET\n+    @Path(\"uniquefiledownloads\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueFileDownloadsAllTime(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getUniqueFileDownloadsToMonth(req, uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+    \n+    @GET\n+    @Path(\"uniquefiledownloads/toMonth/{yyyymm}\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueFileDownloadsToMonth(@Context Request req, @Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"uniquefileDownloads\";\n+\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+        JsonArray jsonArr = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+\n+        if (null == jsonArr) { // run query and save\n+            jsonArr = metricsSvc.fileDownloads(sanitizedyyyymm, d, true);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonArr.toString()));\n+        }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArr);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArr, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquefiledownloads.csv\");\n+    }\n+    \n+    @GET\n+    @Path(\"uniquefiledownloads/monthly\")\n+    @Produces(\"text/csv, application/json\")\n+    public Response getUniqueFileDownloadsTimeSeries(@Context Request req, @Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+        String metricName = \"uniquefileDownloads\";\n \n-            return ok(MetricsUtil.stringToJsonObjectBuilder(jsonString));\n+        JsonArray jsonArray = MetricsUtil.stringToJsonArray(metricsSvc.returnUnexpiredCacheAllTime(metricName, null, d));\n \n-        } catch (Exception ex) {\n-            return error(BAD_REQUEST, ex.getLocalizedMessage());\n+        if (null == jsonArray) { // run query and save\n+            // Only handling published right now\n+            jsonArray = metricsSvc.fileDownloadsTimeSeries(d, true);\n+            metricsSvc.save(new Metric(metricName, null, null, d, jsonArray.toString()));\n         }\n+        MediaType requestedType = getVariant(req, MediaType.valueOf(FileUtil.MIME_TYPE_CSV), MediaType.APPLICATION_JSON_TYPE);\n+        if ((requestedType != null) && (requestedType.equals(MediaType.APPLICATION_JSON_TYPE))) {\n+            return ok(jsonArray);\n+        }\n+        return ok(FileUtil.jsonToCSV(jsonArray, MetricsUtil.DATE, MetricsUtil.ID, MetricsUtil.PID, MetricsUtil.COUNT), MediaType.valueOf(FileUtil.MIME_TYPE_CSV), \"uniquefiledownloads.timeseries.csv\");\n+    }\n+    \n+    @GET\n+    @Path(\"tree\")\n+    public Response getDataversesTree(@Context UriInfo uriInfo, @QueryParam(\"parentAlias\") String parentAlias) {\n+        return getDataversesTreeToMonth(uriInfo, MetricsUtil.getCurrentMonth(), parentAlias);\n+    }\n+\n+    @GET\n+    @Path(\"tree/toMonth/{yyyymm}\")\n+    public Response getDataversesTreeToMonth(@Context UriInfo uriInfo, @PathParam(\"yyyymm\") String yyyymm, @QueryParam(\"parentAlias\") String parentAlias) {\n+\n+        Dataverse d = findDataverseOrDieIfNotFound(parentAlias);\n+\n+        try {\n+            errorIfUnrecongizedQueryParamPassed(uriInfo, new String[] { \"parentAlias\" });\n+        } catch (IllegalArgumentException ia) {\n+            return error(BAD_REQUEST, ia.getLocalizedMessage());\n+        }\n+\n+        String metricName = \"tree\";\n+        String sanitizedyyyymm = MetricsUtil.sanitizeYearMonthUserInput(yyyymm);\n+\n+        JsonObject jsonObj = MetricsUtil.stringToJsonObject(metricsSvc.returnUnexpiredCacheMonthly(metricName, sanitizedyyyymm, null, d));\n+        if (null == jsonObj) { // run query and save\n+            jsonObj = metricsSvc.getDataverseTree(d, sanitizedyyyymm, DatasetVersion.VersionState.RELEASED);\n+            metricsSvc.save(new Metric(metricName, sanitizedyyyymm, null, d, jsonObj.toString()));\n+        }\n+        return ok(jsonObj);\n     }\n \n     private void errorIfUnrecongizedQueryParamPassed(UriInfo uriDetails, String[] allowedQueryParams) throws IllegalArgumentException {\n-        for(String theKey : uriDetails.getQueryParameters().keySet()) {\n-            if(!Arrays.stream(allowedQueryParams).anyMatch(theKey::equals)) {\n+        for (String theKey : uriDetails.getQueryParameters().keySet()) {\n+            if (!Arrays.stream(allowedQueryParams).anyMatch(theKey::equals)) {\n                 throw new IllegalArgumentException(\"queryParameter \" + theKey + \" not supported for this endpont\");\n             }\n         }\n-        \n+\n     }\n-    \n+\n+    // Throws a WebApplicationException if alias is not null and Dataverse can't be\n+    // found\n+    private Dataverse findDataverseOrDieIfNotFound(String alias) {", "originalCommit": "d3d401bb0b7a43e3c8795e659d8a1dfc2212c1f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MTY3Mg==", "url": "https://github.com/IQSS/dataverse/pull/7178#discussion_r510451672", "bodyText": "Not sure I understand why this doesn't look like an orDie method - if the alias requested doesn't exist, it throws an exception (a WebApplicationException rather than WrappedResponse to use the updated error handling that's been added). Is it what is returned that is an issue or something else? Or just findPublishedDataverseOrDie ?", "author": "qqmyers", "createdAt": "2020-10-22T20:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MDQxMw=="}], "type": "inlineReview"}, {"oid": "4caed91f766582012a47a5308f1cfd906c501108", "url": "https://github.com/IQSS/dataverse/commit/4caed91f766582012a47a5308f1cfd906c501108", "message": "per @pdurbin's review, including additional documentation", "committedDate": "2020-10-28T21:39:40Z", "type": "commit"}, {"oid": "c373ddb1dbab05da50bc4b823ec6c1509cb810dc", "url": "https://github.com/IQSS/dataverse/commit/c373ddb1dbab05da50bc4b823ec6c1509cb810dc", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2020-10-30T17:55:31Z", "type": "commit"}, {"oid": "a49785d71db28462125b1f9225e855e98734e96c", "url": "https://github.com/IQSS/dataverse/commit/a49785d71db28462125b1f9225e855e98734e96c", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2020-11-03T20:23:03Z", "type": "commit"}, {"oid": "ff092f86445b1f42b67409e5cf7f5d6e682767b9", "url": "https://github.com/IQSS/dataverse/commit/ff092f86445b1f42b67409e5cf7f5d6e682767b9", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2021-01-08T18:47:44Z", "type": "commit"}, {"oid": "14c0e586e683a31645116383acb414d65df82fd1", "url": "https://github.com/IQSS/dataverse/commit/14c0e586e683a31645116383acb414d65df82fd1", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2021-01-29T18:59:19Z", "type": "commit"}, {"oid": "708b1e8d1c638825d809a60b551638447b9c4f9a", "url": "https://github.com/IQSS/dataverse/commit/708b1e8d1c638825d809a60b551638447b9c4f9a", "message": "Merge remote-tracking branch 'IQSS/develop' into\nIQSS/7177-enhance_metrics_api\n\nConflicts:\n\tdoc/sphinx-guides/source/api/metrics.rst", "committedDate": "2021-02-23T17:32:49Z", "type": "commit"}, {"oid": "3d505bb8b6046f83ef1ee7ebc8353ec311dc1ced", "url": "https://github.com/IQSS/dataverse/commit/3d505bb8b6046f83ef1ee7ebc8353ec311dc1ced", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2021-04-07T19:59:09Z", "type": "commit"}, {"oid": "c8810537cd8f2da07a382dc5e0e0b31ce9b45c3b", "url": "https://github.com/IQSS/dataverse/commit/c8810537cd8f2da07a382dc5e0e0b31ce9b45c3b", "message": "update flyway script number", "committedDate": "2021-04-07T20:11:45Z", "type": "commit"}, {"oid": "e642ff81eda0d73dd74183d85684b6d78a8652ba", "url": "https://github.com/IQSS/dataverse/commit/e642ff81eda0d73dd74183d85684b6d78a8652ba", "message": "fix github link", "committedDate": "2021-04-07T20:32:12Z", "type": "commit"}, {"oid": "0419166c2bb3ef16eb962eecb304f76f27d7e118", "url": "https://github.com/IQSS/dataverse/commit/0419166c2bb3ef16eb962eecb304f76f27d7e118", "message": "release notes", "committedDate": "2021-04-08T15:06:48Z", "type": "commit"}, {"oid": "cc1c06721a2a48785936464d684d4327c0b9bebc", "url": "https://github.com/IQSS/dataverse/commit/cc1c06721a2a48785936464d684d4327c0b9bebc", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2021-04-13T18:28:37Z", "type": "commit"}, {"oid": "e495cf74d61c042b655a4b3c90bd8f57a0ecdd8a", "url": "https://github.com/IQSS/dataverse/commit/e495cf74d61c042b655a4b3c90bd8f57a0ecdd8a", "message": "Merge remote-tracking branch 'IQSS/develop' into IQSS/7177-enhance_metrics_api", "committedDate": "2021-05-05T19:24:02Z", "type": "commit"}, {"oid": "1e4a4cf49c664334d5dc4176917861d441107129", "url": "https://github.com/IQSS/dataverse/commit/1e4a4cf49c664334d5dc4176917861d441107129", "message": "prevent text from being large #7177", "committedDate": "2021-05-10T15:46:10Z", "type": "commit"}, {"oid": "2b872621ee4327cb5887b8cc26d461fce9d13100", "url": "https://github.com/IQSS/dataverse/commit/2b872621ee4327cb5887b8cc26d461fce9d13100", "message": "rename flyway", "committedDate": "2021-05-12T14:39:15Z", "type": "commit"}, {"oid": "61e926d195acccca9276cf846570264183c39c28", "url": "https://github.com/IQSS/dataverse/commit/61e926d195acccca9276cf846570264183c39c28", "message": "Merge remote-tracking branch 'origin/IQSS/7177-enhance_metrics_api' into IQSS/7177-enhance_metrics_api", "committedDate": "2021-05-12T14:42:03Z", "type": "commit"}, {"oid": "35461b7af9087af89f99b251c3fc69dc4b9d2531", "url": "https://github.com/IQSS/dataverse/commit/35461b7af9087af89f99b251c3fc69dc4b9d2531", "message": "Report missing file sizes and return 0 instead of null", "committedDate": "2021-05-12T19:56:48Z", "type": "commit"}, {"oid": "bbbfcd152a6dd54c39d518a0220ec13011547035", "url": "https://github.com/IQSS/dataverse/commit/bbbfcd152a6dd54c39d518a0220ec13011547035", "message": "don't fire a log message if metricscachetimeoutminutes isn't set", "committedDate": "2021-05-12T20:50:23Z", "type": "commit"}, {"oid": "4abcb14793a85713c627a4ef1dbc35ad630a02f3", "url": "https://github.com/IQSS/dataverse/commit/4abcb14793a85713c627a4ef1dbc35ad630a02f3", "message": "add filetype metric api endpoint", "committedDate": "2020-08-11T02:48:31Z", "type": "commit"}, {"oid": "40571eeb9b85d9d9dd51e7c68cd5c2c3de0d9ad1", "url": "https://github.com/IQSS/dataverse/commit/40571eeb9b85d9d9dd51e7c68cd5c2c3de0d9ad1", "message": "missing query ending", "committedDate": "2020-08-11T02:48:50Z", "type": "commit"}, {"oid": "71bf16318450b2428a611e9916b7a5bff915213e", "url": "https://github.com/IQSS/dataverse/commit/71bf16318450b2428a611e9916b7a5bff915213e", "message": "add parens around in", "committedDate": "2020-08-11T02:49:03Z", "type": "commit"}, {"oid": "2ce60ea971d1b3ed0bac00d6ba9544a25371a77e", "url": "https://github.com/IQSS/dataverse/commit/2ce60ea971d1b3ed0bac00d6ba9544a25371a77e", "message": "typo", "committedDate": "2020-08-11T02:49:13Z", "type": "commit"}, {"oid": "34d1865861a9b381a36e029a506cb6aa7aa873f4", "url": "https://github.com/IQSS/dataverse/commit/34d1865861a9b381a36e029a506cb6aa7aa873f4", "message": "add count, fix names (case sensitive)", "committedDate": "2020-08-11T02:49:27Z", "type": "commit"}, {"oid": "470c13502033c199f1bee6afc8bb15828b961ec2", "url": "https://github.com/IQSS/dataverse/commit/470c13502033c199f1bee6afc8bb15828b961ec2", "message": "use native query", "committedDate": "2020-08-11T02:49:50Z", "type": "commit"}, {"oid": "246f36856e9433698596cee7429b629d52a0a75e", "url": "https://github.com/IQSS/dataverse/commit/246f36856e9433698596cee7429b629d52a0a75e", "message": "count is BigDecimal", "committedDate": "2020-08-11T02:50:01Z", "type": "commit"}, {"oid": "96492f71ab5657317498801716518c35f40e8ac2", "url": "https://github.com/IQSS/dataverse/commit/96492f71ab5657317498801716518c35f40e8ac2", "message": "determine types", "committedDate": "2020-08-11T02:50:12Z", "type": "commit"}, {"oid": "3e722a039f5fec63d130cce7de153b298499f774", "url": "https://github.com/IQSS/dataverse/commit/3e722a039f5fec63d130cce7de153b298499f774", "message": "remove debug", "committedDate": "2020-08-11T02:50:22Z", "type": "commit"}, {"oid": "9f08bf17e61e8af3b6c25e0580c98d85344dc355", "url": "https://github.com/IQSS/dataverse/commit/9f08bf17e61e8af3b6c25e0580c98d85344dc355", "message": "Enable per dataverse reporting of all metrics", "committedDate": "2020-08-11T02:51:00Z", "type": "commit"}, {"oid": "0764c20b16070bdf8c2530e289d113c5efe37cb8", "url": "https://github.com/IQSS/dataverse/commit/0764c20b16070bdf8c2530e289d113c5efe37cb8", "message": "Allow an ok(JsonObject) for convenience", "committedDate": "2020-08-11T02:51:12Z", "type": "commit"}, {"oid": "a5f3f680077f8166b49493246e3cb21bb7a2bd0f", "url": "https://github.com/IQSS/dataverse/commit/a5f3f680077f8166b49493246e3cb21bb7a2bd0f", "message": "simplify ok response type", "committedDate": "2020-08-11T02:51:28Z", "type": "commit"}, {"oid": "4525c3d47b5376f519c79c515e3e61852908fcb0", "url": "https://github.com/IQSS/dataverse/commit/4525c3d47b5376f519c79c515e3e61852908fcb0", "message": "sanitize incoming yyyymm info as in Metrics API", "committedDate": "2020-08-11T02:51:39Z", "type": "commit"}, {"oid": "ff6cd9639fe00a5edb39dfb7c0617957ae0e3bc6", "url": "https://github.com/IQSS/dataverse/commit/ff6cd9639fe00a5edb39dfb7c0617957ae0e3bc6", "message": "refactor response logic, add fileTypes by Date, add MDC per Dataverse", "committedDate": "2020-08-11T02:51:55Z", "type": "commit"}, {"oid": "d6aa0e81080ff2fc8afaace38f20fc0399e6880e", "url": "https://github.com/IQSS/dataverse/commit/d6aa0e81080ff2fc8afaace38f20fc0399e6880e", "message": "fix test to match MetricsUtil changes", "committedDate": "2020-08-11T02:52:10Z", "type": "commit"}, {"oid": "6b092383c71e839c3f57bb2d713bb07c5498e56c", "url": "https://github.com/IQSS/dataverse/commit/6b092383c71e839c3f57bb2d713bb07c5498e56c", "message": "allow parentAlias param", "committedDate": "2020-08-11T02:52:26Z", "type": "commit"}, {"oid": "b98b076d95296f89d63cf25f4268dba0981315f6", "url": "https://github.com/IQSS/dataverse/commit/b98b076d95296f89d63cf25f4268dba0981315f6", "message": "fix getMetric query", "committedDate": "2020-08-11T02:52:38Z", "type": "commit"}, {"oid": "37af77fd7f24a6f8c5e68629e55e106b29d98ebd", "url": "https://github.com/IQSS/dataverse/commit/37af77fd7f24a6f8c5e68629e55e106b29d98ebd", "message": "try entity as param", "committedDate": "2020-08-11T02:53:12Z", "type": "commit"}, {"oid": "7bec8bef808c56d778cc4638d275ae413005d351", "url": "https://github.com/IQSS/dataverse/commit/7bec8bef808c56d778cc4638d275ae413005d351", "message": "allow null and fix query", "committedDate": "2020-08-11T02:53:27Z", "type": "commit"}, {"oid": "b7aab41990bb047d2224b890e395499bf4d1b000", "url": "https://github.com/IQSS/dataverse/commit/b7aab41990bb047d2224b890e395499bf4d1b000", "message": "update join info", "committedDate": "2020-08-11T02:53:38Z", "type": "commit"}, {"oid": "2917413633fc95c383c7718664b49f6365e40dbf", "url": "https://github.com/IQSS/dataverse/commit/2917413633fc95c383c7718664b49f6365e40dbf", "message": "add unique download query", "committedDate": "2020-08-11T02:53:49Z", "type": "commit"}, {"oid": "913205fdf1f92702deb94858b2f555384d52179e", "url": "https://github.com/IQSS/dataverse/commit/913205fdf1f92702deb94858b2f555384d52179e", "message": "adjust query", "committedDate": "2020-08-11T02:54:00Z", "type": "commit"}, {"oid": "91d1619f186f678687a333f0a6a52d9da8605a14", "url": "https://github.com/IQSS/dataverse/commit/91d1619f186f678687a333f0a6a52d9da8605a14", "message": "try param name change", "committedDate": "2020-08-11T02:54:12Z", "type": "commit"}, {"oid": "1389107bfac7c2a5c12d36eef724773ba4f7d4df", "url": "https://github.com/IQSS/dataverse/commit/1389107bfac7c2a5c12d36eef724773ba4f7d4df", "message": "debug logging", "committedDate": "2020-08-11T02:54:30Z", "type": "commit"}, {"oid": "5f3c7929916f057441f2824ebf6a2b5aaa0f33b1", "url": "https://github.com/IQSS/dataverse/commit/5f3c7929916f057441f2824ebf6a2b5aaa0f33b1", "message": "typo", "committedDate": "2020-08-11T02:54:44Z", "type": "commit"}, {"oid": "bb9b21d759f11bca2bd97ed6a9fb08cf93b519c0", "url": "https://github.com/IQSS/dataverse/commit/bb9b21d759f11bca2bd97ed6a9fb08cf93b519c0", "message": "return null for null input and more debug", "committedDate": "2020-08-11T02:54:59Z", "type": "commit"}, {"oid": "c2550a0c84943162156ce7ee92dfe031db6dd6b5", "url": "https://github.com/IQSS/dataverse/commit/c2550a0c84943162156ce7ee92dfe031db6dd6b5", "message": "fix ? statement", "committedDate": "2020-08-11T02:55:25Z", "type": "commit"}, {"oid": "034c9381dee8f88ac6566c3ed5c92927869242e4", "url": "https://github.com/IQSS/dataverse/commit/034c9381dee8f88ac6566c3ed5c92927869242e4", "message": "merge with dvobject when needed", "committedDate": "2020-08-11T02:55:36Z", "type": "commit"}, {"oid": "8fb61d9ee55dcf4e5c059183820382bcc01492de", "url": "https://github.com/IQSS/dataverse/commit/8fb61d9ee55dcf4e5c059183820382bcc01492de", "message": "fix MDC query", "committedDate": "2020-08-11T02:55:57Z", "type": "commit"}, {"oid": "8214d028edbc2b376d8080d6ff6aa01320a8e1e8", "url": "https://github.com/IQSS/dataverse/commit/8214d028edbc2b376d8080d6ff6aa01320a8e1e8", "message": "alphabetic compare against string monthyear column", "committedDate": "2020-08-11T02:56:15Z", "type": "commit"}, {"oid": "cf61002c117da9088c4e64ca06bf020a3f835cb8", "url": "https://github.com/IQSS/dataverse/commit/cf61002c117da9088c4e64ca06bf020a3f835cb8", "message": "typo", "committedDate": "2020-08-11T02:56:36Z", "type": "commit"}, {"oid": "9df23ace56570cedb38bc6c84c7d8532abe42aac", "url": "https://github.com/IQSS/dataverse/commit/9df23ace56570cedb38bc6c84c7d8532abe42aac", "message": "more typos", "committedDate": "2020-08-11T02:56:48Z", "type": "commit"}, {"oid": "264a32440790e46c734c0b1ebee63fdb0d49d7ef", "url": "https://github.com/IQSS/dataverse/commit/264a32440790e46c734c0b1ebee63fdb0d49d7ef", "message": "handle country correctly", "committedDate": "2020-08-11T02:56:58Z", "type": "commit"}, {"oid": "804aca6914586976157781f873adda030e4ac76c", "url": "https://github.com/IQSS/dataverse/commit/804aca6914586976157781f873adda030e4ac76c", "message": "add debug logging", "committedDate": "2020-08-11T02:57:08Z", "type": "commit"}, {"oid": "770cc6b6be18e490b0a58b1c5c34079435f3b24a", "url": "https://github.com/IQSS/dataverse/commit/770cc6b6be18e490b0a58b1c5c34079435f3b24a", "message": "Validate country code to ISO 1366 and cache per country", "committedDate": "2020-08-11T02:57:18Z", "type": "commit"}, {"oid": "861a43e541238e49e3401c44269c814a4d6d5570", "url": "https://github.com/IQSS/dataverse/commit/861a43e541238e49e3401c44269c814a4d6d5570", "message": "make country codes transient", "committedDate": "2020-08-11T02:57:41Z", "type": "commit"}, {"oid": "a2cf4d375be1ffad7ddf27aeb4b41cff1d06130b", "url": "https://github.com/IQSS/dataverse/commit/a2cf4d375be1ffad7ddf27aeb4b41cff1d06130b", "message": "move country code validation out of Entity", "committedDate": "2020-08-11T02:57:50Z", "type": "commit"}, {"oid": "d8bc901822a96d7d62d848cddb09e9703acabc42", "url": "https://github.com/IQSS/dataverse/commit/d8bc901822a96d7d62d848cddb09e9703acabc42", "message": "handle null country case", "committedDate": "2020-08-11T02:58:00Z", "type": "commit"}, {"oid": "84ca24f4595849c2ba1dcfeeb2a3c2089c935615", "url": "https://github.com/IQSS/dataverse/commit/84ca24f4595849c2ba1dcfeeb2a3c2089c935615", "message": "handle null result representing 0 counts", "committedDate": "2020-08-11T02:58:14Z", "type": "commit"}, {"oid": "e07f461e61dc5613a84fdde62ad364c17794c57c", "url": "https://github.com/IQSS/dataverse/commit/e07f461e61dc5613a84fdde62ad364c17794c57c", "message": "default to current month instead of null", "committedDate": "2020-08-11T02:58:31Z", "type": "commit"}, {"oid": "b4ff22fd878ad74f61b709806be45f830839d496", "url": "https://github.com/IQSS/dataverse/commit/b4ff22fd878ad74f61b709806be45f830839d496", "message": "unique downloads endpoint", "committedDate": "2020-08-11T02:58:43Z", "type": "commit"}, {"oid": "6d55bbadf89606ed7467b39ad9b09b0a7524c6e2", "url": "https://github.com/IQSS/dataverse/commit/6d55bbadf89606ed7467b39ad9b09b0a7524c6e2", "message": "typo", "committedDate": "2020-08-11T02:58:54Z", "type": "commit"}, {"oid": "85413ceb9c72ca7fd3ca4ebdc001bf6e673b2eda", "url": "https://github.com/IQSS/dataverse/commit/85413ceb9c72ca7fd3ca4ebdc001bf6e673b2eda", "message": "try coalesce to avoid null", "committedDate": "2020-08-11T02:59:02Z", "type": "commit"}, {"oid": "662f44e335dfed681046f0af35a8d4d5449dc55f", "url": "https://github.com/IQSS/dataverse/commit/662f44e335dfed681046f0af35a8d4d5449dc55f", "message": "add json tree of dataverses endpoint", "committedDate": "2020-08-11T02:59:12Z", "type": "commit"}, {"oid": "cd59b71a1fb772311e439745c7d715ba645c205b", "url": "https://github.com/IQSS/dataverse/commit/cd59b71a1fb772311e439745c7d715ba645c205b", "message": "Simplify error handling\n\nMost methods with a throws Exception clause only throw Runtime\nexceptions\nThose exceptions should be being caught by the rest framework and in\n5.0+ by the new\nedu/harvard/iq/dataverse/api/errorhandlers/ThrowableHandler\n\nThe exceptions being caught directly now are all related to checking\nuser input and result in BAD_REQUEST status. Runtime exceptions should\nresult in INTERNAL_SERVER_ERROR status and post 5.0 will be logged via\nthe ThrowableHandler (see#7136).", "committedDate": "2020-08-11T02:59:23Z", "type": "commit"}, {"oid": "eb1dec0c5f89fb60c98de71c400ee2671ac46afb", "url": "https://github.com/IQSS/dataverse/commit/eb1dec0c5f89fb60c98de71c400ee2671ac46afb", "message": "reformatting only", "committedDate": "2020-08-11T02:59:34Z", "type": "commit"}, {"oid": "6dcd0a4426d930455ca5862b381968d7d20a89fa", "url": "https://github.com/IQSS/dataverse/commit/6dcd0a4426d930455ca5862b381968d7d20a89fa", "message": "fix type cast and check for no parent dataverse", "committedDate": "2020-08-11T02:59:44Z", "type": "commit"}, {"oid": "83b2f8131a7cbecad217054f7010732726f79628", "url": "https://github.com/IQSS/dataverse/commit/83b2f8131a7cbecad217054f7010732726f79628", "message": "fix logging statement", "committedDate": "2020-08-11T02:59:53Z", "type": "commit"}, {"oid": "836f36af5091079aad75ff7fd416efd886c4f8ac", "url": "https://github.com/IQSS/dataverse/commit/836f36af5091079aad75ff7fd416efd886c4f8ac", "message": "fix root case", "committedDate": "2020-08-11T03:00:00Z", "type": "commit"}, {"oid": "995f6b2779aee441a10df6b14285429fb416a318", "url": "https://github.com/IQSS/dataverse/commit/995f6b2779aee441a10df6b14285429fb416a318", "message": "handle null case", "committedDate": "2020-08-11T03:00:10Z", "type": "commit"}, {"oid": "ec2c75ea3c6170d68d9e009385880f6cf910d8c6", "url": "https://github.com/IQSS/dataverse/commit/ec2c75ea3c6170d68d9e009385880f6cf910d8c6", "message": "use constants", "committedDate": "2020-08-20T21:20:29Z", "type": "commit"}, {"oid": "b05fb49ee886a3fe6ec896a0eb21308760b81360", "url": "https://github.com/IQSS/dataverse/commit/b05fb49ee886a3fe6ec896a0eb21308760b81360", "message": "dataverse time series", "committedDate": "2020-08-20T21:20:40Z", "type": "commit"}, {"oid": "ab3e41bf1e10c9787d6caeb11c1b8102fe3c5513", "url": "https://github.com/IQSS/dataverse/commit/ab3e41bf1e10c9787d6caeb11c1b8102fe3c5513", "message": "typo", "committedDate": "2020-08-20T21:20:49Z", "type": "commit"}, {"oid": "8024709461326bff72d50eeec0a7287c0b019551", "url": "https://github.com/IQSS/dataverse/commit/8024709461326bff72d50eeec0a7287c0b019551", "message": "document params", "committedDate": "2020-08-20T21:21:04Z", "type": "commit"}, {"oid": "86553d18001208ce3590122a3a320d49bbd113d2", "url": "https://github.com/IQSS/dataverse/commit/86553d18001208ce3590122a3a320d49bbd113d2", "message": "datasets time series", "committedDate": "2020-08-20T21:21:34Z", "type": "commit"}, {"oid": "80aa9dc92b976066109ba56bcf61045f255730d6", "url": "https://github.com/IQSS/dataverse/commit/80aa9dc92b976066109ba56bcf61045f255730d6", "message": "logic issues, typos", "committedDate": "2020-08-20T21:21:44Z", "type": "commit"}, {"oid": "695b66eabf42e889b4b6a5cfc684d6fa71dcb94d", "url": "https://github.com/IQSS/dataverse/commit/695b66eabf42e889b4b6a5cfc684d6fa71dcb94d", "message": "logic, include parent in list", "committedDate": "2020-08-20T21:21:53Z", "type": "commit"}, {"oid": "33224e8ed97d5dbde7f81e3851c0b7a25bdcb714", "url": "https://github.com/IQSS/dataverse/commit/33224e8ed97d5dbde7f81e3851c0b7a25bdcb714", "message": "method name change", "committedDate": "2020-08-20T21:22:02Z", "type": "commit"}, {"oid": "c922d210048aa913b1d9d4cce53bd7aa0b91c6b7", "url": "https://github.com/IQSS/dataverse/commit/c922d210048aa913b1d9d4cce53bd7aa0b91c6b7", "message": "add params comment", "committedDate": "2020-08-20T21:22:12Z", "type": "commit"}, {"oid": "2a5b6ea962fa73b6a4f78d59348b18141f6a4b4a", "url": "https://github.com/IQSS/dataverse/commit/2a5b6ea962fa73b6a4f78d59348b18141f6a4b4a", "message": "fix add parent dataverse logic", "committedDate": "2020-08-20T21:22:22Z", "type": "commit"}, {"oid": "7879656cc44781eedf95c70a7c50d2851a2ee7da", "url": "https://github.com/IQSS/dataverse/commit/7879656cc44781eedf95c70a7c50d2851a2ee7da", "message": "reversed logic", "committedDate": "2020-08-20T21:22:31Z", "type": "commit"}, {"oid": "aaf43ea2327e0053e42ea944d2df66c89cfc0ef0", "url": "https://github.com/IQSS/dataverse/commit/aaf43ea2327e0053e42ea944d2df66c89cfc0ef0", "message": "add mimetype", "committedDate": "2020-08-20T21:22:40Z", "type": "commit"}, {"oid": "5f907dd30dff753202e964fe42489da49d3762e4", "url": "https://github.com/IQSS/dataverse/commit/5f907dd30dff753202e964fe42489da49d3762e4", "message": "add csv endpoint\n\nConflicts:\n\tsrc/main/java/edu/harvard/iq/dataverse/util/FileUtil.java", "committedDate": "2020-08-20T21:35:59Z", "type": "commit"}, {"oid": "54723d7718fd861f64f0dd9f4ef916327fde6651", "url": "https://github.com/IQSS/dataverse/commit/54723d7718fd861f64f0dd9f4ef916327fde6651", "message": "typo", "committedDate": "2020-08-20T21:36:23Z", "type": "commit"}, {"oid": "9b3d3c371dea2f0b6feae8218ce5516e5ad70437", "url": "https://github.com/IQSS/dataverse/commit/9b3d3c371dea2f0b6feae8218ce5516e5ad70437", "message": "convert int to string", "committedDate": "2020-08-20T21:36:37Z", "type": "commit"}, {"oid": "786e99b20073798632395ab688ec3c9ddeb20a97", "url": "https://github.com/IQSS/dataverse/commit/786e99b20073798632395ab688ec3c9ddeb20a97", "message": "use JsonValue", "committedDate": "2020-08-20T21:36:48Z", "type": "commit"}, {"oid": "1b23f574b545fd6622420e36c3ae607b5727f9ee", "url": "https://github.com/IQSS/dataverse/commit/1b23f574b545fd6622420e36c3ae607b5727f9ee", "message": "make CSV the default", "committedDate": "2020-08-20T21:37:04Z", "type": "commit"}, {"oid": "094db71ed0b27617c81e9558ce9e06343a9b1c6c", "url": "https://github.com/IQSS/dataverse/commit/094db71ed0b27617c81e9558ce9e06343a9b1c6c", "message": "calculate full time series", "committedDate": "2020-08-20T21:37:19Z", "type": "commit"}, {"oid": "d931e82a4e17c79248f0ed5613d72e0f88c930e1", "url": "https://github.com/IQSS/dataverse/commit/d931e82a4e17c79248f0ed5613d72e0f88c930e1", "message": "fix date parse issue", "committedDate": "2020-08-20T21:37:45Z", "type": "commit"}, {"oid": "ddef69e688b8f46f864fddad61c161665f3f1682", "url": "https://github.com/IQSS/dataverse/commit/ddef69e688b8f46f864fddad61c161665f3f1682", "message": "stop at last result", "committedDate": "2020-08-20T21:37:57Z", "type": "commit"}, {"oid": "43da4409c9cdb3f25bd61387a022a5c8d3c1ca5d", "url": "https://github.com/IQSS/dataverse/commit/43da4409c9cdb3f25bd61387a022a5c8d3c1ca5d", "message": "correct date", "committedDate": "2020-08-20T21:38:06Z", "type": "commit"}, {"oid": "19684f6bbc48d80661831de99224f792195d1075", "url": "https://github.com/IQSS/dataverse/commit/19684f6bbc48d80661831de99224f792195d1075", "message": "allow CORS requests to send accept header", "committedDate": "2020-08-20T21:38:17Z", "type": "commit"}, {"oid": "29fb5374d460ab7d631f4e520a630c34ab646831", "url": "https://github.com/IQSS/dataverse/commit/29fb5374d460ab7d631f4e520a630c34ab646831", "message": "datasets timeseries and csv export", "committedDate": "2020-08-20T21:38:28Z", "type": "commit"}, {"oid": "17788ceae149df1f9d17f214d618bb5c830b170c", "url": "https://github.com/IQSS/dataverse/commit/17788ceae149df1f9d17f214d618bb5c830b170c", "message": "cleanup", "committedDate": "2020-08-20T21:38:45Z", "type": "commit"}, {"oid": "c23b070681bcfd06664476bbacbf88e26f367f24", "url": "https://github.com/IQSS/dataverse/commit/c23b070681bcfd06664476bbacbf88e26f367f24", "message": "csv for dataverse by subject and category", "committedDate": "2020-08-20T21:38:55Z", "type": "commit"}, {"oid": "4d4a5ce06124640e6f9267c3c5dee71db127d024", "url": "https://github.com/IQSS/dataverse/commit/4d4a5ce06124640e6f9267c3c5dee71db127d024", "message": "datasets by subject csv", "committedDate": "2020-08-20T21:39:05Z", "type": "commit"}, {"oid": "8427d3fcee27615474f35ae9067c4746a05de3e6", "url": "https://github.com/IQSS/dataverse/commit/8427d3fcee27615474f35ae9067c4746a05de3e6", "message": "add files time series, timeseries util, restore /datasets", "committedDate": "2020-08-20T21:39:18Z", "type": "commit"}, {"oid": "e08fe4ac40b5a539475d34046c645ad3f7e9fd5d", "url": "https://github.com/IQSS/dataverse/commit/e08fe4ac40b5a539475d34046c645ad3f7e9fd5d", "message": "files by type time series with csv", "committedDate": "2020-08-20T21:39:28Z", "type": "commit"}, {"oid": "8981eb28ca5772ba971a844829d9720f63f0ad86", "url": "https://github.com/IQSS/dataverse/commit/8981eb28ca5772ba971a844829d9720f63f0ad86", "message": "downloads time series", "committedDate": "2020-08-20T21:39:38Z", "type": "commit"}, {"oid": "7ed9d6a5f703b233865bd80a69f39a223f08e5d8", "url": "https://github.com/IQSS/dataverse/commit/7ed9d6a5f703b233865bd80a69f39a223f08e5d8", "message": "MDC timeseries with csv", "committedDate": "2020-08-20T21:39:45Z", "type": "commit"}, {"oid": "2f70fa7cfaf3e87399524c35449b0f92a385f49e", "url": "https://github.com/IQSS/dataverse/commit/2f70fa7cfaf3e87399524c35449b0f92a385f49e", "message": "unique downloads timeseries and csv", "committedDate": "2020-08-20T21:39:55Z", "type": "commit"}, {"oid": "3976fb52ff52d526d94eee652ed7c2816074f17c", "url": "https://github.com/IQSS/dataverse/commit/3976fb52ff52d526d94eee652ed7c2816074f17c", "message": "update name of query select column", "committedDate": "2020-08-20T21:40:03Z", "type": "commit"}, {"oid": "0eed6d0db78ff5cccc7462f106fa80f921f26c6d", "url": "https://github.com/IQSS/dataverse/commit/0eed6d0db78ff5cccc7462f106fa80f921f26c6d", "message": "stop while when out of results", "committedDate": "2020-08-20T21:40:14Z", "type": "commit"}, {"oid": "edd6058b1fb6fd62044948bade072bc05a889728", "url": "https://github.com/IQSS/dataverse/commit/edd6058b1fb6fd62044948bade072bc05a889728", "message": "fix timeseriesbyX logic", "committedDate": "2020-08-20T21:40:23Z", "type": "commit"}, {"oid": "f46e6c5adc20c881a0144e7068ce36b281762971", "url": "https://github.com/IQSS/dataverse/commit/f46e6c5adc20c881a0144e7068ce36b281762971", "message": "use yyyy in pattern", "committedDate": "2020-08-21T18:04:32Z", "type": "commit"}, {"oid": "50d4d1b5d8e9ac28e9973f23c7382bbc82265178", "url": "https://github.com/IQSS/dataverse/commit/50d4d1b5d8e9ac28e9973f23c7382bbc82265178", "message": "use YearMonth", "committedDate": "2020-08-21T18:05:07Z", "type": "commit"}, {"oid": "d18b196c2b11ca32c25646f3d1ceded0cc5dd1f1", "url": "https://github.com/IQSS/dataverse/commit/d18b196c2b11ca32c25646f3d1ceded0cc5dd1f1", "message": "fix date parsing", "committedDate": "2020-08-21T18:06:53Z", "type": "commit"}, {"oid": "58f6c324dd6e892b8a3d3f94e9c55e5d1f622a6a", "url": "https://github.com/IQSS/dataverse/commit/58f6c324dd6e892b8a3d3f94e9c55e5d1f622a6a", "message": "update files/ByType, caching, naming cleanup\n\nConflicts:\n\tsrc/main/java/edu/harvard/iq/dataverse/api/Metrics.java", "committedDate": "2020-08-21T19:25:56Z", "type": "commit"}, {"oid": "13d31594e4a7c9fd7f7b55f1c69b1f43fe85bc56", "url": "https://github.com/IQSS/dataverse/commit/13d31594e4a7c9fd7f7b55f1c69b1f43fe85bc56", "message": "Constraining calls to require released parent dataverse\n\nchange in Metrics.java should result in a 400 error, avoiding leaking\ninfo that a draft dataverse with that alias exists\nchanges in service bean avoid listing un-released child\ndataverses/datasets in trees/lists - the individual queries should still\nfilter out un-released results, but a) just-in-case, and b) to be more\nefficient, we can filter here too", "committedDate": "2020-08-21T19:25:57Z", "type": "commit"}, {"oid": "5d2804e6053eee06d9af1dec9aebfe49dd7f1e03", "url": "https://github.com/IQSS/dataverse/commit/5d2804e6053eee06d9af1dec9aebfe49dd7f1e03", "message": "null check", "committedDate": "2020-08-25T16:15:26Z", "type": "commit"}, {"oid": "17411daf1437f49c92071a21754bda44a407cd30", "url": "https://github.com/IQSS/dataverse/commit/17411daf1437f49c92071a21754bda44a407cd30", "message": "fix queries", "committedDate": "2020-08-25T16:15:44Z", "type": "commit"}, {"oid": "b0c9867b693bc7af30efa5581608a3df8eaba6d0", "url": "https://github.com/IQSS/dataverse/commit/b0c9867b693bc7af30efa5581608a3df8eaba6d0", "message": "typo in query", "committedDate": "2020-08-25T16:15:56Z", "type": "commit"}, {"oid": "6ccb88a05c346a897e2989fe3624663a7f94d473", "url": "https://github.com/IQSS/dataverse/commit/6ccb88a05c346a897e2989fe3624663a7f94d473", "message": "typo cut/paste", "committedDate": "2020-08-25T16:16:05Z", "type": "commit"}, {"oid": "1ca4c4d234820d1dc22fcfb279dc5de6e236de61", "url": "https://github.com/IQSS/dataverse/commit/1ca4c4d234820d1dc22fcfb279dc5de6e236de61", "message": "typo - err in download counts", "committedDate": "2020-08-25T16:16:13Z", "type": "commit"}, {"oid": "c112dca4f01d85fe1451c8270f56a3a127339ef8", "url": "https://github.com/IQSS/dataverse/commit/c112dca4f01d85fe1451c8270f56a3a127339ef8", "message": "typo - autoescaped quotes", "committedDate": "2020-08-25T16:16:21Z", "type": "commit"}, {"oid": "5a8cbbc17e071a2ca58d6561a5b02f056c0d0990", "url": "https://github.com/IQSS/dataverse/commit/5a8cbbc17e071a2ca58d6561a5b02f056c0d0990", "message": "use array for unique downloads", "committedDate": "2020-08-25T16:16:29Z", "type": "commit"}, {"oid": "e3308cf2c3db3926b0144be0859c855a05d981ae", "url": "https://github.com/IQSS/dataverse/commit/e3308cf2c3db3926b0144be0859c855a05d981ae", "message": "fix where /and clauses for various cases", "committedDate": "2020-08-25T16:16:35Z", "type": "commit"}, {"oid": "f94a85e7fa030a2385587d6375ae084280b68dd1", "url": "https://github.com/IQSS/dataverse/commit/f94a85e7fa030a2385587d6375ae084280b68dd1", "message": "support downloads total and views total queries", "committedDate": "2020-08-25T16:16:43Z", "type": "commit"}, {"oid": "cc85f34d6981c92cc86110906ef9d51bd3baf235", "url": "https://github.com/IQSS/dataverse/commit/cc85f34d6981c92cc86110906ef9d51bd3baf235", "message": "all four aggregate metrics", "committedDate": "2020-08-25T16:16:49Z", "type": "commit"}, {"oid": "caa205ac56b6c6810449d18561291e4371360db5", "url": "https://github.com/IQSS/dataverse/commit/caa205ac56b6c6810449d18561291e4371360db5", "message": "order by popularity", "committedDate": "2020-08-27T17:04:21Z", "type": "commit"}]}