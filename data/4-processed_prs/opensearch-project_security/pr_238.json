{"pr_number": 238, "pr_title": "Adding capability to hot reload ssl certificates", "pr_createdAt": "2020-02-19T22:14:57Z", "pr_url": "https://github.com/opensearch-project/security/pull/238", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjgxMg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383442812", "bodyText": "Why is the advantage of having a setting for this? Any harm in enabling hot reload by default?", "author": "sujithvm", "createdAt": "2020-02-24T18:40:41Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -207,28 +210,40 @@ private static boolean isDisabled(final Settings settings) {\n     private static boolean isSslOnlyMode(final Settings settings) {\n         return settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_SSL_ONLY, false);\n     }\n-    \n+\n+    /**\n+     * SSL Cert will be reloadable if security is enabled and we are not in sslOnly mode\n+     * @param settings Elastic configuration settings\n+     * @return true if ssl cert reload is enabled else false\n+     */\n+    private static boolean isSslCertReloadable(final Settings settings) {\n+        return !isDisabled(settings) && !isSslOnlyMode(settings) && settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_SSL_CERT_RELOAD, false);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5OTMwNw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383499307", "bodyText": "Users should have the option of disabling hot reload, esp if they have their own on prem systems where they do not want to use this feature since it involves dynamically picking up sensitive certificate info from their nodes.", "author": "debjanibnrj", "createdAt": "2020-02-24T20:34:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUzNDYwMg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383534602", "bodyText": "This would imply that they would have certificates that never expire (long expiry) or would need a cluster restart to change this setting (restarting would spoil the purpose of having this feature itself).\nThis feature can be used only by security-admin. Anyways we should ensure picking up certificate info from the nodes is done safely.", "author": "sujithvm", "createdAt": "2020-02-24T21:48:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5ODE1NQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383598155", "bodyText": "@hardik-k-shah whats the rationale behind adding this flag in settings ?", "author": "sujithvm", "createdAt": "2020-02-25T00:41:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjgxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwNzk5NQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384107995", "bodyText": "@sujithvm  As @debjanibnrj mentioned, this flag is specially introduced to for users how do not want to expose this endpoint even for super admin and do now want hot-reload functionality due to their on-premise or infra security restriction.", "author": "hardik-k-shah", "createdAt": "2020-02-25T20:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MjgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0NTczMg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383445732", "bodyText": "Still return 200 if keystore is not initialized? 500 error?", "author": "sujithvm", "createdAt": "2020-02-24T18:46:21Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecerts endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecerts\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch node certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/nodecerts\n+     *\n+     * Sample response:\n+     * {\n+     *   \"node_cert_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=node-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN,\"\");\n+                } else {\n+                    try {\n+                        // Check if keystore initialised\n+                        if (odsks != null) {\n+                            final X509Certificate[] localCertificates = odsks.getTransportCerts();\n+                            builder.startObject();\n+                            if (localCertificates != null) {\n+                                builder.startArray(\"node_cert_list\");\n+                                for (X509Certificate localCertificate : localCertificates) {\n+                                    builder.startObject();\n+                                    builder.field(\"issuer_dn\", localCertificate.getIssuerDN().getName());\n+                                    builder.field(\"subject_dn\", localCertificate.getSubjectDN().toString());\n+                                    builder.field(\"not_before\", localCertificate.getNotBefore());\n+                                    builder.field(\"not_after\", localCertificate.getNotAfter());\n+                                    builder.endObject();\n+                                }\n+                                builder.endArray();\n+                            }\n+                            builder.endObject();\n+                        } else {\n+                            builder.field(\"message\", \"keystore is not initialized\");\n+                        }\n+\n+                        response = new BytesRestResponse(RestStatus.OK, builder);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0ODM0Nw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383448347", "bodyText": "What is the difference in creating api action through extending BaseRestHandler vs the other dlic/rest/api/ actions we have? Had refactored registerHandler to be in separate overridden function.", "author": "sujithvm", "createdAt": "2020-02-24T18:51:28Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecerts endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecerts\", this);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUzNzg5Ng==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383537896", "bodyText": "Implemented APIs in a way similar to the others mentioned in the ssl.rest package. Wanted consistency between APIs that are part of the same package.", "author": "debjanibnrj", "createdAt": "2020-02-24T21:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0ODM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MDYwMg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383450602", "bodyText": "Just for my understanding - is this action limited to super admins? Any chance client will use this information eg: admin roles", "author": "sujithvm", "createdAt": "2020-02-24T18:55:49Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecerts endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecerts\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch node certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/nodecerts\n+     *\n+     * Sample response:\n+     * {\n+     *   \"node_cert_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=node-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMjMwNw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383502307", "bodyText": "API action is limited to super admins only.", "author": "debjanibnrj", "createdAt": "2020-02-24T20:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MDYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MTI1Ng==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383451256", "bodyText": "If we are sending only information in the response, how about we have info in the path.", "author": "sujithvm", "createdAt": "2020-02-24T18:57:07Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecerts endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecerts\", this);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MjAzMg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383452032", "bodyText": "Update the documentation for sslcerts/reload", "author": "sujithvm", "createdAt": "2020-02-24T18:58:32Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint\n+ */\n+public class SSLCertReloadAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public SSLCertReloadAction(final Settings settings,\n+                               final RestController restController,\n+                               final OpenDistroSecurityKeyStore odsks,\n+                               final ThreadPool threadPool,\n+                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"/_opendistro/_security/sslcerts/reload\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/nodecerts", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MjU0OA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383452548", "bodyText": "Same as above. Throw error response if keystore is not initialized?", "author": "sujithvm", "createdAt": "2020-02-24T18:59:26Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint\n+ */\n+public class SSLCertReloadAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public SSLCertReloadAction(final Settings settings,\n+                               final RestController restController,\n+                               final OpenDistroSecurityKeyStore odsks,\n+                               final ThreadPool threadPool,\n+                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"/_opendistro/_security/sslcerts/reload\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/nodecerts\n+     *\n+     * NOTE: No request body is required. We will assume new certificates are loaded in the paths specified in your elasticsearch.yml file\n+     * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+     *\n+     * Sample response:\n+     * { \"message\": \"updated certs successfully\" }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN,\"\");\n+                } else {\n+                    try {\n+                        builder.startObject();\n+                        if (odsks != null) {\n+                            odsks.initSSLConfig();\n+                            builder.field(\"message\", \"updated certs successfully\");\n+                        } else {\n+                            builder.field( \"message\", \"keystore is not initialized\");\n+                        }\n+                        builder.endObject();\n+                        response = new BytesRestResponse(RestStatus.OK, builder);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1NDE0NA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383454144", "bodyText": "Move or consolidate this into PemKeyReader helper file?", "author": "sujithvm", "createdAt": "2020-02-24T19:02:33Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/util/SSLCertificateHelper.java", "diffHunk": "@@ -142,7 +147,19 @@ public static PrivateKey exportDecryptedKey(final KeyStore ks, final String alia\n \n         return null;\n     }\n-    \n+\n+    /**\n+     * Helper function to translate file format to X509Certificate\n+     * @param file Public Key File\n+     * @return X509Formatted File\n+     */\n+    public static X509Certificate convertFileToX509Certificate(File file) throws CertificateException, FileNotFoundException {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MzUzMw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383463533", "bodyText": "Trying to understand - we are comparing the set of new certs DNs vs current set DNs? Slightly confused by statement same Issuer DN.  Shouldnt it all be the same ?\n\nNot familiar with how DNs work.", "author": "sujithvm", "createdAt": "2020-02-24T19:21:23Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -227,306 +230,324 @@ private void initSSLConfig() {\n         }\n \n         if (transportSSLEnabled) {\n+            initTransportCerts();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n-\n-            if (rawKeyStoreFilePath != null) {\n-\n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n-                }\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpCerts();\n+        }\n+    }\n \n-                try {\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    private void initTransportCerts() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+        if (rawKeyStoreFilePath != null) {\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                try {\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n                 }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+                validateNewTransportCerts(transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);\n+                transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n+                    sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer: \" + e.toString(), e);\n             }\n+\n+        } else if (rawPemCertFilePath != null) {\n+\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n+                true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n+                true);\n+\n+            try {\n+                final File pemKeyFile = new File(pemKey);\n+                final File pemCertFile = new File(pemCertFilePath);\n+                final File trustedCasFile = new File(trustedCas);\n+                final X509Certificate[] transportKeystoreCerts = new X509Certificate[]{ SSLCertificateHelper.convertFileToX509Certificate(pemCertFile) };\n+\n+                validateNewTransportCerts(transportKeystoreCerts);\n+                setTransportSSLCerts(transportKeystoreCerts);\n+                transportServerSslContext = buildSSLServerContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+            }\n+\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n+                + \" must be set if transport ssl is reqested.\");\n         }\n+    }\n \n-        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n+    /**\n+     * Initializes certs used for client https communication\n+     */\n+    private void initHttpCerts() {\n+        final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+            null);\n+        final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n+            null);\n+        final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n \n-        if (!client && httpSSLEnabled) {\n+        if (rawKeystoreFilePath != null) {\n \n-            final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                    null);\n-            final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n-                    null);\n-            final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-            if (rawKeystoreFilePath != null) {\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n-\n-                log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n-                            + \" must be set if https is reqested.\");\n-                }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n-                        throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n-                                + \" must be set if http ssl and client auth is reqested.\");\n-                    }\n+            log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n+\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n+                    + \" must be set if https is reqested.\");\n+            }\n+\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n \n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n+                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n+                        + \" must be set if http ssl and client auth is reqested.\");\n                 }\n \n-                try {\n+            }\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n-                        ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                : keystorePassword.toCharArray());\n-                    }\n+            try {\n \n-                    final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n+                    ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+                }\n \n-                    if (httpKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n \n-                    if (httpKeystoreCert != null && httpKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < httpKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = httpKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"HTTP keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (httpKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    X509Certificate[] trustedHTTPCertificates = null;\n+                if (httpKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n+                X509Certificate[] trustedHTTPCertificates = null;\n \n-                        final String truststoreFilePath = resolve(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n \n-                        final String truststoreType = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n-                        final String truststorePassword = settings.get(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n-                                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                        final String truststoreAlias = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n+                    final String truststoreFilePath = resolve(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n \n-                        final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                        try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n-                            ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n-                        }\n-                        trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n+                    final String truststoreType = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n+                    final String truststorePassword = settings.get(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n+                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+                    final String truststoreAlias = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n+\n+                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                    try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n+                        ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n                     }\n+                    trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n+                }\n \n-                    httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+                httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n \n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n-                            e);\n-                }\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n+                    e);\n+            }\n+\n+        } else if (rawPemCertFilePath != null) {\n \n-            } else if (rawPemCertFilePath != null) {\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n+                false);\n \n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n-                        false);\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+                checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+            }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+\n+            try {\n+                httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n+                    trustedCas == null ? null : new File(trustedCas),\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-                    // if(trustedCas == null ||\n-                    // trustedCas.equals(env.config-File().toAbsolutePath().toString())) {\n-                    // throw new\n-                    // ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH\n-                    // + \" must be set if http ssl and client auth is reqested.\");\n-                    // }\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n+                + \" must be set if http ssl is reqested.\");\n+        }\n+    }\n \n-                    checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+    /**\n+     * Cert Issuer DN must be the same\n+     * @param newCerts Array of X509Certificates which will replace our current cert\n+     * @throws Exception if certificate is invalid\n+     */\n+    private void validateNewTransportCerts(final X509Certificate[] newCerts) throws Exception {\n \n-                }\n+        // First time we init certs ignore validity check\n+        if (transportCerts == null) {\n+            return;\n+        }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+        // Check if new X509 certs have been issued by the same Issuer DN", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2OTUyNw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383569527", "bodyText": "You're right, updated to check for Issuer/Subject and Principal.", "author": "debjanibnrj", "createdAt": "2020-02-24T23:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MzUzMw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMDg4Ng==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383620886", "bodyText": "why this class is part of rest? Should it be transport?", "author": "hardik-k-shah", "createdAt": "2020-02-25T02:06:15Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -48,6 +48,8 @@\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import com.amazon.opendistroforelasticsearch.security.ssl.rest.SSLCertReloadAction;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxMzMzMQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384213331", "bodyText": "this can be stay at common place (once we add Cert Renewal for rest layer as well)", "author": "hardik-k-shah", "createdAt": "2020-02-26T00:39:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMDg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMjcwNQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r383622705", "bodyText": "should we rename it to transportCertReloadable ? (as this is related to transport cert and not rest one ).", "author": "hardik-k-shah", "createdAt": "2020-02-25T02:13:43Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -167,6 +169,7 @@\n     private static final String KEYWORD = \".keyword\";\n     private final boolean dlsFlsAvailable;\n     private final Constructor<?> dlsFlsConstructor;\n+    private boolean sslCertReloadable;", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0NjcyNA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385846724", "bodyText": "Added hot reload support for http certificates as well. Keeping the naming generic.", "author": "debjanibnrj", "createdAt": "2020-02-28T18:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYyMjcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwNjMyMA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384106320", "bodyText": "same here", "author": "hardik-k-shah", "createdAt": "2020-02-25T20:24:37Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -48,6 +48,8 @@\n import java.util.stream.Collectors;\n import java.util.stream.Stream;\n \n+import com.amazon.opendistroforelasticsearch.security.ssl.rest.SSLCertReloadAction;\n+import com.amazon.opendistroforelasticsearch.security.ssl.rest.NodeCertInfoAction;", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwODY3Mw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384108673", "bodyText": "Should we rename it to transport? OPENDISTRO_SECURITY_TRANSPORT_CERT_RELOAD or OPENDISTRO_SECURITY_TRANSPORT_SSL_CERT_RELOAD", "author": "hardik-k-shah", "createdAt": "2020-02-25T20:29:29Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -951,6 +969,7 @@ public Settings additionalSettings() {\n             settings.add(Setting.boolSetting(ConfigConstants.OPENDISTRO_SECURITY_UNSUPPORTED_ALLOW_NOW_IN_DLS, false, Property.NodeScope, Property.Filtered));\n             settings.add(Setting.boolSetting(ConfigConstants.OPENDISTRO_SECURITY_UNSUPPORTED_RESTAPI_ALLOW_SECURITYCONFIG_MODIFICATION, false, Property.NodeScope, Property.Filtered));\n             settings.add(Setting.boolSetting(ConfigConstants.OPENDISTRO_SECURITY_UNSUPPORTED_ACCEPT_INVALID_CONFIG, false, Property.NodeScope, Property.Filtered));\n+            settings.add(Setting.boolSetting(ConfigConstants.OPENDISTRO_SECURITY_SSL_CERT_RELOAD, false, Property.NodeScope, Property.Filtered));", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0NzAxOA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385847018", "bodyText": "Keeping the naming generic since we plan on supporting both http and transport certificate hot reload.", "author": "debjanibnrj", "createdAt": "2020-02-28T18:16:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwODY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1MjY5Mw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384152693", "bodyText": "Node can have multiple type of certs (rest, transport and admin).  Should we be more specific in response to differentiate this?", "author": "hardik-k-shah", "createdAt": "2020-02-25T22:00:34Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecertsinfo endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecertsinfo\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch node certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/nodecertsinfo\n+     *\n+     * Sample response:\n+     * {\n+     *   \"node_cert_list\" : [", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1NDc3NA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384154774", "bodyText": "Are we audit logging this API calls? Most probably it should go under compliance logging.", "author": "hardik-k-shah", "createdAt": "2020-02-25T22:04:52Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecertsinfo endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1OTgxMQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384159811", "bodyText": "we should be defining here.. if it is rest or transport cert. (Ideally we should return details of both cert types)\nAnd we should hide admin cert details? (Just a thought to keep admin cert more secure)", "author": "hardik-k-shah", "createdAt": "2020-02-25T22:16:03Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecertsinfo endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecertsinfo\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch node certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/nodecertsinfo\n+     *\n+     * Sample response:\n+     * {\n+     *   \"node_cert_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=node-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Super admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN,\"\");\n+                } else {\n+                    try {\n+                        builder.startObject();\n+                        // Check if keystore initialised\n+                        if (odsks != null) {\n+                            final X509Certificate[] localCertificates = odsks.getTransportCerts();\n+                            if (localCertificates != null) {\n+                                builder.startArray(\"node_cert_list\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MTI5NA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384161294", "bodyText": "Do we get all field always even if cert is private or self signed cert (may be some of those filed might be optional) ? Will it get some default null / empty string value?", "author": "hardik-k-shah", "createdAt": "2020-02-25T22:19:33Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecertsinfo endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public NodeCertInfoAction(final Settings settings,\n+                              final RestController restController,\n+                              final OpenDistroSecurityKeyStore odsks,\n+                              final ThreadPool threadPool,\n+                              final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/nodecertsinfo\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch node certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/nodecertsinfo\n+     *\n+     * Sample response:\n+     * {\n+     *   \"node_cert_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=node-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Super admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN,\"\");\n+                } else {\n+                    try {\n+                        builder.startObject();\n+                        // Check if keystore initialised\n+                        if (odsks != null) {\n+                            final X509Certificate[] localCertificates = odsks.getTransportCerts();\n+                            if (localCertificates != null) {\n+                                builder.startArray(\"node_cert_list\");\n+                                for (X509Certificate localCertificate : localCertificates) {\n+                                    builder.startObject();\n+                                    builder.field(\"issuer_dn\", localCertificate.getIssuerDN().getName());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0NzY2Nw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385847667", "bodyText": "Thanks for pointing this out. Added null checks since some of these fields can be optional.", "author": "debjanibnrj", "createdAt": "2020-02-28T18:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MTI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjUwOA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384162508", "bodyText": "this API should be audit/compliance logged as well.  It should goes under compliance section as it is making changes to security parameter. May be we need to define new action for logging this.", "author": "hardik-k-shah", "createdAt": "2020-02-25T22:22:07Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNTUzOQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385935539", "bodyText": "Can you create issue to track this investigation?", "author": "hardik-k-shah", "createdAt": "2020-02-28T21:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNjgxOA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385936818", "bodyText": "Added https://github.com/opendistro-for-elasticsearch/security/issues/255", "author": "debjanibnrj", "createdAt": "2020-02-28T21:45:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2MjUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NTA1Ng==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384165056", "bodyText": "Is there a way we can specify action/type (rest or transport) into request? may be as an argument?\nWe should also have a way to mention which cert we are renewing. Is it transport or rest? Ideally, we should also support hot reloading (renewing) for rest layer cert for better user experience.", "author": "hardik-k-shah", "createdAt": "2020-02-25T22:28:04Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint\n+ */\n+public class SSLCertReloadAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public SSLCertReloadAction(final Settings settings,\n+                               final RestController restController,\n+                               final OpenDistroSecurityKeyStore odsks,\n+                               final ThreadPool threadPool,\n+                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"/_opendistro/_security/sslcerts/reload\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/sslcerts/reload\n+     *\n+     * NOTE: No request body is required. We will assume new certificates are loaded in the paths specified in your elasticsearch.yml file\n+     * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+     *\n+     * Sample response:\n+     * { \"message\": \"updated certs successfully\" }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0NzkzNg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385847936", "bodyText": "Sure, thanks for that insight. I've added support for rest and transport certificates.", "author": "debjanibnrj", "createdAt": "2020-02-28T18:18:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NTA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3Mzc2Ng==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384173766", "bodyText": "This detail is good. And we should also explicitly mention following things in documentation of this API/ comments/ description of this PR.\nTo keep sensitive certificate hot reload secure, this API will only allow renewing/replacing expired cert issued by same issuer and issued for the same domain/subject name.", "author": "hardik-k-shah", "createdAt": "2020-02-25T22:47:53Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0ODIyMQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385848221", "bodyText": "Sure. I've also added details to the existing PR regarding this feature and its implications.", "author": "debjanibnrj", "createdAt": "2020-02-28T18:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3Mzc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3NTkxMw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384175913", "bodyText": "Should we say Renewal (as we are not allowing any other cert reload different than current in use) ?", "author": "hardik-k-shah", "createdAt": "2020-02-25T22:52:43Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint\n+ */\n+public class SSLCertReloadAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public SSLCertReloadAction(final Settings settings,\n+                               final RestController restController,\n+                               final OpenDistroSecurityKeyStore odsks,\n+                               final ThreadPool threadPool,\n+                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"/_opendistro/_security/sslcerts/reload\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/sslcerts/reload\n+     *\n+     * NOTE: No request body is required. We will assume new certificates are loaded in the paths specified in your elasticsearch.yml file\n+     * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+     *\n+     * Sample response:\n+     * { \"message\": \"updated certs successfully\" }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+                // Check for Admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN,\"\");\n+                } else {\n+                    try {\n+                        builder.startObject();\n+                        if (odsks != null) {\n+                            odsks.initSSLConfig();\n+                            builder.field(\"message\", \"updated certs successfully\");\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.OK, builder);\n+                        } else {\n+                            builder.field( \"message\", \"keystore is not initialized\");\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                        }\n+                    } catch (final Exception e1) {\n+                        builder = channel.newBuilder();\n+                        builder.startObject();\n+                        builder.field(\"error\", e1.toString());\n+                        builder.endObject();\n+                        response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                    } finally {\n+                        if (builder != null) {\n+                            builder.close();\n+                        }\n+                    }\n+                }\n+                channel.sendResponse(response);\n+            }\n+        };\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"SSL Cert Reload Action\";", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0OTA1Nw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385849057", "bodyText": "After speaking with @aetter have decided to stick with reload. The connotation around \"renew\" is that we'd be re-issuing certificates.", "author": "debjanibnrj", "createdAt": "2020-02-28T18:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3NTkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3NjY5Nw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384176697", "bodyText": "[Debatable] ssl_cert_reload  --> ssl_cert_hot_renewal (can be use same flag for both rest and transport cert)", "author": "hardik-k-shah", "createdAt": "2020-02-25T22:54:43Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/support/ConfigConstants.java", "diffHunk": "@@ -209,9 +209,8 @@\n     public static final String OPENDISTRO_SECURITY_COMPLIANCE_SALT = \"opendistro_security.compliance.salt\";\n     public static final String OPENDISTRO_SECURITY_COMPLIANCE_SALT_DEFAULT = \"e1ukloTsQlOgPquJ\";//16 chars\n     public static final String OPENDISTRO_SECURITY_COMPLIANCE_HISTORY_INTERNAL_CONFIG_ENABLED  = \"opendistro_security.compliance.history.internal_config_enabled\";\n-\n+    public static final String OPENDISTRO_SECURITY_SSL_CERT_RELOAD = \"opendistro_security.ssl_cert_reload\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MDE1OA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384190158", "bodyText": "why do we need these attributes separately? Can't we read them from cert using ssl library?", "author": "hardik-k-shah", "createdAt": "2020-02-25T23:29:40Z", "path": "src/test/resources/ssl/reload/node-new.crt.pem", "diffHunk": "@@ -0,0 +1,88 @@\n+Bag Attributes", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0NjI0NQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385846245", "bodyText": "Bag attributes in OpenSSL PEM files seem to be a side effect of converting a PKCS#12 keypair into PEM format.", "author": "debjanibnrj", "createdAt": "2020-02-28T18:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MDE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NzUwOQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384197509", "bodyText": "Should we also validate expiry? (expiry of a new cert should be later than old cert)", "author": "hardik-k-shah", "createdAt": "2020-02-25T23:51:10Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -522,14 +531,43 @@ public SSLEngine createServerTransportSSLEngine() throws SSLException {\n         final SSLEngine engine = transportServerSslContext.newEngine(PooledByteBufAllocator.DEFAULT);\n         engine.setEnabledProtocols(getEnabledSSLProtocols(this.sslTransportServerProvider, false));\n         return engine;\n+    }\n \n+    /**\n+     * Cert Issuer, Subject and Principal DN must be the same\n+     * @param newCerts Array of X509Certificates which will replace our current cert\n+     * @throws Exception if certificate is invalid\n+     */\n+    private void validateNewTransportCerts(final X509Certificate[] newCerts) throws Exception {\n+\n+        // First time we init certs ignore validity check\n+        if (transportCerts == null) {\n+            return;\n+        }\n+\n+        // Check if new X509 certs have been issued by the same Issuer DN - Subject DN - Principal\n+\n+        // Create a sorted array of string with format IssuerDN/SubjectDN/Principal\n+        final List<String> currentCertDNList = Arrays.stream(transportCerts)\n+            .map(c -> c.getIssuerDN()+\"/\"+c.getSubjectDN()+\"/\"+c.getIssuerX500Principal().getName())\n+            .sorted()\n+            .collect(Collectors.toList());\n+        final List<String> newCertDNList = Arrays.stream(newCerts)\n+            .map(c -> c.getIssuerDN()+\"/\"+c.getSubjectDN()+\"/\"+c.getIssuerX500Principal().getName())\n+            .sorted()\n+            .collect(Collectors.toList());\n+\n+        // Both arrays must be equal\n+        if (!currentCertDNList.equals(newCertDNList)) {\n+            throw new Exception(\"DNs of new cert do not match\");\n+        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg0OTMxNw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385849317", "bodyText": "Thanks for the suggestion. Have added a check for expiry as well.", "author": "debjanibnrj", "createdAt": "2020-02-28T18:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NzUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5ODUzMg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384198532", "bodyText": "is it possible to move line 319 to 326 into another function and reuse that code for 344 to avoid duplicity ? You need to handle password requirement with conditions.", "author": "hardik-k-shah", "createdAt": "2020-02-25T23:54:15Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -290,71 +293,77 @@ private void initSSLConfig() {\n                         /*\n                          * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n                          * x509Certificate = transportKeystoreCert[i];\n-                         * \n+                         *\n                          * if(x509Certificate != null) {\n                          * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n                          * getSubjectX500Principal()); } }\n                          */\n                     } else {\n                         throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                            \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                     }\n \n                     final KeyStore ts = KeyStore.getInstance(truststoreType);\n                     ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+                        (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n \n                     final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+                        .exportRootCertificates(ts, truststoreAlias);\n+\n \n                     if (trustedTransportCertificates == null) {\n                         throw new ElasticsearchException(\"No truststore configured for server\");\n                     }\n \n+                    validateNewTransportCerts(transportKeystoreCert);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5OTY1OA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384199658", "bodyText": "We should also see if we can remove duplicity between initTransportCert() and initHTTPCert()", "author": "hardik-k-shah", "createdAt": "2020-02-25T23:57:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5ODUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg1MzI4NQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385853285", "bodyText": "Sure. I created an issue in our backlog for the same https://github.com/opendistro-for-elasticsearch/security/issues/254", "author": "debjanibnrj", "createdAt": "2020-02-28T18:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5ODUzMg=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMDcxNg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384100716", "bodyText": "Shouldn't the name of this class be similar to API \"NodeCertsInfoAction\" (with plural \"Certs\") ?", "author": "dinusX", "createdAt": "2020-02-25T20:13:01Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/NodeCertInfoAction.java", "diffHunk": "@@ -0,0 +1,132 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get information SSL Transport certificates used for node to node encryption.\n+ * Currently this action serves GET request for /_opendistro/_security/nodecertsinfo endpoint\n+ */\n+public class NodeCertInfoAction extends BaseRestHandler {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDIyOQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385954229", "bodyText": "Updated this API", "author": "debjanibnrj", "createdAt": "2020-02-28T22:36:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMDcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMzExNA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384103114", "bodyText": "Same question as in previous action. Shouldn't \"Cert\" be plural in the name to keep it consistent with the API url?", "author": "dinusX", "createdAt": "2020-02-25T20:17:54Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/SSLCertReloadAction.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reinitialize SSL certificates.\n+ * Can be used to replace SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that any new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * Currently this action serves PUT request for /_opendistro/_security/sslcerts/reload endpoint\n+ */\n+public class SSLCertReloadAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public SSLCertReloadAction(final Settings settings,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDI3NQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385954275", "bodyText": "Updated this API.", "author": "debjanibnrj", "createdAt": "2020-02-28T22:36:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMzExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzNTUxMA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384135510", "bodyText": "You removed the check \".length > 0\". Why ? Shouldn't we throw exceptions if \"transportKeystoreCert\" is empty ( [] ) ?\nSimilar comment for the other \"if\" blocks where you removed \"length > 0\" checks.", "author": "dinusX", "createdAt": "2020-02-25T21:26:11Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -227,306 +231,319 @@ private void initSSLConfig() {\n         }\n \n         if (transportSSLEnabled) {\n+            initTransportCerts();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n-\n-            if (rawKeyStoreFilePath != null) {\n-\n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n-                }\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpCerts();\n+        }\n+    }\n \n-                try {\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    private void initTransportCerts() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+        if (rawKeyStoreFilePath != null) {\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                if (transportKeystoreCert == null) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MzgxNw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385963817", "bodyText": "I'll add the check back. Thanks for pointing it out.", "author": "debjanibnrj", "createdAt": "2020-02-28T23:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzNTUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0MTM4Mw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384141383", "bodyText": "Needs review", "author": "dinusX", "createdAt": "2020-02-25T21:38:22Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -227,306 +231,319 @@ private void initSSLConfig() {\n         }\n \n         if (transportSSLEnabled) {\n+            initTransportCerts();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n-\n-            if (rawKeyStoreFilePath != null) {\n-\n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n-                }\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpCerts();\n+        }\n+    }\n \n-                try {\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    private void initTransportCerts() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+        if (rawKeyStoreFilePath != null) {\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                try {\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n                 }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+                validateNewTransportCerts(transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);\n+                transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n+                    sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer: \" + e.toString(), e);\n             }\n-        }\n \n-        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n+        } else if (rawPemCertFilePath != null) {\n+\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n+                true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n+                true);\n+\n+            try {\n+                final File pemKeyFile = new File(pemKey);\n+                final File pemCertFile = new File(pemCertFilePath);\n+                final File trustedCasFile = new File(trustedCas);\n+                final X509Certificate[] transportKeystoreCerts = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+\n+                validateNewTransportCerts(transportKeystoreCerts);\n+                setTransportSSLCerts(transportKeystoreCerts);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0NTQxOA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384145418", "bodyText": "Do we need some logging ? is this the right exceptio n?", "author": "dinusX", "createdAt": "2020-02-25T21:46:08Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -227,306 +231,319 @@ private void initSSLConfig() {\n         }\n \n         if (transportSSLEnabled) {\n+            initTransportCerts();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n-\n-            if (rawKeyStoreFilePath != null) {\n-\n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n-                }\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpCerts();\n+        }\n+    }\n \n-                try {\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    private void initTransportCerts() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+        if (rawKeyStoreFilePath != null) {\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                try {\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n                 }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+                validateNewTransportCerts(transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);\n+                transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n+                    sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer: \" + e.toString(), e);\n             }\n-        }\n \n-        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n+        } else if (rawPemCertFilePath != null) {\n+\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n+                true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n+                true);\n+\n+            try {\n+                final File pemKeyFile = new File(pemKey);\n+                final File pemCertFile = new File(pemCertFilePath);\n+                final File trustedCasFile = new File(trustedCas);\n+                final X509Certificate[] transportKeystoreCerts = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+\n+                validateNewTransportCerts(transportKeystoreCerts);\n+                setTransportSSLCerts(transportKeystoreCerts);\n+                transportServerSslContext = buildSSLServerContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-        if (!client && httpSSLEnabled) {\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n+                + \" must be set if transport ssl is reqested.\");\n+        }\n+    }\n \n-            final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                    null);\n-            final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n-                    null);\n-            final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n+    /**\n+     * Initializes certs used for client https communication\n+     */\n+    private void initHttpCerts() {\n+        final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+            null);\n+        final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n+            null);\n+        final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n \n-            if (rawKeystoreFilePath != null) {\n+        if (rawKeystoreFilePath != null) {\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n-\n-                log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n-                            + \" must be set if https is reqested.\");\n-                }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n-                        throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n-                                + \" must be set if http ssl and client auth is reqested.\");\n-                    }\n \n-                }\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n \n-                try {\n+            log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n-                        ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                : keystorePassword.toCharArray());\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n+                    + \" must be set if https is reqested.\");\n+            }\n \n-                    final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n \n-                    if (httpKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n+                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n+                        + \" must be set if http ssl and client auth is reqested.\");\n+                }\n \n-                    if (httpKeystoreCert != null && httpKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < httpKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = httpKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"HTTP keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            }\n \n-                    X509Certificate[] trustedHTTPCertificates = null;\n+            try {\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n+                    ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+                }\n \n-                        final String truststoreFilePath = resolve(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n+                final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n \n-                        final String truststoreType = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n-                        final String truststorePassword = settings.get(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n-                                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                        final String truststoreAlias = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n+                if (httpKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                        final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                        try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n-                            ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n-                        }\n-                        trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n-                    }\n+                if (httpKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+                X509Certificate[] trustedHTTPCertificates = null;\n \n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n-                            e);\n-                }\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n \n-            } else if (rawPemCertFilePath != null) {\n+                    final String truststoreFilePath = resolve(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n \n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n-                        false);\n+                    final String truststoreType = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n+                    final String truststorePassword = settings.get(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n+                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+                    final String truststoreAlias = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                    try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n+                        ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n+                    }\n+                    trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n+                }\n \n-                    // if(trustedCas == null ||\n-                    // trustedCas.equals(env.config-File().toAbsolutePath().toString())) {\n-                    // throw new\n-                    // ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH\n-                    // + \" must be set if http ssl and client auth is reqested.\");\n-                    // }\n+                httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n \n-                    checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n+                    e);\n+            }\n \n-                }\n+        } else if (rawPemCertFilePath != null) {\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n+                false);\n \n-                try {\n-                    httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            trustedCas == null ? null : new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n-                }\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+                checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+            }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n-                        + \" must be set if http ssl is reqested.\");\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+\n+            try {\n+                httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n+                    trustedCas == null ? null : new File(trustedCas),\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n             }\n \n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n+                + \" must be set if http ssl is reqested.\");\n         }\n     }\n \n-    public SSLEngine createHTTPSSLEngine() throws SSLException {\n+    /**\n+     * Cert Issuer, Subject and Principal DN must be the same\n+     * @param newCerts Array of X509Certificates which will replace our current cert\n+     * @throws Exception if certificate is invalid\n+     */\n+    private void validateNewTransportCerts(final X509Certificate[] newCerts) throws Exception {\n+\n+        // First time we init certs ignore validity check\n+        if (transportCerts == null) {\n+            return;\n+        }\n+\n+        // Check if new X509 certs have been issued by the same Issuer DN - Subject DN - Principal\n+\n+        // Create a sorted array of string with format IssuerDN/SubjectDN/Principal\n+        final List<String> currentCertDNList = Arrays.stream(transportCerts)\n+            .map(c -> c.getIssuerDN()+\"/\"+c.getSubjectDN()+\"/\"+c.getIssuerX500Principal().getName())\n+            .sorted()\n+            .collect(Collectors.toList());\n+        final List<String> newCertDNList = Arrays.stream(newCerts)\n+            .map(c -> c.getIssuerDN()+\"/\"+c.getSubjectDN()+\"/\"+c.getIssuerX500Principal().getName())\n+            .sorted()\n+            .collect(Collectors.toList());\n+\n+        // Both arrays must be equal\n+       if (!currentCertDNList.equals(newCertDNList)) {\n+           throw new Exception(\"DNs of new cert do not match\");\n+       }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDE2OQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385954169", "bodyText": "We will probably add some audit logging. This exception is thrown when DN's of the two certificates do not match.", "author": "debjanibnrj", "createdAt": "2020-02-28T22:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0NTQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0NjIzOQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r384146239", "bodyText": "Seeing second time", "author": "dinusX", "createdAt": "2020-02-25T21:47:49Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -227,306 +231,319 @@ private void initSSLConfig() {\n         }\n \n         if (transportSSLEnabled) {\n+            initTransportCerts();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n-\n-            if (rawKeyStoreFilePath != null) {\n-\n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n-                }\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpCerts();\n+        }\n+    }\n \n-                try {\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    private void initTransportCerts() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+        if (rawKeyStoreFilePath != null) {\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                try {\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n                 }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+                validateNewTransportCerts(transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4MDM3MQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385980371", "bodyText": "Yes, there is lot of duplicate code shared when http and transport certs are initialized. We will need to clean it up as part of Refactoring DefaultODSKS #254", "author": "debjanibnrj", "createdAt": "2020-02-29T00:30:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE0NjIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNTEzNw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385915137", "bodyText": "Do we need to check isDisabled and isSSLOnlyMode here ?\nIn the constructor of the class you already set \"sslCertReloadEnabled = false\" if any of the above flags are true.", "author": "dinusX", "createdAt": "2020-02-28T20:48:34Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/OpenDistroSecurityPlugin.java", "diffHunk": "@@ -207,28 +210,40 @@ private static boolean isDisabled(final Settings settings) {\n     private static boolean isSslOnlyMode(final Settings settings) {\n         return settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_SSL_ONLY, false);\n     }\n-    \n+\n+    /**\n+     * SSL Cert Reload will be enabled only if security is not disabled and not in we are not using sslOnly mode.\n+     * @param settings Elastic configuration settings\n+     * @return true if ssl cert reload is enabled else false\n+     */\n+    private static boolean isSslCertReloadEnabled(final Settings settings) {\n+        return !isDisabled(settings) && !isSslOnlyMode(settings) && settings.getAsBoolean(ConfigConstants.OPENDISTRO_SECURITY_SSL_CERT_RELOAD_ENABLED, false);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NDY1MQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385954651", "bodyText": "Sure, I can remove this check. Thanks", "author": "debjanibnrj", "createdAt": "2020-02-28T22:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkxNTEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzMjA1NQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385932055", "bodyText": "minor: I would name this with \"..Certs..\" (plural), similar to the api \"../certs\" .\nSimilar comment for the other Action classes and test classes.", "author": "dinusX", "createdAt": "2020-02-28T21:32:25Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLCertInfoAction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get SSL certificate information related to http and transport encryption.\n+ * Only super admin users are allowed to access this API.\n+ * Currently this action serves GET request for _opendistro/_security/api/ssl/certs endpoint\n+ */\n+public class OpenDistroSecuritySSLCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public OpenDistroSecuritySSLCertInfoAction(final Settings settings,", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NTExMQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385955111", "bodyText": "Sure will update the naming", "author": "debjanibnrj", "createdAt": "2020-02-28T22:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzMjA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNDkxNw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385934917", "bodyText": "Shouldn't this be cert.getNotAfter() != null ?", "author": "dinusX", "createdAt": "2020-02-28T21:39:58Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLCertInfoAction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get SSL certificate information related to http and transport encryption.\n+ * Only super admin users are allowed to access this API.\n+ * Currently this action serves GET request for _opendistro/_security/api/ssl/certs endpoint\n+ */\n+public class OpenDistroSecuritySSLCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public OpenDistroSecuritySSLCertInfoAction(final Settings settings,\n+                                               final RestController restController,\n+                                               final OpenDistroSecurityKeyStore odsks,\n+                                               final ThreadPool threadPool,\n+                                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/api/ssl/certs\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch transport certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/api/ssl/certs\n+     *\n+     * Sample response:\n+     * {\n+     *   \"http_certificates_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=transport-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *  \"transport_certificates_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=transport-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *      }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+\n+                // Check for Super admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN, builder);\n+                } else {\n+                    try {\n+                        // Check if keystore initialised\n+                        if (odsks != null) {\n+                            builder.startObject();\n+                            builder.field(\"http_certificates_list\", generateCertDetailList(odsks.getHttpCerts()));\n+                            builder.field(\"transport_certificates_list\", generateCertDetailList(odsks.getTransportCerts()));\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.OK, builder);\n+                        } else {\n+                            builder.startObject();\n+                            builder.field(\"message\", \"keystore is not initialized\");\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                        }\n+                    } catch (final Exception e1) {\n+                        log.error(\"Error handle request \" + e1, e1);\n+                        builder = channel.newBuilder();\n+                        builder.startObject();\n+                        builder.field(\"error\", e1.toString());\n+                        builder.endObject();\n+                        response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                    } finally {\n+                        if (builder != null) {\n+                            builder.close();\n+                        }\n+                    }\n+                }\n+                channel.sendResponse(response);\n+            }\n+\n+            /**\n+             * Helper that construct list of certificate details.\n+             * @param certs list of certificates.\n+             * @return Array containing certificate details.\n+             */\n+            private List<Map<String, String>> generateCertDetailList(final X509Certificate[] certs) {\n+                if (certs == null) {\n+                    return null;\n+                }\n+                return Arrays.stream(certs)\n+                    .map(cert -> {\n+                        final String issuerDn = cert != null && cert.getIssuerX500Principal() != null ? cert.getIssuerX500Principal().getName(): \"\";\n+                        final String subjectDn = cert != null && cert.getSubjectX500Principal() != null ? cert.getSubjectX500Principal().getName(): \"\";\n+                        final String notBefore = cert != null && cert.getNotBefore() != null ? cert.getNotBefore().toInstant().toString(): \"\";\n+                        final String notAfter = cert != null && cert.getIssuerX500Principal() != null ? cert.getNotAfter().toInstant().toString(): \"\";", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NTM2OA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385955368", "bodyText": "Nice catch! yes", "author": "debjanibnrj", "createdAt": "2020-02-28T22:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNDkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNjkyNw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385936927", "bodyText": "You might want to convert this string to lowercase \".toLowerCase()\". And in case if there is any way to send parameters with spaces at the beginning or end of string, you might also consider using \".trim()\".", "author": "dinusX", "createdAt": "2020-02-28T21:45:23Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLReloadCertAction.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.DefaultObjectMapper;\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.dlic.rest.support.Utils;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reload SSL certificates.\n+ * Can be used to reload SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * To keep sensitive certificate reload secure, this API will only allow hot reload\n+ * with certificates issued by the same Issuer and Subject DN with expiry dates after the current one.\n+ * Currently this action serves PUT request for /_opendistro/_security/ssl/http/reloadcerts or /_opendistro/_security/ssl/transport/reloadcerts endpoint\n+ */\n+public class OpenDistroSecuritySSLReloadCertAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public OpenDistroSecuritySSLReloadCertAction(final Settings settings,\n+                                                 final RestController restController,\n+                                                 final OpenDistroSecurityKeyStore odsks,\n+                                                 final ThreadPool threadPool,\n+                                                 final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"_opendistro/_security/api/ssl/{certType}/reloadcerts/\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/api/ssl/transport/reloadcerts\n+     * PUT _opendistro/_security/api/ssl/http/reloadcerts\n+     *\n+     * NOTE: No request body is required. We will assume new certificates are loaded in the paths specified in your elasticsearch.yml file\n+     * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+     *\n+     * Sample response:\n+     * { \"message\": \"updated http certs\" }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            final String certType = request.param(\"certType\");", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzg1NA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385937854", "bodyText": "Can we test some exceptions to see what information are we exposing ? (Similar for the other action)", "author": "dinusX", "createdAt": "2020-02-28T21:47:52Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLReloadCertAction.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.DefaultObjectMapper;\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.dlic.rest.support.Utils;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import static org.elasticsearch.rest.RestRequest.Method.PUT;\n+\n+\n+/**\n+ * Rest API action to reload SSL certificates.\n+ * Can be used to reload SSL certificates that are about to expire without restarting ES node.\n+ * This API assumes that new certificates are in the same location specified by the security configurations in elasticsearch.yml\n+ * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+ * To keep sensitive certificate reload secure, this API will only allow hot reload\n+ * with certificates issued by the same Issuer and Subject DN with expiry dates after the current one.\n+ * Currently this action serves PUT request for /_opendistro/_security/ssl/http/reloadcerts or /_opendistro/_security/ssl/transport/reloadcerts endpoint\n+ */\n+public class OpenDistroSecuritySSLReloadCertAction extends BaseRestHandler {\n+\n+    private final Settings settings;\n+    private final OpenDistroSecurityKeyStore odsks;\n+    private final ThreadContext threadContext;\n+    private final AdminDNs adminDns;\n+\n+    public OpenDistroSecuritySSLReloadCertAction(final Settings settings,\n+                                                 final RestController restController,\n+                                                 final OpenDistroSecurityKeyStore odsks,\n+                                                 final ThreadPool threadPool,\n+                                                 final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(PUT, \"_opendistro/_security/api/ssl/{certType}/reloadcerts/\", this);\n+    }\n+\n+    /**\n+     * PUT request to reload SSL Certificates.\n+     *\n+     * Sample request:\n+     * PUT _opendistro/_security/api/ssl/transport/reloadcerts\n+     * PUT _opendistro/_security/api/ssl/http/reloadcerts\n+     *\n+     * NOTE: No request body is required. We will assume new certificates are loaded in the paths specified in your elasticsearch.yml file\n+     * (https://opendistro.github.io/for-elasticsearch-docs/docs/security-configuration/tls/)\n+     *\n+     * Sample response:\n+     * { \"message\": \"updated http certs\" }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        return new RestChannelConsumer() {\n+\n+            final String certType = request.param(\"certType\");\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+\n+                // Check for Super admin user\n+                final User user = (User) threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user ==null||!adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN, \"\");\n+                } else {\n+                    try {\n+                        builder.startObject();\n+                        if (odsks != null) {\n+                            switch (certType) {\n+                                case \"http\":\n+                                    odsks.initHttpSSLConfig();\n+                                    builder.field(\"message\", \"updated http certs\");\n+                                    builder.endObject();\n+                                    response = new BytesRestResponse(RestStatus.OK, builder);\n+                                    break;\n+                                case \"transport\":\n+                                    odsks.initTransportSSLConfig();\n+                                    builder.field(\"message\", \"updated transport certs\");\n+                                    builder.endObject();\n+                                    response = new BytesRestResponse(RestStatus.OK, builder);\n+                                    break;\n+                                default:\n+                                    builder.field(\"message\", \"invalid uri path, please use /_opendistro/_security/api/ssl/http/reload or \" +\n+                                        \"/_opendistro/_security/api/ssl/transport/reload\");\n+                                    builder.endObject();\n+                                    response = new BytesRestResponse(RestStatus.FORBIDDEN, builder);\n+                                    break;\n+                            }\n+                        } else {\n+                            builder.field(\"message\", \"keystore is not initialized\");\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                        }\n+                    } catch (final Exception e1) {\n+                        builder = channel.newBuilder();\n+                        builder.startObject();\n+                        builder.field(\"error\", e1.toString());", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NzIwNw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385957207", "bodyText": "The following test cases return the exception if an Invalid DN is set and if the reload property is not there in the elasticsearch.yml config (https://github.com/opendistro-for-elasticsearch/security/pull/238/files#diff-714682d00b2af7282796d8efc9812f56R173-R198). I'll add one more in there in case the reloaded certificate has an invalid expiry date.\nLet me know if there is any specific test that comes to your mind.", "author": "debjanibnrj", "createdAt": "2020-02-28T22:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkzNzg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NzgzMw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385947833", "bodyText": "What if currentX509Certs is an empty list ?", "author": "dinusX", "createdAt": "2020-02-28T22:16:48Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -223,313 +229,374 @@ private void initSSLConfig() {\n             log.info(\"No config directory, key- and truststore files are resolved absolutely\");\n         } else {\n             log.info(\"Config directory is {}/, from there the key- and truststore files are resolved relatively\",\n-                    env.configFile().toAbsolutePath());\n+                env.configFile().toAbsolutePath());\n         }\n \n+\n         if (transportSSLEnabled) {\n+            initTransportSSLConfig();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-            if (rawKeyStoreFilePath != null) {\n+        if (!client && httpSSLEnabled) {\n+            initHttpSSLConfig();\n+        }\n+    }\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    public void initTransportSSLConfig() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+\n+        if (rawKeyStoreFilePath != null) {\n+\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n+\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n+\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n+\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n+\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                try {\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n+                }\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                validateNewCerts(transportCerts, transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);\n+                transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n+                    sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            }\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+        } else if (rawPemCertFilePath != null) {\n+\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n+                true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n+                true);\n+\n+            try {\n+                final File pemKeyFile = new File(pemKey);\n+                final File pemCertFile = new File(pemCertFilePath);\n+                final File trustedCasFile = new File(trustedCas);\n+                final X509Certificate[] transportKeystoreCerts = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+\n+                validateNewCerts(transportCerts, transportKeystoreCerts);\n+                setTransportSSLCerts(transportKeystoreCerts);\n+                transportServerSslContext = buildSSLServerContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n+                + \" must be set if transport ssl is reqested.\");\n+        }\n+    }\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+    /**\n+     * Initializes certs used for client https communication\n+     */\n+    public void initHttpSSLConfig() {\n+        final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+            null);\n+        final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n+            null);\n+        final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+        if (rawKeystoreFilePath != null) {\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n-                }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-            } else if (rawPemCertFilePath != null) {\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n \n-                try {\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n-                }\n+            log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n+                    + \" must be set if https is reqested.\");\n             }\n-        }\n-\n-        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-        if (!client && httpSSLEnabled) {\n-\n-            final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                    null);\n-            final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n-                    null);\n-            final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n-\n-            if (rawKeystoreFilePath != null) {\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n-\n-                log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n-                            + \" must be set if https is reqested.\");\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n+                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n+                        + \" must be set if http ssl and client auth is reqested.\");\n                 }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+            }\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n-                        throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n-                                + \" must be set if http ssl and client auth is reqested.\");\n-                    }\n+            try {\n \n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n+                    ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n                 }\n \n-                try {\n-\n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n-                        ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                : keystorePassword.toCharArray());\n-                    }\n+                final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n \n-                    final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n-\n-                    if (httpKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (httpKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    if (httpKeystoreCert != null && httpKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < httpKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = httpKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"HTTP keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (httpKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    X509Certificate[] trustedHTTPCertificates = null;\n+                X509Certificate[] trustedHTTPCertificates = null;\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n \n-                        final String truststoreFilePath = resolve(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n+                    final String truststoreFilePath = resolve(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n \n-                        final String truststoreType = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n-                        final String truststorePassword = settings.get(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n-                                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                        final String truststoreAlias = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n+                    final String truststoreType = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n+                    final String truststorePassword = settings.get(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n+                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+                    final String truststoreAlias = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n \n-                        final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                        try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n-                            ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n-                        }\n-                        trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n+                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                    try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n+                        ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n                     }\n-\n-                    httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n-                            e);\n+                    trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                validateNewCerts(httpCerts, httpKeystoreCert);\n+                setHttpSSLCerts(httpKeystoreCert);\n+                httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n \n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n-                        false);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n+                    e);\n+            }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+        } else if (rawPemCertFilePath != null) {\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n+                false);\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+                checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+            }\n \n-                    // if(trustedCas == null ||\n-                    // trustedCas.equals(env.config-File().toAbsolutePath().toString())) {\n-                    // throw new\n-                    // ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH\n-                    // + \" must be set if http ssl and client auth is reqested.\");\n-                    // }\n+            try {\n+                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n+                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+                final X509Certificate[] httpKeystoreCert = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+                validateNewCerts(httpCerts, httpKeystoreCert);\n+                setHttpSSLCerts(httpKeystoreCert);\n+                httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n+                    trustedCas == null ? null : new File(trustedCas),\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-                    checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n+                + \" must be set if http ssl is reqested.\");\n+        }\n+    }\n \n-                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+    /**\n+     * For new X509 cert to be valid Issuer, Subject DN must be the same and\n+     * new certificates should expire after current ones.\n+     * @param currentX509Certs  Array of current x509 certificates\n+     * @param newX509Certs      Array of x509 certificates which will replace our current cert\n+     * @throws Exception if certificate is invalid\n+     */\n+    private void validateNewCerts(final X509Certificate[] currentX509Certs, final X509Certificate[] newX509Certs) throws Exception {\n \n-                try {\n-                    httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            trustedCas == null ? null : new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n-                }\n+        // First time we init certs ignore validity check\n+        if (currentX509Certs == null) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NjM2Mg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385966362", "bodyText": "I've added back the empty list check for keystore certs and transport certs initialized from the keystore. Now if the user passes empty list of certs we throw an exception.\nCurrentX509Certs is the list of certs that we set in this class and it should not have an empty list.", "author": "debjanibnrj", "createdAt": "2020-02-28T23:22:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0NzgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1MjI1NQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385952255", "bodyText": "What if \"buildSSLServerContext\" is crashing due to some issue . Do we still want to show this certificate ?", "author": "dinusX", "createdAt": "2020-02-28T22:29:48Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -223,313 +229,374 @@ private void initSSLConfig() {\n             log.info(\"No config directory, key- and truststore files are resolved absolutely\");\n         } else {\n             log.info(\"Config directory is {}/, from there the key- and truststore files are resolved relatively\",\n-                    env.configFile().toAbsolutePath());\n+                env.configFile().toAbsolutePath());\n         }\n \n+\n         if (transportSSLEnabled) {\n+            initTransportSSLConfig();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-            if (rawKeyStoreFilePath != null) {\n+        if (!client && httpSSLEnabled) {\n+            initHttpSSLConfig();\n+        }\n+    }\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    public void initTransportSSLConfig() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+\n+        if (rawKeyStoreFilePath != null) {\n+\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n+\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n+\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n+\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n+\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                try {\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n+                }\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                validateNewCerts(transportCerts, transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2NDcyMw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385964723", "bodyText": "Thats a valid point. I'll move the setTransportSSLCerts code below the build...Context, that way if there are any exceptions the transport SSL cert will not be explicitly set.", "author": "debjanibnrj", "createdAt": "2020-02-28T23:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1MjI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0MTcyNA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385941724", "bodyText": "will SAN (Subject Alternative name) be a part of subjectDn?  If not, we should add SAN check also.", "author": "hardik-k-shah", "createdAt": "2020-02-28T21:58:29Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -223,313 +229,374 @@ private void initSSLConfig() {\n             log.info(\"No config directory, key- and truststore files are resolved absolutely\");\n         } else {\n             log.info(\"Config directory is {}/, from there the key- and truststore files are resolved relatively\",\n-                    env.configFile().toAbsolutePath());\n+                env.configFile().toAbsolutePath());\n         }\n \n+\n         if (transportSSLEnabled) {\n+            initTransportSSLConfig();\n+        }\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-            if (rawKeyStoreFilePath != null) {\n+        if (!client && httpSSLEnabled) {\n+            initHttpSSLConfig();\n+        }\n+    }\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    public void initTransportSSLConfig() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+\n+        if (rawKeyStoreFilePath != null) {\n+\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n+\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n+\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n+\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n+\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+                if (transportKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                try {\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+                if (trustedTransportCertificates == null) {\n+                    throw new ElasticsearchException(\"No truststore configured for server\");\n+                }\n \n-                    if (transportKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                validateNewCerts(transportCerts, transportKeystoreCert);\n+                setTransportSSLCerts(transportKeystoreCert);\n+                transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n+                    trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n+                    sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer: \" + e.toString(), e);\n+            }\n \n-                    if (transportKeystoreCert != null && transportKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < transportKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = transportKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"Transport keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+        } else if (rawPemCertFilePath != null) {\n+\n+            final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n+                true);\n+            final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n+                true);\n+\n+            try {\n+                final File pemKeyFile = new File(pemKey);\n+                final File pemCertFile = new File(pemCertFilePath);\n+                final File trustedCasFile = new File(trustedCas);\n+                final X509Certificate[] transportKeystoreCerts = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+\n+                validateNewCerts(transportCerts, transportKeystoreCerts);\n+                setTransportSSLCerts(transportKeystoreCerts);\n+                transportServerSslContext = buildSSLServerContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n+                    this.sslTransportServerProvider, ClientAuth.REQUIRE);\n+                transportClientSslContext = buildSSLClientContext(pemKeyFile, pemCertFile, trustedCasFile,\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n+\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                    ts.load(new FileInputStream(new File(truststoreFilePath)),\n-                            (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n+                + \" must be set if transport ssl is reqested.\");\n+        }\n+    }\n \n-                    final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n-                            .exportRootCertificates(ts, truststoreAlias);\n+    /**\n+     * Initializes certs used for client https communication\n+     */\n+    public void initHttpSSLConfig() {\n+        final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+            null);\n+        final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n+            null);\n+        final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n \n-                    if (trustedTransportCertificates == null) {\n-                        throw new ElasticsearchException(\"No truststore configured for server\");\n-                    }\n+        if (rawKeystoreFilePath != null) {\n \n-                    transportServerSslContext = buildSSLServerContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(transportKeystoreKey, transportKeystoreCert,\n-                            trustedTransportCertificates, getEnabledSSLCiphers(sslTransportClientProvider, false),\n-                            sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer: \" + e.toString(), e);\n-                }\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n \n-            } else if (rawPemCertFilePath != null) {\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH,\n-                        true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH, true);\n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMTRUSTEDCAS_FILEPATH,\n-                        true);\n \n-                try {\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n \n-                    transportServerSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslTransportServerProvider, false),\n-                            this.sslTransportServerProvider, ClientAuth.REQUIRE);\n-                    transportClientSslContext = buildSSLClientContext(new File(pemKey), new File(pemCertFilePath),\n-                            new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(sslTransportClientProvider, false), sslTransportClientProvider);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing transport SSL layer from PEM: \" + e.toString(), e);\n-                }\n+            log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMKEY_FILEPATH\n-                        + \" must be set if transport ssl is reqested.\");\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n+                    + \" must be set if https is reqested.\");\n             }\n-        }\n-\n-        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-        if (!client && httpSSLEnabled) {\n-\n-            final String rawKeystoreFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                    null);\n-            final String rawPemCertFilePath = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH,\n-                    null);\n-            final ClientAuth httpClientAuthMode = ClientAuth.valueOf(settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_CLIENTAUTH_MODE, ClientAuth.OPTIONAL.toString()));\n-\n-            if (rawKeystoreFilePath != null) {\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_ALIAS, null);\n-\n-                log.info(\"HTTPS client auth mode {}\", httpClientAuthMode);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH\n-                            + \" must be set if https is reqested.\");\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n+                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n+                        + \" must be set if http ssl and client auth is reqested.\");\n                 }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+            }\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) == null) {\n-                        throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH\n-                                + \" must be set if http ssl and client auth is reqested.\");\n-                    }\n+            try {\n \n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n+                    ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n                 }\n \n-                try {\n-\n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    try (FileInputStream fin = new FileInputStream(new File(keystoreFilePath))) {\n-                        ks.load(fin, (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                : keystorePassword.toCharArray());\n-                    }\n+                final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n \n-                    final X509Certificate[] httpKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey httpKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n-\n-                    if (httpKeystoreKey == null) {\n-                        throw new ElasticsearchException(\n-                                \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (httpKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    if (httpKeystoreCert != null && httpKeystoreCert.length > 0) {\n-\n-                        // TODO create sensitive log property\n-                        /*\n-                         * for (int i = 0; i < httpKeystoreCert.length; i++) { X509Certificate\n-                         * x509Certificate = httpKeystoreCert[i];\n-                         * \n-                         * if(x509Certificate != null) {\n-                         * log.info(\"HTTP keystore subject DN no. {} {}\",i,x509Certificate.\n-                         * getSubjectX500Principal()); } }\n-                         */\n-                    } else {\n-                        throw new ElasticsearchException(\n-                                \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n-                    }\n+                if (httpKeystoreCert == null) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                    X509Certificate[] trustedHTTPCertificates = null;\n+                X509Certificate[] trustedHTTPCertificates = null;\n \n-                    if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n+                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, null) != null) {\n \n-                        final String truststoreFilePath = resolve(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n+                    final String truststoreFilePath = resolve(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_FILEPATH, true);\n \n-                        final String truststoreType = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n-                        final String truststorePassword = settings.get(\n-                                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n-                                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                        final String truststoreAlias = settings\n-                                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n+                    final String truststoreType = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_TYPE, DEFAULT_STORE_TYPE);\n+                    final String truststorePassword = settings.get(\n+                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_PASSWORD,\n+                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+                    final String truststoreAlias = settings\n+                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_TRUSTSTORE_ALIAS, null);\n \n-                        final KeyStore ts = KeyStore.getInstance(truststoreType);\n-                        try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n-                            ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n-                                    : truststorePassword.toCharArray());\n-                        }\n-                        trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n+                    final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                    try (FileInputStream fin = new FileInputStream(new File(truststoreFilePath))) {\n+                        ts.load(fin, (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                            : truststorePassword.toCharArray());\n                     }\n-\n-                    httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n-\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n-                            e);\n+                    trustedHTTPCertificates = SSLCertificateHelper.exportRootCertificates(ts, truststoreAlias);\n                 }\n \n-            } else if (rawPemCertFilePath != null) {\n+                validateNewCerts(httpCerts, httpKeystoreCert);\n+                setHttpSSLCerts(httpKeystoreCert);\n+                httpSslContext = buildSSLServerContext(httpKeystoreKey, httpKeystoreCert, trustedHTTPCertificates,\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n \n-                final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n-                        false);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\"Error while initializing HTTP SSL layer: \" + e.toString(),\n+                    e);\n+            }\n \n-                if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+        } else if (rawPemCertFilePath != null) {\n+            final String trustedCas = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH,\n+                false);\n+            if (httpClientAuthMode == ClientAuth.REQUIRE) {\n+                checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+            }\n \n-                    // if(trustedCas == null ||\n-                    // trustedCas.equals(env.config-File().toAbsolutePath().toString())) {\n-                    // throw new\n-                    // ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH\n-                    // + \" must be set if http ssl and client auth is reqested.\");\n-                    // }\n+            try {\n+                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n+                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+                final X509Certificate[] httpKeystoreCert = new X509Certificate[]{ PemKeyReader.loadCertificateFromFile(pemCertFilePath) };\n+                validateNewCerts(httpCerts, httpKeystoreCert);\n+                setHttpSSLCerts(httpKeystoreCert);\n+                httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n+                    trustedCas == null ? null : new File(trustedCas),\n+                    settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n+                    getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n+            } catch (final Exception e) {\n+                logExplanation(e);\n+                throw new ElasticsearchSecurityException(\n+                    \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n+            }\n \n-                    checkPath(trustedCas, SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMTRUSTEDCAS_FILEPATH);\n+        } else {\n+            throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n+                + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n+                + \" must be set if http ssl is reqested.\");\n+        }\n+    }\n \n-                }\n \n-                final String pemCertFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMCERT_FILEPATH, true);\n-                final String pemKey = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH, true);\n+    /**\n+     * For new X509 cert to be valid Issuer, Subject DN must be the same and\n+     * new certificates should expire after current ones.\n+     * @param currentX509Certs  Array of current x509 certificates\n+     * @param newX509Certs      Array of x509 certificates which will replace our current cert\n+     * @throws Exception if certificate is invalid\n+     */\n+    private void validateNewCerts(final X509Certificate[] currentX509Certs, final X509Certificate[] newX509Certs) throws Exception {\n \n-                try {\n-                    httpSslContext = buildSSLServerContext(new File(pemKey), new File(pemCertFilePath),\n-                            trustedCas == null ? null : new File(trustedCas),\n-                            settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_PASSWORD),\n-                            getEnabledSSLCiphers(this.sslHTTPProvider, true), sslHTTPProvider, httpClientAuthMode);\n-                } catch (final Exception e) {\n-                    logExplanation(e);\n-                    throw new ElasticsearchSecurityException(\n-                            \"Error while initializing http SSL layer from PEM: \" + e.toString(), e);\n-                }\n+        // First time we init certs ignore validity check\n+        if (currentX509Certs == null) {\n+            return;\n+        }\n \n-            } else {\n-                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_KEYSTORE_FILEPATH + \" or \"\n-                        + SSLConfigConstants.OPENDISTRO_SECURITY_SSL_HTTP_PEMKEY_FILEPATH\n-                        + \" must be set if http ssl is reqested.\");\n-            }\n+        // Check if new X509 certs have valid expiry date\n+        if (!hasValidExpiryDates(currentX509Certs, newX509Certs)) {\n+            throw new Exception(\"New certificates expire before the current ones.\");\n+        }\n \n+        // Check if new X509 certs have valid IssuerDN/SubjectDN\n+        if (!hasValidDNs(currentX509Certs, newX509Certs)) {\n+            throw new Exception(\"New Certs do not have valid Issuer and Subject DN.\");\n         }\n     }\n \n-    public SSLEngine createHTTPSSLEngine() throws SSLException {\n+    /**\n+     * Check if new X509 certs have same IssuerDN/SubjectDN as current certificates.\n+     * @param currentX509Certs Array of current X509Certificates.\n+     * @param newX509Certs Array of new X509Certificates.\n+     * @return true if all Issuer DN and Subject DN pairs match; false otherwise.\n+     * @throws Exception if certificate is invalid.\n+     */\n+    private boolean hasValidDNs(final X509Certificate[] currentX509Certs, final X509Certificate[] newX509Certs) {\n+\n+        final Function<? super X509Certificate, String> formatDNString = cert -> {\n+            final String issuerDn = cert !=null && cert.getIssuerX500Principal() != null ? cert.getIssuerX500Principal().getName() : \"\";\n+            final String subjectDn = cert !=null && cert.getSubjectX500Principal() != null ? cert.getSubjectX500Principal().getName() : \"\";", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2OTY2MQ==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385969661", "bodyText": "Sure will add SAN check.", "author": "debjanibnrj", "createdAt": "2020-02-28T23:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0MTcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0OTYxMg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385949612", "bodyText": "We should also add SAN field.", "author": "hardik-k-shah", "createdAt": "2020-02-28T22:21:58Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLCertInfoAction.java", "diffHunk": "@@ -0,0 +1,162 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get SSL certificate information related to http and transport encryption.\n+ * Only super admin users are allowed to access this API.\n+ * Currently this action serves GET request for _opendistro/_security/api/ssl/certs endpoint\n+ */\n+public class OpenDistroSecuritySSLCertInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public OpenDistroSecuritySSLCertInfoAction(final Settings settings,\n+                                               final RestController restController,\n+                                               final OpenDistroSecurityKeyStore odsks,\n+                                               final ThreadPool threadPool,\n+                                               final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/api/ssl/certs\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch transport certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/api/ssl/certs\n+     *\n+     * Sample response:", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk2MTU2Mg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385961562", "bodyText": "Will do.", "author": "debjanibnrj", "createdAt": "2020-02-28T23:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0OTYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4OTE0Mg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r385989142", "bodyText": "Earlier we were allowing transport client creation with an empty truststore file. I added a stronger validation for truststore validation so right now we will prevent transport client and OpenDistroPlugin will not load, hence cause this IllegalStateException", "author": "debjanibnrj", "createdAt": "2020-02-29T01:40:05Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/security/ssl/SSLTest.java", "diffHunk": "@@ -633,7 +633,7 @@ public void testNodeClientSSL() throws Exception {\n \n     @Test\n     public void testTransportClientSSLFail() throws Exception {\n-        thrown.expect(NoNodeAvailableException.class);\n+        thrown.expect(IllegalStateException.class);", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwMTI2Mg==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r386001262", "bodyText": "You don't need to check if it's non-null, since you already checked it in the first part.\nJava will only execute the second part of \"OR\" only if the first condition is true.\n(trustedTransportCertificates == null || trustedTransportCertificates.length == 0", "author": "dinusX", "createdAt": "2020-02-29T04:51:08Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/DefaultOpenDistroSecurityKeyStore.java", "diffHunk": "@@ -223,313 +230,385 @@ private void initSSLConfig() {\n             log.info(\"No config directory, key- and truststore files are resolved absolutely\");\n         } else {\n             log.info(\"Config directory is {}/, from there the key- and truststore files are resolved relatively\",\n-                    env.configFile().toAbsolutePath());\n+                env.configFile().toAbsolutePath());\n         }\n \n+\n         if (transportSSLEnabled) {\n+            initTransportSSLConfig();\n+        }\n+\n+        final boolean client = !\"node\".equals(this.settings.get(OpenDistroSecuritySSLPlugin.CLIENT_TYPE));\n \n-            final String rawKeyStoreFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n-            final String rawPemCertFilePath = settings\n-                    .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+        if (!client && httpSSLEnabled) {\n+            initHttpSSLConfig();\n+        }\n+    }\n \n-            if (rawKeyStoreFilePath != null) {\n+    /**\n+     * Initializes certs used for node to node communication\n+     */\n+    public void initTransportSSLConfig() {\n+        final String rawKeyStoreFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH, null);\n+        final String rawPemCertFilePath = settings\n+            .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_PEMCERT_FILEPATH, null);\n+\n+        if (rawKeyStoreFilePath != null) {\n+\n+            final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n+                true);\n+            final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String keystorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+\n+            final String keyPassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n+                keystorePassword);\n+\n+            final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n+                null);\n+\n+            final String truststoreFilePath = resolve(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n+\n+            if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n+                throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n+                    + \" must be set if transport ssl is requested.\");\n+            }\n \n-                final String keystoreFilePath = resolve(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_FILEPATH,\n-                        true);\n-                final String keystoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String keystorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                \n-                final String keyPassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_KEYPASSWORD,\n-                        keystorePassword);\n-                \n-                final String keystoreAlias = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_KEYSTORE_ALIAS,\n-                        null);\n-\n-                final String truststoreFilePath = resolve(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, true);\n-\n-                if (settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH, null) == null) {\n-                    throw new ElasticsearchException(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_FILEPATH\n-                            + \" must be set if transport ssl is requested.\");\n+            final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n+                DEFAULT_STORE_TYPE);\n+            final String truststorePassword = settings.get(\n+                SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n+                SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n+            final String truststoreAlias = settings\n+                .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+\n+            try {\n+\n+                final KeyStore ks = KeyStore.getInstance(keystoreType);\n+                ks.load(new FileInputStream(new File(keystoreFilePath)),\n+                    (keystorePassword == null || keystorePassword.length() == 0) ? null\n+                        : keystorePassword.toCharArray());\n+\n+                final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n+                    keystoreAlias);\n+                final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n+                    (keyPassword == null || keyPassword.length() == 0) ? null\n+                        : keyPassword.toCharArray());\n+\n+                if (transportKeystoreKey == null) {\n+                    throw new ElasticsearchException(\n+                        \"No key found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n                 }\n \n-                final String truststoreType = settings.get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_TYPE,\n-                        DEFAULT_STORE_TYPE);\n-                final String truststorePassword = settings.get(\n-                        SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_PASSWORD,\n-                        SSLConfigConstants.DEFAULT_STORE_PASSWORD);\n-                final String truststoreAlias = settings\n-                        .get(SSLConfigConstants.OPENDISTRO_SECURITY_SSL_TRANSPORT_TRUSTSTORE_ALIAS, null);\n+                if (transportKeystoreCert == null || (transportKeystoreCert != null && transportKeystoreCert.length == 0)) {\n+                    throw new ElasticsearchException(\n+                        \"No certificates found in \" + keystoreFilePath + \" with alias \" + keystoreAlias);\n+                }\n \n-                try {\n+                final KeyStore ts = KeyStore.getInstance(truststoreType);\n+                ts.load(new FileInputStream(new File(truststoreFilePath)),\n+                    (truststorePassword == null || truststorePassword.length() == 0) ? null\n+                        : truststorePassword.toCharArray());\n \n-                    final KeyStore ks = KeyStore.getInstance(keystoreType);\n-                    ks.load(new FileInputStream(new File(keystoreFilePath)),\n-                            (keystorePassword == null || keystorePassword.length() == 0) ? null\n-                                    : keystorePassword.toCharArray());\n+                final X509Certificate[] trustedTransportCertificates = SSLCertificateHelper\n+                    .exportRootCertificates(ts, truststoreAlias);\n \n-                    final X509Certificate[] transportKeystoreCert = SSLCertificateHelper.exportServerCertChain(ks,\n-                            keystoreAlias);\n-                    final PrivateKey transportKeystoreKey = SSLCertificateHelper.exportDecryptedKey(ks, keystoreAlias,\n-                            (keyPassword == null || keyPassword.length() == 0) ? null\n-                                    : keyPassword.toCharArray());\n+                if (trustedTransportCertificates == null || (trustedTransportCertificates != null && trustedTransportCertificates.length == 0)) {", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwMTU4NA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r386001584", "bodyText": "Thanks for the suggestion. Updated this.", "author": "debjanibnrj", "createdAt": "2020-02-29T04:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwMTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwMTM4MA==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r386001380", "bodyText": "This doesn't seem to do anything. Is this intended to just print an exception and continue ? Did you plan to stop executing the code that follows after this? Also, should it be print or logging.error(..) ?", "author": "dinusX", "createdAt": "2020-02-29T04:53:43Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/security/ssl/rest/OpenDistroSecuritySSLCertsInfoAction.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package com.amazon.opendistroforelasticsearch.security.ssl.rest;\n+\n+import com.amazon.opendistroforelasticsearch.security.configuration.AdminDNs;\n+import com.amazon.opendistroforelasticsearch.security.ssl.OpenDistroSecurityKeyStore;\n+import com.amazon.opendistroforelasticsearch.security.support.ConfigConstants;\n+import com.amazon.opendistroforelasticsearch.security.user.User;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.rest.BaseRestHandler;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.threadpool.ThreadPool;\n+\n+import java.io.IOException;\n+import java.security.cert.CertificateParsingException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static org.elasticsearch.rest.RestRequest.Method.GET;\n+\n+/**\n+ * Rest API action to get SSL certificate information related to http and transport encryption.\n+ * Only super admin users are allowed to access this API.\n+ * Currently this action serves GET request for _opendistro/_security/api/ssl/certs endpoint\n+ */\n+public class OpenDistroSecuritySSLCertsInfoAction extends BaseRestHandler {\n+\n+    private final Logger log = LogManager.getLogger(this.getClass());\n+    private Settings settings;\n+    private OpenDistroSecurityKeyStore odsks;\n+    private AdminDNs adminDns;\n+    private ThreadContext threadContext;\n+\n+    public OpenDistroSecuritySSLCertsInfoAction(final Settings settings,\n+                                                final RestController restController,\n+                                                final OpenDistroSecurityKeyStore odsks,\n+                                                final ThreadPool threadPool,\n+                                                final AdminDNs adminDns) {\n+        super(settings);\n+        this.settings = settings;\n+        this.odsks = odsks;\n+        this.adminDns = adminDns;\n+        this.threadContext = threadPool.getThreadContext();\n+        restController.registerHandler(GET, \"/_opendistro/_security/api/ssl/certs\", this);\n+    }\n+\n+    /**\n+     * GET request to fetch transport certificate details\n+     *\n+     * Sample request:\n+     * GET _opendistro/_security/api/ssl/certs\n+     *\n+     * Sample response:\n+     * {\n+     *   \"http_certificates_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=transport-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *     }\n+     *  \"transport_certificates_list\" : [\n+     *     {\n+     *       \"issuer_dn\" : \"CN=Example Com Inc. Signing CA, OU=Example Com Inc. Signing CA, O=Example Com Inc., DC=example, DC=com\",\n+     *       \"subject_dn\" : \"CN=transport-0.example.com, OU=SSL, O=Test, L=Test, C=DE\",\n+     *       \"not_before\" : \"2018-05-05T14:37:09.000Z\",\n+     *       \"not_after\" : \"2028-05-02T14:37:09.000Z\"\n+     *      }\n+     *   ]\n+     * }\n+     *\n+     * @param request request to be served\n+     * @param client client\n+     * @throws IOException\n+     */\n+    @Override\n+    protected RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {\n+\n+        return new RestChannelConsumer() {\n+\n+            @Override\n+            public void accept(RestChannel channel) throws Exception {\n+                XContentBuilder builder = channel.newBuilder();\n+                BytesRestResponse response = null;\n+\n+                // Check for Super admin user\n+                final User user = (User)threadContext.getTransient(ConfigConstants.OPENDISTRO_SECURITY_USER);\n+                if(user == null || !adminDns.isAdmin(user)) {\n+                    response = new BytesRestResponse(RestStatus.FORBIDDEN, builder);\n+                } else {\n+                    try {\n+                        // Check if keystore initialised\n+                        if (odsks != null) {\n+                            builder.startObject();\n+                            builder.field(\"http_certificates_list\", generateCertDetailList(odsks.getHttpCerts()));\n+                            builder.field(\"transport_certificates_list\", generateCertDetailList(odsks.getTransportCerts()));\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.OK, builder);\n+                        } else {\n+                            builder.startObject();\n+                            builder.field(\"message\", \"keystore is not initialized\");\n+                            builder.endObject();\n+                            response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                        }\n+                    } catch (final Exception e1) {\n+                        log.error(\"Error handle request \" + e1, e1);\n+                        builder = channel.newBuilder();\n+                        builder.startObject();\n+                        builder.field(\"error\", e1.toString());\n+                        builder.endObject();\n+                        response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, builder);\n+                    } finally {\n+                        if (builder != null) {\n+                            builder.close();\n+                        }\n+                    }\n+                }\n+                channel.sendResponse(response);\n+            }\n+\n+            /**\n+             * Helper that construct list of certificate details.\n+             * @param certs list of certificates.\n+             * @return Array containing certificate details.\n+             */\n+            private List<Map<String, String>> generateCertDetailList(final X509Certificate[] certs) {\n+                if (certs == null) {\n+                    return null;\n+                }\n+                return Arrays.stream(certs)\n+                    .map(cert -> {\n+                        final String issuerDn = cert != null && cert.getIssuerX500Principal() != null ? cert.getIssuerX500Principal().getName(): \"\";\n+                        final String subjectDn = cert != null && cert.getSubjectX500Principal() != null ? cert.getSubjectX500Principal().getName(): \"\";\n+\n+                        try {\n+                            Collection<List<?>> sans = cert.getSubjectAlternativeNames();\n+                        } catch (CertificateParsingException e) {\n+                            e.printStackTrace();\n+                        }", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwMTY4Mw==", "url": "https://github.com/opensearch-project/security/pull/238#discussion_r386001683", "bodyText": "Was just supposed to log an error. Updated this.", "author": "debjanibnrj", "createdAt": "2020-02-29T04:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwMTM4MA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "c585c238ea4f2db20ea5a6442a9cad5adf12ae4c", "url": "https://github.com/opensearch-project/security/commit/c585c238ea4f2db20ea5a6442a9cad5adf12ae4c", "message": "Adding capability to hot reload ssl certificates\n        * Added api PUT /_opendistro/_security/ssl/{certType}/reloadcerts which reinitializes http or transport keystore\n        * Added api GET /_opendistro/_security/ssl/certs which returns public key details for http and transport certificates\n        * Updated DefaultODSKeyStore to update, set and get http and transport layer certificates\n        * Added unit tests", "committedDate": "2020-03-03T18:46:30Z", "type": "commit"}, {"oid": "c585c238ea4f2db20ea5a6442a9cad5adf12ae4c", "url": "https://github.com/opensearch-project/security/commit/c585c238ea4f2db20ea5a6442a9cad5adf12ae4c", "message": "Adding capability to hot reload ssl certificates\n        * Added api PUT /_opendistro/_security/ssl/{certType}/reloadcerts which reinitializes http or transport keystore\n        * Added api GET /_opendistro/_security/ssl/certs which returns public key details for http and transport certificates\n        * Updated DefaultODSKeyStore to update, set and get http and transport layer certificates\n        * Added unit tests", "committedDate": "2020-03-03T18:46:30Z", "type": "forcePushed"}]}