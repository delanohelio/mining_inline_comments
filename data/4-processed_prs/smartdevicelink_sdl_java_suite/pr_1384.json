{"pr_number": 1384, "pr_title": "[SDL-0301] SDL Device Listener", "pr_createdAt": "2020-06-12T16:14:17Z", "pr_url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384", "timeline": [{"oid": "88df65d4e7ab7bfa6fcb87233e39b0e09bb9dd0a", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/88df65d4e7ab7bfa6fcb87233e39b0e09bb9dd0a", "message": "Limit exception stacktrace print in BT transport", "committedDate": "2020-06-12T15:03:49Z", "type": "commit"}, {"oid": "dfcdd324cdb9a2a84e237726ca6032d96f4cced0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/dfcdd324cdb9a2a84e237726ca6032d96f4cced0", "message": "Increment router service version", "committedDate": "2020-06-12T15:04:17Z", "type": "commit"}, {"oid": "1aa070be0804493907d2852a98b887b5c0b65398", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/1aa070be0804493907d2852a98b887b5c0b65398", "message": "Add SdlDeviceListener", "committedDate": "2020-06-12T15:04:57Z", "type": "commit"}, {"oid": "7306e2b8100d047a72dc3637d0ac3ac01c787a0e", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/7306e2b8100d047a72dc3637d0ac3ac01c787a0e", "message": "Implement SdlDeviceListener", "committedDate": "2020-06-12T15:05:04Z", "type": "commit"}, {"oid": "01a47b11cc3abe1185177bd0d6f9a1c260ac09ae", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/01a47b11cc3abe1185177bd0d6f9a1c260ac09ae", "message": "Make RS go to foreground if confirmed device", "committedDate": "2020-06-12T15:21:50Z", "type": "commit"}, {"oid": "3ddcd5851ea909915d2d6bfeeb54358fc78e0555", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3ddcd5851ea909915d2d6bfeeb54358fc78e0555", "message": "Merge branch 'develop' of https://github.com/smartdevicelink/sdl_android into feature/sdl_0301_sdl_device_listener", "committedDate": "2020-06-12T15:32:22Z", "type": "commit"}, {"oid": "ba9d5518690be28c82ae94b0d188343c75c39a4a", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/ba9d5518690be28c82ae94b0d188343c75c39a4a", "message": "Update formatting in SdlDeviceListener", "committedDate": "2020-06-12T16:13:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxODgwMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#discussion_r445018801", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param address the mac address of the device in quesiton\n          \n          \n            \n                 * @param address the mac address of the device in question", "author": "bilal-alsharifi", "createdAt": "2020-06-24T16:25:27Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/transport/utl/SdlDeviceListener.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+\n+package com.smartdevicelink.transport.utl;\n+\n+import android.bluetooth.BluetoothDevice;\n+import android.content.Context;\n+import android.content.SharedPreferences;\n+import android.os.Handler;\n+import android.os.Looper;\n+import android.os.Message;\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.transport.MultiplexBaseTransport;\n+import com.smartdevicelink.transport.MultiplexBluetoothTransport;\n+import com.smartdevicelink.transport.SdlRouterService;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.SdlAppInfo;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+\n+\n+public class SdlDeviceListener {\n+\n+    private static final String TAG = \"SdlListener\";\n+    private static final int MIN_VERSION_REQUIRED = 13;\n+    private static final String SDL_DEVICE_STATUS_SHARED_PREFS = \"sdl.device.status\";\n+    private static final Object LOCK = new Object(), RUNNING_LOCK = new Object();\n+\n+    private final WeakReference<Context> contextWeakReference;\n+    private final Callback callback;\n+    private final BluetoothDevice connectedDevice;\n+    private MultiplexBluetoothTransport bluetoothTransport;\n+    private TransportHandler bluetoothHandler;\n+    private Handler timeoutHandler;\n+    private Runnable timeoutRunner;\n+    private boolean isRunning = false;\n+\n+\n+    public SdlDeviceListener(Context context, BluetoothDevice device, Callback callback) {\n+        this.contextWeakReference = new WeakReference<>(context);\n+        this.connectedDevice = device;\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * This will start the SDL Device Listener with two paths. The first path will be a check\n+     * against the supplied bluetooth device to see if it has already successfully connected as an\n+     * SDL device. If it has, the supplied callback will be called immediately. If the device hasn't\n+     * connected as an SDL device before, the SDL Device Listener will then open up an RFCOMM channel\n+     * using the SDL UUID and await a potential connection. A timeout is used to ensure this only\n+     * listens for a finite amount of time. If this is the first time the device has been seen, this\n+     * will listen for 30 seconds, if it is not, this will listen for 15 seconds instead.\n+     */\n+    public void start() {\n+        if (hasSDLConnected(contextWeakReference.get(), connectedDevice.getAddress())) {\n+            DebugTool.logInfo(TAG + \": Confirmed SDL device, should start router service\");\n+            //This device has connected to SDL previously, it is ok to start the RS right now\n+            callback.onTransportConnected(contextWeakReference.get(), connectedDevice);\n+            return;\n+        }\n+        synchronized (RUNNING_LOCK) {\n+            isRunning = true;\n+            // set timeout = if first time seeing BT device, 30s, if not 15s\n+            int timeout = isFirstStatusCheck(connectedDevice.getAddress()) ? 30000 : 15000;\n+            //Set our preference as false for this device for now\n+            setSDLConnectedStatus(contextWeakReference.get(), connectedDevice.getAddress(), false);\n+            bluetoothHandler = new TransportHandler(this);\n+            bluetoothTransport = new MultiplexBluetoothTransport(bluetoothHandler);\n+            bluetoothTransport.start();\n+            timeoutRunner = new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (bluetoothTransport != null) {\n+                        int state = bluetoothTransport.getState();\n+                        if (state != MultiplexBluetoothTransport.STATE_CONNECTED) {\n+                            DebugTool.logInfo(TAG + \": No bluetooth connection made\");\n+                            bluetoothTransport.stop();\n+                        } //else BT is connected; it will close itself through callbacks\n+                    }\n+                }\n+            };\n+            timeoutHandler = new Handler(Looper.getMainLooper());\n+            timeoutHandler.postDelayed(timeoutRunner, timeout);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if this instance is in the middle of running or not\n+     *\n+     * @return if this is already in the process of running\n+     */\n+    public boolean isRunning() {\n+        synchronized (RUNNING_LOCK) {\n+            return isRunning;\n+        }\n+    }\n+\n+    private static class TransportHandler extends Handler {\n+\n+        final WeakReference<SdlDeviceListener> provider;\n+\n+        TransportHandler(SdlDeviceListener provider) {\n+            this.provider = new WeakReference<>(provider);\n+        }\n+\n+        @Override\n+        public void handleMessage(@NonNull Message msg) {\n+            if (this.provider.get() == null) {\n+                return;\n+            }\n+            SdlDeviceListener sdlListener = this.provider.get();\n+            switch (msg.what) {\n+\n+                case SdlRouterService.MESSAGE_STATE_CHANGE:\n+                    switch (msg.arg1) {\n+                        case MultiplexBaseTransport.STATE_CONNECTED:\n+                            sdlListener.setSDLConnectedStatus(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice.getAddress(), true);\n+                            boolean keepConnectionOpen = sdlListener.callback.onTransportConnected(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice);\n+                            if (!keepConnectionOpen) {\n+                                sdlListener.bluetoothTransport.stop();\n+                                sdlListener.bluetoothTransport = null;\n+                                sdlListener.timeoutHandler.removeCallbacks(sdlListener.timeoutRunner);\n+                            }\n+                            break;\n+                        case MultiplexBaseTransport.STATE_NONE:\n+                            // We've just lost the connection\n+                            sdlListener.callback.onTransportDisconnected(sdlListener.connectedDevice);\n+                            break;\n+                        case MultiplexBaseTransport.STATE_ERROR:\n+                            sdlListener.callback.onTransportError(sdlListener.connectedDevice);\n+                            break;\n+                    }\n+                    break;\n+\n+                case com.smartdevicelink.transport.SdlRouterService.MESSAGE_READ:\n+                    break;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Set the connection establishment status of the particular device\n+     *\n+     * @param address         address of the device in quesiton\n+     * @param hasSDLConnected true if a connection has been established, false if not\n+     */\n+    public static void setSDLConnectedStatus(Context context, String address, boolean hasSDLConnected) {\n+        synchronized (LOCK) {\n+            if (context != null) {\n+                DebugTool.logInfo(TAG + \": Saving connected status - \" + address + \" : \" + hasSDLConnected);\n+                SharedPreferences preferences = context.getSharedPreferences(SDL_DEVICE_STATUS_SHARED_PREFS, Context.MODE_PRIVATE);\n+                if (preferences.contains(address) && hasSDLConnected == preferences.getBoolean(address, false)) {\n+                    //The same key/value exists in our shared preferences. No reason to write again.\n+                    return;\n+                }\n+                SharedPreferences.Editor editor = preferences.edit();\n+                editor.putBoolean(address, hasSDLConnected);\n+                editor.commit();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks to see if a device address has connected to SDL before.\n+     *\n+     * @param address the mac address of the device in quesiton", "originalCommit": "ba9d5518690be28c82ae94b0d188343c75c39a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxOTAwMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#discussion_r445019003", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param address the mac address of the device in quesiton\n          \n          \n            \n                 * @param address the mac address of the device in question", "author": "bilal-alsharifi", "createdAt": "2020-06-24T16:25:46Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/transport/utl/SdlDeviceListener.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+\n+package com.smartdevicelink.transport.utl;\n+\n+import android.bluetooth.BluetoothDevice;\n+import android.content.Context;\n+import android.content.SharedPreferences;\n+import android.os.Handler;\n+import android.os.Looper;\n+import android.os.Message;\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.transport.MultiplexBaseTransport;\n+import com.smartdevicelink.transport.MultiplexBluetoothTransport;\n+import com.smartdevicelink.transport.SdlRouterService;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.SdlAppInfo;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+\n+\n+public class SdlDeviceListener {\n+\n+    private static final String TAG = \"SdlListener\";\n+    private static final int MIN_VERSION_REQUIRED = 13;\n+    private static final String SDL_DEVICE_STATUS_SHARED_PREFS = \"sdl.device.status\";\n+    private static final Object LOCK = new Object(), RUNNING_LOCK = new Object();\n+\n+    private final WeakReference<Context> contextWeakReference;\n+    private final Callback callback;\n+    private final BluetoothDevice connectedDevice;\n+    private MultiplexBluetoothTransport bluetoothTransport;\n+    private TransportHandler bluetoothHandler;\n+    private Handler timeoutHandler;\n+    private Runnable timeoutRunner;\n+    private boolean isRunning = false;\n+\n+\n+    public SdlDeviceListener(Context context, BluetoothDevice device, Callback callback) {\n+        this.contextWeakReference = new WeakReference<>(context);\n+        this.connectedDevice = device;\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * This will start the SDL Device Listener with two paths. The first path will be a check\n+     * against the supplied bluetooth device to see if it has already successfully connected as an\n+     * SDL device. If it has, the supplied callback will be called immediately. If the device hasn't\n+     * connected as an SDL device before, the SDL Device Listener will then open up an RFCOMM channel\n+     * using the SDL UUID and await a potential connection. A timeout is used to ensure this only\n+     * listens for a finite amount of time. If this is the first time the device has been seen, this\n+     * will listen for 30 seconds, if it is not, this will listen for 15 seconds instead.\n+     */\n+    public void start() {\n+        if (hasSDLConnected(contextWeakReference.get(), connectedDevice.getAddress())) {\n+            DebugTool.logInfo(TAG + \": Confirmed SDL device, should start router service\");\n+            //This device has connected to SDL previously, it is ok to start the RS right now\n+            callback.onTransportConnected(contextWeakReference.get(), connectedDevice);\n+            return;\n+        }\n+        synchronized (RUNNING_LOCK) {\n+            isRunning = true;\n+            // set timeout = if first time seeing BT device, 30s, if not 15s\n+            int timeout = isFirstStatusCheck(connectedDevice.getAddress()) ? 30000 : 15000;\n+            //Set our preference as false for this device for now\n+            setSDLConnectedStatus(contextWeakReference.get(), connectedDevice.getAddress(), false);\n+            bluetoothHandler = new TransportHandler(this);\n+            bluetoothTransport = new MultiplexBluetoothTransport(bluetoothHandler);\n+            bluetoothTransport.start();\n+            timeoutRunner = new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (bluetoothTransport != null) {\n+                        int state = bluetoothTransport.getState();\n+                        if (state != MultiplexBluetoothTransport.STATE_CONNECTED) {\n+                            DebugTool.logInfo(TAG + \": No bluetooth connection made\");\n+                            bluetoothTransport.stop();\n+                        } //else BT is connected; it will close itself through callbacks\n+                    }\n+                }\n+            };\n+            timeoutHandler = new Handler(Looper.getMainLooper());\n+            timeoutHandler.postDelayed(timeoutRunner, timeout);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if this instance is in the middle of running or not\n+     *\n+     * @return if this is already in the process of running\n+     */\n+    public boolean isRunning() {\n+        synchronized (RUNNING_LOCK) {\n+            return isRunning;\n+        }\n+    }\n+\n+    private static class TransportHandler extends Handler {\n+\n+        final WeakReference<SdlDeviceListener> provider;\n+\n+        TransportHandler(SdlDeviceListener provider) {\n+            this.provider = new WeakReference<>(provider);\n+        }\n+\n+        @Override\n+        public void handleMessage(@NonNull Message msg) {\n+            if (this.provider.get() == null) {\n+                return;\n+            }\n+            SdlDeviceListener sdlListener = this.provider.get();\n+            switch (msg.what) {\n+\n+                case SdlRouterService.MESSAGE_STATE_CHANGE:\n+                    switch (msg.arg1) {\n+                        case MultiplexBaseTransport.STATE_CONNECTED:\n+                            sdlListener.setSDLConnectedStatus(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice.getAddress(), true);\n+                            boolean keepConnectionOpen = sdlListener.callback.onTransportConnected(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice);\n+                            if (!keepConnectionOpen) {\n+                                sdlListener.bluetoothTransport.stop();\n+                                sdlListener.bluetoothTransport = null;\n+                                sdlListener.timeoutHandler.removeCallbacks(sdlListener.timeoutRunner);\n+                            }\n+                            break;\n+                        case MultiplexBaseTransport.STATE_NONE:\n+                            // We've just lost the connection\n+                            sdlListener.callback.onTransportDisconnected(sdlListener.connectedDevice);\n+                            break;\n+                        case MultiplexBaseTransport.STATE_ERROR:\n+                            sdlListener.callback.onTransportError(sdlListener.connectedDevice);\n+                            break;\n+                    }\n+                    break;\n+\n+                case com.smartdevicelink.transport.SdlRouterService.MESSAGE_READ:\n+                    break;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Set the connection establishment status of the particular device\n+     *\n+     * @param address         address of the device in quesiton\n+     * @param hasSDLConnected true if a connection has been established, false if not\n+     */\n+    public static void setSDLConnectedStatus(Context context, String address, boolean hasSDLConnected) {\n+        synchronized (LOCK) {\n+            if (context != null) {\n+                DebugTool.logInfo(TAG + \": Saving connected status - \" + address + \" : \" + hasSDLConnected);\n+                SharedPreferences preferences = context.getSharedPreferences(SDL_DEVICE_STATUS_SHARED_PREFS, Context.MODE_PRIVATE);\n+                if (preferences.contains(address) && hasSDLConnected == preferences.getBoolean(address, false)) {\n+                    //The same key/value exists in our shared preferences. No reason to write again.\n+                    return;\n+                }\n+                SharedPreferences.Editor editor = preferences.edit();\n+                editor.putBoolean(address, hasSDLConnected);\n+                editor.commit();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks to see if a device address has connected to SDL before.\n+     *\n+     * @param address the mac address of the device in quesiton\n+     * @return if this is the first status check of this device\n+     */\n+    private boolean isFirstStatusCheck(String address) {\n+        synchronized (LOCK) {\n+            Context context = contextWeakReference.get();\n+            if (context != null) {\n+                SharedPreferences preferences = context.getSharedPreferences(SDL_DEVICE_STATUS_SHARED_PREFS, Context.MODE_PRIVATE);\n+                return !preferences.contains(address);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Checks to see if a device address has connected to SDL before.\n+     *\n+     * @param address the mac address of the device in quesiton", "originalCommit": "ba9d5518690be28c82ae94b0d188343c75c39a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTAxOTI0Ng==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#discussion_r445019246", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param address         address of the device in quesiton\n          \n          \n            \n                 * @param address         address of the device in question", "author": "bilal-alsharifi", "createdAt": "2020-06-24T16:26:08Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/transport/utl/SdlDeviceListener.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+\n+package com.smartdevicelink.transport.utl;\n+\n+import android.bluetooth.BluetoothDevice;\n+import android.content.Context;\n+import android.content.SharedPreferences;\n+import android.os.Handler;\n+import android.os.Looper;\n+import android.os.Message;\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.transport.MultiplexBaseTransport;\n+import com.smartdevicelink.transport.MultiplexBluetoothTransport;\n+import com.smartdevicelink.transport.SdlRouterService;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.SdlAppInfo;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+\n+\n+public class SdlDeviceListener {\n+\n+    private static final String TAG = \"SdlListener\";\n+    private static final int MIN_VERSION_REQUIRED = 13;\n+    private static final String SDL_DEVICE_STATUS_SHARED_PREFS = \"sdl.device.status\";\n+    private static final Object LOCK = new Object(), RUNNING_LOCK = new Object();\n+\n+    private final WeakReference<Context> contextWeakReference;\n+    private final Callback callback;\n+    private final BluetoothDevice connectedDevice;\n+    private MultiplexBluetoothTransport bluetoothTransport;\n+    private TransportHandler bluetoothHandler;\n+    private Handler timeoutHandler;\n+    private Runnable timeoutRunner;\n+    private boolean isRunning = false;\n+\n+\n+    public SdlDeviceListener(Context context, BluetoothDevice device, Callback callback) {\n+        this.contextWeakReference = new WeakReference<>(context);\n+        this.connectedDevice = device;\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * This will start the SDL Device Listener with two paths. The first path will be a check\n+     * against the supplied bluetooth device to see if it has already successfully connected as an\n+     * SDL device. If it has, the supplied callback will be called immediately. If the device hasn't\n+     * connected as an SDL device before, the SDL Device Listener will then open up an RFCOMM channel\n+     * using the SDL UUID and await a potential connection. A timeout is used to ensure this only\n+     * listens for a finite amount of time. If this is the first time the device has been seen, this\n+     * will listen for 30 seconds, if it is not, this will listen for 15 seconds instead.\n+     */\n+    public void start() {\n+        if (hasSDLConnected(contextWeakReference.get(), connectedDevice.getAddress())) {\n+            DebugTool.logInfo(TAG + \": Confirmed SDL device, should start router service\");\n+            //This device has connected to SDL previously, it is ok to start the RS right now\n+            callback.onTransportConnected(contextWeakReference.get(), connectedDevice);\n+            return;\n+        }\n+        synchronized (RUNNING_LOCK) {\n+            isRunning = true;\n+            // set timeout = if first time seeing BT device, 30s, if not 15s\n+            int timeout = isFirstStatusCheck(connectedDevice.getAddress()) ? 30000 : 15000;\n+            //Set our preference as false for this device for now\n+            setSDLConnectedStatus(contextWeakReference.get(), connectedDevice.getAddress(), false);\n+            bluetoothHandler = new TransportHandler(this);\n+            bluetoothTransport = new MultiplexBluetoothTransport(bluetoothHandler);\n+            bluetoothTransport.start();\n+            timeoutRunner = new Runnable() {\n+                @Override\n+                public void run() {\n+                    if (bluetoothTransport != null) {\n+                        int state = bluetoothTransport.getState();\n+                        if (state != MultiplexBluetoothTransport.STATE_CONNECTED) {\n+                            DebugTool.logInfo(TAG + \": No bluetooth connection made\");\n+                            bluetoothTransport.stop();\n+                        } //else BT is connected; it will close itself through callbacks\n+                    }\n+                }\n+            };\n+            timeoutHandler = new Handler(Looper.getMainLooper());\n+            timeoutHandler.postDelayed(timeoutRunner, timeout);\n+        }\n+    }\n+\n+    /**\n+     * Check to see if this instance is in the middle of running or not\n+     *\n+     * @return if this is already in the process of running\n+     */\n+    public boolean isRunning() {\n+        synchronized (RUNNING_LOCK) {\n+            return isRunning;\n+        }\n+    }\n+\n+    private static class TransportHandler extends Handler {\n+\n+        final WeakReference<SdlDeviceListener> provider;\n+\n+        TransportHandler(SdlDeviceListener provider) {\n+            this.provider = new WeakReference<>(provider);\n+        }\n+\n+        @Override\n+        public void handleMessage(@NonNull Message msg) {\n+            if (this.provider.get() == null) {\n+                return;\n+            }\n+            SdlDeviceListener sdlListener = this.provider.get();\n+            switch (msg.what) {\n+\n+                case SdlRouterService.MESSAGE_STATE_CHANGE:\n+                    switch (msg.arg1) {\n+                        case MultiplexBaseTransport.STATE_CONNECTED:\n+                            sdlListener.setSDLConnectedStatus(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice.getAddress(), true);\n+                            boolean keepConnectionOpen = sdlListener.callback.onTransportConnected(sdlListener.contextWeakReference.get(), sdlListener.connectedDevice);\n+                            if (!keepConnectionOpen) {\n+                                sdlListener.bluetoothTransport.stop();\n+                                sdlListener.bluetoothTransport = null;\n+                                sdlListener.timeoutHandler.removeCallbacks(sdlListener.timeoutRunner);\n+                            }\n+                            break;\n+                        case MultiplexBaseTransport.STATE_NONE:\n+                            // We've just lost the connection\n+                            sdlListener.callback.onTransportDisconnected(sdlListener.connectedDevice);\n+                            break;\n+                        case MultiplexBaseTransport.STATE_ERROR:\n+                            sdlListener.callback.onTransportError(sdlListener.connectedDevice);\n+                            break;\n+                    }\n+                    break;\n+\n+                case com.smartdevicelink.transport.SdlRouterService.MESSAGE_READ:\n+                    break;\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Set the connection establishment status of the particular device\n+     *\n+     * @param address         address of the device in quesiton", "originalCommit": "ba9d5518690be28c82ae94b0d188343c75c39a4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMjk0Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#discussion_r445112943", "bodyText": "if I install the app while BT is already on, the connectedDevice comes as null so the app crashes with this exception\njava.lang.NullPointerException: Attempt to invoke virtual method 'java.lang.String android.bluetooth.BluetoothDevice.getAddress()' on a null object reference\n        at com.smartdevicelink.transport.utl.SdlDeviceListener.start(SdlDeviceListener.java:88)\n        at com.smartdevicelink.transport.SdlBroadcastReceiver$2.onComplete(SdlBroadcastReceiver.java:298)\n        at com.smartdevicelink.util.ServiceFinder.onFinished(ServiceFinder.java:124)\n        at com.smartdevicelink.util.ServiceFinder.access$000(ServiceFinder.java:58)\n        at com.smartdevicelink.util.ServiceFinder$1.run(ServiceFinder.java:84)\n        at android.os.Handler.handleCallback(Handler.java:883)\n        at android.os.Handler.dispatchMessage(Handler.java:100)\n        at android.os.Looper.loop(Looper.java:214)\n        at android.app.ActivityThread.main(ActivityThread.java:7356)\n        at java.lang.reflect.Method.invoke(Native Method)\n        at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:492)\n        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:930)", "author": "bilal-alsharifi", "createdAt": "2020-06-24T19:12:07Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/transport/utl/SdlDeviceListener.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/*\n+ * Copyright (c) 2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+\n+package com.smartdevicelink.transport.utl;\n+\n+import android.bluetooth.BluetoothDevice;\n+import android.content.Context;\n+import android.content.SharedPreferences;\n+import android.os.Handler;\n+import android.os.Looper;\n+import android.os.Message;\n+import android.support.annotation.NonNull;\n+\n+import com.smartdevicelink.transport.MultiplexBaseTransport;\n+import com.smartdevicelink.transport.MultiplexBluetoothTransport;\n+import com.smartdevicelink.transport.SdlRouterService;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.SdlAppInfo;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+\n+\n+public class SdlDeviceListener {\n+\n+    private static final String TAG = \"SdlListener\";\n+    private static final int MIN_VERSION_REQUIRED = 13;\n+    private static final String SDL_DEVICE_STATUS_SHARED_PREFS = \"sdl.device.status\";\n+    private static final Object LOCK = new Object(), RUNNING_LOCK = new Object();\n+\n+    private final WeakReference<Context> contextWeakReference;\n+    private final Callback callback;\n+    private final BluetoothDevice connectedDevice;\n+    private MultiplexBluetoothTransport bluetoothTransport;\n+    private TransportHandler bluetoothHandler;\n+    private Handler timeoutHandler;\n+    private Runnable timeoutRunner;\n+    private boolean isRunning = false;\n+\n+\n+    public SdlDeviceListener(Context context, BluetoothDevice device, Callback callback) {\n+        this.contextWeakReference = new WeakReference<>(context);\n+        this.connectedDevice = device;\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * This will start the SDL Device Listener with two paths. The first path will be a check\n+     * against the supplied bluetooth device to see if it has already successfully connected as an\n+     * SDL device. If it has, the supplied callback will be called immediately. If the device hasn't\n+     * connected as an SDL device before, the SDL Device Listener will then open up an RFCOMM channel\n+     * using the SDL UUID and await a potential connection. A timeout is used to ensure this only\n+     * listens for a finite amount of time. If this is the first time the device has been seen, this\n+     * will listen for 30 seconds, if it is not, this will listen for 15 seconds instead.\n+     */\n+    public void start() {\n+        if (hasSDLConnected(contextWeakReference.get(), connectedDevice.getAddress())) {", "originalCommit": "ba9d5518690be28c82ae94b0d188343c75c39a4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NjU0OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1384#discussion_r445166549", "bodyText": "Bluetooth had to be on and connected for me to see this error, but added a null check before this now so it should throw an error. It's not an easy task to get the connected bluetooth device, so I'm not sure if it is really worth the effort at the moment.", "author": "joeygrover", "createdAt": "2020-06-24T20:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExMjk0Mw=="}], "type": "inlineReview"}, {"oid": "bd30aba86f46a4d297da0f0a1c5a655033d5cbd4", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/bd30aba86f46a4d297da0f0a1c5a655033d5cbd4", "message": "Apply suggestions from code review\n\nCo-authored-by: Bilal Alsharifi <599206+bilal-alsharifi@users.noreply.github.com>", "committedDate": "2020-06-24T19:56:20Z", "type": "commit"}, {"oid": "1516c073d2dbc30d905220985e2dc3df91d4ab2c", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/1516c073d2dbc30d905220985e2dc3df91d4ab2c", "message": "Add null check for BT device in SdlDeviceListener", "committedDate": "2020-06-24T20:49:10Z", "type": "commit"}]}