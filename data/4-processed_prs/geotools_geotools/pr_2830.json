{"pr_number": 2830, "pr_title": "Additional map projection: Homolosine", "pr_createdAt": "2020-03-06T15:55:07Z", "pr_url": "https://github.com/geotools/geotools/pull/2830", "timeline": [{"oid": "12e46b0d99f39b58acf94b79209496e96d2577c0", "url": "https://github.com/geotools/geotools/commit/12e46b0d99f39b58acf94b79209496e96d2577c0", "message": "Additional map projection: Homolosine", "committedDate": "2020-03-06T14:58:58Z", "type": "commit"}, {"oid": "5ef6df558e15907016fd92bc9508c87b5a255af3", "url": "https://github.com/geotools/geotools/commit/5ef6df558e15907016fd92bc9508c87b5a255af3", "message": "Additional map projection: Homolosine", "committedDate": "2020-03-09T07:45:53Z", "type": "commit"}, {"oid": "e4f81d9ca8dafc0526ad492c7523acc1686cce6b", "url": "https://github.com/geotools/geotools/commit/e4f81d9ca8dafc0526ad492c7523acc1686cce6b", "message": "Merge branch 'master' of github.com:ldesousa/geotools", "committedDate": "2020-03-09T07:53:10Z", "type": "commit"}, {"oid": "c6d06dd8b3494633d99a69c915e23da8800f7370", "url": "https://github.com/geotools/geotools/commit/c6d06dd8b3494633d99a69c915e23da8800f7370", "message": "Removed forgotten scratch file", "committedDate": "2020-03-09T07:54:01Z", "type": "commit"}, {"oid": "968c61ba41c1fd208a100fb135ad4245ca8695d8", "url": "https://github.com/geotools/geotools/commit/968c61ba41c1fd208a100fb135ad4245ca8695d8", "message": "Applied correct formatting to Homolosine.java", "committedDate": "2020-03-09T07:55:01Z", "type": "commit"}, {"oid": "9305df76fdb2283d805b1debcb729ebf188e7fc4", "url": "https://github.com/geotools/geotools/commit/9305df76fdb2283d805b1debcb729ebf188e7fc4", "message": "Tweaked while commands to Maven's liking and added extra checks for points outside projection domain and co-domain", "committedDate": "2020-03-09T09:17:21Z", "type": "commit"}, {"oid": "0e1df12646a8599f19b0506dd4c86bd210002061", "url": "https://github.com/geotools/geotools/commit/0e1df12646a8599f19b0506dd4c86bd210002061", "message": "Homolosine projection with Sinusoidal used internally in spherical mode", "committedDate": "2020-03-13T14:59:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA3ODcyOA==", "url": "https://github.com/geotools/geotools/pull/2830#discussion_r393078728", "bodyText": "I searched the EPSG database, to my surprise the projection is not recognized/documented.\nHowever, the name as is seems too generic, as we have 3 variants in the wild\n\nNon interrupted Homolosine (implemented in proj as \"goode\", see https://proj.org/operations/projections/goode.html. ESRI does not seem to have it.\nInterrupted Homolosine, land centric, implemented in proj as \"igh\", see \"https://proj.org/operations/projections/igh.html\", and called \"Goode_Homolosine\" by ESRI, choosing \"option=1\"\nInterrupted Homolosine, water centric, not implemented in proj as far as I can see, and called \"Goode_Homolosine\" by ESRI, choosing \"option=2\"\n\nFor ESRI references see:\n\nhttps://desktop.arcgis.com/en/arcmap/10.3/guide-books/map-projections/goodes-homolosine.htm\nhttps://github.com/Esri/projection-engine-db-doc/blob/master/text/pe_list_projection.txt#L600\nhttps://raw.githubusercontent.com/Esri/projection-engine-db-doc/master/text/pe_list_projcs.txt (warning, big file, 6+MB, search for homolosine in it, you'll fine two examples)\n\nSuggestions:\n\nFor ESRI named identifier, use \"Goode_Homolosine\"\nFor GeoTools, maybe \"Interrupted_Homolosine\" to tell it apart from the non interrupted version?\n\nWhile now they won't present a big problem, I want to avoid issues in a future where the other two variants are implemented, and make sure we don't end up having conflicts.\nThe different name for GeoTools tries to be a match with the PROJ convention (calling interrupted what interrupted is), while the land/water difference can be handled by a parameter just like ESRI did, the day someone wants to implement the ocean centric math.", "author": "aaime", "createdAt": "2020-03-16T14:45:08Z", "path": "modules/library/referencing/src/main/java/org/geotools/referencing/operation/projection/Homolosine.java", "diffHunk": "@@ -0,0 +1,253 @@\n+/*\n+ *    GeoTools - The Open Source Java GIS Toolkit\n+ *    http://geotools.org\n+ *\n+ *    (C) 2020, Open Source Geospatial Foundation (OSGeo)\n+ *\n+ *    This library is free software; you can redistribute it and/or\n+ *    modify it under the terms of the GNU Lesser General Public\n+ *    License as published by the Free Software Foundation;\n+ *    version 2.1 of the License.\n+ *\n+ *    This library is distributed in the hope that it will be useful,\n+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ *    Lesser General Public License for more details.\n+ *\n+ *    This package contains formulas from the PROJ package of USGS.\n+ *    USGS's work is fully acknowledged here. This derived work has\n+ *    been relicensed under LGPL with Frank Warmerdam's permission.\n+ */\n+package org.geotools.referencing.operation.projection;\n+\n+import static java.lang.Math.toRadians;\n+\n+import java.awt.geom.Point2D;\n+import org.geotools.metadata.iso.citation.Citations;\n+import org.geotools.referencing.NamedIdentifier;\n+import org.opengis.parameter.ParameterDescriptor;\n+import org.opengis.parameter.ParameterDescriptorGroup;\n+import org.opengis.parameter.ParameterNotFoundException;\n+import org.opengis.parameter.ParameterValueGroup;\n+import org.opengis.referencing.operation.MathTransform;\n+\n+/**\n+ * Homolosine projection\n+ *\n+ * @see <A HREF=\"https://doi.org/10.2307%2F2560812\">Goode, J.P. (1925). \"The Homolosine projection -\n+ *     a new device for portraying the Earth's surface entire\". Annals of the Association of\n+ *     American Geographers. 15 (3): 119\u2013125</A>\n+ * @see <A HREF=\"https://en.wikipedia.org/wiki/Goode_homolosine_projection\">The Homolosine\n+ *     projection on Wikipedia</A>\n+ * @since 22.x\n+ * @author Lu\u00eds M. de Sousa\n+ */\n+public class Homolosine extends MapProjection {\n+    /** For cross-version compatibility. */\n+    private static final long serialVersionUID = 4740760391570944118L;\n+\n+    private static double LAT_THRESH = toRadians(40 + 44 / 60. + 11.8 / 3600.);\n+\n+    private static final double[] INTERRUP_NORTH = {\n+        toRadians(-180), toRadians(-40), toRadians(180)\n+    };\n+    private static final double[] INTERRUP_SOUTH = {\n+        toRadians(-180), toRadians(-100), toRadians(-20), toRadians(80), toRadians(180)\n+    };\n+\n+    private static final double[] CENTRAL_MERID_NORTH = {toRadians(-100), toRadians(30)};\n+    private static final double[] CENTRAL_MERID_SOUTH = {\n+        toRadians(-160), toRadians(-60), toRadians(20), toRadians(140)\n+    };\n+\n+    ParameterDescriptorGroup descriptors;\n+    ParameterValueGroup parameters; // stored locally to skip computations in parent\n+\n+    Mollweide moll;\n+    Sinusoidal sinu;\n+\n+    /**\n+     * Constructs a new map projection from the supplied parameters.\n+     *\n+     * @param parameters The parameter values in standard units.\n+     * @throws ParameterNotFoundException if a mandatory parameter is missing.\n+     */\n+    protected Homolosine(\n+            final ParameterDescriptorGroup descriptors, final ParameterValueGroup parameters)\n+            throws ParameterNotFoundException {\n+\n+        super(parameters, descriptors.descriptors());\n+        this.descriptors = descriptors;\n+        this.parameters = parameters;\n+        this.sinu = new Sinusoidal(this.parameters);\n+        this.moll =\n+                new Mollweide(\n+                        Mollweide.ProjectionMode.Mollweide, this.descriptors, this.parameters);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public ParameterDescriptorGroup getParameterDescriptors() {\n+        return Provider.PARAMETERS;\n+    }\n+\n+    /**\n+     * Computes the Northing difference between Sinusoidal and Mollweide at the threshold latitude.\n+     *\n+     * @return Northing offset between Sinusoidal and Mollweide at threshold latitude.\n+     * @throws ProjectionException\n+     */\n+    protected double computeOffset() throws ProjectionException {\n+        Point2D moll_tresh = moll.transformNormalized(0, LAT_THRESH, null);\n+        return moll_tresh.getY() - LAT_THRESH;\n+    }\n+\n+    /**\n+     * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates (units in\n+     * radians) and stores the result in {@code ptDst} (linear distance on a unit sphere).\n+     */\n+    protected Point2D transformNormalized(double lam, double phi, Point2D ptDst)\n+            throws ProjectionException {\n+\n+        double[] interruptions;\n+        double[] central_merids;\n+        double offset = computeOffset();\n+        int i = 0;\n+        double central_merid = 0;\n+        double lam_shift = 0;\n+        Point2D p;\n+        Point2D shift;\n+\n+        if (phi >= 0) {\n+            interruptions = INTERRUP_NORTH;\n+            central_merids = CENTRAL_MERID_NORTH;\n+        } else {\n+            interruptions = INTERRUP_SOUTH;\n+            central_merids = CENTRAL_MERID_SOUTH;\n+            offset = -offset;\n+        }\n+\n+        if (lam > interruptions[interruptions.length - 1]) i = interruptions.length;\n+        else while (lam > interruptions[i]) i++;\n+\n+        central_merid = central_merids[i - 1];\n+        lam_shift = lam - central_merid;\n+\n+        if (phi > LAT_THRESH || phi < -LAT_THRESH) { // Mollweide\n+            p = moll.transformNormalized(lam_shift, phi, ptDst);\n+            p.setLocation(p.getX(), p.getY() - offset);\n+        } else { // Sinusoidal in spherical form\n+            p = new Point2D.Double(lam_shift * Math.cos(phi), phi);\n+        }\n+\n+        shift = sinu.transformNormalized(central_merid, 0., null);\n+        p.setLocation(p.getX() + shift.getX(), p.getY());\n+\n+        if (ptDst != null) {\n+            ptDst.setLocation(p.getX(), p.getY());\n+            return ptDst;\n+        } else {\n+            return p;\n+        }\n+    }\n+\n+    /**\n+     * Transforms the specified (<var>x</var>,<var>y</var>) coordinates and stores the result in\n+     * {@code ptDst}.\n+     */\n+    protected Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)\n+            throws ProjectionException {\n+\n+        double[] interruptions;\n+        double[] central_merids;\n+        double offset = computeOffset();\n+        int i = 0;\n+        double central_merid = 0;\n+        Point2D p;\n+        Point2D shift;\n+        double thresh_map = LAT_THRESH; // spherical model\n+\n+        if (y >= 0) {\n+            central_merids = CENTRAL_MERID_NORTH;\n+            interruptions = new double[INTERRUP_NORTH.length];\n+            for (int j = 0; j < INTERRUP_NORTH.length; j++)\n+                interruptions[j] = sinu.transformNormalized(INTERRUP_NORTH[j], 0, null).getX();\n+        } else {\n+            central_merids = CENTRAL_MERID_SOUTH;\n+            offset = -offset;\n+            interruptions = new double[INTERRUP_SOUTH.length];\n+            for (int j = 0; j < INTERRUP_SOUTH.length; j++)\n+                interruptions[j] = sinu.transformNormalized(INTERRUP_SOUTH[j], 0, null).getX();\n+        }\n+\n+        if (x > interruptions[interruptions.length - 1]) i = interruptions.length;\n+        else while (x > interruptions[i]) i++;\n+\n+        central_merid = central_merids[i - 1];\n+        shift = sinu.transformNormalized(central_merid, 0, null);\n+\n+        if (y > thresh_map || y < -thresh_map) { // Mollweide\n+            p = moll.inverseTransformNormalized(x - shift.getX(), y + offset, ptDst);\n+        } else { // Sinusoidal in spherical mode\n+            p = new Point2D.Double((x - shift.getX()) / Math.cos(y), y);\n+        }\n+\n+        p.setLocation(p.getX() + central_merid, p.getY());\n+\n+        if (ptDst != null) {\n+            ptDst.setLocation(p.getX(), p.getY());\n+            return ptDst;\n+        } else {\n+            return p;\n+        }\n+    }\n+\n+    //////////////////////////////////////////////////////////////////////////////////////////\n+    //////////////////////////////////////////////////////////////////////////////////////////\n+    ////////                                                                          ////////\n+    ////////                                 PROVIDERS                                ////////\n+    ////////                                                                          ////////\n+    //////////////////////////////////////////////////////////////////////////////////////////\n+    //////////////////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * The {@linkplain org.geotools.referencing.operation.MathTransformProvider math transform\n+     * provider} for the Homolosine projection (not part of the EPSG database).\n+     *\n+     * @since 22.x\n+     * @author Lu\u00eds M. de Sousa\n+     * @see org.geotools.referencing.operation.DefaultMathTransformFactory\n+     */\n+    public static class Provider extends AbstractProvider {\n+\n+        /** For cross-version compatibility. */\n+        private static final long serialVersionUID = -7345885830045627291L;\n+\n+        /** The parameters group. */\n+        static final ParameterDescriptorGroup PARAMETERS =\n+                createDescriptorGroup(\n+                        new NamedIdentifier[] {", "originalCommit": "0e1df12646a8599f19b0506dd4c86bd210002061", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2755e6b870936aa26dbde8d6a397d54735ee890d", "url": "https://github.com/geotools/geotools/commit/2755e6b870936aa26dbde8d6a397d54735ee890d", "message": "Homolosine named identifiers adapted to legacy names by PROJ and ESRI", "committedDate": "2020-03-16T15:39:51Z", "type": "commit"}, {"oid": "1add18c09324f53e78fb3b32be9de265ac3860ba", "url": "https://github.com/geotools/geotools/commit/1add18c09324f53e78fb3b32be9de265ac3860ba", "message": "Updated Homolosine projection name in tests script", "committedDate": "2020-03-24T19:58:30Z", "type": "commit"}, {"oid": "357ebbef54a3ebdc6226438677dbe188b385540a", "url": "https://github.com/geotools/geotools/commit/357ebbef54a3ebdc6226438677dbe188b385540a", "message": "Homolosine projection treating angles outside the ]-PI, PI] and ]PI/2, PI/2] intervals", "committedDate": "2020-04-13T13:29:07Z", "type": "commit"}, {"oid": "31e5875d94b0b7331b5e7a3ecdcec7b0aee91c13", "url": "https://github.com/geotools/geotools/commit/31e5875d94b0b7331b5e7a3ecdcec7b0aee91c13", "message": "Considering small easting values outside the co-domian in the inverse Homolosine", "committedDate": "2020-04-19T09:58:06Z", "type": "commit"}]}