{"pr_number": 3087, "pr_title": "[GEOT-6386] Implement Polyconic spherical case", "pr_createdAt": "2020-07-23T13:45:33Z", "pr_url": "https://github.com/geotools/geotools/pull/3087", "timeline": [{"oid": "9d3fdfa1574dafa37e5da1dd58cdc6f178e11e80", "url": "https://github.com/geotools/geotools/commit/9d3fdfa1574dafa37e5da1dd58cdc6f178e11e80", "message": "[GEOT-6386] Implement Polyconic spherical case\n\nGEOT-6386 unit tests for spherical polyconic\n\nGEOT-6386 Polyconic Sphere QA Cleanup\n\nGEOT-6386 unit tests for spherical polyconic\n\nGEOT-6386 Polyconic Sphere QA Cleanup", "committedDate": "2020-07-23T13:41:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzODkzMw==", "url": "https://github.com/geotools/geotools/pull/3087#discussion_r464338933", "bodyText": "Inefficient and incoherent with the implemented interface, ptDst should be used when present. When reprojecting lots of points, the machinery passes a single target point to avoid excessive object allocation.", "author": "aaime", "createdAt": "2020-08-03T10:51:32Z", "path": "modules/library/referencing/src/main/java/org/geotools/referencing/operation/projection/Polyconic.java", "diffHunk": "@@ -74,133 +73,212 @@\n     /** Difference allowed in iterative computations. */\n     private static final double ITERATION_TOLERANCE = 1E-12;\n \n-    /**\n-     * Meridian distance at the {@code latitudeOfOrigin}. Used for calculations for the ellipsoid.\n-     */\n-    private final double ml0;\n+    public abstract static class Abstract extends MapProjection {\n+        /**\n+         * Meridian distance at the {@code latitudeOfOrigin}. Used for calculations for the\n+         * ellipsoid.\n+         */\n+        protected final double ml0;\n+        /**\n+         * Constructs a new map projection from the supplied parameters.\n+         *\n+         * @param parameters The parameter values in standard units.\n+         * @throws ParameterNotFoundException if a mandatory parameter is missing.\n+         */\n+        protected Abstract(final ParameterValueGroup parameters) throws ParameterNotFoundException {\n \n-    /**\n-     * Constructs a new map projection from the supplied parameters.\n-     *\n-     * @param parameters The parameter values in standard units.\n-     * @throws ParameterNotFoundException if a mandatory parameter is missing.\n-     */\n-    protected Polyconic(final ParameterValueGroup parameters) throws ParameterNotFoundException {\n-        super(parameters);\n+            super(parameters);\n \n-        //  Compute constants\n-        ml0 = mlfn(latitudeOfOrigin, sin(latitudeOfOrigin), cos(latitudeOfOrigin));\n-    }\n+            //  Compute constants\n+            ml0 = mlfn(latitudeOfOrigin, sin(latitudeOfOrigin), cos(latitudeOfOrigin));\n+        }\n \n-    /** {@inheritDoc} */\n-    public ParameterDescriptorGroup getParameterDescriptors() {\n-        return Provider.PARAMETERS;\n-    }\n+        /** {@inheritDoc} */\n+        public ParameterDescriptorGroup getParameterDescriptors() {\n+            return Provider.PARAMETERS;\n+        }\n \n-    /**\n-     * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates (units in\n-     * radians) and stores the result in {@code ptDst} (linear distance on a unit sphere).\n-     */\n-    protected Point2D transformNormalized(double lam, double phi, final Point2D ptDst)\n-            throws ProjectionException {\n-        double ms, sp, cp, x, y;\n+        @Override\n+        protected double getToleranceForAssertions(double longitude, double latitude) {\n+            if (abs(longitude - centralMeridian) / 2 + abs(latitude - latitudeOfOrigin) > 10) {\n+                // When far from the valid area, use a larger tolerance.\n+                return 0.1;\n+            }\n+            return super.getToleranceForAssertions(longitude, latitude);\n+        }\n \n-        if (abs(phi) <= EPSILON) {\n-            x = lam;\n-            y = -ml0;\n-        } else {\n-            sp = sin(phi);\n-            ms = abs(cp = cos(phi)) > EPSILON ? msfn(sp, cp) / sp : 0.;\n-            lam *= sp;\n-            x = ms * sin(lam);\n-            y = (mlfn(phi, sp, cp) - ml0) + ms * (1. - cos(lam));\n+        /** Returns a hash value for this projection. */\n+        @Override\n+        public int hashCode() {\n+            final long code = Double.doubleToLongBits(ml0);\n+            return ((int) code ^ (int) (code >>> 32)) + 37 * super.hashCode();\n         }\n \n-        if (ptDst != null) {\n-            ptDst.setLocation(x, y);\n-            return ptDst;\n+        /** Compares the specified object with this map projection for equality. */\n+        @Override\n+        public boolean equals(final Object object) {\n+            if (object == this) {\n+                // Slight optimization\n+                return true;\n+            }\n+            if (super.equals(object)) {\n+                final Abstract that = (Abstract) object;\n+                return equals(this.ml0, that.ml0);\n+            }\n+            return false;\n         }\n-        return new Point2D.Double(x, y);\n     }\n \n-    /**\n-     * Transforms the specified (<var>x</var>,<var>y</var>) coordinates and stores the result in\n-     * {@code ptDst}.\n-     */\n-    protected Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)\n-            throws ProjectionException {\n-        double lam, phi;\n-\n-        y += ml0;\n-        if (abs(y) <= EPSILON) {\n-            lam = x;\n-            phi = 0.;\n-        } else {\n-            final double r = y * y + x * x;\n-            phi = y;\n-            int i = 0;\n-            for (; i <= MAXIMUM_ITERATIONS; i++) {\n-                final double sp = sin(phi);\n-                final double cp = cos(phi);\n-                if (abs(cp) < ITERATION_TOLERANCE)\n-                    throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+    /** Ellipsoidal Polyconic projection. */\n+    @SuppressWarnings(\"serial\")\n+    public static class Ellipsoidal extends Abstract {\n+        /**\n+         * Constructor.\n+         *\n+         * @param parameters the parameters that define this projection\n+         * @throws ParameterNotFoundException\n+         */\n+        protected Ellipsoidal(ParameterValueGroup parameters) throws ParameterNotFoundException {\n+            super(parameters);\n+        }\n+        /**\n+         * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates (units in\n+         * radians) and stores the result in {@code ptDst} (linear distance on a unit sphere).\n+         */\n+        protected Point2D transformNormalized(double lam, double phi, final Point2D ptDst)\n+                throws ProjectionException {\n+            double ms, sp, cp, x, y;\n \n-                final double s2ph = sp * cp;\n-                double mlp = sqrt(1. - excentricitySquared * sp * sp);\n-                final double c = sp * mlp / cp;\n-                final double ml = mlfn(phi, sp, cp);\n-                final double mlb = ml * ml + r;\n-                mlp = (1. - excentricitySquared) / (mlp * mlp * mlp);\n-                final double dPhi =\n-                        (ml + ml + c * mlb - 2. * y * (c * ml + 1.))\n-                                / (excentricitySquared * s2ph * (mlb - 2. * y * ml) / c\n-                                        + 2. * (y - ml) * (c * mlp - 1. / s2ph)\n-                                        - mlp\n-                                        - mlp);\n-                if (abs(dPhi) <= ITERATION_TOLERANCE) break;\n+            if (abs(phi) <= EPSILON) {\n+                x = lam;\n+                y = -ml0;\n+            } else {\n+                sp = sin(phi);\n+                ms = abs(cp = cos(phi)) > EPSILON ? msfn(sp, cp) / sp : 0.;\n+                lam *= sp;\n+                x = ms * sin(lam);\n+                y = (mlfn(phi, sp, cp) - ml0) + ms * (1. - cos(lam));\n+            }\n \n-                phi += dPhi;\n+            if (ptDst != null) {\n+                ptDst.setLocation(x, y);\n+                return ptDst;\n             }\n-            if (i > MAXIMUM_ITERATIONS) throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n-            final double c = sin(phi);\n-            lam = asin(x * tan(phi) * sqrt(1. - excentricitySquared * c * c)) / sin(phi);\n+            return new Point2D.Double(x, y);\n         }\n \n-        if (ptDst != null) {\n-            ptDst.setLocation(lam, phi);\n-            return ptDst;\n-        }\n-        return new Point2D.Double(lam, phi);\n-    }\n+        /**\n+         * Transforms the specified (<var>x</var>,<var>y</var>) coordinates and stores the result in\n+         * {@code ptDst}.\n+         */\n+        protected Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)\n+                throws ProjectionException {\n+            double lam, phi;\n+\n+            y += ml0;\n+            if (abs(y) <= EPSILON) {\n+                lam = x;\n+                phi = 0.;\n+            } else {\n+                final double r = y * y + x * x;\n+                phi = y;\n+                int i = 0;\n+                for (; i <= MAXIMUM_ITERATIONS; i++) {\n+                    final double sp = sin(phi);\n+                    final double cp = cos(phi);\n+                    if (abs(cp) < ITERATION_TOLERANCE)\n+                        throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+\n+                    final double s2ph = sp * cp;\n+                    double mlp = sqrt(1. - excentricitySquared * sp * sp);\n+                    final double c = sp * mlp / cp;\n+                    final double ml = mlfn(phi, sp, cp);\n+                    final double mlb = ml * ml + r;\n+                    mlp = (1. - excentricitySquared) / (mlp * mlp * mlp);\n+                    final double dPhi =\n+                            (ml + ml + c * mlb - 2. * y * (c * ml + 1.))\n+                                    / (excentricitySquared * s2ph * (mlb - 2. * y * ml) / c\n+                                            + 2. * (y - ml) * (c * mlp - 1. / s2ph)\n+                                            - mlp\n+                                            - mlp);\n+                    if (abs(dPhi) <= ITERATION_TOLERANCE) break;\n \n-    @Override\n-    protected double getToleranceForAssertions(double longitude, double latitude) {\n-        if (abs(longitude - centralMeridian) / 2 + abs(latitude - latitudeOfOrigin) > 10) {\n-            // When far from the valid area, use a larger tolerance.\n-            return 0.1;\n+                    phi += dPhi;\n+                }\n+                if (i > MAXIMUM_ITERATIONS) throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+                final double c = sin(phi);\n+                lam = asin(x * tan(phi) * sqrt(1. - excentricitySquared * c * c)) / sin(phi);\n+            }\n+\n+            if (ptDst != null) {\n+                ptDst.setLocation(lam, phi);\n+                return ptDst;\n+            }\n+            return new Point2D.Double(lam, phi);\n         }\n-        return super.getToleranceForAssertions(longitude, latitude);\n     }\n \n-    /** Returns a hash value for this projection. */\n-    @Override\n-    public int hashCode() {\n-        final long code = Double.doubleToLongBits(ml0);\n-        return ((int) code ^ (int) (code >>> 32)) + 37 * super.hashCode();\n-    }\n+    /** Ellipsoidal Polyconic projection. */\n+    @SuppressWarnings(\"serial\")\n+    public static class Spherical extends Abstract {\n \n-    /** Compares the specified object with this map projection for equality. */\n-    @Override\n-    public boolean equals(final Object object) {\n-        if (object == this) {\n-            // Slight optimization\n-            return true;\n+        /**\n+         * Constructs a new map projection from the supplied parameters.\n+         *\n+         * @param parameters The parameter values in standard units.\n+         * @throws ParameterNotFoundException if a mandatory parameter is missing.\n+         */\n+        protected Spherical(ParameterValueGroup parameters) throws ParameterNotFoundException {\n+            super(parameters);\n         }\n-        if (super.equals(object)) {\n-            final Polyconic that = (Polyconic) object;\n-            return equals(this.ml0, that.ml0);\n+\n+        @Override\n+        protected Point2D inverseTransformNormalized(double x, double y, Point2D ptDst)\n+                throws ProjectionException {\n+            double lam, phi;\n+            if (abs(y = latitudeOfOrigin + y) <= EPSILON) {\n+                lam = x;\n+                phi = 0.;\n+            } else {\n+                phi = y;\n+                double B = x * x + y * y;\n+                int i = MAXIMUM_ITERATIONS;\n+                while (true) {\n+                    double tp = tan(phi);\n+                    double dphi =\n+                            (y * (phi * tp + 1.) - phi - .5 * (phi * phi + B) * tp)\n+                                    / ((phi - y) / tp - 1.);\n+                    phi -= dphi;\n+                    if (!(abs(dphi) > ITERATION_TOLERANCE)) break;\n+                    --i;\n+                    if (i == 0) {\n+                        throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+                    }\n+                }\n+                lam = asin(x * tan(phi)) / sin(phi);\n+            }\n+            return new Point2D.Double(lam, phi);", "originalCommit": "9d3fdfa1574dafa37e5da1dd58cdc6f178e11e80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4NDc0Nw==", "url": "https://github.com/geotools/geotools/pull/3087#discussion_r464684747", "bodyText": "Fixed.", "author": "turingtestfail", "createdAt": "2020-08-03T22:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzODkzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4NDk4MQ==", "url": "https://github.com/geotools/geotools/pull/3087#discussion_r464684981", "bodyText": "fixed", "author": "turingtestfail", "createdAt": "2020-08-03T22:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzODkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzODk4MA==", "url": "https://github.com/geotools/geotools/pull/3087#discussion_r464338980", "bodyText": "Same as above.", "author": "aaime", "createdAt": "2020-08-03T10:51:40Z", "path": "modules/library/referencing/src/main/java/org/geotools/referencing/operation/projection/Polyconic.java", "diffHunk": "@@ -74,133 +73,212 @@\n     /** Difference allowed in iterative computations. */\n     private static final double ITERATION_TOLERANCE = 1E-12;\n \n-    /**\n-     * Meridian distance at the {@code latitudeOfOrigin}. Used for calculations for the ellipsoid.\n-     */\n-    private final double ml0;\n+    public abstract static class Abstract extends MapProjection {\n+        /**\n+         * Meridian distance at the {@code latitudeOfOrigin}. Used for calculations for the\n+         * ellipsoid.\n+         */\n+        protected final double ml0;\n+        /**\n+         * Constructs a new map projection from the supplied parameters.\n+         *\n+         * @param parameters The parameter values in standard units.\n+         * @throws ParameterNotFoundException if a mandatory parameter is missing.\n+         */\n+        protected Abstract(final ParameterValueGroup parameters) throws ParameterNotFoundException {\n \n-    /**\n-     * Constructs a new map projection from the supplied parameters.\n-     *\n-     * @param parameters The parameter values in standard units.\n-     * @throws ParameterNotFoundException if a mandatory parameter is missing.\n-     */\n-    protected Polyconic(final ParameterValueGroup parameters) throws ParameterNotFoundException {\n-        super(parameters);\n+            super(parameters);\n \n-        //  Compute constants\n-        ml0 = mlfn(latitudeOfOrigin, sin(latitudeOfOrigin), cos(latitudeOfOrigin));\n-    }\n+            //  Compute constants\n+            ml0 = mlfn(latitudeOfOrigin, sin(latitudeOfOrigin), cos(latitudeOfOrigin));\n+        }\n \n-    /** {@inheritDoc} */\n-    public ParameterDescriptorGroup getParameterDescriptors() {\n-        return Provider.PARAMETERS;\n-    }\n+        /** {@inheritDoc} */\n+        public ParameterDescriptorGroup getParameterDescriptors() {\n+            return Provider.PARAMETERS;\n+        }\n \n-    /**\n-     * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates (units in\n-     * radians) and stores the result in {@code ptDst} (linear distance on a unit sphere).\n-     */\n-    protected Point2D transformNormalized(double lam, double phi, final Point2D ptDst)\n-            throws ProjectionException {\n-        double ms, sp, cp, x, y;\n+        @Override\n+        protected double getToleranceForAssertions(double longitude, double latitude) {\n+            if (abs(longitude - centralMeridian) / 2 + abs(latitude - latitudeOfOrigin) > 10) {\n+                // When far from the valid area, use a larger tolerance.\n+                return 0.1;\n+            }\n+            return super.getToleranceForAssertions(longitude, latitude);\n+        }\n \n-        if (abs(phi) <= EPSILON) {\n-            x = lam;\n-            y = -ml0;\n-        } else {\n-            sp = sin(phi);\n-            ms = abs(cp = cos(phi)) > EPSILON ? msfn(sp, cp) / sp : 0.;\n-            lam *= sp;\n-            x = ms * sin(lam);\n-            y = (mlfn(phi, sp, cp) - ml0) + ms * (1. - cos(lam));\n+        /** Returns a hash value for this projection. */\n+        @Override\n+        public int hashCode() {\n+            final long code = Double.doubleToLongBits(ml0);\n+            return ((int) code ^ (int) (code >>> 32)) + 37 * super.hashCode();\n         }\n \n-        if (ptDst != null) {\n-            ptDst.setLocation(x, y);\n-            return ptDst;\n+        /** Compares the specified object with this map projection for equality. */\n+        @Override\n+        public boolean equals(final Object object) {\n+            if (object == this) {\n+                // Slight optimization\n+                return true;\n+            }\n+            if (super.equals(object)) {\n+                final Abstract that = (Abstract) object;\n+                return equals(this.ml0, that.ml0);\n+            }\n+            return false;\n         }\n-        return new Point2D.Double(x, y);\n     }\n \n-    /**\n-     * Transforms the specified (<var>x</var>,<var>y</var>) coordinates and stores the result in\n-     * {@code ptDst}.\n-     */\n-    protected Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)\n-            throws ProjectionException {\n-        double lam, phi;\n-\n-        y += ml0;\n-        if (abs(y) <= EPSILON) {\n-            lam = x;\n-            phi = 0.;\n-        } else {\n-            final double r = y * y + x * x;\n-            phi = y;\n-            int i = 0;\n-            for (; i <= MAXIMUM_ITERATIONS; i++) {\n-                final double sp = sin(phi);\n-                final double cp = cos(phi);\n-                if (abs(cp) < ITERATION_TOLERANCE)\n-                    throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+    /** Ellipsoidal Polyconic projection. */\n+    @SuppressWarnings(\"serial\")\n+    public static class Ellipsoidal extends Abstract {\n+        /**\n+         * Constructor.\n+         *\n+         * @param parameters the parameters that define this projection\n+         * @throws ParameterNotFoundException\n+         */\n+        protected Ellipsoidal(ParameterValueGroup parameters) throws ParameterNotFoundException {\n+            super(parameters);\n+        }\n+        /**\n+         * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates (units in\n+         * radians) and stores the result in {@code ptDst} (linear distance on a unit sphere).\n+         */\n+        protected Point2D transformNormalized(double lam, double phi, final Point2D ptDst)\n+                throws ProjectionException {\n+            double ms, sp, cp, x, y;\n \n-                final double s2ph = sp * cp;\n-                double mlp = sqrt(1. - excentricitySquared * sp * sp);\n-                final double c = sp * mlp / cp;\n-                final double ml = mlfn(phi, sp, cp);\n-                final double mlb = ml * ml + r;\n-                mlp = (1. - excentricitySquared) / (mlp * mlp * mlp);\n-                final double dPhi =\n-                        (ml + ml + c * mlb - 2. * y * (c * ml + 1.))\n-                                / (excentricitySquared * s2ph * (mlb - 2. * y * ml) / c\n-                                        + 2. * (y - ml) * (c * mlp - 1. / s2ph)\n-                                        - mlp\n-                                        - mlp);\n-                if (abs(dPhi) <= ITERATION_TOLERANCE) break;\n+            if (abs(phi) <= EPSILON) {\n+                x = lam;\n+                y = -ml0;\n+            } else {\n+                sp = sin(phi);\n+                ms = abs(cp = cos(phi)) > EPSILON ? msfn(sp, cp) / sp : 0.;\n+                lam *= sp;\n+                x = ms * sin(lam);\n+                y = (mlfn(phi, sp, cp) - ml0) + ms * (1. - cos(lam));\n+            }\n \n-                phi += dPhi;\n+            if (ptDst != null) {\n+                ptDst.setLocation(x, y);\n+                return ptDst;\n             }\n-            if (i > MAXIMUM_ITERATIONS) throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n-            final double c = sin(phi);\n-            lam = asin(x * tan(phi) * sqrt(1. - excentricitySquared * c * c)) / sin(phi);\n+            return new Point2D.Double(x, y);\n         }\n \n-        if (ptDst != null) {\n-            ptDst.setLocation(lam, phi);\n-            return ptDst;\n-        }\n-        return new Point2D.Double(lam, phi);\n-    }\n+        /**\n+         * Transforms the specified (<var>x</var>,<var>y</var>) coordinates and stores the result in\n+         * {@code ptDst}.\n+         */\n+        protected Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)\n+                throws ProjectionException {\n+            double lam, phi;\n+\n+            y += ml0;\n+            if (abs(y) <= EPSILON) {\n+                lam = x;\n+                phi = 0.;\n+            } else {\n+                final double r = y * y + x * x;\n+                phi = y;\n+                int i = 0;\n+                for (; i <= MAXIMUM_ITERATIONS; i++) {\n+                    final double sp = sin(phi);\n+                    final double cp = cos(phi);\n+                    if (abs(cp) < ITERATION_TOLERANCE)\n+                        throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+\n+                    final double s2ph = sp * cp;\n+                    double mlp = sqrt(1. - excentricitySquared * sp * sp);\n+                    final double c = sp * mlp / cp;\n+                    final double ml = mlfn(phi, sp, cp);\n+                    final double mlb = ml * ml + r;\n+                    mlp = (1. - excentricitySquared) / (mlp * mlp * mlp);\n+                    final double dPhi =\n+                            (ml + ml + c * mlb - 2. * y * (c * ml + 1.))\n+                                    / (excentricitySquared * s2ph * (mlb - 2. * y * ml) / c\n+                                            + 2. * (y - ml) * (c * mlp - 1. / s2ph)\n+                                            - mlp\n+                                            - mlp);\n+                    if (abs(dPhi) <= ITERATION_TOLERANCE) break;\n \n-    @Override\n-    protected double getToleranceForAssertions(double longitude, double latitude) {\n-        if (abs(longitude - centralMeridian) / 2 + abs(latitude - latitudeOfOrigin) > 10) {\n-            // When far from the valid area, use a larger tolerance.\n-            return 0.1;\n+                    phi += dPhi;\n+                }\n+                if (i > MAXIMUM_ITERATIONS) throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+                final double c = sin(phi);\n+                lam = asin(x * tan(phi) * sqrt(1. - excentricitySquared * c * c)) / sin(phi);\n+            }\n+\n+            if (ptDst != null) {\n+                ptDst.setLocation(lam, phi);\n+                return ptDst;\n+            }\n+            return new Point2D.Double(lam, phi);\n         }\n-        return super.getToleranceForAssertions(longitude, latitude);\n     }\n \n-    /** Returns a hash value for this projection. */\n-    @Override\n-    public int hashCode() {\n-        final long code = Double.doubleToLongBits(ml0);\n-        return ((int) code ^ (int) (code >>> 32)) + 37 * super.hashCode();\n-    }\n+    /** Ellipsoidal Polyconic projection. */\n+    @SuppressWarnings(\"serial\")\n+    public static class Spherical extends Abstract {\n \n-    /** Compares the specified object with this map projection for equality. */\n-    @Override\n-    public boolean equals(final Object object) {\n-        if (object == this) {\n-            // Slight optimization\n-            return true;\n+        /**\n+         * Constructs a new map projection from the supplied parameters.\n+         *\n+         * @param parameters The parameter values in standard units.\n+         * @throws ParameterNotFoundException if a mandatory parameter is missing.\n+         */\n+        protected Spherical(ParameterValueGroup parameters) throws ParameterNotFoundException {\n+            super(parameters);\n         }\n-        if (super.equals(object)) {\n-            final Polyconic that = (Polyconic) object;\n-            return equals(this.ml0, that.ml0);\n+\n+        @Override\n+        protected Point2D inverseTransformNormalized(double x, double y, Point2D ptDst)\n+                throws ProjectionException {\n+            double lam, phi;\n+            if (abs(y = latitudeOfOrigin + y) <= EPSILON) {\n+                lam = x;\n+                phi = 0.;\n+            } else {\n+                phi = y;\n+                double B = x * x + y * y;\n+                int i = MAXIMUM_ITERATIONS;\n+                while (true) {\n+                    double tp = tan(phi);\n+                    double dphi =\n+                            (y * (phi * tp + 1.) - phi - .5 * (phi * phi + B) * tp)\n+                                    / ((phi - y) / tp - 1.);\n+                    phi -= dphi;\n+                    if (!(abs(dphi) > ITERATION_TOLERANCE)) break;\n+                    --i;\n+                    if (i == 0) {\n+                        throw new ProjectionException(ErrorKeys.NO_CONVERGENCE);\n+                    }\n+                }\n+                lam = asin(x * tan(phi)) / sin(phi);\n+            }\n+            return new Point2D.Double(lam, phi);\n+        }\n+\n+        @Override\n+        protected Point2D transformNormalized(double lam, double phi, Point2D ptDst)\n+                throws ProjectionException {\n+            double x, y;\n+            if (abs(phi) <= EPSILON) {\n+                x = lam;\n+                y = ml0;\n+            } else {\n+                double cot = 1. / tan(phi);\n+                double E = lam * sin(phi);\n+                x = sin(E) * cot;\n+                y = phi - latitudeOfOrigin + cot * (1. - cos(E));\n+            }\n+            if (ptDst != null) {\n+                ptDst.setLocation(x, y);\n+                return ptDst;\n+            }\n+            return new Point2D.Double(x, y);", "originalCommit": "9d3fdfa1574dafa37e5da1dd58cdc6f178e11e80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4NTA0Mg==", "url": "https://github.com/geotools/geotools/pull/3087#discussion_r464685042", "bodyText": "fixed", "author": "turingtestfail", "createdAt": "2020-08-03T22:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDMzODk4MA=="}], "type": "inlineReview"}, {"oid": "ed797db5146cba28ac2cb62e10fb5be48f9f5129", "url": "https://github.com/geotools/geotools/commit/ed797db5146cba28ac2cb62e10fb5be48f9f5129", "message": "addressed PR comment about returning ptDst", "committedDate": "2020-08-03T21:58:55Z", "type": "commit"}]}