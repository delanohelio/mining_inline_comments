{"pr_number": 697, "pr_title": "chore(griffin) - various view and functions needed for Kafka metadata queries", "pr_createdAt": "2020-11-12T14:02:08Z", "pr_url": "https://github.com/questdb/questdb/pull/697", "timeline": [{"oid": "5f403815b5537f4aba89677ec6634c6b0ec0b429", "url": "https://github.com/questdb/questdb/commit/5f403815b5537f4aba89677ec6634c6b0ec0b429", "message": "chore(griffin) - various functions for Kafka PG-driver metadata queries", "committedDate": "2020-11-12T13:54:09Z", "type": "commit"}, {"oid": "3242e5185e292cc57b7231d68bad76e6369b3973", "url": "https://github.com/questdb/questdb/commit/3242e5185e292cc57b7231d68bad76e6369b3973", "message": "fix(sql): fixed sql bug to do with top down column propagation", "committedDate": "2020-11-12T13:55:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMzMzMA==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r522133330", "bodyText": "the goal of the SQL is to enumerate table columns like PG does\n nspname | relname  |  attname   | atttypid | attnotnull | atttypmod | attlen | typtypmod | attnum | attidentity | adsrc | description | typbasetype | typtype\n---------+----------+------------+----------+------------+-----------+--------+-----------+--------+-------------+-------+-------------+-------------+---------\n public  | po_items | po_no      |       23 | t          |        -1 |      4 |        -1 |      1 |             |       |             |           0 | b\n public  | po_items | item_no    |       23 | t          |        -1 |      4 |        -1 |      2 |             |       |             |           0 | b\n public  | po_items | product_no |       23 | f          |        -1 |      4 |        -1 |      3 |             |       |             |           0 | b\n public  | po_items | qty        |       23 | f          |        -1 |      4 |        -1 |      4 |             |       |             |           0 | b\n public  | po_items | net_price  |     1700 | f          |        -1 |     -1 |        -1 |      5 |             |       |             |           0 | b\n(5 rows)", "author": "bluestreak01", "createdAt": "2020-11-12T14:10:35Z", "path": "core/src/test/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactoryTest.java", "diffHunk": "@@ -262,17 +262,61 @@ public void testPgAttributeFuncWith2Tables() throws Exception {\n     @Test\n     public void testPgAttributeFuncWith2TablesLimit1() throws Exception {\n         assertQuery(\n-                \"attrelid\\tattname\\tattnum\\n\" +\n-                        \"1\\ta\\t1\\n\",\n+                \"attrelid\\tattname\\tattnum\\tatttypid\\tattnotnull\\tatttypmod\\tattlen\\tattidentity\\tattisdropped\\n\" +\n+                        \"1\\ta\\t1\\t0\\tfalse\\t0\\t0\\t\\tfalse\\n\",\n                 \"pg_catalog.pg_attribute order by 1 limit 1;\",\n                 \"create table x(a int)\",\n                 null,\n                 \"create table y(a double, b string)\",\n-                \"attrelid\\tattname\\tattnum\\n\" +\n-                        \"1\\ta\\t1\\n\",\n+                \"attrelid\\tattname\\tattnum\\tatttypid\\tattnotnull\\tatttypmod\\tattlen\\tattidentity\\tattisdropped\\n\" +\n+                        \"1\\ta\\t1\\t0\\tfalse\\t0\\t0\\t\\tfalse\\n\",\n                 true,\n                 false,\n                 true\n         );\n     }\n+\n+    @Test\n+    public void testSecondKafkaMetadataQuery() throws Exception {", "originalCommit": "3242e5185e292cc57b7231d68bad76e6369b3973", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEzMzY3MA==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r522133670", "bodyText": "the aim of the SQL is to enum columns. Having constant 0 out of the field isn't going to work", "author": "bluestreak01", "createdAt": "2020-11-12T14:11:10Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -236,6 +246,12 @@ public int getStrLen(int col) {\n         metadata.add(new TableColumnMetadata(\"attrelid\", ColumnType.INT, null));\n         metadata.add(new TableColumnMetadata(\"attname\", ColumnType.STRING, null));\n         metadata.add(new TableColumnMetadata(\"attnum\", ColumnType.SHORT, null));\n+        metadata.add(new TableColumnMetadata(\"atttypid\", ColumnType.INT, null));", "originalCommit": "3242e5185e292cc57b7231d68bad76e6369b3973", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2ced3b9fad8d5457c319277c30a6f82f53adf962", "url": "https://github.com/questdb/questdb/commit/2ced3b9fad8d5457c319277c30a6f82f53adf962", "message": "chore(griffin) - pg_type and pg_attribute now return type information", "committedDate": "2020-11-12T19:47:36Z", "type": "commit"}, {"oid": "36327c8fc5213dc94861f2d5fb08b9037cc69884", "url": "https://github.com/questdb/questdb/commit/36327c8fc5213dc94861f2d5fb08b9037cc69884", "message": "chore(griffin) - refactored pg_description and pg_attrdef to return column metadata", "committedDate": "2020-11-13T13:30:01Z", "type": "commit"}, {"oid": "6555fb22e463aae5fea798ea813ff5fac252e630", "url": "https://github.com/questdb/questdb/commit/6555fb22e463aae5fea798ea813ff5fac252e630", "message": "chore(griffin) - fixed SqlParserTest tests", "committedDate": "2020-11-13T13:42:51Z", "type": "commit"}, {"oid": "c2b189f9110e5d28c7e29c0fe1653ea4cd69f2ea", "url": "https://github.com/questdb/questdb/commit/c2b189f9110e5d28c7e29c0fe1653ea4cd69f2ea", "message": "chore(griffin) - kafka metadata queries: renamed inner class", "committedDate": "2020-11-13T14:11:59Z", "type": "commit"}, {"oid": "8b6be38fc0986ca51b428af38ed9ab9e53c0a137", "url": "https://github.com/questdb/questdb/commit/8b6be38fc0986ca51b428af38ed9ab9e53c0a137", "message": "chore(griffin) - kafka metadata queries: removed extra copyright in FunctionFactory", "committedDate": "2020-11-13T14:14:50Z", "type": "commit"}, {"oid": "752edb38eaee04e216a99e7fb08d2a38ca57db8a", "url": "https://github.com/questdb/questdb/commit/752edb38eaee04e216a99e7fb08d2a38ca57db8a", "message": "Merge branch 'master' into more.kafka.fun", "committedDate": "2020-11-13T14:21:29Z", "type": "commit"}, {"oid": "6900e2f5cbeab4af104ccd55d4c1be4d9411cdd3", "url": "https://github.com/questdb/questdb/commit/6900e2f5cbeab4af104ccd55d4c1be4d9411cdd3", "message": "chore(griffin) - kafka metadata functions: fixed flapping test in AttrDefCatalogueFunctionFactoryTest", "committedDate": "2020-11-13T14:36:15Z", "type": "commit"}, {"oid": "adf708c744206df81695b52ca0584bbce0bea5e0", "url": "https://github.com/questdb/questdb/commit/adf708c744206df81695b52ca0584bbce0bea5e0", "message": "Merge remote-tracking branch 'origin/more.kafka.fun' into more.kafka.fun", "committedDate": "2020-11-13T14:36:26Z", "type": "commit"}, {"oid": "6e7b963c44fd7ad3f5bc212edcb286f757e64b96", "url": "https://github.com/questdb/questdb/commit/6e7b963c44fd7ad3f5bc212edcb286f757e64b96", "message": "chore(griffin) - kafka metadata functions: type name and  type size fixes", "committedDate": "2020-11-13T15:59:34Z", "type": "commit"}, {"oid": "90146d8eb6a49d9ce8924e520b9a862fc476bbd9", "url": "https://github.com/questdb/questdb/commit/90146d8eb6a49d9ce8924e520b9a862fc476bbd9", "message": "chore(griffin) - kafka metadata functions: added function removed by mistake", "committedDate": "2020-11-13T16:03:03Z", "type": "commit"}, {"oid": "be74da0636a17658737803c0931ee8eca8d6aaf5", "url": "https://github.com/questdb/questdb/commit/be74da0636a17658737803c0931ee8eca8d6aaf5", "message": "chore(griffin) - kafka metadata functions: added tests for failed int read", "committedDate": "2020-11-13T19:21:55Z", "type": "commit"}, {"oid": "f28b293ffdb8ff0c246cb0c96cc0d553efb4b965", "url": "https://github.com/questdb/questdb/commit/f28b293ffdb8ff0c246cb0c96cc0d553efb4b965", "message": "chore(griffin) - kafka metadata functions: fixed broken tests", "committedDate": "2020-11-13T19:46:38Z", "type": "commit"}, {"oid": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "url": "https://github.com/questdb/questdb/commit/a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "message": "chore(griffin) - kafka metadata functions: fixed broken tests", "committedDate": "2020-11-13T22:07:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzNjkzNw==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524036937", "bodyText": "make it a list", "author": "bluestreak01", "createdAt": "2020-11-16T09:42:23Z", "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGOids.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.pgwire;\n+\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.std.IntHashSet;\n+import io.questdb.std.IntIntHashMap;\n+import io.questdb.std.IntList;\n+import io.questdb.std.IntObjHashMap;\n+\n+public class PGOids {\n+\n+    public static final int PG_VARCHAR = 1043;\n+    public static final int PG_TIMESTAMP = 1114;\n+    public static final int PG_TIMESTAMPZ = 1184;\n+    public static final int PG_FLOAT8 = 701;\n+    public static final int PG_FLOAT4 = 700;\n+    public static final int PG_INT4 = 23;\n+    public static final int PG_INT2 = 21;\n+    public static final int PG_INT8 = 20;\n+    public static final int PG_NUMERIC = 1700;\n+    public static final int PG_BOOL = 16;\n+    public static final int PG_CHAR = 18;\n+    public static final int PG_DATE = 1082;\n+    public static final int PG_BYTEA = 17;\n+    public static final int PG_UNSPECIFIED = 0;\n+    public static final IntList TYPE_OIDS = new IntList();\n+    public static final IntHashSet PG_TYPE_OIDS = new IntHashSet();", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzNzQ4MA==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524037480", "bodyText": "populate with explicit values", "author": "bluestreak01", "createdAt": "2020-11-16T09:42:54Z", "path": "core/src/main/java/io/questdb/cutlass/pgwire/PGOids.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.pgwire;\n+\n+import io.questdb.cairo.ColumnType;\n+import io.questdb.std.IntHashSet;\n+import io.questdb.std.IntIntHashMap;\n+import io.questdb.std.IntList;\n+import io.questdb.std.IntObjHashMap;\n+\n+public class PGOids {\n+\n+    public static final int PG_VARCHAR = 1043;\n+    public static final int PG_TIMESTAMP = 1114;\n+    public static final int PG_TIMESTAMPZ = 1184;\n+    public static final int PG_FLOAT8 = 701;\n+    public static final int PG_FLOAT4 = 700;\n+    public static final int PG_INT4 = 23;\n+    public static final int PG_INT2 = 21;\n+    public static final int PG_INT8 = 20;\n+    public static final int PG_NUMERIC = 1700;\n+    public static final int PG_BOOL = 16;\n+    public static final int PG_CHAR = 18;\n+    public static final int PG_DATE = 1082;\n+    public static final int PG_BYTEA = 17;\n+    public static final int PG_UNSPECIFIED = 0;\n+    public static final IntList TYPE_OIDS = new IntList();\n+    public static final IntHashSet PG_TYPE_OIDS = new IntHashSet();\n+    public static final IntIntHashMap PG_TYPE_TO_INTERNAL_TYPE_MAP = new IntIntHashMap();\n+    public static final IntObjHashMap<CharSequence> PG_TYPE_TO_NAME = new IntObjHashMap<>();\n+\n+    static {\n+        TYPE_OIDS.extendAndSet(ColumnType.STRING, PG_VARCHAR); // VARCHAR\n+        TYPE_OIDS.extendAndSet(ColumnType.TIMESTAMP, PG_TIMESTAMP); // TIMESTAMP\n+        TYPE_OIDS.extendAndSet(ColumnType.DOUBLE, PG_FLOAT8); // FLOAT8\n+        TYPE_OIDS.extendAndSet(ColumnType.FLOAT, PG_FLOAT4); // FLOAT4\n+        TYPE_OIDS.extendAndSet(ColumnType.INT, PG_INT4); // INT4\n+        TYPE_OIDS.extendAndSet(ColumnType.SHORT, PG_INT2); // INT2\n+        TYPE_OIDS.extendAndSet(ColumnType.CHAR, PG_CHAR);\n+        TYPE_OIDS.extendAndSet(ColumnType.SYMBOL, PG_VARCHAR); // NAME\n+        TYPE_OIDS.extendAndSet(ColumnType.LONG, PG_INT8); // INT8\n+        TYPE_OIDS.extendAndSet(ColumnType.BYTE, PG_INT2); // INT2\n+        TYPE_OIDS.extendAndSet(ColumnType.BOOLEAN, PG_BOOL); // BOOL\n+        TYPE_OIDS.extendAndSet(ColumnType.DATE, PG_TIMESTAMP); // DATE\n+        TYPE_OIDS.extendAndSet(ColumnType.BINARY, PG_BYTEA); // BYTEA\n+        TYPE_OIDS.extendAndSet(ColumnType.LONG256, PG_NUMERIC); // NUMERIC\n+\n+        for (int i = 0, n = TYPE_OIDS.size(); i < n; i++) {\n+            PG_TYPE_OIDS.add(TYPE_OIDS.getQuick(i));", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDAzODY4Nw==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524038687", "bodyText": "close fd once at the end", "author": "bluestreak01", "createdAt": "2020-11-16T09:44:00Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttrDefCatalogueFunctionFactory.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.catalogue;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.FunctionFactory;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.griffin.engine.functions.CursorFunction;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.NativeLPSZ;\n+import io.questdb.std.str.Path;\n+\n+public class AttrDefCatalogueFunctionFactory implements FunctionFactory {\n+\n+    private static final Log LOG = LogFactory.getLog(DescriptionCatalogueFunctionFactory.class);\n+    static final RecordMetadata METADATA;\n+\n+    @Override\n+    public String getSignature() {\n+        return \"pg_catalog.pg_attrdef()\";\n+    }\n+\n+    public Function newInstance(ObjList<Function> args, int position, CairoConfiguration configuration) {\n+        return new CursorFunction(\n+                position,\n+                new AttrDefCatalogueCursorFactory(configuration, METADATA)\n+        );\n+    }\n+\n+    private static class AttrDefCatalogueCursorFactory extends AbstractRecordCursorFactory {\n+\n+        private final Path path = new Path();\n+        private final AttrDefCatalogueCursor cursor;\n+        private final long tempMem;\n+\n+        public AttrDefCatalogueCursorFactory(CairoConfiguration configuration, RecordMetadata metadata) {\n+            super(metadata);\n+            this.tempMem = Unsafe.malloc(Integer.BYTES);\n+            this.cursor = new AttrDefCatalogueCursor(configuration, path, tempMem);\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(path);\n+            Unsafe.free(tempMem, Integer.BYTES);\n+        }\n+\n+        @Override\n+        public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+            cursor.toTop();\n+            return cursor;\n+        }\n+\n+        @Override\n+        public boolean recordCursorSupportsRandomAccess() {\n+            return false;\n+        }\n+    }\n+\n+    private static class AttrDefCatalogueCursor implements NoRandomAccessRecordCursor {\n+        private final Path path;\n+        private final FilesFacade ff;\n+        private final AttrDefCatalogueCursor.DiskReadingRecord diskReadingRecord = new AttrDefCatalogueCursor.DiskReadingRecord();\n+        private final NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        private final int plimit;\n+        private final int[] intValues = new int[4];\n+        private final long tempMem;\n+        private long findFileStruct = 0;\n+        private int columnIndex = 0;\n+        private boolean readNextFileFromDisk = true;\n+        private int columnCount;\n+        private boolean hasNextFile = true;\n+        private boolean foundMetadataFile = false;\n+\n+        public AttrDefCatalogueCursor(CairoConfiguration configuration, Path path, long tempMem) {\n+            this.ff = configuration.getFilesFacade();\n+            this.path = path;\n+            this.path.of(configuration.getRoot()).$();\n+            this.plimit = this.path.length();\n+            this.tempMem = tempMem;\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return diskReadingRecord;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (findFileStruct == 0) {\n+                findFileStruct = ff.findFirst(path.trimTo(plimit).$());\n+                if (findFileStruct > 0) {\n+                    return next0();\n+                }\n+\n+                findFileStruct = 0;\n+                return false;\n+            }\n+\n+            return next0();\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+        }\n+\n+        @Override\n+        public long size() {\n+            return -1;\n+        }\n+\n+        private boolean next0() {\n+            do {\n+                if (readNextFileFromDisk) {\n+                    foundMetadataFile = false;\n+                    final long pname = ff.findName(findFileStruct);\n+                    if (hasNextFile) {\n+                        nativeLPSZ.of(pname);\n+                        if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n+                            path.trimTo(plimit);\n+                            if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n+                                long fd = ff.openRO(path);\n+                                if (fd > -1) {\n+                                    if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n+                                        intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n+                                        if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_COUNT) == Integer.BYTES) {\n+                                            foundMetadataFile = true;\n+                                            columnCount = Unsafe.getUnsafe().getInt(tempMem);\n+                                            ff.close(fd);\n+                                        } else {\n+                                            LOG.error().$(\"Could not read column count [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                            ff.close(fd);\n+                                        }\n+                                    } else {\n+                                        LOG.error().$(\"Could not read table id [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                        ff.close(fd);", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MTkxNw==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524041917", "bodyText": "remove array, only one int column is present", "author": "bluestreak01", "createdAt": "2020-11-16T09:46:58Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttrDefCatalogueFunctionFactory.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.catalogue;\n+\n+import io.questdb.cairo.*;\n+import io.questdb.cairo.sql.*;\n+import io.questdb.griffin.FunctionFactory;\n+import io.questdb.griffin.SqlExecutionContext;\n+import io.questdb.griffin.engine.functions.CursorFunction;\n+import io.questdb.log.Log;\n+import io.questdb.log.LogFactory;\n+import io.questdb.std.*;\n+import io.questdb.std.str.NativeLPSZ;\n+import io.questdb.std.str.Path;\n+\n+public class AttrDefCatalogueFunctionFactory implements FunctionFactory {\n+\n+    private static final Log LOG = LogFactory.getLog(DescriptionCatalogueFunctionFactory.class);\n+    static final RecordMetadata METADATA;\n+\n+    @Override\n+    public String getSignature() {\n+        return \"pg_catalog.pg_attrdef()\";\n+    }\n+\n+    public Function newInstance(ObjList<Function> args, int position, CairoConfiguration configuration) {\n+        return new CursorFunction(\n+                position,\n+                new AttrDefCatalogueCursorFactory(configuration, METADATA)\n+        );\n+    }\n+\n+    private static class AttrDefCatalogueCursorFactory extends AbstractRecordCursorFactory {\n+\n+        private final Path path = new Path();\n+        private final AttrDefCatalogueCursor cursor;\n+        private final long tempMem;\n+\n+        public AttrDefCatalogueCursorFactory(CairoConfiguration configuration, RecordMetadata metadata) {\n+            super(metadata);\n+            this.tempMem = Unsafe.malloc(Integer.BYTES);\n+            this.cursor = new AttrDefCatalogueCursor(configuration, path, tempMem);\n+        }\n+\n+        @Override\n+        public void close() {\n+            Misc.free(path);\n+            Unsafe.free(tempMem, Integer.BYTES);\n+        }\n+\n+        @Override\n+        public RecordCursor getCursor(SqlExecutionContext executionContext) {\n+            cursor.toTop();\n+            return cursor;\n+        }\n+\n+        @Override\n+        public boolean recordCursorSupportsRandomAccess() {\n+            return false;\n+        }\n+    }\n+\n+    private static class AttrDefCatalogueCursor implements NoRandomAccessRecordCursor {\n+        private final Path path;\n+        private final FilesFacade ff;\n+        private final AttrDefCatalogueCursor.DiskReadingRecord diskReadingRecord = new AttrDefCatalogueCursor.DiskReadingRecord();\n+        private final NativeLPSZ nativeLPSZ = new NativeLPSZ();\n+        private final int plimit;\n+        private final int[] intValues = new int[4];\n+        private final long tempMem;\n+        private long findFileStruct = 0;\n+        private int columnIndex = 0;\n+        private boolean readNextFileFromDisk = true;\n+        private int columnCount;\n+        private boolean hasNextFile = true;\n+        private boolean foundMetadataFile = false;\n+\n+        public AttrDefCatalogueCursor(CairoConfiguration configuration, Path path, long tempMem) {\n+            this.ff = configuration.getFilesFacade();\n+            this.path = path;\n+            this.path.of(configuration.getRoot()).$();\n+            this.plimit = this.path.length();\n+            this.tempMem = tempMem;\n+        }\n+\n+        @Override\n+        public void close() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+        }\n+\n+        @Override\n+        public Record getRecord() {\n+            return diskReadingRecord;\n+        }\n+\n+        @Override\n+        public boolean hasNext() {\n+            if (findFileStruct == 0) {\n+                findFileStruct = ff.findFirst(path.trimTo(plimit).$());\n+                if (findFileStruct > 0) {\n+                    return next0();\n+                }\n+\n+                findFileStruct = 0;\n+                return false;\n+            }\n+\n+            return next0();\n+        }\n+\n+        @Override\n+        public void toTop() {\n+            if (findFileStruct != 0) {\n+                ff.findClose(findFileStruct);\n+                findFileStruct = 0;\n+            }\n+        }\n+\n+        @Override\n+        public long size() {\n+            return -1;\n+        }\n+\n+        private boolean next0() {\n+            do {\n+                if (readNextFileFromDisk) {\n+                    foundMetadataFile = false;\n+                    final long pname = ff.findName(findFileStruct);\n+                    if (hasNextFile) {\n+                        nativeLPSZ.of(pname);\n+                        if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n+                            path.trimTo(plimit);\n+                            if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n+                                long fd = ff.openRO(path);\n+                                if (fd > -1) {\n+                                    if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n+                                        intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n+                                        if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_COUNT) == Integer.BYTES) {\n+                                            foundMetadataFile = true;\n+                                            columnCount = Unsafe.getUnsafe().getInt(tempMem);\n+                                            ff.close(fd);\n+                                        } else {\n+                                            LOG.error().$(\"Could not read column count [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                            ff.close(fd);\n+                                        }\n+                                    } else {\n+                                        LOG.error().$(\"Could not read table id [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                        ff.close(fd);\n+                                    }\n+                                } else {\n+                                    LOG.error().$(\"could not read metadata [file=\").$(path).$(']').$();\n+                                }\n+                            }\n+                        }\n+                        hasNextFile = ff.findNext(findFileStruct) > 0;\n+                    }\n+                }\n+\n+                if (foundMetadataFile) {\n+                    for (int i = 0; i < columnCount; i++) {\n+                        if (columnIndex == i) {\n+                            diskReadingRecord.columnNumber = (short) (i + 1);\n+                            columnIndex++;\n+                            if (columnIndex == columnCount) {\n+                                readNextFileFromDisk = true;\n+                                columnIndex = 0;\n+                            } else {\n+                                readNextFileFromDisk = false;\n+                            }\n+                            return true;\n+                        }\n+                    }\n+                }\n+            } while (hasNextFile);\n+\n+            ff.findClose(findFileStruct);\n+            findFileStruct = 0;\n+            hasNextFile = true;\n+            foundMetadataFile = false;\n+            intValues[0] = -1;\n+            return false;\n+        }\n+\n+        private class DiskReadingRecord implements Record {\n+\n+            public short columnNumber = 0;\n+\n+            @Override\n+            public int getInt(int col) {\n+                return intValues[col];", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0MzYxMQ==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524043611", "bodyText": "use sparse arrays like shortValues, populate in next() and dereference using column index", "author": "bluestreak01", "createdAt": "2020-11-16T09:48:29Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -203,15 +207,16 @@ private boolean next0() {\n             public CharSequence name = null;\n             public short columnNumber = 0;\n             public int tableId = 0;\n+            public int type = -1;\n \n             @Override\n             public short getShort(int col) {\n-                return columnNumber;\n+                return col == 2 ? columnNumber : col == 6 ? getTypeSize() : 0;", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0Mzg2Mw==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524043863", "bodyText": "same, use sparse arrays", "author": "bluestreak01", "createdAt": "2020-11-16T09:48:41Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -203,15 +207,16 @@ private boolean next0() {\n             public CharSequence name = null;\n             public short columnNumber = 0;\n             public int tableId = 0;\n+            public int type = -1;\n \n             @Override\n             public short getShort(int col) {\n-                return columnNumber;\n+                return col == 2 ? columnNumber : col == 6 ? getTypeSize() : 0;\n             }\n \n             @Override\n             public int getInt(int col) {\n-                return tableId;\n+                return col == 0 ? tableId : col == 3 ? type : 0;", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NjEyNQ==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524046125", "bodyText": "lets investigate what PG expects for attidentity. Character.MIN_VALUE is not the same as null", "author": "bluestreak01", "createdAt": "2020-11-16T09:50:36Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -224,10 +229,25 @@ public CharSequence getStrB(int col) {\n                 return name;\n             }\n \n+            @Override\n+            public boolean getBool(int col) {\n+                return false;\n+            }\n+\n+            @Override\n+            public char getChar(int col) {\n+                return Character.MIN_VALUE;", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0Njg5Nw==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524046897", "bodyText": "try 0", "author": "bluestreak01", "createdAt": "2020-11-16T09:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NjEyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NzgwOQ==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524047809", "bodyText": "or add a comment on what this means", "author": "bluestreak01", "createdAt": "2020-11-16T09:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA0NjEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1MjQ1Mg==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524052452", "bodyText": "PG_TYPE_TO_INTERNAL_TYPE_MAP is not used for anything other than working out size of type. Change the data structure to provide size right away without call to sizeof() and if", "author": "bluestreak01", "createdAt": "2020-11-16T09:56:01Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/AttributeCatalogueFunctionFactory.java", "diffHunk": "@@ -224,10 +229,25 @@ public CharSequence getStrB(int col) {\n                 return name;\n             }\n \n+            @Override\n+            public boolean getBool(int col) {\n+                return false;\n+            }\n+\n+            @Override\n+            public char getChar(int col) {\n+                return Character.MIN_VALUE;\n+            }\n+\n             @Override\n             public int getStrLen(int col) {\n                 return getStr(col).length();\n             }\n+\n+            private short getTypeSize() {\n+                short size = (short) ColumnType.sizeOf(PG_TYPE_TO_INTERNAL_TYPE_MAP.get(type));", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1NDI1NQ==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524054255", "bodyText": "ff.close(fd) is same as above", "author": "bluestreak01", "createdAt": "2020-11-16T09:57:31Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/DescriptionCatalogueFunctionFactory.java", "diffHunk": "@@ -156,46 +158,86 @@ public long size() {\n \n         private boolean next0() {\n             do {\n-                final long pname = ff.findName(findFileStruct);\n-                nativeLPSZ.of(pname);\n-                if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n-                    path.trimTo(plimit);\n-                    if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n-                        // open metadata file and read id\n-                        long fd = ff.openRO(path);\n-                        if (fd > -1) {\n-                            if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n-                                intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n-                                ff.close(fd);\n-                                return true;\n+                if (readNextFileFromDisk) {\n+                    foundMetadataFile = false;\n+                    final long pname = ff.findName(findFileStruct);\n+                    if (hasNextFile) {\n+                        nativeLPSZ.of(pname);\n+                        if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n+                            path.trimTo(plimit);\n+                            if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n+                                long fd = ff.openRO(path);\n+                                if (fd > -1) {\n+                                    if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n+                                        intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n+                                        if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_COUNT) == Integer.BYTES) {\n+                                            foundMetadataFile = true;\n+                                            columnCount = Unsafe.getUnsafe().getInt(tempMem);\n+                                            diskReadingRecord.columnNumber = 0;\n+                                            ff.close(fd);\n+                                        } else {\n+                                            LOG.error().$(\"Could not read column count [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                            ff.close(fd);\n+                                        }\n+                                    } else {\n+                                        LOG.error().$(\"Could not read table id [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                        ff.close(fd);", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA1NjUwOQ==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524056509", "bodyText": "add a comment", "author": "bluestreak01", "createdAt": "2020-11-16T09:59:28Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/DescriptionCatalogueFunctionFactory.java", "diffHunk": "@@ -214,7 +256,7 @@ public int getStrLen(int col) {\n         final GenericRecordMetadata metadata = new GenericRecordMetadata();\n         metadata.add(new TableColumnMetadata(\"objoid\", ColumnType.INT, null));\n         metadata.add(new TableColumnMetadata(\"classoid\", ColumnType.INT, null));\n-        metadata.add(new TableColumnMetadata(\"objsubid\", ColumnType.INT, null));\n+        metadata.add(new TableColumnMetadata(\"objsubid\", ColumnType.SHORT, null));", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2MDExNw==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524060117", "bodyText": "use sparse array", "author": "bluestreak01", "createdAt": "2020-11-16T10:02:38Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/DescriptionCatalogueFunctionFactory.java", "diffHunk": "@@ -156,46 +158,86 @@ public long size() {\n \n         private boolean next0() {\n             do {\n-                final long pname = ff.findName(findFileStruct);\n-                nativeLPSZ.of(pname);\n-                if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n-                    path.trimTo(plimit);\n-                    if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n-                        // open metadata file and read id\n-                        long fd = ff.openRO(path);\n-                        if (fd > -1) {\n-                            if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n-                                intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n-                                ff.close(fd);\n-                                return true;\n+                if (readNextFileFromDisk) {\n+                    foundMetadataFile = false;\n+                    final long pname = ff.findName(findFileStruct);\n+                    if (hasNextFile) {\n+                        nativeLPSZ.of(pname);\n+                        if (ff.findType(findFileStruct) == Files.DT_DIR && Chars.notDots(nativeLPSZ)) {\n+                            path.trimTo(plimit);\n+                            if (ff.exists(path.concat(pname).concat(TableUtils.META_FILE_NAME).$())) {\n+                                long fd = ff.openRO(path);\n+                                if (fd > -1) {\n+                                    if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_TABLE_ID) == Integer.BYTES) {\n+                                        intValues[0] = Unsafe.getUnsafe().getInt(tempMem);\n+                                        if (ff.read(fd, tempMem, Integer.BYTES, TableUtils.META_OFFSET_COUNT) == Integer.BYTES) {\n+                                            foundMetadataFile = true;\n+                                            columnCount = Unsafe.getUnsafe().getInt(tempMem);\n+                                            diskReadingRecord.columnNumber = 0;\n+                                            ff.close(fd);\n+                                        } else {\n+                                            LOG.error().$(\"Could not read column count [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                            ff.close(fd);\n+                                        }\n+                                    } else {\n+                                        LOG.error().$(\"Could not read table id [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n+                                        ff.close(fd);\n+                                    }\n+                                } else {\n+                                    LOG.error().$(\"could not read metadata [file=\").$(path).$(']').$();\n+                                }\n                             }\n-                            LOG.error().$(\"Could not read table id [fd=\").$(fd).$(\", errno=\").$(ff.errno()).$(']').$();\n-                            ff.close(fd);\n-                        } else {\n-                            LOG.error().$(\"could not read metadata [file=\").$(path).$(']').$();\n                         }\n-                        intValues[0] = -1;\n-                        return true;\n+                        hasNextFile = ff.findNext(findFileStruct) > 0;\n+                        if (foundMetadataFile) {\n+                            readNextFileFromDisk = false;\n+                            return true;\n+                        }\n                     }\n                 }\n-            } while (ff.findNext(findFileStruct) > 0);\n+\n+                if (foundMetadataFile) {\n+                    for (int i = 0; i < columnCount + 1; i++) {\n+                        if (columnIndex == i) {\n+                            diskReadingRecord.columnNumber = (short) (i + 1);\n+                            columnIndex++;\n+                            if (columnIndex == columnCount) {\n+                                readNextFileFromDisk = true;\n+                                columnIndex = 0;\n+                            } else {\n+                                readNextFileFromDisk = false;\n+                            }\n+                            return true;\n+                        }\n+                    }\n+                }\n+            } while (hasNextFile);\n \n             ff.findClose(findFileStruct);\n             findFileStruct = 0;\n+            hasNextFile = true;\n+            foundMetadataFile = false;\n+            intValues[0] = -1;\n             return false;\n         }\n \n         private class DiskReadingRecord implements Record {\n \n+            public short columnNumber = 0;\n \n             @Override\n             public int getInt(int col) {\n                 return intValues[col];\n             }\n \n+            @Override\n+            public short getShort(int col) {\n+                return columnNumber;\n+            }\n+\n             @Override\n             public CharSequence getStr(int col) {\n-                return \"table\";\n+                return columnNumber == 0 ? \"table\" : \"column\";", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2MTUzOQ==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524061539", "bodyText": "check if base type does the same and remove if duplicate", "author": "bluestreak01", "createdAt": "2020-11-16T10:03:58Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/PrefixedTypeCatalogueFunctionFactory.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.griffin.engine.functions.catalogue;\n+\n+import io.questdb.cairo.CairoConfiguration;\n+import io.questdb.cairo.sql.Function;\n+import io.questdb.griffin.engine.functions.CursorFunction;\n+import io.questdb.griffin.engine.functions.GenericRecordCursorFactory;\n+import io.questdb.std.ObjList;\n+\n+public class PrefixedTypeCatalogueFunctionFactory extends TypeCatalogueFunctionFactory {\n+\n+    @Override\n+    public String getSignature() {\n+        return \"pg_catalog.pg_type()\";\n+    }\n+\n+    @Override\n+    public Function newInstance(ObjList<Function> args, int position, CairoConfiguration configuration) {", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2MjMwMQ==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524062301", "bodyText": "use sparse array", "author": "bluestreak01", "createdAt": "2020-11-16T10:04:41Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/TypeCatalogueCursor.java", "diffHunk": "@@ -69,28 +62,51 @@ public void toTop() {\n \n     @Override\n     public long size() {\n-        return 1;\n+        return rowCount;\n     }\n \n-    private class DescriptionCatalogueRecord implements Record {\n-\n+    private class TypeCatalogueRecord implements Record {\n         @Override\n         public int getInt(int col) {\n-            return intColumns[col][row];\n+            return col == 0 ? PG_TYPE_OIDS.get(row) : col == 4 ? PgOIDs.PG_PUBLIC_OID : 0;", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2NTA3NA==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524065074", "bodyText": "PG_TYPE_TO_NAME should be an array (dense)", "author": "bluestreak01", "createdAt": "2020-11-16T10:07:15Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/TypeCatalogueCursor.java", "diffHunk": "@@ -69,28 +62,51 @@ public void toTop() {\n \n     @Override\n     public long size() {\n-        return 1;\n+        return rowCount;\n     }\n \n-    private class DescriptionCatalogueRecord implements Record {\n-\n+    private class TypeCatalogueRecord implements Record {\n         @Override\n         public int getInt(int col) {\n-            return intColumns[col][row];\n+            return col == 0 ? PG_TYPE_OIDS.get(row) : col == 4 ? PgOIDs.PG_PUBLIC_OID : 0;\n         }\n \n         @Override\n         public CharSequence getStr(int col) {\n-            return descriptions[row];\n+            return PG_TYPE_TO_NAME.get(PG_TYPE_OIDS.get(row));", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDA2NzQ5NA==", "url": "https://github.com/questdb/questdb/pull/697#discussion_r524067494", "bodyText": "check if this factory overrides isCursor()\nisCursor must return true for all factories that return cursor instance", "author": "bluestreak01", "createdAt": "2020-11-16T10:09:24Z", "path": "core/src/main/java/io/questdb/griffin/engine/functions/catalogue/TypeCatalogueFunctionFactory.java", "diffHunk": "@@ -24,32 +24,15 @@\n \n package io.questdb.griffin.engine.functions.catalogue;\n \n-import io.questdb.cairo.*;\n+import io.questdb.cairo.CairoConfiguration;\n import io.questdb.cairo.sql.Function;\n-import io.questdb.cairo.sql.RecordCursor;\n-import io.questdb.cairo.sql.RecordMetadata;\n import io.questdb.griffin.FunctionFactory;\n-import io.questdb.griffin.SqlExecutionContext;\n-import io.questdb.griffin.engine.EmptyTableRecordCursor;\n import io.questdb.griffin.engine.functions.CursorFunction;\n-import io.questdb.std.Misc;\n+import io.questdb.griffin.engine.functions.GenericRecordCursorFactory;\n import io.questdb.std.ObjList;\n-import io.questdb.std.str.Path;\n \n public class TypeCatalogueFunctionFactory implements FunctionFactory {", "originalCommit": "a45677dd8ce5e74bd9d6fe9e45d4d1b7468e0389", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c496d1ac11b155f78ec8a55c22a076ff8b9a2ae", "url": "https://github.com/questdb/questdb/commit/5c496d1ac11b155f78ec8a55c22a076ff8b9a2ae", "message": "chore(griffin) - kafka metadata functions: tidy up", "committedDate": "2020-11-16T13:20:19Z", "type": "commit"}, {"oid": "4062a317916036d7e250801f2c624e08367c8c68", "url": "https://github.com/questdb/questdb/commit/4062a317916036d7e250801f2c624e08367c8c68", "message": "chore(griffin) - kafka metadata functions: added assertion", "committedDate": "2020-11-16T17:38:12Z", "type": "commit"}]}