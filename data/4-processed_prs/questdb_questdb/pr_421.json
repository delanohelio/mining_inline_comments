{"pr_number": 421, "pr_title": "Wait on writer locks when processing json requests", "pr_createdAt": "2020-06-22T08:55:41Z", "pr_url": "https://github.com/questdb/questdb/pull/421", "timeline": [{"oid": "6529d578e1b27531f4aa64e32d133984f8b86d90", "url": "https://github.com/questdb/questdb/commit/6529d578e1b27531f4aa64e32d133984f8b86d90", "message": "Naive implementation of wait and resume of inserts", "committedDate": "2020-06-17T23:41:53Z", "type": "commit"}, {"oid": "0ee03ffd304aa42883f856d7d60f4221158b8d69", "url": "https://github.com/questdb/questdb/commit/0ee03ffd304aa42883f856d7d60f4221158b8d69", "message": "Fix re usage of JsonQueryProcessor in HttpRequestProcessor on retries", "committedDate": "2020-06-18T22:25:16Z", "type": "commit"}, {"oid": "9b90693af3e36ee789e9818011eef1a4e46280c5", "url": "https://github.com/questdb/questdb/commit/9b90693af3e36ee789e9818011eef1a4e46280c5", "message": "Create WaitProcessor to reschedule retries.", "committedDate": "2020-06-21T00:25:26Z", "type": "commit"}, {"oid": "87c1635129d690102fb026fc389c53f4adebb4d6", "url": "https://github.com/questdb/questdb/commit/87c1635129d690102fb026fc389c53f4adebb4d6", "message": "Cleanup. Use RetryOperationException instead EntryUnavailableException to schedule a retry.", "committedDate": "2020-06-21T00:36:03Z", "type": "commit"}, {"oid": "ae84ee89db0afdeaaa287e5166c61c9f0dbe912f", "url": "https://github.com/questdb/questdb/commit/ae84ee89db0afdeaaa287e5166c61c9f0dbe912f", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/PropServerConfiguration.java", "committedDate": "2020-06-22T09:41:55Z", "type": "commit"}, {"oid": "be52bfbe89a716e89b462fd62fd92a753bde878c", "url": "https://github.com/questdb/questdb/commit/be52bfbe89a716e89b462fd62fd92a753bde878c", "message": "Refactoring / cleanup - remove unnecessary EmptyRescheduleContext", "committedDate": "2020-06-22T09:48:12Z", "type": "commit"}, {"oid": "bc1fa1a0fda9dea48bd0a64fac0fa565f8c01f64", "url": "https://github.com/questdb/questdb/commit/bc1fa1a0fda9dea48bd0a64fac0fa565f8c01f64", "message": "Multipart import retry", "committedDate": "2020-06-28T23:17:40Z", "type": "commit"}, {"oid": "40f0217ee279279cd7c3fa50abc2de96dd1506f9", "url": "https://github.com/questdb/questdb/commit/40f0217ee279279cd7c3fa50abc2de96dd1506f9", "message": "Fix double quote in query parsing", "committedDate": "2020-06-29T00:03:09Z", "type": "commit"}, {"oid": "d145b4cc4e15fadd5bcee65ad718d4070623849e", "url": "https://github.com/questdb/questdb/commit/d145b4cc4e15fadd5bcee65ad718d4070623849e", "message": "More tests on concurrent import.", "committedDate": "2020-06-29T09:52:24Z", "type": "commit"}, {"oid": "5078a7a1651e45e5daa6942f8b791c1c91f20982", "url": "https://github.com/questdb/questdb/commit/5078a7a1651e45e5daa6942f8b791c1c91f20982", "message": "Fix multipart import retry concurrent failure", "committedDate": "2020-06-30T23:33:09Z", "type": "commit"}, {"oid": "ee81c5874af60ab0a5109bda8ffd10bb66791780", "url": "https://github.com/questdb/questdb/commit/ee81c5874af60ab0a5109bda8ffd10bb66791780", "message": "Remove excessive logging, restore refactored test to working version", "committedDate": "2020-06-30T23:55:56Z", "type": "commit"}, {"oid": "8572d548c771383aa95fface1aa21da2e73ac3f0", "url": "https://github.com/questdb/questdb/commit/8572d548c771383aa95fface1aa21da2e73ac3f0", "message": "Better code formatting", "committedDate": "2020-07-01T11:09:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5OTc4NA==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448299784", "bodyText": "don't yield - just go for it right away", "author": "bluestreak01", "createdAt": "2020-07-01T11:30:14Z", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(JobRunner pool, WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+\n+        if (pool.getWorkerCount() > 0) {\n+            int workerId = pool.getWorkerCount() - 1; // Last one lucky.\n+            pool.assign(workerId, workerId1 -> processInQueue() || sendToOutQueue());\n+        }\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    public void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                RetryHolder retryHolder = inQueue.get(cursor);\n+                retryHolder.retry = retry;\n+                retryHolder.attempt = attempt;\n+                retryHolder.lastRunTimestamp = now;\n+                retryHolder.waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+                return;\n+            } finally {\n+                inPubSequence.done(cursor);\n+            }\n+        }\n+    }\n+\n+    // This hijacks http execution thread / job and runs retries in it.\n+    public boolean runReruns(HttpRequestProcessorSelector selector) {\n+        boolean useful = false;\n+        long now = 0;\n+\n+        while (true) {\n+            RetryHolder retryHolder = getNextRerun();\n+            if (retryHolder != null) {\n+                useful = true;\n+                if (!retryHolder.retry.tryRerun(selector)) {\n+                    // Need more attempts\n+                    reschedule(retryHolder.retry, retryHolder.attempt + 1, retryHolder.waitStartTimestamp);\n+                }\n+            } else {\n+                return useful;\n+            }\n+        }\n+    }\n+\n+    private @Nullable RetryHolder getNextRerun() {\n+        long cursor = outSubSequence.next();\n+        // -2 = there was a contest for queue index and this thread has lost\n+        if (cursor < 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return outQueue.get(cursor);\n+        } finally {\n+            outSubSequence.done(cursor);\n+        }\n+    }\n+\n+    // Process incoming queue and put it on priority queue with next timestamp to rerun\n+    private boolean processInQueue() {\n+        while (true) {\n+            long cursor = inSubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);", "originalCommit": "8572d548c771383aa95fface1aa21da2e73ac3f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjI3NQ==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448662275", "bodyText": "Done", "author": "ideoma", "createdAt": "2020-07-01T23:12:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI5OTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxOTcwNg==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448319706", "bodyText": "It feels that this class should be a job?", "author": "bluestreak01", "createdAt": "2020-07-01T12:11:32Z", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {", "originalCommit": "8572d548c771383aa95fface1aa21da2e73ac3f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjM5MA==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448662390", "bodyText": "Made it SynchronizedJob", "author": "ideoma", "createdAt": "2020-07-01T23:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxOTcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTI0Mw==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448321243", "bodyText": "why can't we use ObjArrayDequeue directly?", "author": "bluestreak01", "createdAt": "2020-07-01T12:14:54Z", "path": "core/src/main/java/io/questdb/std/ObjQueue.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.std;\n+\n+public class ObjQueue<T> implements Mutable {", "originalCommit": "8572d548c771383aa95fface1aa21da2e73ac3f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjYzMQ==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448662631", "bodyText": "Removed changes to ObjStack and removed ObjQueue since I didn't use it at the end. Left new tests on ObjStack only", "author": "ideoma", "createdAt": "2020-07-01T23:13:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTUyNQ==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448321525", "bodyText": "Same here, we need to have second delegate that doesn't seem to add any value.", "author": "bluestreak01", "createdAt": "2020-07-01T12:15:26Z", "path": "core/src/main/java/io/questdb/std/ObjStack.java", "diffHunk": "@@ -24,93 +24,46 @@\n \n package io.questdb.std;\n \n-import java.util.Arrays;\n-\n public class ObjStack<T> implements Mutable {\n-    private static final int MIN_INITIAL_CAPACITY = 8;\n-    private static final int DEFAULT_INITIAL_CAPACITY = 16;\n-    private T[] elements;\n-    private int head;\n-    private int tail;\n-    private int mask;\n+    private final ObjArrayDequeue<T> dequeue;\n \n     public ObjStack() {\n-        this(DEFAULT_INITIAL_CAPACITY);\n+        dequeue = new ObjArrayDequeue<>();\n     }\n \n     public ObjStack(int initialCapacity) {\n-        allocateElements(initialCapacity);\n+        dequeue = new ObjArrayDequeue<>(initialCapacity);\n     }\n \n     public void clear() {\n-        if (head != tail) {\n-            head = tail = 0;\n-            Arrays.fill(elements, null);\n-        }\n+        dequeue.clear();\n     }\n \n     public boolean notEmpty() {\n-        return head != tail;\n+        return dequeue.notEmpty();\n     }\n \n     public T peek() {\n-        return elements[head];\n+        return dequeue.peekLast();\n     }\n \n     public T peek(int n) {\n-        return elements[(head + n) & mask];\n+        return dequeue.peekLast(n);", "originalCommit": "8572d548c771383aa95fface1aa21da2e73ac3f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjY5Mw==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448662693", "bodyText": "Reverted", "author": "ideoma", "createdAt": "2020-07-01T23:13:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMTUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMzAyNQ==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448323025", "bodyText": "why don't we have these attributes on the context itself and not use holder? This way we don't really need to create objects for retries?", "author": "bluestreak01", "createdAt": "2020-07-01T12:18:26Z", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(JobRunner pool, WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+\n+        if (pool.getWorkerCount() > 0) {\n+            int workerId = pool.getWorkerCount() - 1; // Last one lucky.\n+            pool.assign(workerId, workerId1 -> processInQueue() || sendToOutQueue());\n+        }\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    public void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                LockSupport.parkNanos(1);\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                RetryHolder retryHolder = inQueue.get(cursor);\n+                retryHolder.retry = retry;\n+                retryHolder.attempt = attempt;", "originalCommit": "8572d548c771383aa95fface1aa21da2e73ac3f0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY2MjgxNw==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r448662817", "bodyText": "Done", "author": "ideoma", "createdAt": "2020-07-01T23:14:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMzAyNQ=="}], "type": "inlineReview"}, {"oid": "4f0e1e59d15d8a113f37a6542a3857ec005e190f", "url": "https://github.com/questdb/questdb/commit/4f0e1e59d15d8a113f37a6542a3857ec005e190f", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/cutlass/http/HttpConnectionContext.java\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java", "committedDate": "2020-07-01T12:25:22Z", "type": "commit"}, {"oid": "338ddc15ee8b6baf255e9968244ffa4c3bfdb5b5", "url": "https://github.com/questdb/questdb/commit/338ddc15ee8b6baf255e9968244ffa4c3bfdb5b5", "message": "PR feedback.\n- wait processor to be a job\n- retry parameters stored within retry-\n- reverted changes to ObjStack", "committedDate": "2020-07-01T23:11:50Z", "type": "commit"}, {"oid": "9c456f3f9f3782db3d11d95744a53a31f69e242b", "url": "https://github.com/questdb/questdb/commit/9c456f3f9f3782db3d11d95744a53a31f69e242b", "message": "Merge remote-tracking branch 'upstream/master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java", "committedDate": "2020-07-01T23:24:19Z", "type": "commit"}, {"oid": "0e683f743819e760b418b99d24696e3e38c6b065", "url": "https://github.com/questdb/questdb/commit/0e683f743819e760b418b99d24696e3e38c6b065", "message": "Merge remote-tracking branch 'upstream/master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java", "committedDate": "2020-07-01T23:27:34Z", "type": "commit"}, {"oid": "bbbc9c6887895362cf66c1c579deabb80d3789eb", "url": "https://github.com/questdb/questdb/commit/bbbc9c6887895362cf66c1c579deabb80d3789eb", "message": "Cleanup, file headers added, unused code deleted.", "committedDate": "2020-07-02T09:14:42Z", "type": "commit"}, {"oid": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "url": "https://github.com/questdb/questdb/commit/9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "message": "Do not restore state in HttpMultipartContentParser to the previous state when retry exception handled. Instead roll it over to next token to prepare to continue after processor successfully retried.", "committedDate": "2020-08-15T22:39:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3MzkyMQ==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471173921", "bodyText": "This is a race condition. done() releases slot, which can be written to right after done() and right before RetryHolder is retried. This can lead to unpredictable results.\nRetryHolder needs to be copied off before releasing queue slot", "author": "bluestreak01", "createdAt": "2020-08-16T23:38:53Z", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                inQueue.get(cursor).retry = retry;;\n+                return;\n+            } finally {\n+                inPubSequence.done(cursor);\n+            }\n+        }\n+    }\n+\n+    // This hijacks http execution thread / job and runs retries in it.\n+    public boolean runReruns(HttpRequestProcessorSelector selector) {\n+        boolean useful = false;\n+\n+        while (true) {\n+            RetryHolder retryHolder = getNextRerun();\n+            if (retryHolder != null) {\n+                useful = true;\n+                if (!retryHolder.retry.tryRerun(selector)) {\n+                    // Need more attempts\n+                    reschedule(retryHolder.retry, retryHolder.retry.getAttemptDetails().attempt + 1, retryHolder.retry.getAttemptDetails().waitStartTimestamp);\n+                }\n+            } else {\n+                return useful;\n+            }\n+        }\n+    }\n+\n+    private @Nullable RetryHolder getNextRerun() {\n+        long cursor = outSubSequence.next();\n+        // -2 = there was a contest for queue index and this thread has lost\n+        if (cursor < 0) {\n+            return null;\n+        }\n+\n+        try {\n+            return outQueue.get(cursor);\n+        } finally {\n+            outSubSequence.done(cursor);", "originalCommit": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDAyNQ==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174025", "bodyText": "perhaps RetryHolder is redundant here. Priority queue can take comparator.", "author": "bluestreak01", "createdAt": "2020-08-16T23:39:40Z", "path": "core/src/main/java/io/questdb/cutlass/http/RetryHolder.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import org.jetbrains.annotations.NotNull;\n+\n+public class RetryHolder implements Comparable<RetryHolder> {\n+    public Retry retry;\n+\n+    @Override\n+    public int compareTo(@NotNull RetryHolder o) {", "originalCommit": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDA4MA==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174080", "bodyText": "size of priority queue should be configurable", "author": "bluestreak01", "createdAt": "2020-08-16T23:40:06Z", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);", "originalCommit": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDEyMg==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174122", "bodyText": "this should also be configurable", "author": "bluestreak01", "createdAt": "2020-08-16T23:40:30Z", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;", "originalCommit": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDUyOA==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174528", "bodyText": "queue is full?", "author": "bluestreak01", "createdAt": "2020-08-16T23:44:18Z", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting", "originalCommit": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDk0Nw==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471174947", "bodyText": "Is this tested?\nI could be wrong here, but when this exception is thrown out of runReruns it would be not be handled at all?", "author": "bluestreak01", "createdAt": "2020-08-16T23:47:59Z", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;", "originalCommit": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NTAxOA==", "url": "https://github.com/questdb/questdb/pull/421#discussion_r471175018", "bodyText": "when queue is full exception out of this method looks unhandled", "author": "bluestreak01", "createdAt": "2020-08-16T23:48:39Z", "path": "core/src/main/java/io/questdb/cutlass/http/WaitProcessor.java", "diffHunk": "@@ -0,0 +1,211 @@\n+/*******************************************************************************\n+ *     ___                  _   ____  ____\n+ *    / _ \\ _   _  ___  ___| |_|  _ \\| __ )\n+ *   | | | | | | |/ _ \\/ __| __| | | |  _ \\\n+ *   | |_| | |_| |  __/\\__ \\ |_| |_| | |_) |\n+ *    \\__\\_\\\\__,_|\\___||___/\\__|____/|____/\n+ *\n+ *  Copyright (c) 2014-2019 Appsicle\n+ *  Copyright (c) 2019-2020 QuestDB\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\n+ ******************************************************************************/\n+\n+package io.questdb.cutlass.http;\n+\n+import io.questdb.cairo.pool.ex.EntryUnavailableException;\n+import io.questdb.mp.*;\n+import io.questdb.std.time.MillisecondClock;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.PriorityQueue;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class WaitProcessor extends  SynchronizedJob implements RescheduleContext {\n+\n+    private static final int retryQueueLength = 4096;\n+    private final RingQueue<RetryHolder> inQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence inPubSequence = new MPSequence(retryQueueLength);\n+    private final Sequence inSubSequence = new SCSequence();\n+    private final PriorityQueue<RetryHolder> nextRerun = new PriorityQueue<>(64);\n+    private final RingQueue<RetryHolder> outQueue = new RingQueue<>(RetryHolder::new, retryQueueLength);\n+    private final Sequence outPubSequence = new SPSequence(retryQueueLength);\n+    private final Sequence outSubSequence = new MCSequence(retryQueueLength);\n+    private final MillisecondClock clock;\n+    private final long maxWaitCapMs;\n+    private final double exponentialWaitMultiplier;\n+\n+    public WaitProcessor(WaitProcessorConfiguration configuration) {\n+        this.clock = configuration.getClock();\n+        this.maxWaitCapMs = configuration.getMaxWaitCapMs();\n+        this.exponentialWaitMultiplier = configuration.getExponentialWaitMultiplier();\n+\n+        inPubSequence.then(inSubSequence).then(inPubSequence);\n+        outPubSequence.then(outSubSequence).then(outPubSequence);\n+    }\n+\n+    @Override\n+    protected boolean runSerially() {\n+        return processInQueue() || sendToOutQueue();\n+    }\n+\n+    @Override\n+    // This supposed to run in http execution thread / job\n+    public void reschedule(Retry retry) {\n+        reschedule(retry, 0, 0);\n+    }\n+\n+    private void reschedule(Retry retry, int attempt, long waitStartMs) {\n+        long now = clock.getTicks();\n+        retry.getAttemptDetails().attempt = attempt;\n+        retry.getAttemptDetails().lastRunTimestamp = now;\n+        retry.getAttemptDetails().waitStartTimestamp = attempt == 0 ? now : waitStartMs;\n+\n+        while (true) {\n+            long cursor = inPubSequence.next();\n+            // -2 = there was a contest for queue index and this thread has lost\n+            if (cursor < -1) {\n+                continue;\n+            }\n+\n+            // -1 = queue is empty. It means there are already too many retries waiting\n+            // Send error to client.\n+            if (cursor < 0) {\n+                throw EntryUnavailableException.INSTANCE;\n+            }\n+\n+            try {\n+                inQueue.get(cursor).retry = retry;;\n+                return;\n+            } finally {\n+                inPubSequence.done(cursor);\n+            }\n+        }\n+    }\n+\n+    // This hijacks http execution thread / job and runs retries in it.\n+    public boolean runReruns(HttpRequestProcessorSelector selector) {\n+        boolean useful = false;\n+\n+        while (true) {\n+            RetryHolder retryHolder = getNextRerun();\n+            if (retryHolder != null) {\n+                useful = true;\n+                if (!retryHolder.retry.tryRerun(selector)) {", "originalCommit": "9325aa4c8f13a5bb96c8b6ddb494c6e2d06a81fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "07d73190d2383517dc906355e1d0903ed4e17ba5", "url": "https://github.com/questdb/questdb/commit/07d73190d2383517dc906355e1d0903ed4e17ba5", "message": "PR feedback fixes. Handling retry queues capacity exceeded situation.", "committedDate": "2020-08-26T23:00:28Z", "type": "commit"}, {"oid": "a1f1bcd3353521a2b8356a5d4f68e61fdcf3b7a4", "url": "https://github.com/questdb/questdb/commit/a1f1bcd3353521a2b8356a5d4f68e61fdcf3b7a4", "message": "Handling retry queues capacity exceeded situation in TextImportProcessor", "committedDate": "2020-08-26T23:29:38Z", "type": "commit"}, {"oid": "7fb4cd790af74b3828452bd90312a37aa72d5a48", "url": "https://github.com/questdb/questdb/commit/7fb4cd790af74b3828452bd90312a37aa72d5a48", "message": "Testing wait retry with PeerIsSlowToReadException", "committedDate": "2020-09-15T13:37:43Z", "type": "commit"}, {"oid": "b1d379f71ce969dba6b26e02aa62788d0fbc6373", "url": "https://github.com/questdb/questdb/commit/b1d379f71ce969dba6b26e02aa62788d0fbc6373", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/PropServerConfiguration.java\n#\tcore/src/main/java/io/questdb/cutlass/http/HttpConnectionContext.java\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java", "committedDate": "2020-09-17T21:55:43Z", "type": "commit"}, {"oid": "702416b2fb6345ecd51ff86db8fc6c442d4d1700", "url": "https://github.com/questdb/questdb/commit/702416b2fb6345ecd51ff86db8fc6c442d4d1700", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/PropServerConfiguration.java\n#\tcore/src/main/java/io/questdb/cutlass/http/HttpConnectionContext.java\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java", "committedDate": "2020-09-19T23:11:34Z", "type": "commit"}, {"oid": "e3e84e99044ebfaa2f36bf19dbdb80e26bcd3572", "url": "https://github.com/questdb/questdb/commit/e3e84e99044ebfaa2f36bf19dbdb80e26bcd3572", "message": "Making retries work after merge from master", "committedDate": "2020-09-22T15:01:09Z", "type": "commit"}, {"oid": "263d55a037af0edee9e4133bd865803e5dd6106d", "url": "https://github.com/questdb/questdb/commit/263d55a037af0edee9e4133bd865803e5dd6106d", "message": "Retry query tests with slow peer", "committedDate": "2020-09-29T17:11:41Z", "type": "commit"}, {"oid": "f745f86262ec57fdb4596294944fa481d8736cc9", "url": "https://github.com/questdb/questdb/commit/f745f86262ec57fdb4596294944fa481d8736cc9", "message": "Fix import failing when not enough lines read from client.\nFix errors on sending error back to slow client.", "committedDate": "2020-10-05T00:31:16Z", "type": "commit"}, {"oid": "11d31d5c80b079b0a3c2a38b859011bc70562357", "url": "https://github.com/questdb/questdb/commit/11d31d5c80b079b0a3c2a38b859011bc70562357", "message": "Rename expected exception in failing text import test", "committedDate": "2020-10-05T08:29:32Z", "type": "commit"}, {"oid": "0cb0316e8f5ea3ff6a652c7ded1c349f5c7051e7", "url": "https://github.com/questdb/questdb/commit/0cb0316e8f5ea3ff6a652c7ded1c349f5c7051e7", "message": "Schedule channel to read when not enough lines received in Text Import.\nCover server disconnect exception on retry processing in Http Context.", "committedDate": "2020-10-07T00:01:11Z", "type": "commit"}, {"oid": "e3e891c66cbcca76e441a24546406981bb610792", "url": "https://github.com/questdb/questdb/commit/e3e891c66cbcca76e441a24546406981bb610792", "message": "PR comment minor refactoring:\n- move new exceptions to http package\n- few renaming\n- code cleanup", "committedDate": "2020-10-13T22:44:11Z", "type": "commit"}, {"oid": "8ab5e324dcd5965f7f6d316949db2f7f41d18767", "url": "https://github.com/questdb/questdb/commit/8ab5e324dcd5965f7f6d316949db2f7f41d18767", "message": "- Test small http receive buffer with text import\n- In text import, save the import status before releasing the writer to the pool to not access the writer if interrupted by slow receiver.", "committedDate": "2020-10-20T00:02:17Z", "type": "commit"}, {"oid": "9147fc22850be61ad57401e1e0cca437921edf08", "url": "https://github.com/questdb/questdb/commit/9147fc22850be61ad57401e1e0cca437921edf08", "message": "Merge remote-tracking branch 'remotes/origin/master' into writer-wait-next", "committedDate": "2020-10-20T15:20:42Z", "type": "commit"}, {"oid": "8c6e55c358e364920151b99d516675eba0c3da45", "url": "https://github.com/questdb/questdb/commit/8c6e55c358e364920151b99d516675eba0c3da45", "message": "Fix merger from master", "committedDate": "2020-10-20T15:45:29Z", "type": "commit"}, {"oid": "a87e90bf8abee96681b49806edb372893e54977d", "url": "https://github.com/questdb/questdb/commit/a87e90bf8abee96681b49806edb372893e54977d", "message": "Fix master merge conflicts", "committedDate": "2020-10-22T23:26:40Z", "type": "commit"}, {"oid": "04799213139c9f255b5fd2261a02c18350f35694", "url": "https://github.com/questdb/questdb/commit/04799213139c9f255b5fd2261a02c18350f35694", "message": "Merge branch 'writer-wait-next' of https://github.com/ideoma/questdb into writer-wait-next", "committedDate": "2020-10-23T15:46:54Z", "type": "commit"}, {"oid": "bcacfa4ca437b204d70e2ef450afe166335f9dea", "url": "https://github.com/questdb/questdb/commit/bcacfa4ca437b204d70e2ef450afe166335f9dea", "message": "Enable all the tests, small cleanup", "committedDate": "2020-10-23T22:55:48Z", "type": "commit"}, {"oid": "38d5d3a177c1f109eb2eb3cbc0ffcf2a3131479b", "url": "https://github.com/questdb/questdb/commit/38d5d3a177c1f109eb2eb3cbc0ffcf2a3131479b", "message": "Testing with slow text import sender and receiver.", "committedDate": "2020-10-28T00:36:45Z", "type": "commit"}, {"oid": "fd949c0d68f3a8ca07b36fe7a8efb135f0a10440", "url": "https://github.com/questdb/questdb/commit/fd949c0d68f3a8ca07b36fe7a8efb135f0a10440", "message": "Test to reproduce HttpMultipartContentParser break on boundary", "committedDate": "2020-10-29T12:58:15Z", "type": "commit"}, {"oid": "109c9fcfad157d5963c157e98c8cc55fe690b787", "url": "https://github.com/questdb/questdb/commit/109c9fcfad157d5963c157e98c8cc55fe690b787", "message": "Merge branch 'master' into writer-wait-next", "committedDate": "2020-10-30T10:36:30Z", "type": "commit"}, {"oid": "43310da0f62587fc51274c706b4e95b4e0bff1de", "url": "https://github.com/questdb/questdb/commit/43310da0f62587fc51274c706b4e95b4e0bff1de", "message": "Merge branch 'master' into writer-wait-next", "committedDate": "2020-10-30T14:13:18Z", "type": "commit"}, {"oid": "f1ebb014cadd55b83dd71197741ad275753c03ac", "url": "https://github.com/questdb/questdb/commit/f1ebb014cadd55b83dd71197741ad275753c03ac", "message": "Merge branch 'master' into writer-wait-next", "committedDate": "2020-10-30T18:15:50Z", "type": "commit"}, {"oid": "1ddd6ea61e88eda8cc29bc747206cc6dddf625e3", "url": "https://github.com/questdb/questdb/commit/1ddd6ea61e88eda8cc29bc747206cc6dddf625e3", "message": "Multipart parsing with retry tests.\nAvoiding to request to read more if retry happens on chunk before boundary.", "committedDate": "2020-11-03T00:21:32Z", "type": "commit"}, {"oid": "975edaabb0dd2ad048fe43e4b8c65f7942d3d31b", "url": "https://github.com/questdb/questdb/commit/975edaabb0dd2ad048fe43e4b8c65f7942d3d31b", "message": "Fix test", "committedDate": "2020-11-04T00:30:07Z", "type": "commit"}, {"oid": "37e72c583e35d46bd74a0dcf9e1267bd32f062c9", "url": "https://github.com/questdb/questdb/commit/37e72c583e35d46bd74a0dcf9e1267bd32f062c9", "message": "Merge branch 'master' into writer-wait-next", "committedDate": "2020-11-04T13:35:54Z", "type": "commit"}, {"oid": "edcff1913c45558316ba3d3456ae48e53d43bf40", "url": "https://github.com/questdb/questdb/commit/edcff1913c45558316ba3d3456ae48e53d43bf40", "message": "Merge branch 'master' into writer-wait-next", "committedDate": "2020-11-04T14:40:21Z", "type": "commit"}, {"oid": "59c536634bf33777257fe8802f8ce583bf894c61", "url": "https://github.com/questdb/questdb/commit/59c536634bf33777257fe8802f8ce583bf894c61", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/cutlass/http/processors/JsonQueryProcessor.java\n#\tcore/src/main/java/io/questdb/cutlass/http/processors/TextImportProcessor.java\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java", "committedDate": "2020-11-05T00:19:06Z", "type": "commit"}, {"oid": "ffc5c308acf30aaa31ccf53c270128d1498e5ec8", "url": "https://github.com/questdb/questdb/commit/ffc5c308acf30aaa31ccf53c270128d1498e5ec8", "message": "Fix edge case of slow sender on text import", "committedDate": "2020-11-05T00:27:33Z", "type": "commit"}, {"oid": "e035f635420d218cf48b809c3337685a09527865", "url": "https://github.com/questdb/questdb/commit/e035f635420d218cf48b809c3337685a09527865", "message": "Merge branch 'master' into writer-wait-next", "committedDate": "2020-11-05T13:11:47Z", "type": "commit"}, {"oid": "bb5a03997f5ee5701501892d32df0b3fed2205d4", "url": "https://github.com/questdb/questdb/commit/bb5a03997f5ee5701501892d32df0b3fed2205d4", "message": "PR feedback", "committedDate": "2020-11-06T10:57:29Z", "type": "commit"}, {"oid": "576ae1dc1eee1887787307a2369eadfa95bc0d19", "url": "https://github.com/questdb/questdb/commit/576ae1dc1eee1887787307a2369eadfa95bc0d19", "message": "Merge branch 'master' into writer-wait-next\n\n# Conflicts:\n#\tcore/src/main/java/io/questdb/PropServerConfiguration.java\n#\tcore/src/main/java/io/questdb/cutlass/http/HttpConnectionContext.java\n#\tcore/src/main/java/io/questdb/cutlass/http/HttpServerConfiguration.java\n#\tcore/src/test/java/io/questdb/cutlass/http/IODispatcherTest.java", "committedDate": "2020-11-06T16:48:29Z", "type": "commit"}]}