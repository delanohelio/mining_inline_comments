{"pr_number": 949, "pr_title": "PHOENIX-6032: When phoenix.allow.system.catalog.rollback=true, a view still sees data from a column that was dropped", "pr_createdAt": "2020-10-30T00:38:37Z", "pr_url": "https://github.com/apache/phoenix/pull/949", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDczODI2OQ==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r514738269", "bodyText": "nit: the expected value should be the first argument", "author": "yanxinyi", "createdAt": "2020-10-30T02:45:00Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/SystemCatalogRollbackEnabledIT.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.RegionLocator;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.query.BaseTest;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.ColumnNotFoundException;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import com.google.common.collect.Maps;\n+\n+/**\n+ * Tests various scenarios when {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK}\n+ * is set to true and SYSTEM.CATALOG should not be allowed to split. Note that this config must\n+ * be set on both the client and server\n+ */\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class SystemCatalogRollbackEnabledIT extends BaseTest {\n+\n+\t@BeforeClass\n+\tpublic static synchronized void doSetup() throws Exception {\n+\t\tMap<String, String> serverProps = Maps.newHashMapWithExpectedSize(2);\n+\t\tMap<String, String> clientProps = Maps.newHashMapWithExpectedSize(1);\n+\t\tserverProps.put(QueryServices.SYSTEM_CATALOG_SPLITTABLE, \"false\");\n+        serverProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK, \"true\");\n+        clientProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK, \"true\");\n+\t\tsetUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()),\n+                new ReadOnlyProps(clientProps.entrySet().iterator()));\n+\t}\n+\n+    private void createTable(String tableName) throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement();) {\n+            stmt.execute(\"DROP TABLE IF EXISTS \" + tableName);\n+            stmt.execute(\"CREATE TABLE \" + tableName + \" (TENANT_ID VARCHAR NOT NULL, \" +\n+                    \"PK1 VARCHAR NOT NULL, V1 VARCHAR CONSTRAINT PK \" +\n+                    \"PRIMARY KEY(TENANT_ID, PK1)) MULTI_TENANT=true\");\n+            try (Connection tenant1Conn = getTenantConnection(\"tenant1\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName + \"_view1 AS SELECT * FROM \" +\n+                        tableName;\n+                tenant1Conn.createStatement().execute(view1DDL);\n+            }\n+            try (Connection tenant1Conn = getTenantConnection(\"tenant2\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName + \"_view2 AS SELECT * FROM \" +\n+                        tableName;\n+                tenant1Conn.createStatement().execute(view1DDL);\n+            }\n+            conn.commit();\n+        }\n+    }\n+\n+    private Connection getTenantConnection(String tenantId) throws SQLException {\n+        Properties tenantProps = new Properties();\n+        tenantProps.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n+        return DriverManager.getConnection(getUrl(), tenantProps);\n+    }\n+\n+\n+    /**\n+     * Make sure that SYSTEM.CATALOG cannot be split if\n+     * {@link QueryServices#SYSTEM_CATALOG_SPLITTABLE} is false\n+     */\n+    @Test\n+    public void testSystemTableDoesNotSplit() throws Exception {\n+        HBaseTestingUtility testUtil = getUtility();\n+        for (int i=0; i<10; i++) {\n+            createTable(\"schema\"+i+\".table_\"+i);\n+        }\n+        TableName systemCatalog = TableName.valueOf(\"SYSTEM.CATALOG\");\n+        RegionLocator rl = testUtil.getConnection().getRegionLocator(systemCatalog);\n+        assertEquals(rl.getAllRegionLocations().size(), 1);", "originalCommit": "18af3b27a5e0cf4cfc3796c14118a8de54bea5e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc1Mzk5NA==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r514753994", "bodyText": "I've copied this from the existing SystemCatalogIT, but will fix it anyways", "author": "ChinmaySKulkarni", "createdAt": "2020-10-30T03:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDczODI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc0MDUxMA==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r514740510", "bodyText": "nit: using PhoenixDatabaseMetaData.SYSTEM_CATALOG_NAME", "author": "yanxinyi", "createdAt": "2020-10-30T02:47:16Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/SystemCatalogRollbackEnabledIT.java", "diffHunk": "@@ -0,0 +1,271 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.RegionLocator;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.query.BaseTest;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.ColumnNotFoundException;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+import com.google.common.collect.Maps;\n+\n+/**\n+ * Tests various scenarios when {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK}\n+ * is set to true and SYSTEM.CATALOG should not be allowed to split. Note that this config must\n+ * be set on both the client and server\n+ */\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class SystemCatalogRollbackEnabledIT extends BaseTest {\n+\n+\t@BeforeClass\n+\tpublic static synchronized void doSetup() throws Exception {\n+\t\tMap<String, String> serverProps = Maps.newHashMapWithExpectedSize(2);\n+\t\tMap<String, String> clientProps = Maps.newHashMapWithExpectedSize(1);\n+\t\tserverProps.put(QueryServices.SYSTEM_CATALOG_SPLITTABLE, \"false\");\n+        serverProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK, \"true\");\n+        clientProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK, \"true\");\n+\t\tsetUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()),\n+                new ReadOnlyProps(clientProps.entrySet().iterator()));\n+\t}\n+\n+    private void createTable(String tableName) throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement();) {\n+            stmt.execute(\"DROP TABLE IF EXISTS \" + tableName);\n+            stmt.execute(\"CREATE TABLE \" + tableName + \" (TENANT_ID VARCHAR NOT NULL, \" +\n+                    \"PK1 VARCHAR NOT NULL, V1 VARCHAR CONSTRAINT PK \" +\n+                    \"PRIMARY KEY(TENANT_ID, PK1)) MULTI_TENANT=true\");\n+            try (Connection tenant1Conn = getTenantConnection(\"tenant1\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName + \"_view1 AS SELECT * FROM \" +\n+                        tableName;\n+                tenant1Conn.createStatement().execute(view1DDL);\n+            }\n+            try (Connection tenant1Conn = getTenantConnection(\"tenant2\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName + \"_view2 AS SELECT * FROM \" +\n+                        tableName;\n+                tenant1Conn.createStatement().execute(view1DDL);\n+            }\n+            conn.commit();\n+        }\n+    }\n+\n+    private Connection getTenantConnection(String tenantId) throws SQLException {\n+        Properties tenantProps = new Properties();\n+        tenantProps.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n+        return DriverManager.getConnection(getUrl(), tenantProps);\n+    }\n+\n+\n+    /**\n+     * Make sure that SYSTEM.CATALOG cannot be split if\n+     * {@link QueryServices#SYSTEM_CATALOG_SPLITTABLE} is false\n+     */\n+    @Test\n+    public void testSystemTableDoesNotSplit() throws Exception {\n+        HBaseTestingUtility testUtil = getUtility();\n+        for (int i=0; i<10; i++) {\n+            createTable(\"schema\"+i+\".table_\"+i);\n+        }\n+        TableName systemCatalog = TableName.valueOf(\"SYSTEM.CATALOG\");", "originalCommit": "18af3b27a5e0cf4cfc3796c14118a8de54bea5e2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc1NDA1Ng==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r514754056", "bodyText": "I've copied this from the existing SystemCatalogIT, but will fix it anyways", "author": "ChinmaySKulkarni", "createdAt": "2020-10-30T03:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc0MDUxMA=="}], "type": "inlineReview"}, {"oid": "73e597ee90693c9c7ab8fcf8916c44d0ef02c76f", "url": "https://github.com/apache/phoenix/commit/73e597ee90693c9c7ab8fcf8916c44d0ef02c76f", "message": "PHOENIX-6032: When phoenix.allow.system.catalog.rollback=true, a view still sees data from a column that was dropped", "committedDate": "2020-10-30T18:38:26Z", "type": "forcePushed"}, {"oid": "63812e7c7d3e039a77ddf36461ceb445789ebd90", "url": "https://github.com/apache/phoenix/commit/63812e7c7d3e039a77ddf36461ceb445789ebd90", "message": "PHOENIX-6032: When phoenix.allow.system.catalog.rollback=true, a view still sees data from a column that was dropped", "committedDate": "2020-10-30T18:47:08Z", "type": "forcePushed"}, {"oid": "bd51b4374a91c36790f4bbc0c58915c3246278fb", "url": "https://github.com/apache/phoenix/commit/bd51b4374a91c36790f4bbc0c58915c3246278fb", "message": "PHOENIX-6032: When phoenix.allow.system.catalog.rollback=true, a view still sees data from a column that was dropped", "committedDate": "2020-10-30T23:20:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ4MTA2Mw==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r515481063", "bodyText": "Soon after this check to ensure CNFE for C occurs, maybe we can again repeat the above test of parent table to ensure record in parent table stays intact? (repeating \"SELECT A,B,C,D FROM \" + parentName test?)", "author": "virajjasani", "createdAt": "2020-10-31T10:11:19Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/SystemCatalogRollbackEnabledIT.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.RegionLocator;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.jdbc.PhoenixDatabaseMetaData;\n+import org.apache.phoenix.query.BaseTest;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.ColumnNotFoundException;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Tests various scenarios when {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK}\n+ * is set to true and SYSTEM.CATALOG should not be allowed to split. Note that this config must\n+ * be set on both the client and server\n+ */\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class SystemCatalogRollbackEnabledIT extends BaseTest {\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> serverProps = new HashMap<>(2);\n+        Map<String, String> clientProps = new HashMap<>(1);\n+        serverProps.put(QueryServices.SYSTEM_CATALOG_SPLITTABLE, \"false\");\n+        serverProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK,\n+                \"true\");\n+        clientProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK,\n+                \"true\");\n+        setUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()),\n+                new ReadOnlyProps(clientProps.entrySet().iterator()));\n+    }\n+\n+    private void createTable(String tableName) throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement();) {\n+            stmt.execute(\"DROP TABLE IF EXISTS \" + tableName);\n+            stmt.execute(\"CREATE TABLE \" + tableName + \" (TENANT_ID VARCHAR NOT NULL, \" +\n+                    \"PK1 VARCHAR NOT NULL, V1 VARCHAR CONSTRAINT PK \" +\n+                    \"PRIMARY KEY(TENANT_ID, PK1)) MULTI_TENANT=true\");\n+            try (Connection tenant1Conn = getTenantConnection(\"tenant1\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName + \"_view1 AS SELECT * FROM \" +\n+                        tableName;\n+                tenant1Conn.createStatement().execute(view1DDL);\n+            }\n+            try (Connection tenant1Conn = getTenantConnection(\"tenant2\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName + \"_view2 AS SELECT * FROM \" +\n+                        tableName;\n+                tenant1Conn.createStatement().execute(view1DDL);\n+            }\n+            conn.commit();\n+        }\n+    }\n+\n+    private Connection getTenantConnection(String tenantId) throws SQLException {\n+        Properties tenantProps = new Properties();\n+        tenantProps.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n+        return DriverManager.getConnection(getUrl(), tenantProps);\n+    }\n+\n+\n+    /**\n+     * Make sure that SYSTEM.CATALOG cannot be split if\n+     * {@link QueryServices#SYSTEM_CATALOG_SPLITTABLE} is false\n+     */\n+    @Test\n+    public void testSystemTableDoesNotSplit() throws Exception {\n+        HBaseTestingUtility testUtil = getUtility();\n+        for (int i=0; i<10; i++) {\n+            createTable(\"schema\"+i+\".table_\"+i);\n+        }\n+        TableName systemCatalog = TableName.valueOf(PhoenixDatabaseMetaData.SYSTEM_CATALOG_NAME);\n+        RegionLocator rl = testUtil.getConnection().getRegionLocator(systemCatalog);\n+        assertEquals(1, rl.getAllRegionLocations().size());\n+        try {\n+            // now attempt to split SYSTEM.CATALOG\n+            testUtil.getHBaseAdmin().split(systemCatalog);\n+            // make sure the split finishes (there's no synchronous splitting before HBase 2.x)\n+            testUtil.getHBaseAdmin().disableTable(systemCatalog);\n+            testUtil.getHBaseAdmin().enableTable(systemCatalog);\n+        } catch (DoNotRetryIOException e) {\n+            // table is not splittable\n+            assert (e.getMessage().contains(\"NOT splittable\"));\n+        }\n+\n+        // test again... Must still be exactly one region.\n+        rl = testUtil.getConnection().getRegionLocator(systemCatalog);\n+        assertEquals(1, rl.getAllRegionLocations().size());\n+    }\n+\n+    /**\n+     * Ensure that we cannot add a column to a parent table or view if\n+     * {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK} is true\n+     */\n+    @Test\n+    public void testAddColumnOnParentFails() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            final String parentTableName = SchemaUtil.getTableName(generateUniqueName(),\n+                    generateUniqueName());\n+            final String parentViewName = SchemaUtil.getTableName(generateUniqueName(),\n+                    generateUniqueName());\n+            final String childViewName = SchemaUtil.getTableName(generateUniqueName(),\n+                    generateUniqueName());\n+            // create parent table\n+            String ddl = \"CREATE TABLE \" + parentTableName + \" (col1 INTEGER NOT NULL,\"\n+                    + \" col2 INTEGER \" + \"CONSTRAINT pk PRIMARY KEY (col1))\";\n+            conn.createStatement().execute(ddl);\n+\n+            // create view on table\n+            ddl = \"CREATE VIEW \" + parentViewName + \" AS SELECT * FROM \" + parentTableName;\n+            conn.createStatement().execute(ddl);\n+            try {\n+                ddl = \"ALTER TABLE \" + parentTableName + \" ADD col4 INTEGER\";\n+                conn.createStatement().execute(ddl);\n+                fail(\"ALTER TABLE ADD should not be allowed on parent table\");\n+            } catch (SQLException e) {\n+                assertEquals(SQLExceptionCode.CANNOT_MUTATE_TABLE.getErrorCode(), e.getErrorCode());\n+            }\n+\n+            // create child view on above view\n+            ddl = \"CREATE VIEW \" + childViewName + \"(col3 INTEGER) AS SELECT * FROM \"\n+                    + parentViewName;\n+            conn.createStatement().execute(ddl);\n+            try {\n+                ddl = \"ALTER VIEW \" + parentViewName + \" ADD col4 INTEGER\";\n+                conn.createStatement().execute(ddl);\n+                fail(\"ALTER VIEW ADD should not be allowed on parent view\");\n+            } catch (SQLException e) {\n+                assertEquals(SQLExceptionCode.CANNOT_MUTATE_TABLE.getErrorCode(), e.getErrorCode());\n+            }\n+\n+            // alter child view with add column should be allowed\n+            ddl = \"ALTER VIEW \" + childViewName + \" ADD col4 INTEGER\";\n+            conn.createStatement().execute(ddl);\n+        }\n+    }\n+\n+    /**\n+     * Ensure that we cannot drop a column from a parent table or view if\n+     * {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK} is true\n+     */\n+    @Test\n+    public void testDropColumnOnParentFails() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            final String parentTableName = SchemaUtil.getTableName(generateUniqueName(),\n+                    generateUniqueName());\n+            final String parentViewName = SchemaUtil.getTableName(generateUniqueName(),\n+                    generateUniqueName());\n+            final String childViewName = SchemaUtil.getTableName(generateUniqueName(),\n+                    generateUniqueName());\n+            // create parent table\n+            String ddl = \"CREATE TABLE \" + parentTableName\n+                    + \" (col1 INTEGER NOT NULL, col2 INTEGER, col3 VARCHAR \"\n+                    + \"CONSTRAINT pk PRIMARY KEY (col1))\";\n+            conn.createStatement().execute(ddl);\n+\n+            // create view on table\n+            ddl = \"CREATE VIEW \" + parentViewName + \" AS SELECT * FROM \" + parentTableName;\n+            conn.createStatement().execute(ddl);\n+            try {\n+                ddl = \"ALTER TABLE \" + parentTableName + \" DROP COLUMN col2\";\n+                conn.createStatement().execute(ddl);\n+                fail(\"ALTER TABLE DROP COLUMN should not be allowed on parent table\");\n+            } catch (SQLException e) {\n+                assertEquals(SQLExceptionCode.CANNOT_MUTATE_TABLE.getErrorCode(), e.getErrorCode());\n+            }\n+\n+            // create child view on above view\n+            ddl = \"CREATE VIEW \" + childViewName + \"(col5 INTEGER) AS SELECT * FROM \"\n+                    + parentViewName;\n+            conn.createStatement().execute(ddl);\n+            try {\n+                ddl = \"ALTER VIEW \" + parentViewName + \" DROP COLUMN col2\";\n+                conn.createStatement().execute(ddl);\n+                fail(\"ALTER VIEW DROP COLUMN should not be allowed on parent view\");\n+            } catch (SQLException e) {\n+                assertEquals(SQLExceptionCode.CANNOT_MUTATE_TABLE.getErrorCode(), e.getErrorCode());\n+            }\n+\n+            // alter child view with drop column should be allowed\n+            ddl = \"ALTER VIEW \" + childViewName + \" DROP COLUMN col2\";\n+            conn.createStatement().execute(ddl);\n+        }\n+    }\n+\n+    // Test for PHOENIX-6032\n+    @Test\n+    public void testViewDoesNotSeeDataForDroppedColumn() throws Exception {\n+        final String parentName = \"T_\"\n+                + SchemaUtil.getTableName(generateUniqueName(), generateUniqueName());\n+        final String viewName = \"V_\"\n+                + SchemaUtil.getTableName(generateUniqueName(), generateUniqueName());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + parentName\n+                    + \" (A INTEGER PRIMARY KEY, B INTEGER, C VARCHAR, D INTEGER)\");\n+            conn.createStatement().execute(\"CREATE VIEW \" + viewName + \" (VA INTEGER, VB INTEGER)\"\n+                    + \" AS SELECT * FROM \" + parentName + \" WHERE B=200\");\n+            // Upsert some data via the view\n+            conn.createStatement().execute(\"UPSERT INTO \" + viewName + \" (A,B,C,D,VA,VB) VALUES\"\n+                    + \" (2, 200, 'def', -20, 91, 101)\");\n+            conn.commit();\n+        }\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            // Query from the parent table and assert expected values\n+            ResultSet rs = conn.createStatement().executeQuery(\"SELECT A,B,C,D FROM \" + parentName);\n+            assertTrue(rs.next());\n+            assertEquals(2, rs.getInt(1));\n+            assertEquals(200, rs.getInt(2));\n+            assertEquals(\"def\", rs.getString(3));\n+            assertEquals(-20, rs.getInt(4));\n+            assertFalse(rs.next());\n+\n+            // Query from the view and assert expected values\n+            rs = conn.createStatement().executeQuery(\"SELECT A,B,C,D,VA,VB FROM \" + viewName);\n+            assertTrue(rs.next());\n+            assertEquals(2, rs.getInt(1));\n+            assertEquals(200, rs.getInt(2));\n+            assertEquals(\"def\", rs.getString(3));\n+            assertEquals(-20, rs.getInt(4));\n+            assertEquals(91, rs.getInt(5));\n+            assertEquals(101, rs.getInt(6));\n+            assertFalse(rs.next());\n+        }\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            // Drop a parent column from the view\n+            conn.createStatement().execute(\"ALTER VIEW \" + viewName + \" DROP COLUMN C\");\n+            try {\n+                conn.createStatement().executeQuery(\"SELECT C FROM \" + viewName);\n+                fail(\"Expected a ColumnNotFoundException for C since it was dropped\");\n+            } catch (ColumnNotFoundException ignore) { }", "originalCommit": "bd51b4374a91c36790f4bbc0c58915c3246278fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIzMDA1MQ==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516230051", "bodyText": "I think it would be a much bigger bug if a view alteration caused the base table's schema to be changed. This patch doesn't change any of that, so not sure that an extra check is valuable after this.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-02T20:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ4MTA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ4MTM2Ng==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r515481366", "bodyText": "nit: maybe we can rename to createTableAndTenantViews ?", "author": "virajjasani", "createdAt": "2020-10-31T10:15:06Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/SystemCatalogRollbackEnabledIT.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.RegionLocator;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.jdbc.PhoenixDatabaseMetaData;\n+import org.apache.phoenix.query.BaseTest;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.ColumnNotFoundException;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Tests various scenarios when {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK}\n+ * is set to true and SYSTEM.CATALOG should not be allowed to split. Note that this config must\n+ * be set on both the client and server\n+ */\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class SystemCatalogRollbackEnabledIT extends BaseTest {\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> serverProps = new HashMap<>(2);\n+        Map<String, String> clientProps = new HashMap<>(1);\n+        serverProps.put(QueryServices.SYSTEM_CATALOG_SPLITTABLE, \"false\");\n+        serverProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK,\n+                \"true\");\n+        clientProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK,\n+                \"true\");\n+        setUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()),\n+                new ReadOnlyProps(clientProps.entrySet().iterator()));\n+    }\n+\n+    private void createTable(String tableName) throws Exception {", "originalCommit": "bd51b4374a91c36790f4bbc0c58915c3246278fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIzMDY4MQ==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516230681", "bodyText": "This is copied over from an existing class to consolidate tests, but sure I will rename it.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-02T20:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ4MTM2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ4MTQxMw==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r515481413", "bodyText": "nit: tenant2Conn", "author": "virajjasani", "createdAt": "2020-10-31T10:15:52Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/SystemCatalogRollbackEnabledIT.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.RegionLocator;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.jdbc.PhoenixDatabaseMetaData;\n+import org.apache.phoenix.query.BaseTest;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.ColumnNotFoundException;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Tests various scenarios when {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK}\n+ * is set to true and SYSTEM.CATALOG should not be allowed to split. Note that this config must\n+ * be set on both the client and server\n+ */\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class SystemCatalogRollbackEnabledIT extends BaseTest {\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> serverProps = new HashMap<>(2);\n+        Map<String, String> clientProps = new HashMap<>(1);\n+        serverProps.put(QueryServices.SYSTEM_CATALOG_SPLITTABLE, \"false\");\n+        serverProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK,\n+                \"true\");\n+        clientProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK,\n+                \"true\");\n+        setUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()),\n+                new ReadOnlyProps(clientProps.entrySet().iterator()));\n+    }\n+\n+    private void createTable(String tableName) throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement();) {\n+            stmt.execute(\"DROP TABLE IF EXISTS \" + tableName);\n+            stmt.execute(\"CREATE TABLE \" + tableName + \" (TENANT_ID VARCHAR NOT NULL, \" +\n+                    \"PK1 VARCHAR NOT NULL, V1 VARCHAR CONSTRAINT PK \" +\n+                    \"PRIMARY KEY(TENANT_ID, PK1)) MULTI_TENANT=true\");\n+            try (Connection tenant1Conn = getTenantConnection(\"tenant1\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName + \"_view1 AS SELECT * FROM \" +\n+                        tableName;\n+                tenant1Conn.createStatement().execute(view1DDL);\n+            }\n+            try (Connection tenant1Conn = getTenantConnection(\"tenant2\")) {", "originalCommit": "bd51b4374a91c36790f4bbc0c58915c3246278fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjIzMDgyMg==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516230822", "bodyText": "Similarly, this is just copied over but I will change it. Thanks", "author": "ChinmaySKulkarni", "createdAt": "2020-11-02T20:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ4MTQxMw=="}], "type": "inlineReview"}, {"oid": "e5e08f050422f31406b27183790eb881081e0ef9", "url": "https://github.com/apache/phoenix/commit/e5e08f050422f31406b27183790eb881081e0ef9", "message": "PHOENIX-6032: When phoenix.allow.system.catalog.rollback=true, a view still sees data from a column that was dropped", "committedDate": "2020-11-02T21:44:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3Njc4MQ==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516276781", "bodyText": "Do we require that we get this exception? If so should be an Assert.fail() after enableTable", "author": "gjacoby126", "createdAt": "2020-11-02T21:54:10Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/SystemCatalogRollbackEnabledIT.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.RegionLocator;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.jdbc.PhoenixDatabaseMetaData;\n+import org.apache.phoenix.query.BaseTest;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.ColumnNotFoundException;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Tests various scenarios when\n+ * {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK}\n+ * is set to true and SYSTEM.CATALOG should not be allowed to split.\n+ * Note that this config must\n+ * be set on both the client and server\n+ */\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class SystemCatalogRollbackEnabledIT extends BaseTest {\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> serverProps = new HashMap<>(2);\n+        Map<String, String> clientProps = new HashMap<>(1);\n+        serverProps.put(QueryServices.SYSTEM_CATALOG_SPLITTABLE, \"false\");\n+        serverProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK,\n+                \"true\");\n+        clientProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK,\n+                \"true\");\n+        setUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()),\n+                new ReadOnlyProps(clientProps.entrySet().iterator()));\n+    }\n+\n+    private void createTableAndTenantViews(String tableName) throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement();) {\n+            stmt.execute(\"DROP TABLE IF EXISTS \" + tableName);\n+            stmt.execute(\"CREATE TABLE \" + tableName +\n+                    \" (TENANT_ID VARCHAR NOT NULL, \" +\n+                    \"PK1 VARCHAR NOT NULL, V1 VARCHAR CONSTRAINT PK \" +\n+                    \"PRIMARY KEY(TENANT_ID, PK1)) MULTI_TENANT=true\");\n+            try (Connection tenant1Conn = getTenantConnection(\"tenant1\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName +\n+                        \"_view1 AS SELECT * FROM \" +\n+                        tableName;\n+                tenant1Conn.createStatement().execute(view1DDL);\n+            }\n+            try (Connection tenant2Conn = getTenantConnection(\"tenant2\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName +\n+                        \"_view2 AS SELECT * FROM \" + tableName;\n+                tenant2Conn.createStatement().execute(view1DDL);\n+            }\n+            conn.commit();\n+        }\n+    }\n+\n+    private Connection getTenantConnection(String tenantId)\n+            throws SQLException {\n+        Properties tenantProps = new Properties();\n+        tenantProps.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n+        return DriverManager.getConnection(getUrl(), tenantProps);\n+    }\n+\n+\n+    /**\n+     * Make sure that SYSTEM.CATALOG cannot be split if\n+     * {@link QueryServices#SYSTEM_CATALOG_SPLITTABLE} is false\n+     */\n+    @Test\n+    public void testSystemTableDoesNotSplit() throws Exception {\n+        HBaseTestingUtility testUtil = getUtility();\n+        for (int i=0; i<10; i++) {\n+            createTableAndTenantViews(\"schema\"+i+\".table_\"+i);\n+        }\n+        TableName systemCatalog = TableName.valueOf(\n+                PhoenixDatabaseMetaData.SYSTEM_CATALOG_NAME);\n+        RegionLocator rl = testUtil.getConnection()\n+                .getRegionLocator(systemCatalog);\n+        assertEquals(1, rl.getAllRegionLocations().size());\n+        try {\n+            // now attempt to split SYSTEM.CATALOG\n+            testUtil.getHBaseAdmin().split(systemCatalog);\n+            // make sure the split finishes (there's no synchronous splitting\n+            // before HBase 2.x)\n+            testUtil.getHBaseAdmin().disableTable(systemCatalog);\n+            testUtil.getHBaseAdmin().enableTable(systemCatalog);\n+        } catch (DoNotRetryIOException e) {\n+            // table is not splittable\n+            assert (e.getMessage().contains(\"NOT splittable\"));", "originalCommit": "e5e08f050422f31406b27183790eb881081e0ef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3NjkzMg==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516276932", "bodyText": "Also, should use JUnit assertions rather than Java assert keyword", "author": "gjacoby126", "createdAt": "2020-11-02T21:54:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3Njc4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4Mjc4Nw==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516282787", "bodyText": "(I know this is a copied test, but good to do the simple fixes while we're at it)", "author": "gjacoby126", "createdAt": "2020-11-02T22:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3Njc4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4NTA4NQ==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516285085", "bodyText": "hmm I'm not sure. This diff is just a result of copy pasting from the original test SystemCatalogIT Let me try to find out. Will change to using JUnit assert.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-02T22:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3Njc4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwMjcwMA==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516302700", "bodyText": "Looks like that test wasn't reliably trying to split SYSCAT at all. I will open a follow-up Jira to fix this since it is unrelated to 6032.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-02T22:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3Njc4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMzMjk1MQ==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516332951", "bodyText": "Created https://issues.apache.org/jira/browse/PHOENIX-6212", "author": "ChinmaySKulkarni", "createdAt": "2020-11-02T23:34:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI3Njc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4MjEwMw==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516282103", "bodyText": "Should also fail if we get some other exception other than ColumnNotFoundException -- can have a second catch block for Throwable and then fail() in it.", "author": "gjacoby126", "createdAt": "2020-11-02T22:05:37Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/SystemCatalogRollbackEnabledIT.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.RegionLocator;\n+import org.apache.phoenix.exception.SQLExceptionCode;\n+import org.apache.phoenix.jdbc.PhoenixDatabaseMetaData;\n+import org.apache.phoenix.query.BaseTest;\n+import org.apache.phoenix.query.QueryServices;\n+import org.apache.phoenix.schema.ColumnNotFoundException;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Tests various scenarios when\n+ * {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK}\n+ * is set to true and SYSTEM.CATALOG should not be allowed to split.\n+ * Note that this config must\n+ * be set on both the client and server\n+ */\n+@Category(NeedsOwnMiniClusterTest.class)\n+public class SystemCatalogRollbackEnabledIT extends BaseTest {\n+\n+    @BeforeClass\n+    public static synchronized void doSetup() throws Exception {\n+        Map<String, String> serverProps = new HashMap<>(2);\n+        Map<String, String> clientProps = new HashMap<>(1);\n+        serverProps.put(QueryServices.SYSTEM_CATALOG_SPLITTABLE, \"false\");\n+        serverProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK,\n+                \"true\");\n+        clientProps.put(QueryServices.ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK,\n+                \"true\");\n+        setUpTestDriver(new ReadOnlyProps(serverProps.entrySet().iterator()),\n+                new ReadOnlyProps(clientProps.entrySet().iterator()));\n+    }\n+\n+    private void createTableAndTenantViews(String tableName) throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl());\n+                Statement stmt = conn.createStatement();) {\n+            stmt.execute(\"DROP TABLE IF EXISTS \" + tableName);\n+            stmt.execute(\"CREATE TABLE \" + tableName +\n+                    \" (TENANT_ID VARCHAR NOT NULL, \" +\n+                    \"PK1 VARCHAR NOT NULL, V1 VARCHAR CONSTRAINT PK \" +\n+                    \"PRIMARY KEY(TENANT_ID, PK1)) MULTI_TENANT=true\");\n+            try (Connection tenant1Conn = getTenantConnection(\"tenant1\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName +\n+                        \"_view1 AS SELECT * FROM \" +\n+                        tableName;\n+                tenant1Conn.createStatement().execute(view1DDL);\n+            }\n+            try (Connection tenant2Conn = getTenantConnection(\"tenant2\")) {\n+                String view1DDL = \"CREATE VIEW \" + tableName +\n+                        \"_view2 AS SELECT * FROM \" + tableName;\n+                tenant2Conn.createStatement().execute(view1DDL);\n+            }\n+            conn.commit();\n+        }\n+    }\n+\n+    private Connection getTenantConnection(String tenantId)\n+            throws SQLException {\n+        Properties tenantProps = new Properties();\n+        tenantProps.setProperty(PhoenixRuntime.TENANT_ID_ATTRIB, tenantId);\n+        return DriverManager.getConnection(getUrl(), tenantProps);\n+    }\n+\n+\n+    /**\n+     * Make sure that SYSTEM.CATALOG cannot be split if\n+     * {@link QueryServices#SYSTEM_CATALOG_SPLITTABLE} is false\n+     */\n+    @Test\n+    public void testSystemTableDoesNotSplit() throws Exception {\n+        HBaseTestingUtility testUtil = getUtility();\n+        for (int i=0; i<10; i++) {\n+            createTableAndTenantViews(\"schema\"+i+\".table_\"+i);\n+        }\n+        TableName systemCatalog = TableName.valueOf(\n+                PhoenixDatabaseMetaData.SYSTEM_CATALOG_NAME);\n+        RegionLocator rl = testUtil.getConnection()\n+                .getRegionLocator(systemCatalog);\n+        assertEquals(1, rl.getAllRegionLocations().size());\n+        try {\n+            // now attempt to split SYSTEM.CATALOG\n+            testUtil.getHBaseAdmin().split(systemCatalog);\n+            // make sure the split finishes (there's no synchronous splitting\n+            // before HBase 2.x)\n+            testUtil.getHBaseAdmin().disableTable(systemCatalog);\n+            testUtil.getHBaseAdmin().enableTable(systemCatalog);\n+        } catch (DoNotRetryIOException e) {\n+            // table is not splittable\n+            assert (e.getMessage().contains(\"NOT splittable\"));\n+        }\n+\n+        // test again... Must still be exactly one region.\n+        rl = testUtil.getConnection().getRegionLocator(systemCatalog);\n+        assertEquals(1, rl.getAllRegionLocations().size());\n+    }\n+\n+    /**\n+     * Ensure that we cannot add a column to a parent table or view if\n+     * {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK} is true\n+     */\n+    @Test\n+    public void testAddColumnOnParentFails() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            final String parentTableName = SchemaUtil.getTableName(\n+                    generateUniqueName(), generateUniqueName());\n+            final String parentViewName = SchemaUtil.getTableName(\n+                    generateUniqueName(), generateUniqueName());\n+            final String childViewName = SchemaUtil.getTableName(\n+                    generateUniqueName(), generateUniqueName());\n+            // create parent table\n+            String ddl = \"CREATE TABLE \" + parentTableName\n+                    + \" (col1 INTEGER NOT NULL,\"\n+                    + \" col2 INTEGER \" + \"CONSTRAINT pk PRIMARY KEY (col1))\";\n+            conn.createStatement().execute(ddl);\n+\n+            // create view on table\n+            ddl = \"CREATE VIEW \" + parentViewName + \" AS SELECT * FROM \"\n+                    + parentTableName;\n+            conn.createStatement().execute(ddl);\n+            try {\n+                ddl = \"ALTER TABLE \" + parentTableName + \" ADD col4 INTEGER\";\n+                conn.createStatement().execute(ddl);\n+                fail(\"ALTER TABLE ADD should not be allowed on parent table\");\n+            } catch (SQLException e) {\n+                assertEquals(SQLExceptionCode.CANNOT_MUTATE_TABLE\n+                        .getErrorCode(), e.getErrorCode());\n+            }\n+\n+            // create child view on above view\n+            ddl = \"CREATE VIEW \" + childViewName\n+                    + \"(col3 INTEGER) AS SELECT * FROM \" + parentViewName;\n+            conn.createStatement().execute(ddl);\n+            try {\n+                ddl = \"ALTER VIEW \" + parentViewName + \" ADD col4 INTEGER\";\n+                conn.createStatement().execute(ddl);\n+                fail(\"ALTER VIEW ADD should not be allowed on parent view\");\n+            } catch (SQLException e) {\n+                assertEquals(SQLExceptionCode.CANNOT_MUTATE_TABLE\n+                        .getErrorCode(), e.getErrorCode());\n+            }\n+\n+            // alter child view with add column should be allowed\n+            ddl = \"ALTER VIEW \" + childViewName + \" ADD col4 INTEGER\";\n+            conn.createStatement().execute(ddl);\n+        }\n+    }\n+\n+    /**\n+     * Ensure that we cannot drop a column from a parent table or view if\n+     * {@link QueryServices#ALLOW_SPLITTABLE_SYSTEM_CATALOG_ROLLBACK} is true\n+     */\n+    @Test\n+    public void testDropColumnOnParentFails() throws Exception {\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            final String parentTableName = SchemaUtil.getTableName(\n+                    generateUniqueName(), generateUniqueName());\n+            final String parentViewName = SchemaUtil.getTableName(\n+                    generateUniqueName(), generateUniqueName());\n+            final String childViewName = SchemaUtil.getTableName(\n+                    generateUniqueName(), generateUniqueName());\n+            // create parent table\n+            String ddl = \"CREATE TABLE \" + parentTableName\n+                    + \" (col1 INTEGER NOT NULL, col2 INTEGER, col3 VARCHAR \"\n+                    + \"CONSTRAINT pk PRIMARY KEY (col1))\";\n+            conn.createStatement().execute(ddl);\n+\n+            // create view on table\n+            ddl = \"CREATE VIEW \" + parentViewName + \" AS SELECT * FROM \"\n+                    + parentTableName;\n+            conn.createStatement().execute(ddl);\n+            try {\n+                ddl = \"ALTER TABLE \" + parentTableName + \" DROP COLUMN col2\";\n+                conn.createStatement().execute(ddl);\n+                fail(\"ALTER TABLE DROP COLUMN should not be allowed on \"\n+                        + \"parent table\");\n+            } catch (SQLException e) {\n+                assertEquals(SQLExceptionCode.CANNOT_MUTATE_TABLE\n+                        .getErrorCode(), e.getErrorCode());\n+            }\n+\n+            // create child view on above view\n+            ddl = \"CREATE VIEW \" + childViewName\n+                    + \"(col5 INTEGER) AS SELECT * FROM \" + parentViewName;\n+            conn.createStatement().execute(ddl);\n+            try {\n+                ddl = \"ALTER VIEW \" + parentViewName + \" DROP COLUMN col2\";\n+                conn.createStatement().execute(ddl);\n+                fail(\"ALTER VIEW DROP COLUMN should not be allowed on \"\n+                        + \"parent view\");\n+            } catch (SQLException e) {\n+                assertEquals(SQLExceptionCode.CANNOT_MUTATE_TABLE\n+                        .getErrorCode(), e.getErrorCode());\n+            }\n+\n+            // alter child view with drop column should be allowed\n+            ddl = \"ALTER VIEW \" + childViewName + \" DROP COLUMN col2\";\n+            conn.createStatement().execute(ddl);\n+        }\n+    }\n+\n+    // Test for PHOENIX-6032\n+    @Test\n+    public void testViewDoesNotSeeDataForDroppedColumn() throws Exception {\n+        final String parentName = \"T_\" + SchemaUtil.getTableName(\n+                generateUniqueName(), generateUniqueName());\n+        final String viewName = \"V_\" + SchemaUtil.getTableName(\n+                generateUniqueName(), generateUniqueName());\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + parentName\n+                    + \" (A INTEGER PRIMARY KEY, B INTEGER, C\"\n+                    + \" VARCHAR, D INTEGER)\");\n+            conn.createStatement().execute(\"CREATE VIEW \" + viewName\n+                    + \" (VA INTEGER, VB INTEGER)\"\n+                    + \" AS SELECT * FROM \" + parentName + \" WHERE B=200\");\n+            // Upsert some data via the view\n+            conn.createStatement().execute(\"UPSERT INTO \" + viewName\n+                    + \" (A,B,C,D,VA,VB) VALUES\"\n+                    + \" (2, 200, 'def', -20, 91, 101)\");\n+            conn.commit();\n+        }\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            // Query from the parent table and assert expected values\n+            ResultSet rs = conn.createStatement().executeQuery(\n+                    \"SELECT A,B,C,D FROM \" + parentName);\n+            assertTrue(rs.next());\n+            assertEquals(2, rs.getInt(1));\n+            assertEquals(200, rs.getInt(2));\n+            assertEquals(\"def\", rs.getString(3));\n+            assertEquals(-20, rs.getInt(4));\n+            assertFalse(rs.next());\n+\n+            // Query from the view and assert expected values\n+            rs = conn.createStatement().executeQuery(\n+                    \"SELECT A,B,C,D,VA,VB FROM \" + viewName);\n+            assertTrue(rs.next());\n+            assertEquals(2, rs.getInt(1));\n+            assertEquals(200, rs.getInt(2));\n+            assertEquals(\"def\", rs.getString(3));\n+            assertEquals(-20, rs.getInt(4));\n+            assertEquals(91, rs.getInt(5));\n+            assertEquals(101, rs.getInt(6));\n+            assertFalse(rs.next());\n+        }\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl())) {\n+            // Drop a parent column from the view\n+            conn.createStatement().execute(\"ALTER VIEW \" + viewName\n+                    + \" DROP COLUMN C\");\n+            try {\n+                conn.createStatement().executeQuery(\"SELECT C FROM \"\n+                        + viewName);\n+                fail(\"Expected a ColumnNotFoundException for C since it \"\n+                        + \"was dropped\");\n+            } catch (ColumnNotFoundException ignore) { }\n+        }", "originalCommit": "e5e08f050422f31406b27183790eb881081e0ef9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4NjA3NA==", "url": "https://github.com/apache/phoenix/pull/949#discussion_r516286074", "bodyText": "If any other exception apart from CNFE gets thrown here the test will fail anyways.", "author": "ChinmaySKulkarni", "createdAt": "2020-11-02T22:14:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI4MjEwMw=="}], "type": "inlineReview"}, {"oid": "a62205ac96da9c7737d29f51a1cd1737371a1512", "url": "https://github.com/apache/phoenix/commit/a62205ac96da9c7737d29f51a1cd1737371a1512", "message": "PHOENIX-6032: When phoenix.allow.system.catalog.rollback=true, a view still sees data from a column that was dropped", "committedDate": "2020-11-02T22:47:15Z", "type": "forcePushed"}, {"oid": "a62205ac96da9c7737d29f51a1cd1737371a1512", "url": "https://github.com/apache/phoenix/commit/a62205ac96da9c7737d29f51a1cd1737371a1512", "message": "PHOENIX-6032: When phoenix.allow.system.catalog.rollback=true, a view still sees data from a column that was dropped", "committedDate": "2020-11-02T22:47:15Z", "type": "commit"}]}