{"pr_number": 750, "pr_title": "PHOENIX-5799 - Inline Index Verification Output API", "pr_createdAt": "2020-04-01T00:10:34Z", "pr_url": "https://github.com/apache/phoenix/pull/750", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MDg3MA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r401950870", "bodyText": "How these two repositories differ from each other? Could the names be more explicit?", "author": "swaroopak", "createdAt": "2020-04-01T22:38:01Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -154,6 +143,8 @@\n     private int  singleRowRebuildReturnCode;\n     private Map<byte[], NavigableSet<byte[]>> familyMap;\n     private byte[][] viewConstants;\n+    private IndexVerificationResultRepository verificationResultRepository;", "originalCommit": "08f957046b0bbcd019a870ee77bb75850bcafe4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk3ODU2OQ==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r401978569", "bodyText": "Each repo controls insert/select operations for a particular table: the result table (PHOENIX_INDEX_TOOL_RESULT) that stores summary information about the run (counters, etc), and the output table (PHOENIX_INDEX_TOOL) that contains the row-level information about the failed rows.\nPlease let me know if you have suggestions on clearer names.\n(The word \"Repository\", btw, is the name of the design pattern being used -- https://martinfowler.com/eaaCatalog/repository.html , from Martin Fowler's Patterns of Enterprise Architecture and Eric Evans' Domain Driven Design)", "author": "gjacoby126", "createdAt": "2020-04-02T00:01:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1MDg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MzcwMA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402643700", "bodyText": "Should not this be called IndexVerificationResultRepositoryIT?", "author": "kadirozde", "createdAt": "2020-04-02T22:58:42Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationResultRepositoryTest.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end.index;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.end2end.ParallelStatsDisabledIT;\n+import org.apache.phoenix.mapreduce.index.IndexTool;\n+import org.apache.phoenix.mapreduce.index.IndexVerificationResultRepository;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+\n+public class IndexVerificationResultRepositoryTest extends ParallelStatsDisabledIT {", "originalCommit": "e0ada5b0b339d381874e422ad0588fece35cc764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1Njc1NA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402656754", "bodyText": "Fair point. It's sort of between a true unit test and an IT, because it needs a minicluster but is exercising a particular class rather than something broader. I'll change the names.", "author": "gjacoby126", "createdAt": "2020-04-02T23:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MzcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0NDI2MA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402744260", "bodyText": "Fixed", "author": "gjacoby126", "createdAt": "2020-04-03T05:28:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0MzcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0NDc0NA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402644744", "bodyText": "Should not this be called IndexVerificationOutputRepositoryIT?", "author": "kadirozde", "createdAt": "2020-04-02T23:01:34Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/index/IndexVerificationOutputRepositoryTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.end2end.index;\n+\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.end2end.ParallelStatsDisabledIT;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository;\n+import org.apache.phoenix.mapreduce.index.IndexVerificationOutputRow;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.ReadOnlyProps;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.SQLException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.PHASE_AFTER_VALUE;\n+import static org.apache.phoenix.mapreduce.index.IndexVerificationOutputRepository.PHASE_BEFORE_VALUE;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class IndexVerificationOutputRepositoryTest extends ParallelStatsDisabledIT {", "originalCommit": "e0ada5b0b339d381874e422ad0588fece35cc764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjc0NDI5NA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402744294", "bodyText": "Fixed", "author": "gjacoby126", "createdAt": "2020-04-03T05:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY0NDc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MjUwOA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402652508", "bodyText": "Is this class is used only for IT? If so, it should not be under src/main, should it?", "author": "kadirozde", "createdAt": "2020-04-02T23:25:16Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class IndexVerificationOutputRow {", "originalCommit": "e0ada5b0b339d381874e422ad0588fece35cc764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1NzI1Mg==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402657252", "bodyText": "The purpose of the patch is to expose the output row and repo classes so they can be used both for tests and also externally in tools that programmatically query and analyze the output table. So it needs to be in main.", "author": "gjacoby126", "createdAt": "2020-04-02T23:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MjUwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5MzEzOA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r402693138", "bodyText": "It makes sense. Thx", "author": "kadirozde", "createdAt": "2020-04-03T01:51:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY1MjUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4MzM2OA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r403383368", "bodyText": "Do we need this constructor? I see that read (non static)methods make use of outputHTable which would not work with an instance created through this.", "author": "abhishek-chouhan", "createdAt": "2020-04-03T23:31:18Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.hbase.HColumnDescriptor;\n+import org.apache.hadoop.hbase.HTableDescriptor;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.MetaDataProtocol;\n+import org.apache.phoenix.hbase.index.table.HTableFactory;\n+import org.apache.phoenix.hbase.index.util.ImmutableBytesPtr;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.ConnectionQueryServices;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.util.ByteUtil;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public class IndexVerificationOutputRepository {\n+    public static final byte[] ROW_KEY_SEPARATOR_BYTE = Bytes.toBytes(\"|\");\n+    private Table indexHTable;\n+    private byte[] indexName;\n+    private Table outputHTable;\n+    public final static String OUTPUT_TABLE_NAME = \"PHOENIX_INDEX_TOOL\";\n+    public final static byte[] OUTPUT_TABLE_NAME_BYTES = Bytes.toBytes(OUTPUT_TABLE_NAME);\n+    public final static byte[] OUTPUT_TABLE_COLUMN_FAMILY = QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES;\n+\n+    public final static String DATA_TABLE_NAME = \"DTName\";\n+    public final static byte[] DATA_TABLE_NAME_BYTES = Bytes.toBytes(DATA_TABLE_NAME);\n+    public static String INDEX_TABLE_NAME = \"ITName\";\n+    public final static byte[] INDEX_TABLE_NAME_BYTES = Bytes.toBytes(INDEX_TABLE_NAME);\n+    public static String DATA_TABLE_ROW_KEY = \"DTRowKey\";\n+    public final static byte[] DATA_TABLE_ROW_KEY_BYTES = Bytes.toBytes(DATA_TABLE_ROW_KEY);\n+    public static String INDEX_TABLE_ROW_KEY = \"ITRowKey\";\n+    public final static byte[] INDEX_TABLE_ROW_KEY_BYTES = Bytes.toBytes(INDEX_TABLE_ROW_KEY);\n+    public static String DATA_TABLE_TS = \"DTTS\";\n+    public final static byte[] DATA_TABLE_TS_BYTES = Bytes.toBytes(DATA_TABLE_TS);\n+    public static String INDEX_TABLE_TS = \"ITTS\";\n+    public final static byte[] INDEX_TABLE_TS_BYTES = Bytes.toBytes(INDEX_TABLE_TS);\n+    public static String ERROR_MESSAGE = \"Error\";\n+    public final static byte[] ERROR_MESSAGE_BYTES = Bytes.toBytes(ERROR_MESSAGE);\n+\n+    public static String  VERIFICATION_PHASE = \"Phase\";\n+    public final static byte[] VERIFICATION_PHASE_BYTES = Bytes.toBytes(VERIFICATION_PHASE);\n+    public final static String EXPECTED_VALUE = \"ExpectedValue\";\n+    public final static byte[] EXPECTED_VALUE_BYTES = Bytes.toBytes(EXPECTED_VALUE);\n+    public final static String ACTUAL_VALUE = \"ActualValue\";\n+    public final static byte[] ACTUAL_VALUE_BYTES = Bytes.toBytes(ACTUAL_VALUE);\n+    public static final byte[] E_VALUE_PREFIX_BYTES = Bytes.toBytes(\" E:\");\n+    public static final byte[] A_VALUE_PREFIX_BYTES = Bytes.toBytes(\" A:\");\n+    public static final int PREFIX_LENGTH = 3;\n+    public static final int TOTAL_PREFIX_LENGTH = 6;\n+    public static final byte[] PHASE_BEFORE_VALUE = Bytes.toBytes(\"BEFORE\");\n+    public static final byte[] PHASE_AFTER_VALUE = Bytes.toBytes(\"AFTER\");\n+\n+    /**\n+     * Only usable for the read path or for testing\n+     */\n+    public IndexVerificationOutputRepository(){", "originalCommit": "0a8196474136ee0ab23312a378be2a650f06ca54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMjYwNg==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r404312606", "bodyText": "The constructor's needed for a case in IndexTool where we're just creating the tables but not reading or writing the tables. I've added setters so that a developer can use the default constructor and still write after using the setters. Is that sufficient?", "author": "gjacoby126", "createdAt": "2020-04-06T18:48:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4MzM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NDcxMw==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r403384713", "bodyText": "Should we close indexHTable too?", "author": "abhishek-chouhan", "createdAt": "2020-04-03T23:37:26Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRepository.java", "diffHunk": "@@ -0,0 +1,285 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.hbase.HColumnDescriptor;\n+import org.apache.hadoop.hbase.HTableDescriptor;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.MetaDataProtocol;\n+import org.apache.phoenix.hbase.index.table.HTableFactory;\n+import org.apache.phoenix.hbase.index.util.ImmutableBytesPtr;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.ConnectionQueryServices;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.util.ByteUtil;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public class IndexVerificationOutputRepository {\n+    public static final byte[] ROW_KEY_SEPARATOR_BYTE = Bytes.toBytes(\"|\");\n+    private Table indexHTable;\n+    private byte[] indexName;\n+    private Table outputHTable;\n+    public final static String OUTPUT_TABLE_NAME = \"PHOENIX_INDEX_TOOL\";\n+    public final static byte[] OUTPUT_TABLE_NAME_BYTES = Bytes.toBytes(OUTPUT_TABLE_NAME);\n+    public final static byte[] OUTPUT_TABLE_COLUMN_FAMILY = QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES;\n+\n+    public final static String DATA_TABLE_NAME = \"DTName\";\n+    public final static byte[] DATA_TABLE_NAME_BYTES = Bytes.toBytes(DATA_TABLE_NAME);\n+    public static String INDEX_TABLE_NAME = \"ITName\";\n+    public final static byte[] INDEX_TABLE_NAME_BYTES = Bytes.toBytes(INDEX_TABLE_NAME);\n+    public static String DATA_TABLE_ROW_KEY = \"DTRowKey\";\n+    public final static byte[] DATA_TABLE_ROW_KEY_BYTES = Bytes.toBytes(DATA_TABLE_ROW_KEY);\n+    public static String INDEX_TABLE_ROW_KEY = \"ITRowKey\";\n+    public final static byte[] INDEX_TABLE_ROW_KEY_BYTES = Bytes.toBytes(INDEX_TABLE_ROW_KEY);\n+    public static String DATA_TABLE_TS = \"DTTS\";\n+    public final static byte[] DATA_TABLE_TS_BYTES = Bytes.toBytes(DATA_TABLE_TS);\n+    public static String INDEX_TABLE_TS = \"ITTS\";\n+    public final static byte[] INDEX_TABLE_TS_BYTES = Bytes.toBytes(INDEX_TABLE_TS);\n+    public static String ERROR_MESSAGE = \"Error\";\n+    public final static byte[] ERROR_MESSAGE_BYTES = Bytes.toBytes(ERROR_MESSAGE);\n+\n+    public static String  VERIFICATION_PHASE = \"Phase\";\n+    public final static byte[] VERIFICATION_PHASE_BYTES = Bytes.toBytes(VERIFICATION_PHASE);\n+    public final static String EXPECTED_VALUE = \"ExpectedValue\";\n+    public final static byte[] EXPECTED_VALUE_BYTES = Bytes.toBytes(EXPECTED_VALUE);\n+    public final static String ACTUAL_VALUE = \"ActualValue\";\n+    public final static byte[] ACTUAL_VALUE_BYTES = Bytes.toBytes(ACTUAL_VALUE);\n+    public static final byte[] E_VALUE_PREFIX_BYTES = Bytes.toBytes(\" E:\");\n+    public static final byte[] A_VALUE_PREFIX_BYTES = Bytes.toBytes(\" A:\");\n+    public static final int PREFIX_LENGTH = 3;\n+    public static final int TOTAL_PREFIX_LENGTH = 6;\n+    public static final byte[] PHASE_BEFORE_VALUE = Bytes.toBytes(\"BEFORE\");\n+    public static final byte[] PHASE_AFTER_VALUE = Bytes.toBytes(\"AFTER\");\n+\n+    /**\n+     * Only usable for the read path or for testing\n+     */\n+    public IndexVerificationOutputRepository(){\n+\n+    }\n+\n+    @VisibleForTesting\n+    public IndexVerificationOutputRepository(byte[] indexName, Connection conn) throws SQLException {\n+        ConnectionQueryServices queryServices =\n+            conn.unwrap(PhoenixConnection.class).getQueryServices();\n+        outputHTable = queryServices.getTable(OUTPUT_TABLE_NAME_BYTES);\n+        indexHTable = queryServices.getTable(indexName);\n+    }\n+\n+    public IndexVerificationOutputRepository(byte[] indexName, HTableFactory hTableFactory) throws IOException {\n+        this.indexName = indexName;\n+        outputHTable = hTableFactory.getTable(new ImmutableBytesPtr(OUTPUT_TABLE_NAME_BYTES));\n+        indexHTable = hTableFactory.getTable(new ImmutableBytesPtr(indexName));\n+    }\n+\n+    public static byte[] generateOutputTableRowKey(long ts, byte[] indexTableName, byte[] dataRowKey ) {\n+        byte[] keyPrefix = Bytes.toBytes(Long.toString(ts));\n+        byte[] rowKey;\n+        int targetOffset = 0;\n+        // The row key for the output table : timestamp | index table name | data row key\n+        rowKey = new byte[keyPrefix.length + ROW_KEY_SEPARATOR_BYTE.length + indexTableName.length +\n+            ROW_KEY_SEPARATOR_BYTE.length + dataRowKey.length];\n+        Bytes.putBytes(rowKey, targetOffset, keyPrefix, 0, keyPrefix.length);\n+        targetOffset += keyPrefix.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, indexTableName, 0, indexTableName.length);\n+        targetOffset += indexTableName.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, dataRowKey, 0, dataRowKey.length);\n+        return rowKey;\n+    }\n+\n+    /**\n+     * Generates partial row key for use in a Scan to get all rows for an index verification\n+     */\n+    private static byte[] generatePartialOutputTableRowKey(long ts, byte[] indexTableName){\n+        byte[] keyPrefix = Bytes.toBytes(Long.toString(ts));\n+        byte[] partialRowKey;\n+        int targetOffset = 0;\n+        // The row key for the output table : timestamp | index table name | data row key\n+        partialRowKey = new byte[keyPrefix.length + ROW_KEY_SEPARATOR_BYTE.length + indexTableName.length];\n+        Bytes.putBytes(partialRowKey, targetOffset, keyPrefix, 0, keyPrefix.length);\n+        targetOffset += keyPrefix.length;\n+        Bytes.putBytes(partialRowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(partialRowKey, targetOffset, indexTableName, 0, indexTableName.length);\n+        return partialRowKey;\n+    }\n+\n+    public void createOutputTable(Connection connection) throws IOException, SQLException {\n+        ConnectionQueryServices queryServices = connection.unwrap(PhoenixConnection.class).getQueryServices();\n+        Admin admin = queryServices.getAdmin();\n+        if (!admin.tableExists(TableName.valueOf(OUTPUT_TABLE_NAME))) {\n+            HTableDescriptor tableDescriptor = new\n+                HTableDescriptor(TableName.valueOf(OUTPUT_TABLE_NAME));\n+            tableDescriptor.setValue(HColumnDescriptor.TTL,\n+                String.valueOf(MetaDataProtocol.DEFAULT_LOG_TTL));\n+            HColumnDescriptor columnDescriptor = new HColumnDescriptor(OUTPUT_TABLE_COLUMN_FAMILY);\n+            tableDescriptor.addFamily(columnDescriptor);\n+            admin.createTable(tableDescriptor);\n+        }\n+    }\n+        \n+    @VisibleForTesting\n+    public void logToIndexToolOutputTable(byte[] dataRowKey, byte[] indexRowKey, long dataRowTs,\n+                                          long indexRowTs,\n+                                          String errorMsg, byte[] expectedValue, byte[] actualValue,\n+                                          long scanMaxTs, byte[] tableName, boolean isBeforeRebuild)\n+        throws IOException {\n+        byte[] rowKey = generateOutputTableRowKey(scanMaxTs, indexHTable.getName().toBytes(), dataRowKey);\n+        Put put = new Put(rowKey);\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, DATA_TABLE_NAME_BYTES,\n+            scanMaxTs, tableName);\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, INDEX_TABLE_NAME_BYTES,\n+            scanMaxTs, indexName);\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, DATA_TABLE_TS_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(dataRowTs)));\n+\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, INDEX_TABLE_ROW_KEY_BYTES,\n+            scanMaxTs, indexRowKey);\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, INDEX_TABLE_TS_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(indexRowTs)));\n+        byte[] errorMessageBytes;\n+        if (expectedValue != null) {\n+            errorMessageBytes = getErrorMessageBytes(errorMsg, expectedValue, actualValue);\n+            put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, EXPECTED_VALUE_BYTES, expectedValue);\n+            put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, ACTUAL_VALUE_BYTES, actualValue);\n+        } else {\n+            errorMessageBytes = Bytes.toBytes(errorMsg);\n+        }\n+        put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, ERROR_MESSAGE_BYTES, scanMaxTs, errorMessageBytes);\n+        if (isBeforeRebuild) {\n+            put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, VERIFICATION_PHASE_BYTES, scanMaxTs, PHASE_BEFORE_VALUE);\n+        } else {\n+            put.addColumn(OUTPUT_TABLE_COLUMN_FAMILY, VERIFICATION_PHASE_BYTES, scanMaxTs, PHASE_AFTER_VALUE);\n+        }\n+        outputHTable.put(put);\n+    }\n+\n+    public static byte[] getErrorMessageBytes(String errorMsg, byte[] expectedValue, byte[] actualValue) {\n+        byte[] errorMessageBytes;\n+        errorMessageBytes = new byte[errorMsg.length() + expectedValue.length + actualValue.length +\n+            TOTAL_PREFIX_LENGTH];\n+        Bytes.putBytes(errorMessageBytes, 0, Bytes.toBytes(errorMsg), 0, errorMsg.length());\n+        int length = errorMsg.length();\n+        Bytes.putBytes(errorMessageBytes, length, E_VALUE_PREFIX_BYTES, 0, PREFIX_LENGTH);\n+        length += PREFIX_LENGTH;\n+        Bytes.putBytes(errorMessageBytes, length, expectedValue, 0, expectedValue.length);\n+        length += expectedValue.length;\n+        Bytes.putBytes(errorMessageBytes, length, A_VALUE_PREFIX_BYTES, 0, PREFIX_LENGTH);\n+        length += PREFIX_LENGTH;\n+        Bytes.putBytes(errorMessageBytes, length, actualValue, 0, actualValue.length);\n+        return errorMessageBytes;\n+    }\n+\n+    public List<IndexVerificationOutputRow> getOutputRows(long ts, byte[] indexName)\n+        throws IOException {\n+        Iterator<IndexVerificationOutputRow> iter = getOutputRowIterator(ts, indexName);\n+        List<IndexVerificationOutputRow> outputRowList = new ArrayList<IndexVerificationOutputRow>();\n+        while (iter.hasNext()){\n+            outputRowList.add(iter.next());\n+        }\n+        return outputRowList;\n+    }\n+\n+    public Iterator<IndexVerificationOutputRow> getOutputRowIterator(long ts, byte[] indexName)\n+        throws IOException {\n+        Scan scan = new Scan();\n+        byte[] partialKey = generatePartialOutputTableRowKey(ts, indexName);\n+        scan.withStartRow(partialKey);\n+        scan.withStopRow(ByteUtil.calculateTheClosestNextRowKeyForPrefix(partialKey));\n+        ResultScanner scanner = outputHTable.getScanner(scan);\n+        return new IndexVerificationOutputRowIterator(scanner.iterator());\n+    }\n+\n+    public static IndexVerificationOutputRow getOutputRowFromResult(Result result) {\n+        IndexVerificationOutputRow.IndexVerificationOutputRowBuilder builder =\n+            new IndexVerificationOutputRow.IndexVerificationOutputRowBuilder();\n+        byte[] rowKey = result.getRow();\n+        //rowkey is scanTs + SEPARATOR_BYTE + indexTableName + SEPARATOR_BYTE + dataTableRowKey\n+        byte[][] rowKeySplit = ByteUtil.splitArrayBySeparator(rowKey, ROW_KEY_SEPARATOR_BYTE[0]);\n+        builder.setScanMaxTimestamp(Long.parseLong(Bytes.toString(rowKeySplit[0])));\n+        builder.setIndexTableName(Bytes.toString(rowKeySplit[1]));\n+        builder.setDataTableRowKey(rowKeySplit[2]);\n+\n+        builder.setDataTableName(Bytes.toString(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY,\n+            DATA_TABLE_NAME_BYTES)));\n+        builder.setIndexTableRowKey(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY,\n+            INDEX_TABLE_ROW_KEY_BYTES));\n+        builder.setDataTableRowTimestamp(Long.parseLong(Bytes.toString(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY,\n+            DATA_TABLE_TS_BYTES))));\n+        builder.setIndexTableRowTimestamp(Long.parseLong(Bytes.toString(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY,\n+            INDEX_TABLE_TS_BYTES))));\n+        builder.setErrorMessage(Bytes.toString(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY,\n+            ERROR_MESSAGE_BYTES)));\n+        //actual and expected value might not be present, but will just set to null if not\n+        builder.setExpectedValue(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY, EXPECTED_VALUE_BYTES));\n+        builder.setActualValue(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY, ACTUAL_VALUE_BYTES));\n+        builder.setPhaseValue(result.getValue(OUTPUT_TABLE_COLUMN_FAMILY, VERIFICATION_PHASE_BYTES));\n+        return builder.build();\n+    }\n+\n+    public void close() throws IOException {\n+        if (outputHTable != null) {\n+            outputHTable.close();\n+        }", "originalCommit": "0a8196474136ee0ab23312a378be2a650f06ca54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMDU4Mg==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r404310582", "bodyText": "Good catch, thanks. Done.", "author": "gjacoby126", "createdAt": "2020-04-06T18:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NzAwNw==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r403387007", "bodyText": "Check for indexHtable and close here too?", "author": "abhishek-chouhan", "createdAt": "2020-04-03T23:48:06Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationResultRepository.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.HColumnDescriptor;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HTableDescriptor;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.coprocessor.MetaDataProtocol;\n+import org.apache.phoenix.hbase.index.table.HTableFactory;\n+import org.apache.phoenix.hbase.index.util.ImmutableBytesPtr;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.mapreduce.index.IndexTool;\n+import org.apache.phoenix.query.ConnectionQueryServices;\n+import org.apache.phoenix.query.QueryConstants;\n+import org.apache.phoenix.util.ByteUtil;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+\n+public class IndexVerificationResultRepository {\n+    private Table resultHTable;\n+    private Table indexHTable;\n+    public static final byte[] ROW_KEY_SEPARATOR_BYTE = Bytes.toBytes(\"|\");\n+    public final static String RESULT_TABLE_NAME = \"PHOENIX_INDEX_TOOL_RESULT\";\n+    public final static byte[] RESULT_TABLE_NAME_BYTES = Bytes.toBytes(RESULT_TABLE_NAME);\n+    public final static byte[] RESULT_TABLE_COLUMN_FAMILY = QueryConstants.DEFAULT_COLUMN_FAMILY_BYTES;\n+    public static String SCANNED_DATA_ROW_COUNT = \"ScannedDataRowCount\";\n+    public final static byte[] SCANNED_DATA_ROW_COUNT_BYTES = Bytes.toBytes(SCANNED_DATA_ROW_COUNT);\n+    public static String REBUILT_INDEX_ROW_COUNT = \"RebuiltIndexRowCount\";\n+    public final static byte[] REBUILT_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(REBUILT_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_VALID_INDEX_ROW_COUNT = \"BeforeRebuildValidIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_VALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_VALID_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT = \"BeforeRebuildExpiredIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT = \"BeforeRebuildMissingIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT);\n+    public static String BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT = \"BeforeRebuildInvalidIndexRowCount\";\n+    public final static byte[] BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_VALID_INDEX_ROW_COUNT = \"AfterValidExpiredIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_VALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_VALID_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT = \"AfterRebuildExpiredIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_MISSING_INDEX_ROW_COUNT = \"AfterRebuildMissingIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_MISSING_INDEX_ROW_COUNT);\n+    public static String AFTER_REBUILD_INVALID_INDEX_ROW_COUNT = \"AfterRebuildInvalidIndexRowCount\";\n+    public final static byte[] AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES = Bytes.toBytes(AFTER_REBUILD_INVALID_INDEX_ROW_COUNT);\n+    /***\n+     * Only usable for read methods\n+     */\n+    public IndexVerificationResultRepository(){\n+\n+    }\n+\n+    public IndexVerificationResultRepository(Connection conn, byte[] indexNameBytes) throws SQLException {\n+        resultHTable = getTable(conn, RESULT_TABLE_NAME_BYTES);\n+        indexHTable = getTable(conn, indexNameBytes);\n+    }\n+\n+    public IndexVerificationResultRepository(byte[] indexName,\n+                                             HTableFactory hTableFactory) throws IOException {\n+        resultHTable = hTableFactory.getTable(new ImmutableBytesPtr(RESULT_TABLE_NAME_BYTES));\n+        indexHTable = hTableFactory.getTable(new ImmutableBytesPtr(indexName));\n+    }\n+\n+    public void createResultTable(Connection connection) throws IOException, SQLException {\n+        ConnectionQueryServices queryServices = connection.unwrap(PhoenixConnection.class).getQueryServices();\n+        Admin admin = queryServices.getAdmin();\n+\n+        if (!admin.tableExists(TableName.valueOf(RESULT_TABLE_NAME))) {\n+            HTableDescriptor tableDescriptor = new\n+                HTableDescriptor(TableName.valueOf(RESULT_TABLE_NAME));\n+            tableDescriptor.setValue(HColumnDescriptor.TTL, String.valueOf(MetaDataProtocol.DEFAULT_LOG_TTL));\n+            HColumnDescriptor columnDescriptor = new HColumnDescriptor(RESULT_TABLE_COLUMN_FAMILY);\n+            tableDescriptor.addFamily(columnDescriptor);\n+            admin.createTable(tableDescriptor);\n+        }\n+    }\n+    public static byte[] generateResultTableRowKey(long ts, byte[] indexTableName,  byte [] regionName,\n+                                                    byte[] startRow, byte[] stopRow) {\n+        byte[] keyPrefix = Bytes.toBytes(Long.toString(ts));\n+        int targetOffset = 0;\n+        // The row key for the result table : timestamp | index table name | datable table region name |\n+        //                                    scan start row | scan stop row\n+        byte[] rowKey = new byte[keyPrefix.length + ROW_KEY_SEPARATOR_BYTE.length + indexTableName.length +\n+            ROW_KEY_SEPARATOR_BYTE.length + regionName.length + ROW_KEY_SEPARATOR_BYTE.length +\n+            startRow.length + ROW_KEY_SEPARATOR_BYTE.length + stopRow.length];\n+        Bytes.putBytes(rowKey, targetOffset, keyPrefix, 0, keyPrefix.length);\n+        targetOffset += keyPrefix.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, indexTableName, 0, indexTableName.length);\n+        targetOffset += indexTableName.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, regionName, 0, regionName.length);\n+        targetOffset += regionName.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, startRow, 0, startRow.length);\n+        targetOffset += startRow.length;\n+        Bytes.putBytes(rowKey, targetOffset, ROW_KEY_SEPARATOR_BYTE, 0, ROW_KEY_SEPARATOR_BYTE.length);\n+        targetOffset += ROW_KEY_SEPARATOR_BYTE.length;\n+        Bytes.putBytes(rowKey, targetOffset, stopRow, 0, stopRow.length);\n+        return rowKey;\n+    }\n+\n+    public void logToIndexToolResultTable(IndexToolVerificationResult verificationResult,\n+                                          IndexTool.IndexVerifyType verifyType, byte[] region) throws IOException {\n+        long scanMaxTs = verificationResult.getScanMaxTs();\n+        byte[] rowKey = generateResultTableRowKey(scanMaxTs, indexHTable.getName().toBytes(),\n+            region, verificationResult.getStartRow(),\n+            verificationResult.getStopRow());\n+        Put put = new Put(rowKey);\n+        put.addColumn(RESULT_TABLE_COLUMN_FAMILY, SCANNED_DATA_ROW_COUNT_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getScannedDataRowCount())));\n+        put.addColumn(RESULT_TABLE_COLUMN_FAMILY, REBUILT_INDEX_ROW_COUNT_BYTES,\n+            scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getRebuiltIndexRowCount())));\n+        if (verifyType == IndexTool.IndexVerifyType.BEFORE || verifyType == IndexTool.IndexVerifyType.BOTH ||\n+            verifyType == IndexTool.IndexVerifyType.ONLY) {\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_VALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildValidIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildExpiredIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildMissingIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getBeforeRebuildInvalidIndexRowCount())));\n+        }\n+        if (verifyType == IndexTool.IndexVerifyType.AFTER || verifyType == IndexTool.IndexVerifyType.BOTH) {\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_VALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildValidIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildExpiredIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildMissingIndexRowCount())));\n+            put.addColumn(RESULT_TABLE_COLUMN_FAMILY, AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES,\n+                scanMaxTs, Bytes.toBytes(Long.toString(verificationResult.getAfterRebuildInvalidIndexRowCount())));\n+        }\n+        resultHTable.put(put);\n+    }\n+\n+    public IndexToolVerificationResult getVerificationResult(Connection conn, long ts) throws IOException, SQLException {\n+        Table hTable = getTable(conn, RESULT_TABLE_NAME_BYTES);\n+        return getVerificationResult(hTable, ts);\n+    }\n+\n+    public Table getTable(Connection conn, byte[] tableName) throws SQLException {\n+        return conn.unwrap(PhoenixConnection.class).getQueryServices()\n+                .getTable(tableName);\n+    }\n+\n+    public IndexToolVerificationResult getVerificationResult(Table htable, long ts)\n+        throws IOException {\n+        byte[] startRowKey = Bytes.toBytes(Long.toString(ts));\n+        byte[] stopRowKey = ByteUtil.calculateTheClosestNextRowKeyForPrefix(startRowKey);\n+        IndexToolVerificationResult verificationResult = new IndexToolVerificationResult(ts);\n+        Scan scan = new Scan();\n+        scan.withStartRow(startRowKey);\n+        scan.withStopRow(stopRowKey);\n+        ResultScanner scanner = htable.getScanner(scan);\n+        for (Result result = scanner.next(); result != null; result = scanner.next()) {\n+            boolean isFirst = true;\n+            for (Cell cell : result.rawCells()) {\n+                if (isFirst){\n+                    byte[][] rowKeyParts = ByteUtil.splitArrayBySeparator(result.getRow(),\n+                        ROW_KEY_SEPARATOR_BYTE[0]);\n+                    verificationResult.setStartRow(rowKeyParts[3]);\n+                    verificationResult.setStopRow(rowKeyParts[4]);\n+                    isFirst = false;\n+                }\n+                verificationResult.update(cell);\n+            }\n+        }\n+        return verificationResult;\n+    }\n+\n+    public void close() throws IOException {\n+        if (resultHTable != null) {", "originalCommit": "0a8196474136ee0ab23312a378be2a650f06ca54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMDY3MA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r404310670", "bodyText": "Done.", "author": "gjacoby126", "createdAt": "2020-04-06T18:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NzAwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwNDczMA==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r403404730", "bodyText": "Why not reuse the same strings from table values? like DTName, ITName. Would be easier to track and reuse.", "author": "swaroopak", "createdAt": "2020-04-04T01:25:40Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/mapreduce/index/IndexVerificationOutputRow.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.mapreduce.index;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class IndexVerificationOutputRow {\n+    private String dataTableName;\n+    private String indexTableName;\n+    private Long scanMaxTimestamp;\n+    private byte[] dataTableRowKey;\n+    private byte[] indexTableRowKey;\n+    private Long dataTableRowTimestamp;\n+    private Long indexTableRowTimestamp;\n+    private String errorMessage;\n+    private byte[] expectedValue;\n+    private byte[] actualValue;\n+    private byte[] phaseValue;\n+\n+    private IndexVerificationOutputRow(String dataTableName, String indexTableName,\n+                                       byte[] dataTableRowKey, Long scanMaxTimestamp,\n+                                      byte[] indexTableRowKey,\n+                                       long dataTableRowTimestamp, long indexTableRowTimestamp,\n+                                      String errorMessage, byte[] expectedValue, byte[] actualValue,\n+                                      byte[] phaseValue) {\n+        this.dataTableName = dataTableName;\n+        this.indexTableName = indexTableName;\n+        this.scanMaxTimestamp = scanMaxTimestamp;\n+        this.dataTableRowKey = dataTableRowKey;\n+        this.indexTableRowKey = indexTableRowKey;\n+        this.dataTableRowTimestamp = dataTableRowTimestamp;\n+        this.indexTableRowTimestamp = indexTableRowTimestamp;\n+        this.errorMessage = errorMessage;\n+        this.expectedValue = expectedValue;\n+        this.actualValue = actualValue;\n+        this.phaseValue = phaseValue;\n+    }\n+\n+    public String getDataTableName() {\n+        return dataTableName;\n+    }\n+\n+    public String getIndexTableName() {\n+        return indexTableName;\n+    }\n+\n+    public Long getScanMaxTimestamp() {\n+        return scanMaxTimestamp;\n+    }\n+\n+    public byte[] getIndexTableRowKey() {\n+        return indexTableRowKey;\n+    }\n+\n+    public long getIndexTableRowTimestamp() {\n+        return indexTableRowTimestamp;\n+    }\n+\n+    public String getErrorMessage() {\n+        return errorMessage;\n+    }\n+\n+    public byte[] getExpectedValue() {\n+        return expectedValue;\n+    }\n+\n+    public byte[] getActualValue() {\n+        return actualValue;\n+    }\n+\n+    public byte[] getPhaseValue() {\n+        return phaseValue;\n+    }\n+\n+    public byte[] getDataTableRowKey() {\n+        return dataTableRowKey;\n+    }\n+\n+    public Long getDataTableRowTimestamp() {\n+        return dataTableRowTimestamp;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (o == null ) {\n+            return false;\n+        }\n+        if (!(o instanceof  IndexVerificationOutputRow)) {\n+            return false;\n+        }\n+        IndexVerificationOutputRow otherRow = (IndexVerificationOutputRow) o;\n+\n+        return Objects.equals(dataTableName, otherRow.getDataTableName()) &&\n+            Objects.equals(indexTableName, otherRow.getIndexTableName()) &&\n+            Objects.equals(scanMaxTimestamp, otherRow.getScanMaxTimestamp()) &&\n+            Arrays.equals(dataTableRowKey, otherRow.getDataTableRowKey()) &&\n+            Arrays.equals(indexTableRowKey, otherRow.getIndexTableRowKey()) &&\n+            Objects.equals(dataTableRowTimestamp, otherRow.getDataTableRowTimestamp()) &&\n+            Objects.equals(indexTableRowTimestamp, otherRow.getIndexTableRowTimestamp()) &&\n+            Objects.equals(errorMessage, otherRow.getErrorMessage()) &&\n+            Arrays.equals(expectedValue, otherRow.getExpectedValue()) &&\n+            Arrays.equals(actualValue, otherRow.getActualValue()) &&\n+            Arrays.equals(phaseValue, otherRow.getPhaseValue());\n+    }\n+\n+    @Override\n+    public int hashCode(){\n+        return Objects.hashCode(scanMaxTimestamp) ^ Objects.hashCode(indexTableName) ^\n+            Arrays.hashCode(dataTableRowKey);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"DataTableName: \").append(dataTableName).append(\",\");", "originalCommit": "0a8196474136ee0ab23312a378be2a650f06ca54", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDMxMDgwOQ==", "url": "https://github.com/apache/phoenix/pull/750#discussion_r404310809", "bodyText": "Good idea. Done.", "author": "gjacoby126", "createdAt": "2020-04-06T18:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwNDczMA=="}], "type": "inlineReview"}, {"oid": "df24ffd03a3934efb86102b250285adcd5bf060f", "url": "https://github.com/apache/phoenix/commit/df24ffd03a3934efb86102b250285adcd5bf060f", "message": "PHOENIX-5799 - Inline Index Verification Output API", "committedDate": "2020-04-07T22:24:53Z", "type": "commit"}, {"oid": "df24ffd03a3934efb86102b250285adcd5bf060f", "url": "https://github.com/apache/phoenix/commit/df24ffd03a3934efb86102b250285adcd5bf060f", "message": "PHOENIX-5799 - Inline Index Verification Output API", "committedDate": "2020-04-07T22:24:53Z", "type": "forcePushed"}]}