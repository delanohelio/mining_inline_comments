{"pr_number": 995, "pr_title": "PHOENIX-6200 Add counters for extra index rows, log results to PIT and PIT_RESULT table", "pr_createdAt": "2020-12-01T22:48:25Z", "pr_url": "https://github.com/apache/phoenix/pull/995", "timeline": [{"oid": "1cdfa882003afaaf2365020fbd7405d02ca5541b", "url": "https://github.com/apache/phoenix/commit/1cdfa882003afaaf2365020fbd7405d02ca5541b", "message": "PHOENIX-6200 Add counters for extra index rows, log results to PIT and PIT_RESULT table", "committedDate": "2020-12-01T22:15:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1Mzc5Mw==", "url": "https://github.com/apache/phoenix/pull/995#discussion_r534353793", "bodyText": "I recommend having a contains rather than equals here. Sometimes we enhance the error messages.", "author": "gokceni", "createdAt": "2020-12-02T17:34:16Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexRepairRegionScannerIT.java", "diffHunk": "@@ -163,35 +308,251 @@ public void testRepairExtraIndexRows() throws Exception {\n         String indexTableName = generateUniqueName();\n         String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n         Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            // do index rebuild without -fi and check with scrutiny that index tool failed to fix the extra rows\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE);\n+\n+            boolean failed;\n+            try {\n+                IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+                failed = false;\n+            } catch (AssertionError e) {\n+                failed = true;\n+            }\n+            assertTrue(failed);\n+\n+            // now repair the index with -fi\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+\n+            assertExtraCounters(indexTool, NROWS, 0, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_overwrite() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n-                    + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \"\n-                    + tableDDLOptions);\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n             PreparedStatement dataPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n             for (int i = 1; i <= NROWS; i++) {\n                 dataPreparedStatement.setInt(1, i);\n                 dataPreparedStatement.setInt(2, i + 1);\n                 dataPreparedStatement.setInt(3, i * 2);\n                 dataPreparedStatement.execute();\n             }\n             conn.commit();\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"UPSERT INTO \" + dataTableFullName + \" VALUES(3, 100, 200)\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_delete() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n             conn.createStatement().execute(String.format(\n-                    \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n-            // Add extra index rows\n-            PreparedStatement indexPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + indexTableFullName + \" VALUES(?,?,?)\");\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n \n-            for (int i = NROWS + 1; i <= 2 * NROWS; i++) {\n-                indexPreparedStatement.setInt(1, i + 1); // the indexed column\n-                indexPreparedStatement.setInt(2, i); // the data pk column\n-                indexPreparedStatement.setInt(3, i * 2); // the included column\n-                indexPreparedStatement.execute();\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n             }\n             conn.commit();\n-            // Set all index row statuses to verified so that read verify will not fix them. We want them to be fixed\n-            // by IndexRepairRegionScanner\n-            setIndexRowStatusesToVerified(conn, dataTableFullName, indexTableFullName);\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"DELETE FROM \" + dataTableFullName + \" WHERE ID = 3\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+            TestUtil.doMajorCompaction(conn, dataTableFullName);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(1,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS - 1, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_DataTableUpdateFailure() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 20;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n+            }\n+            commitWithException(conn);\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(0, actualRowCount);\n+\n+            assertExtraCounters(indexTool, 0, NROWS, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testPITRow() throws Exception {\n+        final int NROWS = 1;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+\n+            Cell cell = IndexToolIT.getErrorMessageFromIndexToolOutputTable(conn, dataTableFullName, indexTableFullName);\n+            try {\n+                String expectedErrorMsg = IndexRepairRegionScanner.ERROR_MESSAGE_EXTRA_INDEX_ROW;\n+                String actualErrorMsg = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());\n+                assertTrue(expectedErrorMsg.equals(actualErrorMsg));", "originalCommit": "1cdfa882003afaaf2365020fbd7405d02ca5541b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1NDYxNA==", "url": "https://github.com/apache/phoenix/pull/995#discussion_r534354614", "bodyText": "nit: Do you need this? It will fail the test anyway without this assert right? It will be consistent with how we throw exceptions from test methods", "author": "gokceni", "createdAt": "2020-12-02T17:35:31Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexRepairRegionScannerIT.java", "diffHunk": "@@ -163,35 +308,251 @@ public void testRepairExtraIndexRows() throws Exception {\n         String indexTableName = generateUniqueName();\n         String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n         Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            // do index rebuild without -fi and check with scrutiny that index tool failed to fix the extra rows\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE);\n+\n+            boolean failed;\n+            try {\n+                IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+                failed = false;\n+            } catch (AssertionError e) {\n+                failed = true;\n+            }\n+            assertTrue(failed);\n+\n+            // now repair the index with -fi\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+\n+            assertExtraCounters(indexTool, NROWS, 0, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_overwrite() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n-                    + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \"\n-                    + tableDDLOptions);\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n             PreparedStatement dataPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n             for (int i = 1; i <= NROWS; i++) {\n                 dataPreparedStatement.setInt(1, i);\n                 dataPreparedStatement.setInt(2, i + 1);\n                 dataPreparedStatement.setInt(3, i * 2);\n                 dataPreparedStatement.execute();\n             }\n             conn.commit();\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"UPSERT INTO \" + dataTableFullName + \" VALUES(3, 100, 200)\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_delete() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n             conn.createStatement().execute(String.format(\n-                    \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n-            // Add extra index rows\n-            PreparedStatement indexPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + indexTableFullName + \" VALUES(?,?,?)\");\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n \n-            for (int i = NROWS + 1; i <= 2 * NROWS; i++) {\n-                indexPreparedStatement.setInt(1, i + 1); // the indexed column\n-                indexPreparedStatement.setInt(2, i); // the data pk column\n-                indexPreparedStatement.setInt(3, i * 2); // the included column\n-                indexPreparedStatement.execute();\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n             }\n             conn.commit();\n-            // Set all index row statuses to verified so that read verify will not fix them. We want them to be fixed\n-            // by IndexRepairRegionScanner\n-            setIndexRowStatusesToVerified(conn, dataTableFullName, indexTableFullName);\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"DELETE FROM \" + dataTableFullName + \" WHERE ID = 3\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+            TestUtil.doMajorCompaction(conn, dataTableFullName);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(1,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS - 1, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_DataTableUpdateFailure() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 20;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n+            }\n+            commitWithException(conn);\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(0, actualRowCount);\n+\n+            assertExtraCounters(indexTool, 0, NROWS, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testPITRow() throws Exception {\n+        final int NROWS = 1;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+\n+            Cell cell = IndexToolIT.getErrorMessageFromIndexToolOutputTable(conn, dataTableFullName, indexTableFullName);\n+            try {\n+                String expectedErrorMsg = IndexRepairRegionScanner.ERROR_MESSAGE_EXTRA_INDEX_ROW;\n+                String actualErrorMsg = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());\n+                assertTrue(expectedErrorMsg.equals(actualErrorMsg));\n+            } catch(Exception ex) {\n+                Assert.fail(\"Fail to parsing the error message from IndexToolOutputTable\");", "originalCommit": "1cdfa882003afaaf2365020fbd7405d02ca5541b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1NzQzMw==", "url": "https://github.com/apache/phoenix/pull/995#discussion_r534357433", "bodyText": "So this means -fi only works with BEFORE option is that correct?\nIs there any reason why it doesn't work with AFTER?\nI would expect it to build correctly independent of verify option and Verify is just verification not affecting how we build the index.", "author": "gokceni", "createdAt": "2020-12-02T17:39:42Z", "path": "phoenix-core/src/it/java/org/apache/phoenix/end2end/IndexRepairRegionScannerIT.java", "diffHunk": "@@ -163,35 +308,251 @@ public void testRepairExtraIndexRows() throws Exception {\n         String indexTableName = generateUniqueName();\n         String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n         Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            // do index rebuild without -fi and check with scrutiny that index tool failed to fix the extra rows\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE);\n+\n+            boolean failed;\n+            try {\n+                IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+                failed = false;\n+            } catch (AssertionError e) {\n+                failed = true;\n+            }\n+            assertTrue(failed);\n+\n+            // now repair the index with -fi\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+\n+            assertExtraCounters(indexTool, NROWS, 0, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_overwrite() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n         try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n             conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n-                    + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \"\n-                    + tableDDLOptions);\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n             PreparedStatement dataPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n             for (int i = 1; i <= NROWS; i++) {\n                 dataPreparedStatement.setInt(1, i);\n                 dataPreparedStatement.setInt(2, i + 1);\n                 dataPreparedStatement.setInt(3, i * 2);\n                 dataPreparedStatement.execute();\n             }\n             conn.commit();\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"UPSERT INTO \" + dataTableFullName + \" VALUES(3, 100, 200)\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(2,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_PostIndexUpdateFailure_delete() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 4;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n             conn.createStatement().execute(String.format(\n-                    \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n-            // Add extra index rows\n-            PreparedStatement indexPreparedStatement =\n-                    conn.prepareStatement(\"UPSERT INTO \" + indexTableFullName + \" VALUES(?,?,?)\");\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n \n-            for (int i = NROWS + 1; i <= 2 * NROWS; i++) {\n-                indexPreparedStatement.setInt(1, i + 1); // the indexed column\n-                indexPreparedStatement.setInt(2, i); // the data pk column\n-                indexPreparedStatement.setInt(3, i * 2); // the included column\n-                indexPreparedStatement.execute();\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n             }\n             conn.commit();\n-            // Set all index row statuses to verified so that read verify will not fix them. We want them to be fixed\n-            // by IndexRepairRegionScanner\n-            setIndexRowStatusesToVerified(conn, dataTableFullName, indexTableFullName);\n+\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(true);\n+            conn.createStatement().execute(\"DELETE FROM \" + dataTableFullName + \" WHERE ID = 3\");\n+            conn.commit();\n+            IndexRegionObserver.setFailPostIndexUpdatesForTesting(false);\n+            TestUtil.doMajorCompaction(conn, dataTableFullName);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            CounterGroup mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(1,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+            mrJobCounters = IndexToolIT.getMRJobCounters(indexTool);\n+\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REBUILD_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_VERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+            assertEquals(0,\n+                mrJobCounters.findCounter(BEFORE_REPAIR_EXTRA_UNVERIFIED_INDEX_ROW_COUNT.name()).getValue());\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(NROWS - 1, actualRowCount);\n+        }\n+    }\n+\n+    @Test\n+    public void testRepairExtraIndexRows_DataTableUpdateFailure() throws Exception {\n+        if (!mutable) {\n+            return;\n+        }\n+        final int NROWS = 20;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            conn.createStatement().execute(\"CREATE TABLE \" + dataTableFullName\n+                + \" (ID INTEGER NOT NULL PRIMARY KEY, VAL1 INTEGER, VAL2 INTEGER) \" + tableDDLOptions);\n+            conn.createStatement().execute(String.format(\n+                \"CREATE INDEX %s ON %s (VAL1) INCLUDE (VAL2)\", indexTableName, dataTableFullName));\n+\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            PreparedStatement dataPreparedStatement =\n+                conn.prepareStatement(\"UPSERT INTO \" + dataTableFullName + \" VALUES(?,?,?)\");\n+            for (int i = 1; i <= NROWS; i++) {\n+                dataPreparedStatement.setInt(1, i);\n+                dataPreparedStatement.setInt(2, i + 1);\n+                dataPreparedStatement.setInt(3, i * 2);\n+                dataPreparedStatement.execute();\n+            }\n+            commitWithException(conn);\n+            IndexRegionObserver.setFailDataTableUpdatesForTesting(true);\n+\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.BEFORE, \"-fi\");\n+\n+            long actualRowCount = IndexScrutiny.scrutinizeIndex(conn, dataTableFullName, indexTableFullName);\n+            assertEquals(0, actualRowCount);\n+\n+            assertExtraCounters(indexTool, 0, NROWS, true);\n+        }\n+    }\n+\n+    @Test\n+    public void testPITRow() throws Exception {\n+        final int NROWS = 1;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, 0, IndexVerifyType.ONLY, \"-fi\");\n+\n+            Cell cell = IndexToolIT.getErrorMessageFromIndexToolOutputTable(conn, dataTableFullName, indexTableFullName);\n+            try {\n+                String expectedErrorMsg = IndexRepairRegionScanner.ERROR_MESSAGE_EXTRA_INDEX_ROW;\n+                String actualErrorMsg = Bytes.toString(cell.getValueArray(), cell.getValueOffset(), cell.getValueLength());\n+                assertTrue(expectedErrorMsg.equals(actualErrorMsg));\n+            } catch(Exception ex) {\n+                Assert.fail(\"Fail to parsing the error message from IndexToolOutputTable\");\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifyAfterExtraIndexRows() throws Exception {\n+        final int NROWS = 20;\n+        String schemaName = generateUniqueName();\n+        String dataTableName = generateUniqueName();\n+        String dataTableFullName = SchemaUtil.getTableName(schemaName, dataTableName);\n+        String indexTableName = generateUniqueName();\n+        String indexTableFullName = SchemaUtil.getTableName(schemaName, indexTableName);\n+        Properties props = PropertiesUtil.deepCopy(TEST_PROPERTIES);\n+\n+        try (Connection conn = DriverManager.getConnection(getUrl(), props)) {\n+            initTablesAndAddExtraRowsToIndex(conn, schemaName, dataTableName, indexTableName, NROWS);\n+\n+            // Run -v AFTER and check it doesn't fix the extra rows and the job fails\n+            IndexTool indexTool = IndexToolIT.runIndexTool(false, false, schemaName, dataTableName,\n+                indexTableName, null, -1, IndexVerifyType.AFTER, \"-fi\");", "originalCommit": "1cdfa882003afaaf2365020fbd7405d02ca5541b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMzNzczNg==", "url": "https://github.com/apache/phoenix/pull/995#discussion_r536337736", "bodyText": "@Gokcen AFTER first rebuilds the index using the expected mutations from the data table. So any extra rows in the index table will remain after the rebuild since they are not present in the data table. Then when we verify, those rows will be reported as extra. As a result, the AFTER job will fail.", "author": "tkhurana", "createdAt": "2020-12-04T19:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM1NzQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4NjY2OA==", "url": "https://github.com/apache/phoenix/pull/995#discussion_r534386668", "bodyText": "I think adding a comment here would be nice. Something like this case happens when there is extra index rows", "author": "gokceni", "createdAt": "2020-12-02T18:24:34Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/GlobalIndexRegionScanner.java", "diffHunk": "@@ -883,6 +925,9 @@ public boolean verifySingleIndexRow(byte[] indexRowKey, List<Mutation> actualMut\n                 logMismatch(expected, actual, expectedIndex, verificationPhaseResult, isBeforeRebuild);\n             }\n             else {\n+                if (expected == null) {", "originalCommit": "1cdfa882003afaaf2365020fbd7405d02ca5541b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4ODQwNw==", "url": "https://github.com/apache/phoenix/pull/995#discussion_r534388407", "bodyText": "Does the below code work if there is no index row?", "author": "gokceni", "createdAt": "2020-12-02T18:27:22Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRepairRegionScanner.java", "diffHunk": "@@ -178,6 +183,28 @@ protected void repairIndexRows(Map<byte[], List<Mutation>> indexMutationMap,\n         return actualIndexMutationMap;\n     }\n \n+    private Map<byte[], List<Mutation>> populateActualIndexMutationMap() throws IOException {\n+        Map<byte[], List<Mutation>> actualIndexMutationMap = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n+        Scan indexScan = new Scan();\n+        indexScan.setTimeRange(scan.getTimeRange().getMin(), scan.getTimeRange().getMax());\n+        indexScan.setRaw(true);\n+        indexScan.setMaxVersions();\n+        indexScan.setCacheBlocks(false);\n+        try (RegionScanner regionScanner = region.getScanner(indexScan)) {", "originalCommit": "1cdfa882003afaaf2365020fbd7405d02ca5541b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQyMjMyOQ==", "url": "https://github.com/apache/phoenix/pull/995#discussion_r536422329", "bodyText": "@gokceni I am not sure I understood your concern here ?", "author": "tkhurana", "createdAt": "2020-12-04T22:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4ODQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY5NDgyNw==", "url": "https://github.com/apache/phoenix/pull/995#discussion_r537694827", "bodyText": "If the index is truncated for some reason and this code is run, the below do while code, will it work since you seem to be checking the hasMore in the while part of the loop?", "author": "gokceni", "createdAt": "2020-12-07T17:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4ODQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgxNjMxNA==", "url": "https://github.com/apache/phoenix/pull/995#discussion_r537816314", "bodyText": "@gokceni  hasMore will be false in that case and the code should exit the loop. This is a standard pattern used in multiple places in the index rebuild code.", "author": "tkhurana", "createdAt": "2020-12-07T20:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDM4ODQwNw=="}], "type": "inlineReview"}, {"oid": "534c2646e9377b977056310cc9ec4737e8769ae1", "url": "https://github.com/apache/phoenix/commit/534c2646e9377b977056310cc9ec4737e8769ae1", "message": "Address feedback", "committedDate": "2020-12-04T20:26:23Z", "type": "commit"}]}