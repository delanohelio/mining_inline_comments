{"pr_number": 725, "pr_title": "PHOENIX-5749: Add unit tests for verifySingleIndexRow() of IndexRebui\u2026", "pr_createdAt": "2020-03-06T20:40:39Z", "pr_url": "https://github.com/apache/phoenix/pull/725", "timeline": [{"oid": "72d0124d63009e1bff961e712fe5d414934ff509", "url": "https://github.com/apache/phoenix/commit/72d0124d63009e1bff961e712fe5d414934ff509", "message": "PHOENIX-5749: Add unit tests for verifySingleIndexRow() of IndexRebuildRegionScanner", "committedDate": "2020-03-06T20:37:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzODUxOQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r389138519", "bodyText": "Why do you need to move this code out from this file? It is a static helper class and only meaningful in the context of index verification and not by itself.", "author": "kadirozde", "createdAt": "2020-03-06T20:53:22Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -109,231 +110,6 @@\n \n public class IndexRebuildRegionScanner extends BaseRegionScanner {\n \n-    public static class VerificationResult {", "originalCommit": "72d0124d63009e1bff961e712fe5d414934ff509", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MTI0OQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391771249", "bodyText": "I agree that VerificationResult makes sense as an inner class of something, but since I'd eventually like to see the verification logic moved out into its own class (and the index generation logic moved out into its own class), I still support moving the VerificationResult out of IndexRebuildRegionScanner. :-)", "author": "gjacoby126", "createdAt": "2020-03-12T17:15:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzODUxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2Mzc2NQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r392363765", "bodyText": "Also, for tests, it was 3 level indirection to access the PhaseResult, so I thought of putting it into its own class. :)", "author": "swaroopak", "createdAt": "2020-03-13T17:16:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzODUxOQ=="}], "type": "inlineReview"}, {"oid": "157bbf8b8e12e2ee1715c96dcd74f31e1188a7a2", "url": "https://github.com/apache/phoenix/commit/157bbf8b8e12e2ee1715c96dcd74f31e1188a7a2", "message": "Removing thread sleep and restructuring the setup", "committedDate": "2020-03-07T01:47:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ1MjA0NQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r389452045", "bodyText": "Comparing one PhaseResult to another would be more intuitive and best implemented by overriding equals() instead of comparing output of toString() functions. You wouldn't even need assertVerificationPhaseResult() function then and Assert.Equals() would suffice.", "author": "priyankporwal", "createdAt": "2020-03-09T03:45:27Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_VALUE = \"UNEXPECTED_VALUE\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+\n+    private enum TestType {\n+        VALID,\n+        EXPIRED,\n+        INVALID_LESS_MUTATIONS,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR, expectedPR;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (kv.getType() == (KeyValue.Type.Put.getCode())) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        rebuildScanner.indexTableTTL = HConstants.FOREVER;\n+        rebuildScanner.indexMaintainer = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+        rebuildScanner.indexKeyToMutationMap = Maps.newTreeMap((Bytes.BYTES_COMPARATOR));\n+    }\n+\n+    private void initializeGlobalMockitoSetup() throws IOException {\n+        //setup\n+        when(rebuildScanner.getIndexRowKey(put)).thenCallRealMethod();\n+        when(rebuildScanner.prepareIndexMutations(put, delete)).thenCallRealMethod();\n+        when(rebuildScanner.verifySingleIndexRow(Matchers.<Result>any(),\n+                Matchers.<IndexToolVerificationResult.PhaseResult>any())).thenCallRealMethod();\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString(),\n+                        Matchers.<byte[]>any(), Matchers.<byte[]>any());\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString());\n+\n+        //populate the map\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_nonZero() throws IOException {\n+        expectedPR = new IndexToolVerificationResult.PhaseResult(1, 0, 0, 0);\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_expiredIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult\n+                expectedPR = new IndexToolVerificationResult.PhaseResult(0, 1, 0, 0);\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.EXPIRED);\n+            expireThisRow();\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_lessMutations() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_LESS_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_cellValue() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_CELL_VALUE);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_emptyCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EMPTY_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_diffColumn() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_COLUMN);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_extraCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : rebuildScanner.indexKeyToMutationMap.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EXTRA_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertVerificationPhaseResult(actualPR, expectedPR);\n+        }\n+    }\n+\n+    private IndexToolVerificationResult.PhaseResult getInvalidPhaseResult() {\n+        return new IndexToolVerificationResult.PhaseResult(0, 0, 0, 1);\n+    }\n+\n+    private void initializeLocalMockitoSetup(Map.Entry<byte[], List<Mutation>> entry, TestType testType)\n+            throws IOException {\n+        actualPR = new IndexToolVerificationResult.PhaseResult();\n+        byte[] indexKey = entry.getKey();\n+        when(indexRow.getRow()).thenReturn(indexKey);\n+        actualMutationList = buildActualIndexMutationsList(testType);\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(actualMutationList);\n+    }\n+\n+    private List<Mutation> buildActualIndexMutationsList(TestType testType) {\n+        List<Mutation> actualMutations = new ArrayList<>();\n+        actualMutations.addAll(rebuildScanner.indexKeyToMutationMap.get(indexRow.getRow()));\n+        if(testType.equals(TestType.EXPIRED) || testType.equals(TestType.VALID)) {\n+            return actualMutations;\n+        }\n+        if (testType.equals(TestType.INVALID_LESS_MUTATIONS)) {\n+            return getTotalMutationsLessThanExpected(actualMutations);\n+        }\n+\n+        List <Mutation> newActualMutations = new ArrayList<>();\n+        newActualMutations.addAll(actualMutations);\n+\n+        for (Mutation m : actualMutations) {\n+            newActualMutations.remove(m);\n+            NavigableMap<byte [], List<Cell>> familyCellMap = m.getFamilyCellMap();\n+            List<Cell> cellList = familyCellMap.firstEntry().getValue();\n+            List <Cell> newCellList = new ArrayList<>();\n+            for (Cell c : cellList) {\n+                infiltrateCell(c, newCellList, testType);\n+            }\n+            familyCellMap.put(Bytes.toBytes(0), newCellList);\n+            m.setFamilyCellMap(familyCellMap);\n+            newActualMutations.add(m);\n+        }\n+        return newActualMutations;\n+    }\n+\n+    private void infiltrateCell(Cell c, List<Cell> newCellList, TestType e) {\n+        Cell newCell;\n+        switch(e) {\n+        case INVALID_COLUMN:\n+            newCell =\n+                CellUtil.createCell(CellUtil.cloneRow(c), CellUtil.cloneFamily(c),\n+                        Bytes.toBytes(\"0:\" + UNEXPECTED_VALUE),\n+                        EnvironmentEdgeManager.currentTimeMillis(),\n+                        KeyValue.Type.Put.getCode(), Bytes.toBytes(\"zxcv\"));\n+            newCellList.add(newCell);\n+            newCellList.add(c);\n+            break;\n+        case INVALID_CELL_VALUE:\n+            if (CellUtil.matchingQualifier(c, EMPTY_COLUMN_BYTES)) {\n+                newCell = CellUtil.createCell(CellUtil.cloneRow(c), CellUtil.cloneFamily(c),\n+                        Bytes.toBytes(FIRST_VALUE), EnvironmentEdgeManager.currentTimeMillis(),\n+                        KeyValue.Type.Put.getCode(),\n+                        Bytes.toBytes(\"zxcv\"));\n+                newCellList.add(newCell);\n+            } else {\n+                newCellList.add(c);\n+            }\n+            break;\n+        case INVALID_EMPTY_CELL:\n+            if (CellUtil.matchingQualifier(c, EMPTY_COLUMN_BYTES)) {\n+                newCell = CellUtil.createCell(CellUtil.cloneRow(c), CellUtil.cloneFamily(c),\n+                        CellUtil.cloneQualifier(c), c.getTimestamp(),\n+                        KeyValue.Type.Delete.getCode(),\n+                        Bytes.toBytes(\"\\\\x02\"));\n+                newCellList.add(newCell);\n+            } else {\n+                newCellList.add(c);\n+            }\n+            break;\n+        case INVALID_EXTRA_CELL:\n+            if (CellUtil.matchingQualifier(c, EMPTY_COLUMN_BYTES)) {\n+                newCell = CellUtil.createCell(CellUtil.cloneRow(c), CellUtil.cloneFamily(c),\n+                        Bytes.toBytes(FIRST_VALUE), EnvironmentEdgeManager.currentTimeMillis(),\n+                        KeyValue.Type.Put.getCode(),\n+                        Bytes.toBytes(\"zxcv\"));\n+                newCellList.add(newCell);\n+            }\n+            newCellList.add(c);\n+        }\n+    }\n+\n+    private void expireThisRow() {\n+        rebuildScanner.indexTableTTL = INDEX_TABLE_EXPIRY_SEC;\n+        UnitTestClock expiryClock = new UnitTestClock(5000);\n+        EnvironmentEdgeManager.injectEdge(expiryClock);\n+    }\n+\n+    private List<Mutation> getTotalMutationsLessThanExpected(List<Mutation> actualMutations) {\n+        Mutation m = actualMutations.get(0);\n+        NavigableMap<byte [], List<Cell>> familyCellMap = m.getFamilyCellMap();\n+        List<Cell> cellList = familyCellMap.firstEntry().getValue();\n+        Cell c = cellList.get(0);\n+        Cell newCell = CellUtil.createCell(CellUtil.cloneRow(c), CellUtil.cloneFamily(c),\n+                CellUtil.cloneQualifier(c), EnvironmentEdgeManager.currentTimeMillis(),\n+                KeyValue.Type.Delete.getCode(),\n+                    CellUtil.cloneValue(c));\n+        cellList.add(newCell);\n+        familyCellMap.put(Bytes.toBytes(0), cellList);\n+        m.setFamilyCellMap(familyCellMap);\n+        actualMutations.removeAll(actualMutations);\n+        actualMutations.add(m);\n+        return actualMutations;\n+    }\n+\n+    private void assertVerificationPhaseResult(IndexToolVerificationResult.PhaseResult actualPR,\n+            IndexToolVerificationResult.PhaseResult expectedPR) {\n+        Assert.assertTrue(actualPR.toString().equalsIgnoreCase(expectedPR.toString()));", "originalCommit": "157bbf8b8e12e2ee1715c96dcd74f31e1188a7a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f2f9f0ff0e39e37cdea086d06d29ee1b77bee04a", "url": "https://github.com/apache/phoenix/commit/f2f9f0ff0e39e37cdea086d06d29ee1b77bee04a", "message": "Added more scenarios to increase the branch coverage", "committedDate": "2020-03-10T04:07:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA4NjY5NQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r390086695", "bodyText": "Do we still need this annotation if it is a public function?", "author": "wangweiming800", "createdAt": "2020-03-10T04:14:03Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -594,14 +376,16 @@ private boolean checkIndexRow(final byte[] indexRowKey, final Put put) throws IO\n         return true;\n     }\n \n-    private void logToIndexToolOutputTable(byte[] dataRowKey, byte[] indexRowKey, long dataRowTs, long indexRowTs,\n+    @VisibleForTesting", "originalCommit": "f2f9f0ff0e39e37cdea086d06d29ee1b77bee04a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM1MTYyMg==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391351622", "bodyText": "Nope!", "author": "swaroopak", "createdAt": "2020-03-12T01:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA4NjY5NQ=="}], "type": "inlineReview"}, {"oid": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "url": "https://github.com/apache/phoenix/commit/3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "message": "Fixing review comments", "committedDate": "2020-03-12T01:57:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MTc2Mw==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391771763", "bodyText": "tiny nit: unnecessary extra space", "author": "gjacoby126", "createdAt": "2020-03-12T17:16:48Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -359,23 +138,24 @@ public void add(VerificationResult verificationResult) {\n     private Table resultHTable = null;\n     private IndexTool.IndexVerifyType verifyType = IndexTool.IndexVerifyType.NONE;\n     private boolean verify = false;\n-    private Map<byte[], List<Mutation>> indexKeyToMutationMap;\n+    private  Map<byte[], List<Mutation>> indexKeyToMutationMap;", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MjE2Nw==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391772167", "bodyText": "nit: variable name is confusing, since it can be any int, not just Hconstants.forever", "author": "gjacoby126", "createdAt": "2020-03-12T17:17:33Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -552,6 +332,24 @@ private void setMutationAttributes(Mutation m, byte[] uuidValue) {\n         return uuidValue;\n     }\n \n+    @VisibleForTesting\n+    public int setIndexTableTTL(int forever) {", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3MzY0MA==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391773640", "bodyText": "This change is a hint that index generation code should be its own class with its own public methods. (Not necessarily in this JIRA.) After all, this method doesn't really have much to do with \"scanning\".", "author": "gjacoby126", "createdAt": "2020-03-12T17:20:00Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -578,7 +376,7 @@ public ImmutableBytesWritable getLatestValue(ColumnReference ref, long ts) throw\n \n     }\n \n-    private byte[] getIndexRowKey(final Put dataRow) throws IOException {\n+    public byte[] getIndexRowKey(final Put dataRow) throws IOException {", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3NDMwNA==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391774304", "bodyText": "Likewise logging to the output table should likely be its own class (easier to mock, for one thing). Again, not necessarily for this JIRA.", "author": "gjacoby126", "createdAt": "2020-03-12T17:21:09Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -594,14 +392,16 @@ private boolean checkIndexRow(final byte[] indexRowKey, final Put put) throws IO\n         return true;\n     }\n \n-    private void logToIndexToolOutputTable(byte[] dataRowKey, byte[] indexRowKey, long dataRowTs, long indexRowTs,\n+    @VisibleForTesting\n+    public void logToIndexToolOutputTable(byte[] dataRowKey, byte[] indexRowKey, long dataRowTs, long indexRowTs,", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3NzUzNg==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391777536", "bodyText": "tiny nit: extra space", "author": "gjacoby126", "createdAt": "2020-03-12T17:26:27Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexRebuildRegionScanner.java", "diffHunk": "@@ -866,7 +668,7 @@ private boolean verifySingleIndexRow(Result indexRow, VerificationResult.PhaseRe\n         Mutation expected = null;\n         Mutation previousExpected;\n         Mutation actual;\n-        while (expectedIndex < expectedSize && actualIndex <actualSize) {\n+        while (expectedIndex < expectedSize && actualIndex < actualSize) {", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3ODg3Mg==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391778872", "bodyText": "Good job on overriding equals. However, Java requires that if you override equals you must also override hash code (and make them consistent)", "author": "gjacoby126", "createdAt": "2020-03-12T17:28:40Z", "path": "phoenix-core/src/main/java/org/apache/phoenix/coprocessor/IndexToolVerificationResult.java", "diffHunk": "@@ -0,0 +1,294 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.coprocessor;\n+\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.phoenix.mapreduce.index.IndexTool;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+import static org.apache.phoenix.mapreduce.index.IndexTool.AFTER_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.AFTER_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.AFTER_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.AFTER_REBUILD_VALID_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.BEFORE_REBUILD_EXPIRED_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.BEFORE_REBUILD_INVALID_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.BEFORE_REBUILD_MISSING_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.BEFORE_REBUILD_VALID_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.REBUILT_INDEX_ROW_COUNT_BYTES;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.RESULT_TABLE_COLUMN_FAMILY;\n+import static org.apache.phoenix.mapreduce.index.IndexTool.SCANNED_DATA_ROW_COUNT_BYTES;\n+\n+public class IndexToolVerificationResult {\n+    public static class PhaseResult {\n+        long validIndexRowCount = 0;\n+        long expiredIndexRowCount = 0;\n+        long missingIndexRowCount = 0;\n+        long invalidIndexRowCount = 0;\n+\n+        public void add(PhaseResult phaseResult) {\n+            validIndexRowCount += phaseResult.validIndexRowCount;\n+            expiredIndexRowCount += phaseResult.expiredIndexRowCount;\n+            missingIndexRowCount += phaseResult.missingIndexRowCount;\n+            invalidIndexRowCount += phaseResult.invalidIndexRowCount;\n+        }\n+\n+        public PhaseResult(){}\n+\n+        public PhaseResult(long validIndexRowCount, long expiredIndexRowCount,\n+                long missingIndexRowCount, long invalidIndexRowCount) {\n+            this.validIndexRowCount = validIndexRowCount;\n+            this.expiredIndexRowCount = expiredIndexRowCount;\n+            this.missingIndexRowCount = missingIndexRowCount;\n+            this.invalidIndexRowCount = invalidIndexRowCount;\n+        }\n+\n+        public long getTotalCount() {\n+            return validIndexRowCount + expiredIndexRowCount + missingIndexRowCount + invalidIndexRowCount;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"PhaseResult{\" +\n+                    \"validIndexRowCount=\" + validIndexRowCount +\n+                    \", expiredIndexRowCount=\" + expiredIndexRowCount +\n+                    \", missingIndexRowCount=\" + missingIndexRowCount +\n+                    \", invalidIndexRowCount=\" + invalidIndexRowCount +\n+                    '}';\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM3NDcxNQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r392374715", "bodyText": "aah! ll do it with 17 and 31 way. :)", "author": "swaroopak", "createdAt": "2020-03-13T17:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc3ODg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4MDA0MQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391780041", "bodyText": "nit: CREATE_TABLE_DDL", "author": "gjacoby126", "createdAt": "2020-03-12T17:30:34Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4MDE3NQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391780175", "bodyText": "nit: CREATE_INDEX_DDL", "author": "gjacoby126", "createdAt": "2020-03-12T17:30:47Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4MjU3OQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391782579", "bodyText": "some of these are self explanatory, but a comment would be good", "author": "gjacoby126", "createdAt": "2020-03-12T17:34:49Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ2ODQ1NQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r392468455", "bodyText": "added comment wherever felt necessary", "author": "swaroopak", "createdAt": "2020-03-13T20:51:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4MjU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4NzM4Nw==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391787387", "bodyText": "These KeyValue.get* operations are deprecated. Actually, all operations directly on a KeyValue are deprecated. Should be using the Cell interface, which KeyValues implement.", "author": "gjacoby126", "createdAt": "2020-03-12T17:42:32Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4OTAwOA==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391789008", "bodyText": "Better to use CellUtil.cloneRow, cloneFamily, etc. Can't seem to fine a cloneCell method anywhere, which is a little strange....", "author": "gjacoby126", "createdAt": "2020-03-12T17:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4NzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc5MDY0Mg==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391790642", "bodyText": "Ah, I see, later versions of HBase get CellBuilder/CellBuilderFactory but 1.x doesn't have it.", "author": "gjacoby126", "createdAt": "2020-03-12T17:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc4NzM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNDQ5NA==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391804494", "bodyText": "All of this partial mocking in initializeRebuildScannerAttributes and initalizeGlobalMockitoSetup should be taken as a \"code smell\" that the rebuild scanner needs to be broken apart into multiple classes. Generally when mocking you have one class under test which isn't mocked at all, and other dependent classes that aren't being tested that are completely mocked.\nAgain, don't have to fix this in this PR, because without the tests first it's hard to refactor this safely. But the refactoring should happen.", "author": "gjacoby126", "createdAt": "2020-03-12T18:12:50Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        when(rebuildScanner.setIndexTableTTL(Matchers.anyInt())).thenCallRealMethod();", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNTgyNw==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391805827", "bodyText": "forgot to assert?", "author": "gjacoby126", "createdAt": "2020-03-12T18:15:14Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        when(rebuildScanner.setIndexTableTTL(Matchers.anyInt())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexMaintainer(Matchers.<IndexMaintainer>any())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexKeyToMutationMap(Matchers.<Map>any())).thenCallRealMethod();\n+        rebuildScanner.setIndexTableTTL(HConstants.FOREVER);\n+        indexMaintainer = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+        rebuildScanner.setIndexMaintainer(indexMaintainer);\n+    }\n+\n+    private void initializeGlobalMockitoSetup() throws IOException {\n+        //setup\n+        when(rebuildScanner.getIndexRowKey(put)).thenCallRealMethod();\n+        when(rebuildScanner.prepareIndexMutations(put, delete)).thenCallRealMethod();\n+        when(rebuildScanner.verifySingleIndexRow(Matchers.<Result>any(),\n+                Matchers.<IndexToolVerificationResult.PhaseResult>any())).thenCallRealMethod();\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString(),\n+                        Matchers.<byte[]>any(), Matchers.<byte[]>any());\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString());\n+\n+        //populate the local map to use to create actual mutations\n+        indexKeyToMutationMapLocal = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMapLocal);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+\n+        //populate map to use in test code\n+        Map<byte[], List<Mutation>> indexKeyToMutationMap = Maps.newTreeMap((Bytes.BYTES_COMPARATOR));\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMap);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+    }\n+\n+    private byte[] getValidRowKey() {\n+        return indexKeyToMutationMapLocal.entrySet().iterator().next().getKey();\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            actualPR.equals(expectedPR);", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgwNjExNQ==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391806115", "bodyText": "nit: don't have to tell me you assert just before a line called assert. :-) Ditto for the other places this got pasted.", "author": "gjacoby126", "createdAt": "2020-03-12T18:15:48Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        when(rebuildScanner.setIndexTableTTL(Matchers.anyInt())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexMaintainer(Matchers.<IndexMaintainer>any())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexKeyToMutationMap(Matchers.<Map>any())).thenCallRealMethod();\n+        rebuildScanner.setIndexTableTTL(HConstants.FOREVER);\n+        indexMaintainer = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+        rebuildScanner.setIndexMaintainer(indexMaintainer);\n+    }\n+\n+    private void initializeGlobalMockitoSetup() throws IOException {\n+        //setup\n+        when(rebuildScanner.getIndexRowKey(put)).thenCallRealMethod();\n+        when(rebuildScanner.prepareIndexMutations(put, delete)).thenCallRealMethod();\n+        when(rebuildScanner.verifySingleIndexRow(Matchers.<Result>any(),\n+                Matchers.<IndexToolVerificationResult.PhaseResult>any())).thenCallRealMethod();\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString(),\n+                        Matchers.<byte[]>any(), Matchers.<byte[]>any());\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString());\n+\n+        //populate the local map to use to create actual mutations\n+        indexKeyToMutationMapLocal = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMapLocal);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+\n+        //populate map to use in test code\n+        Map<byte[], List<Mutation>> indexKeyToMutationMap = Maps.newTreeMap((Bytes.BYTES_COMPARATOR));\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMap);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+    }\n+\n+    private byte[] getValidRowKey() {\n+        return indexKeyToMutationMapLocal.entrySet().iterator().next().getKey();\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            actualPR.equals(expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_moreActual() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_MORE_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxOTU3Ng==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391819576", "bodyText": "should this be VALID_EMPTY?", "author": "gjacoby126", "createdAt": "2020-03-12T18:40:37Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        when(rebuildScanner.setIndexTableTTL(Matchers.anyInt())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexMaintainer(Matchers.<IndexMaintainer>any())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexKeyToMutationMap(Matchers.<Map>any())).thenCallRealMethod();\n+        rebuildScanner.setIndexTableTTL(HConstants.FOREVER);\n+        indexMaintainer = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+        rebuildScanner.setIndexMaintainer(indexMaintainer);\n+    }\n+\n+    private void initializeGlobalMockitoSetup() throws IOException {\n+        //setup\n+        when(rebuildScanner.getIndexRowKey(put)).thenCallRealMethod();\n+        when(rebuildScanner.prepareIndexMutations(put, delete)).thenCallRealMethod();\n+        when(rebuildScanner.verifySingleIndexRow(Matchers.<Result>any(),\n+                Matchers.<IndexToolVerificationResult.PhaseResult>any())).thenCallRealMethod();\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString(),\n+                        Matchers.<byte[]>any(), Matchers.<byte[]>any());\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString());\n+\n+        //populate the local map to use to create actual mutations\n+        indexKeyToMutationMapLocal = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMapLocal);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+\n+        //populate map to use in test code\n+        Map<byte[], List<Mutation>> indexKeyToMutationMap = Maps.newTreeMap((Bytes.BYTES_COMPARATOR));\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMap);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+    }\n+\n+    private byte[] getValidRowKey() {\n+        return indexKeyToMutationMapLocal.entrySet().iterator().next().getKey();\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            actualPR.equals(expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_moreActual() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_MORE_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_allMix() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_MIX_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_allUnverified() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_NEW_UNVERIFIED_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_expiredIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult\n+                expectedPR = new IndexToolVerificationResult.PhaseResult(0, 1, 0, 0);\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.EXPIRED);\n+            expireThisRow();\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_cellValue() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_CELL_VALUE);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_emptyCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EMPTY_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_diffColumn() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_COLUMN);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_extraCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EXTRA_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_expectedMutations_null() throws IOException {\n+        when(indexRow.getRow()).thenReturn(Bytes.toBytes(1));\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.NO_EXPECTED_MUTATION);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_actualMutations_null() throws IOException {\n+        byte [] validRowKey = getValidRowKey();\n+        when(indexRow.getRow()).thenReturn(validRowKey);\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(null);\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.ACTUAL_MUTATION_IS_NULL_OR_EMPTY);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_actualMutations_empty() throws IOException {\n+        byte [] validRowKey = getValidRowKey();\n+        when(indexRow.getRow()).thenReturn(validRowKey);\n+        actualMutationList = new ArrayList<>();\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(actualMutationList);\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.ACTUAL_MUTATION_IS_NULL_OR_EMPTY);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    private IndexToolVerificationResult.PhaseResult getValidPhaseResult() {\n+        return new IndexToolVerificationResult.PhaseResult(1,0,0,0);\n+    }\n+\n+    private IndexToolVerificationResult.PhaseResult getInvalidPhaseResult() {\n+        return new IndexToolVerificationResult.PhaseResult(0, 0, 0, 1);\n+    }\n+\n+    private void initializeLocalMockitoSetup(Map.Entry<byte[], List<Mutation>> entry,\n+            TestType testType)\n+            throws IOException {\n+        actualPR = new IndexToolVerificationResult.PhaseResult();\n+        byte[] indexKey = entry.getKey();\n+        when(indexRow.getRow()).thenReturn(indexKey);\n+        actualMutationList = buildActualIndexMutationsList(testType);\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(actualMutationList);\n+    }\n+\n+    private List<Mutation> buildActualIndexMutationsList(TestType testType) {\n+        List<Mutation> actualMutations = new ArrayList<>();\n+        actualMutations.addAll(indexKeyToMutationMapLocal.get(indexRow.getRow()));\n+        if(testType.equals(TestType.EXPIRED)) {\n+            return actualMutations;\n+        }\n+        if(testType.toString().startsWith(\"VALID\")) {\n+            return getValidActualMutations(testType, actualMutations);\n+        }\n+        if(testType.toString().startsWith(\"INVALID\")) {\n+            return getInvalidActualMutations(testType, actualMutations);\n+        }\n+        return null;\n+    }\n+\n+    private List <Mutation> getValidActualMutations(TestType testType,\n+            List<Mutation> actualMutations) {\n+        List <Mutation> newActualMutations = new ArrayList<>();\n+        if(testType.equals(TestType.VALID)) {", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjQ2Nzk0OA==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r392467948", "bodyText": "making it VALID_EXACT_MATCH.", "author": "swaroopak", "createdAt": "2020-03-13T20:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgxOTU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTgyMDM3Nw==", "url": "https://github.com/apache/phoenix/pull/725#discussion_r391820377", "bodyText": "Nice method name. :-)", "author": "gjacoby126", "createdAt": "2020-03-12T18:42:04Z", "path": "phoenix-core/src/test/java/org/apache/phoenix/index/IndexToolSingleRowVerifyTest.java", "diffHunk": "@@ -0,0 +1,634 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.phoenix.index;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Maps;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.CellUtil;\n+import org.apache.hadoop.hbase.DoNotRetryIOException;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.KeyValue;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Mutation;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.phoenix.coprocessor.IndexRebuildRegionScanner;\n+import org.apache.phoenix.coprocessor.IndexToolVerificationResult;\n+import org.apache.phoenix.jdbc.PhoenixConnection;\n+import org.apache.phoenix.query.BaseConnectionlessQueryTest;\n+import org.apache.phoenix.schema.PTable;\n+import org.apache.phoenix.schema.PTableKey;\n+import org.apache.phoenix.util.EnvironmentEdge;\n+import org.apache.phoenix.util.EnvironmentEdgeManager;\n+import org.apache.phoenix.util.PhoenixRuntime;\n+import org.apache.phoenix.util.SchemaUtil;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.mockito.Matchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.MockitoAnnotations;\n+\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.DriverManager;\n+import java.sql.PreparedStatement;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.UNVERIFIED_BYTES;\n+import static org.apache.phoenix.hbase.index.IndexRegionObserver.VERIFIED_BYTES;\n+import static org.apache.phoenix.query.QueryConstants.EMPTY_COLUMN_BYTES;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.when;\n+\n+public class IndexToolSingleRowVerifyTest extends BaseConnectionlessQueryTest {\n+\n+    private static final int INDEX_TABLE_EXPIRY_SEC = 1;\n+    private static final String UNEXPECTED_COLUMN = \"0:UNEXPECTED_COLUMN\";\n+    public static final String FIRST_ID = \"FIRST_ID\";\n+    public static final String SECOND_ID = \"SECOND_ID\";\n+    public static final String FIRST_VALUE = \"FIRST_VALUE\";\n+    public static final String SECOND_VALUE = \"SECOND_VALUE\";\n+    public static final String\n+            createTableDDL = \"CREATE TABLE IF NOT EXISTS %s (FIRST_ID BIGINT NOT NULL, \"\n+                        + \"SECOND_ID BIGINT NOT NULL, FIRST_VALUE VARCHAR(20), \"\n+                        + \"SECOND_VALUE INTEGER \"\n+                        + \"CONSTRAINT PK PRIMARY KEY(FIRST_ID, SECOND_ID)) COLUMN_ENCODED_BYTES=0\";\n+\n+    public static final String\n+            createIndexDDL = \"CREATE INDEX %s ON %s (SECOND_VALUE) INCLUDE (FIRST_VALUE)\";\n+    public static final String completeRowUpsert = \"UPSERT INTO %s VALUES (?,?,?,?)\";\n+    public static final String partialRowUpsert1 = \"UPSERT INTO %s (%s, %s, %s) VALUES (?,?,?)\";\n+    public static final String deleteRowDML = \"DELETE FROM %s WHERE %s = ?  AND %s = ?\";\n+    public static final String INCLUDED_COLUMN = \"0:FIRST_VALUE\";\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    private enum TestType {\n+        VALID,\n+        VALID_MIX_MUTATIONS,\n+        VALID_NEW_UNVERIFIED_MUTATIONS,\n+        VALID_MORE_MUTATIONS,\n+        EXPIRED,\n+        INVALID_EXTRA_CELL,\n+        INVALID_EMPTY_CELL,\n+        INVALID_CELL_VALUE,\n+        INVALID_COLUMN\n+    }\n+\n+    public static class UnitTestClock extends EnvironmentEdge {\n+        long initialTime;\n+        long delta;\n+\n+        public UnitTestClock(long delta) {\n+            initialTime = System.currentTimeMillis() + delta;\n+            this.delta = delta;\n+        }\n+\n+        @Override\n+        public long currentTime() {\n+            return System.currentTimeMillis() + delta;\n+        }\n+    }\n+\n+    @Mock\n+    Result indexRow;\n+    @Mock\n+    IndexRebuildRegionScanner rebuildScanner;\n+    List<Mutation> actualMutationList;\n+    String schema, table, dataTableFullName, index, indexTableFullName;\n+    PTable pIndexTable, pDataTable;\n+    Put put = null;\n+    Delete delete = null;\n+    PhoenixConnection pconn;\n+    IndexToolVerificationResult.PhaseResult actualPR;\n+    public Map<byte[], List<Mutation>> indexKeyToMutationMapLocal;\n+    private IndexMaintainer indexMaintainer;\n+\n+    @Before\n+    public void setup() throws SQLException, IOException {\n+        MockitoAnnotations.initMocks(this);\n+        createDBObject();\n+        createMutationsWithUpserts();\n+        initializeRebuildScannerAttributes();\n+        initializeGlobalMockitoSetup();\n+    }\n+\n+    public void createDBObject() throws SQLException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            schema = generateUniqueName();\n+            table = generateUniqueName();\n+            index = generateUniqueName();\n+            dataTableFullName = SchemaUtil.getQualifiedTableName(schema, table);\n+            indexTableFullName = SchemaUtil.getQualifiedTableName(schema, index);\n+\n+            conn.createStatement().execute(String.format(createTableDDL, dataTableFullName));\n+            conn.createStatement().execute(String.format(createIndexDDL, index, dataTableFullName));\n+            conn.commit();\n+\n+            pconn = conn.unwrap(PhoenixConnection.class);\n+            pIndexTable = pconn.getTable(new PTableKey(pconn.getTenantId(), indexTableFullName));\n+            pDataTable = pconn.getTable(new PTableKey(pconn.getTenantId(), dataTableFullName));\n+        }\n+    }\n+\n+    private void createMutationsWithUpserts() throws SQLException, IOException {\n+        deleteRow(2, 3);\n+        upsertPartialRow(2, 3, \"abc\");\n+        upsertCompleteRow(2, 3, \"hik\", 8);\n+        upsertPartialRow(2, 3, 10);\n+        upsertPartialRow(2,3,4);\n+        deleteRow(2, 3);\n+        upsertPartialRow(2,3, \"def\");\n+        upsertCompleteRow(2, 3, null, 20);\n+        upsertPartialRow(2,3, \"wert\");\n+    }\n+\n+    private void deleteRow(int key1, int key2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(deleteRowDML, dataTableFullName, FIRST_ID, SECOND_ID));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, String val1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    FIRST_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertPartialRow(int key1, int key2, int value1)\n+            throws SQLException, IOException {\n+\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())){\n+            PreparedStatement\n+                    ps =\n+                    conn.prepareStatement(\n+                            String.format(partialRowUpsert1, dataTableFullName, FIRST_ID, SECOND_ID,\n+                                    SECOND_VALUE));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setInt(3, value1);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void upsertCompleteRow(int key1, int key2, String val1\n+    , int val2) throws SQLException, IOException {\n+        try(Connection conn = DriverManager.getConnection(getUrl(), new Properties())) {\n+            PreparedStatement\n+                    ps = conn.prepareStatement(String.format(completeRowUpsert, dataTableFullName));\n+            ps.setInt(1, key1);\n+            ps.setInt(2, key2);\n+            ps.setString(3, val1);\n+            ps.setInt(4, val2);\n+            ps.execute();\n+            convertUpsertToMutations(conn);\n+        }\n+    }\n+\n+    private void convertUpsertToMutations(Connection conn) throws SQLException, IOException {\n+        Iterator<Pair<byte[],List<KeyValue>>>\n+                dataTableNameAndMutationKeyValuesIter = PhoenixRuntime.getUncommittedDataIterator(conn);\n+        Pair<byte[], List<KeyValue>> elem = dataTableNameAndMutationKeyValuesIter.next();\n+        byte[] key = elem.getSecond().get(0).getRow();\n+        long mutationTS = EnvironmentEdgeManager.currentTimeMillis();\n+\n+        for (KeyValue kv : elem.getSecond()) {\n+            Cell cell =\n+                    CellUtil.createCell(kv.getRow(), kv.getFamily(), kv.getQualifier(),\n+                            mutationTS, kv.getType(), kv.getValue());\n+            if (KeyValue.Type.codeToType(cell.getTypeByte()) == KeyValue.Type.Put) {\n+                if (put == null ) {\n+                    put = new Put(key);\n+                }\n+                put.add(cell);\n+            } else {\n+                if (delete == null) {\n+                    delete = new Delete(key);\n+                }\n+                delete.addDeleteMarker(cell);\n+            }\n+        }\n+    }\n+\n+    private void initializeRebuildScannerAttributes() {\n+        when(rebuildScanner.setIndexTableTTL(Matchers.anyInt())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexMaintainer(Matchers.<IndexMaintainer>any())).thenCallRealMethod();\n+        when(rebuildScanner.setIndexKeyToMutationMap(Matchers.<Map>any())).thenCallRealMethod();\n+        rebuildScanner.setIndexTableTTL(HConstants.FOREVER);\n+        indexMaintainer = pIndexTable.getIndexMaintainer(pDataTable, pconn);\n+        rebuildScanner.setIndexMaintainer(indexMaintainer);\n+    }\n+\n+    private void initializeGlobalMockitoSetup() throws IOException {\n+        //setup\n+        when(rebuildScanner.getIndexRowKey(put)).thenCallRealMethod();\n+        when(rebuildScanner.prepareIndexMutations(put, delete)).thenCallRealMethod();\n+        when(rebuildScanner.verifySingleIndexRow(Matchers.<Result>any(),\n+                Matchers.<IndexToolVerificationResult.PhaseResult>any())).thenCallRealMethod();\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString(),\n+                        Matchers.<byte[]>any(), Matchers.<byte[]>any());\n+        doNothing().when(rebuildScanner)\n+                .logToIndexToolOutputTable(Matchers.<byte[]>any(),Matchers.<byte[]>any(),\n+                Mockito.anyLong(),Mockito.anyLong(), Mockito.anyString());\n+\n+        //populate the local map to use to create actual mutations\n+        indexKeyToMutationMapLocal = Maps.newTreeMap(Bytes.BYTES_COMPARATOR);\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMapLocal);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+\n+        //populate map to use in test code\n+        Map<byte[], List<Mutation>> indexKeyToMutationMap = Maps.newTreeMap((Bytes.BYTES_COMPARATOR));\n+        rebuildScanner.setIndexKeyToMutationMap(indexKeyToMutationMap);\n+        rebuildScanner.prepareIndexMutations(put, delete);\n+    }\n+\n+    private byte[] getValidRowKey() {\n+        return indexKeyToMutationMapLocal.entrySet().iterator().next().getKey();\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            actualPR.equals(expectedPR);\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_validIndexRowCount_moreActual() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_MORE_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_allMix() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_MIX_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_allUnverified() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getValidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.VALID_NEW_UNVERIFIED_MUTATIONS);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_expiredIndexRowCount_nonZero() throws IOException {\n+        IndexToolVerificationResult.PhaseResult\n+                expectedPR = new IndexToolVerificationResult.PhaseResult(0, 1, 0, 0);\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.EXPIRED);\n+            expireThisRow();\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_cellValue() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_CELL_VALUE);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_emptyCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EMPTY_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_diffColumn() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_COLUMN);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_invalidIndexRowCount_extraCell() throws IOException {\n+        IndexToolVerificationResult.PhaseResult expectedPR = getInvalidPhaseResult();\n+        for (Map.Entry<byte[], List<Mutation>>\n+                entry : indexKeyToMutationMapLocal.entrySet()) {\n+            initializeLocalMockitoSetup(entry, TestType.INVALID_EXTRA_CELL);\n+            //test code\n+            rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+            //assert\n+            assertTrue(actualPR.equals(expectedPR));\n+        }\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_expectedMutations_null() throws IOException {\n+        when(indexRow.getRow()).thenReturn(Bytes.toBytes(1));\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.NO_EXPECTED_MUTATION);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_actualMutations_null() throws IOException {\n+        byte [] validRowKey = getValidRowKey();\n+        when(indexRow.getRow()).thenReturn(validRowKey);\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(null);\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.ACTUAL_MUTATION_IS_NULL_OR_EMPTY);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    @Test\n+    public void testVerifySingleIndexRow_actualMutations_empty() throws IOException {\n+        byte [] validRowKey = getValidRowKey();\n+        when(indexRow.getRow()).thenReturn(validRowKey);\n+        actualMutationList = new ArrayList<>();\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(actualMutationList);\n+        exceptionRule.expect(DoNotRetryIOException.class);\n+        exceptionRule.expectMessage(IndexRebuildRegionScanner.ACTUAL_MUTATION_IS_NULL_OR_EMPTY);\n+        rebuildScanner.verifySingleIndexRow(indexRow, actualPR);\n+    }\n+\n+    private IndexToolVerificationResult.PhaseResult getValidPhaseResult() {\n+        return new IndexToolVerificationResult.PhaseResult(1,0,0,0);\n+    }\n+\n+    private IndexToolVerificationResult.PhaseResult getInvalidPhaseResult() {\n+        return new IndexToolVerificationResult.PhaseResult(0, 0, 0, 1);\n+    }\n+\n+    private void initializeLocalMockitoSetup(Map.Entry<byte[], List<Mutation>> entry,\n+            TestType testType)\n+            throws IOException {\n+        actualPR = new IndexToolVerificationResult.PhaseResult();\n+        byte[] indexKey = entry.getKey();\n+        when(indexRow.getRow()).thenReturn(indexKey);\n+        actualMutationList = buildActualIndexMutationsList(testType);\n+        when(rebuildScanner.prepareActualIndexMutations(indexRow)).thenReturn(actualMutationList);\n+    }\n+\n+    private List<Mutation> buildActualIndexMutationsList(TestType testType) {\n+        List<Mutation> actualMutations = new ArrayList<>();\n+        actualMutations.addAll(indexKeyToMutationMapLocal.get(indexRow.getRow()));\n+        if(testType.equals(TestType.EXPIRED)) {\n+            return actualMutations;\n+        }\n+        if(testType.toString().startsWith(\"VALID\")) {\n+            return getValidActualMutations(testType, actualMutations);\n+        }\n+        if(testType.toString().startsWith(\"INVALID\")) {\n+            return getInvalidActualMutations(testType, actualMutations);\n+        }\n+        return null;\n+    }\n+\n+    private List <Mutation> getValidActualMutations(TestType testType,\n+            List<Mutation> actualMutations) {\n+        List <Mutation> newActualMutations = new ArrayList<>();\n+        if(testType.equals(TestType.VALID)) {\n+            return actualMutations;\n+        }\n+        if (testType.equals(TestType.VALID_MIX_MUTATIONS)) {\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getDeleteMutation(actualMutations.get(0), new Long(1)));\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+        }\n+        if (testType.equals(TestType.VALID_NEW_UNVERIFIED_MUTATIONS)) {\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), new Long(1)));\n+        }\n+        newActualMutations.addAll(actualMutations);\n+        if(testType.equals(TestType.VALID_MORE_MUTATIONS)) {\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getDeleteMutation(actualMutations.get(0), null));\n+            newActualMutations.add(getDeleteMutation(actualMutations.get(0), new Long(1)));\n+            newActualMutations.add(getUnverifiedPutMutation(actualMutations.get(0), new Long(1)));\n+        }\n+        return newActualMutations;\n+    }\n+\n+    private List <Mutation> getInvalidActualMutations(TestType testType,\n+            List<Mutation> actualMutations) {\n+        List <Mutation> newActualMutations = new ArrayList<>();\n+        newActualMutations.addAll(actualMutations);\n+        for (Mutation m : actualMutations) {\n+            newActualMutations.remove(m);\n+            NavigableMap<byte[], List<Cell>> familyCellMap = m.getFamilyCellMap();\n+            List<Cell> cellList = familyCellMap.firstEntry().getValue();\n+            List<Cell> newCellList = new ArrayList<>();\n+            byte[] fam = CellUtil.cloneFamily(cellList.get(0));\n+            for (Cell c : cellList) {\n+                infiltrateCell(c, newCellList, testType);", "originalCommit": "3ed237a599e889ce9a8c03ff2448a6b0d35fb463", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9445e9c9213771bb434677356a2c44ddb7bcd106", "url": "https://github.com/apache/phoenix/commit/9445e9c9213771bb434677356a2c44ddb7bcd106", "message": "Fixing review comments", "committedDate": "2020-03-13T18:14:19Z", "type": "commit"}, {"oid": "aaf838478db333f263136fe538c51c31a114b3e3", "url": "https://github.com/apache/phoenix/commit/aaf838478db333f263136fe538c51c31a114b3e3", "message": "Adding comments and changed name", "committedDate": "2020-03-13T20:51:52Z", "type": "commit"}]}