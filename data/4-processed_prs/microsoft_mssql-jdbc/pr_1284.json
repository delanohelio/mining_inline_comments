{"pr_number": 1284, "pr_title": "Feature | client certificate authentication", "pr_createdAt": "2020-03-16T19:36:51Z", "pr_url": "https://github.com/microsoft/mssql-jdbc/pull/1284", "timeline": [{"oid": "c97b863c95385bdcd1afc897ef39cbebaf495578", "url": "https://github.com/microsoft/mssql-jdbc/commit/c97b863c95385bdcd1afc897ef39cbebaf495578", "message": "Fix AEv2 tests exclude for reqExternalSetup and cleanup (#1247)", "committedDate": "2020-02-05T19:03:48Z", "type": "commit"}, {"oid": "54b5a194e5d46552419c86e0d1f8c800f42d3de8", "url": "https://github.com/microsoft/mssql-jdbc/commit/54b5a194e5d46552419c86e0d1f8c800f42d3de8", "message": "Fix | Add null check for getObject() with LocalTime and LocalDate (#1250)", "committedDate": "2020-02-08T00:19:05Z", "type": "commit"}, {"oid": "672b7d67caae75250c53f82a760e8d3880e62a37", "url": "https://github.com/microsoft/mssql-jdbc/commit/672b7d67caae75250c53f82a760e8d3880e62a37", "message": "added all AKV tests to use reqExternalSetup tag so they will be skipped by default (#1254)\n\n* skip AKV test properly\r\n\r\n* removed enclave properties string to failed errors as enclave tests could be skipped", "committedDate": "2020-02-10T19:04:22Z", "type": "commit"}, {"oid": "f006c4eb7daf92211d90bdb5f0c088eb50969914", "url": "https://github.com/microsoft/mssql-jdbc/commit/f006c4eb7daf92211d90bdb5f0c088eb50969914", "message": "Added new Azure endpoints to the list of trusted endpoints (#1264)", "committedDate": "2020-02-24T20:22:09Z", "type": "commit"}, {"oid": "5f33c574906313ecd45694a9e3638d12c23bf837", "url": "https://github.com/microsoft/mssql-jdbc/commit/5f33c574906313ecd45694a9e3638d12c23bf837", "message": "Release | Changes for 8.2.1 HotFix release (#1260)", "committedDate": "2020-02-24T20:31:36Z", "type": "commit"}, {"oid": "10f973767ce0f6e6c2cbf9b2432f93e00f899883", "url": "https://github.com/microsoft/mssql-jdbc/commit/10f973767ce0f6e6c2cbf9b2432f93e00f899883", "message": "Sync master with dev for 8.2.1 Release", "committedDate": "2020-02-27T20:58:49Z", "type": "commit"}, {"oid": "77d25cb6b8729b98d3605b11681f319c9a75e951", "url": "https://github.com/microsoft/mssql-jdbc/commit/77d25cb6b8729b98d3605b11681f319c9a75e951", "message": "Release | 8.3.0-SNAPSHOT", "committedDate": "2020-02-27T21:28:10Z", "type": "commit"}, {"oid": "166add5529f1af3c17fe2dfa160f61bd3ef7dece", "url": "https://github.com/microsoft/mssql-jdbc/commit/166add5529f1af3c17fe2dfa160f61bd3ef7dece", "message": "Sync dev with master for 8.2.1 Release", "committedDate": "2020-02-27T21:29:07Z", "type": "commit"}, {"oid": "3346b3a17f92d6ad2c9ddd3593f04d52e6ed65cd", "url": "https://github.com/microsoft/mssql-jdbc/commit/3346b3a17f92d6ad2c9ddd3593f04d52e6ed65cd", "message": "Release | Add snapshot to pom file", "committedDate": "2020-02-27T22:47:48Z", "type": "commit"}, {"oid": "bef72c52169edd02f7794ace32a684be1e4c0a7f", "url": "https://github.com/microsoft/mssql-jdbc/commit/bef72c52169edd02f7794ace32a684be1e4c0a7f", "message": "Release | Update version to 8.3.0-SNAPSHOT", "committedDate": "2020-02-28T00:14:23Z", "type": "commit"}, {"oid": "560be4ce0675adb7b2826220977bf85aa87d63d3", "url": "https://github.com/microsoft/mssql-jdbc/commit/560be4ce0675adb7b2826220977bf85aa87d63d3", "message": "initial stuff", "committedDate": "2020-03-04T20:40:23Z", "type": "commit"}, {"oid": "bcc4a03b4433bb32bce008464ec438030b9d8abf", "url": "https://github.com/microsoft/mssql-jdbc/commit/bcc4a03b4433bb32bce008464ec438030b9d8abf", "message": "Merge branch 'dev' of https://github.com/Microsoft/mssql-jdbc into clientcertauth", "committedDate": "2020-03-09T20:43:21Z", "type": "commit"}, {"oid": "2508f53e3bd79be0de1cba07d9bc6da529d3258c", "url": "https://github.com/microsoft/mssql-jdbc/commit/2508f53e3bd79be0de1cba07d9bc6da529d3258c", "message": "Add support for PKCS8 and PKCS1 private keys", "committedDate": "2020-03-10T16:37:21Z", "type": "commit"}, {"oid": "15293afaecf17371b1a9016875d0684c14c15b00", "url": "https://github.com/microsoft/mssql-jdbc/commit/15293afaecf17371b1a9016875d0684c14c15b00", "message": "Remove imports", "committedDate": "2020-03-10T16:41:36Z", "type": "commit"}, {"oid": "e1e7c428bdb5211113e4329f76aae9f70c390f16", "url": "https://github.com/microsoft/mssql-jdbc/commit/e1e7c428bdb5211113e4329f76aae9f70c390f16", "message": "Remove imports from iobuffer", "committedDate": "2020-03-10T16:41:55Z", "type": "commit"}, {"oid": "9d2013654ce486e6f899d8b74965006eedbbdd44", "url": "https://github.com/microsoft/mssql-jdbc/commit/9d2013654ce486e6f899d8b74965006eedbbdd44", "message": "more import cleanup", "committedDate": "2020-03-10T16:42:25Z", "type": "commit"}, {"oid": "e2d5f88f7aeccd7ace88fb5261e2feb36ebc97e5", "url": "https://github.com/microsoft/mssql-jdbc/commit/e2d5f88f7aeccd7ace88fb5261e2feb36ebc97e5", "message": "Merge pull request #11 from rene-ye/clientcertauth\n\nAdd support for PKCS8 and PKCS1 private keys", "committedDate": "2020-03-10T16:43:20Z", "type": "commit"}, {"oid": "fa15950f8424791d9551ee3e51956d88d167c0f4", "url": "https://github.com/microsoft/mssql-jdbc/commit/fa15950f8424791d9551ee3e51956d88d167c0f4", "message": "change logic for decryptprovider", "committedDate": "2020-03-10T16:45:10Z", "type": "commit"}, {"oid": "45a7a259820dff620773f496e7289326d7b82abe", "url": "https://github.com/microsoft/mssql-jdbc/commit/45a7a259820dff620773f496e7289326d7b82abe", "message": "Add PVK support", "committedDate": "2020-03-10T17:06:52Z", "type": "commit"}, {"oid": "b51d9b9a4b1578d5d945b0c51c11501dafcc4fad", "url": "https://github.com/microsoft/mssql-jdbc/commit/b51d9b9a4b1578d5d945b0c51c11501dafcc4fad", "message": "changes", "committedDate": "2020-03-10T17:07:21Z", "type": "commit"}, {"oid": "a743065132e87a02b954cbfbbbe8362041afe9aa", "url": "https://github.com/microsoft/mssql-jdbc/commit/a743065132e87a02b954cbfbbbe8362041afe9aa", "message": "Merge branch 'clientcertauth' of https://github.com/peterbae/mssql-jdbc into clientcertauth", "committedDate": "2020-03-10T17:08:14Z", "type": "commit"}, {"oid": "13db00239144c5d9e019284c08ae5cead5ef716d", "url": "https://github.com/microsoft/mssql-jdbc/commit/13db00239144c5d9e019284c08ae5cead5ef716d", "message": "Merge pull request #12 from rene-ye/clientcertauth\n\nchange logic for decryptprovider", "committedDate": "2020-03-10T17:11:08Z", "type": "commit"}, {"oid": "fb19534292ca0da882ef3c2c407a3f801ee6497d", "url": "https://github.com/microsoft/mssql-jdbc/commit/fb19534292ca0da882ef3c2c407a3f801ee6497d", "message": "hw", "committedDate": "2020-03-12T19:52:37Z", "type": "commit"}, {"oid": "f94a3da0859a8186fe1a6020c75cfc75fcfaa926", "url": "https://github.com/microsoft/mssql-jdbc/commit/f94a3da0859a8186fe1a6020c75cfc75fcfaa926", "message": "Merge pull request #13 from rene-ye/clientcertauth\n\nhw", "committedDate": "2020-03-12T20:00:04Z", "type": "commit"}, {"oid": "3f5a9585835875481f7d41acdd06a0fd359776cb", "url": "https://github.com/microsoft/mssql-jdbc/commit/3f5a9585835875481f7d41acdd06a0fd359776cb", "message": "initial changes", "committedDate": "2020-03-16T16:46:23Z", "type": "commit"}, {"oid": "58fb495ae8fd93c4a0d95559d420b89f9258a92e", "url": "https://github.com/microsoft/mssql-jdbc/commit/58fb495ae8fd93c4a0d95559d420b89f9258a92e", "message": "update", "committedDate": "2020-03-16T19:20:53Z", "type": "commit"}, {"oid": "e521b6000f5fcbd2c31787274685503c26d42168", "url": "https://github.com/microsoft/mssql-jdbc/commit/e521b6000f5fcbd2c31787274685503c26d42168", "message": "try", "committedDate": "2020-03-16T19:33:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4ODgxOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r393288819", "bodyText": "Does this need any sort of open source approval?", "author": "saurabh500", "createdAt": "2020-03-16T20:22:41Z", "path": "pom.xml", "diffHunk": "@@ -122,6 +122,13 @@\n \t\t\t<version>1.64</version>\n \t\t\t<optional>true</optional>\n \t\t</dependency>\n+\t\t\n+\t\t<!-- dependencies for Client Certificate Authentication -->\n+\t\t<dependency>", "originalCommit": "e521b6000f5fcbd2c31787274685503c26d42168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MDA5OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r393290099", "bodyText": "Yes, we will have to talk to crypto team for approval.", "author": "peterbae", "createdAt": "2020-03-16T20:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4ODgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4OTkzNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r393289934", "bodyText": "Can \"PKCS12\" be turned into a constant string? Or is there a constant in JDK that can be used instead?", "author": "saurabh500", "createdAt": "2020-03-16T20:25:02Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.Security;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r", "originalCommit": "e521b6000f5fcbd2c31787274685503c26d42168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAwMTE4MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398001181", "bodyText": "Will do.", "author": "peterbae", "createdAt": "2020-03-25T16:38:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI4OTkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTA5Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r393291092", "bodyText": "Is it possible to use the StringBuilder to do these manipulations on the key?\nThe current code will create new instances of String since String is immutable. Can we optimize a bit for memory?", "author": "saurabh500", "createdAt": "2020-03-16T20:27:35Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.Security;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\r\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\r\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\r\n+        return keyManagerFactory.getKeyManagers();\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        Certificate clientCertificate = loadCertificate(certPath);\r\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\r\n+\r\n+        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n+        keyStore.load(null, null);\r\n+        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\r\n+        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\r\n+                new Certificate[] {clientCertificate});\r\n+\r\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n+        kmf.init(keyStore, keyPassword.toCharArray());\r\n+        return kmf.getKeyManagers();\r\n+    }\r\n+\r\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\r\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\r\n+        InputStream certstream = fileToStream(certificatePem);\r\n+        return certificateFactory.generateCertificate(certstream);\r\n+    }\r\n+\r\n+    // PKCS#8 format\r\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\r\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\r\n+    // PKCS#1 format\r\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\r\n+    // PVK format\r\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\r\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\r\n+    private static final String RC4_ALG = \"RC4\";\r\n+    private static final String RSA_ALG = \"RSA\";\r\n+\r\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\r\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\r\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\r\n+\r\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\r\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\r\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\r\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\r\n+        } else {\r\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\r\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\r", "originalCommit": "e521b6000f5fcbd2c31787274685503c26d42168", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTM4OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r393291389", "bodyText": "Instead of relying on empty exception handling, is there a way to check if the provider is loaded, and use that ?", "author": "saurabh500", "createdAt": "2020-03-16T20:28:14Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.Security;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\r\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\r\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\r\n+        return keyManagerFactory.getKeyManagers();\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        Certificate clientCertificate = loadCertificate(certPath);\r\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\r\n+\r\n+        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n+        keyStore.load(null, null);\r\n+        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\r\n+        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\r\n+                new Certificate[] {clientCertificate});\r\n+\r\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n+        kmf.init(keyStore, keyPassword.toCharArray());\r\n+        return kmf.getKeyManagers();\r\n+    }\r\n+\r\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\r\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\r\n+        InputStream certstream = fileToStream(certificatePem);\r\n+        return certificateFactory.generateCertificate(certstream);\r\n+    }\r\n+\r\n+    // PKCS#8 format\r\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\r\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\r\n+    // PKCS#1 format\r\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\r\n+    // PVK format\r\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\r\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\r\n+    private static final String RC4_ALG = \"RC4\";\r\n+    private static final String RSA_ALG = \"RSA\";\r\n+\r\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\r\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\r\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\r\n+\r\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\r\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\r\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\r\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\r\n+        } else {\r\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\r\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\r\n+        key = key.replaceAll(\"\\\\s\", \"\");\r\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\r\n+\r\n+        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\r\n+        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\r\n+            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        try {\r\n+            Security.addProvider(new BouncyCastleProvider());\r\n+        } catch (SecurityException se) {\r\n+            // fall through, provider already loaded\r", "originalCommit": "e521b6000f5fcbd2c31787274685503c26d42168", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAyNzY1Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398027653", "bodyText": "Hi @saurabh500, in my opinion this is the best way to handle loading this dependency. The empty catch is there in case the user has loaded BouncyCastle themselves, and this is more efficient and reliable then trying to determine whether they've loaded BC or not.", "author": "rene-ye", "createdAt": "2020-03-25T17:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk4NzUxNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398987517", "bodyText": "SecurityException is thrown if a security manager exists and its method denies access to add a new provider. So there can be multiple reasons why this exception is thrown, not only when the provider exists.\nWhy is this approach better than just checking if provider is loaded using Security.getProvider(name)?", "author": "ulvii", "createdAt": "2020-03-27T01:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MTkzNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r393291937", "bodyText": "Magic number 4. can you create a constant out of it?", "author": "saurabh500", "createdAt": "2020-03-16T20:29:29Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.Security;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\r\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\r\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\r\n+        return keyManagerFactory.getKeyManagers();\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        Certificate clientCertificate = loadCertificate(certPath);\r\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\r\n+\r\n+        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n+        keyStore.load(null, null);\r\n+        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\r\n+        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\r\n+                new Certificate[] {clientCertificate});\r\n+\r\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n+        kmf.init(keyStore, keyPassword.toCharArray());\r\n+        return kmf.getKeyManagers();\r\n+    }\r\n+\r\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\r\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\r\n+        InputStream certstream = fileToStream(certificatePem);\r\n+        return certificateFactory.generateCertificate(certstream);\r\n+    }\r\n+\r\n+    // PKCS#8 format\r\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\r\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\r\n+    // PKCS#1 format\r\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\r\n+    // PVK format\r\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\r\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\r\n+    private static final String RC4_ALG = \"RC4\";\r\n+    private static final String RSA_ALG = \"RSA\";\r\n+\r\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\r\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\r\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\r\n+\r\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\r\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\r\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\r\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\r\n+        } else {\r\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\r\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\r\n+        key = key.replaceAll(\"\\\\s\", \"\");\r\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\r\n+\r\n+        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\r\n+        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\r\n+            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        try {\r\n+            Security.addProvider(new BouncyCastleProvider());\r\n+        } catch (SecurityException se) {\r\n+            // fall through, provider already loaded\r\n+        }\r\n+        PEMParser pemParser = null;\r\n+        try {\r\n+            pemParser = new PEMParser(new StringReader(key));\r\n+            Object object = pemParser.readObject();\r\n+            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\r\n+            KeyPair kp;\r\n+            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\r\n+                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\r\n+                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\r\n+            } else {\r\n+                kp = converter.getKeyPair((PEMKeyPair) object);\r\n+            }\r\n+            return kp.getPrivate();\r\n+        } finally {\r\n+            pemParser.close();\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\r\n+            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        File f = new File(keyPath);\r\n+        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\r\n+        try (FileInputStream in = new FileInputStream(f)) {\r\n+            in.getChannel().read(buffer);\r\n+            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\r\n+\r\n+            long magic = buffer.getInt() & 0xFFFFFFFFL;\r\n+            if (PVK_MAGIC != magic) {\r\n+                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\r\n+                        \"\", false);\r\n+            }\r\n+\r\n+            buffer.position(buffer.position() + 8); // skip reserved and keytype\r\n+            boolean encrypted = buffer.getInt() != 0;\r\n+            int saltLength = buffer.getInt();\r\n+            int keyLength = buffer.getInt();\r\n+            byte[] salt = new byte[saltLength];\r\n+            buffer.get(salt);\r\n+\r\n+            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\r\n+\r\n+            byte[] key = new byte[keyLength - 8];\r\n+            buffer.get(key);\r\n+\r\n+            if (encrypted) {\r\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\r\n+                digest.update(salt);\r\n+                if (keyPass != null) {\r\n+                    digest.update(keyPass.getBytes());\r\n+                }\r\n+                byte[] hash = digest.digest();\r\n+                key = getSecretKeyFromHash(key, hash);\r\n+            }\r\n+\r\n+            ByteBuffer keyBuff = ByteBuffer.wrap(key).order(ByteOrder.LITTLE_ENDIAN);\r\n+            keyBuff.position(RSA2_MAGIC.length); // skip the header\r\n+\r\n+            int byteLength = keyBuff.getInt() / 8;\r\n+            BigInteger publicExponent = BigInteger.valueOf(keyBuff.getInt());\r\n+            BigInteger modulus = getBigInteger(keyBuff, byteLength);\r\n+            BigInteger prime1 = getBigInteger(keyBuff, byteLength / 2);\r\n+            BigInteger prime2 = getBigInteger(keyBuff, byteLength / 2);\r\n+            BigInteger primeExponent1 = getBigInteger(keyBuff, byteLength / 2);\r\n+            BigInteger primeExponent2 = getBigInteger(keyBuff, byteLength / 2);\r\n+            BigInteger crtCoefficient = getBigInteger(keyBuff, byteLength / 2);\r\n+            BigInteger privateExponent = getBigInteger(keyBuff, byteLength);\r\n+\r\n+            RSAPrivateCrtKeySpec spec = new RSAPrivateCrtKeySpec(modulus, publicExponent, privateExponent, prime1,\r\n+                    prime2, primeExponent1, primeExponent2, crtCoefficient);\r\n+            KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\r\n+            return factory.generatePrivate(spec);\r\n+        }\r\n+    }\r\n+\r\n+    private static boolean startsWithMagic(byte[] b) {\r\n+        for (int i = 0; i < 4; i++) {\r", "originalCommit": "e521b6000f5fcbd2c31787274685503c26d42168", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e36be2b40b0d14ca94689870b6995136511985ef", "url": "https://github.com/microsoft/mssql-jdbc/commit/e36be2b40b0d14ca94689870b6995136511985ef", "message": "statically load BC", "committedDate": "2020-03-16T20:39:13Z", "type": "commit"}, {"oid": "32ed914a84c1a51a049a472b09b42ef6cf3d2b14", "url": "https://github.com/microsoft/mssql-jdbc/commit/32ed914a84c1a51a049a472b09b42ef6cf3d2b14", "message": "update test", "committedDate": "2020-03-16T22:06:34Z", "type": "commit"}, {"oid": "fd353311e0994f478517e6ec811edb254a3bbd0e", "url": "https://github.com/microsoft/mssql-jdbc/commit/fd353311e0994f478517e6ec811edb254a3bbd0e", "message": "format", "committedDate": "2020-03-16T23:33:25Z", "type": "commit"}, {"oid": "ceca02beb53b3c5c8f9b7bb8d9ca152f1e060957", "url": "https://github.com/microsoft/mssql-jdbc/commit/ceca02beb53b3c5c8f9b7bb8d9ca152f1e060957", "message": "update test", "committedDate": "2020-03-17T19:59:13Z", "type": "commit"}, {"oid": "e4621c879bb6bea6ec9b3151e0579b45feb012ae", "url": "https://github.com/microsoft/mssql-jdbc/commit/e4621c879bb6bea6ec9b3151e0579b45feb012ae", "message": "add null check", "committedDate": "2020-03-18T17:58:49Z", "type": "commit"}, {"oid": "565c16d5063bb3140e5a6beb6980a76de03c4b79", "url": "https://github.com/microsoft/mssql-jdbc/commit/565c16d5063bb3140e5a6beb6980a76de03c4b79", "message": "logic change", "committedDate": "2020-03-18T20:53:27Z", "type": "commit"}, {"oid": "db3d040b41d3fe44a60a096076941919244a5dd0", "url": "https://github.com/microsoft/mssql-jdbc/commit/db3d040b41d3fe44a60a096076941919244a5dd0", "message": "test change", "committedDate": "2020-03-18T23:08:16Z", "type": "commit"}, {"oid": "e802213277d0e443fc327c946954a0e75a48e806", "url": "https://github.com/microsoft/mssql-jdbc/commit/e802213277d0e443fc327c946954a0e75a48e806", "message": "test update", "committedDate": "2020-03-20T15:33:09Z", "type": "commit"}, {"oid": "bae1e045e5ba01f8e13898f3c0a4cd9de21f42ba", "url": "https://github.com/microsoft/mssql-jdbc/commit/bae1e045e5ba01f8e13898f3c0a4cd9de21f42ba", "message": "Fix some issues", "committedDate": "2020-03-20T16:16:33Z", "type": "commit"}, {"oid": "bee991c2d4f6dc729c23fe62b50cb5cae59b72f9", "url": "https://github.com/microsoft/mssql-jdbc/commit/bee991c2d4f6dc729c23fe62b50cb5cae59b72f9", "message": "Add resources", "committedDate": "2020-03-20T16:34:46Z", "type": "commit"}, {"oid": "a791523ad7b63679dbdf3ca60bf6dd2df148fc77", "url": "https://github.com/microsoft/mssql-jdbc/commit/a791523ad7b63679dbdf3ca60bf6dd2df148fc77", "message": "Merge branch 'clientcertauth' of https://github.com/peterbae/mssql-jdbc into clientcertauth\n\n# Conflicts:\n#\tsrc/main/java/com/microsoft/sqlserver/jdbc/SQLServerResource.java", "committedDate": "2020-03-20T16:44:29Z", "type": "commit"}, {"oid": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "url": "https://github.com/microsoft/mssql-jdbc/commit/887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "message": "Merge branch 'dev' of https://github.com/Microsoft/mssql-jdbc into clientcertauth", "committedDate": "2020-03-20T20:25:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MjM1OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397652358", "bodyText": "are these tabs?", "author": "lilgreenbird", "createdAt": "2020-03-25T07:30:04Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -1774,13 +1782,31 @@ else if (con.getTrustManagerClass() != null) {\n             if (logger.isLoggable(Level.FINEST))\n                 logger.finest(toString() + \" Getting TLS or better SSL context\");\n \n-            sslContext = SSLContext.getInstance(sslProtocol);\n-            sslContextProvider = sslContext.getProvider();\n+            if (null != clientCertificate) {\n+                try {\n+                    KeyManager[] km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n+                            clientKeyPassword);\n+                    \n+                    sslContext = SSLContext.getInstance(sslProtocol);\n+                    sslContextProvider = sslContext.getProvider();\n \n-            if (logger.isLoggable(Level.FINEST))\n-                logger.finest(toString() + \" Initializing SSL context\");\n+                    if (logger.isLoggable(Level.FINEST))\n+                        logger.finest(toString() + \" Initializing SSL context\");", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAwMDc1Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398000752", "bodyText": "Will fix.", "author": "peterbae", "createdAt": "2020-03-25T16:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MjM1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MzM0Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397653342", "bodyText": "should we have this? we don't usually have getters for passwords", "author": "lilgreenbird", "createdAt": "2020-03-25T07:32:46Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/ISQLServerDataSource.java", "diffHunk": "@@ -903,5 +903,50 @@\n      *        Enclave attestation protocol.\n      */\n     void setEnclaveAttestationProtocol(String protocol);\n+    \n+    /**\n+     * Returns client certificate path for client certificate authentication.\n+     * \n+     * @return Client certificate path.\n+     */\n+    String getClientCertificate();\n+\n+    /**\n+     * Sets client certificate path for client certificate authentication.\n+     * \n+     * @param certPath\n+     *        Client certificate path.\n+     */\n+    void setClientCertificate(String certPath);\n+    \n+    /**\n+     * Returns Private key file path for client certificate authentication.\n+     * \n+     * @return Private key file path.\n+     */\n+    String getClientKey();\n+\n+    /**\n+     * Sets Private key file path for client certificate authentication.\n+     * \n+     * @param keyPath\n+     *        Private key file path.\n+     */\n+    void setClientKey(String keyPath);\n+    \n+    /**\n+     * Returns the password to be used for Private key provided by the user for client certificate authentication.\n+     * \n+     * @return Private key password.\n+     */\n+    String getClientKeyPassword();", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAwMDkyNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398000926", "bodyText": "Good point, I'll remove this one.", "author": "peterbae", "createdAt": "2020-03-25T16:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1MzM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1Njc4OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397656788", "bodyText": "are these hardcoded aliases defined in the specs? can we define them somewhere else?", "author": "lilgreenbird", "createdAt": "2020-03-25T07:41:30Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\r\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\r\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\r\n+        return keyManagerFactory.getKeyManagers();\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        Certificate clientCertificate = loadCertificate(certPath);\r\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\r\n+\r\n+        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n+        keyStore.load(null, null);\r\n+        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\r\n+        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\r", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1ODYyOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397658629", "bodyText": "null !=", "author": "lilgreenbird", "createdAt": "2020-03-25T07:46:08Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerCertificateUtils.java", "diffHunk": "@@ -0,0 +1,274 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+\r\n+package com.microsoft.sqlserver.jdbc;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.DataInputStream;\r\n+import java.io.File;\r\n+import java.io.FileInputStream;\r\n+import java.io.FileNotFoundException;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.StringReader;\r\n+import java.math.BigInteger;\r\n+import java.nio.ByteBuffer;\r\n+import java.nio.ByteOrder;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Paths;\r\n+import java.security.GeneralSecurityException;\r\n+import java.security.KeyFactory;\r\n+import java.security.KeyPair;\r\n+import java.security.KeyStore;\r\n+import java.security.KeyStoreException;\r\n+import java.security.MessageDigest;\r\n+import java.security.NoSuchAlgorithmException;\r\n+import java.security.PrivateKey;\r\n+import java.security.UnrecoverableKeyException;\r\n+import java.security.cert.Certificate;\r\n+import java.security.cert.CertificateException;\r\n+import java.security.cert.CertificateFactory;\r\n+import java.security.spec.InvalidKeySpecException;\r\n+import java.security.spec.PKCS8EncodedKeySpec;\r\n+import java.security.spec.RSAPrivateCrtKeySpec;\r\n+import java.util.Arrays;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.SecretKey;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+import javax.net.ssl.KeyManager;\r\n+import javax.net.ssl.KeyManagerFactory;\r\n+\r\n+import org.bouncycastle.openssl.PEMDecryptorProvider;\r\n+import org.bouncycastle.openssl.PEMEncryptedKeyPair;\r\n+import org.bouncycastle.openssl.PEMKeyPair;\r\n+import org.bouncycastle.openssl.PEMParser;\r\n+import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;\r\n+import org.bouncycastle.openssl.jcajce.JcePEMDecryptorProviderBuilder;\r\n+\r\n+\r\n+final class SQLServerCertificateUtils {\r\n+\r\n+    static KeyManager[] getKeyManagerFromFile(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        if (keyPath != null && keyPath.length() > 0) {\r\n+            return readPKCS8Certificate(certPath, keyPath, keyPassword);\r\n+        } else {\r\n+            return readPKCS12Certificate(certPath, keyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS12Certificate(String certPath,\r\n+            String keyPassword) throws NoSuchAlgorithmException, CertificateException, FileNotFoundException, IOException, UnrecoverableKeyException, KeyStoreException {\r\n+        KeyStore keystore = KeyStore.getInstance(\"PKCS12\");\r\n+        keystore.load(new FileInputStream(certPath), keyPassword.toCharArray());\r\n+        KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(\"SunX509\");\r\n+        keyManagerFactory.init(keystore, keyPassword.toCharArray());\r\n+        return keyManagerFactory.getKeyManagers();\r\n+    }\r\n+\r\n+    private static KeyManager[] readPKCS8Certificate(String certPath, String keyPath,\r\n+            String keyPassword) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        Certificate clientCertificate = loadCertificate(certPath);\r\n+        PrivateKey privateKey = loadPrivateKey(keyPath, keyPassword);\r\n+\r\n+        KeyStore keyStore = KeyStore.getInstance(\"JKS\");\r\n+        keyStore.load(null, null);\r\n+        keyStore.setCertificateEntry(\"client-cert\", clientCertificate);\r\n+        keyStore.setKeyEntry(\"client-key\", privateKey, keyPassword.toCharArray(),\r\n+                new Certificate[] {clientCertificate});\r\n+\r\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\r\n+        kmf.init(keyStore, keyPassword.toCharArray());\r\n+        return kmf.getKeyManagers();\r\n+    }\r\n+\r\n+    private static Certificate loadCertificate(String certificatePem) throws IOException, GeneralSecurityException {\r\n+        CertificateFactory certificateFactory = CertificateFactory.getInstance(\"X509\");\r\n+        InputStream certstream = fileToStream(certificatePem);\r\n+        return certificateFactory.generateCertificate(certstream);\r\n+    }\r\n+\r\n+    // PKCS#8 format\r\n+    private static final String PEM_PRIVATE_START = \"-----BEGIN PRIVATE KEY-----\";\r\n+    private static final String PEM_PRIVATE_END = \"-----END PRIVATE KEY-----\";\r\n+    // PKCS#1 format\r\n+    private static final String PEM_RSA_PRIVATE_START = \"-----BEGIN RSA PRIVATE KEY-----\";\r\n+    // PVK format\r\n+    private static final long PVK_MAGIC = 0xB0B5F11EL;\r\n+    private static final byte[] RSA2_MAGIC = {82, 83, 65, 50};\r\n+    private static final String RC4_ALG = \"RC4\";\r\n+    private static final String RSA_ALG = \"RSA\";\r\n+\r\n+    private static PrivateKey loadPrivateKey(String privateKeyPemPath,\r\n+            String privateKeyPassword) throws GeneralSecurityException, IOException, SQLServerException {\r\n+        String privateKeyPem = getStringFromFile(privateKeyPemPath);\r\n+\r\n+        if (privateKeyPem.contains(PEM_PRIVATE_START)) { // PKCS#8 format\r\n+            return loadPrivateKeyFromPKCS8(privateKeyPem);\r\n+        } else if (privateKeyPem.contains(PEM_RSA_PRIVATE_START)) { // PKCS#1 format\r\n+            return loadPrivateKeyFromPKCS1(privateKeyPem, privateKeyPassword);\r\n+        } else {\r\n+            return loadPrivateKeyFromPVK(privateKeyPemPath, privateKeyPassword);\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS8(\r\n+            String key) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        key = key.replace(PEM_PRIVATE_START, \"\").replace(PEM_PRIVATE_END, \"\");\r\n+        key = key.replaceAll(\"\\\\s\", \"\");\r\n+        byte[] pkcs8EncodedKey = Base64.getDecoder().decode(key);\r\n+\r\n+        KeyFactory factory = KeyFactory.getInstance(RSA_ALG);\r\n+        return factory.generatePrivate(new PKCS8EncodedKeySpec(pkcs8EncodedKey));\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPKCS1(String key,\r\n+            String keyPass) throws IOException, NoSuchAlgorithmException, InvalidKeySpecException {\r\n+        try {\r\n+            SQLServerBouncyCastleLoader.loadBouncyCastle();\r\n+        } catch (SecurityException se) {\r\n+            // fall through, provider already loaded\r\n+        }\r\n+        PEMParser pemParser = null;\r\n+        try {\r\n+            pemParser = new PEMParser(new StringReader(key));\r\n+            Object object = pemParser.readObject();\r\n+            JcaPEMKeyConverter converter = new JcaPEMKeyConverter().setProvider(\"BC\");\r\n+            KeyPair kp;\r\n+            if (object instanceof PEMEncryptedKeyPair && keyPass != null) {\r\n+                PEMDecryptorProvider decProv = new JcePEMDecryptorProviderBuilder().build(keyPass.toCharArray());\r\n+                kp = converter.getKeyPair(((PEMEncryptedKeyPair) object).decryptKeyPair(decProv));\r\n+            } else {\r\n+                kp = converter.getKeyPair((PEMKeyPair) object);\r\n+            }\r\n+            return kp.getPrivate();\r\n+        } finally {\r\n+            pemParser.close();\r\n+        }\r\n+    }\r\n+\r\n+    private static PrivateKey loadPrivateKeyFromPVK(String keyPath,\r\n+            String keyPass) throws IOException, GeneralSecurityException, SQLServerException {\r\n+        File f = new File(keyPath);\r\n+        ByteBuffer buffer = ByteBuffer.allocate((int) f.length());\r\n+        try (FileInputStream in = new FileInputStream(f)) {\r\n+            in.getChannel().read(buffer);\r\n+            buffer.order(ByteOrder.LITTLE_ENDIAN).rewind();\r\n+\r\n+            long magic = buffer.getInt() & 0xFFFFFFFFL;\r\n+            if (PVK_MAGIC != magic) {\r\n+                SQLServerException.makeFromDriverError(null, magic, SQLServerResource.getResource(\"R_pvkHeaderError\"),\r\n+                        \"\", false);\r\n+            }\r\n+\r\n+            buffer.position(buffer.position() + 8); // skip reserved and keytype\r\n+            boolean encrypted = buffer.getInt() != 0;\r\n+            int saltLength = buffer.getInt();\r\n+            int keyLength = buffer.getInt();\r\n+            byte[] salt = new byte[saltLength];\r\n+            buffer.get(salt);\r\n+\r\n+            buffer.position(buffer.position() + 8); // skip btype(1b), version(1b), reserved(2b), and keyalg(4b)\r\n+\r\n+            byte[] key = new byte[keyLength - 8];\r\n+            buffer.get(key);\r\n+\r\n+            if (encrypted) {\r\n+                MessageDigest digest = MessageDigest.getInstance(\"SHA1\");\r\n+                digest.update(salt);\r\n+                if (keyPass != null) {\r", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY1OTUyMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397659520", "bodyText": "null ==\nmultiple occurences", "author": "lilgreenbird", "createdAt": "2020-03-25T07:48:14Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -4960,7 +4985,7 @@ final boolean complete(LogonCommand logonCommand, TDSReader tdsReader) throws SQ\n                 + 4; // AE is always on;\n \n         // only add lengths of password and username if not using SSPI or requesting federated authentication info\n-        if (!integratedSecurity && !(federatedAuthenticationInfoRequested || federatedAuthenticationRequested)) {\n+        if (!integratedSecurity && !(federatedAuthenticationInfoRequested || federatedAuthenticationRequested) && clientCertificate == null) {", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MDkyMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397660920", "bodyText": "no test for datasource getters and setters\nI think you also need to update AbstractTest.updateDataSource()", "author": "lilgreenbird", "createdAt": "2020-03-25T07:51:36Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pkcs8Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs8.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs8EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxEncrytedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\r\n+                + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pvkTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\r\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCert() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\r\n+                + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCertPassword() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\r\n+                + \"clientKeyPassword=invalid_password;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\r\n+        }\r\n+    }\r\n+}\r", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAyNjczNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398026737", "bodyText": "Thanks. I added a test for data source.", "author": "peterbae", "createdAt": "2020-03-25T17:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MDkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MTg3MQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r397661871", "bodyText": "? why are we only checking if it contains the string Microsoft?", "author": "lilgreenbird", "createdAt": "2020-03-25T07:53:48Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r", "originalCommit": "887fbdfb8cc7e787ddd119d88f3732a1fce7667a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODAwMzI1OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398003259", "bodyText": "Well...it can check any part of the string that @@Version will return. I just decided to use the keyword microsoft.", "author": "peterbae", "createdAt": "2020-03-25T16:41:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MTg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5MjUxMQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398992511", "bodyText": "I would suggest to use the existing conn.isValid(timeout); API.", "author": "ulvii", "createdAt": "2020-03-27T01:55:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY2MTg3MQ=="}], "type": "inlineReview"}, {"oid": "f64828f3b3c985cd0fa46195704a91fe5795417d", "url": "https://github.com/microsoft/mssql-jdbc/commit/f64828f3b3c985cd0fa46195704a91fe5795417d", "message": "Merge pull request #14 from rene-ye/clientcertauth\n\nClientcertauth", "committedDate": "2020-03-25T16:46:04Z", "type": "commit"}, {"oid": "a426136032358d95011cf8ebbf3783732c95cfb9", "url": "https://github.com/microsoft/mssql-jdbc/commit/a426136032358d95011cf8ebbf3783732c95cfb9", "message": "test update", "committedDate": "2020-03-25T17:08:04Z", "type": "commit"}, {"oid": "6b42090b39b132a39df29e97d134f563afb8dd59", "url": "https://github.com/microsoft/mssql-jdbc/commit/6b42090b39b132a39df29e97d134f563afb8dd59", "message": "disable clientcertauth on CI", "committedDate": "2020-03-25T19:35:45Z", "type": "commit"}, {"oid": "de3f1755cbf15c9f18dc31a8214907438c906e4b", "url": "https://github.com/microsoft/mssql-jdbc/commit/de3f1755cbf15c9f18dc31a8214907438c906e4b", "message": "make it optional", "committedDate": "2020-03-25T21:31:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1MDMwOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398250309", "bodyText": "create a variable for the version and use it for both bcpkix-jdk15on and bcprov-jdk15on", "author": "ulvii", "createdAt": "2020-03-26T00:28:24Z", "path": "pom.xml", "diffHunk": "@@ -122,6 +123,14 @@\n \t\t\t<version>1.64</version>\n \t\t\t<optional>true</optional>\n \t\t</dependency>\n+\t\t\n+\t\t<!-- dependencies for Client Certificate Authentication -->\n+\t\t<dependency>\n+\t\t\t<groupId>org.bouncycastle</groupId>\n+\t\t\t<artifactId>bcpkix-jdk15on</artifactId>\n+\t\t\t<version>1.64</version>", "originalCommit": "de3f1755cbf15c9f18dc31a8214907438c906e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1MjU1Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398752556", "bodyText": "done.", "author": "peterbae", "createdAt": "2020-03-26T17:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1MDMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2MzcyNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398263726", "bodyText": "Catching NullPointerException ???", "author": "ulvii", "createdAt": "2020-03-26T01:18:30Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -1774,13 +1782,31 @@ else if (con.getTrustManagerClass() != null) {\n             if (logger.isLoggable(Level.FINEST))\n                 logger.finest(toString() + \" Getting TLS or better SSL context\");\n \n-            sslContext = SSLContext.getInstance(sslProtocol);\n-            sslContextProvider = sslContext.getProvider();\n+            if (null != clientCertificate) {\n+                try {\n+                    KeyManager[] km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,\n+                            clientKeyPassword);\n \n-            if (logger.isLoggable(Level.FINEST))\n-                logger.finest(toString() + \" Initializing SSL context\");\n+                    sslContext = SSLContext.getInstance(sslProtocol);\n+                    sslContextProvider = sslContext.getProvider();\n+\n+                    if (logger.isLoggable(Level.FINEST))\n+                        logger.finest(toString() + \" Initializing SSL context\");\n+\n+                    sslContext.init(km, tm, null);\n+                } catch (NullPointerException | FileNotFoundException e) {", "originalCommit": "de3f1755cbf15c9f18dc31a8214907438c906e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODczODU5OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398738598", "bodyText": "We forgot to remove this exception, I've added null checks in the finally blocks inside the SQLServerCertificateUtils.java. We shouldn't need to catch NPE.", "author": "peterbae", "createdAt": "2020-03-26T17:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2MzcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2NDg2Mw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398264863", "bodyText": "The code in if/else are almost the same. You just need to initialize km to null and have km = SQLServerCertificateUtils.getKeyManagerFromFile(clientCertificate, clientKey,clientKeyPassword); inside if block.", "author": "ulvii", "createdAt": "2020-03-26T01:22:51Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -1774,13 +1782,31 @@ else if (con.getTrustManagerClass() != null) {\n             if (logger.isLoggable(Level.FINEST))\n                 logger.finest(toString() + \" Getting TLS or better SSL context\");\n \n-            sslContext = SSLContext.getInstance(sslProtocol);\n-            sslContextProvider = sslContext.getProvider();\n+            if (null != clientCertificate) {", "originalCommit": "de3f1755cbf15c9f18dc31a8214907438c906e4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc1NTIzNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398755236", "bodyText": "thanks. done", "author": "peterbae", "createdAt": "2020-03-26T17:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI2NDg2Mw=="}], "type": "inlineReview"}, {"oid": "c03a69f4a83bc67a3fc591f1cf51a3f0b3fa01cb", "url": "https://github.com/microsoft/mssql-jdbc/commit/c03a69f4a83bc67a3fc591f1cf51a3f0b3fa01cb", "message": "add null check", "committedDate": "2020-03-26T17:02:13Z", "type": "commit"}, {"oid": "898feca0c08f251d3d9d43789f16b506240e5a03", "url": "https://github.com/microsoft/mssql-jdbc/commit/898feca0c08f251d3d9d43789f16b506240e5a03", "message": "Fix pkcs8 and add tests", "committedDate": "2020-03-26T17:04:14Z", "type": "commit"}, {"oid": "85a8ad8bd83f301ff7521ad4ac128c30e4a4b4ee", "url": "https://github.com/microsoft/mssql-jdbc/commit/85a8ad8bd83f301ff7521ad4ac128c30e4a4b4ee", "message": "Remove uneeded import", "committedDate": "2020-03-26T17:06:13Z", "type": "commit"}, {"oid": "ee8f08b61c33f466a7b92d09df54b32b5b38cfdf", "url": "https://github.com/microsoft/mssql-jdbc/commit/ee8f08b61c33f466a7b92d09df54b32b5b38cfdf", "message": "Merge pull request #15 from rene-ye/clientcertauth\n\nFix pkcs8 and add tests", "committedDate": "2020-03-26T17:07:59Z", "type": "commit"}, {"oid": "7482c8eaec3d09783646262216dceb77d0b6740b", "url": "https://github.com/microsoft/mssql-jdbc/commit/7482c8eaec3d09783646262216dceb77d0b6740b", "message": "changes", "committedDate": "2020-03-26T17:26:06Z", "type": "commit"}, {"oid": "198b97d76a99f8353c01bf53e356797c520339b3", "url": "https://github.com/microsoft/mssql-jdbc/commit/198b97d76a99f8353c01bf53e356797c520339b3", "message": "Make some changes", "committedDate": "2020-03-26T17:31:18Z", "type": "commit"}, {"oid": "13b27a4ec2358b73d1c7c79a01fca38a0f3f0e6b", "url": "https://github.com/microsoft/mssql-jdbc/commit/13b27a4ec2358b73d1c7c79a01fca38a0f3f0e6b", "message": "Merge branch 'clientcertauth' of https://github.com/peterbae/mssql-jdbc into clientcertauth\n\n# Conflicts:\n#\tsrc/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "committedDate": "2020-03-26T17:34:34Z", "type": "commit"}, {"oid": "b7a6f9b8a349681e740a6e9f01207cf276a8d0b4", "url": "https://github.com/microsoft/mssql-jdbc/commit/b7a6f9b8a349681e740a6e9f01207cf276a8d0b4", "message": "Add file not found catching", "committedDate": "2020-03-26T17:37:39Z", "type": "commit"}, {"oid": "15ada35398836d584d706a620e9bc0d397f87630", "url": "https://github.com/microsoft/mssql-jdbc/commit/15ada35398836d584d706a620e9bc0d397f87630", "message": "Merge pull request #16 from rene-ye/clientcertauth\n\nClientcertauth", "committedDate": "2020-03-26T17:45:15Z", "type": "commit"}, {"oid": "a4868fecda835757ed2ac1c7affca641c02945f8", "url": "https://github.com/microsoft/mssql-jdbc/commit/a4868fecda835757ed2ac1c7affca641c02945f8", "message": "test changes", "committedDate": "2020-03-26T21:43:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NDQzNA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398954434", "bodyText": "This exception should be handled from the method that reads from the file, not here.", "author": "ulvii", "createdAt": "2020-03-26T23:37:44Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -1880,6 +1891,8 @@ else if (con.getTrustManagerClass() != null) {\n                     && (SQLServerException.getErrString(\"R_truncatedServerResponse\").equals(errMsg)\n                             || SQLServerException.getErrString(\"R_truncatedServerResponse\").equals(causeErrMsg))) {\n                 con.terminate(SQLServerException.DRIVER_ERROR_INTERMITTENT_TLS_FAILED, form.format(msgArgs), e);\n+            } else if (e instanceof FileNotFoundException) {", "originalCommit": "a4868fecda835757ed2ac1c7affca641c02945f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1ODI3Nw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398958277", "bodyText": "ok, I've reverted it to the way it was being handled before.", "author": "peterbae", "createdAt": "2020-03-26T23:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1NDQzNA=="}], "type": "inlineReview"}, {"oid": "30b989dd92aa1781da43a6a4cc0fb279c62905a1", "url": "https://github.com/microsoft/mssql-jdbc/commit/30b989dd92aa1781da43a6a4cc0fb279c62905a1", "message": "revert", "committedDate": "2020-03-26T23:49:12Z", "type": "commit"}, {"oid": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "url": "https://github.com/microsoft/mssql-jdbc/commit/6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "message": "handle exception", "committedDate": "2020-03-27T00:22:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk3ODMzMw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398978333", "bodyText": "Is this absolute path? Can applications also provide relative path?", "author": "ulvii", "createdAt": "2020-03-27T01:00:34Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/IOBuffer.java", "diffHunk": "@@ -1597,9 +1598,16 @@ private void validateServerNameInCertificate(X509Certificate cert) throws Certif\n      *        Server Host Name for SSL Handshake\n      * @param port\n      *        Server Port for SSL Handshake\n+     * @param clientCertificate\n+     *        Client certificate path", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM3NzIwMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399377200", "bodyText": "It accepts both relative and absolute path.", "author": "peterbae", "createdAt": "2020-03-27T16:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk3ODMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NDgwNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398994806", "bodyText": "You can use R_clientCertError from SQLServerResource.", "author": "ulvii", "createdAt": "2020-03-27T02:04:14Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pkcs8Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs8.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs8EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxEncrytedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\r\n+                + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pvkTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\r\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCert() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\r\n+                + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\r", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM5ODY3OQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399398679", "bodyText": "SQLServerResource is not visible in this package, we can just use the TestResource for test related texts.", "author": "peterbae", "createdAt": "2020-03-27T16:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NDgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQwMTI3Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399401272", "bodyText": "See SQLServerConnectionTest.executeInvalidFmt() for example use.\nassertTrue(e.getMessage().matches(TestUtils.formatErrorMsg(\"R_invalidArgument\")));", "author": "ulvii", "createdAt": "2020-03-27T16:46:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NDgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQxMTg0OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399411848", "bodyText": "Thanks. done.", "author": "peterbae", "createdAt": "2020-03-27T17:02:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NDgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NTIyOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398995229", "bodyText": "We should not be hardcoding the file names like this. Please use config properties file and specify full file names in it.", "author": "ulvii", "createdAt": "2020-03-27T02:06:00Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4OTk1Mg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399389952", "bodyText": "Why do we need to use a config file? The user can only provide one connection property for clientCertificate, and that one property needs to be re-used multiple times for different private key formats. The hardcoded strings here are the formats for the names that the test has defined. I can turn these hardcoded strings into constants, but I wouldn't use a config file here.", "author": "peterbae", "createdAt": "2020-03-27T16:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NTIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NzMzNw==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398997337", "bodyText": "Why aren't you using new DataSource APIs? setClientCertificate(), setClientKey(), setClientKeyPassword", "author": "ulvii", "createdAt": "2020-03-27T02:14:32Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pkcs8Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs8.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs8EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxEncrytedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\r\n+                + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pvkTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\r\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCert() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\r\n+                + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCertPassword() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\r\n+                + \"clientKeyPassword=invalid_password;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void testDataSource() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ4NTgyOQ==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399485829", "bodyText": "done", "author": "peterbae", "createdAt": "2020-03-27T19:13:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NzMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NzY0OA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r398997648", "bodyText": "Use R_pvkParseError from SQLServerResource instead.", "author": "ulvii", "createdAt": "2020-03-27T02:15:51Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs1.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs1.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pkcs8Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-pkcs8.key;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pkcs8EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pem;\" + \"clientKey=\"\r\n+                + clientKey + \"-encrypted-pkcs8.key;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void pfxEncrytedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \"-encrypted.pfx;\" + \"clientKeyPassword=\"\r\n+                + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+    \r\n+    @Test\r\n+    public void pvkTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".cer;\" + \"clientKey=\"\r\n+                + clientKey + \".pvk;\" + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            ResultSet rs = stmt.executeQuery(\"SELECT @@VERSION AS 'SQL Server Version'\");\r\n+            rs.next();\r\n+            assertTrue(rs.getString(1).contains(TestResource.getResource(\"R_microsoft\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCert() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=invalid_path;\" + \"clientKeyPassword=\" + clientKeyPassword\r\n+                + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_invalidPath\")));\r\n+        }\r\n+    }\r\n+\r\n+    @Test\r\n+    public void invalidCertPassword() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + \".pfx;\"\r\n+                + \"clientKeyPassword=invalid_password;\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr)) {\r\n+        } catch (SQLServerException e) {\r\n+            assertTrue(e.getMessage().contains(TestResource.getResource(\"R_keystorePassword\")));\r", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwMzQwMA==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399503400", "bodyText": "Why is this resolved?", "author": "ulvii", "createdAt": "2020-03-27T19:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NzY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTUwNDEzNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399504136", "bodyText": "For this error message, the error message isn't coming from the driver, it's coming from Java. So there's no SQLServerResource text to refer here.", "author": "peterbae", "createdAt": "2020-03-27T19:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk5NzY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA1MTMyNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399051326", "bodyText": "define this constant", "author": "lilgreenbird", "createdAt": "2020-03-27T06:02:37Z", "path": "src/main/java/com/microsoft/sqlserver/jdbc/SQLServerConnection.java", "diffHunk": "@@ -2629,7 +2654,7 @@ void Prelogin(String serverName, int portNumber) throws SQLServerException {\n                 0, 0, 0, 0, 0, 0,\n \n                 // - Encryption -\n-                requestedEncryptionLevel,\n+                (null == clientCertificate) ? requestedEncryptionLevel : (byte) (requestedEncryptionLevel | (byte) 0x80),", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4MDU2Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399380566", "bodyText": "done", "author": "peterbae", "createdAt": "2020-03-27T16:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA1MTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA1MzEwMg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399053102", "bodyText": "add description of what the tests are testing", "author": "lilgreenbird", "createdAt": "2020-03-27T06:09:40Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    @Test\r", "originalCommit": "6a2978f862c3307d09ec9f242b5ee7bdb45ba1ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM4NDAxNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399384016", "bodyText": "done", "author": "peterbae", "createdAt": "2020-03-27T16:20:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA1MzEwMg=="}], "type": "inlineReview"}, {"oid": "b6d6b19d06e0001146924bdbfe135126b73c1a5f", "url": "https://github.com/microsoft/mssql-jdbc/commit/b6d6b19d06e0001146924bdbfe135126b73c1a5f", "message": "comments", "committedDate": "2020-03-27T16:36:31Z", "type": "commit"}, {"oid": "51596474568003c5aa7754b7b76711f336505c3a", "url": "https://github.com/microsoft/mssql-jdbc/commit/51596474568003c5aa7754b7b76711f336505c3a", "message": "comments", "committedDate": "2020-03-27T17:02:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2ODYxNg==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399468616", "bodyText": "No need to create a statement", "author": "ulvii", "createdAt": "2020-03-27T18:40:37Z", "path": "src/test/java/com/microsoft/sqlserver/clientcertauth/ClientCertificateAuthenticationTest.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\r\n+ * Microsoft JDBC Driver for SQL Server Copyright(c) Microsoft Corporation All rights reserved. This program is made\r\n+ * available under the terms of the MIT License. See the LICENSE file in the project root for more information.\r\n+ */\r\n+package com.microsoft.sqlserver.clientcertauth;\r\n+\r\n+import static org.junit.Assert.assertTrue;\r\n+\r\n+import java.sql.Connection;\r\n+import java.sql.DriverManager;\r\n+import java.sql.ResultSet;\r\n+import java.sql.Statement;\r\n+\r\n+import org.junit.jupiter.api.Tag;\r\n+import org.junit.jupiter.api.Test;\r\n+import org.junit.platform.runner.JUnitPlatform;\r\n+import org.junit.runner.RunWith;\r\n+\r\n+import com.microsoft.sqlserver.jdbc.SQLServerDataSource;\r\n+import com.microsoft.sqlserver.jdbc.SQLServerException;\r\n+import com.microsoft.sqlserver.jdbc.TestResource;\r\n+import com.microsoft.sqlserver.jdbc.TestUtils;\r\n+import com.microsoft.sqlserver.testframework.AbstractTest;\r\n+import com.microsoft.sqlserver.testframework.Constants;\r\n+\r\n+\r\n+/**\r\n+ * Tests client certificate authentication feature\r\n+ * The feature is only supported against SQL Server Linux CU2 or higher.\r\n+ * \r\n+ */\r\n+@RunWith(JUnitPlatform.class)\r\n+@Tag(Constants.xSQLv12)\r\n+@Tag(Constants.xSQLv14)\r\n+@Tag(Constants.xAzureSQLDW)\r\n+@Tag(Constants.xAzureSQLDB)\r\n+@Tag(Constants.clientCertAuth)\r\n+public class ClientCertificateAuthenticationTest extends AbstractTest {\r\n+\r\n+    static final String PEM_SUFFIX = \".pem;\";\r\n+    static final String CER_SUFFIX = \".cer;\";\r\n+    static final String PVK_SUFFIX = \".pvk;\";\r\n+\r\n+    static final String PKCS1_KEY_SUFFIX = \"-pkcs1.key;\";\r\n+    static final String ENCRYPTED_PKCS1_KEY_SUFFIX = \"-encrypted-pkcs1.key;\";\r\n+    static final String PKCS8_KEY_SUFFIX = \"-pkcs8.key;\";\r\n+    static final String ENCRYPTED_PKCS8_KEY_SUFFIX = \"-encrypted-pkcs8.key;\";\r\n+    static final String PFX_KEY_SUFFIX = \".pfx;\";\r\n+    static final String ENCRYPTED_PFX_KEY_SUFFIX = \"-encrypted.pfx;\";\r\n+\r\n+    /**\r\n+     * Tests client certificate authentication feature with PKCS1 private key.\r\n+     * \r\n+     * @throws Exception\r\n+     */\r\n+    @Test\r\n+    public void pkcs1Test() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\r\n+                + clientKey + PKCS1_KEY_SUFFIX;\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r\n+            assertTrue(conn.isValid(1));\r\n+        }\r\n+    }\r\n+\r\n+    /**\r\n+     * Tests client certificate authentication feature with PKCS1 private key that has been encrypted with a password.\r\n+     * \r\n+     * @throws Exception\r\n+     */\r\n+    @Test\r\n+    public void pkcs1EncryptedTest() throws Exception {\r\n+        String conStr = connectionString + \";clientCertificate=\" + clientCertificate + PEM_SUFFIX + \"clientKey=\"\r\n+                + clientKey + ENCRYPTED_PKCS1_KEY_SUFFIX + \"clientKeyPassword=\" + clientKeyPassword + \";\";\r\n+        try (Connection conn = DriverManager.getConnection(conStr); Statement stmt = conn.createStatement()) {\r", "originalCommit": "51596474568003c5aa7754b7b76711f336505c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ3Nzk1Ng==", "url": "https://github.com/microsoft/mssql-jdbc/pull/1284#discussion_r399477956", "bodyText": "Thanks, done.", "author": "peterbae", "createdAt": "2020-03-27T18:58:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTQ2ODYxNg=="}], "type": "inlineReview"}, {"oid": "5d223e039cc99f41f4e6abff9566a6db7e550535", "url": "https://github.com/microsoft/mssql-jdbc/commit/5d223e039cc99f41f4e6abff9566a6db7e550535", "message": "dont need statements", "committedDate": "2020-03-27T18:58:00Z", "type": "commit"}, {"oid": "49ed48782f1538717321a73656dbfd475b08ed6e", "url": "https://github.com/microsoft/mssql-jdbc/commit/49ed48782f1538717321a73656dbfd475b08ed6e", "message": "use datasoure api", "committedDate": "2020-03-27T19:13:31Z", "type": "commit"}, {"oid": "0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "url": "https://github.com/microsoft/mssql-jdbc/commit/0533b48be8560e0dd2d1f24f2cd0e60ee0218eda", "message": "String match provider name", "committedDate": "2020-03-27T20:11:42Z", "type": "commit"}, {"oid": "c347a2905d33172731871696989c790b62ca8596", "url": "https://github.com/microsoft/mssql-jdbc/commit/c347a2905d33172731871696989c790b62ca8596", "message": "Merge pull request #17 from rene-ye/clientcertauth\n\nString match provider name", "committedDate": "2020-03-27T20:27:50Z", "type": "commit"}]}