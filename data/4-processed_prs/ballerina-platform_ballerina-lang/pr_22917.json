{"pr_number": 22917, "pr_title": "Introduce new API to validate OAuth2 tokens & move OAuth2 caching operations to validation logic [master]", "pr_createdAt": "2020-04-27T11:25:19Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917", "timeline": [{"oid": "b6334e13f4bd1dfd1020834b58797e8752d323eb", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b6334e13f4bd1dfd1020834b58797e8752d323eb", "message": "Add new API to validate OAuth2 token", "committedDate": "2020-04-27T09:43:45Z", "type": "commit"}, {"oid": "d7886d178fbc76e48555088973e06ec7ff14488f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d7886d178fbc76e48555088973e06ec7ff14488f", "message": "Move OAuth2 caching operations to validation logic", "committedDate": "2020-04-27T10:09:29Z", "type": "commit"}, {"oid": "815d2685c5eba78197a8cc0b727ef1c44613dad6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/815d2685c5eba78197a8cc0b727ef1c44613dad6", "message": "Build introspection response with all parameters", "committedDate": "2020-04-27T11:06:40Z", "type": "commit"}, {"oid": "ac27cd1c4720767c4b7c4079947ef3ea58f6f668", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ac27cd1c4720767c4b7c4079947ef3ea58f6f668", "message": "Update caching and retrieving implementation", "committedDate": "2020-04-27T11:21:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjA4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072081", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + token - OAuth2 token that needs to be validated\n          \n          \n            \n            # + token - OAuth2 token, which needs to be validated", "author": "praneesha", "createdAt": "2020-04-29T05:19:36Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjEzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072138", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n          \n          \n            \n            # + return - OAuth2 introspection server response or else an `oauth2:Error` if token validation fails", "author": "praneesha", "createdAt": "2020-04-29T05:19:51Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjIwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072207", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Build the request to be send to the introspection endpoint.\n          \n          \n            \n                // Builds the request to be sent to the introspection endpoint.", "author": "praneesha", "createdAt": "2020-04-29T05:20:06Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjUxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072510", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n          \n          \n            \n                // For more information, see the [OAuth 2.0 Token Introspection RFC](https://tools.ietf.org/html/rfc7662#section-2.1)", "author": "praneesha", "createdAt": "2020-04-29T05:21:10Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MjcxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072717", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // If the exp parameter is not set by introspection response, use cache default expiry by\n          \n          \n            \n                    // If the `exp` parameter is not set by the introspection response, use the cache default expiry by", "author": "praneesha", "createdAt": "2020-04-29T05:21:52Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3Mjc5Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072793", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n          \n          \n            \n                    // the `defaultTokenExpTimeInSeconds`. Then, the cached value will be removed when retrieving.", "author": "praneesha", "createdAt": "2020-04-29T05:22:05Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3Mjk2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417072963", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n          \n          \n            \n                    // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return `()`.", "author": "praneesha", "createdAt": "2020-04-29T05:22:21Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzAwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073008", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return \"Failed to validate token from from the cache, since token is expired.\";\n          \n          \n            \n                        return \"Failed to validate the token from the cache since the token is expired.\";", "author": "praneesha", "createdAt": "2020-04-29T05:22:35Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzA2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073067", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n          \n          \n            \n                        return \"Failed to validate the token from the cache. Cache error: \" + cachedValue.toString();", "author": "praneesha", "createdAt": "2020-04-29T05:22:48Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzE3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073175", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still\n          \n          \n            \n                // The `expTime` can be `()`. This means that the `defaultTokenExpTimeInSeconds` is not exceeded yet. Hence, the token is still", "author": "praneesha", "createdAt": "2020-04-29T05:23:18Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n         });\n-        return oauth2CacheEntry;\n+        return;\n+    }\n+    IntrospectionResponse response = <IntrospectionResponse>cachedValue;\n+    int? expTime = response?.exp;\n+    // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzUxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073517", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // valid. Convert to current time and check the expiry time is exceeds if the expTime is int.\n          \n          \n            \n                // valid. If the `expTime` is given in int, convert this to the current time and check if the expiry time is exceeded.", "author": "praneesha", "createdAt": "2020-04-29T05:24:25Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n         });\n-        return oauth2CacheEntry;\n+        return;\n+    }\n+    IntrospectionResponse response = <IntrospectionResponse>cachedValue;\n+    int? expTime = response?.exp;\n+    // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still\n+    // valid. Convert to current time and check the expiry time is exceeds if the expTime is int.", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzYxMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073610", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # Reads the scope(s) for the user with the given username.\n          \n          \n            \n            # Reads the scope(s) of the user with the given username.", "author": "praneesha", "createdAt": "2020-04-29T05:24:48Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n         });\n-        return oauth2CacheEntry;\n+        return;\n+    }\n+    IntrospectionResponse response = <IntrospectionResponse>cachedValue;\n+    int? expTime = response?.exp;\n+    // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still\n+    // valid. Convert to current time and check the expiry time is exceeds if the expTime is int.\n+    if (expTime is () || expTime > (time:currentTime().time / 1000)) {\n+        log:printDebug(function() returns string {\n+            return \"OAuth2 token validated from the cache. Introspection response: \" + response.toString();\n+        });\n+        return response;\n+    } else {\n+        cache:Error? result = oauth2Cache.invalidate(token);\n+        if (result is cache:Error) {\n+            log:printDebug(function() returns string {\n+                return \"Failed to invalidate OAuth2 token from the cache. Introspection response: \" + response.toString();\n+            });\n+        }\n     }\n }\n \n # Reads the scope(s) for the user with the given username.", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzY2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073663", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + return - Array of groups for the user denoted by the username\n          \n          \n            \n            # + return - Array of groups for the user who is denoted by the username", "author": "praneesha", "createdAt": "2020-04-29T05:24:58Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n         });\n-        return oauth2CacheEntry;\n+        return;\n+    }\n+    IntrospectionResponse response = <IntrospectionResponse>cachedValue;\n+    int? expTime = response?.exp;\n+    // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still\n+    // valid. Convert to current time and check the expiry time is exceeds if the expTime is int.\n+    if (expTime is () || expTime > (time:currentTime().time / 1000)) {\n+        log:printDebug(function() returns string {\n+            return \"OAuth2 token validated from the cache. Introspection response: \" + response.toString();\n+        });\n+        return response;\n+    } else {\n+        cache:Error? result = oauth2Cache.invalidate(token);\n+        if (result is cache:Error) {\n+            log:printDebug(function() returns string {\n+                return \"Failed to invalidate OAuth2 token from the cache. Introspection response: \" + response.toString();\n+            });\n+        }\n     }\n }\n \n # Reads the scope(s) for the user with the given username.\n #\n # + scopes - Set of scopes seperated with a space\n # + return - Array of groups for the user denoted by the username", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzY5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073691", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # Represents introspection server onfigurations.\n          \n          \n            \n            # Represents the introspection server configurations.", "author": "praneesha", "createdAt": "2020-04-29T05:25:09Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.\n+# ```ballerina\n+# oauth2:IntrospectionResponse|oauth2:Error result = oauth2:validateOAuth2Token(token, introspectionServerConfig);\n+# ```\n+#\n+# + token - OAuth2 token that needs to be validated\n+# + config -  OAuth2 introspection server configurations\n+# + return - OAuth2 introspection server response or else a `oauth2:Error` if token validation fails\n+public function validateOAuth2Token(string token, IntrospectionServerConfig config)\n+                                    returns @tainted (IntrospectionResponse|Error) {\n+    cache:Cache? oauth2Cache = config?.oauth2Cache;\n+    if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(token)) {\n+        IntrospectionResponse? response = validateFromCache(oauth2Cache, token);\n+        if (response is IntrospectionResponse) {\n+            return response;\n+        }\n+    }\n \n-                if (oauth2Cache is cache:Cache) {\n-                    addToAuthenticationCache(oauth2Cache, credential, username, scopes, exp);\n-                }\n-                auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(username, username, getScopes(scopes ?: \"\"));\n-                return true;\n+    // Build the request to be send to the introspection endpoint.\n+    // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n+    http:Request req = new;\n+    string textPayload = \"token=\" + token;\n+    string? tokenTypeHint = config?.tokenTypeHint;\n+    if (tokenTypeHint is string) {\n+        textPayload += \"&token_type_hint=\" + tokenTypeHint;\n+    }\n+    req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n+    http:Client introspectionClient = new(config.url, config.clientConfig);\n+    http:Response|http:ClientError response = introspectionClient->post(\"\", req);\n+    if (response is http:Response) {\n+        json|error result = response.getJsonPayload();\n+        if (result is error) {\n+            return <@untainted> prepareError(result.reason(), result);\n+        }\n+        IntrospectionResponse introspectionResponse = prepareIntrospectionResponse(<json>result);\n+        if (introspectionResponse.active) {\n+            if (oauth2Cache is cache:Cache) {\n+                addToCache(oauth2Cache, token, introspectionResponse, config.defaultTokenExpTimeInSeconds);\n             }\n-            return false;\n-        } else {\n-            return prepareAuthError(\"Failed to call the introspection endpoint.\", response);\n         }\n+        return introspectionResponse;\n+    } else {\n+        return prepareError(\"Failed to call the introspection endpoint.\", response);\n     }\n-};\n+}\n \n-function addToAuthenticationCache(cache:Cache oauth2Cache, string token, string? username, string? scopes, int exp) {\n-    InboundOAuth2CacheEntry oauth2CacheEntry = {username: username ?: \"\", scopes: scopes ?: \"\"};\n-    cache:Error? result = oauth2Cache.put(token, oauth2CacheEntry, exp);\n+function prepareIntrospectionResponse(json payload) returns IntrospectionResponse {\n+    boolean active = <boolean>payload.active;\n+    IntrospectionResponse introspectionResponse = {\n+        active: active\n+    };\n+    if (active) {\n+        if (payload.scope is string) {\n+            introspectionResponse.scopes = <@untainted> <string>payload.scope;\n+        }\n+        if (payload.client_id is string) {\n+            introspectionResponse.clientId = <@untainted> <string>payload.client_id;\n+        }\n+        if (payload.username is string) {\n+            introspectionResponse.username = <@untainted> <string>payload.username;\n+        }\n+        if (payload.token_type is string) {\n+            introspectionResponse.tokenType = <@untainted> <string>payload.token_type;\n+        }\n+        if (payload.exp is int) {\n+            introspectionResponse.exp = <@untainted> <int>payload.exp;\n+        }\n+        if (payload.iat is int) {\n+            introspectionResponse.iat = <@untainted> <int>payload.iat;\n+        }\n+        if (payload.nbf is int) {\n+            introspectionResponse.nbf = <@untainted> <int>payload.nbf;\n+        }\n+        if (payload.sub is string) {\n+            introspectionResponse.sub = <@untainted> <string>payload.sub;\n+        }\n+        if (payload.aud is string) {\n+            introspectionResponse.aud = <@untainted> <string>payload.aud;\n+        }\n+        if (payload.iss is string) {\n+            introspectionResponse.iss = <@untainted> <string>payload.iss;\n+        }\n+        if (payload.jti is string) {\n+            introspectionResponse.jti = <@untainted> <string>payload.jti;\n+        }\n+    }\n+    return introspectionResponse;\n+}\n+\n+function addToCache(cache:Cache oauth2Cache, string token, IntrospectionResponse response,\n+                    int defaultTokenExpTimeInSeconds) {\n+    cache:Error? result;\n+    if (response?.exp is int) {\n+        result = oauth2Cache.put(token, response);\n+    } else {\n+        // If the exp parameter is not set by introspection response, use cache default expiry by\n+        // defaultTokenExpTimeInSeconds. Then the cached value will be removed when retrieving.\n+        result = oauth2Cache.put(token, response, defaultTokenExpTimeInSeconds);\n+    }\n     if (result is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Failed to add JWT to the cache\";\n+            return \"Failed to add OAuth2 token to the cache. Introspection response: \" + response.toString();\n         });\n         return;\n     }\n-    if (username is string) {\n-        string user = username;\n+    log:printDebug(function() returns string {\n+        return \"OAuth2 token added to the cache. Introspection response: \" + response.toString();\n+    });\n+}\n+\n+function validateFromCache(cache:Cache oauth2Cache, string token) returns IntrospectionResponse? {\n+    any|cache:Error cachedValue = oauth2Cache.get(token);\n+    if (cachedValue is ()) {\n+        // If the cached value is expired (defaultTokenExpTimeInSeconds is passed), it will return ().\n         log:printDebug(function() returns string {\n-            return \"Add authenticated user: \" + user + \" to the cache.\";\n+            return \"Failed to validate token from from the cache, since token is expired.\";\n         });\n+        return;\n     }\n-}\n-\n-function authenticateFromCache(cache:Cache oauth2Cache, string token) returns InboundOAuth2CacheEntry? {\n-    if (oauth2Cache.hasKey(token)) {\n-        InboundOAuth2CacheEntry oauth2CacheEntry = <InboundOAuth2CacheEntry>oauth2Cache.get(token);\n+    if (cachedValue is cache:Error) {\n         log:printDebug(function() returns string {\n-            return \"Get authenticated user: \" + oauth2CacheEntry.username + \" from the cache.\";\n+            return \"Failed to validate token from from the cache. Cache error: \" + cachedValue.toString();\n         });\n-        return oauth2CacheEntry;\n+        return;\n+    }\n+    IntrospectionResponse response = <IntrospectionResponse>cachedValue;\n+    int? expTime = response?.exp;\n+    // expTime can be (), that means the defaultTokenExpTimeInSeconds is not exceeded yet. Hence the token is still\n+    // valid. Convert to current time and check the expiry time is exceeds if the expTime is int.\n+    if (expTime is () || expTime > (time:currentTime().time / 1000)) {\n+        log:printDebug(function() returns string {\n+            return \"OAuth2 token validated from the cache. Introspection response: \" + response.toString();\n+        });\n+        return response;\n+    } else {\n+        cache:Error? result = oauth2Cache.invalidate(token);\n+        if (result is cache:Error) {\n+            log:printDebug(function() returns string {\n+                return \"Failed to invalidate OAuth2 token from the cache. Introspection response: \" + response.toString();\n+            });\n+        }\n     }\n }\n \n # Reads the scope(s) for the user with the given username.\n #\n # + scopes - Set of scopes seperated with a space\n # + return - Array of groups for the user denoted by the username\n-public function getScopes(string scopes) returns string[] {\n-    string scopeVal = scopes.trim();\n-    if (scopeVal == \"\") {\n+function getScopes(string? scopes) returns string[] {\n+    if (scopes is ()) {\n         return [];\n+    } else {\n+        string scopeVal = scopes.trim();\n+        if (scopeVal == \"\") {\n+            return [];\n+        }\n+        return stringutils:split(scopeVal, \" \");\n     }\n-    return stringutils:split(scopeVal, \" \");\n }\n \n # Represents introspection server onfigurations.", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3MzcyNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073725", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # Represents introspection server response.\n          \n          \n            \n            # Represents the introspection server response.", "author": "praneesha", "createdAt": "2020-04-29T05:25:19Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -179,11 +246,31 @@ public type IntrospectionServerConfig record {|\n     http:ClientConfiguration clientConfig = {};\n |};\n \n-# Represents cached OAuth2 information.\n+# Represents introspection server response.", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3Mzg2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417073861", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + clientId - Client identifier for the OAuth 2.0 client that requested this token\n          \n          \n            \n            # + clientId - Client identifier for the OAuth 2.0 client, which requested this token", "author": "praneesha", "createdAt": "2020-04-29T05:25:52Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -179,11 +246,31 @@ public type IntrospectionServerConfig record {|\n     http:ClientConfiguration clientConfig = {};\n |};\n \n-# Represents cached OAuth2 information.\n+# Represents introspection server response.\n #\n-# + username - Username of the OAuth2 validated user\n-# + scopes - Scopes of the OAuth2 validated user\n-public type InboundOAuth2CacheEntry record {|\n-    string username;\n-    string scopes;\n+# + active - Boolean indicator of whether or not the presented token is currently active\n+# + scopes - A JSON string containing a space-separated list of scopes associated with this token\n+# + clientId - Client identifier for the OAuth 2.0 client that requested this token", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3NDAwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417074006", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + iat - Token originally issued time (seconds since the Epoch)\n          \n          \n            \n            # + iat - Time when the token was issued originally (seconds since the Epoch)", "author": "praneesha", "createdAt": "2020-04-29T05:26:20Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -179,11 +246,31 @@ public type IntrospectionServerConfig record {|\n     http:ClientConfiguration clientConfig = {};\n |};\n \n-# Represents cached OAuth2 information.\n+# Represents introspection server response.\n #\n-# + username - Username of the OAuth2 validated user\n-# + scopes - Scopes of the OAuth2 validated user\n-public type InboundOAuth2CacheEntry record {|\n-    string username;\n-    string scopes;\n+# + active - Boolean indicator of whether or not the presented token is currently active\n+# + scopes - A JSON string containing a space-separated list of scopes associated with this token\n+# + clientId - Client identifier for the OAuth 2.0 client that requested this token\n+# + username - Resource owner who authorized this token\n+# + tokenType - Type of the token\n+# + exp - Expiry time (seconds since the Epoch)\n+# + iat - Token originally issued time (seconds since the Epoch)", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3NDA1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417074059", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + nbf - Token is not to be used before time (seconds since the Epoch)\n          \n          \n            \n            # + nbf - Token is not to be used before this time (seconds since the Epoch)", "author": "praneesha", "createdAt": "2020-04-29T05:26:33Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -179,11 +246,31 @@ public type IntrospectionServerConfig record {|\n     http:ClientConfiguration clientConfig = {};\n |};\n \n-# Represents cached OAuth2 information.\n+# Represents introspection server response.\n #\n-# + username - Username of the OAuth2 validated user\n-# + scopes - Scopes of the OAuth2 validated user\n-public type InboundOAuth2CacheEntry record {|\n-    string username;\n-    string scopes;\n+# + active - Boolean indicator of whether or not the presented token is currently active\n+# + scopes - A JSON string containing a space-separated list of scopes associated with this token\n+# + clientId - Client identifier for the OAuth 2.0 client that requested this token\n+# + username - Resource owner who authorized this token\n+# + tokenType - Type of the token\n+# + exp - Expiry time (seconds since the Epoch)\n+# + iat - Token originally issued time (seconds since the Epoch)\n+# + nbf - Token is not to be used before time (seconds since the Epoch)", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA3NDk0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22917#discussion_r417074944", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # Validates the given OAuth2 token.\n          \n          \n            \n            # Validates the given OAuth2 token by calling the OAuth2 introspection endpoint.", "author": "ldclakmal", "createdAt": "2020-04-29T05:30:08Z", "path": "stdlib/oauth2/src/main/ballerina/src/oauth2/inbound_oauth2_provider.bal", "diffHunk": "@@ -60,108 +52,183 @@ public type InboundOAuth2Provider object {\n #\n # + credential - OAuth2 token to be authenticated\n # + return - `true` if authentication is successful, `false` otherwise, or else an `auth:Error` if an error occurred\n-    public function authenticate(string credential) returns boolean|auth:Error {\n+    public function authenticate(string credential) returns @tainted (boolean|auth:Error) {\n         if (credential == \"\") {\n             return false;\n         }\n \n-        cache:Cache? oauth2Cache = self.inboundOAuth2Cache;\n-        if (oauth2Cache is cache:Cache && oauth2Cache.hasKey(credential)) {\n-            InboundOAuth2CacheEntry? oauth2CacheEntry = authenticateFromCache(oauth2Cache, credential);\n-            if (oauth2CacheEntry is InboundOAuth2CacheEntry) {\n+        IntrospectionResponse|Error validationResult = validateOAuth2Token(credential, self.introspectionServerConfig);\n+        if (validationResult is IntrospectionResponse) {\n+            if (validationResult.active) {\n                 auth:setAuthenticationContext(\"oauth2\", credential);\n-                auth:setPrincipal(oauth2CacheEntry.username, oauth2CacheEntry.username,\n-                                  getScopes(oauth2CacheEntry.scopes));\n-                return true;\n+                auth:setPrincipal(validationResult?.username, validationResult?.username,\n+                                  getScopes(validationResult?.scopes));\n             }\n+            return validationResult.active;\n+        } else {\n+            return prepareAuthError(\"OAuth2 validation failed.\", validationResult);\n         }\n+    }\n+};\n \n-        // Build the request to be send to the introspection endpoint.\n-        // Refer: https://tools.ietf.org/html/rfc7662#section-2.1\n-        http:Request req = new;\n-        string textPayload = \"token=\" + credential;\n-        string? tokenTypeHint = self.tokenTypeHint;\n-        if (tokenTypeHint is string) {\n-            textPayload += \"&token_type_hint=\" + tokenTypeHint;\n-        }\n-        req.setTextPayload(textPayload, mime:APPLICATION_FORM_URLENCODED);\n-        http:Response|http:ClientError response = self.introspectionClient->post(\"\", req);\n-        if (response is http:Response) {\n-            json|error result = response.getJsonPayload();\n-            if (result is error) {\n-                return <@untainted> prepareAuthError(result.reason(), result);\n-            }\n-\n-            json payload = <json>result;\n-            boolean active = <boolean>payload.active;\n-            if (active) {\n-                string? username = ();\n-                string? scopes = ();\n-                int exp;\n-\n-                if (payload.username is string) {\n-                    username = <@untainted> <string>payload.username;\n-                }\n-                if (payload.scope is string) {\n-                    scopes = <@untainted> <string>payload.scope;\n-                }\n-                if (payload.exp is int) {\n-                    exp = <@untainted> <int>payload.exp;\n-                } else {\n-                    exp = self.defaultTokenExpTimeInSeconds +  (time:currentTime().time / 1000);\n-                }\n+# Validates the given OAuth2 token.", "originalCommit": "ff83dc80c4afbcd940b49c0035b3a0dfbeafc642", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0eb181f4861e7abc20f3051400ac8dfc608e0d2f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0eb181f4861e7abc20f3051400ac8dfc608e0d2f", "message": "Refactor code", "committedDate": "2020-04-29T05:46:57Z", "type": "commit"}, {"oid": "7ddbcb2ed83a4f05c3e876d31e949e790f6518e1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ddbcb2ed83a4f05c3e876d31e949e790f6518e1", "message": "Apply suggestions from code review", "committedDate": "2020-04-29T05:52:48Z", "type": "commit"}, {"oid": "7ddbcb2ed83a4f05c3e876d31e949e790f6518e1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7ddbcb2ed83a4f05c3e876d31e949e790f6518e1", "message": "Apply suggestions from code review", "committedDate": "2020-04-29T05:52:48Z", "type": "forcePushed"}]}