{"pr_number": 26161, "pr_title": "[Formatter] Add several node implementations", "pr_createdAt": "2020-09-30T07:48:59Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26161", "timeline": [{"oid": "3ddaceb957397ae308b14f298cbc7469c03cb9a8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3ddaceb957397ae308b14f298cbc7469c03cb9a8", "message": "Add nodes ConstantDeclarationNode, ParameterizedTypeDescriptorNode and TypeParameterNode", "committedDate": "2020-09-29T20:34:08Z", "type": "commit"}, {"oid": "1a5df7f990230f32861377f2ea9a70cdd82dc686", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a5df7f990230f32861377f2ea9a70cdd82dc686", "message": "Add nodes FunctionTypeDescriptorNode and ParenthesisedTypeDescriptorNode", "committedDate": "2020-09-29T20:38:23Z", "type": "commit"}, {"oid": "d594fd050779121c1e6422cab91f0c9bdd009229", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d594fd050779121c1e6422cab91f0c9bdd009229", "message": "Add several node implementations\n\nExternalFunctionBodyNode, AnnotationNode, MappingConstructorExpressionNode, SpecificFieldNode, ListConstructorExpressionNode", "committedDate": "2020-09-29T20:38:24Z", "type": "commit"}, {"oid": "61257551d93cbcce3ef6944175f38af10d7596f8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/61257551d93cbcce3ef6944175f38af10d7596f8", "message": "Add several node implementations\n\nErrorTypeDescriptorNode, PanicStatementNode, IntersectionTypeDescriptorNode, ModuleVariableDeclarationNode, ExpressionFunctionBodyNode, TypeCastExpressionNode, TypeCastParamNode, IndexedExpressionNode, ComputedNameFieldNode, TupleTypeDescriptorNode, ListBindingPatternNode, RestBindingPatternNode, TableTypeDescriptorNode, KeyTypeConstraintNode, MatchStatementNode, MatchClauseNode, MatchGuardNode", "committedDate": "2020-09-30T07:42:47Z", "type": "commit"}, {"oid": "8ac8b7b09e7c7130dfe7b7ca694bfce350b4db91", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8ac8b7b09e7c7130dfe7b7ca694bfce350b4db91", "message": "Add LockStatementNode, FieldAccessExpressionNode and MetadataNode", "committedDate": "2020-09-30T08:39:14Z", "type": "commit"}, {"oid": "ff30678bb8e425e1a21b1925c10ee8651cd7b06f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ff30678bb8e425e1a21b1925c10ee8651cd7b06f", "message": "Add EnumDeclarationNode and EnumMemberNode", "committedDate": "2020-09-30T08:54:28Z", "type": "commit"}, {"oid": "2093e02f1bc23ac9cb8fcbdbd1c9ef0c196c5e9d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2093e02f1bc23ac9cb8fcbdbd1c9ef0c196c5e9d", "message": "Add nodes MarkdownDocumentationNode, MarkdownDocumentationLineNode, MarkdownParameterDocumentationLineNode, DocumentationReferenceNode", "committedDate": "2020-09-30T09:29:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3MjA0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26161#discussion_r497472042", "bodyText": "if annotationNode.annotValue() is not present, trailing WS and NL should get from the top", "author": "SupunS", "createdAt": "2020-09-30T12:34:05Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -920,6 +956,645 @@ public NilTypeDescriptorNode transform(NilTypeDescriptorNode nilTypeDescriptorNo\n                 .apply();\n     }\n \n+    @Override\n+    public ConstantDeclarationNode transform(ConstantDeclarationNode constantDeclarationNode) {\n+        if (constantDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(constantDeclarationNode.metadata().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        if (constantDeclarationNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(constantDeclarationNode.visibilityQualifier().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify()\n+                    .withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+        Token constKeyword = formatToken(constantDeclarationNode.constKeyword(), 1, 0);\n+\n+        if (constantDeclarationNode.typeDescriptor().isPresent()) {\n+            TypeDescriptorNode typeDescriptorNode = formatNode(constantDeclarationNode.typeDescriptor().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify().withTypeDescriptor(typeDescriptorNode).apply();\n+        }\n+\n+        Token variableName = formatToken(constantDeclarationNode.variableName(), 1, 0);\n+        Token equalsToken = formatToken(constantDeclarationNode.equalsToken(), 1, 0);\n+        Node initializer = formatNode(constantDeclarationNode.initializer(), 0, 0);\n+        Token semicolonToken = formatToken(constantDeclarationNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return constantDeclarationNode.modify()\n+                .withConstKeyword(constKeyword)\n+                .withEqualsToken(equalsToken)\n+                .withInitializer(initializer)\n+                .withSemicolonToken(semicolonToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParameterizedTypeDescriptorNode transform(ParameterizedTypeDescriptorNode parameterizedTypeDescriptorNode) {\n+        Token parameterizedType = formatToken(parameterizedTypeDescriptorNode.parameterizedType(), 0, 0);\n+        TypeParameterNode typeParameter = formatNode(parameterizedTypeDescriptorNode.typeParameter(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return parameterizedTypeDescriptorNode.modify()\n+                .withParameterizedType(parameterizedType)\n+                .withTypeParameter(typeParameter)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeParameterNode transform(TypeParameterNode typeParameterNode) {\n+        Token ltToken = formatToken(typeParameterNode.ltToken(), 0, 0);\n+        TypeDescriptorNode typeNode = formatNode(typeParameterNode.typeNode(), 0, 0);\n+        Token gtToken = formatToken(typeParameterNode.gtToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeParameterNode.modify()\n+                .withTypeNode(typeNode)\n+                .withLtToken(ltToken)\n+                .withGtToken(gtToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FunctionTypeDescriptorNode transform(FunctionTypeDescriptorNode functionTypeDescriptorNode) {\n+        NodeList<Token> qualifierList = formatNodeList(functionTypeDescriptorNode.qualifierList(), 1, 0, 0, 1);\n+        Token functionKeyword = formatToken(functionTypeDescriptorNode.functionKeyword(), 1, 0);\n+        FunctionSignatureNode functionSignature = formatNode(functionTypeDescriptorNode.functionSignature(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return functionTypeDescriptorNode.modify()\n+                .withQualifierList(qualifierList)\n+                .withFunctionKeyword(functionKeyword)\n+                .withFunctionSignature(functionSignature)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesisedTypeDescriptorNode transform(ParenthesisedTypeDescriptorNode parenthesisedTypeDescriptorNode) {\n+        Token openParenToken = formatToken(parenthesisedTypeDescriptorNode.openParenToken(), 0, 0);\n+        TypeDescriptorNode typedesc = formatNode(parenthesisedTypeDescriptorNode.typedesc(), 0, 0);\n+        Token closeParenToken = formatToken(parenthesisedTypeDescriptorNode.closeParenToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return parenthesisedTypeDescriptorNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withTypedesc(typedesc)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExternalFunctionBodyNode transform(ExternalFunctionBodyNode externalFunctionBodyNode) {\n+        Token equalsToken = formatToken(externalFunctionBodyNode.equalsToken(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(externalFunctionBodyNode.annotations(), 0, 1, 1, 0);\n+        Token externalKeyword = formatToken(externalFunctionBodyNode.externalKeyword(), 0, 0);\n+        Token semicolonToken = formatToken(externalFunctionBodyNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return externalFunctionBodyNode.modify()\n+                .withEqualsToken(equalsToken)\n+                .withAnnotations(annotations)\n+                .withExternalKeyword(externalKeyword)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AnnotationNode transform(AnnotationNode annotationNode) {\n+        Token atToken = formatToken(annotationNode.atToken(), 0, 0);\n+        Node annotReference = formatNode(annotationNode.annotReference(), 1, 0);", "originalCommit": "2093e02f1bc23ac9cb8fcbdbd1c9ef0c196c5e9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3NDMzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26161#discussion_r497474336", "bodyText": "We could try to do something similar to the record-type-desc, to selectively expand", "author": "SupunS", "createdAt": "2020-09-30T12:37:30Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -920,6 +956,645 @@ public NilTypeDescriptorNode transform(NilTypeDescriptorNode nilTypeDescriptorNo\n                 .apply();\n     }\n \n+    @Override\n+    public ConstantDeclarationNode transform(ConstantDeclarationNode constantDeclarationNode) {\n+        if (constantDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(constantDeclarationNode.metadata().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        if (constantDeclarationNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(constantDeclarationNode.visibilityQualifier().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify()\n+                    .withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+        Token constKeyword = formatToken(constantDeclarationNode.constKeyword(), 1, 0);\n+\n+        if (constantDeclarationNode.typeDescriptor().isPresent()) {\n+            TypeDescriptorNode typeDescriptorNode = formatNode(constantDeclarationNode.typeDescriptor().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify().withTypeDescriptor(typeDescriptorNode).apply();\n+        }\n+\n+        Token variableName = formatToken(constantDeclarationNode.variableName(), 1, 0);\n+        Token equalsToken = formatToken(constantDeclarationNode.equalsToken(), 1, 0);\n+        Node initializer = formatNode(constantDeclarationNode.initializer(), 0, 0);\n+        Token semicolonToken = formatToken(constantDeclarationNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return constantDeclarationNode.modify()\n+                .withConstKeyword(constKeyword)\n+                .withEqualsToken(equalsToken)\n+                .withInitializer(initializer)\n+                .withSemicolonToken(semicolonToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParameterizedTypeDescriptorNode transform(ParameterizedTypeDescriptorNode parameterizedTypeDescriptorNode) {\n+        Token parameterizedType = formatToken(parameterizedTypeDescriptorNode.parameterizedType(), 0, 0);\n+        TypeParameterNode typeParameter = formatNode(parameterizedTypeDescriptorNode.typeParameter(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return parameterizedTypeDescriptorNode.modify()\n+                .withParameterizedType(parameterizedType)\n+                .withTypeParameter(typeParameter)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeParameterNode transform(TypeParameterNode typeParameterNode) {\n+        Token ltToken = formatToken(typeParameterNode.ltToken(), 0, 0);\n+        TypeDescriptorNode typeNode = formatNode(typeParameterNode.typeNode(), 0, 0);\n+        Token gtToken = formatToken(typeParameterNode.gtToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeParameterNode.modify()\n+                .withTypeNode(typeNode)\n+                .withLtToken(ltToken)\n+                .withGtToken(gtToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FunctionTypeDescriptorNode transform(FunctionTypeDescriptorNode functionTypeDescriptorNode) {\n+        NodeList<Token> qualifierList = formatNodeList(functionTypeDescriptorNode.qualifierList(), 1, 0, 0, 1);\n+        Token functionKeyword = formatToken(functionTypeDescriptorNode.functionKeyword(), 1, 0);\n+        FunctionSignatureNode functionSignature = formatNode(functionTypeDescriptorNode.functionSignature(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return functionTypeDescriptorNode.modify()\n+                .withQualifierList(qualifierList)\n+                .withFunctionKeyword(functionKeyword)\n+                .withFunctionSignature(functionSignature)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesisedTypeDescriptorNode transform(ParenthesisedTypeDescriptorNode parenthesisedTypeDescriptorNode) {\n+        Token openParenToken = formatToken(parenthesisedTypeDescriptorNode.openParenToken(), 0, 0);\n+        TypeDescriptorNode typedesc = formatNode(parenthesisedTypeDescriptorNode.typedesc(), 0, 0);\n+        Token closeParenToken = formatToken(parenthesisedTypeDescriptorNode.closeParenToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return parenthesisedTypeDescriptorNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withTypedesc(typedesc)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExternalFunctionBodyNode transform(ExternalFunctionBodyNode externalFunctionBodyNode) {\n+        Token equalsToken = formatToken(externalFunctionBodyNode.equalsToken(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(externalFunctionBodyNode.annotations(), 0, 1, 1, 0);\n+        Token externalKeyword = formatToken(externalFunctionBodyNode.externalKeyword(), 0, 0);\n+        Token semicolonToken = formatToken(externalFunctionBodyNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return externalFunctionBodyNode.modify()\n+                .withEqualsToken(equalsToken)\n+                .withAnnotations(annotations)\n+                .withExternalKeyword(externalKeyword)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AnnotationNode transform(AnnotationNode annotationNode) {\n+        Token atToken = formatToken(annotationNode.atToken(), 0, 0);\n+        Node annotReference = formatNode(annotationNode.annotReference(), 1, 0);\n+\n+        if (annotationNode.annotValue().isPresent()) {\n+            MappingConstructorExpressionNode annotValue = formatNode(annotationNode.annotValue().get(),\n+                    this.trailingWS, this.trailingNL);\n+            annotationNode = annotationNode.modify().withAnnotValue(annotValue).apply();\n+        }\n+\n+        return annotationNode.modify()\n+                .withAtToken(atToken)\n+                .withAnnotReference(annotReference)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MappingConstructorExpressionNode transform(\n+            MappingConstructorExpressionNode mappingConstructorExpressionNode) {\n+        Token openBrace = formatToken(mappingConstructorExpressionNode.openBrace(), 0, 1);\n+        indent();\n+        SeparatedNodeList<MappingFieldNode> fields = formatSeparatedNodeList(", "originalCommit": "2093e02f1bc23ac9cb8fcbdbd1c9ef0c196c5e9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3NTE1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26161#discussion_r497475153", "bodyText": "need to get trailing WS/NL from the top", "author": "SupunS", "createdAt": "2020-09-30T12:38:45Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -920,6 +956,645 @@ public NilTypeDescriptorNode transform(NilTypeDescriptorNode nilTypeDescriptorNo\n                 .apply();\n     }\n \n+    @Override\n+    public ConstantDeclarationNode transform(ConstantDeclarationNode constantDeclarationNode) {\n+        if (constantDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(constantDeclarationNode.metadata().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        if (constantDeclarationNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(constantDeclarationNode.visibilityQualifier().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify()\n+                    .withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+        Token constKeyword = formatToken(constantDeclarationNode.constKeyword(), 1, 0);\n+\n+        if (constantDeclarationNode.typeDescriptor().isPresent()) {\n+            TypeDescriptorNode typeDescriptorNode = formatNode(constantDeclarationNode.typeDescriptor().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify().withTypeDescriptor(typeDescriptorNode).apply();\n+        }\n+\n+        Token variableName = formatToken(constantDeclarationNode.variableName(), 1, 0);\n+        Token equalsToken = formatToken(constantDeclarationNode.equalsToken(), 1, 0);\n+        Node initializer = formatNode(constantDeclarationNode.initializer(), 0, 0);\n+        Token semicolonToken = formatToken(constantDeclarationNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return constantDeclarationNode.modify()\n+                .withConstKeyword(constKeyword)\n+                .withEqualsToken(equalsToken)\n+                .withInitializer(initializer)\n+                .withSemicolonToken(semicolonToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParameterizedTypeDescriptorNode transform(ParameterizedTypeDescriptorNode parameterizedTypeDescriptorNode) {\n+        Token parameterizedType = formatToken(parameterizedTypeDescriptorNode.parameterizedType(), 0, 0);\n+        TypeParameterNode typeParameter = formatNode(parameterizedTypeDescriptorNode.typeParameter(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return parameterizedTypeDescriptorNode.modify()\n+                .withParameterizedType(parameterizedType)\n+                .withTypeParameter(typeParameter)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeParameterNode transform(TypeParameterNode typeParameterNode) {\n+        Token ltToken = formatToken(typeParameterNode.ltToken(), 0, 0);\n+        TypeDescriptorNode typeNode = formatNode(typeParameterNode.typeNode(), 0, 0);\n+        Token gtToken = formatToken(typeParameterNode.gtToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeParameterNode.modify()\n+                .withTypeNode(typeNode)\n+                .withLtToken(ltToken)\n+                .withGtToken(gtToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FunctionTypeDescriptorNode transform(FunctionTypeDescriptorNode functionTypeDescriptorNode) {\n+        NodeList<Token> qualifierList = formatNodeList(functionTypeDescriptorNode.qualifierList(), 1, 0, 0, 1);\n+        Token functionKeyword = formatToken(functionTypeDescriptorNode.functionKeyword(), 1, 0);\n+        FunctionSignatureNode functionSignature = formatNode(functionTypeDescriptorNode.functionSignature(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return functionTypeDescriptorNode.modify()\n+                .withQualifierList(qualifierList)\n+                .withFunctionKeyword(functionKeyword)\n+                .withFunctionSignature(functionSignature)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesisedTypeDescriptorNode transform(ParenthesisedTypeDescriptorNode parenthesisedTypeDescriptorNode) {\n+        Token openParenToken = formatToken(parenthesisedTypeDescriptorNode.openParenToken(), 0, 0);\n+        TypeDescriptorNode typedesc = formatNode(parenthesisedTypeDescriptorNode.typedesc(), 0, 0);\n+        Token closeParenToken = formatToken(parenthesisedTypeDescriptorNode.closeParenToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return parenthesisedTypeDescriptorNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withTypedesc(typedesc)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExternalFunctionBodyNode transform(ExternalFunctionBodyNode externalFunctionBodyNode) {\n+        Token equalsToken = formatToken(externalFunctionBodyNode.equalsToken(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(externalFunctionBodyNode.annotations(), 0, 1, 1, 0);\n+        Token externalKeyword = formatToken(externalFunctionBodyNode.externalKeyword(), 0, 0);\n+        Token semicolonToken = formatToken(externalFunctionBodyNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return externalFunctionBodyNode.modify()\n+                .withEqualsToken(equalsToken)\n+                .withAnnotations(annotations)\n+                .withExternalKeyword(externalKeyword)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AnnotationNode transform(AnnotationNode annotationNode) {\n+        Token atToken = formatToken(annotationNode.atToken(), 0, 0);\n+        Node annotReference = formatNode(annotationNode.annotReference(), 1, 0);\n+\n+        if (annotationNode.annotValue().isPresent()) {\n+            MappingConstructorExpressionNode annotValue = formatNode(annotationNode.annotValue().get(),\n+                    this.trailingWS, this.trailingNL);\n+            annotationNode = annotationNode.modify().withAnnotValue(annotValue).apply();\n+        }\n+\n+        return annotationNode.modify()\n+                .withAtToken(atToken)\n+                .withAnnotReference(annotReference)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MappingConstructorExpressionNode transform(\n+            MappingConstructorExpressionNode mappingConstructorExpressionNode) {\n+        Token openBrace = formatToken(mappingConstructorExpressionNode.openBrace(), 0, 1);\n+        indent();\n+        SeparatedNodeList<MappingFieldNode> fields = formatSeparatedNodeList(\n+                mappingConstructorExpressionNode.fields(), 0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace = formatToken(mappingConstructorExpressionNode.closeBrace(), this.trailingWS, this.trailingNL);\n+\n+        return mappingConstructorExpressionNode.modify()\n+                .withOpenBrace(openBrace)\n+                .withFields(fields)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SpecificFieldNode transform(SpecificFieldNode specificFieldNode) {\n+        if (specificFieldNode.readonlyKeyword().isPresent()) {\n+            Token readOnlyKeyword = formatToken(specificFieldNode.readonlyKeyword().get(), 1, 0);\n+            specificFieldNode = specificFieldNode.modify()\n+                    .withReadonlyKeyword(readOnlyKeyword).apply();\n+        }\n+\n+        Token fieldName;\n+        if (specificFieldNode.fieldName() instanceof BasicLiteralNode) {\n+            fieldName = ((BasicLiteralNode) specificFieldNode.fieldName()).literalToken();\n+        } else {\n+            fieldName = (Token) specificFieldNode.fieldName();\n+        }\n+\n+        if (specificFieldNode.colon().isPresent()) {\n+            fieldName = formatToken(fieldName, 1, 0);\n+            Token colon = formatToken(specificFieldNode.colon().get(), 1, 0);\n+            ExpressionNode expressionNode = formatNode(specificFieldNode.valueExpr().get(),\n+                    this.trailingWS, this.trailingNL);\n+            return specificFieldNode.modify()\n+                    .withFieldName(fieldName)\n+                    .withColon(colon)\n+                    .withValueExpr(expressionNode)\n+                    .apply();\n+        } else {\n+            fieldName = formatToken(fieldName, this.trailingWS, this.trailingNL);\n+            return specificFieldNode.modify()\n+                    .withFieldName(fieldName)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public ListConstructorExpressionNode transform(ListConstructorExpressionNode listConstructorExpressionNode) {\n+        Token openBracket = formatToken(listConstructorExpressionNode.openBracket(), 0, 0);\n+        SeparatedNodeList<Node> expressions = formatSeparatedNodeList(listConstructorExpressionNode.expressions(),\n+                0, 0, 0, 0);\n+        Token closeBracket = formatToken(listConstructorExpressionNode.closeBracket(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return listConstructorExpressionNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withExpressions(expressions)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ErrorTypeDescriptorNode transform(ErrorTypeDescriptorNode errorTypeDescriptorNode) {\n+        if (errorTypeDescriptorNode.errorTypeParamsNode().isPresent()) {\n+            Token errorKeywordToken = formatToken(errorTypeDescriptorNode.errorKeywordToken(), 1, 0);\n+            ErrorTypeParamsNode errorTypeParamsNode = formatNode(errorTypeDescriptorNode.errorTypeParamsNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return errorTypeDescriptorNode.modify()\n+                    .withErrorKeywordToken(errorKeywordToken)\n+                    .withErrorTypeParamsNode(errorTypeParamsNode)\n+                    .apply();\n+        } else {\n+            Token errorKeywordToken = formatToken(errorTypeDescriptorNode.errorKeywordToken(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return errorTypeDescriptorNode.modify()\n+                    .withErrorKeywordToken(errorKeywordToken)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public PanicStatementNode transform(PanicStatementNode panicStatementNode) {\n+        Token panicKeyword = formatToken(panicStatementNode.panicKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(panicStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(panicStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return panicStatementNode.modify()\n+                .withPanicKeyword(panicKeyword)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public IntersectionTypeDescriptorNode transform(IntersectionTypeDescriptorNode intersectionTypeDescriptorNode) {\n+        Node leftTypeDesc = formatNode(intersectionTypeDescriptorNode.leftTypeDesc(), 1, 0);\n+        Token bitwiseAndToken = formatToken(intersectionTypeDescriptorNode.bitwiseAndToken(), 1, 0);\n+        Node rightTypeDesc = formatNode(intersectionTypeDescriptorNode.rightTypeDesc(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return intersectionTypeDescriptorNode.modify()\n+                .withLeftTypeDesc(leftTypeDesc)\n+                .withBitwiseAndToken(bitwiseAndToken)\n+                .withRightTypeDesc(rightTypeDesc)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ModuleVariableDeclarationNode transform(ModuleVariableDeclarationNode moduleVariableDeclarationNode) {\n+        if (moduleVariableDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(moduleVariableDeclarationNode.metadata().get(), 1, 0);\n+            moduleVariableDeclarationNode = moduleVariableDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        if (moduleVariableDeclarationNode.finalKeyword().isPresent()) {\n+            Token finalKeyword = formatToken(moduleVariableDeclarationNode.finalKeyword().get(), 1, 0);\n+            moduleVariableDeclarationNode = moduleVariableDeclarationNode.modify()\n+                    .withFinalKeyword(finalKeyword).apply();\n+        }\n+\n+        TypedBindingPatternNode typedBindingPatternNode =\n+                formatNode(moduleVariableDeclarationNode.typedBindingPattern(), 1, 0);\n+        Token equalsToken = formatToken(moduleVariableDeclarationNode.equalsToken(), 1, 0);\n+        ExpressionNode initializer = formatNode(moduleVariableDeclarationNode.initializer(), 0, 0);\n+        Token semicolonToken = formatToken(moduleVariableDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return moduleVariableDeclarationNode.modify()\n+                .withTypedBindingPattern(typedBindingPatternNode)\n+                .withEqualsToken(equalsToken)\n+                .withInitializer(initializer)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionFunctionBodyNode transform(ExpressionFunctionBodyNode expressionFunctionBodyNode) {\n+        Token rightDoubleArrow = formatToken(expressionFunctionBodyNode.rightDoubleArrow(), 1, 0);\n+\n+        if (expressionFunctionBodyNode.semicolon().isPresent()) {\n+            ExpressionNode expression = formatNode(expressionFunctionBodyNode.expression(), 0, 0);\n+            Token semicolon = formatToken(expressionFunctionBodyNode.semicolon().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return expressionFunctionBodyNode.modify()\n+                    .withRightDoubleArrow(rightDoubleArrow)\n+                    .withExpression(expression)\n+                    .withSemicolon(semicolon)\n+                    .apply();\n+        } else {\n+            ExpressionNode expression = formatNode(expressionFunctionBodyNode.expression(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return expressionFunctionBodyNode.modify()\n+                    .withRightDoubleArrow(rightDoubleArrow)\n+                    .withExpression(expression)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public TypeCastExpressionNode transform(TypeCastExpressionNode typeCastExpressionNode) {\n+        Token ltToken = formatToken(typeCastExpressionNode.ltToken(), 0, 0);\n+        TypeCastParamNode typeCastParam = formatNode(typeCastExpressionNode.typeCastParam(), 0, 0);\n+        Token gtToken = formatToken(typeCastExpressionNode.gtToken(), 0, 0);\n+        ExpressionNode expression = formatNode(typeCastExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return typeCastExpressionNode.modify()\n+                .withLtToken(ltToken)\n+                .withTypeCastParam(typeCastParam)\n+                .withGtToken(gtToken)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeCastParamNode transform(TypeCastParamNode typeCastParamNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(typeCastParamNode.annotations(), 0, 1, 1, 0);\n+        Node type = formatNode(typeCastParamNode.type(), this.trailingWS, this.trailingNL);\n+\n+        return typeCastParamNode.modify()\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public IndexedExpressionNode transform(IndexedExpressionNode indexedExpressionNode) {\n+        ExpressionNode containerExpression = formatNode(indexedExpressionNode.containerExpression(), 0, 0);\n+        Token openBracket = formatToken(indexedExpressionNode.openBracket(), 0, 0);\n+        SeparatedNodeList<ExpressionNode> keyExpression = formatSeparatedNodeList(indexedExpressionNode.keyExpression(),\n+                0, 0, 0, 0);\n+        Token closeBracket = formatToken(indexedExpressionNode.closeBracket(), this.trailingWS, this.trailingNL);\n+\n+        return indexedExpressionNode.modify()\n+                .withContainerExpression(containerExpression)\n+                .withOpenBracket(openBracket)\n+                .withKeyExpression(keyExpression)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ComputedNameFieldNode transform(ComputedNameFieldNode computedNameFieldNode) {\n+        Token openBracket = formatToken(computedNameFieldNode.openBracket(), 0, 0);\n+        ExpressionNode fieldNameExpr = formatNode(computedNameFieldNode.fieldNameExpr(), 0, 0);\n+        Token closeBracket = formatToken(computedNameFieldNode.closeBracket(), 1, 0);\n+        Token colonToken = formatToken(computedNameFieldNode.colonToken(), 1, 0);\n+        ExpressionNode valueExpr = formatNode(computedNameFieldNode.valueExpr(), this.trailingWS, this.trailingNL);\n+\n+        return computedNameFieldNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withFieldNameExpr(fieldNameExpr)\n+                .withCloseBracket(closeBracket)\n+                .withColonToken(colonToken)\n+                .withValueExpr(valueExpr)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TupleTypeDescriptorNode transform(TupleTypeDescriptorNode tupleTypeDescriptorNode) {\n+        Token openBracketToken = formatToken(tupleTypeDescriptorNode.openBracketToken(), 0, 0);\n+        SeparatedNodeList<Node> memberTypeDesc = formatSeparatedNodeList(tupleTypeDescriptorNode.memberTypeDesc(),\n+                0, 0, 0, 0);\n+        Token closeBracketToken = formatToken(tupleTypeDescriptorNode.closeBracketToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tupleTypeDescriptorNode.modify()\n+                .withOpenBracketToken(openBracketToken)\n+                .withMemberTypeDesc(memberTypeDesc)\n+                .withCloseBracketToken(closeBracketToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatternNode) {\n+        Token openBracket = formatToken(listBindingPatternNode.openBracket(), 0, 0);\n+        SeparatedNodeList<BindingPatternNode> bindingPatternNodes =\n+                formatSeparatedNodeList(listBindingPatternNode.bindingPatterns(), 0, 0, 0, 0);\n+        Token closeBracket = formatToken(listBindingPatternNode.closeBracket(), this.trailingWS, this.trailingNL);\n+\n+        if (listBindingPatternNode.restBindingPattern().isPresent()) {\n+            RestBindingPatternNode restBindingPattern = formatNode(listBindingPatternNode.restBindingPattern().get(),\n+                    this.trailingWS, this.trailingNL);\n+            listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n+        }\n+\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(), 1, 0);", "originalCommit": "2093e02f1bc23ac9cb8fcbdbd1c9ef0c196c5e9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3NjQ2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26161#discussion_r497476469", "bodyText": "lets get trailing WS/NL from the top", "author": "SupunS", "createdAt": "2020-09-30T12:40:44Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -920,6 +956,645 @@ public NilTypeDescriptorNode transform(NilTypeDescriptorNode nilTypeDescriptorNo\n                 .apply();\n     }\n \n+    @Override\n+    public ConstantDeclarationNode transform(ConstantDeclarationNode constantDeclarationNode) {\n+        if (constantDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(constantDeclarationNode.metadata().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        if (constantDeclarationNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(constantDeclarationNode.visibilityQualifier().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify()\n+                    .withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+        Token constKeyword = formatToken(constantDeclarationNode.constKeyword(), 1, 0);\n+\n+        if (constantDeclarationNode.typeDescriptor().isPresent()) {\n+            TypeDescriptorNode typeDescriptorNode = formatNode(constantDeclarationNode.typeDescriptor().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify().withTypeDescriptor(typeDescriptorNode).apply();\n+        }\n+\n+        Token variableName = formatToken(constantDeclarationNode.variableName(), 1, 0);\n+        Token equalsToken = formatToken(constantDeclarationNode.equalsToken(), 1, 0);\n+        Node initializer = formatNode(constantDeclarationNode.initializer(), 0, 0);\n+        Token semicolonToken = formatToken(constantDeclarationNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return constantDeclarationNode.modify()\n+                .withConstKeyword(constKeyword)\n+                .withEqualsToken(equalsToken)\n+                .withInitializer(initializer)\n+                .withSemicolonToken(semicolonToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParameterizedTypeDescriptorNode transform(ParameterizedTypeDescriptorNode parameterizedTypeDescriptorNode) {\n+        Token parameterizedType = formatToken(parameterizedTypeDescriptorNode.parameterizedType(), 0, 0);\n+        TypeParameterNode typeParameter = formatNode(parameterizedTypeDescriptorNode.typeParameter(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return parameterizedTypeDescriptorNode.modify()\n+                .withParameterizedType(parameterizedType)\n+                .withTypeParameter(typeParameter)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeParameterNode transform(TypeParameterNode typeParameterNode) {\n+        Token ltToken = formatToken(typeParameterNode.ltToken(), 0, 0);\n+        TypeDescriptorNode typeNode = formatNode(typeParameterNode.typeNode(), 0, 0);\n+        Token gtToken = formatToken(typeParameterNode.gtToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeParameterNode.modify()\n+                .withTypeNode(typeNode)\n+                .withLtToken(ltToken)\n+                .withGtToken(gtToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FunctionTypeDescriptorNode transform(FunctionTypeDescriptorNode functionTypeDescriptorNode) {\n+        NodeList<Token> qualifierList = formatNodeList(functionTypeDescriptorNode.qualifierList(), 1, 0, 0, 1);\n+        Token functionKeyword = formatToken(functionTypeDescriptorNode.functionKeyword(), 1, 0);\n+        FunctionSignatureNode functionSignature = formatNode(functionTypeDescriptorNode.functionSignature(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return functionTypeDescriptorNode.modify()\n+                .withQualifierList(qualifierList)\n+                .withFunctionKeyword(functionKeyword)\n+                .withFunctionSignature(functionSignature)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesisedTypeDescriptorNode transform(ParenthesisedTypeDescriptorNode parenthesisedTypeDescriptorNode) {\n+        Token openParenToken = formatToken(parenthesisedTypeDescriptorNode.openParenToken(), 0, 0);\n+        TypeDescriptorNode typedesc = formatNode(parenthesisedTypeDescriptorNode.typedesc(), 0, 0);\n+        Token closeParenToken = formatToken(parenthesisedTypeDescriptorNode.closeParenToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return parenthesisedTypeDescriptorNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withTypedesc(typedesc)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExternalFunctionBodyNode transform(ExternalFunctionBodyNode externalFunctionBodyNode) {\n+        Token equalsToken = formatToken(externalFunctionBodyNode.equalsToken(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(externalFunctionBodyNode.annotations(), 0, 1, 1, 0);\n+        Token externalKeyword = formatToken(externalFunctionBodyNode.externalKeyword(), 0, 0);\n+        Token semicolonToken = formatToken(externalFunctionBodyNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return externalFunctionBodyNode.modify()\n+                .withEqualsToken(equalsToken)\n+                .withAnnotations(annotations)\n+                .withExternalKeyword(externalKeyword)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AnnotationNode transform(AnnotationNode annotationNode) {\n+        Token atToken = formatToken(annotationNode.atToken(), 0, 0);\n+        Node annotReference = formatNode(annotationNode.annotReference(), 1, 0);\n+\n+        if (annotationNode.annotValue().isPresent()) {\n+            MappingConstructorExpressionNode annotValue = formatNode(annotationNode.annotValue().get(),\n+                    this.trailingWS, this.trailingNL);\n+            annotationNode = annotationNode.modify().withAnnotValue(annotValue).apply();\n+        }\n+\n+        return annotationNode.modify()\n+                .withAtToken(atToken)\n+                .withAnnotReference(annotReference)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MappingConstructorExpressionNode transform(\n+            MappingConstructorExpressionNode mappingConstructorExpressionNode) {\n+        Token openBrace = formatToken(mappingConstructorExpressionNode.openBrace(), 0, 1);\n+        indent();\n+        SeparatedNodeList<MappingFieldNode> fields = formatSeparatedNodeList(\n+                mappingConstructorExpressionNode.fields(), 0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace = formatToken(mappingConstructorExpressionNode.closeBrace(), this.trailingWS, this.trailingNL);\n+\n+        return mappingConstructorExpressionNode.modify()\n+                .withOpenBrace(openBrace)\n+                .withFields(fields)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SpecificFieldNode transform(SpecificFieldNode specificFieldNode) {\n+        if (specificFieldNode.readonlyKeyword().isPresent()) {\n+            Token readOnlyKeyword = formatToken(specificFieldNode.readonlyKeyword().get(), 1, 0);\n+            specificFieldNode = specificFieldNode.modify()\n+                    .withReadonlyKeyword(readOnlyKeyword).apply();\n+        }\n+\n+        Token fieldName;\n+        if (specificFieldNode.fieldName() instanceof BasicLiteralNode) {\n+            fieldName = ((BasicLiteralNode) specificFieldNode.fieldName()).literalToken();\n+        } else {\n+            fieldName = (Token) specificFieldNode.fieldName();\n+        }\n+\n+        if (specificFieldNode.colon().isPresent()) {\n+            fieldName = formatToken(fieldName, 1, 0);\n+            Token colon = formatToken(specificFieldNode.colon().get(), 1, 0);\n+            ExpressionNode expressionNode = formatNode(specificFieldNode.valueExpr().get(),\n+                    this.trailingWS, this.trailingNL);\n+            return specificFieldNode.modify()\n+                    .withFieldName(fieldName)\n+                    .withColon(colon)\n+                    .withValueExpr(expressionNode)\n+                    .apply();\n+        } else {\n+            fieldName = formatToken(fieldName, this.trailingWS, this.trailingNL);\n+            return specificFieldNode.modify()\n+                    .withFieldName(fieldName)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public ListConstructorExpressionNode transform(ListConstructorExpressionNode listConstructorExpressionNode) {\n+        Token openBracket = formatToken(listConstructorExpressionNode.openBracket(), 0, 0);\n+        SeparatedNodeList<Node> expressions = formatSeparatedNodeList(listConstructorExpressionNode.expressions(),\n+                0, 0, 0, 0);\n+        Token closeBracket = formatToken(listConstructorExpressionNode.closeBracket(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return listConstructorExpressionNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withExpressions(expressions)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ErrorTypeDescriptorNode transform(ErrorTypeDescriptorNode errorTypeDescriptorNode) {\n+        if (errorTypeDescriptorNode.errorTypeParamsNode().isPresent()) {\n+            Token errorKeywordToken = formatToken(errorTypeDescriptorNode.errorKeywordToken(), 1, 0);\n+            ErrorTypeParamsNode errorTypeParamsNode = formatNode(errorTypeDescriptorNode.errorTypeParamsNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return errorTypeDescriptorNode.modify()\n+                    .withErrorKeywordToken(errorKeywordToken)\n+                    .withErrorTypeParamsNode(errorTypeParamsNode)\n+                    .apply();\n+        } else {\n+            Token errorKeywordToken = formatToken(errorTypeDescriptorNode.errorKeywordToken(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return errorTypeDescriptorNode.modify()\n+                    .withErrorKeywordToken(errorKeywordToken)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public PanicStatementNode transform(PanicStatementNode panicStatementNode) {\n+        Token panicKeyword = formatToken(panicStatementNode.panicKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(panicStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(panicStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return panicStatementNode.modify()\n+                .withPanicKeyword(panicKeyword)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public IntersectionTypeDescriptorNode transform(IntersectionTypeDescriptorNode intersectionTypeDescriptorNode) {\n+        Node leftTypeDesc = formatNode(intersectionTypeDescriptorNode.leftTypeDesc(), 1, 0);\n+        Token bitwiseAndToken = formatToken(intersectionTypeDescriptorNode.bitwiseAndToken(), 1, 0);\n+        Node rightTypeDesc = formatNode(intersectionTypeDescriptorNode.rightTypeDesc(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return intersectionTypeDescriptorNode.modify()\n+                .withLeftTypeDesc(leftTypeDesc)\n+                .withBitwiseAndToken(bitwiseAndToken)\n+                .withRightTypeDesc(rightTypeDesc)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ModuleVariableDeclarationNode transform(ModuleVariableDeclarationNode moduleVariableDeclarationNode) {\n+        if (moduleVariableDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(moduleVariableDeclarationNode.metadata().get(), 1, 0);\n+            moduleVariableDeclarationNode = moduleVariableDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        if (moduleVariableDeclarationNode.finalKeyword().isPresent()) {\n+            Token finalKeyword = formatToken(moduleVariableDeclarationNode.finalKeyword().get(), 1, 0);\n+            moduleVariableDeclarationNode = moduleVariableDeclarationNode.modify()\n+                    .withFinalKeyword(finalKeyword).apply();\n+        }\n+\n+        TypedBindingPatternNode typedBindingPatternNode =\n+                formatNode(moduleVariableDeclarationNode.typedBindingPattern(), 1, 0);\n+        Token equalsToken = formatToken(moduleVariableDeclarationNode.equalsToken(), 1, 0);\n+        ExpressionNode initializer = formatNode(moduleVariableDeclarationNode.initializer(), 0, 0);\n+        Token semicolonToken = formatToken(moduleVariableDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return moduleVariableDeclarationNode.modify()\n+                .withTypedBindingPattern(typedBindingPatternNode)\n+                .withEqualsToken(equalsToken)\n+                .withInitializer(initializer)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionFunctionBodyNode transform(ExpressionFunctionBodyNode expressionFunctionBodyNode) {\n+        Token rightDoubleArrow = formatToken(expressionFunctionBodyNode.rightDoubleArrow(), 1, 0);\n+\n+        if (expressionFunctionBodyNode.semicolon().isPresent()) {\n+            ExpressionNode expression = formatNode(expressionFunctionBodyNode.expression(), 0, 0);\n+            Token semicolon = formatToken(expressionFunctionBodyNode.semicolon().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return expressionFunctionBodyNode.modify()\n+                    .withRightDoubleArrow(rightDoubleArrow)\n+                    .withExpression(expression)\n+                    .withSemicolon(semicolon)\n+                    .apply();\n+        } else {\n+            ExpressionNode expression = formatNode(expressionFunctionBodyNode.expression(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return expressionFunctionBodyNode.modify()\n+                    .withRightDoubleArrow(rightDoubleArrow)\n+                    .withExpression(expression)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public TypeCastExpressionNode transform(TypeCastExpressionNode typeCastExpressionNode) {\n+        Token ltToken = formatToken(typeCastExpressionNode.ltToken(), 0, 0);\n+        TypeCastParamNode typeCastParam = formatNode(typeCastExpressionNode.typeCastParam(), 0, 0);\n+        Token gtToken = formatToken(typeCastExpressionNode.gtToken(), 0, 0);\n+        ExpressionNode expression = formatNode(typeCastExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return typeCastExpressionNode.modify()\n+                .withLtToken(ltToken)\n+                .withTypeCastParam(typeCastParam)\n+                .withGtToken(gtToken)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeCastParamNode transform(TypeCastParamNode typeCastParamNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(typeCastParamNode.annotations(), 0, 1, 1, 0);\n+        Node type = formatNode(typeCastParamNode.type(), this.trailingWS, this.trailingNL);\n+\n+        return typeCastParamNode.modify()\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public IndexedExpressionNode transform(IndexedExpressionNode indexedExpressionNode) {\n+        ExpressionNode containerExpression = formatNode(indexedExpressionNode.containerExpression(), 0, 0);\n+        Token openBracket = formatToken(indexedExpressionNode.openBracket(), 0, 0);\n+        SeparatedNodeList<ExpressionNode> keyExpression = formatSeparatedNodeList(indexedExpressionNode.keyExpression(),\n+                0, 0, 0, 0);\n+        Token closeBracket = formatToken(indexedExpressionNode.closeBracket(), this.trailingWS, this.trailingNL);\n+\n+        return indexedExpressionNode.modify()\n+                .withContainerExpression(containerExpression)\n+                .withOpenBracket(openBracket)\n+                .withKeyExpression(keyExpression)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ComputedNameFieldNode transform(ComputedNameFieldNode computedNameFieldNode) {\n+        Token openBracket = formatToken(computedNameFieldNode.openBracket(), 0, 0);\n+        ExpressionNode fieldNameExpr = formatNode(computedNameFieldNode.fieldNameExpr(), 0, 0);\n+        Token closeBracket = formatToken(computedNameFieldNode.closeBracket(), 1, 0);\n+        Token colonToken = formatToken(computedNameFieldNode.colonToken(), 1, 0);\n+        ExpressionNode valueExpr = formatNode(computedNameFieldNode.valueExpr(), this.trailingWS, this.trailingNL);\n+\n+        return computedNameFieldNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withFieldNameExpr(fieldNameExpr)\n+                .withCloseBracket(closeBracket)\n+                .withColonToken(colonToken)\n+                .withValueExpr(valueExpr)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TupleTypeDescriptorNode transform(TupleTypeDescriptorNode tupleTypeDescriptorNode) {\n+        Token openBracketToken = formatToken(tupleTypeDescriptorNode.openBracketToken(), 0, 0);\n+        SeparatedNodeList<Node> memberTypeDesc = formatSeparatedNodeList(tupleTypeDescriptorNode.memberTypeDesc(),\n+                0, 0, 0, 0);\n+        Token closeBracketToken = formatToken(tupleTypeDescriptorNode.closeBracketToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tupleTypeDescriptorNode.modify()\n+                .withOpenBracketToken(openBracketToken)\n+                .withMemberTypeDesc(memberTypeDesc)\n+                .withCloseBracketToken(closeBracketToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatternNode) {\n+        Token openBracket = formatToken(listBindingPatternNode.openBracket(), 0, 0);\n+        SeparatedNodeList<BindingPatternNode> bindingPatternNodes =\n+                formatSeparatedNodeList(listBindingPatternNode.bindingPatterns(), 0, 0, 0, 0);\n+        Token closeBracket = formatToken(listBindingPatternNode.closeBracket(), this.trailingWS, this.trailingNL);\n+\n+        if (listBindingPatternNode.restBindingPattern().isPresent()) {\n+            RestBindingPatternNode restBindingPattern = formatNode(listBindingPatternNode.restBindingPattern().get(),\n+                    this.trailingWS, this.trailingNL);\n+            listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n+        }\n+\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(), 1, 0);\n+\n+        return tableTypeDescriptorNode.modify()\n+                .withTableKeywordToken(tableKeywordToken)\n+                .withRowTypeParameterNode(rowTypeParameterNode)\n+                .withKeyConstraintNode(keyConstraintNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n+        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n+        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return keyTypeConstraintNode.modify()\n+                .withKeyKeywordToken(keyKeywordToken)\n+                .withTypeParameterNode(typeParameterNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n+        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n+        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n+        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n+        indent();\n+        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace;\n+\n+        if (hasOnFailClause) {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return matchStatementNode.modify()\n+                .withMatchKeyword(matchKeyword)\n+                .withCondition(condition)\n+                .withOpenBrace(openBrace)\n+                .withMatchClauses(matchClauses)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n+        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n+                0, 0, 0, 0, 1, 0);\n+\n+        if (matchClauseNode.matchGuard().isPresent()) {\n+            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n+            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        }\n+\n+        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return matchClauseNode.modify()\n+                .withMatchPatterns(matchPatterns)\n+                .withRightDoubleArrow(rightDoubleArrow)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n+        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return matchGuardNode.modify()\n+                .withIfKeyword(ifKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n+        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n+        StatementNode blockStatement;\n+\n+        if (lockStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return lockStatementNode.modify()\n+                .withLockKeyword(lockKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n+        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n+        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n+        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return fieldAccessExpressionNode.modify()\n+                .withExpression(expression)\n+                .withDotToken(dotToken)\n+                .withFieldName(fieldName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MetadataNode transform(MetadataNode metadataNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+\n+        if (metadataNode.documentationString().isPresent()) {\n+            Node documentationString = formatNode(metadataNode.documentationString().get(),\n+                    this.trailingWS, this.trailingNL);\n+            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n+        }\n+\n+        return metadataNode.modify()\n+                .withAnnotations(annotations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n+        if (enumDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n+            enumDeclarationNode = enumDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n+        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n+        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n+        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n+        indent();\n+        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n+                0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return enumDeclarationNode.modify()\n+                .withQualifier(qualifier)\n+                .withEnumKeywordToken(enumKeywordToken)\n+                .withIdentifier(identifier)\n+                .withOpenBraceToken(openBraceToken)\n+                .withEnumMemberList(enumMemberList)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n+        if (enumMemberNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n+            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n+        }\n+        IdentifierToken identifier;\n+\n+        if (enumMemberNode.equalToken().isPresent()) {\n+            identifier = formatNode(enumMemberNode.identifier(), 1, 0);\n+            Token equalToken = formatToken(enumMemberNode.equalToken().get(), 1, 0);\n+            ExpressionNode constExprNode = formatNode(enumMemberNode.constExprNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .withEqualToken(equalToken)\n+                    .withConstExprNode(constExprNode)\n+                    .apply();\n+        } else {\n+            identifier = formatNode(enumMemberNode.identifier(), this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationNode transform(MarkdownDocumentationNode markdownDocumentationNode) {\n+        NodeList<Node> documentationLines = formatNodeList(markdownDocumentationNode.documentationLines(), 0, 0, 0, 1);\n+\n+        return markdownDocumentationNode.modify()\n+                .withDocumentationLines(documentationLines)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationLineNode transform(MarkdownDocumentationLineNode markdownDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownDocumentationLineNode.hashToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownDocumentationLineNode.documentElements(), 0, 0, 0, 1);", "originalCommit": "2093e02f1bc23ac9cb8fcbdbd1c9ef0c196c5e9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQ3NjYwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26161#discussion_r497476607", "bodyText": "same here", "author": "SupunS", "createdAt": "2020-09-30T12:40:56Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -920,6 +956,645 @@ public NilTypeDescriptorNode transform(NilTypeDescriptorNode nilTypeDescriptorNo\n                 .apply();\n     }\n \n+    @Override\n+    public ConstantDeclarationNode transform(ConstantDeclarationNode constantDeclarationNode) {\n+        if (constantDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(constantDeclarationNode.metadata().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        if (constantDeclarationNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(constantDeclarationNode.visibilityQualifier().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify()\n+                    .withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+        Token constKeyword = formatToken(constantDeclarationNode.constKeyword(), 1, 0);\n+\n+        if (constantDeclarationNode.typeDescriptor().isPresent()) {\n+            TypeDescriptorNode typeDescriptorNode = formatNode(constantDeclarationNode.typeDescriptor().get(), 1, 0);\n+            constantDeclarationNode = constantDeclarationNode.modify().withTypeDescriptor(typeDescriptorNode).apply();\n+        }\n+\n+        Token variableName = formatToken(constantDeclarationNode.variableName(), 1, 0);\n+        Token equalsToken = formatToken(constantDeclarationNode.equalsToken(), 1, 0);\n+        Node initializer = formatNode(constantDeclarationNode.initializer(), 0, 0);\n+        Token semicolonToken = formatToken(constantDeclarationNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return constantDeclarationNode.modify()\n+                .withConstKeyword(constKeyword)\n+                .withEqualsToken(equalsToken)\n+                .withInitializer(initializer)\n+                .withSemicolonToken(semicolonToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParameterizedTypeDescriptorNode transform(ParameterizedTypeDescriptorNode parameterizedTypeDescriptorNode) {\n+        Token parameterizedType = formatToken(parameterizedTypeDescriptorNode.parameterizedType(), 0, 0);\n+        TypeParameterNode typeParameter = formatNode(parameterizedTypeDescriptorNode.typeParameter(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return parameterizedTypeDescriptorNode.modify()\n+                .withParameterizedType(parameterizedType)\n+                .withTypeParameter(typeParameter)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeParameterNode transform(TypeParameterNode typeParameterNode) {\n+        Token ltToken = formatToken(typeParameterNode.ltToken(), 0, 0);\n+        TypeDescriptorNode typeNode = formatNode(typeParameterNode.typeNode(), 0, 0);\n+        Token gtToken = formatToken(typeParameterNode.gtToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeParameterNode.modify()\n+                .withTypeNode(typeNode)\n+                .withLtToken(ltToken)\n+                .withGtToken(gtToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FunctionTypeDescriptorNode transform(FunctionTypeDescriptorNode functionTypeDescriptorNode) {\n+        NodeList<Token> qualifierList = formatNodeList(functionTypeDescriptorNode.qualifierList(), 1, 0, 0, 1);\n+        Token functionKeyword = formatToken(functionTypeDescriptorNode.functionKeyword(), 1, 0);\n+        FunctionSignatureNode functionSignature = formatNode(functionTypeDescriptorNode.functionSignature(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return functionTypeDescriptorNode.modify()\n+                .withQualifierList(qualifierList)\n+                .withFunctionKeyword(functionKeyword)\n+                .withFunctionSignature(functionSignature)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesisedTypeDescriptorNode transform(ParenthesisedTypeDescriptorNode parenthesisedTypeDescriptorNode) {\n+        Token openParenToken = formatToken(parenthesisedTypeDescriptorNode.openParenToken(), 0, 0);\n+        TypeDescriptorNode typedesc = formatNode(parenthesisedTypeDescriptorNode.typedesc(), 0, 0);\n+        Token closeParenToken = formatToken(parenthesisedTypeDescriptorNode.closeParenToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return parenthesisedTypeDescriptorNode.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withTypedesc(typedesc)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExternalFunctionBodyNode transform(ExternalFunctionBodyNode externalFunctionBodyNode) {\n+        Token equalsToken = formatToken(externalFunctionBodyNode.equalsToken(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(externalFunctionBodyNode.annotations(), 0, 1, 1, 0);\n+        Token externalKeyword = formatToken(externalFunctionBodyNode.externalKeyword(), 0, 0);\n+        Token semicolonToken = formatToken(externalFunctionBodyNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return externalFunctionBodyNode.modify()\n+                .withEqualsToken(equalsToken)\n+                .withAnnotations(annotations)\n+                .withExternalKeyword(externalKeyword)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AnnotationNode transform(AnnotationNode annotationNode) {\n+        Token atToken = formatToken(annotationNode.atToken(), 0, 0);\n+        Node annotReference = formatNode(annotationNode.annotReference(), 1, 0);\n+\n+        if (annotationNode.annotValue().isPresent()) {\n+            MappingConstructorExpressionNode annotValue = formatNode(annotationNode.annotValue().get(),\n+                    this.trailingWS, this.trailingNL);\n+            annotationNode = annotationNode.modify().withAnnotValue(annotValue).apply();\n+        }\n+\n+        return annotationNode.modify()\n+                .withAtToken(atToken)\n+                .withAnnotReference(annotReference)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MappingConstructorExpressionNode transform(\n+            MappingConstructorExpressionNode mappingConstructorExpressionNode) {\n+        Token openBrace = formatToken(mappingConstructorExpressionNode.openBrace(), 0, 1);\n+        indent();\n+        SeparatedNodeList<MappingFieldNode> fields = formatSeparatedNodeList(\n+                mappingConstructorExpressionNode.fields(), 0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace = formatToken(mappingConstructorExpressionNode.closeBrace(), this.trailingWS, this.trailingNL);\n+\n+        return mappingConstructorExpressionNode.modify()\n+                .withOpenBrace(openBrace)\n+                .withFields(fields)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SpecificFieldNode transform(SpecificFieldNode specificFieldNode) {\n+        if (specificFieldNode.readonlyKeyword().isPresent()) {\n+            Token readOnlyKeyword = formatToken(specificFieldNode.readonlyKeyword().get(), 1, 0);\n+            specificFieldNode = specificFieldNode.modify()\n+                    .withReadonlyKeyword(readOnlyKeyword).apply();\n+        }\n+\n+        Token fieldName;\n+        if (specificFieldNode.fieldName() instanceof BasicLiteralNode) {\n+            fieldName = ((BasicLiteralNode) specificFieldNode.fieldName()).literalToken();\n+        } else {\n+            fieldName = (Token) specificFieldNode.fieldName();\n+        }\n+\n+        if (specificFieldNode.colon().isPresent()) {\n+            fieldName = formatToken(fieldName, 1, 0);\n+            Token colon = formatToken(specificFieldNode.colon().get(), 1, 0);\n+            ExpressionNode expressionNode = formatNode(specificFieldNode.valueExpr().get(),\n+                    this.trailingWS, this.trailingNL);\n+            return specificFieldNode.modify()\n+                    .withFieldName(fieldName)\n+                    .withColon(colon)\n+                    .withValueExpr(expressionNode)\n+                    .apply();\n+        } else {\n+            fieldName = formatToken(fieldName, this.trailingWS, this.trailingNL);\n+            return specificFieldNode.modify()\n+                    .withFieldName(fieldName)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public ListConstructorExpressionNode transform(ListConstructorExpressionNode listConstructorExpressionNode) {\n+        Token openBracket = formatToken(listConstructorExpressionNode.openBracket(), 0, 0);\n+        SeparatedNodeList<Node> expressions = formatSeparatedNodeList(listConstructorExpressionNode.expressions(),\n+                0, 0, 0, 0);\n+        Token closeBracket = formatToken(listConstructorExpressionNode.closeBracket(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return listConstructorExpressionNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withExpressions(expressions)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ErrorTypeDescriptorNode transform(ErrorTypeDescriptorNode errorTypeDescriptorNode) {\n+        if (errorTypeDescriptorNode.errorTypeParamsNode().isPresent()) {\n+            Token errorKeywordToken = formatToken(errorTypeDescriptorNode.errorKeywordToken(), 1, 0);\n+            ErrorTypeParamsNode errorTypeParamsNode = formatNode(errorTypeDescriptorNode.errorTypeParamsNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return errorTypeDescriptorNode.modify()\n+                    .withErrorKeywordToken(errorKeywordToken)\n+                    .withErrorTypeParamsNode(errorTypeParamsNode)\n+                    .apply();\n+        } else {\n+            Token errorKeywordToken = formatToken(errorTypeDescriptorNode.errorKeywordToken(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return errorTypeDescriptorNode.modify()\n+                    .withErrorKeywordToken(errorKeywordToken)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public PanicStatementNode transform(PanicStatementNode panicStatementNode) {\n+        Token panicKeyword = formatToken(panicStatementNode.panicKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(panicStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(panicStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return panicStatementNode.modify()\n+                .withPanicKeyword(panicKeyword)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public IntersectionTypeDescriptorNode transform(IntersectionTypeDescriptorNode intersectionTypeDescriptorNode) {\n+        Node leftTypeDesc = formatNode(intersectionTypeDescriptorNode.leftTypeDesc(), 1, 0);\n+        Token bitwiseAndToken = formatToken(intersectionTypeDescriptorNode.bitwiseAndToken(), 1, 0);\n+        Node rightTypeDesc = formatNode(intersectionTypeDescriptorNode.rightTypeDesc(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return intersectionTypeDescriptorNode.modify()\n+                .withLeftTypeDesc(leftTypeDesc)\n+                .withBitwiseAndToken(bitwiseAndToken)\n+                .withRightTypeDesc(rightTypeDesc)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ModuleVariableDeclarationNode transform(ModuleVariableDeclarationNode moduleVariableDeclarationNode) {\n+        if (moduleVariableDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(moduleVariableDeclarationNode.metadata().get(), 1, 0);\n+            moduleVariableDeclarationNode = moduleVariableDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        if (moduleVariableDeclarationNode.finalKeyword().isPresent()) {\n+            Token finalKeyword = formatToken(moduleVariableDeclarationNode.finalKeyword().get(), 1, 0);\n+            moduleVariableDeclarationNode = moduleVariableDeclarationNode.modify()\n+                    .withFinalKeyword(finalKeyword).apply();\n+        }\n+\n+        TypedBindingPatternNode typedBindingPatternNode =\n+                formatNode(moduleVariableDeclarationNode.typedBindingPattern(), 1, 0);\n+        Token equalsToken = formatToken(moduleVariableDeclarationNode.equalsToken(), 1, 0);\n+        ExpressionNode initializer = formatNode(moduleVariableDeclarationNode.initializer(), 0, 0);\n+        Token semicolonToken = formatToken(moduleVariableDeclarationNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return moduleVariableDeclarationNode.modify()\n+                .withTypedBindingPattern(typedBindingPatternNode)\n+                .withEqualsToken(equalsToken)\n+                .withInitializer(initializer)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionFunctionBodyNode transform(ExpressionFunctionBodyNode expressionFunctionBodyNode) {\n+        Token rightDoubleArrow = formatToken(expressionFunctionBodyNode.rightDoubleArrow(), 1, 0);\n+\n+        if (expressionFunctionBodyNode.semicolon().isPresent()) {\n+            ExpressionNode expression = formatNode(expressionFunctionBodyNode.expression(), 0, 0);\n+            Token semicolon = formatToken(expressionFunctionBodyNode.semicolon().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return expressionFunctionBodyNode.modify()\n+                    .withRightDoubleArrow(rightDoubleArrow)\n+                    .withExpression(expression)\n+                    .withSemicolon(semicolon)\n+                    .apply();\n+        } else {\n+            ExpressionNode expression = formatNode(expressionFunctionBodyNode.expression(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return expressionFunctionBodyNode.modify()\n+                    .withRightDoubleArrow(rightDoubleArrow)\n+                    .withExpression(expression)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public TypeCastExpressionNode transform(TypeCastExpressionNode typeCastExpressionNode) {\n+        Token ltToken = formatToken(typeCastExpressionNode.ltToken(), 0, 0);\n+        TypeCastParamNode typeCastParam = formatNode(typeCastExpressionNode.typeCastParam(), 0, 0);\n+        Token gtToken = formatToken(typeCastExpressionNode.gtToken(), 0, 0);\n+        ExpressionNode expression = formatNode(typeCastExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return typeCastExpressionNode.modify()\n+                .withLtToken(ltToken)\n+                .withTypeCastParam(typeCastParam)\n+                .withGtToken(gtToken)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeCastParamNode transform(TypeCastParamNode typeCastParamNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(typeCastParamNode.annotations(), 0, 1, 1, 0);\n+        Node type = formatNode(typeCastParamNode.type(), this.trailingWS, this.trailingNL);\n+\n+        return typeCastParamNode.modify()\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public IndexedExpressionNode transform(IndexedExpressionNode indexedExpressionNode) {\n+        ExpressionNode containerExpression = formatNode(indexedExpressionNode.containerExpression(), 0, 0);\n+        Token openBracket = formatToken(indexedExpressionNode.openBracket(), 0, 0);\n+        SeparatedNodeList<ExpressionNode> keyExpression = formatSeparatedNodeList(indexedExpressionNode.keyExpression(),\n+                0, 0, 0, 0);\n+        Token closeBracket = formatToken(indexedExpressionNode.closeBracket(), this.trailingWS, this.trailingNL);\n+\n+        return indexedExpressionNode.modify()\n+                .withContainerExpression(containerExpression)\n+                .withOpenBracket(openBracket)\n+                .withKeyExpression(keyExpression)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ComputedNameFieldNode transform(ComputedNameFieldNode computedNameFieldNode) {\n+        Token openBracket = formatToken(computedNameFieldNode.openBracket(), 0, 0);\n+        ExpressionNode fieldNameExpr = formatNode(computedNameFieldNode.fieldNameExpr(), 0, 0);\n+        Token closeBracket = formatToken(computedNameFieldNode.closeBracket(), 1, 0);\n+        Token colonToken = formatToken(computedNameFieldNode.colonToken(), 1, 0);\n+        ExpressionNode valueExpr = formatNode(computedNameFieldNode.valueExpr(), this.trailingWS, this.trailingNL);\n+\n+        return computedNameFieldNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withFieldNameExpr(fieldNameExpr)\n+                .withCloseBracket(closeBracket)\n+                .withColonToken(colonToken)\n+                .withValueExpr(valueExpr)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TupleTypeDescriptorNode transform(TupleTypeDescriptorNode tupleTypeDescriptorNode) {\n+        Token openBracketToken = formatToken(tupleTypeDescriptorNode.openBracketToken(), 0, 0);\n+        SeparatedNodeList<Node> memberTypeDesc = formatSeparatedNodeList(tupleTypeDescriptorNode.memberTypeDesc(),\n+                0, 0, 0, 0);\n+        Token closeBracketToken = formatToken(tupleTypeDescriptorNode.closeBracketToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return tupleTypeDescriptorNode.modify()\n+                .withOpenBracketToken(openBracketToken)\n+                .withMemberTypeDesc(memberTypeDesc)\n+                .withCloseBracketToken(closeBracketToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ListBindingPatternNode transform(ListBindingPatternNode listBindingPatternNode) {\n+        Token openBracket = formatToken(listBindingPatternNode.openBracket(), 0, 0);\n+        SeparatedNodeList<BindingPatternNode> bindingPatternNodes =\n+                formatSeparatedNodeList(listBindingPatternNode.bindingPatterns(), 0, 0, 0, 0);\n+        Token closeBracket = formatToken(listBindingPatternNode.closeBracket(), this.trailingWS, this.trailingNL);\n+\n+        if (listBindingPatternNode.restBindingPattern().isPresent()) {\n+            RestBindingPatternNode restBindingPattern = formatNode(listBindingPatternNode.restBindingPattern().get(),\n+                    this.trailingWS, this.trailingNL);\n+            listBindingPatternNode = listBindingPatternNode.modify().withRestBindingPattern(restBindingPattern).apply();\n+        }\n+\n+        return listBindingPatternNode.modify()\n+                .withOpenBracket(openBracket)\n+                .withBindingPatterns(bindingPatternNodes)\n+                .withCloseBracket(closeBracket)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RestBindingPatternNode transform(RestBindingPatternNode restBindingPatternNode) {\n+        Token ellipsisToken = formatToken(restBindingPatternNode.ellipsisToken(), 0, 0);\n+        SimpleNameReferenceNode variableName = formatNode(restBindingPatternNode.variableName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return restBindingPatternNode.modify()\n+                .withEllipsisToken(ellipsisToken)\n+                .withVariableName(variableName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TableTypeDescriptorNode transform(TableTypeDescriptorNode tableTypeDescriptorNode) {\n+        Token tableKeywordToken = formatToken(tableTypeDescriptorNode.tableKeywordToken(), 0, 0);\n+        Node rowTypeParameterNode = formatNode(tableTypeDescriptorNode.rowTypeParameterNode(), 1, 0);\n+        Node keyConstraintNode = formatNode(tableTypeDescriptorNode.keyConstraintNode(), 1, 0);\n+\n+        return tableTypeDescriptorNode.modify()\n+                .withTableKeywordToken(tableKeywordToken)\n+                .withRowTypeParameterNode(rowTypeParameterNode)\n+                .withKeyConstraintNode(keyConstraintNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public KeyTypeConstraintNode transform(KeyTypeConstraintNode keyTypeConstraintNode) {\n+        Token keyKeywordToken = formatToken(keyTypeConstraintNode.keyKeywordToken(), 0, 0);\n+        Node typeParameterNode = formatNode(keyTypeConstraintNode.typeParameterNode(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return keyTypeConstraintNode.modify()\n+                .withKeyKeywordToken(keyKeywordToken)\n+                .withTypeParameterNode(typeParameterNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchStatementNode transform(MatchStatementNode matchStatementNode) {\n+        boolean hasOnFailClause = matchStatementNode.onFailClause().isPresent();\n+        Token matchKeyword = formatToken(matchStatementNode.matchKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(matchStatementNode.condition(), 1, 0);\n+        Token openBrace = formatToken(matchStatementNode.openBrace(), 0, 1);\n+        indent();\n+        NodeList<MatchClauseNode> matchClauses = formatNodeList(matchStatementNode.matchClauses(), 0, 1, 0, 1);\n+        unindent();\n+        Token closeBrace;\n+\n+        if (hasOnFailClause) {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(matchStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            matchStatementNode = matchStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            closeBrace = formatToken(matchStatementNode.closeBrace(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return matchStatementNode.modify()\n+                .withMatchKeyword(matchKeyword)\n+                .withCondition(condition)\n+                .withOpenBrace(openBrace)\n+                .withMatchClauses(matchClauses)\n+                .withCloseBrace(closeBrace)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchClauseNode transform(MatchClauseNode matchClauseNode) {\n+        SeparatedNodeList<Node> matchPatterns = formatSeparatedNodeList(matchClauseNode.matchPatterns(),\n+                0, 0, 0, 0, 1, 0);\n+\n+        if (matchClauseNode.matchGuard().isPresent()) {\n+            MatchGuardNode matchGuard = formatNode(matchClauseNode.matchGuard().get(), 1, 0);\n+            matchClauseNode = matchClauseNode.modify().withMatchGuard(matchGuard).apply();\n+        }\n+\n+        Token rightDoubleArrow = formatToken(matchClauseNode.rightDoubleArrow(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(matchClauseNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return matchClauseNode.modify()\n+                .withMatchPatterns(matchPatterns)\n+                .withRightDoubleArrow(rightDoubleArrow)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MatchGuardNode transform(MatchGuardNode matchGuardNode) {\n+        Token ifKeyword = formatToken(matchGuardNode.ifKeyword(), 1, 0);\n+        ExpressionNode expression = formatNode(matchGuardNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return matchGuardNode.modify()\n+                .withIfKeyword(ifKeyword)\n+                .withExpression(expression)\n+                .apply();\n+    }\n+\n+    @Override\n+    public LockStatementNode transform(LockStatementNode lockStatementNode) {\n+        Token lockKeyword = formatToken(lockStatementNode.lockKeyword(), 1, 0);\n+        StatementNode blockStatement;\n+\n+        if (lockStatementNode.onFailClause().isPresent()) {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), 1, 0);\n+            OnFailClauseNode onFailClause = formatNode(lockStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            lockStatementNode = lockStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        } else {\n+            blockStatement = formatNode(lockStatementNode.blockStatement(), this.trailingWS, this.trailingNL);\n+        }\n+\n+        return lockStatementNode.modify()\n+                .withLockKeyword(lockKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public FieldAccessExpressionNode transform(FieldAccessExpressionNode fieldAccessExpressionNode) {\n+        ExpressionNode expression = formatNode(fieldAccessExpressionNode.expression(), 0, 0);\n+        Token dotToken = formatToken(fieldAccessExpressionNode.dotToken(), 0, 0);\n+        NameReferenceNode fieldName = formatNode(fieldAccessExpressionNode.fieldName(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return fieldAccessExpressionNode.modify()\n+                .withExpression(expression)\n+                .withDotToken(dotToken)\n+                .withFieldName(fieldName)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MetadataNode transform(MetadataNode metadataNode) {\n+        NodeList<AnnotationNode> annotations = formatNodeList(metadataNode.annotations(), 0, 1, 0, 1);\n+\n+        if (metadataNode.documentationString().isPresent()) {\n+            Node documentationString = formatNode(metadataNode.documentationString().get(),\n+                    this.trailingWS, this.trailingNL);\n+            metadataNode = metadataNode.modify().withDocumentationString(documentationString).apply();\n+        }\n+\n+        return metadataNode.modify()\n+                .withAnnotations(annotations)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumDeclarationNode transform(EnumDeclarationNode enumDeclarationNode) {\n+        if (enumDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumDeclarationNode.metadata().get(), 0, 1);\n+            enumDeclarationNode = enumDeclarationNode.modify()\n+                    .withMetadata(metadata).apply();\n+        }\n+\n+        Token qualifier = formatToken(enumDeclarationNode.qualifier(), 1, 0);\n+        Token enumKeywordToken = formatToken(enumDeclarationNode.enumKeywordToken(), 1, 0);\n+        IdentifierToken identifier = formatNode(enumDeclarationNode.identifier(), 1, 0);\n+        Token openBraceToken = formatToken(enumDeclarationNode.openBraceToken(), 0, 1);\n+        indent();\n+        SeparatedNodeList<Node> enumMemberList = formatSeparatedNodeList(enumDeclarationNode.enumMemberList(),\n+                0, 0, 0, 1, 0, 1);\n+        unindent();\n+        Token closeBraceToken = formatToken(enumDeclarationNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return enumDeclarationNode.modify()\n+                .withQualifier(qualifier)\n+                .withEnumKeywordToken(enumKeywordToken)\n+                .withIdentifier(identifier)\n+                .withOpenBraceToken(openBraceToken)\n+                .withEnumMemberList(enumMemberList)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public EnumMemberNode transform(EnumMemberNode enumMemberNode) {\n+        if (enumMemberNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(enumMemberNode.metadata().get(), 0, 1);\n+            enumMemberNode = enumMemberNode.modify().withMetadata(metadata).apply();\n+        }\n+        IdentifierToken identifier;\n+\n+        if (enumMemberNode.equalToken().isPresent()) {\n+            identifier = formatNode(enumMemberNode.identifier(), 1, 0);\n+            Token equalToken = formatToken(enumMemberNode.equalToken().get(), 1, 0);\n+            ExpressionNode constExprNode = formatNode(enumMemberNode.constExprNode().get(),\n+                    this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .withEqualToken(equalToken)\n+                    .withConstExprNode(constExprNode)\n+                    .apply();\n+        } else {\n+            identifier = formatNode(enumMemberNode.identifier(), this.trailingWS, this.trailingNL);\n+\n+            return enumMemberNode.modify()\n+                    .withIdentifier(identifier)\n+                    .apply();\n+        }\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationNode transform(MarkdownDocumentationNode markdownDocumentationNode) {\n+        NodeList<Node> documentationLines = formatNodeList(markdownDocumentationNode.documentationLines(), 0, 0, 0, 1);\n+\n+        return markdownDocumentationNode.modify()\n+                .withDocumentationLines(documentationLines)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownDocumentationLineNode transform(MarkdownDocumentationLineNode markdownDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownDocumentationLineNode.hashToken(), 0, 0);\n+        NodeList<Node> documentElements = formatNodeList(markdownDocumentationLineNode.documentElements(), 0, 0, 0, 1);\n+\n+        return markdownDocumentationLineNode.modify()\n+                .withDocumentElements(documentElements)\n+                .withHashToken(hashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public MarkdownParameterDocumentationLineNode transform(\n+            MarkdownParameterDocumentationLineNode markdownParameterDocumentationLineNode) {\n+        Token hashToken = formatToken(markdownParameterDocumentationLineNode.hashToken(), 1, 0);\n+        Token plusToken = formatToken(markdownParameterDocumentationLineNode.plusToken(), 1, 0);\n+        Token parameterName = formatToken(markdownParameterDocumentationLineNode.parameterName(), 1, 0);\n+        Token minusToken = formatToken(markdownParameterDocumentationLineNode.minusToken(), 0, 0);\n+        NodeList<Node> documentElements =\n+                formatNodeList(markdownParameterDocumentationLineNode.documentElements(), 0, 0, 0, 1);", "originalCommit": "2093e02f1bc23ac9cb8fcbdbd1c9ef0c196c5e9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}