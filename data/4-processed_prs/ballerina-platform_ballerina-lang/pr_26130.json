{"pr_number": 26130, "pr_title": "Add annotation completion support", "pr_createdAt": "2020-09-28T07:26:34Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26130", "timeline": [{"oid": "16d663dd00805dfc6a6d97b73d7551a6214305a3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/16d663dd00805dfc6a6d97b73d7551a6214305a3", "message": "add annotation completion support", "committedDate": "2020-09-28T07:15:43Z", "type": "commit"}, {"oid": "27c761f3fd41abf876d5e23e0dde47ecac8e117c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/27c761f3fd41abf876d5e23e0dde47ecac8e117c", "message": "add java doc for public API", "committedDate": "2020-09-28T07:31:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc2OTMyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26130#discussion_r495769323", "bodyText": "Shall we rename this into a more meaningful name like annotations or filteredAnnotations", "author": "rasika", "createdAt": "2020-09-28T08:25:13Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/providers/context/AnnotationNodeContext.java", "diffHunk": "@@ -71,53 +71,112 @@ public AnnotationNodeContext() {\n             }\n         }\n \n-        Node annotRef = node.annotReference();\n-        String finalAlias = annotRef.kind() != SyntaxKind.QUALIFIED_NAME_REFERENCE ? null\n-                : ((QualifiedNameReferenceNode) annotRef).modulePrefix().text();\n         Map<String, String> pkgAliasMap = context.get(DocumentServiceKeys.CURRENT_DOC_IMPORTS_KEY).stream()\n                 .filter(pkg -> pkg.symbol != null)\n                 .collect(Collectors.toMap(pkg -> pkg.symbol.pkgID.toString(), pkg -> pkg.alias.value));\n \n+        if (this.onQualifiedNameIdentifier(context, node.annotReference())) {\n+            QualifiedNameReferenceNode qNameRef = (QualifiedNameReferenceNode) node.annotReference();\n+            return this.getAnnotationsInModule(context, qNameRef.modulePrefix().text(), attachedNode, pkgAliasMap);\n+        }\n+\n         LSAnnotationCache.getInstance().getAnnotationMapForType(attachedNode, context)\n                 .forEach((key, value) -> value.forEach(annotation -> {\n-                    String annotationPkgAlias = annotation.pkgID.nameComps\n-                            .get(annotation.pkgID.nameComps.size() - 1).value;\n-                    String annotationPkg = annotation.pkgID.toString();\n-                    // compare with the import statements' package alias\n-                    if (finalAlias == null || finalAlias.equals(annotationPkgAlias)\n-                            || finalAlias.equals(pkgAliasMap.get(annotationPkg))) {\n-                        completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, finalAlias,\n-                                pkgAliasMap));\n-                    }\n+                    boolean withAlias = this.withAlias(context, node, annotation.pkgID);\n+                    completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, withAlias,\n+                            pkgAliasMap));\n                 }));\n-        completionItems.addAll(this.getAnnotationsInModule(context, attachedNode, pkgAliasMap));\n+        completionItems.addAll(this.getCurrentModuleAnnotations(context, attachedNode, pkgAliasMap));\n         return completionItems;\n     }\n \n-    private List<LSCompletionItem> getAnnotationsInModule(LSContext ctx, SyntaxKind kind,\n-                                                          Map<String, String> pkgAliasMap) {\n+    private boolean withAlias(LSContext context, AnnotationNode node, PackageID annotationOwner) {\n+        PackageID currentModule = context.get(DocumentServiceKeys.CURRENT_PACKAGE_ID_KEY);\n+        String orgName = annotationOwner.orgName.getValue();\n+        String value = annotationOwner.getName().getValue();\n+        return node.annotReference().kind() != SyntaxKind.QUALIFIED_NAME_REFERENCE\n+                && !currentModule.name.value.equals(annotationOwner.name.value) && !(\"ballerina\".equals(orgName)\n+                && \"lang.annotations\".equals(value));\n+    }\n+\n+    private List<LSCompletionItem> getCurrentModuleAnnotations(LSContext ctx, SyntaxKind kind,\n+                                                               Map<String, String> pkgAliasMap) {\n         BLangPackage bLangPackage = ctx.get(DocumentServiceKeys.CURRENT_BLANG_PACKAGE_CONTEXT_KEY);\n-        List<LSCompletionItem> completionItems = new ArrayList<>();\n-        List<BLangAnnotation> annotations = bLangPackage.topLevelNodes.stream()\n+        List<BAnnotationSymbol> annotations = bLangPackage.topLevelNodes.stream()\n                 .filter(topLevelNode -> topLevelNode instanceof BLangAnnotation)\n-                .map(topLevelNode -> (BLangAnnotation) topLevelNode)\n+                .map(topLevelNode -> (BAnnotationSymbol) ((BLangAnnotation) topLevelNode).symbol)\n+                .collect(Collectors.toList());\n+\n+        return this.getAnnotationCompletionsForSymbols(ctx, annotations, kind, pkgAliasMap);\n+    }\n+\n+    private List<LSCompletionItem> getAnnotationsInModule(LSContext context, String alias, SyntaxKind kind,\n+                                                          Map<String, String> pkgAliasMap) {\n+        Optional<Scope.ScopeEntry> moduleEntry = CommonUtil.packageSymbolFromAlias(context, alias);\n+        if (!moduleEntry.isPresent()) {\n+            List<LSCompletionItem> completionItems = new ArrayList<>();\n+            // Import statement has not been added. Hence try resolving from the annotation cache\n+            LSAnnotationCache.getInstance().getAnnotationsInModule(context, alias, kind)\n+                    .forEach((key, value) -> value.forEach(annotation -> {\n+                        completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, false,\n+                                pkgAliasMap));\n+                    }));\n+\n+            return completionItems;\n+        }\n+\n+        List<BAnnotationSymbol> collect = moduleEntry.get().symbol.scope.entries.values().stream()", "originalCommit": "27c761f3fd41abf876d5e23e0dde47ecac8e117c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc3NDM3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26130#discussion_r495774372", "bodyText": "Can we move node.parent().kind() into local variable and Line 140-144 can be simplified into a ternary return statement.", "author": "rasika", "createdAt": "2020-09-28T08:34:02Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/completions/providers/context/AnnotationNodeContext.java", "diffHunk": "@@ -71,53 +71,112 @@ public AnnotationNodeContext() {\n             }\n         }\n \n-        Node annotRef = node.annotReference();\n-        String finalAlias = annotRef.kind() != SyntaxKind.QUALIFIED_NAME_REFERENCE ? null\n-                : ((QualifiedNameReferenceNode) annotRef).modulePrefix().text();\n         Map<String, String> pkgAliasMap = context.get(DocumentServiceKeys.CURRENT_DOC_IMPORTS_KEY).stream()\n                 .filter(pkg -> pkg.symbol != null)\n                 .collect(Collectors.toMap(pkg -> pkg.symbol.pkgID.toString(), pkg -> pkg.alias.value));\n \n+        if (this.onQualifiedNameIdentifier(context, node.annotReference())) {\n+            QualifiedNameReferenceNode qNameRef = (QualifiedNameReferenceNode) node.annotReference();\n+            return this.getAnnotationsInModule(context, qNameRef.modulePrefix().text(), attachedNode, pkgAliasMap);\n+        }\n+\n         LSAnnotationCache.getInstance().getAnnotationMapForType(attachedNode, context)\n                 .forEach((key, value) -> value.forEach(annotation -> {\n-                    String annotationPkgAlias = annotation.pkgID.nameComps\n-                            .get(annotation.pkgID.nameComps.size() - 1).value;\n-                    String annotationPkg = annotation.pkgID.toString();\n-                    // compare with the import statements' package alias\n-                    if (finalAlias == null || finalAlias.equals(annotationPkgAlias)\n-                            || finalAlias.equals(pkgAliasMap.get(annotationPkg))) {\n-                        completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, finalAlias,\n-                                pkgAliasMap));\n-                    }\n+                    boolean withAlias = this.withAlias(context, node, annotation.pkgID);\n+                    completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, withAlias,\n+                            pkgAliasMap));\n                 }));\n-        completionItems.addAll(this.getAnnotationsInModule(context, attachedNode, pkgAliasMap));\n+        completionItems.addAll(this.getCurrentModuleAnnotations(context, attachedNode, pkgAliasMap));\n         return completionItems;\n     }\n \n-    private List<LSCompletionItem> getAnnotationsInModule(LSContext ctx, SyntaxKind kind,\n-                                                          Map<String, String> pkgAliasMap) {\n+    private boolean withAlias(LSContext context, AnnotationNode node, PackageID annotationOwner) {\n+        PackageID currentModule = context.get(DocumentServiceKeys.CURRENT_PACKAGE_ID_KEY);\n+        String orgName = annotationOwner.orgName.getValue();\n+        String value = annotationOwner.getName().getValue();\n+        return node.annotReference().kind() != SyntaxKind.QUALIFIED_NAME_REFERENCE\n+                && !currentModule.name.value.equals(annotationOwner.name.value) && !(\"ballerina\".equals(orgName)\n+                && \"lang.annotations\".equals(value));\n+    }\n+\n+    private List<LSCompletionItem> getCurrentModuleAnnotations(LSContext ctx, SyntaxKind kind,\n+                                                               Map<String, String> pkgAliasMap) {\n         BLangPackage bLangPackage = ctx.get(DocumentServiceKeys.CURRENT_BLANG_PACKAGE_CONTEXT_KEY);\n-        List<LSCompletionItem> completionItems = new ArrayList<>();\n-        List<BLangAnnotation> annotations = bLangPackage.topLevelNodes.stream()\n+        List<BAnnotationSymbol> annotations = bLangPackage.topLevelNodes.stream()\n                 .filter(topLevelNode -> topLevelNode instanceof BLangAnnotation)\n-                .map(topLevelNode -> (BLangAnnotation) topLevelNode)\n+                .map(topLevelNode -> (BAnnotationSymbol) ((BLangAnnotation) topLevelNode).symbol)\n+                .collect(Collectors.toList());\n+\n+        return this.getAnnotationCompletionsForSymbols(ctx, annotations, kind, pkgAliasMap);\n+    }\n+\n+    private List<LSCompletionItem> getAnnotationsInModule(LSContext context, String alias, SyntaxKind kind,\n+                                                          Map<String, String> pkgAliasMap) {\n+        Optional<Scope.ScopeEntry> moduleEntry = CommonUtil.packageSymbolFromAlias(context, alias);\n+        if (!moduleEntry.isPresent()) {\n+            List<LSCompletionItem> completionItems = new ArrayList<>();\n+            // Import statement has not been added. Hence try resolving from the annotation cache\n+            LSAnnotationCache.getInstance().getAnnotationsInModule(context, alias, kind)\n+                    .forEach((key, value) -> value.forEach(annotation -> {\n+                        completionItems.add(CommonUtil.getAnnotationCompletionItem(key, annotation, context, false,\n+                                pkgAliasMap));\n+                    }));\n+\n+            return completionItems;\n+        }\n+\n+        List<BAnnotationSymbol> collect = moduleEntry.get().symbol.scope.entries.values().stream()\n+                .filter(entry -> {\n+                    BSymbol symbol = entry.symbol;\n+                    return symbol instanceof BAnnotationSymbol && ((symbol.flags & Flags.PUBLIC) == Flags.PUBLIC);\n+                })\n+                .map(scopeEntry -> (BAnnotationSymbol) scopeEntry.symbol)\n                 .collect(Collectors.toList());\n-        BLangNode scopeNode = ctx.get(CompletionKeys.SCOPE_NODE_KEY);\n \n-        annotations.forEach(bLangAnnotation -> {\n-            BAnnotationSymbol symbol = (BAnnotationSymbol) bLangAnnotation.symbol;\n+        return this.getAnnotationCompletionsForSymbols(context, collect, kind, pkgAliasMap);\n+    }\n+\n+    private SyntaxKind getParentSyntaxKind(AnnotationNode node) {\n+        if (node.parent().kind() == SyntaxKind.METADATA) {", "originalCommit": "27c761f3fd41abf876d5e23e0dde47ecac8e117c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}