{"pr_number": 21187, "pr_title": "Implement Failover in WebSocket", "pr_createdAt": "2020-02-20T14:25:02Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187", "timeline": [{"oid": "436222ca898db5bd5d35273a4986ca2be30260e8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/436222ca898db5bd5d35273a4986ca2be30260e8", "message": "Merge branch\ng On branch master", "committedDate": "2020-02-07T09:18:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA5MjE3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r383092177", "bodyText": "Can we be consistent when documenting the return value? Here we have a full stop after the error and starts a  new sentence with the word If.  But in some places (for ex: Line 92) same sentence has continued.", "author": "anupama-pathirage", "createdAt": "2020-02-24T05:40:31Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_connector.bal", "diffHunk": "@@ -43,51 +45,61 @@ type WebSocketConnector object {\n         return externPushText(self, java:fromString(text), finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection.\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n+    # + return - An `error`. If an error occurs while sending the binary message to the server, that message\n+    #            will be lost\n     public function pushBinary(byte[] data, boolean finalFrame) returns WebSocketError? {\n         return externPushBinary(self, data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return - An `error`. If an error occurs while sending the ping frame to the server, that frame will be lost", "originalCommit": "11a273934aae95264e116906a469b0cf9e1e1c05", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY5MzYyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397693620", "bodyText": "Shall we give a proper name. For now lets call it ExtendedHashakeListener", "author": "shafreenAnfar", "createdAt": "2020-03-25T08:56:25Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/HandshakeListener.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.ClientHandshakeListener;\n+\n+/**\n+ * Interface for the client handshake listener.\n+ *\n+ * @since 1.2.0\n+ */\n+public interface HandshakeListener extends ClientHandshakeListener {", "originalCommit": "37544470b0fdd1aca5315a64b5f32301e19817de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY5Njk0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397696946", "bodyText": "Do we need this class base class should be WebSocketHandshakeListener right", "author": "shafreenAnfar", "createdAt": "2020-03-25T09:02:09Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/ClientHandshakeListener.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+/**\n+ * Handshake listener of WebSocket client.\n+ *\n+ * @since 1.2.0\n+ */\n+public class ClientHandshakeListener implements HandshakeListener {", "originalCommit": "37544470b0fdd1aca5315a64b5f32301e19817de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczNDQxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397734418", "bodyText": "Yes as the dispatchOnError() used to close the connection between client and server(terminate the connector thread) but WebSocketHandshakeListener is a base class for RetryHandshakeListener and FailoverHandshakeListener. Therefore we can't call that dispatchOnError() in the base class. So, I implemented this class to handle dispatchOnError() for normal webSocketClient.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-25T10:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzY5Njk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxODg2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397718861", "bodyText": "I think now it is a good time to move these listener creations to their respective endpoint classes :)", "author": "shafreenAnfar", "createdAt": "2020-03-25T09:38:31Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/InitEndpoint.java", "diffHunk": "@@ -59,140 +57,62 @@ public static void initEndpoint(ObjectValue webSocketClient) {\n                 HttpConstants.CLIENT_ENDPOINT_CONFIG);\n         Strand strand = Scheduler.getStrand();\n         String remoteUrl = webSocketClient.getStringValue(WebSocketConstants.CLIENT_URL_CONFIG);\n-        WebSocketService wsService = validateAndCreateWebSocketService(clientEndpointConfig, strand);\n+        WebSocketService wsService = WebSocketUtil.validateAndCreateWebSocketService(strand, clientEndpointConfig);\n         HttpWsConnectorFactory connectorFactory = HttpUtil.createHttpWsConnectionFactory();\n         WebSocketClientConnectorConfig clientConnectorConfig = new WebSocketClientConnectorConfig(remoteUrl);\n         String scheme = URI.create(remoteUrl).getScheme();\n-        populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n-        // Create the client connector.\n+        WebSocketUtil.populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n+        // Creates the client connector\n         WebSocketClientConnector clientConnector = connectorFactory.createWsClientConnector(clientConnectorConfig);\n-        WebSocketClientConnectorListener clientConnectorListener = new WebSocketClientConnectorListener();\n-        // Add the client connector as a native data when the client is not a failover client\n-        // because when using one URL, there is no need to create the client connector again.\n+        webSocketClient.addNativeData(WebSocketConstants.CONNECTOR_FACTORY, connectorFactory);\n+        // Add the client connector as a native data\n+        // because there is no need to create the client connector again when using one URL\n         webSocketClient.addNativeData(WebSocketConstants.CLIENT_CONNECTOR, clientConnector);\n-        webSocketClient.addNativeData(WebSocketConstants.CLIENT_LISTENER, clientConnectorListener);\n-        if (WebSocketUtil.hasRetryConfig(webSocketClient)) {\n-            @SuppressWarnings(WebSocketConstants.UNCHECKED)\n-            MapValue<String, Object> retryConfig = (MapValue<String, Object>) clientEndpointConfig.getMapValue(\n-                    WebSocketConstants.RETRY_CONFIG);\n-            RetryContext retryConnectorConfig = new RetryContext();\n-            populateRetryConnectorConfig(retryConfig, retryConnectorConfig);\n-            webSocketClient.addNativeData(WebSocketConstants.RETRY_CONFIG, retryConnectorConfig);\n-            CountDownLatch countDownLatch = new CountDownLatch(1);\n-            webSocketClient.addNativeData(WebSocketConstants.COUNT_DOWN_LATCH, countDownLatch);\n-            WebSocketUtil.establishWebSocketConnection(webSocketClient, wsService);\n-            // Set the count Down latch for initial connection\n-            waitForHandshake(countDownLatch);\n-        } else {\n-            WebSocketUtil.establishWebSocketConnection(webSocketClient, wsService);\n-        }\n-\n-    }\n-\n-    private static void waitForHandshake(CountDownLatch countDownLatch) {\n-        try {\n-            // Wait to call countDown()\n-            countDownLatch.await();\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-            throw new WebSocketException(WebSocketConstants.ERROR_MESSAGE + e.getMessage());\n-        }\n-    }\n-\n-    private static void populateClientConnectorConfig(MapValue<String, Object> clientEndpointConfig,\n-                                                      WebSocketClientConnectorConfig clientConnectorConfig,\n-                                                      String scheme) {\n-        clientConnectorConfig.setAutoRead(false); // Frames are read sequentially in ballerina.\n-        clientConnectorConfig.setSubProtocols(WebSocketUtil.findNegotiableSubProtocols(clientEndpointConfig));\n-        @SuppressWarnings(WebSocketConstants.UNCHECKED)\n-        MapValue<String, Object> headerValues = (MapValue<String, Object>) clientEndpointConfig.getMapValue(\n-                WebSocketConstants.CLIENT_CUSTOM_HEADERS_CONFIG);\n-        if (headerValues != null) {\n-            clientConnectorConfig.addHeaders(getCustomHeaders(headerValues));\n-        }\n-\n-        long idleTimeoutInSeconds = WebSocketUtil.findTimeoutInSeconds(clientEndpointConfig,\n-                WebSocketConstants.ANNOTATION_ATTR_IDLE_TIMEOUT, 0);\n-        if (idleTimeoutInSeconds > 0) {\n-            clientConnectorConfig.setIdleTimeoutInMillis((int) (idleTimeoutInSeconds * 1000));\n-        }\n-\n-        clientConnectorConfig.setMaxFrameSize(WebSocketUtil.findMaxFrameSize(clientEndpointConfig));\n-\n-        MapValue secureSocket = clientEndpointConfig.getMapValue(HttpConstants.ENDPOINT_CONFIG_SECURE_SOCKET);\n-        if (secureSocket != null) {\n-            HttpUtil.populateSSLConfiguration(clientConnectorConfig, secureSocket);\n-        } else if (scheme.equals(WebSocketConstants.WSS_SCHEME)) {\n-            clientConnectorConfig.useJavaDefaults();\n+        if (webSocketClient.getType().getName().equalsIgnoreCase(WebSocketConstants.WEBSOCKET_CLIENT)) {\n+            if (WebSocketUtil.hasRetryContext(webSocketClient)) {\n+                @SuppressWarnings(WebSocketConstants.UNCHECKED)\n+                MapValue<String, Object> retryConfig = (MapValue<String, Object>) clientEndpointConfig.getMapValue(\n+                        WebSocketConstants.RETRY_CONTEXT);\n+                RetryContext retryConnectorConfig = new RetryContext();\n+                populateRetryConnectorConfig(retryConfig, retryConnectorConfig);\n+                webSocketClient.addNativeData(WebSocketConstants.RETRY_CONTEXT, retryConnectorConfig);\n+                webSocketClient.addNativeData(WebSocketConstants.CLIENT_LISTENER, new RetryConnectorListener(\n+                        new ClientConnectorListener()));", "originalCommit": "37544470b0fdd1aca5315a64b5f32301e19817de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg0NzY1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397847653", "bodyText": "I have created the retryClient as per the offline discussion.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-25T13:22:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzcxODg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczMzc3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397733776", "bodyText": "This also we can move to respective Endpoints and pass it along inside WebSocketClient native data right.", "author": "shafreenAnfar", "createdAt": "2020-03-25T10:02:20Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/WebSocketUtil.java", "diffHunk": "@@ -224,54 +246,160 @@ private static ErrorValue createErrorCause(String message, String reason, BPacka\n     }\n \n     /**\n-     * Establish connection with the endpoint.\n+     * Reconnect when the WebSocket connection is lost.\n+     *\n+     * @param webSocketClient - webSocket client\n+     * @param wsService - webSocket service\n+     * @return If attempts reconnection, then return true\n+     */\n+    public static boolean reconnect(ObjectValue webSocketClient, WebSocketService wsService) {\n+        RetryContext retryConnectorConfig = (RetryContext) webSocketClient.getNativeData(WebSocketConstants.\n+                RETRY_CONTEXT);\n+        int maxAttempts = retryConnectorConfig.getMaxAttempts();\n+        int noOfReconnectAttempts = retryConnectorConfig.getReconnectAttempts();\n+        if (noOfReconnectAttempts < maxAttempts || maxAttempts == 0) {\n+            retryConnectorConfig.setReconnectAttempts(noOfReconnectAttempts + 1);\n+            if (logger.isDebugEnabled()) {\n+                Date date = new Date();\n+                SimpleDateFormat formatter = new SimpleDateFormat(\"dd-MM-yyyy HH:mm:ss\");\n+                String time = formatter.format(date.getTime());\n+                logger.debug(WebSocketConstants.LOG_MESSAGE, time, \"reconnecting...\");\n+            }\n+            createDelay(calculateWaitingTime(retryConnectorConfig.getInterval(), retryConnectorConfig.getMaxInterval(),\n+                    retryConnectorConfig.getBackOfFactor(), noOfReconnectAttempts));\n+            establishWebSocketConnection((WebSocketClientConnector) webSocketClient.getNativeData(WebSocketConstants.\n+                    CLIENT_CONNECTOR), webSocketClient, wsService);\n+            return true;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(WebSocketConstants.LOG_MESSAGE, \"Maximum retry attempts but couldn't connect to the server: \",\n+                    webSocketClient.getStringValue(WebSocketConstants.CLIENT_URL_CONFIG));\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Failover when webSocket connection lost.\n      *\n-     * @param webSocketClient - the WebSocket client.\n-     * @param wsService - the WebSocket service.\n+     * @param webSocketClient - webSocket client\n+     * @param wsService - webSocket service\n+     * @return if attempts failover, return true\n      */\n-    public static void establishWebSocketConnection(ObjectValue webSocketClient, WebSocketService wsService) {\n-        WebSocketClientConnectorListener clientConnectorListener = (WebSocketClientConnectorListener) webSocketClient.\n-                getNativeData(WebSocketConstants.CLIENT_LISTENER);\n-        WebSocketClientConnector clientConnector = (WebSocketClientConnector) webSocketClient.\n-                getNativeData(WebSocketConstants.CLIENT_CONNECTOR);\n+    public static boolean failover(ObjectValue webSocketClient, WebSocketService wsService) {\n+        FailoverContext failoverContext = (FailoverContext) webSocketClient.\n+                getNativeData(WebSocketConstants.FAILOVER_CONTEXT);\n+        int currentIndex = failoverContext.getCurrentIndex();\n+        List targets = failoverContext.getTargetUrls();\n+        // Sets next url index\n+        currentIndex++;\n+        // Checks current url index equals to target size or not. if equal, set the currentIndex = 0\n+        if (currentIndex == targets.size()) {\n+            currentIndex = 0;\n+        }\n+        // Checks the current url index equals with previous connected url index or not\n+        // If it isn't equal, call the initialiseWebSocketConnection()\n+        // if it equals, return false\n+        if (currentIndex != failoverContext.getInitialIndex()) {\n+            failoverContext.setCurrentIndex(currentIndex);\n+            createDelay(failoverContext.getFailoverInterval());\n+            establishWebSocketConnection(createWebSocketClientConnector(targets.get(currentIndex).toString(),\n+                       webSocketClient), webSocketClient, wsService);\n+            return true;\n+        }\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(WebSocketConstants.LOG_MESSAGE, \"Couldn't connect to one of the server in the targets: \",\n+                    targets);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Establishes connection with the endpoint.\n+     *\n+     * @param clientConnector -  the webSocket client connector\n+     * @param webSocketClient - the WebSocket client\n+     * @param wsService - the WebSocket service\n+     */\n+    public static void establishWebSocketConnection(WebSocketClientConnector clientConnector,\n+                                                    ObjectValue webSocketClient, WebSocketService wsService) {\n         boolean readyOnConnect = webSocketClient.getMapValue(CLIENT_ENDPOINT_CONFIG).getBooleanValue(\n                 WebSocketConstants.CLIENT_READY_ON_CONNECT);\n         ClientHandshakeFuture handshakeFuture = clientConnector.connect();\n-        handshakeFuture.setWebSocketConnectorListener(clientConnectorListener);\n         CountDownLatch countDownLatch = new CountDownLatch(1);\n-        if (WebSocketUtil.hasRetryConfig(webSocketClient)) {\n-            handshakeFuture.setClientHandshakeListener(new WebSocketClientHandshakeListenerForRetry(webSocketClient,\n-                    wsService, clientConnectorListener, readyOnConnect, countDownLatch,\n-                    (RetryContext) webSocketClient.getNativeData(WebSocketConstants.RETRY_CONFIG)));\n+        setListenersToHandshakeFuture(handshakeFuture, webSocketClient, wsService, countDownLatch, readyOnConnect);\n+        // Sets the countDown latch for every handshake\n+        waitForHandshake(webSocketClient, countDownLatch, wsService);\n+    }\n+\n+    /**\n+     * Sets listeners to the handshake future.\n+     *\n+     * @param handshakeFuture - the handshake future\n+     * @param webSocketClient - the WebSocket client\n+     * @param wsService - the WebSocket service\n+     * @param countDownLatch - the countdown latch\n+     * @param readyOnConnect - the ready on connect\n+     */\n+    private static void setListenersToHandshakeFuture(ClientHandshakeFuture handshakeFuture,\n+                                                      ObjectValue webSocketClient, WebSocketService wsService,\n+                                                      CountDownLatch countDownLatch, boolean readyOnConnect) {\n+        ConnectorListener connectorListener = (ConnectorListener) webSocketClient.getNativeData(\n+                WebSocketConstants.CLIENT_LISTENER);\n+        handshakeFuture.setWebSocketConnectorListener(connectorListener);\n+        WebSocketHandshakeListener webSocketHandshakeListener = new WebSocketHandshakeListener(webSocketClient,", "originalCommit": "37544470b0fdd1aca5315a64b5f32301e19817de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyMjQ5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397822499", "bodyText": "Every handshake needs to set the coundownLatch as it handles the handshake's timeout. therefore we can't move this to respective Endpoints.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-25T12:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczMzc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMxMDkyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398310928", "bodyText": "Yeah, can't we create handshake listener's along with the count down listeners in the respective init endpoint classes ?", "author": "shafreenAnfar", "createdAt": "2020-03-26T04:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczMzc3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE5NDAxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399194016", "bodyText": "we can change the readyOnConnect value by calling the ready() and store the some connection properties into the webSocketClient and use it in the iteration connection.\nTherefore these values are also dynamic. So, we can't move this to respective Endpoints.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-27T11:17:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzczMzc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MDE3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397950176", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # that message will be lost\n          \n          \n            \n                # that message will be lost.", "author": "praneesha", "createdAt": "2020-03-25T15:33:40Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_caller.bal", "diffHunk": "@@ -29,83 +29,86 @@ public type WebSocketCaller client object {\n         // package private function to prevent object creation\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n         public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MDQzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397950435", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # frame will be lost\n          \n          \n            \n                # frame will be lost.", "author": "praneesha", "createdAt": "2020-03-25T15:33:58Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_caller.bal", "diffHunk": "@@ -29,83 +29,86 @@ public type WebSocketCaller client object {\n         // package private function to prevent object creation\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n         public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MDcxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397950713", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n          \n          \n            \n                #                   until a close frame is received. If WebSocket frame is received from the remote endpoint", "author": "praneesha", "createdAt": "2020-03-25T15:34:18Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_caller.bal", "diffHunk": "@@ -29,83 +29,86 @@ public type WebSocketCaller client object {\n         // package private function to prevent object creation\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n         public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pong(byte[] data) returns WebSocketError? {\n         return self.conn.pong(data);\n     }\n \n-    # Close the connection.\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n     #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n     #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MDg4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397950887", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                #                   within waiting period the connection is terminated immediately\n          \n          \n            \n                #                   within waiting period, the connection is terminated immediately.", "author": "praneesha", "createdAt": "2020-03-25T15:34:30Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_caller.bal", "diffHunk": "@@ -29,83 +29,86 @@ public type WebSocketCaller client object {\n         // package private function to prevent object creation\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n         public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pong(byte[] data) returns WebSocketError? {\n         return self.conn.pong(data);\n     }\n \n-    # Close the connection.\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n     #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n     #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n-    #                   within waiting period the connection is terminated immediately.\n-    # + return - `error` if an error occurs when sending\n+    #                   within waiting period the connection is terminated immediately", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MTA2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397951069", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # + key - The key that identifies the attribute\n          \n          \n            \n                # + key - The key, which identifies the attribute", "author": "praneesha", "createdAt": "2020-03-25T15:34:42Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_caller.bal", "diffHunk": "@@ -29,83 +29,86 @@ public type WebSocketCaller client object {\n         // package private function to prevent object creation\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n         public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pong(byte[] data) returns WebSocketError? {\n         return self.conn.pong(data);\n     }\n \n-    # Close the connection.\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n     #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n     #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n-    #                   within waiting period the connection is terminated immediately.\n-    # + return - `error` if an error occurs when sending\n+    #                   within waiting period the connection is terminated immediately\n+    # + return - An `error` if an error occurs when sending\n     public remote function close(public int? statusCode = 1000, public string? reason = (),\n         public int timeoutInSeconds = 60) returns WebSocketError? {\n         return self.conn.close(statusCode, reason, timeoutInSeconds);\n     }\n \n     # Sets a connection related attribute.\n     #\n-    # + key - key that identifies the attribute\n-    # + value - value of the attribute\n+    # + key - The key that identifies the attribute", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MTM0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397951344", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # + return - The unique id associated with the connection\n          \n          \n            \n                # + return - The unique ID associated with the connection", "author": "praneesha", "createdAt": "2020-03-25T15:35:02Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_caller.bal", "diffHunk": "@@ -29,83 +29,86 @@ public type WebSocketCaller client object {\n         // package private function to prevent object creation\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n         public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pong(byte[] data) returns WebSocketError? {\n         return self.conn.pong(data);\n     }\n \n-    # Close the connection.\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n     #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n     #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n-    #                   within waiting period the connection is terminated immediately.\n-    # + return - `error` if an error occurs when sending\n+    #                   within waiting period the connection is terminated immediately\n+    # + return - An `error` if an error occurs when sending\n     public remote function close(public int? statusCode = 1000, public string? reason = (),\n         public int timeoutInSeconds = 60) returns WebSocketError? {\n         return self.conn.close(statusCode, reason, timeoutInSeconds);\n     }\n \n     # Sets a connection related attribute.\n     #\n-    # + key - key that identifies the attribute\n-    # + value - value of the attribute\n+    # + key - The key that identifies the attribute\n+    # + value - The value of the attribute\n     public function setAttribute(string key, any value) {\n         self.attributes[key] = value;\n     }\n \n     # Gets connection related attribute if any.\n     #\n-    # + key - the key to identify the attribute.\n-    # + return - the attribute related to the given key or `nil`\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n     public function getAttribute(string key) returns any {\n         return self.attributes[key];\n     }\n \n     # Removes connection related attribute if any.\n     #\n-    # + key - the key to identify the attribute.\n-    # + return - the attribute related to the given key or `nil`\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n     public function removeAttribute(string key) returns any {\n         return self.attributes.remove(key);\n     }\n \n     # Gives the connection id associated with this connection.\n     #\n-    # + return - the unique id associated with the connection\n+    # + return - The unique id associated with the connection", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MTc3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397951779", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # frame will be lost\n          \n          \n            \n                # frame will be lost.", "author": "praneesha", "createdAt": "2020-03-25T15:35:36Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_client.bal", "diffHunk": "@@ -43,93 +41,102 @@ public type WebSocketClient client object {\n \n     # Initializes the endpoint.\n     public function initEndpoint() {\n-        return externWSInitEndpoint(self);\n+        var retryConfig = self.config?.retryConfig;\n+        if (retryConfig is WebSocketRetryConfig) {\n+            return externRetryInitEndpoint(self);\n+        } else {\n+            return externWSInitEndpoint(self);\n+        }\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n     public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n-    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns error? {\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MjE2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397952169", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                #                   endpoint within the waiting period, the connection is terminated immediately\n          \n          \n            \n                #                   endpoint within the waiting period, the connection is terminated immediately.", "author": "praneesha", "createdAt": "2020-03-25T15:36:05Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_client.bal", "diffHunk": "@@ -43,93 +41,102 @@ public type WebSocketClient client object {\n \n     # Initializes the endpoint.\n     public function initEndpoint() {\n-        return externWSInitEndpoint(self);\n+        var retryConfig = self.config?.retryConfig;\n+        if (retryConfig is WebSocketRetryConfig) {\n+            return externRetryInitEndpoint(self);\n+        } else {\n+            return externWSInitEndpoint(self);\n+        }\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n     public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n-    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns error? {\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pong(byte[] data) returns WebSocketError? {\n         return self.conn.pong(data);\n     }\n \n-    # Close the connection.\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n-    #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n-    #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n-    #                   within waiting period the connection is terminated immediately.\n-    # + return - `error` if an error occurs when sending\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MjczOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397952739", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # + return - An `error` if an error occurs while closing the webSocket connection\n          \n          \n            \n                # + return - An `error` if an error occurs while closing the WebSocket connection", "author": "praneesha", "createdAt": "2020-03-25T15:36:50Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_client.bal", "diffHunk": "@@ -43,93 +41,102 @@ public type WebSocketClient client object {\n \n     # Initializes the endpoint.\n     public function initEndpoint() {\n-        return externWSInitEndpoint(self);\n+        var retryConfig = self.config?.retryConfig;\n+        if (retryConfig is WebSocketRetryConfig) {\n+            return externRetryInitEndpoint(self);\n+        } else {\n+            return externWSInitEndpoint(self);\n+        }\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n     public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n-    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns error? {\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pong(byte[] data) returns WebSocketError? {\n         return self.conn.pong(data);\n     }\n \n-    # Close the connection.\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n-    #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n-    #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n-    #                   within waiting period the connection is terminated immediately.\n-    # + return - `error` if an error occurs when sending\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately\n+    # + return - An `error` if an error occurs while closing the webSocket connection", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MzQ0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397953447", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # that message will be lost\n          \n          \n            \n                # that message will be lost.", "author": "praneesha", "createdAt": "2020-03-25T15:37:46Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_client.bal", "diffHunk": "@@ -43,93 +41,102 @@ public type WebSocketClient client object {\n \n     # Initializes the endpoint.\n     public function initEndpoint() {\n-        return externWSInitEndpoint(self);\n+        var retryConfig = self.config?.retryConfig;\n+        if (retryConfig is WebSocketRetryConfig) {\n+            return externRetryInitEndpoint(self);\n+        } else {\n+            return externWSInitEndpoint(self);\n+        }\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n     public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1Mzc3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397953772", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # + key - The key that identifies the attribute\n          \n          \n            \n                # + key - The key, which identifies the attribute", "author": "praneesha", "createdAt": "2020-03-25T15:38:10Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_client.bal", "diffHunk": "@@ -43,93 +41,102 @@ public type WebSocketClient client object {\n \n     # Initializes the endpoint.\n     public function initEndpoint() {\n-        return externWSInitEndpoint(self);\n+        var retryConfig = self.config?.retryConfig;\n+        if (retryConfig is WebSocketRetryConfig) {\n+            return externRetryInitEndpoint(self);\n+        } else {\n+            return externWSInitEndpoint(self);\n+        }\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n     public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n-    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns error? {\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pong(byte[] data) returns WebSocketError? {\n         return self.conn.pong(data);\n     }\n \n-    # Close the connection.\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n-    #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n-    #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n-    #                   within waiting period the connection is terminated immediately.\n-    # + return - `error` if an error occurs when sending\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately\n+    # + return - An `error` if an error occurs while closing the webSocket connection\n     public remote function close(public int? statusCode = 1000, public string? reason = (),\n         public int timeoutInSeconds = 60) returns WebSocketError? {\n         return self.conn.close(statusCode, reason, timeoutInSeconds);\n     }\n \n-    # Called when the client is ready to receive messages. Can be called only once.\n+    # Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the\n+    # WebSocketListener, it can be called only in the `upgrade` or `onOpen` resources.\n     #\n-    # + return - `error` if an error occurs when sending\n+    # + return - an `error` if an error occurs while checking the connection state\n     public remote function ready() returns WebSocketError? {\n-        return externWSReady(self);\n+        return self.conn.ready();\n     }\n \n-    # Sets a connection related attribute.\n+    # Sets a connection-related attribute.\n     #\n-    # + key - key that identifies the attribute\n-    # + value - value of the attribute\n+    # + key - The key that identifies the attribute", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1MzkzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397953930", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # Gets connection related attribute if any.\n          \n          \n            \n                # Gets connection-related attributes if any.", "author": "praneesha", "createdAt": "2020-03-25T15:38:23Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_client.bal", "diffHunk": "@@ -43,93 +41,102 @@ public type WebSocketClient client object {\n \n     # Initializes the endpoint.\n     public function initEndpoint() {\n-        return externWSInitEndpoint(self);\n+        var retryConfig = self.config?.retryConfig;\n+        if (retryConfig is WebSocketRetryConfig) {\n+            return externRetryInitEndpoint(self);\n+        } else {\n+            return externWSInitEndpoint(self);\n+        }\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n     public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n-    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns error? {\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pong(byte[] data) returns WebSocketError? {\n         return self.conn.pong(data);\n     }\n \n-    # Close the connection.\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n-    #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n-    #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n-    #                   within waiting period the connection is terminated immediately.\n-    # + return - `error` if an error occurs when sending\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately\n+    # + return - An `error` if an error occurs while closing the webSocket connection\n     public remote function close(public int? statusCode = 1000, public string? reason = (),\n         public int timeoutInSeconds = 60) returns WebSocketError? {\n         return self.conn.close(statusCode, reason, timeoutInSeconds);\n     }\n \n-    # Called when the client is ready to receive messages. Can be called only once.\n+    # Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the\n+    # WebSocketListener, it can be called only in the `upgrade` or `onOpen` resources.\n     #\n-    # + return - `error` if an error occurs when sending\n+    # + return - an `error` if an error occurs while checking the connection state\n     public remote function ready() returns WebSocketError? {\n-        return externWSReady(self);\n+        return self.conn.ready();\n     }\n \n-    # Sets a connection related attribute.\n+    # Sets a connection-related attribute.\n     #\n-    # + key - key that identifies the attribute\n-    # + value - value of the attribute\n+    # + key - The key that identifies the attribute\n+    # + value - The value of the attribute\n     public function setAttribute(string key, any value) {\n         self.attributes[key] = value;\n     }\n \n     # Gets connection related attribute if any.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NDE4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397954182", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # + return - The unique id associated with the connection\n          \n          \n            \n                # + return - The unique ID associated with the connection", "author": "praneesha", "createdAt": "2020-03-25T15:38:38Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_client.bal", "diffHunk": "@@ -43,93 +41,102 @@ public type WebSocketClient client object {\n \n     # Initializes the endpoint.\n     public function initEndpoint() {\n-        return externWSInitEndpoint(self);\n+        var retryConfig = self.config?.retryConfig;\n+        if (retryConfig is WebSocketRetryConfig) {\n+            return externRetryInitEndpoint(self);\n+        } else {\n+            return externWSInitEndpoint(self);\n+        }\n     }\n \n-    # Push text to the connection.\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n     #\n-    # + data - Data to be sent, if byte[] it is converted to a UTF-8 string for sending\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return  - `error` if an error occurs when sending\n-    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data, \n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n     public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushText(data, finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n-    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns error? {\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n         return self.conn.pushBinary(data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the server, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public remote function ping(byte[] data) returns WebSocketError? {\n         return self.conn.ping(data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public remote function pong(byte[] data) returns WebSocketError? {\n         return self.conn.pong(data);\n     }\n \n-    # Close the connection.\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n-    #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n-    #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n-    #                   within waiting period the connection is terminated immediately.\n-    # + return - `error` if an error occurs when sending\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately\n+    # + return - An `error` if an error occurs while closing the webSocket connection\n     public remote function close(public int? statusCode = 1000, public string? reason = (),\n         public int timeoutInSeconds = 60) returns WebSocketError? {\n         return self.conn.close(statusCode, reason, timeoutInSeconds);\n     }\n \n-    # Called when the client is ready to receive messages. Can be called only once.\n+    # Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the\n+    # WebSocketListener, it can be called only in the `upgrade` or `onOpen` resources.\n     #\n-    # + return - `error` if an error occurs when sending\n+    # + return - an `error` if an error occurs while checking the connection state\n     public remote function ready() returns WebSocketError? {\n-        return externWSReady(self);\n+        return self.conn.ready();\n     }\n \n-    # Sets a connection related attribute.\n+    # Sets a connection-related attribute.\n     #\n-    # + key - key that identifies the attribute\n-    # + value - value of the attribute\n+    # + key - The key that identifies the attribute\n+    # + value - The value of the attribute\n     public function setAttribute(string key, any value) {\n         self.attributes[key] = value;\n     }\n \n     # Gets connection related attribute if any.\n     #\n-    # + key - the key to identify the attribute.\n-    # + return - the attribute related to the given key or `nil`\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n     public function getAttribute(string key) returns any {\n         return self.attributes[key];\n     }\n \n     # Removes connection related attribute if any.\n     #\n-    # + key - the key to identify the attribute.\n-    # + return - the attribute related to the given key or `nil`\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n     public function removeAttribute(string key) returns any {\n         return self.attributes.remove(key);\n     }\n \n     # Gives the connection id associated with this connection.\n     #\n-    # + return - the unique id associated with the connection\n+    # + return - The unique id associated with the connection", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NDM5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397954397", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # + return - The HTTP response received for the client handshake request\n          \n          \n            \n                # + return - The HTTP response received from the client handshake request", "author": "praneesha", "createdAt": "2020-03-25T15:38:53Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_client.bal", "diffHunk": "@@ -157,32 +164,32 @@ public type WebSocketClient client object {\n \n     # Gives the HTTP response if any received for the client handshake request.\n     #\n-    # + return - the HTTP response received for the client handshake request\n+    # + return - The HTTP response received for the client handshake request", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NTEyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397955127", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            #                               an error.If the value < 0, then the value sets to the default value(300)\n          \n          \n            \n            #                               an error.If the value < 0, then the value sets to the default value(300).", "author": "praneesha", "createdAt": "2020-03-25T15:39:46Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_client.bal", "diffHunk": "@@ -157,32 +164,32 @@ public type WebSocketClient client object {\n \n     # Gives the HTTP response if any received for the client handshake request.\n     #\n-    # + return - the HTTP response received for the client handshake request\n+    # + return - The HTTP response received for the client handshake request\n     public function getHttpResponse() returns Response? {\n         return self.response;\n     }\n     \n };\n \n-# Configuration for the WebSocket client endpoint.\n+# Configurations for the WebSocket client endpoint.\n #\n-# + callbackService - The callback service for the client. Resources in this service gets called on receipt of messages\n-#                     from the server.\n-# + subProtocols - Negotiable sub protocols for the client\n-# + customHeaders - Custom headers which should be sent to the server\n-# + idleTimeoutInSeconds - Idle timeout of the client. Upon timeout, `onIdleTimeout` resource (if defined) in the client\n-#                          service will be triggered.\n-# + readyOnConnect - `true` if the client is ready to receive messages as soon as the connection is established.\n-#                    This is true by default. If changed to false the function ready() of the\n-#                    `WebSocketClient`needs to be called once to start receiving messages.\n-# + secureSocket - SSL/TLS related options\n-# + maxFrameSize - The maximum payload size of a WebSocket frame in bytes.\n+# + callbackService - The callback service of the client. Resources in this service gets called on the\n+#                     receipt of messages from the server\n+# + subProtocols - Negotiable sub protocols of the client\n+# + customHeaders - Custom headers, which should be sent to the server\n+# + idleTimeoutInSeconds - Idle timeout of the client. Upon timeout, the `onIdleTimeout` resource (if defined)\n+#                          of the client service will be triggered\n+# + readyOnConnect - Set to `true` if the client is ready to receive messages as soon as the connection is established.\n+#                    This is set to `true` by default. If changed to `false`, the ready() function of the\n+#                    `WebSocketClient` needs to be called once to start receiving messages\n+# + secureSocket - SSL/TLS-related options\n+# + maxFrameSize - The maximum payload size of a WebSocket frame in bytes\n #                  If this is not set, is negative, or is zero, the default frame size of 65536 will be used.\n-# + webSocketCompressionEnabled - Enable support for compression in the WebSocket.\n+# + webSocketCompressionEnabled - Enable support for compression in the WebSocket\n # + handShakeTimeoutInSeconds - Time (in seconds) that a connection waits to get the response of\n #                               the webSocket handshake. If the timeout exceeds, then the connection is terminated with\n-#                               an error.If the value < 0, then the value sets to the default value(300).\n-# + retryConfig - Retry related configurations.\n+#                               an error.If the value < 0, then the value sets to the default value(300)", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NTQ5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397955494", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # that message will be lost\n          \n          \n            \n                # that message will be lost.", "author": "praneesha", "createdAt": "2020-03-25T15:40:13Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_connector.bal", "diffHunk": "@@ -43,41 +45,51 @@ type WebSocketConnector object {\n         return externPushText(self, java:fromString(text), finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NTY2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397955663", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # frame will be lost\n          \n          \n            \n                # frame will be lost.", "author": "praneesha", "createdAt": "2020-03-25T15:40:26Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_connector.bal", "diffHunk": "@@ -43,41 +45,51 @@ type WebSocketConnector object {\n         return externPushText(self, java:fromString(text), finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public function pushBinary(byte[] data, boolean finalFrame) returns WebSocketError? {\n         return externPushBinary(self, data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public function ping(byte[] data) returns WebSocketError? {\n         return externPing(self, data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NjQ2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397956466", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # Initializes failover client, which provides failover capabilities to a WebSocket client endpoint.\n          \n          \n            \n                # Initializes the failover client, which provides failover capabilities to a WebSocket client endpoint.", "author": "praneesha", "createdAt": "2020-03-25T15:41:23Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_failover_client.bal", "diffHunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/java;\n+\n+# A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.\n+public type WebSocketFailoverClient client object {\n+\n+    private string id = \"\";\n+    private string? negotiatedSubProtocol = ();\n+    private boolean secure = false;\n+    private boolean open = false;\n+    private Response? response = ();\n+    private map<any> attributes = {};\n+    private string url = \"\";\n+\n+    private WebSocketConnector conn = new;\n+    private WebSocketFailoverClientConfiguration config = {};\n+\n+    # Initializes failover client, which provides failover capabilities to a WebSocket client endpoint.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NjczMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397956731", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # that message will be lost\n          \n          \n            \n                # that message will be lost.", "author": "praneesha", "createdAt": "2020-03-25T15:41:44Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_failover_client.bal", "diffHunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/java;\n+\n+# A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.\n+public type WebSocketFailoverClient client object {\n+\n+    private string id = \"\";\n+    private string? negotiatedSubProtocol = ();\n+    private boolean secure = false;\n+    private boolean open = false;\n+    private Response? response = ();\n+    private map<any> attributes = {};\n+    private string url = \"\";\n+\n+    private WebSocketConnector conn = new;\n+    private WebSocketFailoverClientConfiguration config = {};\n+\n+    # Initializes failover client, which provides failover capabilities to a WebSocket client endpoint.\n+    #\n+    # + config - The `WebSocketFailoverClientConfiguration` of the endpoint\n+    public function __init(public WebSocketFailoverClientConfiguration config) {\n+        self.url = config.targetUrls[0];\n+        self.config = config;\n+        self.init();\n+    }\n+\n+    public function init() {\n+        return externFailoverInit(self);\n+    }\n+\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n+    #\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n+    public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushText(data, finalFrame);\n+    }\n+\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1Njg2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397956865", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # frame will be lost\n          \n          \n            \n                # frame will be lost.", "author": "praneesha", "createdAt": "2020-03-25T15:41:55Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_failover_client.bal", "diffHunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/java;\n+\n+# A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.\n+public type WebSocketFailoverClient client object {\n+\n+    private string id = \"\";\n+    private string? negotiatedSubProtocol = ();\n+    private boolean secure = false;\n+    private boolean open = false;\n+    private Response? response = ();\n+    private map<any> attributes = {};\n+    private string url = \"\";\n+\n+    private WebSocketConnector conn = new;\n+    private WebSocketFailoverClientConfiguration config = {};\n+\n+    # Initializes failover client, which provides failover capabilities to a WebSocket client endpoint.\n+    #\n+    # + config - The `WebSocketFailoverClientConfiguration` of the endpoint\n+    public function __init(public WebSocketFailoverClientConfiguration config) {\n+        self.url = config.targetUrls[0];\n+        self.config = config;\n+        self.init();\n+    }\n+\n+    public function init() {\n+        return externFailoverInit(self);\n+    }\n+\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n+    #\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n+    public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushText(data, finalFrame);\n+    }\n+\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushBinary(data, finalFrame);\n+    }\n+\n+    # Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function ping(byte[] data) returns WebSocketError? {\n+        return self.conn.ping(data);\n+    }\n+\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NzUxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397957516", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n          \n          \n            \n                #                   until a close frame is received. If WebSocket frame is received from the remote endpoint", "author": "praneesha", "createdAt": "2020-03-25T15:42:45Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_connector.bal", "diffHunk": "@@ -43,41 +45,51 @@ type WebSocketConnector object {\n         return externPushText(self, java:fromString(text), finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public function pushBinary(byte[] data, boolean finalFrame) returns WebSocketError? {\n         return externPushBinary(self, data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public function ping(byte[] data) returns WebSocketError? {\n         return externPing(self, data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public function pong(byte[] data) returns WebSocketError? {\n         return externPong(self, data);\n     }\n \n-    # Close the connection.\n+    # Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. The\n+    # WebSocketListener can be called only in the `upgrade` or `onOpen` resources.\n+    #\n+    # + return - An `error` if an error occurs when sending\n+    public function ready() returns WebSocketError? {\n+        return externReady(self);\n+    }\n+\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSecs - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n     #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n     #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NzcwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397957704", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                #                   within waiting period the connection is terminated immediately\n          \n          \n            \n                #                   within the waiting period, the connection is terminated immediately.", "author": "praneesha", "createdAt": "2020-03-25T15:42:56Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_connector.bal", "diffHunk": "@@ -43,41 +45,51 @@ type WebSocketConnector object {\n         return externPushText(self, java:fromString(text), finalFrame);\n     }\n \n-    # Push binary data to the connection.\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n     #\n     # + data - Binary data to be sent\n     # + finalFrame - Set to `true` if this is a final frame of a (long) message\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public function pushBinary(byte[] data, boolean finalFrame) returns WebSocketError? {\n         return externPushBinary(self, data, finalFrame);\n     }\n \n-    # Ping the connection.\n+    # Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.\n     #\n-    # + data - Binary data to be sent.\n-    # + return - `error` if an error occurs when sending\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n     public function ping(byte[] data) returns WebSocketError? {\n         return externPing(self, data);\n     }\n \n-    # Send pong message to the connection.\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n     #\n     # + data - Binary data to be sent\n-    # + return - `error` if an error occurs when sending\n+    # + return  - An `error` if an error occurs when sending\n     public function pong(byte[] data) returns WebSocketError? {\n         return externPong(self, data);\n     }\n \n-    # Close the connection.\n+    # Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. The\n+    # WebSocketListener can be called only in the `upgrade` or `onOpen` resources.\n+    #\n+    # + return - An `error` if an error occurs when sending\n+    public function ready() returns WebSocketError? {\n+        return externReady(self);\n+    }\n+\n+    # Closes the connection.\n     #\n     # + statusCode - Status code for closing the connection\n     # + reason - Reason for closing the connection\n     # + timeoutInSecs - Time to wait for the close frame to be received from the remote endpoint before closing the\n     #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n     #                   is not received from the remote endpoint. If the value < 0 (e.g., -1), then the connection waits\n     #                   until a close frame is received. If WebSocket frame is received from the remote endpoint,\n-    #                   within waiting period the connection is terminated immediately.\n-    # + return - `error` if an error occurs when sending\n+    #                   within waiting period the connection is terminated immediately", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1NzkwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397957906", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                #                   endpoint within the waiting period, the connection is terminated immediately\n          \n          \n            \n                #                   endpoint within the waiting period, the connection is terminated immediately.", "author": "praneesha", "createdAt": "2020-03-25T15:43:12Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_failover_client.bal", "diffHunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/java;\n+\n+# A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.\n+public type WebSocketFailoverClient client object {\n+\n+    private string id = \"\";\n+    private string? negotiatedSubProtocol = ();\n+    private boolean secure = false;\n+    private boolean open = false;\n+    private Response? response = ();\n+    private map<any> attributes = {};\n+    private string url = \"\";\n+\n+    private WebSocketConnector conn = new;\n+    private WebSocketFailoverClientConfiguration config = {};\n+\n+    # Initializes failover client, which provides failover capabilities to a WebSocket client endpoint.\n+    #\n+    # + config - The `WebSocketFailoverClientConfiguration` of the endpoint\n+    public function __init(public WebSocketFailoverClientConfiguration config) {\n+        self.url = config.targetUrls[0];\n+        self.config = config;\n+        self.init();\n+    }\n+\n+    public function init() {\n+        return externFailoverInit(self);\n+    }\n+\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n+    #\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n+    public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushText(data, finalFrame);\n+    }\n+\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushBinary(data, finalFrame);\n+    }\n+\n+    # Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function ping(byte[] data) returns WebSocketError? {\n+        return self.conn.ping(data);\n+    }\n+\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pong(byte[] data) returns WebSocketError? {\n+        return self.conn.pong(data);\n+    }\n+\n+    # Closes the connection.\n+    #\n+    # + statusCode - Status code for closing the connection\n+    # + reason - Reason for closing the connection\n+    # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n+    #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1ODUxMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397958512", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                # Gives any HTTP response for the client handshake request if received.\n          \n          \n            \n                # Gives any HTTP response of the client handshake request if received.", "author": "praneesha", "createdAt": "2020-03-25T15:43:57Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_failover_client.bal", "diffHunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/java;\n+\n+# A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.\n+public type WebSocketFailoverClient client object {\n+\n+    private string id = \"\";\n+    private string? negotiatedSubProtocol = ();\n+    private boolean secure = false;\n+    private boolean open = false;\n+    private Response? response = ();\n+    private map<any> attributes = {};\n+    private string url = \"\";\n+\n+    private WebSocketConnector conn = new;\n+    private WebSocketFailoverClientConfiguration config = {};\n+\n+    # Initializes failover client, which provides failover capabilities to a WebSocket client endpoint.\n+    #\n+    # + config - The `WebSocketFailoverClientConfiguration` of the endpoint\n+    public function __init(public WebSocketFailoverClientConfiguration config) {\n+        self.url = config.targetUrls[0];\n+        self.config = config;\n+        self.init();\n+    }\n+\n+    public function init() {\n+        return externFailoverInit(self);\n+    }\n+\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n+    #\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n+    public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushText(data, finalFrame);\n+    }\n+\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushBinary(data, finalFrame);\n+    }\n+\n+    # Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function ping(byte[] data) returns WebSocketError? {\n+        return self.conn.ping(data);\n+    }\n+\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pong(byte[] data) returns WebSocketError? {\n+        return self.conn.pong(data);\n+    }\n+\n+    # Closes the connection.\n+    #\n+    # + statusCode - Status code for closing the connection\n+    # + reason - Reason for closing the connection\n+    # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n+    #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately\n+    # + return - An `error` if an error occurs while closing the webSocket connection\n+    public remote function close(public int? statusCode = 1000, public string? reason = (),\n+    public int timeoutInSeconds = 60) returns WebSocketError? {\n+        return self.conn.close(statusCode, reason, timeoutInSeconds);\n+    }\n+\n+    # Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the\n+    # WebSocketListener, it can be called only in the `upgrade` or `onOpen` resources.\n+    #\n+    # + return - An `error` if an error occurs while checking the connection state\n+    public remote function ready() returns WebSocketError? {\n+        return self.conn.ready();\n+    }\n+\n+    # Sets a connection-related attribute.\n+    #\n+    # + key - The key to identify the attribute\n+    # + value - The value of the attribute\n+    public function setAttribute(string key, any value) {\n+        self.attributes[key] = value;\n+    }\n+\n+    # Gets connection-related attributes if any.\n+    #\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n+    public function getAttribute(string key) returns any {\n+        return self.attributes[key];\n+    }\n+\n+    # Removes connection-related attributes if any.\n+    #\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n+    public function removeAttribute(string key) returns any {\n+        return self.attributes.remove(key);\n+    }\n+\n+    # Gives the connection ID associated with this connection.\n+    #\n+    # + return - The unique ID associated with the connection\n+    public function getConnectionId() returns string {\n+        return self.id;\n+    }\n+\n+    # Gives the subprotocol if any that is negotiated with the client.\n+    #\n+    # + return - Returns the subprotocol if any that is negotiated with the client or `nil`\n+    public function getNegotiatedSubProtocol() returns string? {\n+        return self.negotiatedSubProtocol;\n+    }\n+\n+    # Gives the secured status of the connection.\n+    #\n+    # + return - Returns `true` if the connection is secure\n+    public function isSecure() returns boolean {\n+        return self.secure;\n+    }\n+\n+    # Gives the open or closed status of the connection.\n+    #\n+    # + return - Returns `true` if the connection is open\n+    public function isOpen() returns boolean {\n+        return self.open;\n+    }\n+\n+    # Gives any HTTP response for the client handshake request if received.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1ODgxMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397958813", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + callbackService - The callback service for the client. Resources in this service gets called on the\n          \n          \n            \n            # + callbackService - The callback service of the client. Resources in this service gets called on the", "author": "praneesha", "createdAt": "2020-03-25T15:44:19Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_failover_client.bal", "diffHunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/java;\n+\n+# A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.\n+public type WebSocketFailoverClient client object {\n+\n+    private string id = \"\";\n+    private string? negotiatedSubProtocol = ();\n+    private boolean secure = false;\n+    private boolean open = false;\n+    private Response? response = ();\n+    private map<any> attributes = {};\n+    private string url = \"\";\n+\n+    private WebSocketConnector conn = new;\n+    private WebSocketFailoverClientConfiguration config = {};\n+\n+    # Initializes failover client, which provides failover capabilities to a WebSocket client endpoint.\n+    #\n+    # + config - The `WebSocketFailoverClientConfiguration` of the endpoint\n+    public function __init(public WebSocketFailoverClientConfiguration config) {\n+        self.url = config.targetUrls[0];\n+        self.config = config;\n+        self.init();\n+    }\n+\n+    public function init() {\n+        return externFailoverInit(self);\n+    }\n+\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n+    #\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n+    public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushText(data, finalFrame);\n+    }\n+\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushBinary(data, finalFrame);\n+    }\n+\n+    # Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function ping(byte[] data) returns WebSocketError? {\n+        return self.conn.ping(data);\n+    }\n+\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pong(byte[] data) returns WebSocketError? {\n+        return self.conn.pong(data);\n+    }\n+\n+    # Closes the connection.\n+    #\n+    # + statusCode - Status code for closing the connection\n+    # + reason - Reason for closing the connection\n+    # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n+    #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately\n+    # + return - An `error` if an error occurs while closing the webSocket connection\n+    public remote function close(public int? statusCode = 1000, public string? reason = (),\n+    public int timeoutInSeconds = 60) returns WebSocketError? {\n+        return self.conn.close(statusCode, reason, timeoutInSeconds);\n+    }\n+\n+    # Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the\n+    # WebSocketListener, it can be called only in the `upgrade` or `onOpen` resources.\n+    #\n+    # + return - An `error` if an error occurs while checking the connection state\n+    public remote function ready() returns WebSocketError? {\n+        return self.conn.ready();\n+    }\n+\n+    # Sets a connection-related attribute.\n+    #\n+    # + key - The key to identify the attribute\n+    # + value - The value of the attribute\n+    public function setAttribute(string key, any value) {\n+        self.attributes[key] = value;\n+    }\n+\n+    # Gets connection-related attributes if any.\n+    #\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n+    public function getAttribute(string key) returns any {\n+        return self.attributes[key];\n+    }\n+\n+    # Removes connection-related attributes if any.\n+    #\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n+    public function removeAttribute(string key) returns any {\n+        return self.attributes.remove(key);\n+    }\n+\n+    # Gives the connection ID associated with this connection.\n+    #\n+    # + return - The unique ID associated with the connection\n+    public function getConnectionId() returns string {\n+        return self.id;\n+    }\n+\n+    # Gives the subprotocol if any that is negotiated with the client.\n+    #\n+    # + return - Returns the subprotocol if any that is negotiated with the client or `nil`\n+    public function getNegotiatedSubProtocol() returns string? {\n+        return self.negotiatedSubProtocol;\n+    }\n+\n+    # Gives the secured status of the connection.\n+    #\n+    # + return - Returns `true` if the connection is secure\n+    public function isSecure() returns boolean {\n+        return self.secure;\n+    }\n+\n+    # Gives the open or closed status of the connection.\n+    #\n+    # + return - Returns `true` if the connection is open\n+    public function isOpen() returns boolean {\n+        return self.open;\n+    }\n+\n+    # Gives any HTTP response for the client handshake request if received.\n+    #\n+    # + return - Returns the HTTP response received for the client handshake request\n+    public function getHttpResponse() returns Response? {\n+        return self.response;\n+    }\n+\n+};\n+\n+# Configurations for the WebSocket client endpoint.\n+#\n+# + callbackService - The callback service for the client. Resources in this service gets called on the", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1ODkyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397958928", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + subProtocols - Negotiable sub protocols for the client\n          \n          \n            \n            # + subProtocols - Negotiable sub protocols of the client", "author": "praneesha", "createdAt": "2020-03-25T15:44:29Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_failover_client.bal", "diffHunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/java;\n+\n+# A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.\n+public type WebSocketFailoverClient client object {\n+\n+    private string id = \"\";\n+    private string? negotiatedSubProtocol = ();\n+    private boolean secure = false;\n+    private boolean open = false;\n+    private Response? response = ();\n+    private map<any> attributes = {};\n+    private string url = \"\";\n+\n+    private WebSocketConnector conn = new;\n+    private WebSocketFailoverClientConfiguration config = {};\n+\n+    # Initializes failover client, which provides failover capabilities to a WebSocket client endpoint.\n+    #\n+    # + config - The `WebSocketFailoverClientConfiguration` of the endpoint\n+    public function __init(public WebSocketFailoverClientConfiguration config) {\n+        self.url = config.targetUrls[0];\n+        self.config = config;\n+        self.init();\n+    }\n+\n+    public function init() {\n+        return externFailoverInit(self);\n+    }\n+\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n+    #\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n+    public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushText(data, finalFrame);\n+    }\n+\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushBinary(data, finalFrame);\n+    }\n+\n+    # Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function ping(byte[] data) returns WebSocketError? {\n+        return self.conn.ping(data);\n+    }\n+\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pong(byte[] data) returns WebSocketError? {\n+        return self.conn.pong(data);\n+    }\n+\n+    # Closes the connection.\n+    #\n+    # + statusCode - Status code for closing the connection\n+    # + reason - Reason for closing the connection\n+    # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n+    #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately\n+    # + return - An `error` if an error occurs while closing the webSocket connection\n+    public remote function close(public int? statusCode = 1000, public string? reason = (),\n+    public int timeoutInSeconds = 60) returns WebSocketError? {\n+        return self.conn.close(statusCode, reason, timeoutInSeconds);\n+    }\n+\n+    # Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the\n+    # WebSocketListener, it can be called only in the `upgrade` or `onOpen` resources.\n+    #\n+    # + return - An `error` if an error occurs while checking the connection state\n+    public remote function ready() returns WebSocketError? {\n+        return self.conn.ready();\n+    }\n+\n+    # Sets a connection-related attribute.\n+    #\n+    # + key - The key to identify the attribute\n+    # + value - The value of the attribute\n+    public function setAttribute(string key, any value) {\n+        self.attributes[key] = value;\n+    }\n+\n+    # Gets connection-related attributes if any.\n+    #\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n+    public function getAttribute(string key) returns any {\n+        return self.attributes[key];\n+    }\n+\n+    # Removes connection-related attributes if any.\n+    #\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n+    public function removeAttribute(string key) returns any {\n+        return self.attributes.remove(key);\n+    }\n+\n+    # Gives the connection ID associated with this connection.\n+    #\n+    # + return - The unique ID associated with the connection\n+    public function getConnectionId() returns string {\n+        return self.id;\n+    }\n+\n+    # Gives the subprotocol if any that is negotiated with the client.\n+    #\n+    # + return - Returns the subprotocol if any that is negotiated with the client or `nil`\n+    public function getNegotiatedSubProtocol() returns string? {\n+        return self.negotiatedSubProtocol;\n+    }\n+\n+    # Gives the secured status of the connection.\n+    #\n+    # + return - Returns `true` if the connection is secure\n+    public function isSecure() returns boolean {\n+        return self.secure;\n+    }\n+\n+    # Gives the open or closed status of the connection.\n+    #\n+    # + return - Returns `true` if the connection is open\n+    public function isOpen() returns boolean {\n+        return self.open;\n+    }\n+\n+    # Gives any HTTP response for the client handshake request if received.\n+    #\n+    # + return - Returns the HTTP response received for the client handshake request\n+    public function getHttpResponse() returns Response? {\n+        return self.response;\n+    }\n+\n+};\n+\n+# Configurations for the WebSocket client endpoint.\n+#\n+# + callbackService - The callback service for the client. Resources in this service gets called on the\n+#                     receipt of messages from the server\n+# + subProtocols - Negotiable sub protocols for the client", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk1OTE3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397959178", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + readyOnConnect - Set to `true` if the client is ready to receive messages as soon as the connection is established.\n          \n          \n            \n            # + readyOnConnect - Set to `true` if the client is ready to receive messages as soon as the connection is established", "author": "praneesha", "createdAt": "2020-03-25T15:44:48Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_failover_client.bal", "diffHunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/java;\n+\n+# A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.\n+public type WebSocketFailoverClient client object {\n+\n+    private string id = \"\";\n+    private string? negotiatedSubProtocol = ();\n+    private boolean secure = false;\n+    private boolean open = false;\n+    private Response? response = ();\n+    private map<any> attributes = {};\n+    private string url = \"\";\n+\n+    private WebSocketConnector conn = new;\n+    private WebSocketFailoverClientConfiguration config = {};\n+\n+    # Initializes failover client, which provides failover capabilities to a WebSocket client endpoint.\n+    #\n+    # + config - The `WebSocketFailoverClientConfiguration` of the endpoint\n+    public function __init(public WebSocketFailoverClientConfiguration config) {\n+        self.url = config.targetUrls[0];\n+        self.config = config;\n+        self.init();\n+    }\n+\n+    public function init() {\n+        return externFailoverInit(self);\n+    }\n+\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n+    #\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n+    public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushText(data, finalFrame);\n+    }\n+\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushBinary(data, finalFrame);\n+    }\n+\n+    # Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function ping(byte[] data) returns WebSocketError? {\n+        return self.conn.ping(data);\n+    }\n+\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pong(byte[] data) returns WebSocketError? {\n+        return self.conn.pong(data);\n+    }\n+\n+    # Closes the connection.\n+    #\n+    # + statusCode - Status code for closing the connection\n+    # + reason - Reason for closing the connection\n+    # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n+    #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately\n+    # + return - An `error` if an error occurs while closing the webSocket connection\n+    public remote function close(public int? statusCode = 1000, public string? reason = (),\n+    public int timeoutInSeconds = 60) returns WebSocketError? {\n+        return self.conn.close(statusCode, reason, timeoutInSeconds);\n+    }\n+\n+    # Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the\n+    # WebSocketListener, it can be called only in the `upgrade` or `onOpen` resources.\n+    #\n+    # + return - An `error` if an error occurs while checking the connection state\n+    public remote function ready() returns WebSocketError? {\n+        return self.conn.ready();\n+    }\n+\n+    # Sets a connection-related attribute.\n+    #\n+    # + key - The key to identify the attribute\n+    # + value - The value of the attribute\n+    public function setAttribute(string key, any value) {\n+        self.attributes[key] = value;\n+    }\n+\n+    # Gets connection-related attributes if any.\n+    #\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n+    public function getAttribute(string key) returns any {\n+        return self.attributes[key];\n+    }\n+\n+    # Removes connection-related attributes if any.\n+    #\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n+    public function removeAttribute(string key) returns any {\n+        return self.attributes.remove(key);\n+    }\n+\n+    # Gives the connection ID associated with this connection.\n+    #\n+    # + return - The unique ID associated with the connection\n+    public function getConnectionId() returns string {\n+        return self.id;\n+    }\n+\n+    # Gives the subprotocol if any that is negotiated with the client.\n+    #\n+    # + return - Returns the subprotocol if any that is negotiated with the client or `nil`\n+    public function getNegotiatedSubProtocol() returns string? {\n+        return self.negotiatedSubProtocol;\n+    }\n+\n+    # Gives the secured status of the connection.\n+    #\n+    # + return - Returns `true` if the connection is secure\n+    public function isSecure() returns boolean {\n+        return self.secure;\n+    }\n+\n+    # Gives the open or closed status of the connection.\n+    #\n+    # + return - Returns `true` if the connection is open\n+    public function isOpen() returns boolean {\n+        return self.open;\n+    }\n+\n+    # Gives any HTTP response for the client handshake request if received.\n+    #\n+    # + return - Returns the HTTP response received for the client handshake request\n+    public function getHttpResponse() returns Response? {\n+        return self.response;\n+    }\n+\n+};\n+\n+# Configurations for the WebSocket client endpoint.\n+#\n+# + callbackService - The callback service for the client. Resources in this service gets called on the\n+#                     receipt of messages from the server\n+# + subProtocols - Negotiable sub protocols for the client\n+# + customHeaders - Custom headers, which should be sent to the server\n+# + idleTimeoutInSeconds - Idle timeout of the client. Upon timeout, the `onIdleTimeout` resource (if defined)\n+#                          of the client service will be triggered\n+# + readyOnConnect - Set to `true` if the client is ready to receive messages as soon as the connection is established.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2MDY2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397960660", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return validated target URLs array\n          \n          \n            \n                 * @return - validated target URLs array", "author": "praneesha", "createdAt": "2020-03-25T15:46:39Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/FailoverInitEndpoint.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client;\n+\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.MapValue;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketException;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.listener.ClientConnectorListener;\n+import org.ballerinalang.net.http.websocket.client.listener.FailoverConnectorListener;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Initializes the Failover WebSocket Client.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverInitEndpoint {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(FailoverInitEndpoint.class);\n+    private static final String FAILOVER_INTERVAL = \"failoverIntervalInMillis\";\n+\n+    public static void initEndpoint(ObjectValue failoverClient) {\n+        @SuppressWarnings(WebSocketConstants.UNCHECKED)\n+        MapValue<String, Object> clientEndpointConfig = (MapValue<String, Object>) failoverClient.getMapValue(\n+                WebSocketConstants.CLIENT_ENDPOINT_CONFIG);\n+        List<String> newTargetUrls = getValidUrls(clientEndpointConfig.getArrayValue(WebSocketConstants.TARGET_URLS));\n+        // Sets the failover config values.\n+        failoverClient.set(WebSocketConstants.CLIENT_URL_CONFIG, newTargetUrls.get(0));\n+        FailoverContext failoverContext = new FailoverContext();\n+        populateFailoverContext(clientEndpointConfig, failoverContext, newTargetUrls);\n+        failoverClient.addNativeData(WebSocketConstants.FAILOVER_CONTEXT, failoverContext);\n+        failoverClient.addNativeData(WebSocketConstants.CLIENT_LISTENER, new FailoverConnectorListener(\n+                new ClientConnectorListener()));\n+        InitEndpoint.initEndpoint(failoverClient);\n+    }\n+\n+    /**\n+     * Populates the failover config.\n+     *\n+     * @param failoverConfig - a failover config\n+     * @param failoverClientConnectorConfig - a failover client connector config\n+     * @param targetUrls - target URLs\n+     */\n+    private static void populateFailoverContext(MapValue<String, Object> failoverConfig,\n+                                                FailoverContext failoverClientConnectorConfig,\n+                                                List<String> targetUrls) {\n+        failoverClientConnectorConfig.setFailoverInterval(WebSocketUtil.getIntValue(failoverConfig, FAILOVER_INTERVAL,\n+                1000));\n+        failoverClientConnectorConfig.setTargetUrls(targetUrls);\n+    }\n+\n+    /**\n+     * Checks whether the URL has a valid format or not. If it isn't in the valid format, removes that from the URL set.\n+     *\n+     * @param targets - target URLs array\n+     * @return validated target URLs array", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2MDkzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397960933", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Sets the count Down latch for initial connection\n          \n          \n            \n                    // Sets the count down latch for the initial connection.", "author": "praneesha", "createdAt": "2020-03-25T15:46:58Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/InitEndpoint.java", "diffHunk": "@@ -47,152 +42,33 @@\n  */\n public class InitEndpoint {\n \n-    private static final Logger logger = LoggerFactory.getLogger(InitEndpoint.class);\n-    private static final String INTERVAL_IN_MILLIS = \"intervalInMillis\";\n-    private static final String MAX_WAIT_INTERVAL = \"maxWaitIntervalInMillis\";\n-    private static final String MAX_COUNT = \"maxCount\";\n-    private static final String BACK_OF_FACTOR = \"backOffFactor\";\n-\n     public static void initEndpoint(ObjectValue webSocketClient) {\n         @SuppressWarnings(WebSocketConstants.UNCHECKED)\n         MapValue<String, Object> clientEndpointConfig = (MapValue<String, Object>) webSocketClient.getMapValue(\n                 HttpConstants.CLIENT_ENDPOINT_CONFIG);\n         Strand strand = Scheduler.getStrand();\n         String remoteUrl = webSocketClient.getStringValue(WebSocketConstants.CLIENT_URL_CONFIG);\n-        WebSocketService wsService = validateAndCreateWebSocketService(clientEndpointConfig, strand);\n+        WebSocketService wsService = WebSocketUtil.validateAndCreateWebSocketService(strand, clientEndpointConfig);\n         HttpWsConnectorFactory connectorFactory = HttpUtil.createHttpWsConnectionFactory();\n         WebSocketClientConnectorConfig clientConnectorConfig = new WebSocketClientConnectorConfig(remoteUrl);\n         String scheme = URI.create(remoteUrl).getScheme();\n-        populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n-        // Create the client connector.\n+        WebSocketUtil.populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n+        // Creates the client connector\n         WebSocketClientConnector clientConnector = connectorFactory.createWsClientConnector(clientConnectorConfig);\n-        WebSocketClientConnectorListener clientConnectorListener = new WebSocketClientConnectorListener();\n-        // Add the client connector as a native data when the client is not a failover client\n-        // because when using one URL, there is no need to create the client connector again.\n+        webSocketClient.addNativeData(WebSocketConstants.CONNECTOR_FACTORY, connectorFactory);\n+        // Add the client connector as a native data\n+        // because there is no need to create the client connector again when using one URL\n         webSocketClient.addNativeData(WebSocketConstants.CLIENT_CONNECTOR, clientConnector);\n-        webSocketClient.addNativeData(WebSocketConstants.CLIENT_LISTENER, clientConnectorListener);\n-        if (WebSocketUtil.hasRetryConfig(webSocketClient)) {\n-            @SuppressWarnings(WebSocketConstants.UNCHECKED)\n-            MapValue<String, Object> retryConfig = (MapValue<String, Object>) clientEndpointConfig.getMapValue(\n-                    WebSocketConstants.RETRY_CONFIG);\n-            RetryContext retryConnectorConfig = new RetryContext();\n-            populateRetryConnectorConfig(retryConfig, retryConnectorConfig);\n-            webSocketClient.addNativeData(WebSocketConstants.RETRY_CONFIG, retryConnectorConfig);\n-            CountDownLatch countDownLatch = new CountDownLatch(1);\n-            webSocketClient.addNativeData(WebSocketConstants.COUNT_DOWN_LATCH, countDownLatch);\n-            WebSocketUtil.establishWebSocketConnection(webSocketClient, wsService);\n-            // Set the count Down latch for initial connection\n-            waitForHandshake(countDownLatch);\n-        } else {\n-            WebSocketUtil.establishWebSocketConnection(webSocketClient, wsService);\n-        }\n-\n-    }\n-\n-    private static void waitForHandshake(CountDownLatch countDownLatch) {\n-        try {\n-            // Wait to call countDown()\n-            countDownLatch.await();\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-            throw new WebSocketException(WebSocketConstants.ERROR_MESSAGE + e.getMessage());\n-        }\n-    }\n-\n-    private static void populateClientConnectorConfig(MapValue<String, Object> clientEndpointConfig,\n-                                                      WebSocketClientConnectorConfig clientConnectorConfig,\n-                                                      String scheme) {\n-        clientConnectorConfig.setAutoRead(false); // Frames are read sequentially in ballerina.\n-        clientConnectorConfig.setSubProtocols(WebSocketUtil.findNegotiableSubProtocols(clientEndpointConfig));\n-        @SuppressWarnings(WebSocketConstants.UNCHECKED)\n-        MapValue<String, Object> headerValues = (MapValue<String, Object>) clientEndpointConfig.getMapValue(\n-                WebSocketConstants.CLIENT_CUSTOM_HEADERS_CONFIG);\n-        if (headerValues != null) {\n-            clientConnectorConfig.addHeaders(getCustomHeaders(headerValues));\n-        }\n-\n-        long idleTimeoutInSeconds = WebSocketUtil.findTimeoutInSeconds(clientEndpointConfig,\n-                WebSocketConstants.ANNOTATION_ATTR_IDLE_TIMEOUT, 0);\n-        if (idleTimeoutInSeconds > 0) {\n-            clientConnectorConfig.setIdleTimeoutInMillis((int) (idleTimeoutInSeconds * 1000));\n-        }\n-\n-        clientConnectorConfig.setMaxFrameSize(WebSocketUtil.findMaxFrameSize(clientEndpointConfig));\n-\n-        MapValue secureSocket = clientEndpointConfig.getMapValue(HttpConstants.ENDPOINT_CONFIG_SECURE_SOCKET);\n-        if (secureSocket != null) {\n-            HttpUtil.populateSSLConfiguration(clientConnectorConfig, secureSocket);\n-        } else if (scheme.equals(WebSocketConstants.WSS_SCHEME)) {\n-            clientConnectorConfig.useJavaDefaults();\n+        if (webSocketClient.getNativeData(WebSocketConstants.CLIENT_LISTENER) == null) {\n+            webSocketClient.addNativeData(WebSocketConstants.CLIENT_LISTENER, new ClientConnectorListener());\n         }\n-        clientConnectorConfig.setWebSocketCompressionEnabled(\n-                clientEndpointConfig.getBooleanValue(WebSocketConstants.COMPRESSION_ENABLED_CONFIG));\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        webSocketClient.addNativeData(WebSocketConstants.COUNT_DOWN_LATCH, countDownLatch);\n+        WebSocketUtil.establishWebSocketConnection(clientConnector, webSocketClient, wsService);\n+        // Sets the count Down latch for initial connection", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2MTE5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397961197", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Handshake listener of WebSocket client.\n          \n          \n            \n             * Handshake listener of the WebSocket client.", "author": "praneesha", "createdAt": "2020-03-25T15:47:18Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/ClientHandshakeListener.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+/**\n+ * Handshake listener of WebSocket client.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2MTU2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397961569", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Handshake listener of webSocket failover client.\n          \n          \n            \n             * Handshake listener of the WebSocket failover client.", "author": "praneesha", "createdAt": "2020-03-25T15:47:44Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverHandshakeListener.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Handshake listener of webSocket failover client.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2NTkyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397965924", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # + webSocketCompressionEnabled - Enable support for compression in WebSocket\n          \n          \n            \n            # + webSocketCompressionEnabled - Enable support for compression in the WebSocket", "author": "praneesha", "createdAt": "2020-03-25T15:52:51Z", "path": "stdlib/http/src/main/ballerina/src/http/websocket/websocket_failover_client.bal", "diffHunk": "@@ -0,0 +1,205 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+// http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+import ballerina/java;\n+\n+# A WebSocket client endpoint, which provides failover support for multiple WebSocket targets.\n+public type WebSocketFailoverClient client object {\n+\n+    private string id = \"\";\n+    private string? negotiatedSubProtocol = ();\n+    private boolean secure = false;\n+    private boolean open = false;\n+    private Response? response = ();\n+    private map<any> attributes = {};\n+    private string url = \"\";\n+\n+    private WebSocketConnector conn = new;\n+    private WebSocketFailoverClientConfiguration config = {};\n+\n+    # Initializes failover client, which provides failover capabilities to a WebSocket client endpoint.\n+    #\n+    # + config - The `WebSocketFailoverClientConfiguration` of the endpoint\n+    public function __init(public WebSocketFailoverClientConfiguration config) {\n+        self.url = config.targetUrls[0];\n+        self.config = config;\n+        self.init();\n+    }\n+\n+    public function init() {\n+        return externFailoverInit(self);\n+    }\n+\n+    # Pushes text to the connection. If an error occurs while sending the text message to the connection, that message\n+    # will be lost.\n+    #\n+    # + data - Data to be sent. If it is a byte[], it is converted to a UTF-8 string for sending\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushText(string|json|xml|boolean|int|float|byte|byte[] data,\n+    public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushText(data, finalFrame);\n+    }\n+\n+    # Pushes binary data to the connection. If an error occurs while sending the binary message to the connection,\n+    # that message will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + finalFrame - Set to `true` if this is a final frame of a (long) message\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pushBinary(byte[] data, public boolean finalFrame = true) returns WebSocketError? {\n+        return self.conn.pushBinary(data, finalFrame);\n+    }\n+\n+    # Pings the connection. If an error occurs while sending the ping frame to the connection, that frame will be lost.\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function ping(byte[] data) returns WebSocketError? {\n+        return self.conn.ping(data);\n+    }\n+\n+    # Sends a pong message to the connection. If an error occurs while sending the pong frame to the connection, that\n+    # frame will be lost\n+    #\n+    # + data - Binary data to be sent\n+    # + return  - An `error` if an error occurs when sending\n+    public remote function pong(byte[] data) returns WebSocketError? {\n+        return self.conn.pong(data);\n+    }\n+\n+    # Closes the connection.\n+    #\n+    # + statusCode - Status code for closing the connection\n+    # + reason - Reason for closing the connection\n+    # + timeoutInSeconds - Time to wait for the close frame to be received from the remote endpoint before closing the\n+    #                   connection. If the timeout exceeds, then the connection is terminated even though a close frame\n+    #                   is not received from the remote endpoint. If the value is < 0 (e.g., -1), then the connection\n+    #                   waits until a close frame is received. If the WebSocket frame is received from the remote\n+    #                   endpoint within the waiting period, the connection is terminated immediately\n+    # + return - An `error` if an error occurs while closing the webSocket connection\n+    public remote function close(public int? statusCode = 1000, public string? reason = (),\n+    public int timeoutInSeconds = 60) returns WebSocketError? {\n+        return self.conn.close(statusCode, reason, timeoutInSeconds);\n+    }\n+\n+    # Calls when the endpoint is ready to receive messages. It can be called only once per endpoint. For the\n+    # WebSocketListener, it can be called only in the `upgrade` or `onOpen` resources.\n+    #\n+    # + return - An `error` if an error occurs while checking the connection state\n+    public remote function ready() returns WebSocketError? {\n+        return self.conn.ready();\n+    }\n+\n+    # Sets a connection-related attribute.\n+    #\n+    # + key - The key to identify the attribute\n+    # + value - The value of the attribute\n+    public function setAttribute(string key, any value) {\n+        self.attributes[key] = value;\n+    }\n+\n+    # Gets connection-related attributes if any.\n+    #\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n+    public function getAttribute(string key) returns any {\n+        return self.attributes[key];\n+    }\n+\n+    # Removes connection-related attributes if any.\n+    #\n+    # + key - The key to identify the attribute\n+    # + return - The attribute related to the given key or `nil`\n+    public function removeAttribute(string key) returns any {\n+        return self.attributes.remove(key);\n+    }\n+\n+    # Gives the connection ID associated with this connection.\n+    #\n+    # + return - The unique ID associated with the connection\n+    public function getConnectionId() returns string {\n+        return self.id;\n+    }\n+\n+    # Gives the subprotocol if any that is negotiated with the client.\n+    #\n+    # + return - Returns the subprotocol if any that is negotiated with the client or `nil`\n+    public function getNegotiatedSubProtocol() returns string? {\n+        return self.negotiatedSubProtocol;\n+    }\n+\n+    # Gives the secured status of the connection.\n+    #\n+    # + return - Returns `true` if the connection is secure\n+    public function isSecure() returns boolean {\n+        return self.secure;\n+    }\n+\n+    # Gives the open or closed status of the connection.\n+    #\n+    # + return - Returns `true` if the connection is open\n+    public function isOpen() returns boolean {\n+        return self.open;\n+    }\n+\n+    # Gives any HTTP response for the client handshake request if received.\n+    #\n+    # + return - Returns the HTTP response received for the client handshake request\n+    public function getHttpResponse() returns Response? {\n+        return self.response;\n+    }\n+\n+};\n+\n+# Configurations for the WebSocket client endpoint.\n+#\n+# + callbackService - The callback service for the client. Resources in this service gets called on the\n+#                     receipt of messages from the server\n+# + subProtocols - Negotiable sub protocols for the client\n+# + customHeaders - Custom headers, which should be sent to the server\n+# + idleTimeoutInSeconds - Idle timeout of the client. Upon timeout, the `onIdleTimeout` resource (if defined)\n+#                          of the client service will be triggered\n+# + readyOnConnect - Set to `true` if the client is ready to receive messages as soon as the connection is established.\n+#                    This is set to `true` by default. If changed to `false`, the ready() function of the\n+#                    `WebSocketFailoverClient` needs to be called once to start receiving messages\n+# + secureSocket - SSL/TLS-related options\n+# + maxFrameSize - The maximum payload size of a WebSocket frame in bytes\n+#                  If this is not set, is negative, or is zero, the default frame size of 65536 will be used.\n+# + targetUrls - The set of URLs, which are used to connect to the server\n+# + failoverIntervalInMillis - The maximum number of milliseconds to delay a failover attempt\n+# + webSocketCompressionEnabled - Enable support for compression in WebSocket", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2NzA5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397967094", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Creates the client connector\n          \n          \n            \n                    // Creates the client connector.", "author": "praneesha", "createdAt": "2020-03-25T15:54:22Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/InitEndpoint.java", "diffHunk": "@@ -47,152 +42,33 @@\n  */\n public class InitEndpoint {\n \n-    private static final Logger logger = LoggerFactory.getLogger(InitEndpoint.class);\n-    private static final String INTERVAL_IN_MILLIS = \"intervalInMillis\";\n-    private static final String MAX_WAIT_INTERVAL = \"maxWaitIntervalInMillis\";\n-    private static final String MAX_COUNT = \"maxCount\";\n-    private static final String BACK_OF_FACTOR = \"backOffFactor\";\n-\n     public static void initEndpoint(ObjectValue webSocketClient) {\n         @SuppressWarnings(WebSocketConstants.UNCHECKED)\n         MapValue<String, Object> clientEndpointConfig = (MapValue<String, Object>) webSocketClient.getMapValue(\n                 HttpConstants.CLIENT_ENDPOINT_CONFIG);\n         Strand strand = Scheduler.getStrand();\n         String remoteUrl = webSocketClient.getStringValue(WebSocketConstants.CLIENT_URL_CONFIG);\n-        WebSocketService wsService = validateAndCreateWebSocketService(clientEndpointConfig, strand);\n+        WebSocketService wsService = WebSocketUtil.validateAndCreateWebSocketService(strand, clientEndpointConfig);\n         HttpWsConnectorFactory connectorFactory = HttpUtil.createHttpWsConnectionFactory();\n         WebSocketClientConnectorConfig clientConnectorConfig = new WebSocketClientConnectorConfig(remoteUrl);\n         String scheme = URI.create(remoteUrl).getScheme();\n-        populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n-        // Create the client connector.\n+        WebSocketUtil.populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n+        // Creates the client connector", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2NzQzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397967434", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // because there is no need to create the client connector again when using one URL\n          \n          \n            \n                    // because there is no need to create the client connector again when using one URL.", "author": "praneesha", "createdAt": "2020-03-25T15:54:45Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/InitEndpoint.java", "diffHunk": "@@ -47,152 +42,33 @@\n  */\n public class InitEndpoint {\n \n-    private static final Logger logger = LoggerFactory.getLogger(InitEndpoint.class);\n-    private static final String INTERVAL_IN_MILLIS = \"intervalInMillis\";\n-    private static final String MAX_WAIT_INTERVAL = \"maxWaitIntervalInMillis\";\n-    private static final String MAX_COUNT = \"maxCount\";\n-    private static final String BACK_OF_FACTOR = \"backOffFactor\";\n-\n     public static void initEndpoint(ObjectValue webSocketClient) {\n         @SuppressWarnings(WebSocketConstants.UNCHECKED)\n         MapValue<String, Object> clientEndpointConfig = (MapValue<String, Object>) webSocketClient.getMapValue(\n                 HttpConstants.CLIENT_ENDPOINT_CONFIG);\n         Strand strand = Scheduler.getStrand();\n         String remoteUrl = webSocketClient.getStringValue(WebSocketConstants.CLIENT_URL_CONFIG);\n-        WebSocketService wsService = validateAndCreateWebSocketService(clientEndpointConfig, strand);\n+        WebSocketService wsService = WebSocketUtil.validateAndCreateWebSocketService(strand, clientEndpointConfig);\n         HttpWsConnectorFactory connectorFactory = HttpUtil.createHttpWsConnectionFactory();\n         WebSocketClientConnectorConfig clientConnectorConfig = new WebSocketClientConnectorConfig(remoteUrl);\n         String scheme = URI.create(remoteUrl).getScheme();\n-        populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n-        // Create the client connector.\n+        WebSocketUtil.populateClientConnectorConfig(clientEndpointConfig, clientConnectorConfig, scheme);\n+        // Creates the client connector\n         WebSocketClientConnector clientConnector = connectorFactory.createWsClientConnector(clientConnectorConfig);\n-        WebSocketClientConnectorListener clientConnectorListener = new WebSocketClientConnectorListener();\n-        // Add the client connector as a native data when the client is not a failover client\n-        // because when using one URL, there is no need to create the client connector again.\n+        webSocketClient.addNativeData(WebSocketConstants.CONNECTOR_FACTORY, connectorFactory);\n+        // Add the client connector as a native data\n+        // because there is no need to create the client connector again when using one URL", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2ODIzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397968230", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Cannot reach this point as onHandshake and onOpen is not supported for WebSocket client service\n          \n          \n            \n                    // Cannot reach this point as `onHandshake` and `onOpen` are not supported by WebSocket client services.", "author": "praneesha", "createdAt": "2020-03-25T15:55:48Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverConnectorListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ *  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketBinaryMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketCloseMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketControlMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketHandshaker;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketTextMessage;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Ballerina Connector listener of WebSocket failover.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverConnectorListener implements ExtendedConnectorListener {\n+\n+    private WebSocketConnectionInfo connectionInfo = null;\n+    private ExtendedConnectorListener connectorListener;\n+\n+    public FailoverConnectorListener(ExtendedConnectorListener connectorListener) {\n+        this.connectorListener = connectorListener;\n+    }\n+\n+    @Override\n+    public void setConnectionInfo(WebSocketConnectionInfo connectionInfo) {\n+        connectorListener.setConnectionInfo(connectionInfo);\n+        this.connectionInfo = connectionInfo;\n+    }\n+\n+    @Override\n+    public void onHandshake(WebSocketHandshaker webSocketHandshaker) {\n+        // Cannot reach this point as onHandshake and onOpen is not supported for WebSocket client service", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2ODM3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397968371", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // When the connection is lost, do the failover to the remaining server URLs\n          \n          \n            \n                    // When the connection is lost, do the failover to the remaining server URLs.", "author": "praneesha", "createdAt": "2020-03-25T15:55:58Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverConnectorListener.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ *  Copyright (c) 2017, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketBinaryMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketCloseMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketControlMessage;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketHandshaker;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketTextMessage;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Ballerina Connector listener of WebSocket failover.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverConnectorListener implements ExtendedConnectorListener {\n+\n+    private WebSocketConnectionInfo connectionInfo = null;\n+    private ExtendedConnectorListener connectorListener;\n+\n+    public FailoverConnectorListener(ExtendedConnectorListener connectorListener) {\n+        this.connectorListener = connectorListener;\n+    }\n+\n+    @Override\n+    public void setConnectionInfo(WebSocketConnectionInfo connectionInfo) {\n+        connectorListener.setConnectionInfo(connectionInfo);\n+        this.connectionInfo = connectionInfo;\n+    }\n+\n+    @Override\n+    public void onHandshake(WebSocketHandshaker webSocketHandshaker) {\n+        // Cannot reach this point as onHandshake and onOpen is not supported for WebSocket client service\n+    }\n+\n+    @Override\n+    public void onMessage(WebSocketTextMessage textMessage) {\n+        connectorListener.onMessage(textMessage);\n+    }\n+\n+    @Override\n+    public void onMessage(WebSocketBinaryMessage binaryMessage) {\n+        connectorListener.onMessage(binaryMessage);\n+    }\n+\n+    @Override\n+    public void onMessage(WebSocketControlMessage controlMessage) {\n+        connectorListener.onMessage(controlMessage);\n+    }\n+\n+    @Override\n+    public void onMessage(WebSocketCloseMessage webSocketCloseMessage) {\n+        int statusCode = webSocketCloseMessage.getCloseCode();\n+        if (!(statusCode == WebSocketConstants.STATUS_CODE_ABNORMAL_CLOSURE &&\n+                WebSocketUtil.failover(connectionInfo.getWebSocketEndpoint(), connectionInfo.getService()))) {\n+            connectorListener.onMessage(webSocketCloseMessage);\n+        }\n+    }\n+\n+    @Override\n+    public void onClose(WebSocketConnection webSocketConnection) {\n+        connectorListener.onClose(webSocketConnection);\n+    }\n+\n+    @Override\n+    public void onError(WebSocketConnection webSocketConnection, Throwable throwable) {\n+        // When the connection is lost, do the failover to the remaining server URLs", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2ODczNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397968735", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Sets failover context variable's value\n          \n          \n            \n                    // Sets the value of the failover context variable.", "author": "praneesha", "createdAt": "2020-03-25T15:56:25Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverHandshakeListener.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Handshake listener of webSocket failover client.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private ExtendedHandshakeListener handshakeListener;\n+    private static final Logger logger = LoggerFactory.getLogger(FailoverHandshakeListener.class);\n+\n+    public FailoverHandshakeListener(ExtendedHandshakeListener handshakeListener, WebSocketService wsService) {\n+        this.handshakeListener = handshakeListener;\n+        this.wsService = wsService;\n+    }\n+\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse response) {\n+        handshakeListener.onSuccess(webSocketConnection, response);\n+        FailoverContext failoverContext = (FailoverContext) getWebSocketClient().getNativeData(WebSocketConstants.\n+                FAILOVER_CONTEXT);\n+        int currentIndex = failoverContext.getCurrentIndex();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(WebSocketConstants.LOG_MESSAGE, WebSocketConstants.CONNECTED_TO,\n+                    failoverContext.getTargetUrls().get(failoverContext.getCurrentIndex()));\n+        }\n+        // Sets failover context variable's value", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2ODg3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397968873", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // When the connection is lost, do the failover to the remaining server URLs\n          \n          \n            \n                    // When the connection is lost, do the failover to the remaining server URLs.", "author": "praneesha", "createdAt": "2020-03-25T15:56:32Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverHandshakeListener.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Handshake listener of webSocket failover client.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private ExtendedHandshakeListener handshakeListener;\n+    private static final Logger logger = LoggerFactory.getLogger(FailoverHandshakeListener.class);\n+\n+    public FailoverHandshakeListener(ExtendedHandshakeListener handshakeListener, WebSocketService wsService) {\n+        this.handshakeListener = handshakeListener;\n+        this.wsService = wsService;\n+    }\n+\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse response) {\n+        handshakeListener.onSuccess(webSocketConnection, response);\n+        FailoverContext failoverContext = (FailoverContext) getWebSocketClient().getNativeData(WebSocketConstants.\n+                FAILOVER_CONTEXT);\n+        int currentIndex = failoverContext.getCurrentIndex();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(WebSocketConstants.LOG_MESSAGE, WebSocketConstants.CONNECTED_TO,\n+                    failoverContext.getTargetUrls().get(failoverContext.getCurrentIndex()));\n+        }\n+        // Sets failover context variable's value\n+        failoverContext.setInitialIndex(currentIndex);\n+        failoverContext.setFirstConnectionEstablished();\n+    }\n+\n+    @Override\n+    public void onError(Throwable throwable, HttpCarbonResponse response) {\n+        handshakeListener.onError(throwable, response);\n+        ObjectValue webSocketClient = getWebSocketClient();\n+        // When the connection is lost, do the failover to the remaining server URLs", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2OTUwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397969505", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // Calls the countDown() to initial connection's countDown latch\n          \n          \n            \n                        // Calls the `countDown()` function to initialize the count down latch of the connection.", "author": "praneesha", "createdAt": "2020-03-25T15:57:17Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/FailoverHandshakeListener.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Handshake listener of webSocket failover client.\n+ *\n+ * @since 1.2.0\n+ */\n+public class FailoverHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private ExtendedHandshakeListener handshakeListener;\n+    private static final Logger logger = LoggerFactory.getLogger(FailoverHandshakeListener.class);\n+\n+    public FailoverHandshakeListener(ExtendedHandshakeListener handshakeListener, WebSocketService wsService) {\n+        this.handshakeListener = handshakeListener;\n+        this.wsService = wsService;\n+    }\n+\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse response) {\n+        handshakeListener.onSuccess(webSocketConnection, response);\n+        FailoverContext failoverContext = (FailoverContext) getWebSocketClient().getNativeData(WebSocketConstants.\n+                FAILOVER_CONTEXT);\n+        int currentIndex = failoverContext.getCurrentIndex();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(WebSocketConstants.LOG_MESSAGE, WebSocketConstants.CONNECTED_TO,\n+                    failoverContext.getTargetUrls().get(failoverContext.getCurrentIndex()));\n+        }\n+        // Sets failover context variable's value\n+        failoverContext.setInitialIndex(currentIndex);\n+        failoverContext.setFirstConnectionEstablished();\n+    }\n+\n+    @Override\n+    public void onError(Throwable throwable, HttpCarbonResponse response) {\n+        handshakeListener.onError(throwable, response);\n+        ObjectValue webSocketClient = getWebSocketClient();\n+        // When the connection is lost, do the failover to the remaining server URLs\n+        if (!(throwable instanceof IOException && WebSocketUtil.failover(webSocketClient, wsService))) {\n+            // Calls the countDown() to initial connection's countDown latch", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk2OTc4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397969783", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Handshake listener for retry WebSocket client.\n          \n          \n            \n             * Handshake listener for retrying of the WebSocket client.", "author": "praneesha", "createdAt": "2020-03-25T15:57:39Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/RetryHandshakeListener.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketResourceDispatcher;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.RetryContext;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Handshake listener for retry WebSocket client.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MDA5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397970090", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * WebSocketHandshakeListener implements {@link ExtendedHandshakeListener} interface directly.\n          \n          \n            \n             * The `WebSocketHandshakeListener` implements the `{@link ExtendedHandshakeListener}` interface directly.", "author": "praneesha", "createdAt": "2020-03-25T15:58:02Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/WebSocketHandshakeListener.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.HttpConstants;\n+import org.ballerinalang.net.http.HttpUtil;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.client.RetryContext;\n+import org.ballerinalang.net.http.websocket.observability.WebSocketObservabilityUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.ballerinalang.net.http.HttpConstants.CLIENT_ENDPOINT_CONFIG;\n+\n+/**\n+ * WebSocketHandshakeListener implements {@link ExtendedHandshakeListener} interface directly.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MDU0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397970541", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // Calls the countDown() to initial connection's countDown latch\n          \n          \n            \n                        // Calls the `countDown()` function to initialize the count down latch of the connection.", "author": "praneesha", "createdAt": "2020-03-25T15:58:34Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/WebSocketHandshakeListener.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.HttpConstants;\n+import org.ballerinalang.net.http.HttpUtil;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.client.RetryContext;\n+import org.ballerinalang.net.http.websocket.observability.WebSocketObservabilityUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.ballerinalang.net.http.HttpConstants.CLIENT_ENDPOINT_CONFIG;\n+\n+/**\n+ * WebSocketHandshakeListener implements {@link ExtendedHandshakeListener} interface directly.\n+ *\n+ * @since 1.2.0\n+ */\n+public class WebSocketHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private final ExtendedConnectorListener connectorListener;\n+    private final ObjectValue webSocketClient;\n+    private CountDownLatch countDownLatch;\n+    private WebSocketConnectionInfo connectionInfo;\n+        private boolean readyOnConnect;\n+\n+    public WebSocketHandshakeListener(ObjectValue webSocketClient, WebSocketService wsService,\n+                                      ExtendedConnectorListener connectorListener,\n+                                      CountDownLatch countDownLatch, boolean readyOnConnect) {\n+        this.webSocketClient = webSocketClient;\n+        this.wsService = wsService;\n+        this.connectorListener = connectorListener;\n+        this.countDownLatch = countDownLatch;\n+        this.readyOnConnect = readyOnConnect;\n+    }\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse carbonResponse) {\n+        ObjectValue webSocketConnector;\n+        webSocketClient.set(WebSocketConstants.CLIENT_RESPONSE_FIELD, HttpUtil.createResponseStruct(carbonResponse));\n+        if (isFirstConnectionEstablished(webSocketClient)) {\n+            webSocketConnector = (ObjectValue) webSocketClient.get(WebSocketConstants.CLIENT_CONNECTOR_FIELD);\n+            webSocketClient.set(WebSocketConstants.LISTENER_ID_FIELD, webSocketConnection.getChannelId());\n+        } else {\n+            webSocketConnector = createWebSocketConnector(readyOnConnect);\n+            WebSocketUtil.populateWebSocketEndpoint(webSocketConnection, webSocketClient);\n+            // Calls the countDown() to initial connection's countDown latch", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MTIyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397971220", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Sets readyOnConnect's value to the created webSocketConnector's isReady field\n          \n          \n            \n                    // Sets the value of `readyOnConnect` to the created `isReady' field of the webSocketConnector.", "author": "praneesha", "createdAt": "2020-03-25T15:59:25Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/WebSocketHandshakeListener.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.HttpConstants;\n+import org.ballerinalang.net.http.HttpUtil;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.client.RetryContext;\n+import org.ballerinalang.net.http.websocket.observability.WebSocketObservabilityUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.ballerinalang.net.http.HttpConstants.CLIENT_ENDPOINT_CONFIG;\n+\n+/**\n+ * WebSocketHandshakeListener implements {@link ExtendedHandshakeListener} interface directly.\n+ *\n+ * @since 1.2.0\n+ */\n+public class WebSocketHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private final ExtendedConnectorListener connectorListener;\n+    private final ObjectValue webSocketClient;\n+    private CountDownLatch countDownLatch;\n+    private WebSocketConnectionInfo connectionInfo;\n+        private boolean readyOnConnect;\n+\n+    public WebSocketHandshakeListener(ObjectValue webSocketClient, WebSocketService wsService,\n+                                      ExtendedConnectorListener connectorListener,\n+                                      CountDownLatch countDownLatch, boolean readyOnConnect) {\n+        this.webSocketClient = webSocketClient;\n+        this.wsService = wsService;\n+        this.connectorListener = connectorListener;\n+        this.countDownLatch = countDownLatch;\n+        this.readyOnConnect = readyOnConnect;\n+    }\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse carbonResponse) {\n+        ObjectValue webSocketConnector;\n+        webSocketClient.set(WebSocketConstants.CLIENT_RESPONSE_FIELD, HttpUtil.createResponseStruct(carbonResponse));\n+        if (isFirstConnectionEstablished(webSocketClient)) {\n+            webSocketConnector = (ObjectValue) webSocketClient.get(WebSocketConstants.CLIENT_CONNECTOR_FIELD);\n+            webSocketClient.set(WebSocketConstants.LISTENER_ID_FIELD, webSocketConnection.getChannelId());\n+        } else {\n+            webSocketConnector = createWebSocketConnector(readyOnConnect);\n+            WebSocketUtil.populateWebSocketEndpoint(webSocketConnection, webSocketClient);\n+            // Calls the countDown() to initial connection's countDown latch\n+            WebSocketUtil.countDownForHandshake(webSocketClient);\n+        }\n+        if (readyOnConnect) {\n+            WebSocketUtil.readFirstFrame(webSocketConnection, webSocketConnector);\n+        }\n+        setWebSocketOpenConnectionInfo(webSocketConnection, webSocketConnector, webSocketClient, wsService);\n+        connectorListener.setConnectionInfo(connectionInfo);\n+        countDownLatch.countDown();\n+        WebSocketObservabilityUtil.observeConnection(connectionInfo);\n+    }\n+\n+    @Override\n+    public void onError(Throwable t, HttpCarbonResponse response) {\n+        if (response != null) {\n+            webSocketClient.set(WebSocketConstants.CLIENT_RESPONSE_FIELD, HttpUtil.createResponseStruct(response));\n+        }\n+        ObjectValue webSocketConnector = BallerinaValues.createObjectValue(WebSocketConstants.PROTOCOL_HTTP_PKG_ID,\n+                WebSocketConstants.WEBSOCKET_CONNECTOR);\n+        setWebSocketOpenConnectionInfo(null, webSocketConnector, webSocketClient, wsService);\n+        webSocketConnector.addNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_CONNECTION_INFO, connectionInfo);\n+        webSocketClient.set(WebSocketConstants.CLIENT_CONNECTOR_FIELD, webSocketConnector);\n+        countDownLatch.countDown();\n+    }\n+\n+    @Override\n+    public ObjectValue getWebSocketClient() {\n+        return webSocketClient;\n+    }\n+\n+    @Override\n+    public WebSocketConnectionInfo getWebSocketConnectionInfo() {\n+        return connectionInfo;\n+    }\n+\n+    private void setWebSocketOpenConnectionInfo(WebSocketConnection webSocketConnection,\n+                                                ObjectValue webSocketConnector,\n+                                                ObjectValue webSocketClient, WebSocketService wsService) {\n+        this.connectionInfo = new WebSocketConnectionInfo(wsService, webSocketConnection, webSocketClient);\n+        webSocketConnector.addNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_CONNECTION_INFO, connectionInfo);\n+        webSocketClient.set(WebSocketConstants.CLIENT_CONNECTOR_FIELD, webSocketConnector);\n+    }\n+\n+    private static ObjectValue createWebSocketConnector(boolean readyOnConnect) {\n+        ObjectValue webSocketConnector = BallerinaValues.createObjectValue(HttpConstants.PROTOCOL_HTTP_PKG_ID,\n+                WebSocketConstants.WEBSOCKET_CONNECTOR);\n+        // Sets readyOnConnect's value to the created webSocketConnector's isReady field", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MTgxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397971818", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // It uses to check whether readNextFrame function already called or not When call the ready() function\n          \n          \n            \n                    // It checks whether the `readNextFrame` function is already called or not when the `ready()` function is called.", "author": "praneesha", "createdAt": "2020-03-25T16:00:08Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/client/listener/WebSocketHandshakeListener.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.net.http.websocket.client.listener;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.net.http.HttpConstants;\n+import org.ballerinalang.net.http.HttpUtil;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.net.http.websocket.WebSocketService;\n+import org.ballerinalang.net.http.websocket.WebSocketUtil;\n+import org.ballerinalang.net.http.websocket.client.FailoverContext;\n+import org.ballerinalang.net.http.websocket.client.RetryContext;\n+import org.ballerinalang.net.http.websocket.observability.WebSocketObservabilityUtil;\n+import org.ballerinalang.net.http.websocket.server.WebSocketConnectionInfo;\n+import org.wso2.transport.http.netty.contract.websocket.WebSocketConnection;\n+import org.wso2.transport.http.netty.message.HttpCarbonResponse;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+import static org.ballerinalang.net.http.HttpConstants.CLIENT_ENDPOINT_CONFIG;\n+\n+/**\n+ * WebSocketHandshakeListener implements {@link ExtendedHandshakeListener} interface directly.\n+ *\n+ * @since 1.2.0\n+ */\n+public class WebSocketHandshakeListener implements ExtendedHandshakeListener {\n+\n+    private final WebSocketService wsService;\n+    private final ExtendedConnectorListener connectorListener;\n+    private final ObjectValue webSocketClient;\n+    private CountDownLatch countDownLatch;\n+    private WebSocketConnectionInfo connectionInfo;\n+        private boolean readyOnConnect;\n+\n+    public WebSocketHandshakeListener(ObjectValue webSocketClient, WebSocketService wsService,\n+                                      ExtendedConnectorListener connectorListener,\n+                                      CountDownLatch countDownLatch, boolean readyOnConnect) {\n+        this.webSocketClient = webSocketClient;\n+        this.wsService = wsService;\n+        this.connectorListener = connectorListener;\n+        this.countDownLatch = countDownLatch;\n+        this.readyOnConnect = readyOnConnect;\n+    }\n+    @Override\n+    public void onSuccess(WebSocketConnection webSocketConnection, HttpCarbonResponse carbonResponse) {\n+        ObjectValue webSocketConnector;\n+        webSocketClient.set(WebSocketConstants.CLIENT_RESPONSE_FIELD, HttpUtil.createResponseStruct(carbonResponse));\n+        if (isFirstConnectionEstablished(webSocketClient)) {\n+            webSocketConnector = (ObjectValue) webSocketClient.get(WebSocketConstants.CLIENT_CONNECTOR_FIELD);\n+            webSocketClient.set(WebSocketConstants.LISTENER_ID_FIELD, webSocketConnection.getChannelId());\n+        } else {\n+            webSocketConnector = createWebSocketConnector(readyOnConnect);\n+            WebSocketUtil.populateWebSocketEndpoint(webSocketConnection, webSocketClient);\n+            // Calls the countDown() to initial connection's countDown latch\n+            WebSocketUtil.countDownForHandshake(webSocketClient);\n+        }\n+        if (readyOnConnect) {\n+            WebSocketUtil.readFirstFrame(webSocketConnection, webSocketConnector);\n+        }\n+        setWebSocketOpenConnectionInfo(webSocketConnection, webSocketConnector, webSocketClient, wsService);\n+        connectorListener.setConnectionInfo(connectionInfo);\n+        countDownLatch.countDown();\n+        WebSocketObservabilityUtil.observeConnection(connectionInfo);\n+    }\n+\n+    @Override\n+    public void onError(Throwable t, HttpCarbonResponse response) {\n+        if (response != null) {\n+            webSocketClient.set(WebSocketConstants.CLIENT_RESPONSE_FIELD, HttpUtil.createResponseStruct(response));\n+        }\n+        ObjectValue webSocketConnector = BallerinaValues.createObjectValue(WebSocketConstants.PROTOCOL_HTTP_PKG_ID,\n+                WebSocketConstants.WEBSOCKET_CONNECTOR);\n+        setWebSocketOpenConnectionInfo(null, webSocketConnector, webSocketClient, wsService);\n+        webSocketConnector.addNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_CONNECTION_INFO, connectionInfo);\n+        webSocketClient.set(WebSocketConstants.CLIENT_CONNECTOR_FIELD, webSocketConnector);\n+        countDownLatch.countDown();\n+    }\n+\n+    @Override\n+    public ObjectValue getWebSocketClient() {\n+        return webSocketClient;\n+    }\n+\n+    @Override\n+    public WebSocketConnectionInfo getWebSocketConnectionInfo() {\n+        return connectionInfo;\n+    }\n+\n+    private void setWebSocketOpenConnectionInfo(WebSocketConnection webSocketConnection,\n+                                                ObjectValue webSocketConnector,\n+                                                ObjectValue webSocketClient, WebSocketService wsService) {\n+        this.connectionInfo = new WebSocketConnectionInfo(wsService, webSocketConnection, webSocketClient);\n+        webSocketConnector.addNativeData(WebSocketConstants.NATIVE_DATA_WEBSOCKET_CONNECTION_INFO, connectionInfo);\n+        webSocketClient.set(WebSocketConstants.CLIENT_CONNECTOR_FIELD, webSocketConnector);\n+    }\n+\n+    private static ObjectValue createWebSocketConnector(boolean readyOnConnect) {\n+        ObjectValue webSocketConnector = BallerinaValues.createObjectValue(HttpConstants.PROTOCOL_HTTP_PKG_ID,\n+                WebSocketConstants.WEBSOCKET_CONNECTOR);\n+        // Sets readyOnConnect's value to the created webSocketConnector's isReady field\n+        // It uses to check whether readNextFrame function already called or not When call the ready() function", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzk3MjAwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r397972002", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Tests failover support of the WebSocket client.\n          \n          \n            \n             * Tests the failover support of the WebSocket client.", "author": "praneesha", "createdAt": "2020-03-25T16:00:23Z", "path": "tests/jballerina-integration-test/src/test/java/org/ballerinalang/test/service/websocket/FailoverClientTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.test.service.websocket;\n+\n+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\n+import org.ballerinalang.test.context.BallerinaTestException;\n+import org.ballerinalang.test.util.websocket.client.WebSocketTestClient;\n+import org.ballerinalang.test.util.websocket.server.WebSocketRemoteServer;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Tests failover support of the WebSocket client.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDk1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398330953", "bodyText": "Why is this function called setCallback? Can we use a better name? It doesn't seem to set any callbacks.", "author": "riyafa", "createdAt": "2020-03-26T05:49:15Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/actions/websocketconnector/WebSocketConnector.java", "diffHunk": "@@ -127,8 +127,25 @@ public static Object pong(ObjectValue wsConnection, ArrayValue binaryData) {\n                                                     WebSocketObservabilityConstants.ERROR_TYPE_MESSAGE_SENT,\n                                                     WebSocketObservabilityConstants.MESSAGE_TYPE_PONG,\n                                                     e.getMessage());\n-            callback.notifyFailure(WebSocketUtil.createErrorByType(e));\n+            setCallback(connectionInfo, callback, e);\n         }\n         return null;\n     }\n+\n+    public static void setCallback(WebSocketConnectionInfo connectionInfo, NonBlockingCallback callback,", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA0MDI4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399040289", "bodyText": "Changed it", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-27T05:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMDk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMTkyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398331929", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static boolean isClientSupportResiliency(WebSocketConnectionInfo connectionInfo) {\n          \n          \n            \n                private static boolean hasSupportForResiliency(WebSocketConnectionInfo connectionInfo) {", "author": "riyafa", "createdAt": "2020-03-26T05:53:03Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/actions/websocketconnector/WebSocketConnector.java", "diffHunk": "@@ -127,8 +127,25 @@ public static Object pong(ObjectValue wsConnection, ArrayValue binaryData) {\n                                                     WebSocketObservabilityConstants.ERROR_TYPE_MESSAGE_SENT,\n                                                     WebSocketObservabilityConstants.MESSAGE_TYPE_PONG,\n                                                     e.getMessage());\n-            callback.notifyFailure(WebSocketUtil.createErrorByType(e));\n+            setCallback(connectionInfo, callback, e);\n         }\n         return null;\n     }\n+\n+    public static void setCallback(WebSocketConnectionInfo connectionInfo, NonBlockingCallback callback,\n+                                   Throwable error) {\n+        if (isClientSupportResiliency(connectionInfo)) {\n+            ErrorHandlerUtils.printError(error);\n+            callback.notifySuccess();\n+        } else {\n+            callback.notifyFailure(WebSocketUtil.createErrorByType(error));\n+        }\n+    }\n+\n+    private static boolean isClientSupportResiliency(WebSocketConnectionInfo connectionInfo) {", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMzExMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398333113", "bodyText": "Why do we handle resiliency cases differently?", "author": "riyafa", "createdAt": "2020-03-26T05:57:20Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/actions/websocketconnector/WebSocketConnector.java", "diffHunk": "@@ -127,8 +127,25 @@ public static Object pong(ObjectValue wsConnection, ArrayValue binaryData) {\n                                                     WebSocketObservabilityConstants.ERROR_TYPE_MESSAGE_SENT,\n                                                     WebSocketObservabilityConstants.MESSAGE_TYPE_PONG,\n                                                     e.getMessage());\n-            callback.notifyFailure(WebSocketUtil.createErrorByType(e));\n+            setCallback(connectionInfo, callback, e);\n         }\n         return null;\n     }\n+\n+    public static void setCallback(WebSocketConnectionInfo connectionInfo, NonBlockingCallback callback,\n+                                   Throwable error) {\n+        if (isClientSupportResiliency(connectionInfo)) {", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAzNTg0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399035840", "bodyText": "In other places, we checked whether client supports retry|not  or failover|not but here, we are checking that client supports retry|failover|not. So, I handled like this.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-27T04:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMzExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzMzM0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398333340", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Service validator for the failover WebSocket.\n          \n          \n            \n             * Service validator for WebSocket failover.", "author": "riyafa", "createdAt": "2020-03-26T05:58:04Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/compiler/websocket/WebSocketFailoverClientResourceValidator.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.ballerinalang.net.http.compiler.websocket;\n+\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.util.diagnostic.Diagnostic;\n+import org.ballerinalang.util.diagnostic.DiagnosticLog;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+\n+/**\n+ * Service validator for the failover WebSocket.", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTQ3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398335479", "bodyText": "Shall we not use static imports?", "author": "riyafa", "createdAt": "2020-03-26T06:05:39Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/compiler/websocket/WebSocketFailoverClientServiceCompilerPlugin.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.ballerinalang.net.http.compiler.websocket;\n+\n+import org.ballerinalang.compiler.plugins.AbstractCompilerPlugin;\n+import org.ballerinalang.compiler.plugins.SupportedResourceParamTypes;\n+import org.ballerinalang.model.tree.AnnotationAttachmentNode;\n+import org.ballerinalang.model.tree.ServiceNode;\n+import org.ballerinalang.net.http.websocket.WebSocketConstants;\n+import org.ballerinalang.util.diagnostic.DiagnosticLog;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+\n+import java.util.List;\n+\n+import static org.ballerinalang.net.http.websocket.WebSocketConstants.FAILOVER_WEBSOCKET_CLIENT;", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTg2MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398335861", "bodyText": "Shall we have this constant in the relevant class?", "author": "riyafa", "createdAt": "2020-03-26T06:07:11Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/WebSocketConstants.java", "diffHunk": "@@ -79,13 +79,22 @@\n     public static final String CLIENT_READY_ON_CONNECT = \"readyOnConnect\";\n     public static final String WEBSOCKET_UPGRADE_SERVICE_CONFIG = \"upgradeService\";\n \n-    public static final String RETRY_CONFIG = \"retryConfig\";\n+    public static final String RETRY_CONTEXT = \"retryConfig\";\n     public static final String COUNT_DOWN_LATCH = \"countDownLatch\";\n     public static final String CLIENT_LISTENER = \"clientListener\";\n     public static final String CLIENT_CONNECTOR = \"clientConnector\";\n     public static final String LOG_MESSAGE = \"{} {}\";\n     public static final String ERROR_MESSAGE = \"Error occurred: \";\n \n+    public static final String CLIENT_ENDPOINT_CONFIG = \"config\";\n+    public static final String TARGET_URLS = \"targetUrls\";\n+    public static final String FAILOVER_CONTEXT = \"failoverContext\";\n+    public static final String CONNECTOR_FACTORY = \"connectorFactory\";\n+    public static final String FAILOVER_WEBSOCKET_CLIENT = \"WebSocketFailoverClient\";\n+    public static final String CONNECTED_TO = \"Connected to \";", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAzOTkwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399039906", "bodyText": "We are using in both classes now(#21187 615a022) So I'm keeping here.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-27T05:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTg2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA0NjEyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399046121", "bodyText": "I meant this comment? #21187 (comment)\nApplies to LOG_MESSAGE constant as well from above", "author": "riyafa", "createdAt": "2020-03-27T05:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMzNTk3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398335978", "bodyText": "Shall we have the message related constants in the relevant class?", "author": "riyafa", "createdAt": "2020-03-26T06:07:35Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/websocket/WebSocketConstants.java", "diffHunk": "@@ -79,13 +79,22 @@\n     public static final String CLIENT_READY_ON_CONNECT = \"readyOnConnect\";\n     public static final String WEBSOCKET_UPGRADE_SERVICE_CONFIG = \"upgradeService\";\n \n-    public static final String RETRY_CONFIG = \"retryConfig\";\n+    public static final String RETRY_CONTEXT = \"retryConfig\";\n     public static final String COUNT_DOWN_LATCH = \"countDownLatch\";\n     public static final String CLIENT_LISTENER = \"clientListener\";\n     public static final String CLIENT_CONNECTOR = \"clientConnector\";\n     public static final String LOG_MESSAGE = \"{} {}\";\n     public static final String ERROR_MESSAGE = \"Error occurred: \";", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODM1MzA4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r398353081", "bodyText": "Between if this going to be a utility function used by other classes we can move it to the WebSocketUtil class.", "author": "riyafa", "createdAt": "2020-03-26T07:02:19Z", "path": "stdlib/http/src/main/java/org/ballerinalang/net/http/actions/websocketconnector/WebSocketConnector.java", "diffHunk": "@@ -127,8 +127,25 @@ public static Object pong(ObjectValue wsConnection, ArrayValue binaryData) {\n                                                     WebSocketObservabilityConstants.ERROR_TYPE_MESSAGE_SENT,\n                                                     WebSocketObservabilityConstants.MESSAGE_TYPE_PONG,\n                                                     e.getMessage());\n-            callback.notifyFailure(WebSocketUtil.createErrorByType(e));\n+            setCallback(connectionInfo, callback, e);\n         }\n         return null;\n     }\n+\n+    public static void setCallback(WebSocketConnectionInfo connectionInfo, NonBlockingCallback callback,", "originalCommit": "59c7e27877456f35a4da8e3f23c0b14de329f478", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIwNDUwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399204509", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Test(description = \"Tests the failover webSocket client by starting the both server in the target URLs.\")\n          \n          \n            \n                @Test(description = \"Tests the failover webSocket client by starting two servers in the target URLs.\")", "author": "riyafa", "createdAt": "2020-03-27T11:39:03Z", "path": "tests/jballerina-integration-test/src/test/java/org/ballerinalang/test/service/websocket/FailoverClientTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.test.service.websocket;\n+\n+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\n+import org.ballerinalang.test.context.BallerinaTestException;\n+import org.ballerinalang.test.util.websocket.client.WebSocketTestClient;\n+import org.ballerinalang.test.util.websocket.server.WebSocketRemoteServer;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Tests the failover support of the WebSocket client.\n+ */\n+@Test(groups = {\"websocket-test\"})\n+public class FailoverClientTest extends WebSocketTestCommons {\n+\n+    private static final String URL = \"ws://localhost:21032\";\n+    private static final int FIRST_SERVER_PORT = 15300;\n+    private static final int SECOND_SERVER_PORT = 15200;\n+    private static final int THIRD_SERVER_PORT = 15400;\n+    private static final String MESSAGE = \"hi all\";\n+    private WebSocketRemoteServer firstRemoteServer;\n+    private WebSocketRemoteServer secondRemoteServer;\n+    private WebSocketRemoteServer thirdRemoteServer;\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the second server in the target URLs.\")\n+    public void testTextFrameWithSecondServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        secondRemoteServer = initiateServer(SECOND_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendTextDataAndAssert(client);\n+        closeConnection(client, secondRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the first server in the target URLs.\")\n+    public void testBinaryFrameWithFirstServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, firstRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the third server in the target URLs.\")\n+    public void testBinaryFrameWithThirdServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        thirdRemoteServer = initiateServer(THIRD_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, thirdRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by not starting any of the servers in the targets URLs\")\n+    public void testFailingFailover() throws URISyntaxException, InterruptedException {\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        WebSocketTestClient client = initiateClient(URL);\n+        client.setCountDownLatch(countDownLatch);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        CloseWebSocketFrame closeWebSocketFrame = client.getReceivedCloseFrame();\n+        Assert.assertNotNull(closeWebSocketFrame);\n+        Assert.assertEquals(closeWebSocketFrame.statusCode(), 1011);\n+        Assert.assertTrue(closeWebSocketFrame.reasonText().contains(\"Unexpected condition\"));\n+        closeWebSocketFrame.release();\n+    }\n+\n+    @Test(description = \"Tests the failover client when getting a handshake timeout\")\n+    public void testHandshakeTimeout() throws URISyntaxException, InterruptedException, BallerinaTestException {\n+        WebSocketTestClient client = initiateClient(\"ws://localhost:21034\");\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        sendTextDataAndAssert(client);\n+        closeConnection(client, firstRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the both server in the target URLs.\")", "originalCommit": "a9e39ae1b647dccab97f8595717e52d3ee6952b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIwNDY2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399204666", "bodyText": "same as above", "author": "riyafa", "createdAt": "2020-03-27T11:39:23Z", "path": "tests/jballerina-integration-test/src/test/java/org/ballerinalang/test/service/websocket/FailoverClientTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.test.service.websocket;\n+\n+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\n+import org.ballerinalang.test.context.BallerinaTestException;\n+import org.ballerinalang.test.util.websocket.client.WebSocketTestClient;\n+import org.ballerinalang.test.util.websocket.server.WebSocketRemoteServer;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Tests the failover support of the WebSocket client.\n+ */\n+@Test(groups = {\"websocket-test\"})\n+public class FailoverClientTest extends WebSocketTestCommons {\n+\n+    private static final String URL = \"ws://localhost:21032\";\n+    private static final int FIRST_SERVER_PORT = 15300;\n+    private static final int SECOND_SERVER_PORT = 15200;\n+    private static final int THIRD_SERVER_PORT = 15400;\n+    private static final String MESSAGE = \"hi all\";\n+    private WebSocketRemoteServer firstRemoteServer;\n+    private WebSocketRemoteServer secondRemoteServer;\n+    private WebSocketRemoteServer thirdRemoteServer;\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the second server in the target URLs.\")\n+    public void testTextFrameWithSecondServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        secondRemoteServer = initiateServer(SECOND_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendTextDataAndAssert(client);\n+        closeConnection(client, secondRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the first server in the target URLs.\")\n+    public void testBinaryFrameWithFirstServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, firstRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the third server in the target URLs.\")\n+    public void testBinaryFrameWithThirdServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        thirdRemoteServer = initiateServer(THIRD_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, thirdRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by not starting any of the servers in the targets URLs\")\n+    public void testFailingFailover() throws URISyntaxException, InterruptedException {\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        WebSocketTestClient client = initiateClient(URL);\n+        client.setCountDownLatch(countDownLatch);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        CloseWebSocketFrame closeWebSocketFrame = client.getReceivedCloseFrame();\n+        Assert.assertNotNull(closeWebSocketFrame);\n+        Assert.assertEquals(closeWebSocketFrame.statusCode(), 1011);\n+        Assert.assertTrue(closeWebSocketFrame.reasonText().contains(\"Unexpected condition\"));\n+        closeWebSocketFrame.release();\n+    }\n+\n+    @Test(description = \"Tests the failover client when getting a handshake timeout\")\n+    public void testHandshakeTimeout() throws URISyntaxException, InterruptedException, BallerinaTestException {\n+        WebSocketTestClient client = initiateClient(\"ws://localhost:21034\");\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        sendTextDataAndAssert(client);\n+        closeConnection(client, firstRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the both server in the target URLs.\")\n+    public void testFailoverWithBothServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        secondRemoteServer = initiateServer(SECOND_SERVER_PORT);\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendTextDataAndAssert(client);\n+        firstRemoteServer.stop();\n+        sendTextDataAndAssert(client);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, secondRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the both server in the target URLs.\")", "originalCommit": "a9e39ae1b647dccab97f8595717e52d3ee6952b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIwNjMwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399206305", "bodyText": "how is timeout checked here?", "author": "riyafa", "createdAt": "2020-03-27T11:42:37Z", "path": "tests/jballerina-integration-test/src/test/java/org/ballerinalang/test/service/websocket/FailoverClientTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.ballerinalang.test.service.websocket;\n+\n+import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;\n+import org.ballerinalang.test.context.BallerinaTestException;\n+import org.ballerinalang.test.util.websocket.client.WebSocketTestClient;\n+import org.ballerinalang.test.util.websocket.server.WebSocketRemoteServer;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.net.URISyntaxException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Tests the failover support of the WebSocket client.\n+ */\n+@Test(groups = {\"websocket-test\"})\n+public class FailoverClientTest extends WebSocketTestCommons {\n+\n+    private static final String URL = \"ws://localhost:21032\";\n+    private static final int FIRST_SERVER_PORT = 15300;\n+    private static final int SECOND_SERVER_PORT = 15200;\n+    private static final int THIRD_SERVER_PORT = 15400;\n+    private static final String MESSAGE = \"hi all\";\n+    private WebSocketRemoteServer firstRemoteServer;\n+    private WebSocketRemoteServer secondRemoteServer;\n+    private WebSocketRemoteServer thirdRemoteServer;\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the second server in the target URLs.\")\n+    public void testTextFrameWithSecondServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        secondRemoteServer = initiateServer(SECOND_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendTextDataAndAssert(client);\n+        closeConnection(client, secondRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the first server in the target URLs.\")\n+    public void testBinaryFrameWithFirstServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, firstRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by starting the third server in the target URLs.\")\n+    public void testBinaryFrameWithThirdServer() throws URISyntaxException, InterruptedException,\n+            BallerinaTestException {\n+        thirdRemoteServer = initiateServer(THIRD_SERVER_PORT);\n+        WebSocketTestClient client = initiateClient(URL);\n+        sendBinaryDataAndAssert(client);\n+        closeConnection(client, thirdRemoteServer);\n+    }\n+\n+    @Test(description = \"Tests the failover webSocket client by not starting any of the servers in the targets URLs\")\n+    public void testFailingFailover() throws URISyntaxException, InterruptedException {\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        WebSocketTestClient client = initiateClient(URL);\n+        client.setCountDownLatch(countDownLatch);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        CloseWebSocketFrame closeWebSocketFrame = client.getReceivedCloseFrame();\n+        Assert.assertNotNull(closeWebSocketFrame);\n+        Assert.assertEquals(closeWebSocketFrame.statusCode(), 1011);\n+        Assert.assertTrue(closeWebSocketFrame.reasonText().contains(\"Unexpected condition\"));\n+        closeWebSocketFrame.release();\n+    }\n+\n+    @Test(description = \"Tests the failover client when getting a handshake timeout\")\n+    public void testHandshakeTimeout() throws URISyntaxException, InterruptedException, BallerinaTestException {\n+        WebSocketTestClient client = initiateClient(\"ws://localhost:21034\");\n+        firstRemoteServer = initiateServer(FIRST_SERVER_PORT);\n+        CountDownLatch countDownLatch = new CountDownLatch(1);\n+        countDownLatch.await(TIMEOUT_IN_SECS, TimeUnit.SECONDS);\n+        sendTextDataAndAssert(client);", "originalCommit": "a9e39ae1b647dccab97f8595717e52d3ee6952b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkyNjAyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r399926024", "bodyText": "Here, we are waiting until handshake timeout. The timeout error is an IOError. Therefore we need to do the failover.", "author": "kalaiyarasiganeshalingam", "createdAt": "2020-03-30T04:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTIwNjMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDY0NDk5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/21187#discussion_r400644991", "bodyText": "Shall we have a meaningful name for the file?", "author": "riyafa", "createdAt": "2020-03-31T05:03:33Z", "path": "tests/jballerina-integration-test/src/test/resources/websocket/src/wsservices/34_counDown_latch.bal", "diffHunk": "@@ -0,0 +1,51 @@\n+// Copyright (c) 2020 WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "originalCommit": "7abb6607eecd6a7d996916ab2737ec39731761ba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f1da2e03281f20d579c8e9d6faf667035cc29b5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3f1da2e03281f20d579c8e9d6faf667035cc29b5", "message": "revert the commit", "committedDate": "2020-03-31T12:50:47Z", "type": "commit"}, {"oid": "2a1f2619d0fbf331ae875dfad5ece929cf7e5ea0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2a1f2619d0fbf331ae875dfad5ece929cf7e5ea0", "message": "Merge master", "committedDate": "2020-03-31T12:58:30Z", "type": "commit"}, {"oid": "0694fd668a2c985cf7b06d9951cfa9ddb4a3feca", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0694fd668a2c985cf7b06d9951cfa9ddb4a3feca", "message": "Implement failover in webSocket\n\nRemove additional changes\n\nRemove additional changes\n\nRemove additional changes", "committedDate": "2020-03-31T14:21:42Z", "type": "commit"}, {"oid": "2c828e11ef653a7f692749512bb62c5b6dc23036", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2c828e11ef653a7f692749512bb62c5b6dc23036", "message": "Fix conflict", "committedDate": "2020-03-31T15:02:48Z", "type": "commit"}, {"oid": "1d88bf18858fc74cfdd8221803c9e4d4cbf9dac8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1d88bf18858fc74cfdd8221803c9e4d4cbf9dac8", "message": "Fix language server core test\n\nFix language server core test\n\nFix language server core test\n\nAdd test inthe testng\n\nRemove unwanted changes", "committedDate": "2020-04-01T03:44:09Z", "type": "commit"}, {"oid": "9a9ec9beae6a6dbfd9f257a4c511c0a8fced6e96", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9a9ec9beae6a6dbfd9f257a4c511c0a8fced6e96", "message": "Merge https://github.com/ballerina-platform/ballerina-lang into webSocket_failover", "committedDate": "2020-04-01T06:00:35Z", "type": "commit"}, {"oid": "6017edc7a58857b54d20f0df6df3003a2e9fb621", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6017edc7a58857b54d20f0df6df3003a2e9fb621", "message": "Fix language server tests", "committedDate": "2020-04-01T06:37:09Z", "type": "commit"}]}