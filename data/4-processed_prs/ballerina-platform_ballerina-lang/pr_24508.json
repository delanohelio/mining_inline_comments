{"pr_number": 24508, "pr_title": "Refactor and use switch statements", "pr_createdAt": "2020-06-30T08:10:52Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/24508", "timeline": [{"oid": "c005391be7b384b4f8fa6a5f6232702902c19819", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c005391be7b384b4f8fa6a5f6232702902c19819", "message": "Use switch statements", "committedDate": "2020-06-30T10:34:10Z", "type": "forcePushed"}, {"oid": "9af3400b5ca13cc641615862e941bb0dc0343e5a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9af3400b5ca13cc641615862e941bb0dc0343e5a", "message": "Use switch statements", "committedDate": "2020-06-30T14:04:50Z", "type": "commit"}, {"oid": "9af3400b5ca13cc641615862e941bb0dc0343e5a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9af3400b5ca13cc641615862e941bb0dc0343e5a", "message": "Use switch statements", "committedDate": "2020-06-30T14:04:50Z", "type": "forcePushed"}, {"oid": "e3c76390d1fe89fea969ca45e2fff4a790857542", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e3c76390d1fe89fea969ca45e2fff4a790857542", "message": "Refactor unused method params and vars\n\nThis commit has the following fixes\n\n- Remove unused method parameters\n- Remove unused variables", "committedDate": "2020-07-01T06:55:11Z", "type": "commit"}, {"oid": "aa82d51019a7c0fb7fd70ee3eab4978fc7cdf53e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa82d51019a7c0fb7fd70ee3eab4978fc7cdf53e", "message": "Remove and refactor redundant else blocks", "committedDate": "2020-07-01T06:55:52Z", "type": "commit"}, {"oid": "aa82d51019a7c0fb7fd70ee3eab4978fc7cdf53e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/aa82d51019a7c0fb7fd70ee3eab4978fc7cdf53e", "message": "Remove and refactor redundant else blocks", "committedDate": "2020-07-01T06:55:52Z", "type": "forcePushed"}, {"oid": "ca9ab9ba06e4614fe16b9340155316da79893968", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca9ab9ba06e4614fe16b9340155316da79893968", "message": "Remove unused variables\n\nThis commit also merge duplicate switch cases in JvmTerminatorGen", "committedDate": "2020-07-01T08:36:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjE1MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24508#discussion_r449186150", "bodyText": "Shall we remove the commented code? We can add a Todo if needed about what to fix properly and remove the code. Anyone can see the code from git history right?", "author": "riyafa", "createdAt": "2020-07-02T18:04:03Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -310,122 +379,174 @@ private static void generateJToBCheckCast(MethodVisitor mv, BIRVarToJVMIndexMap\n \n         if (TypeTags.isIntegerTypeTag(targetType.tag)) {\n             generateCheckCastJToBInt(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.FLOAT) {\n-            generateCheckCastJToBFloat(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.DECIMAL) {\n-            generateCheckCastJToBDecimal(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BOOLEAN) {\n-            generateCheckCastJToBBoolean(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BYTE) {\n-            generateCheckCastJToBByte(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.NIL || targetType.tag == TypeTags.NEVER) {\n-            // Do nothing\n-        } else {\n-            if (targetType.tag == TypeTags.UNION) {\n-                generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n-            } else if (targetType.tag == TypeTags.ANYDATA) {\n-                generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.HANDLE) {\n-                generateJCastToBHandle(mv, sourceType);\n-            } else if (targetType.tag == TypeTags.ANY) {\n-                generateJCastToBAny(mv, indexMap, sourceType, targetType);\n-            } else if (targetType.tag == TypeTags.JSON) {\n-                generateCheckCastJToBJSON(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.FINITE) {\n-                generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n-                // TODO fix below properly - rajith\n-                //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n-                //    generateXMLToAttributesMap(mv, sourceType);\n-                //    return;\n-                //} else if (targetType is bir:BFiniteType) {\n-                //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n-                //    return;\n-                //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType && targetType.constraint\n-                // is bir:BTypeAny)) {\n-                //    // do nothing\n-            }\n+            return;\n+        }\n \n-            checkCast(mv, targetType);\n-            String targetTypeClass = getTargetClass(targetType);\n-            if (targetTypeClass != null) {\n-                mv.visitTypeInsn(CHECKCAST, targetTypeClass);\n-            }\n+        switch (targetType.tag) {\n+            case TypeTags.FLOAT:\n+                generateCheckCastJToBFloat(mv, sourceType);\n+                break;\n+            case TypeTags.DECIMAL:\n+                generateCheckCastJToBDecimal(mv, sourceType);\n+                break;\n+            case TypeTags.BOOLEAN:\n+                generateCheckCastJToBBoolean(mv, sourceType);\n+                break;\n+            case TypeTags.BYTE:\n+                generateCheckCastJToBByte(mv, sourceType);\n+                break;\n+            case TypeTags.NIL:\n+            case TypeTags.NEVER:\n+                // Do nothing\n+                break;\n+            default:\n+                switch (targetType.tag) {\n+                    case TypeTags.UNION:\n+                        generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n+                        break;\n+                    case TypeTags.ANYDATA:\n+                        generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.HANDLE:\n+                        generateJCastToBHandle(mv, sourceType);\n+                        break;\n+                    case TypeTags.ANY:\n+                        generateJCastToBAny(mv, indexMap, sourceType, targetType);\n+                        break;\n+                    case TypeTags.JSON:\n+                        generateCheckCastJToBJSON(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.FINITE:\n+                        generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n+                        // TODO fix below properly - rajith\n+                        //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n+                        //    generateXMLToAttributesMap(mv, sourceType);\n+                        //    return;\n+                        //} else if (targetType is bir:BFiniteType) {\n+                        //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n+                        //    return;\n+                        //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType &&\n+                        // targetType.constraint\n+                        // is bir:BTypeAny)) {\n+                        //    // do nothing", "originalCommit": "ca9ab9ba06e4614fe16b9340155316da79893968", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NjMyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24508#discussion_r449186328", "bodyText": "Shall we remove commented code?", "author": "riyafa", "createdAt": "2020-07-02T18:04:25Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/codegen/JvmCastGen.java", "diffHunk": "@@ -310,122 +379,174 @@ private static void generateJToBCheckCast(MethodVisitor mv, BIRVarToJVMIndexMap\n \n         if (TypeTags.isIntegerTypeTag(targetType.tag)) {\n             generateCheckCastJToBInt(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.FLOAT) {\n-            generateCheckCastJToBFloat(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.DECIMAL) {\n-            generateCheckCastJToBDecimal(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BOOLEAN) {\n-            generateCheckCastJToBBoolean(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.BYTE) {\n-            generateCheckCastJToBByte(mv, sourceType);\n-        } else if (targetType.tag == TypeTags.NIL || targetType.tag == TypeTags.NEVER) {\n-            // Do nothing\n-        } else {\n-            if (targetType.tag == TypeTags.UNION) {\n-                generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n-            } else if (targetType.tag == TypeTags.ANYDATA) {\n-                generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.HANDLE) {\n-                generateJCastToBHandle(mv, sourceType);\n-            } else if (targetType.tag == TypeTags.ANY) {\n-                generateJCastToBAny(mv, indexMap, sourceType, targetType);\n-            } else if (targetType.tag == TypeTags.JSON) {\n-                generateCheckCastJToBJSON(mv, indexMap, sourceType);\n-            } else if (targetType.tag == TypeTags.FINITE) {\n-                generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n-                // TODO fix below properly - rajith\n-                //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n-                //    generateXMLToAttributesMap(mv, sourceType);\n-                //    return;\n-                //} else if (targetType is bir:BFiniteType) {\n-                //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n-                //    return;\n-                //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType && targetType.constraint\n-                // is bir:BTypeAny)) {\n-                //    // do nothing\n-            }\n+            return;\n+        }\n \n-            checkCast(mv, targetType);\n-            String targetTypeClass = getTargetClass(targetType);\n-            if (targetTypeClass != null) {\n-                mv.visitTypeInsn(CHECKCAST, targetTypeClass);\n-            }\n+        switch (targetType.tag) {\n+            case TypeTags.FLOAT:\n+                generateCheckCastJToBFloat(mv, sourceType);\n+                break;\n+            case TypeTags.DECIMAL:\n+                generateCheckCastJToBDecimal(mv, sourceType);\n+                break;\n+            case TypeTags.BOOLEAN:\n+                generateCheckCastJToBBoolean(mv, sourceType);\n+                break;\n+            case TypeTags.BYTE:\n+                generateCheckCastJToBByte(mv, sourceType);\n+                break;\n+            case TypeTags.NIL:\n+            case TypeTags.NEVER:\n+                // Do nothing\n+                break;\n+            default:\n+                switch (targetType.tag) {\n+                    case TypeTags.UNION:\n+                        generateCheckCastJToBUnionType(mv, indexMap, sourceType, (BUnionType) targetType);\n+                        break;\n+                    case TypeTags.ANYDATA:\n+                        generateCheckCastJToBAnyData(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.HANDLE:\n+                        generateJCastToBHandle(mv, sourceType);\n+                        break;\n+                    case TypeTags.ANY:\n+                        generateJCastToBAny(mv, indexMap, sourceType, targetType);\n+                        break;\n+                    case TypeTags.JSON:\n+                        generateCheckCastJToBJSON(mv, indexMap, sourceType);\n+                        break;\n+                    case TypeTags.FINITE:\n+                        generateCheckCastJToBFiniteType(mv, indexMap, sourceType, targetType);\n+                        // TODO fix below properly - rajith\n+                        //} else if (sourceType is bir:BXMLType && targetType is bir:BMapType) {\n+                        //    generateXMLToAttributesMap(mv, sourceType);\n+                        //    return;\n+                        //} else if (targetType is bir:BFiniteType) {\n+                        //    generateCheckCastToFiniteType(mv, sourceType, targetType);\n+                        //    return;\n+                        //} else if (sourceType is bir:BRecordType && (targetType is bir:BMapType &&\n+                        // targetType.constraint\n+                        // is bir:BTypeAny)) {\n+                        //    // do nothing\n+                        break;\n+                }\n+\n+                checkCast(mv, targetType);\n+                String targetTypeClass = getTargetClass(targetType);\n+                if (targetTypeClass != null) {\n+                    mv.visitTypeInsn(CHECKCAST, targetTypeClass);\n+                }\n+                break;\n         }\n     }\n \n     private static void generateCheckCastJToBInt(MethodVisitor mv, JType sourceType) {\n \n-        if (sourceType.jTag == JTypeTags.JBYTE) {\n-            mv.visitInsn(I2B);\n-            mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"toUnsignedInt\", \"(B)I\", false);\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JCHAR) {\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JSHORT) {\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JINT) {\n-            mv.visitInsn(I2L);\n-        } else if (sourceType.jTag == JTypeTags.JLONG) {\n-            // do nothing\n-            // According to the spec doc, below two are not needed\n-            // } else if (sourceType is jvm:JFloat) {\n-            //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jFloatToBInt\", \"(F)J\", false);\n-            // } else if (sourceType is jvm:JDouble) {\n-            //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jDoubleToBInt\", \"(D)J\", false);\n-        } else if (sourceType.jTag == JTypeTags.JREF) {\n-            mv.visitMethodInsn(INVOKESTATIC, TYPE_CHECKER, \"anyToJLong\", String.format(\"(L%s;)J\", OBJECT), false);\n-        } else {\n-            throw new BLangCompilerException(String.format(\"Casting is not supported from '%s' to 'int'\", sourceType));\n+        switch (sourceType.jTag) {\n+            case JTypeTags.JBYTE:\n+                mv.visitInsn(I2B);\n+                mv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"toUnsignedInt\", \"(B)I\", false);\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JCHAR:\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JSHORT:\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JINT:\n+                mv.visitInsn(I2L);\n+                break;\n+            case JTypeTags.JLONG:\n+                // do nothing\n+                // According to the spec doc, below two are not needed\n+                // } else if (sourceType is jvm:JFloat) {\n+                //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jFloatToBInt\", \"(F)J\", false);\n+                // } else if (sourceType is jvm:JDouble) {\n+                //     mv.visitMethodInsn(INVOKESTATIC, TYPE_CONVERTER, \"jDoubleToBInt\", \"(D)J\", false);", "originalCommit": "ca9ab9ba06e4614fe16b9340155316da79893968", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7f7d76761e5016c7732dfa8be609e9abd7a6ab69", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7f7d76761e5016c7732dfa8be609e9abd7a6ab69", "message": "Remove commented out code segements", "committedDate": "2020-07-03T05:29:25Z", "type": "commit"}]}