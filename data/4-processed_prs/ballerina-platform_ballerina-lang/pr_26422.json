{"pr_number": 26422, "pr_title": "Revamp ballerina parser qualifier parsing", "pr_createdAt": "2020-10-20T07:32:16Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422", "timeline": [{"oid": "e9a833c63bbe30d56b50e0b9003ad369bb703204", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e9a833c63bbe30d56b50e0b9003ad369bb703204", "message": "Revamp BallerinaParser qualifier parsing\n\nGive methods performing qualifier based directions, self qualifier parsing capabilities thus allowing them to direct without worrying about the qualifiers.", "committedDate": "2020-10-16T15:45:44Z", "type": "commit"}, {"oid": "e65980c43249d1c3996138f475ab3ffcafddf311", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e65980c43249d1c3996138f475ab3ffcafddf311", "message": "Address added TODOs from the previous commit", "committedDate": "2020-10-19T20:41:29Z", "type": "commit"}, {"oid": "9c8f02d51a94db46bc715ea2bf99118b2016de48", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9c8f02d51a94db46bc715ea2bf99118b2016de48", "message": "Resolve readonly and distinct keyword parsing ambiguity", "committedDate": "2020-10-20T10:44:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0MDI5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r509040291", "bodyText": "Any reason for removing these test cases?", "author": "rdulmina", "createdAt": "2020-10-21T07:12:53Z", "path": "compiler/ballerina-parser/src/test/java/io/ballerinalang/compiler/parser/test/syntax/declarations/FunctionDefinitionTest.java", "diffHunk": "@@ -157,11 +157,6 @@ public void testFunctionWithInvalidExpressionStatement() {\n         testFile(\"func-definition/func_def_source_24.bal\", \"func-definition/func_def_assert_24.json\");\n     }\n \n-    @Test\n-    public void testMissingFunctionKeywordWithQualifiers() {\n-        testFile(\"func-definition/func_def_source_25.bal\", \"func-definition/func_def_assert_25.json\");\n-    }\n-", "originalCommit": "08f454d29c1915434bd00293fffc6514644af9c2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3NDk3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r509074970", "bodyText": "Now that parsing is independent of qualifiers\npublic isolated transcational foo(int i) returns boolean { }\nis equivalent to\npublic foo(int i) returns boolean { }\nRemoved the test cases(5 tests) which were previously recovered based on the preceding qualifiers with 5a1c5a8", "author": "lochana-chathura", "createdAt": "2020-10-21T08:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0MDI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3ODUyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r509078529", "bodyText": "Anyway consider following code snippet.\npublic foo() returns boolean { }\n\npublic foo(int i) returns boolean { }\nRecovery is\npublic  MISSING[function]foo() returns boolean { }\n\n INVALID[public] foo MISSING[error] MISSING[]( INVALID[int] i)  MISSING[;] MISSING[object] INVALID[returns]  INVALID[boolean] { } MISSING[] MISSING[;]\nin the current master.\nIt seems something is wrong with the recovery of functions with parameters\nAn issue created. #26460", "author": "lochana-chathura", "createdAt": "2020-10-21T08:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0MDI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE0MDUzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r509140538", "bodyText": "But I think it's better to keep them since they are valid test cases @SupunS WDYT?", "author": "rdulmina", "createdAt": "2020-10-21T09:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0MDI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY1NzgyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r510657824", "bodyText": "https://github.com/ballerina-platform/ballerina-lang/blob/70c5342829156da8525211726b1548d2ad018271/compiler/ballerina-parser/src/test/resources/types/func-type/func_type_source_10.bal\nhttps://github.com/ballerina-platform/ballerina-lang/blob/70c5342829156da8525211726b1548d2ad018271/compiler/ballerina-parser/src/test/resources/types/func-type/func_type_source_12.bal\n\nConsider above two test cases. They both same only different is qualifiers.  Also there are invalid tokens in between qualifiers in lot of places and now some of them match with the switch cases in the parsing methods and parser going haywire. Since those test cases no longer test any granular level recovery we don't need to keep them right?\n\nhttps://github.com/ballerina-platform/ballerina-lang/blob/70c5342829156da8525211726b1548d2ad018271/compiler/ballerina-parser/src/test/resources/declarations/isolated-object-methods/isolated_object_method_source_02.bal\nhttps://github.com/ballerina-platform/ballerina-lang/blob/master/compiler/ballerina-parser/src/test/resources/declarations/func-definition/func_def_source_25.bal\n\nAbove two test cases the same and they are broken due to #26460. I think adding one test case when fixing that issue would be sufficient.", "author": "lochana-chathura", "createdAt": "2020-10-23T06:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA0MDI5MQ=="}], "type": "inlineReview"}, {"oid": "6fab85d3455deb50777b730630c4d40d19cbc033", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6fab85d3455deb50777b730630c4d40d19cbc033", "message": "Clean up code", "committedDate": "2020-10-21T17:56:50Z", "type": "commit"}, {"oid": "74da4a495e9c6cd68c950a377b216d77eb9ecb00", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/74da4a495e9c6cd68c950a377b216d77eb9ecb00", "message": "Fix ResilientParserTest for class definition", "committedDate": "2020-10-22T04:53:38Z", "type": "commit"}, {"oid": "5a1c5a8fbc8a489e6aea9c4e4f2a0dc5ac26d14b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5a1c5a8fbc8a489e6aea9c4e4f2a0dc5ac26d14b", "message": "Remove outdated recovery test cases", "committedDate": "2020-10-22T05:01:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NDk3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r510554977", "bodyText": "Its fine to call this parseModuleVarDecl. The overloaded parameters will indicate this takes qualifiers from outside..", "author": "SupunS", "createdAt": "2020-10-23T02:08:30Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -739,111 +739,117 @@ private STNode parseImportPrefix() {\n     /**\n      * Parse top level node, given the modifier that precedes it.\n      *\n-     * @param qualifier Qualifier that precedes the top level node\n+     * @param metadata  Metadata that precedes the top level node\n+     * @param publicQualifier Public qualifier that precedes the top level node\n      * @return Parsed node\n      */\n-    private STNode parseTopLevelNode(STNode metadata, STNode qualifier) {\n+    private STNode parseTopLevelNode(STNode metadata, STNode publicQualifier) {\n+        List<STNode> topLevelQualifiers = new ArrayList<>();\n+        return parseTopLevelNode(metadata, publicQualifier, topLevelQualifiers);\n+    }\n+\n+    private STNode parseTopLevelNode(STNode metadata, STNode publicQualifier, List<STNode> qualifiers) {\n         STToken nextToken = peek();\n         switch (nextToken.kind) {\n             case EOF_TOKEN:\n-                reportInvalidQualifier(qualifier);\n                 reportInvalidMetaData(metadata);\n+                reportInvalidQualifier(publicQualifier);\n+                reportInvalidQualifierList(qualifiers);\n                 return null;\n-            case ISOLATED_KEYWORD:\n-            case CLIENT_KEYWORD:\n-                // Note that following top level nodes can have the isolated qualifier.\n-                // funcDef, funcType, classDef, objectType\n-                if (!isFuncDefOrFuncTypeStart()) {\n-                    if (isObjectTypeStart()) {\n-                        return parseModuleVarDecl(metadata, qualifier);\n-                    } else {\n-                        return parseClassDefinition(metadata, qualifier);\n-                    }\n-                }\n-                // Else fall through\n             case FUNCTION_KEYWORD:\n-            case TRANSACTIONAL_KEYWORD:\n                 // Anything starts with a function keyword could be a function definition\n                 // or a module-var-decl with function type desc.\n-                List<STNode> qualifiers = new ArrayList<>();\n-                if (qualifier != null) {\n-                    qualifiers.add(qualifier);\n+                if (publicQualifier != null) {\n+                    qualifiers.add(0, publicQualifier);\n                 }\n                 return parseFuncDefOrFuncTypeDesc(ParserRuleContext.TOP_LEVEL_FUNC_DEF_OR_FUNC_TYPE_DESC, metadata,\n                         qualifiers, false, false);\n             case TYPE_KEYWORD:\n-                return parseModuleTypeDefinition(metadata, getQualifier(qualifier));\n+                reportInvalidQualifierList(qualifiers);\n+                return parseModuleTypeDefinition(metadata, publicQualifier);\n             case CLASS_KEYWORD:\n-            case DISTINCT_KEYWORD:\n-            case READONLY_KEYWORD:\n-                return parseClassDefinition(metadata, getQualifier(qualifier));\n+                return parseClassDefinition(metadata, publicQualifier, qualifiers);\n             case LISTENER_KEYWORD:\n-                return parseListenerDeclaration(metadata, getQualifier(qualifier));\n+                reportInvalidQualifierList(qualifiers);\n+                return parseListenerDeclaration(metadata, publicQualifier);\n             case CONST_KEYWORD:\n-                return parseConstantDeclaration(metadata, getQualifier(qualifier));\n+                reportInvalidQualifierList(qualifiers);\n+                return parseConstantDeclaration(metadata, publicQualifier);\n             case ANNOTATION_KEYWORD:\n+                reportInvalidQualifierList(qualifiers);\n                 STNode constKeyword = STNodeFactory.createEmptyNode();\n-                return parseAnnotationDeclaration(metadata, getQualifier(qualifier), constKeyword);\n+                return parseAnnotationDeclaration(metadata, publicQualifier, constKeyword);\n             case IMPORT_KEYWORD:\n-                reportInvalidQualifier(qualifier);\n                 reportInvalidMetaData(metadata);\n+                reportInvalidQualifier(publicQualifier);\n+                reportInvalidQualifierList(qualifiers);\n                 return parseImportDecl();\n             case XMLNS_KEYWORD:\n-                reportInvalidQualifier(qualifier);\n                 reportInvalidMetaData(metadata);\n+                reportInvalidQualifier(publicQualifier);\n+                reportInvalidQualifierList(qualifiers);\n                 return parseXMLNamespaceDeclaration(true);\n             case FINAL_KEYWORD:\n-                reportInvalidQualifier(qualifier);\n+                reportInvalidQualifier(publicQualifier);\n+                reportInvalidQualifierList(qualifiers);\n                 STNode finalKeyword = parseFinalKeyword();\n                 return parseVariableDecl(metadata, finalKeyword, true);\n             case SERVICE_KEYWORD:\n                 if (isServiceDeclStart(ParserRuleContext.TOP_LEVEL_NODE, 1)) {\n-                    reportInvalidQualifier(qualifier);\n+                    reportInvalidQualifier(publicQualifier);\n+                    reportInvalidQualifierList(qualifiers);\n                     return parseServiceDecl(metadata);\n+                } else {\n+                    reportInvalidQualifierList(qualifiers);\n+                    return parseModuleVarDecl(metadata, publicQualifier);\n                 }\n-                return parseModuleVarDecl(metadata, qualifier);\n             case ENUM_KEYWORD:\n-                return parseEnumDeclaration(metadata, getQualifier(qualifier));\n+                reportInvalidQualifierList(qualifiers);\n+                return parseEnumDeclaration(metadata, publicQualifier);\n             case IDENTIFIER_TOKEN:\n                 // Here we assume that after recovering, we'll never reach here.\n                 // Otherwise the tokenOffset will not be 1.\n                 if (isModuleVarDeclStart(1)) {\n-                    return parseModuleVarDecl(metadata, qualifier);\n+                    reportInvalidQualifierList(qualifiers);\n+                    return parseModuleVarDecl(metadata, publicQualifier);\n                 }\n                 // fall through\n             default:\n+                if (isTopLevelQualifier(nextToken.kind)) {\n+                    // Top level qualifiers are present. Parse them first and then try to re-parse the method.\n+                    parseTopLevelQualifiers(qualifiers);\n+                    return parseTopLevelNode(metadata, publicQualifier, qualifiers);\n+                }\n+\n                 if (isTypeStartingToken(nextToken.kind) && nextToken.kind != SyntaxKind.IDENTIFIER_TOKEN) {\n-                    return parseModuleVarDecl(metadata, qualifier);\n+                    return parseModuleVarDeclWithoutQuals(metadata, publicQualifier, qualifiers);\n                 }\n \n                 STToken token = peek();\n-                Solution solution =\n-                        recover(token, ParserRuleContext.TOP_LEVEL_NODE_WITHOUT_MODIFIER, metadata, qualifier);\n+                Solution solution = recover(token, ParserRuleContext.TOP_LEVEL_NODE_WITHOUT_MODIFIER, metadata,\n+                        publicQualifier, qualifiers);\n \n                 if (solution.action == Action.KEEP) {\n                     // If the solution is {@link Action#KEEP}, that means next immediate token is\n                     // at the correct place, but some token after that is not. There only one such\n                     // cases here, which is the `case IDENTIFIER_TOKEN`. So accept it, and continue.\n-                    return parseModuleVarDecl(metadata, qualifier);\n+                    reportInvalidQualifierList(qualifiers);\n+                    return parseModuleVarDecl(metadata, publicQualifier);\n                 }\n \n-                return parseTopLevelNode(metadata, qualifier);\n+                return parseTopLevelNode(metadata, publicQualifier, qualifiers);\n         }\n-\n     }\n \n-    private boolean isObjectTypeStart() {\n-        return peek(2).kind == SyntaxKind.OBJECT_KEYWORD || peek(3).kind == SyntaxKind.OBJECT_KEYWORD;\n+    private STNode parseModuleVarDecl(STNode metadata, STNode qualifier) {\n+        List<STNode> topLevelQualifiers = new ArrayList<>();\n+        return parseModuleVarDeclWithoutQuals(metadata, qualifier, topLevelQualifiers);\n     }\n \n-    private STNode parseModuleVarDecl(STNode metadata, STNode qualifier) {\n+    private STNode parseModuleVarDeclWithoutQuals(STNode metadata, STNode qualifier, List<STNode> qualifiers) {", "originalCommit": "5a1c5a8fbc8a489e6aea9c4e4f2a0dc5ac26d14b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NTQ3Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r510555472", "bodyText": "Inverting the condition can avoid the nesting if's:\nif (isNodeListEmpty(annots)) {\n    return;\n}", "author": "SupunS", "createdAt": "2020-10-23T02:10:37Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -859,21 +865,122 @@ private void reportInvalidMetaData(STNode metadata) {\n         }\n     }\n \n-    /**\n-     * Parse access modifiers.\n-     *\n-     * @return Parsed node\n-     */\n-    private STNode parseQualifier() {\n-        STToken token = peek();\n-        if (token.kind == SyntaxKind.PUBLIC_KEYWORD) {\n-            return consume();\n-        } else {\n-            recover(token, ParserRuleContext.PUBLIC_KEYWORD);\n-            return parseQualifier();\n+    private void reportInvalidQualifierList(List<STNode> qualifiers) {\n+        for (STNode qual : qualifiers) {\n+            addInvalidNodeToNextToken(qual, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qual).text());\n+        }\n+    }\n+\n+    private void reportInvalidStatementAnnots(STNode annots, List<STNode> qualifiers) {\n+        if (!isNodeListEmpty(annots)) {", "originalCommit": "5a1c5a8fbc8a489e6aea9c4e4f2a0dc5ac26d14b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NjgyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r510556821", "bodyText": "Inverting the condition would be better", "author": "SupunS", "createdAt": "2020-10-23T02:16:37Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -899,10 +1006,70 @@ private STNode parseFuncDefinition(STNode metadata, boolean isObjectMember, STNo\n      */\n     private STNode parseFuncDefOrFuncTypeDesc(ParserRuleContext context, STNode metadata, List<STNode> qualifiers,\n                                               boolean isObjectMember, boolean isObjectTypeDesc) {\n-        STNode qualifierList = parseFunctionQualifiers(context, qualifiers);\n+        STNode qualifierList;\n+        // TODO: remove validation at this level when syncing to service-typing branch\n+        if (context == ParserRuleContext.TOP_LEVEL_FUNC_DEF_OR_FUNC_TYPE_DESC) {\n+            qualifierList = createFuncDefNodeList(qualifiers);\n+        } else {\n+            qualifierList = createMethodQualNodeList(qualifiers);\n+        }\n         return parseFuncDefOrFuncTypeDesc(metadata, qualifierList, isObjectMember, isObjectTypeDesc);\n     }\n \n+    private STNode createFuncDefNodeList(List<STNode> qualifierList) {\n+        // This method is temporary. Will be removed when syncing to service-typing branch\n+        // Validate qualifiers and create a STNodeList\n+        for (int i = 0; i < qualifierList.size();) {\n+            STNode qualifier = qualifierList.get(i);\n+            if (qualifier.kind != SyntaxKind.ISOLATED_KEYWORD &&", "originalCommit": "5a1c5a8fbc8a489e6aea9c4e4f2a0dc5ac26d14b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1ODY0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r510558640", "bodyText": "What if we move this, entirely before the switch-case, and only call parseTypeDescQualifiers(qualifiers);, (without the if-check and without the re-parse)?\ninside parseTypeDescQualifiers(qualifiers) we can have a while loop, rather than the do-while.", "author": "SupunS", "createdAt": "2020-10-23T02:24:27Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -1690,93 +1863,85 @@ private STNode validateForUsageOfVar(STNode typeDesc) {\n     /**\n      * <p>\n      * Parse a type descriptor, given the next token kind.\n+     * <br/>\n+     * Note that this method itself is capable of parsing type descriptor qualifiers\n+     * if they are not already parsed before coming here.\n      * </p>\n-     * If the preceding token is <code>?</code> then it is an optional type descriptor\n      *\n+     * @param qualifiers          Preceding type descriptor qualifiers\n      * @param context             Current context\n-     * @param isInConditionalExpr\n+     * @param isInConditionalExpr Whether in the conditional expression or not\n      * @return Parsed node\n      */\n-    private STNode parseTypeDescriptorInternal(ParserRuleContext context, boolean isInConditionalExpr) {\n+    private STNode parseTypeDescriptorInternal(List<STNode> qualifiers, ParserRuleContext context,\n+                                               boolean isInConditionalExpr) {\n         STToken nextToken = peek();\n         switch (nextToken.kind) {\n             case IDENTIFIER_TOKEN:\n+                reportInvalidQualifierList(qualifiers);\n                 return parseTypeReference(isInConditionalExpr);\n             case RECORD_KEYWORD:\n-                // Record type descriptor\n+                reportInvalidQualifierList(qualifiers);\n                 return parseRecordTypeDescriptor();\n-            case READONLY_KEYWORD:\n-                STToken nextNextToken = getNextNextToken(nextToken.kind);\n-                SyntaxKind nextNextTokenKind = nextNextToken.kind;\n-                if (nextNextTokenKind != SyntaxKind.OBJECT_KEYWORD &&\n-                        nextNextTokenKind != SyntaxKind.ABSTRACT_KEYWORD &&\n-                        nextNextTokenKind != SyntaxKind.CLIENT_KEYWORD) {\n-                    return parseSimpleTypeDescriptor();\n-                }\n-                // Allow `readonly` to be parsed as a object type qualifier and then log an error\n-                // Fall through\n             case OBJECT_KEYWORD:\n-            case ABSTRACT_KEYWORD: // Allow `abstract` to be parsed as an object type qualifier and then log an error\n-            case CLIENT_KEYWORD:\n-                return parseObjectTypeDescriptor();\n+                return parseObjectTypeDescriptor(qualifiers);\n             case OPEN_PAREN_TOKEN:\n+                reportInvalidQualifierList(qualifiers);\n                 return parseNilOrParenthesisedTypeDesc();\n             case MAP_KEYWORD: // map type desc\n             case FUTURE_KEYWORD: // future type desc\n+                reportInvalidQualifierList(qualifiers);\n                 return parseParameterizedTypeDescriptor();\n-            case TYPEDESC_KEYWORD: // typedesc type desc\n+            case TYPEDESC_KEYWORD:\n+                reportInvalidQualifierList(qualifiers);\n                 return parseTypedescTypeDescriptor();\n-            case ERROR_KEYWORD: // error type descriptor\n+            case ERROR_KEYWORD:\n+                reportInvalidQualifierList(qualifiers);\n                 return parseErrorTypeDescriptor();\n-            case XML_KEYWORD: // typedesc type desc\n+            case XML_KEYWORD:\n+                reportInvalidQualifierList(qualifiers);\n                 return parseXmlTypeDescriptor();\n-            case STREAM_KEYWORD: // stream type desc\n+            case STREAM_KEYWORD:\n+                reportInvalidQualifierList(qualifiers);\n                 return parseStreamTypeDescriptor();\n-            case TABLE_KEYWORD: // table type desc\n+            case TABLE_KEYWORD:\n+                reportInvalidQualifierList(qualifiers);\n                 return parseTableTypeDescriptor();\n             case FUNCTION_KEYWORD:\n-            case TRANSACTIONAL_KEYWORD:\n-                return parseFunctionTypeDesc();\n+                return parseFunctionTypeDesc(qualifiers);\n             case OPEN_BRACKET_TOKEN:\n+                reportInvalidQualifierList(qualifiers);\n                 return parseTupleTypeDesc();\n             case DISTINCT_KEYWORD:\n-                return parseDistinctTypeDesc(context);\n-            case ISOLATED_KEYWORD:\n-                if (isFuncDefOrFuncTypeStart()) {\n-                    return parseFunctionTypeDesc();\n-                } else {\n-                    return parseObjectTypeDescriptor();\n-                }\n+                reportInvalidQualifierList(qualifiers);\n+                STNode distinctKeyword = consume();\n+                return parseDistinctTypeDesc(distinctKeyword, context);\n             default:\n+                if (isTypeDescQualifier(nextToken.kind)) {\n+                    // Type desc qualifiers are present. Parse them first and then try to re-parse the method.\n+                    parseTypeDescQualifiers(qualifiers);\n+                    return parseTypeDescriptorInternal(qualifiers, context, isInConditionalExpr);\n+                }", "originalCommit": "5a1c5a8fbc8a489e6aea9c4e4f2a0dc5ac26d14b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1OTE1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r510559156", "bodyText": "Can do the same for top-level nodes as well", "author": "SupunS", "createdAt": "2020-10-23T02:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1ODY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1OTY2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r510559660", "bodyText": "Invert the condition. Let's do the early exit in all places", "author": "SupunS", "createdAt": "2020-10-23T02:28:50Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -2490,50 +2646,90 @@ private STNode parseClassDefinition(STNode metadata, STNode qualifier) {\n                 className, openBrace, classMembers, closeBrace);\n     }\n \n+    private boolean isClassTypeQual(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case CLIENT_KEYWORD:\n+            case READONLY_KEYWORD:\n+            case DISTINCT_KEYWORD:\n+            case ISOLATED_KEYWORD:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isObjectTypeQual(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case ISOLATED_KEYWORD:\n+            case CLIENT_KEYWORD:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n     /**\n-     * Parse class type qualifiers.\n+     * <p>\n+     * Validate and create class type qualifier node list.\n+     * </p>\n+     * <code> class-type-quals := (distinct | client | readonly | isolated)*</code>\n      *\n+     * @param qualifierList Qualifier list to be validated\n      * @return Parsed node\n      */\n-    private STNode parseClassTypeQualifiers() {\n-        List<STNode> qualifiers = new ArrayList<>();\n-        STNode qualifier;\n-        for (int i = 0; i < 4; i++) {\n-            STNode nextToken = peek();\n-            if (isNodeWithSyntaxKindInList(qualifiers, nextToken.kind)) {\n-                qualifier = consume();\n-                updateLastNodeInListOrAddInvalidNodeToNextToken(qualifiers, nextToken,\n-                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n+    private STNode createClassTypeQualNodeList(List<STNode> qualifierList) {\n+        // Validate qualifiers and create a STNodeList\n+        for (int i = 0; i < qualifierList.size();) {\n+            STNode qualifier = qualifierList.get(i);\n+            if (!isClassTypeQual(qualifier.kind)) {", "originalCommit": "5a1c5a8fbc8a489e6aea9c4e4f2a0dc5ac26d14b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MDIwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r510560203", "bodyText": "same here", "author": "SupunS", "createdAt": "2020-10-23T02:30:56Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -2490,50 +2646,90 @@ private STNode parseClassDefinition(STNode metadata, STNode qualifier) {\n                 className, openBrace, classMembers, closeBrace);\n     }\n \n+    private boolean isClassTypeQual(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case CLIENT_KEYWORD:\n+            case READONLY_KEYWORD:\n+            case DISTINCT_KEYWORD:\n+            case ISOLATED_KEYWORD:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    private boolean isObjectTypeQual(SyntaxKind tokenKind) {\n+        switch (tokenKind) {\n+            case ISOLATED_KEYWORD:\n+            case CLIENT_KEYWORD:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n     /**\n-     * Parse class type qualifiers.\n+     * <p>\n+     * Validate and create class type qualifier node list.\n+     * </p>\n+     * <code> class-type-quals := (distinct | client | readonly | isolated)*</code>\n      *\n+     * @param qualifierList Qualifier list to be validated\n      * @return Parsed node\n      */\n-    private STNode parseClassTypeQualifiers() {\n-        List<STNode> qualifiers = new ArrayList<>();\n-        STNode qualifier;\n-        for (int i = 0; i < 4; i++) {\n-            STNode nextToken = peek();\n-            if (isNodeWithSyntaxKindInList(qualifiers, nextToken.kind)) {\n-                qualifier = consume();\n-                updateLastNodeInListOrAddInvalidNodeToNextToken(qualifiers, nextToken,\n-                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n+    private STNode createClassTypeQualNodeList(List<STNode> qualifierList) {\n+        // Validate qualifiers and create a STNodeList\n+        for (int i = 0; i < qualifierList.size();) {\n+            STNode qualifier = qualifierList.get(i);\n+            if (!isClassTypeQual(qualifier.kind)) {\n+                qualifierList.remove(i);\n+                if (qualifierList.size() == i) {\n+                    addInvalidNodeToNextToken(qualifier, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED,\n+                            ((STToken) qualifier).text());\n+                } else {\n+                    STNode nextQual = qualifierList.remove(i);\n+                    nextQual = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(nextQual, qualifier,\n+                            DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text());\n+                    qualifierList.add(nextQual);\n+                }\n                 continue;\n             }\n-\n-            qualifier = parseSingleClassTypeQualifier();\n-            if (qualifier == null) {\n-                return STNodeFactory.createNodeList(qualifiers);\n-            }\n-\n-            qualifiers.add(qualifier);\n+            i++;\n         }\n \n-        return STNodeFactory.createNodeList(qualifiers);\n+        return STNodeFactory.createNodeList(qualifierList);\n     }\n \n-    private STNode parseSingleClassTypeQualifier() {\n-        STToken nextToken = peek();\n-        switch (nextToken.kind) {\n-            case CLIENT_KEYWORD:\n-            case READONLY_KEYWORD:\n-            case DISTINCT_KEYWORD:\n-            case ISOLATED_KEYWORD:\n-                return consume();\n-            case CLASS_KEYWORD:\n-            case EOF_TOKEN:\n-                // null indicates the end of qualifiers\n-                return null;\n-            default:\n-                recover(nextToken, ParserRuleContext.MODULE_CLASS_DEFINITION_START);\n-                return parseSingleClassTypeQualifier();\n+    /**\n+     * <p>\n+     * Validate and create object type qualifier node list.\n+     * </p>\n+     * <code> object-type-quals := (client | isolated)*</code>\n+     *\n+     * @param qualifierList Qualifier list to be validated\n+     * @return Parsed node\n+     */\n+    private STNode createObjectTypeQualNodeList(List<STNode> qualifierList) {\n+        // Validate qualifiers and create a STNodeList\n+        for (int i = 0; i < qualifierList.size();) {\n+            STNode qualifier = qualifierList.get(i);\n+            if (!isObjectTypeQual(qualifier.kind)) {", "originalCommit": "5a1c5a8fbc8a489e6aea9c4e4f2a0dc5ac26d14b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU2MjAyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26422#discussion_r510562023", "bodyText": "Better to extract this logic inside the 'if-condition' to a separate method, something like isValidMethodQualifier", "author": "SupunS", "createdAt": "2020-10-23T02:39:16Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -899,10 +1006,70 @@ private STNode parseFuncDefinition(STNode metadata, boolean isObjectMember, STNo\n      */\n     private STNode parseFuncDefOrFuncTypeDesc(ParserRuleContext context, STNode metadata, List<STNode> qualifiers,\n                                               boolean isObjectMember, boolean isObjectTypeDesc) {\n-        STNode qualifierList = parseFunctionQualifiers(context, qualifiers);\n+        STNode qualifierList;\n+        // TODO: remove validation at this level when syncing to service-typing branch\n+        if (context == ParserRuleContext.TOP_LEVEL_FUNC_DEF_OR_FUNC_TYPE_DESC) {\n+            qualifierList = createFuncDefNodeList(qualifiers);\n+        } else {\n+            qualifierList = createMethodQualNodeList(qualifiers);\n+        }\n         return parseFuncDefOrFuncTypeDesc(metadata, qualifierList, isObjectMember, isObjectTypeDesc);\n     }\n \n+    private STNode createFuncDefNodeList(List<STNode> qualifierList) {\n+        // This method is temporary. Will be removed when syncing to service-typing branch\n+        // Validate qualifiers and create a STNodeList\n+        for (int i = 0; i < qualifierList.size();) {\n+            STNode qualifier = qualifierList.get(i);\n+            if (qualifier.kind != SyntaxKind.ISOLATED_KEYWORD &&\n+                    qualifier.kind != SyntaxKind.TRANSACTIONAL_KEYWORD &&\n+                    qualifier.kind != SyntaxKind.PUBLIC_KEYWORD) {\n+                qualifierList.remove(i);\n+                if (qualifierList.size() == i) {\n+                    addInvalidNodeToNextToken(qualifier, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED,\n+                            ((STToken) qualifier).text());\n+                } else {\n+                    STNode nextQual = qualifierList.remove(i);\n+                    nextQual = SyntaxErrors.cloneWithLeadingInvalidNodeMinutiae(nextQual, qualifier,\n+                            DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED, ((STToken) qualifier).text());\n+                    qualifierList.add(nextQual);\n+                }\n+                continue;\n+            }\n+            i++;\n+        }\n+\n+        return STNodeFactory.createNodeList(qualifierList);\n+    }\n+\n+    private STNode createMethodQualNodeList(List<STNode> qualifierList) {\n+        // This method is temporary. Will be removed when syncing to service-typing branch\n+        // Validate qualifiers and create a STNodeList\n+        for (int i = 0; i < qualifierList.size();) {\n+            STNode qualifier = qualifierList.get(i);\n+            if (qualifier.kind != SyntaxKind.ISOLATED_KEYWORD &&\n+                    qualifier.kind != SyntaxKind.TRANSACTIONAL_KEYWORD &&\n+                    qualifier.kind != SyntaxKind.REMOTE_KEYWORD &&\n+                    qualifier.kind != SyntaxKind.PUBLIC_KEYWORD &&\n+                    qualifier.kind != SyntaxKind.PRIVATE_KEYWORD) {", "originalCommit": "5a1c5a8fbc8a489e6aea9c4e4f2a0dc5ac26d14b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "eeac0cf95c0bd2a48ad37f8d087a2e5121734b3a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eeac0cf95c0bd2a48ad37f8d087a2e5121734b3a", "message": "Add review changes", "committedDate": "2020-10-23T05:58:09Z", "type": "commit"}, {"oid": "c9195a717f5d38a3fee3220ff5a022735b461a9e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c9195a717f5d38a3fee3220ff5a022735b461a9e", "message": "Remove/update outdated recovery test cases", "committedDate": "2020-10-23T05:58:27Z", "type": "commit"}, {"oid": "c9195a717f5d38a3fee3220ff5a022735b461a9e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c9195a717f5d38a3fee3220ff5a022735b461a9e", "message": "Remove/update outdated recovery test cases", "committedDate": "2020-10-23T05:58:27Z", "type": "forcePushed"}]}