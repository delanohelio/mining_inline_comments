{"pr_number": 20541, "pr_title": "Add observability (metrics and tracing) to Kafka connector", "pr_createdAt": "2020-01-07T08:54:23Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541", "timeline": [{"oid": "05eed3df9a6b72d1a85a09a9bfc7844ed20224fc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/05eed3df9a6b72d1a85a09a9bfc7844ed20224fc", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into kafka-observability", "committedDate": "2020-01-08T09:49:40Z", "type": "forcePushed"}, {"oid": "23fc14a844b861aaa296b4bfbe8c5cc473faa755", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/23fc14a844b861aaa296b4bfbe8c5cc473faa755", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-08T09:52:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MDk4Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365560986", "bodyText": "Is NATIVE_CONSUMER_CONFIG always present? Cause otherwise, getNativeData can return Null. Therefore possible NPE.", "author": "grainier", "createdAt": "2020-01-12T06:34:04Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "diffHunk": "@@ -59,8 +70,9 @@ public KafkaListenerImpl(Strand strand, ObjectValue listener, ObjectValue servic\n     @Override\n     public void onRecordsReceived(ConsumerRecords records, KafkaConsumer kafkaConsumer, String groupId) {\n         listener.addNativeData(NATIVE_CONSUMER, kafkaConsumer);\n-        Executor.submit(this.scheduler, service, KAFKA_RESOURCE_ON_MESSAGE, callback,\n-                null, getResourceParameters(service, this.listener, records, groupId));\n+        String url = ((Properties) listener.getNativeData(NATIVE_CONSUMER_CONFIG)).getProperty(BOOTSTRAP_SERVERS);", "originalCommit": "23fc14a844b861aaa296b4bfbe8c5cc473faa755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MTA4OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365561088", "bodyText": "Why this line has to repeat all the time? Can't we resolve URL at the init and then re-use it?", "author": "grainier", "createdAt": "2020-01-12T06:37:13Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "diffHunk": "@@ -83,6 +95,38 @@ public void onRecordsReceived(ConsumerRecords records,\n     @Override\n     public void onError(Throwable throwable) {\n         logger.error(\"Kafka Ballerina server connector retrieved exception: \" + throwable.getMessage(), throwable);\n+        String url = ((Properties) listener.getNativeData(NATIVE_CONSUMER_CONFIG)).getProperty(BOOTSTRAP_SERVERS);", "originalCommit": "23fc14a844b861aaa296b4bfbe8c5cc473faa755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MTM1NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365561354", "bodyText": "This is repeated in 120-125. Can't we refactor?", "author": "grainier", "createdAt": "2020-01-12T06:45:07Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/impl/KafkaListenerImpl.java", "diffHunk": "@@ -83,6 +95,38 @@ public void onRecordsReceived(ConsumerRecords records,\n     @Override\n     public void onError(Throwable throwable) {\n         logger.error(\"Kafka Ballerina server connector retrieved exception: \" + throwable.getMessage(), throwable);\n+        String url = ((Properties) listener.getNativeData(NATIVE_CONSUMER_CONFIG)).getProperty(BOOTSTRAP_SERVERS);\n+        KafkaMetricsUtil.reportConsumerError(url, KafkaObservabilityConstants.ERROR_TYPE_MSG_RECEIVED);\n+    }\n+\n+    private void executeResource(String url, ConsumerRecords records, String groupId) {\n+        if (ObserveUtils.isTracingEnabled()) {\n+            Map<String, Object> properties = new HashMap<>();\n+            KafkaObserverContext observerContext = new KafkaObserverContext(\n+                    KafkaObservabilityConstants.CONTEXT_CONSUMER, url);\n+            properties.put(ObservabilityConstants.KEY_OBSERVER_CONTEXT, observerContext);\n+            Executor.submit(this.scheduler, service, KAFKA_RESOURCE_ON_MESSAGE, callback,\n+                            properties, getResourceParameters(service, this.listener, records, groupId));", "originalCommit": "23fc14a844b861aaa296b4bfbe8c5cc473faa755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTU2MTU3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r365561571", "bodyText": "Declare with interface (or super) type.", "author": "grainier", "createdAt": "2020-01-12T06:49:53Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/Assign.java", "diffHunk": "@@ -41,11 +46,14 @@\n     private static final Logger logger = LoggerFactory.getLogger(Assign.class);\n \n     public static Object assign(ObjectValue consumerObject, ArrayValue topicPartitions) {\n+        String bootstrapServers = KafkaUtils.getBootstrapServers(consumerObject);\n+        KafkaTracingUtil.traceResourceInvocation(Scheduler.getStrand(), bootstrapServers);\n         KafkaConsumer<byte[], byte[]> kafkaConsumer = (KafkaConsumer) consumerObject.getNativeData(NATIVE_CONSUMER);\n         ArrayList<TopicPartition> partitions = getTopicPartitionList(topicPartitions, logger);", "originalCommit": "23fc14a844b861aaa296b4bfbe8c5cc473faa755", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a62e9877d1b606a8d0227f1fb097dd58918b04f4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a62e9877d1b606a8d0227f1fb097dd58918b04f4", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-13T05:34:32Z", "type": "forcePushed"}, {"oid": "495d5f1f92d833cdebfdd986c5470289ee92cb47", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/495d5f1f92d833cdebfdd986c5470289ee92cb47", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-13T05:47:19Z", "type": "forcePushed"}, {"oid": "eb0c4d08a3da553ca61d23bdaff916fd1f64ba8f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/eb0c4d08a3da553ca61d23bdaff916fd1f64ba8f", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-13T06:09:14Z", "type": "forcePushed"}, {"oid": "67338734d987580144b7c58daa78a3176925d414", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/67338734d987580144b7c58daa78a3176925d414", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-13T06:15:38Z", "type": "forcePushed"}, {"oid": "b03ab6c782a7f44878926a72bb6639c4a77a3bd3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b03ab6c782a7f44878926a72bb6639c4a77a3bd3", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-13T07:41:40Z", "type": "forcePushed"}, {"oid": "edbad225b205e517825119ded44a06483595d436", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/edbad225b205e517825119ded44a06483595d436", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-14T06:11:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MTU5OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367771599", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(Close.class);\n          \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(CommitOffset.class);", "author": "chamil321", "createdAt": "2020-01-17T05:10:11Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/CommitOffset.java", "diffHunk": "@@ -49,6 +53,7 @@\n     private static final Logger logger = LoggerFactory.getLogger(Close.class);", "originalCommit": "edbad225b205e517825119ded44a06483595d436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MTg2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367771868", "bodyText": "Indentation issue?", "author": "chamil321", "createdAt": "2020-01-17T05:11:43Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/Connect.java", "diffHunk": "@@ -46,16 +51,23 @@ public static Object connect(ObjectValue consumerObject) {\n         // Check whether already native consumer is attached to the struct.\n         // This can be happen either from Kafka service or via programmatically.\n         if (Objects.nonNull(consumerObject.getNativeData(NATIVE_CONSUMER))) {\n+            KafkaMetricsUtil.reportConsumerError(consumerObject, KafkaObservabilityConstants.ERROR_TYPE_CONNECTION);\n             return createKafkaError(\"Kafka consumer is already connected to external broker. \" +\n-                    \"Please close it before re-connecting the external broker again.\", CONSUMER_ERROR);\n+                                            \"Please close it before re-connecting the external broker again.\",", "originalCommit": "edbad225b205e517825119ded44a06483595d436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MzczNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367773737", "bodyText": "Ideally the method should be changed to avoid getting Strand as a parameter.", "author": "chamil321", "createdAt": "2020-01-17T05:22:17Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "diffHunk": "@@ -68,16 +71,19 @@\n \n     public static Object subscribeWithPartitionRebalance(Strand strand, ObjectValue consumerObject, ArrayValue topics,", "originalCommit": "edbad225b205e517825119ded44a06483595d436", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NDMwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367774308", "bodyText": "This should have been done during the kafka - Java interop task. Must have missed", "author": "chamil321", "createdAt": "2020-01-17T05:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MzczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgwMTcyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367801727", "bodyText": "This is not changed due to we cannot pass function pointers to an inter-op function (at least then). @aashikam", "author": "ThisaruGuruge", "createdAt": "2020-01-17T07:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3MzczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3Mzg4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367773885", "bodyText": "use Scheduler.getStrand() here as well. The parameter should be avoided", "author": "chamil321", "createdAt": "2020-01-17T05:23:05Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/nativeimpl/consumer/SubscribeWithPartitionRebalance.java", "diffHunk": "@@ -68,16 +71,19 @@\n \n     public static Object subscribeWithPartitionRebalance(Strand strand, ObjectValue consumerObject, ArrayValue topics,\n                                                          FPValue onPartitionsRevoked, FPValue onPartitionsAssigned) {\n-\n+        KafkaTracingUtil.traceResourceInvocation(Scheduler.getStrand(), consumerObject);\n         NonBlockingCallback callback = new NonBlockingCallback(strand);", "originalCommit": "edbad225b205e517825119ded44a06483595d436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NDc3NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367774774", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Reports a new producer connection.\n          \n          \n            \n                 * Reports a new consumer connection.", "author": "chamil321", "createdAt": "2020-01-17T05:28:05Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka. connector\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new producer connection.", "originalCommit": "edbad225b205e517825119ded44a06483595d436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NzE1Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367777152", "bodyText": "Shall we created separate method for unsetGauge rather having a integer parameter to distinguish the logic?\nIt is more clearer and consistent with other methods.", "author": "chamil321", "createdAt": "2020-01-17T05:42:06Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka. connector\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],", "originalCommit": "edbad225b205e517825119ded44a06483595d436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3NzgyMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367777822", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Constants for NATS Observability.\n          \n          \n            \n             * Constants for Kafka Observability.", "author": "chamil321", "createdAt": "2020-01-17T05:46:06Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObservabilityConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+/**\n+ * Constants for NATS Observability.", "originalCommit": "edbad225b205e517825119ded44a06483595d436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzc3Nzk0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367777947", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Extension of ObserverContext for NATS.\n          \n          \n            \n             * Extension of ObserverContext for Kafka.", "author": "chamil321", "createdAt": "2020-01-17T05:46:49Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObserverContext.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.ballerinalang.jvm.observability.ObserverContext;\n+import org.ballerinalang.jvm.observability.metrics.Tag;\n+import org.ballerinalang.jvm.observability.metrics.Tags;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Extension of ObserverContext for NATS.", "originalCommit": "edbad225b205e517825119ded44a06483595d436", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dff95d227db71e659b3a9f90678ee7c3d50076f5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dff95d227db71e659b3a9f90678ee7c3d50076f5", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-17T11:01:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NTkxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367885917", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "author": "wggihan", "createdAt": "2020-01-17T11:13:40Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.1.0", "originalCommit": "dff95d227db71e659b3a9f90678ee7c3d50076f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NjUzNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367886535", "bodyText": "Extra line.", "author": "wggihan", "createdAt": "2020-01-17T11:15:25Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+", "originalCommit": "dff95d227db71e659b3a9f90678ee7c3d50076f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4Njg5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367886897", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Reports a consumer consuming a message.\n          \n          \n            \n                 * Reports a message consumption of the consumer.", "author": "wggihan", "createdAt": "2020-01-17T11:16:20Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,373 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.1.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+\n+    }\n+\n+    /**\n+     * Reports a consumer consuming a message.", "originalCommit": "dff95d227db71e659b3a9f90678ee7c3d50076f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NzYwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367887607", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "author": "wggihan", "createdAt": "2020-01-17T11:18:10Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObservabilityConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+/**\n+ * Constants for Kafka Observability.\n+ *\n+ * @since 1.1.0", "originalCommit": "dff95d227db71e659b3a9f90678ee7c3d50076f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4Nzc0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367887742", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "author": "wggihan", "createdAt": "2020-01-17T11:18:35Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaObserverContext.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.ballerinalang.jvm.observability.ObserverContext;\n+import org.ballerinalang.jvm.observability.metrics.Tag;\n+import org.ballerinalang.jvm.observability.metrics.Tags;\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Extension of ObserverContext for Kafka.\n+ *\n+ * @since 1.1.0", "originalCommit": "dff95d227db71e659b3a9f90678ee7c3d50076f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg4NzkzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367887936", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 1.1.0\n          \n          \n            \n             * @since 1.2.0", "author": "wggihan", "createdAt": "2020-01-17T11:19:06Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaTracingUtil.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.ObserverContext;\n+import org.ballerinalang.jvm.scheduling.Strand;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Providing tracing functionality to Kafka.\n+ *\n+ * @since 1.1.0", "originalCommit": "dff95d227db71e659b3a9f90678ee7c3d50076f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg5MDY4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367890680", "bodyText": "Don't catch NPE. Handle null value. Apply to other places as well.", "author": "wggihan", "createdAt": "2020-01-17T11:26:19Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/utils/KafkaUtils.java", "diffHunk": "@@ -689,4 +695,34 @@ public static String getBrokerNames(ObjectValue listener) {\n     public static String getTopicNamesString(ArrayList<String> topicsList) {\n         return String.join(\", \", topicsList);\n     }\n+\n+    public static String getClientIdFromProperties(Properties properties) {\n+        String clientId = properties.getProperty(KafkaConstants.CLIENT_ID);\n+        if (clientId == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return  clientId;\n+    }\n+\n+    public static String getBootstrapServers(ObjectValue object) {\n+        try {\n+            return (String) object.getNativeData(KafkaConstants.BOOTSTRAP_SERVERS);\n+        } catch (NullPointerException ex) {", "originalCommit": "dff95d227db71e659b3a9f90678ee7c3d50076f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "686745345044b18037d8f38ab3480fab94f4dfa1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/686745345044b18037d8f38ab3480fab94f4dfa1", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-17T11:33:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzMDI3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r367930279", "bodyText": "Extra line.", "author": "wggihan", "createdAt": "2020-01-17T13:17:57Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/utils/KafkaUtils.java", "diffHunk": "@@ -689,4 +695,39 @@ public static String getBrokerNames(ObjectValue listener) {\n     public static String getTopicNamesString(ArrayList<String> topicsList) {\n         return String.join(\", \", topicsList);\n     }\n+\n+    public static String getClientIdFromProperties(Properties properties) {\n+        if (properties == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        String clientId = properties.getProperty(KafkaConstants.CLIENT_ID);\n+        if (clientId == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return  clientId;\n+    }\n+\n+    public static String getBootstrapServers(ObjectValue object) {\n+        if (object == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        String bootstrapServers = (String) object.getNativeData(KafkaConstants.BOOTSTRAP_SERVERS);\n+        if (bootstrapServers == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return bootstrapServers;\n+    }\n+\n+    public static String getClientId(ObjectValue object) {\n+        if (object == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        String clientId = (String) object.getNativeData(KafkaConstants.CLIENT_ID);\n+        if (clientId == null) {\n+            return KafkaObservabilityConstants.UNKNOWN;\n+        }\n+        return clientId;\n+    }\n+", "originalCommit": "686745345044b18037d8f38ab3480fab94f4dfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NjI4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r368266284", "bodyText": "Extra empty line?", "author": "ThisaruGuruge", "createdAt": "2020-01-19T05:07:29Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.2.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+    }\n+\n+    /**\n+     * Reports a message consumption of a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer receives the message from.\n+     * @param size              Size of the message in bytes.\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        reportConsume(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer consuming a record of messages.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param records           Records\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, ConsumerRecords records) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        records.forEach(record -> {\n+            KafkaMetricsUtil.reportConsume(consumerObject, ((ConsumerRecord) record).topic(),\n+                                           ((ConsumerRecord) record).serializedValueSize());\n+        });\n+    }\n+\n+", "originalCommit": "686745345044b18037d8f38ab3480fab94f4dfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2NjI5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/20541#discussion_r368266294", "bodyText": "Extra empty line?", "author": "ThisaruGuruge", "createdAt": "2020-01-19T05:07:55Z", "path": "stdlib/messaging/kafka/src/main/java/org/ballerinalang/messaging/kafka/observability/KafkaMetricsUtil.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.ballerinalang.messaging.kafka.observability;\n+\n+import org.apache.kafka.clients.consumer.ConsumerRecord;\n+import org.apache.kafka.clients.consumer.ConsumerRecords;\n+import org.ballerinalang.jvm.observability.ObserveUtils;\n+import org.ballerinalang.jvm.observability.metrics.DefaultMetricRegistry;\n+import org.ballerinalang.jvm.observability.metrics.MetricId;\n+import org.ballerinalang.jvm.observability.metrics.MetricRegistry;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.messaging.kafka.utils.KafkaUtils;\n+\n+import java.util.Set;\n+\n+/**\n+ * Providing metrics functionality to the Kafka connector.\n+ *\n+ * @since 1.2.0\n+ */\n+public class KafkaMetricsUtil {\n+\n+    private static final MetricRegistry metricRegistry = DefaultMetricRegistry.getInstance();\n+\n+    /**\n+     * Reports a new producer connection.\n+     *\n+     * @param producerObject producerObject.\n+     */\n+    public static void reportNewProducer(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a new consumer connection.\n+     *\n+     * @param consumerObject consumer object\n+     */\n+    public static void reportNewConsumer(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        incrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a producer disconnection.\n+     *\n+     * @param producerObject producer object.\n+     */\n+    public static void reportProducerClose(ObjectValue producerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHERS[0],\n+                       KafkaObservabilityConstants.METRIC_PUBLISHERS[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer close.\n+     *\n+     * @param consumerObject consumer object.\n+     */\n+    public static void reportConsumerClose(ObjectValue consumerObject) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject));\n+        decrementGauge(observerContext, KafkaObservabilityConstants.METRIC_CONSUMERS[0],\n+                       KafkaObservabilityConstants.METRIC_CONSUMERS[1]);\n+    }\n+\n+    /**\n+     * Reports a message being published by a Kafka producer.\n+     *\n+     * @param producerObject  producer object.\n+     * @param topic Subject the message is published to.\n+     * @param size  Size in bytes of the message.\n+     */\n+    public static void reportPublish(ObjectValue producerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_PRODUCER,\n+                                                                        KafkaUtils.getClientId(producerObject),\n+                                                                        KafkaUtils.getBootstrapServers(producerObject),\n+                                                                        topic);\n+        reportPublish(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer subscribing to a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topicsList        List of topics that the consumer subscribes to.\n+     */\n+    public static void reportBulkSubscription(ObjectValue consumerObject, Set<String> topicsList) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String topic : topicsList) {\n+            reportSubscription(consumerObject, topic);\n+        }\n+    }\n+\n+\n+    /**\n+     * Reports a consumer subscribing to a topic.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Topic that the consumer subscribes to.\n+     */\n+    public static void reportSubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        setGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1], 1);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from a subject.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer unsubscribes from.\n+     */\n+    public static void reportUnsubscription(ObjectValue consumerObject, String topic) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        resetGauge(observerContext, KafkaObservabilityConstants.METRIC_SUBSCRIPTION[0],\n+                       KafkaObservabilityConstants.METRIC_SUBSCRIPTION[1]);\n+    }\n+\n+    /**\n+     * Reports a consumer unsubscribing from multiple topics.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topics            Subjects that the consumer unsubscribes from.\n+     */\n+    public static void reportBulkUnsubscription(ObjectValue consumerObject, Set<String> topics) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        for (String subject : topics) {\n+            KafkaMetricsUtil.reportUnsubscription(consumerObject, subject);\n+        }\n+    }\n+\n+    /**\n+     * Reports a message consumption of a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer receives the message from.\n+     * @param size              Size of the message in bytes.\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, String topic, int size) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        KafkaObserverContext observerContext = new KafkaObserverContext(KafkaObservabilityConstants.CONTEXT_CONSUMER,\n+                                                                        KafkaUtils.getClientId(consumerObject),\n+                                                                        KafkaUtils.getBootstrapServers(consumerObject),\n+                                                                        topic);\n+        reportConsume(observerContext, size);\n+    }\n+\n+    /**\n+     * Reports a consumer consuming a record of messages.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param records           Records\n+     */\n+    public static void reportConsume(ObjectValue consumerObject, ConsumerRecords records) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        records.forEach(record -> {\n+            KafkaMetricsUtil.reportConsume(consumerObject, ((ConsumerRecord) record).topic(),\n+                                           ((ConsumerRecord) record).serializedValueSize());\n+        });\n+    }\n+\n+\n+    /**\n+     * Reports an error generated by a producer. This method is called when the URL/subject of the current producer is\n+     * unknown. e.g. when a Kafka connection doesn't exist for a producer.\n+     *\n+     * @param producerObject    Producer object.\n+     * @param errorType         Type of the error.\n+     */\n+    public static void reportProducerError(ObjectValue producerObject, String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(KafkaObservabilityConstants.CONTEXT_PRODUCER, producerObject, errorType);\n+    }\n+\n+    /**\n+     * Reports an error generated by a consumer. This method is called when the URL/subject of the current consumer is\n+     * unknown. e.g. when a Kafka connection doesn't exist for a consumer.\n+     *\n+     * @param errorType type of the error.\n+     */\n+    public static void reportConsumerError(String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(KafkaObservabilityConstants.CONTEXT_CONSUMER, errorType);\n+    }\n+\n+    /**\n+     * Reports an error generated by a consumer. This method is called when the URL/subject of the current consumer is\n+     * unknown. e.g. when a Kafka connection doesn't exist for a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param errorType         Type of the error.\n+     */\n+    public static void reportConsumerError(ObjectValue consumerObject, String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(KafkaObservabilityConstants.CONTEXT_CONSUMER, consumerObject, errorType);\n+    }\n+\n+    /**\n+     * Reports an error generated by a consumer.\n+     *\n+     * @param consumerObject    Consumer object.\n+     * @param topic             Subject that the consumer is subscribed to.\n+     * @param errorType         Type of the error.\n+     */\n+    public static void reportConsumerError(ObjectValue consumerObject, String topic, String errorType) {\n+        if (!ObserveUtils.isMetricsEnabled()) {\n+            return;\n+        }\n+        reportError(consumerObject, topic, KafkaObservabilityConstants.CONTEXT_CONSUMER, errorType);\n+    }\n+\n+    private static void reportPublish(KafkaObserverContext observerContext, int size) {\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHED[0],\n+                         KafkaObservabilityConstants.METRIC_PUBLISHED[1]);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_PUBLISHED_SIZE[0],\n+                         KafkaObservabilityConstants.METRIC_PUBLISHED_SIZE[1], size);\n+    }\n+\n+    private static void reportConsume(KafkaObserverContext observerContext, int size) {\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_CONSUMED[0],\n+                         KafkaObservabilityConstants.METRIC_CONSUMED[1]);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_CONSUMED_SIZE[0],\n+                         KafkaObservabilityConstants.METRIC_CONSUMED_SIZE[1], size);\n+    }\n+\n+    public static void reportError(String context, String errorType) {\n+        KafkaObserverContext observerContext = new KafkaObserverContext(context);\n+        observerContext.addTag(KafkaObservabilityConstants.TAG_ERROR_TYPE, errorType);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_ERRORS[0],\n+                         KafkaObservabilityConstants.METRIC_ERRORS[1]);\n+    }\n+\n+    public static void reportError(String context, ObjectValue object, String errorType) {\n+        KafkaObserverContext observerContext = new KafkaObserverContext(context,\n+                                                                        KafkaUtils.getClientId(object),\n+                                                                        KafkaUtils.getBootstrapServers(object));\n+        observerContext.addTag(KafkaObservabilityConstants.TAG_ERROR_TYPE, errorType);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_ERRORS[0],\n+                         KafkaObservabilityConstants.METRIC_ERRORS[1]);\n+    }\n+\n+    public static void reportError(ObjectValue object, String topic, String context, String errorType) {\n+        KafkaObserverContext observerContext = new KafkaObserverContext(context,\n+                                                                        KafkaUtils.getClientId(object),\n+                                                                        KafkaUtils.getBootstrapServers(object),\n+                                                                        topic);\n+        observerContext.addTag(KafkaObservabilityConstants.TAG_ERROR_TYPE, errorType);\n+        incrementCounter(observerContext, KafkaObservabilityConstants.METRIC_ERRORS[0],\n+                         KafkaObservabilityConstants.METRIC_ERRORS[1]);\n+    }\n+\n+    private static void incrementCounter(KafkaObserverContext observerContext, String name, String desc) {\n+        incrementCounter(observerContext, name, desc, 1);\n+    }\n+\n+    private static void incrementCounter(KafkaObserverContext observerContext, String name, String desc, int amount) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.counter(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .increment(amount);\n+    }\n+\n+    private static void incrementGauge(KafkaObserverContext observerContext, String name, String desc) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .increment();\n+    }\n+\n+    private static void decrementGauge(KafkaObserverContext observerContext, String name, String desc) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .decrement();\n+    }\n+\n+    private static void setGauge(KafkaObserverContext observerContext, String name, String desc, int value) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .setValue(value);\n+    }\n+\n+    private static void resetGauge(KafkaObserverContext observerContext, String name, String desc) {\n+        if (metricRegistry == null) {\n+            return;\n+        }\n+        metricRegistry.gauge(new MetricId(\n+                KafkaObservabilityConstants.CONNECTOR_NAME + \"_\" + name, desc, observerContext.getAllTags()))\n+                .setValue(0);\n+    }\n+\n+    private KafkaMetricsUtil() {\n+    }\n+", "originalCommit": "686745345044b18037d8f38ab3480fab94f4dfa1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4e2343bcf2392e3752abd3d88f0bca06050d50ee", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e2343bcf2392e3752abd3d88f0bca06050d50ee", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-20T04:24:48Z", "type": "commit"}, {"oid": "4e2343bcf2392e3752abd3d88f0bca06050d50ee", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4e2343bcf2392e3752abd3d88f0bca06050d50ee", "message": "Add observability (metrics and tracing) to Kafka connector", "committedDate": "2020-01-20T04:24:48Z", "type": "forcePushed"}]}