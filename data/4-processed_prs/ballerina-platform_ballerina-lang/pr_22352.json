{"pr_number": 22352, "pr_title": "Allow passing args for non-rest params via the vararg", "pr_createdAt": "2020-03-31T15:18:36Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352", "timeline": [{"oid": "591537b5d1bd25a8ff135b14761c5ca3cabc8d66", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/591537b5d1bd25a8ff135b14761c5ca3cabc8d66", "message": "Intro semantic analysis changes for rest arg fixes", "committedDate": "2020-03-29T14:15:07Z", "type": "commit"}, {"oid": "6e4779361f0be11a6ce67ced85cb427dcc092941", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6e4779361f0be11a6ce67ced85cb427dcc092941", "message": "Intro desugar changes for rest arg changes", "committedDate": "2020-03-29T14:18:05Z", "type": "commit"}, {"oid": "4bc68e38e8e80beb25cf789fea2dbc4514ee405f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4bc68e38e8e80beb25cf789fea2dbc4514ee405f", "message": "Refactor code", "committedDate": "2020-03-29T14:18:09Z", "type": "commit"}, {"oid": "f361c93047d71a2b0218a5b54f1c08095a042261", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f361c93047d71a2b0218a5b54f1c08095a042261", "message": "Fix issues in sync with langlib change branch", "committedDate": "2020-03-29T16:37:42Z", "type": "commit"}, {"oid": "8bfe3f4291261c01622877115035c81d482cc574", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8bfe3f4291261c01622877115035c81d482cc574", "message": "Fix tests", "committedDate": "2020-03-30T17:38:33Z", "type": "commit"}, {"oid": "8beb546ee0c66ac46f06cab3f2f62dc8bec207b6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8beb546ee0c66ac46f06cab3f2f62dc8bec207b6", "message": "Add negative tests", "committedDate": "2020-03-31T05:42:25Z", "type": "commit"}, {"oid": "fb5ef322de428c1319adbb326216b778a0575a2a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fb5ef322de428c1319adbb326216b778a0575a2a", "message": "Fix type-checking for tuple with rest desc.", "committedDate": "2020-03-31T11:39:11Z", "type": "commit"}, {"oid": "4788433e494561c9b4b73435a805ab94e7a8e21f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4788433e494561c9b4b73435a805ab94e7a8e21f", "message": "Fix too many args error not being logged and add tests", "committedDate": "2020-03-31T13:13:37Z", "type": "commit"}, {"oid": "d560f8bd010cd882369ccce10c9f3aabeb36d58c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d560f8bd010cd882369ccce10c9f3aabeb36d58c", "message": "Fix slice on tuple with rest desc.", "committedDate": "2020-03-31T15:15:05Z", "type": "commit"}, {"oid": "f464c038368c6b30a1ff2b1125665bdbcb480a2d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f464c038368c6b30a1ff2b1125665bdbcb480a2d", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2", "committedDate": "2020-04-01T08:16:01Z", "type": "commit"}, {"oid": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2", "committedDate": "2020-04-02T03:51:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5Nzk4NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404697984", "bodyText": "restArgs.get(restArgs.size() - 1)\nI think we can extract this or related logic to a variable. This is used multiple times. This will simplify the code increasing readability.\nL5083, L5088, L5098, L5115 (condition)", "author": "KRVPerera", "createdAt": "2020-04-07T10:18:01Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&", "originalCommit": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5ODQxNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404698416", "bodyText": "Doesn't iExpr.restArgs already has an ArrayList ?", "author": "KRVPerera", "createdAt": "2020-04-07T10:18:47Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();", "originalCommit": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1OTE4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r405259182", "bodyText": "It does, but we want to overwrite it here. I've updated this to create a list only if it is not empty already.", "author": "MaryamZi", "createdAt": "2020-04-08T05:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5ODQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5OTAwOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404699008", "bodyText": "Do we need this exprs? It can directly be arrayLiteral.exprs", "author": "KRVPerera", "createdAt": "2020-04-07T10:19:46Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();", "originalCommit": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1OTUxMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r405259512", "bodyText": "Then we have to do in L5127\narrayLiteral.exprs.add(addConversionExprIfRequired(restArg, elemType));\n\nI'd rather complete the list and then set it.", "author": "MaryamZi", "createdAt": "2020-04-08T05:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY5OTAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwMDIyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404700227", "bodyText": "iExpr.requiredArgs.size()is already extracted to variable originalRequiredArgCount", "author": "KRVPerera", "createdAt": "2020-04-07T10:21:48Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {", "originalCommit": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODAxOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404708018", "bodyText": "Where does this change?", "author": "KRVPerera", "createdAt": "2020-04-07T10:35:54Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;", "originalCommit": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1NTQ3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r405255476", "bodyText": "In reorderNamedArgs.", "author": "MaryamZi", "createdAt": "2020-04-08T04:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODQ5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404708490", "bodyText": "Is it better to rename type to reflect it is actually the type of rest param?", "author": "KRVPerera", "createdAt": "2020-04-07T10:36:48Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;\n+            }\n+\n+            // Args for some or all of the required/defaultable parameters have been provided via the vararg.\n+            // Remove the first required arg and add a statement expression instead.\n+            // The removed first arg is set as the expression and the vararg expression definition is set as\n+            // statement(s).\n+            BLangExpression firstNonRestArg = iExpr.requiredArgs.remove(0);\n+            BLangStatementExpression stmtExpression = createStatementExpression(blockStmt, firstNonRestArg);\n+            stmtExpression.type = firstNonRestArg.type;\n+            iExpr.requiredArgs.add(0, stmtExpression);\n+\n+            // The original value passed as the vararg has to now be sliced to pass only the args for the rest param,\n+            // if there is a rest param.\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangLiteral startIndex = createIntLiteral(invokableSymbol.params.size() - originalRequiredArgCount);\n+            BLangInvocation sliceInvocation =\n+                    createLangLibInvocationNode(SLICE_LANGLIB_METHOD, varargRef,\n+                                                new ArrayList<BLangExpression>() {{\n+                                                    add(startIndex);\n+                                                }},\n+                                                varargRef.type, varargRef.pos);\n+            restArgs.remove(0);\n+            restArgs.add(addConversionExprIfRequired(sliceInvocation, invokableSymbol.restParam.type));\n             return;\n         }\n+\n+        // Now the `restArgs` list has both individual rest args and a vararg, all for the rest param.\n+        // We create a new array with the individual rest args and push the list passed as the vararg to it.\n+        BArrayType type = (BArrayType) invokableSymbol.restParam.type;", "originalCommit": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1Nzg0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r405257846", "bodyText": "Renamed to restParamType.", "author": "MaryamZi", "createdAt": "2020-04-08T04:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODg4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r404708883", "bodyText": "This can be arrayLiteral.exprs = new ArrayList<>();", "author": "KRVPerera", "createdAt": "2020-04-07T10:37:37Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/desugar/Desugar.java", "diffHunk": "@@ -5065,36 +5071,154 @@ private void reorderArguments(BLangInvocation iExpr) {\n         }\n \n         BInvokableSymbol invokableSymbol = (BInvokableSymbol) symbol;\n+\n+        List<BLangExpression> restArgs = iExpr.restArgs;\n+        int originalRequiredArgCount = iExpr.requiredArgs.size();\n+\n+        // Constructs used when the vararg provides args for required/defaultable params.\n+        BLangExpression varargRef = null;\n+        BLangBlockStmt blockStmt = null;\n+\n+        if (!iExpr.restArgs.isEmpty() &&\n+                restArgs.get(restArgs.size() - 1).getKind() == NodeKind.REST_ARGS_EXPR &&\n+                iExpr.requiredArgs.size() < invokableSymbol.params.size()) {\n+            // All or part of the args for the required and defaultable parameters are provided via the vararg.\n+            // We have to first evaluate the vararg's expression, define a variable, and pass a reference to it\n+            // to use for member access when adding such required arguments from the vararg.\n+            BLangExpression expr = ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr;\n+            DiagnosticPos varargExpPos = expr.pos;\n+            BType varargVarType = expr.type;\n+            String varargVarName = DESUGARED_VARARG_KEY + this.varargCount++;\n+\n+            BVarSymbol varargVarSymbol = new BVarSymbol(0, names.fromString(varargVarName), this.env.scope.owner.pkgID,\n+                                                        varargVarType, this.env.scope.owner);\n+            varargRef = ASTBuilderUtil.createVariableRef(varargExpPos, varargVarSymbol);\n+\n+            BLangSimpleVariable var = createVariable(varargExpPos, varargVarName, varargVarType,\n+                                                     ((BLangRestArgsExpression) restArgs.get(restArgs.size() - 1)).expr,\n+                                                     varargVarSymbol);\n+\n+            BLangSimpleVariableDef varDef = ASTBuilderUtil.createVariableDef(varargExpPos);\n+            varDef.var = var;\n+            varDef.type = varargVarType;\n+\n+            blockStmt = createBlockStmt(varargExpPos);\n+            blockStmt.stmts.add(varDef);\n+        }\n+\n         if (!invokableSymbol.params.isEmpty()) {\n             // Re-order the arguments\n-            reorderNamedArgs(iExpr, invokableSymbol);\n+            reorderNamedArgs(iExpr, invokableSymbol, varargRef);\n         }\n \n-        if (invokableSymbol.restParam == null) {\n+        // There are no rest args at all or args for the rest param are only given as individual args (i.e., no vararg).\n+        if (restArgs.isEmpty() || restArgs.get(restArgs.size() - 1).getKind() != NodeKind.REST_ARGS_EXPR) {\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n+            List<BLangExpression> exprs = new ArrayList<>();\n+\n+            BArrayType arrayType = (BArrayType) invokableSymbol.restParam.type;\n+            BType elemType = arrayType.eType;\n+\n+            for (BLangExpression restArg : restArgs) {\n+                exprs.add(addConversionExprIfRequired(restArg, elemType));\n+            }\n+\n+            arrayLiteral.exprs = exprs;\n+            arrayLiteral.type = arrayType;\n+            iExpr.restArgs = new ArrayList<>();\n+            iExpr.restArgs.add(arrayLiteral);\n             return;\n         }\n \n-        // Create an array out of all the rest arguments, and pass it as a single argument.\n-        // If there is only one optional argument and its type is restArg (i.e: ...x), then\n-        // leave it as is.\n-        if (iExpr.restArgs.size() == 1 && iExpr.restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+        // There are no individual rest args, but there is a single vararg.\n+        if (restArgs.size() == 1 && restArgs.get(0).getKind() == NodeKind.REST_ARGS_EXPR) {\n+\n+            // If the number of expressions in `iExpr.requiredArgs` hasn't changed, the vararg only contained\n+            // arguments for the rest parameter.\n+            if (iExpr.requiredArgs.size() == originalRequiredArgCount) {\n+                return;\n+            }\n+\n+            // Args for some or all of the required/defaultable parameters have been provided via the vararg.\n+            // Remove the first required arg and add a statement expression instead.\n+            // The removed first arg is set as the expression and the vararg expression definition is set as\n+            // statement(s).\n+            BLangExpression firstNonRestArg = iExpr.requiredArgs.remove(0);\n+            BLangStatementExpression stmtExpression = createStatementExpression(blockStmt, firstNonRestArg);\n+            stmtExpression.type = firstNonRestArg.type;\n+            iExpr.requiredArgs.add(0, stmtExpression);\n+\n+            // The original value passed as the vararg has to now be sliced to pass only the args for the rest param,\n+            // if there is a rest param.\n+            if (invokableSymbol.restParam == null) {\n+                return;\n+            }\n+\n+            BLangLiteral startIndex = createIntLiteral(invokableSymbol.params.size() - originalRequiredArgCount);\n+            BLangInvocation sliceInvocation =\n+                    createLangLibInvocationNode(SLICE_LANGLIB_METHOD, varargRef,\n+                                                new ArrayList<BLangExpression>() {{\n+                                                    add(startIndex);\n+                                                }},\n+                                                varargRef.type, varargRef.pos);\n+            restArgs.remove(0);\n+            restArgs.add(addConversionExprIfRequired(sliceInvocation, invokableSymbol.restParam.type));\n             return;\n         }\n+\n+        // Now the `restArgs` list has both individual rest args and a vararg, all for the rest param.\n+        // We create a new array with the individual rest args and push the list passed as the vararg to it.\n+        BArrayType type = (BArrayType) invokableSymbol.restParam.type;\n+\n         BLangArrayLiteral arrayLiteral = (BLangArrayLiteral) TreeBuilder.createArrayLiteralExpressionNode();\n-        arrayLiteral.type = invokableSymbol.restParam.type;\n+        arrayLiteral.type = type;\n \n-        BType elemType = ((BArrayType) arrayLiteral.type).eType;\n-        List<BLangExpression> rewrittenRestArgs = new ArrayList<>();\n-        for (BLangExpression restArg : iExpr.restArgs) {\n-            rewrittenRestArgs.add(addConversionExprIfRequired(restArg, elemType));\n+        BType elemType = type.eType;\n+        DiagnosticPos pos = restArgs.get(0).pos;\n+\n+        List<BLangExpression> exprs = new ArrayList<>();", "originalCommit": "a3de0504b70b2f24c86cb079c3baca7e5f2e45cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTI1NzUyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/22352#discussion_r405257521", "bodyText": "Then we have to do in L5186\narrayLiteral.exprs.add(addConversionExprIfRequired(restArgs.get(i), elemType));\n\nI'd rather complete the list and then set it.", "author": "MaryamZi", "createdAt": "2020-04-08T04:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcwODg4Mw=="}], "type": "inlineReview"}, {"oid": "e80562179f469165cd2b9e337180cd96d4d03c01", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e80562179f469165cd2b9e337180cd96d4d03c01", "message": "Resolve conflicts and Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2", "committedDate": "2020-04-08T04:29:48Z", "type": "commit"}, {"oid": "9df5679cf9b5eabedf383b4ef1c3fb6c93470636", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9df5679cf9b5eabedf383b4ef1c3fb6c93470636", "message": "Refactor code", "committedDate": "2020-04-08T05:22:40Z", "type": "commit"}, {"oid": "1d0df0403e6a320a308d82feee9f331e1d605f80", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1d0df0403e6a320a308d82feee9f331e1d605f80", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2", "committedDate": "2020-04-15T10:03:38Z", "type": "commit"}, {"oid": "4b8a3d523d0f596e5a6067e0ea07e8253fd803d4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4b8a3d523d0f596e5a6067e0ea07e8253fd803d4", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2", "committedDate": "2020-04-16T06:50:28Z", "type": "commit"}, {"oid": "1609879ebb86ab9f553ee0d2125f9691814ae161", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1609879ebb86ab9f553ee0d2125f9691814ae161", "message": "Merge branch 'master' of https://github.com/ballerina-lang/ballerina into func-call-2", "committedDate": "2020-04-16T09:23:48Z", "type": "commit"}, {"oid": "b98967bf53d82219bfcd6c02bb45c193afab623f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b98967bf53d82219bfcd6c02bb45c193afab623f", "message": "Fix bstring unit tests", "committedDate": "2020-04-16T09:52:50Z", "type": "commit"}]}