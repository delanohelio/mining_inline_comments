{"pr_number": 24684, "pr_title": "Enable documentaion tests for new parser", "pr_createdAt": "2020-07-09T16:29:21Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684", "timeline": [{"oid": "263f4ba124a0cd734d9ce0a66618f40959b5d8f5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/263f4ba124a0cd734d9ce0a66618f40959b5d8f5", "message": "Fix trivia capturing for the hash token", "committedDate": "2020-07-08T09:14:20Z", "type": "commit"}, {"oid": "9d38e1d25c983920481c21e7f0a3aed17db1bd81", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9d38e1d25c983920481c21e7f0a3aed17db1bd81", "message": "Fix parameter name capturing in the lexer", "committedDate": "2020-07-08T10:21:04Z", "type": "commit"}, {"oid": "f30f7cb37f3c2ce743eab040c311cc614005d29e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f30f7cb37f3c2ce743eab040c311cc614005d29e", "message": "Fix node transformer for multiline documentation", "committedDate": "2020-07-08T10:32:35Z", "type": "commit"}, {"oid": "5054e3ca471a8c91bceb5623f2c66a09e85e78a0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5054e3ca471a8c91bceb5623f2c66a09e85e78a0", "message": "Fix diagnostic positions for documentation in node transformer", "committedDate": "2020-07-09T04:00:48Z", "type": "commit"}, {"oid": "a2e5a99318a589ab4ef2bc597e6e3bcbf61f3a0e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2e5a99318a589ab4ef2bc597e6e3bcbf61f3a0e", "message": "Add \"const\" keyword to the special keywords supported by BFM", "committedDate": "2020-07-09T05:08:07Z", "type": "commit"}, {"oid": "3fc6264fe88f0d345fe26038eea1f0adc33d2aa2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3fc6264fe88f0d345fe26038eea1f0adc33d2aa2", "message": "Fix documentation for object fields and change getTextWithWhitespaceTrivia logic in node transformer", "committedDate": "2020-07-09T09:34:44Z", "type": "commit"}, {"oid": "5da380e3c78a638ddea1d17b97c0e0df80d83995", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5da380e3c78a638ddea1d17b97c0e0df80d83995", "message": "Fix trivia capturing for documentation tokens", "committedDate": "2020-07-09T12:27:44Z", "type": "commit"}, {"oid": "41152096bf954ebb02ed7604cf0d6c68b9264f5f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/41152096bf954ebb02ed7604cf0d6c68b9264f5f", "message": "Fix node transformer for wrong diagnostic positions in doc and update doc text logic for the lexer changes", "committedDate": "2020-07-09T12:34:13Z", "type": "commit"}, {"oid": "3432d0d67aacf680b66d301b12d8fbc0fb3db1ec", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3432d0d67aacf680b66d301b12d8fbc0fb3db1ec", "message": "Fix testMultilineDocsWithDeprecation failing", "committedDate": "2020-07-09T14:09:26Z", "type": "commit"}, {"oid": "436fcdac71daf6ad78df21a3da4636b3de740722", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/436fcdac71daf6ad78df21a3da4636b3de740722", "message": "Fix tests with deprecated annotation failing with a runtime exception", "committedDate": "2020-07-09T16:17:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0Njg1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r452346857", "bodyText": "Support for the special keyword const was added, as it is going to be included in the spec. (ballerina-platform/ballerina-spec#336)\nKeyword is already supported in the DocumentationAnalyzer and used in the unit tests as well.", "author": "lochana-chathura", "createdAt": "2020-07-09T16:35:48Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1719,6 +1750,7 @@ private boolean processDocumentationReference(int nextChar) {\n             case LexerTerminals.MODULE:\n             case LexerTerminals.FUNCTION:\n             case LexerTerminals.PARAMETER:\n+            case LexerTerminals.CONST:", "originalCommit": "5fdaef55ff3320891ad724ff67bfc7022653132f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a", "message": "Enable DocumentationAnalyzer for new parser and all documentation unit tests", "committedDate": "2020-07-09T16:40:05Z", "type": "commit"}, {"oid": "3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a", "message": "Enable DocumentationAnalyzer for new parser and all documentation unit tests", "committedDate": "2020-07-09T16:40:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjYwODI0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r452608240", "bodyText": "IMO amount of leading whitespaces shouldn't matter.\nIs it possible to send this from the lexer itself, as a token?", "author": "SupunS", "createdAt": "2020-07-10T03:51:47Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12815,7 +12815,7 @@ private STNode parseDocumentationLine(STNode hashToken) {\n             case 1:\n                 STNode docElement = docElements.get(0);\n                 if (docElement.kind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n-                    if (((STToken) docElement).text().startsWith(\"# Deprecated\")) {\n+                    if (((STToken) docElement).text().startsWith(\" # Deprecated\")) {", "originalCommit": "3fd9b6c8d501850fc7fb98efd7167f502bcf3c4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b7587b9d8be02e0ab4febbef9f517b317becad98", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b7587b9d8be02e0ab4febbef9f517b317becad98", "message": "Add deprecation literal support from lexer", "committedDate": "2020-07-10T09:05:44Z", "type": "commit"}, {"oid": "b7587b9d8be02e0ab4febbef9f517b317becad98", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b7587b9d8be02e0ab4febbef9f517b317becad98", "message": "Add deprecation literal support from lexer", "committedDate": "2020-07-10T09:05:44Z", "type": "forcePushed"}, {"oid": "df475bac38759853611065cb316b663e0b6acc31", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/df475bac38759853611065cb316b663e0b6acc31", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into doc-support", "committedDate": "2020-07-10T09:31:32Z", "type": "commit"}, {"oid": "56c5202c60fceab2e57c3acec5150d564a9cd375", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/56c5202c60fceab2e57c3acec5150d564a9cd375", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into doc-support", "committedDate": "2020-07-10T11:13:12Z", "type": "commit"}, {"oid": "ea914c6e27a2591e0de66f268f3957a88134d37a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ea914c6e27a2591e0de66f268f3957a88134d37a", "message": "Fix build failing due to wrong doc parameter name from upstream", "committedDate": "2020-07-10T11:22:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5MjE5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r452792191", "bodyText": "we can do this in a better-performance way:\nchar[] deprecatedChars = {'D', 'E', 'P', 'R', 'E', 'C', 'A', 'T', 'E', 'D' };\n\nif ((char) lookAheadChar != deprecatedChars[i]) {\n}", "author": "SupunS", "createdAt": "2020-07-10T11:42:44Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1578,13 +1598,60 @@ private STToken readTokenInBracedContentInInterpolation() {\n      */\n \n     private STToken readDocumentationToken() {\n-        int nextChar = peek();\n-        if (nextChar == LexerTerminals.PLUS) {\n+        // Look ahead and see if next non-trivial char is a plus char or a hash char.\n+        // If it is a plus char, process trivial chars as leading trivia of the plus token.\n+        // If it is a hash char, look ahead and see if it is followed by a deprecation literal.\n+        // Else, let trivial chars be a part of the documentation description.\n+        int lookAheadCount = 0;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        if (lookAheadChar == LexerTerminals.PLUS) {\n+            return processPlusToken();\n+        } else if (lookAheadChar == LexerTerminals.HASH) {\n+            return processDeprecationLiteralToken(lookAheadCount);\n+        } else {\n+            return readDocumentationInternalToken();\n+        }\n+    }\n+\n+    private STToken processPlusToken() {\n+        processLeadingTrivia();\n+        reader.advance();\n+        switchMode(ParserMode.DOCUMENTATION_PARAMETER);\n+        return getDocumentationSyntaxToken(SyntaxKind.PLUS_TOKEN);\n+    }\n+\n+    private STToken processDeprecationLiteralToken(int lookAheadCount) {\n+        // Look ahead and see if next non-trivial char belongs to a deprecation literal.\n+        // There could be spaces and tabs in between.\n+        lookAheadCount++;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        // Look ahead for a \"Deprecated\" word match.\n+        for (int i = 0; i < 10; i++) {\n+            if ((char) lookAheadChar != LexerTerminals.DEPRECATED.charAt(i)) {", "originalCommit": "ea914c6e27a2591e0de66f268f3957a88134d37a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjQyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r452796423", "bodyText": "why do we need this while loop?\nis it possible to avoid getLexeme().endsWith(LexerTerminals.DEPRECATED) check? Coz regex-related operations on top of java Strings (such as contains(), endsWith(), startsWith(), etc ) can be really expensive..", "author": "SupunS", "createdAt": "2020-07-10T11:53:27Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1578,13 +1598,60 @@ private STToken readTokenInBracedContentInInterpolation() {\n      */\n \n     private STToken readDocumentationToken() {\n-        int nextChar = peek();\n-        if (nextChar == LexerTerminals.PLUS) {\n+        // Look ahead and see if next non-trivial char is a plus char or a hash char.\n+        // If it is a plus char, process trivial chars as leading trivia of the plus token.\n+        // If it is a hash char, look ahead and see if it is followed by a deprecation literal.\n+        // Else, let trivial chars be a part of the documentation description.\n+        int lookAheadCount = 0;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        if (lookAheadChar == LexerTerminals.PLUS) {\n+            return processPlusToken();\n+        } else if (lookAheadChar == LexerTerminals.HASH) {\n+            return processDeprecationLiteralToken(lookAheadCount);\n+        } else {\n+            return readDocumentationInternalToken();\n+        }\n+    }\n+\n+    private STToken processPlusToken() {\n+        processLeadingTrivia();\n+        reader.advance();\n+        switchMode(ParserMode.DOCUMENTATION_PARAMETER);\n+        return getDocumentationSyntaxToken(SyntaxKind.PLUS_TOKEN);\n+    }\n+\n+    private STToken processDeprecationLiteralToken(int lookAheadCount) {\n+        // Look ahead and see if next non-trivial char belongs to a deprecation literal.\n+        // There could be spaces and tabs in between.\n+        lookAheadCount++;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        // Look ahead for a \"Deprecated\" word match.\n+        for (int i = 0; i < 10; i++) {\n+            if ((char) lookAheadChar != LexerTerminals.DEPRECATED.charAt(i)) {\n+                // No match. Hence return a documentation internal token.\n+                return readDocumentationInternalToken();\n+            }\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        // There is a match. Hence return a deprecation literal.\n+        processLeadingTrivia();\n+        reader.mark();\n+        while (!getLexeme().endsWith(LexerTerminals.DEPRECATED)) {", "originalCommit": "ea914c6e27a2591e0de66f268f3957a88134d37a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgxNzY1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r452817651", "bodyText": "Fixed with 2331d55. Thanks for pointing out expensive operation. :)\nReason for the while loop:\nBy code line 1648, lexer knows there's a WS # WS Deprecated match ahead. After calling processLeadingTrivia() lexer doesn't know, for how many chars, the reader should be advanced.", "author": "lochana-chathura", "createdAt": "2020-07-10T12:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mjc5NjQyMw=="}], "type": "inlineReview"}, {"oid": "2331d5519a2a7055ee6b37a9a44e4998551c54be", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/2331d5519a2a7055ee6b37a9a44e4998551c54be", "message": "Improve processDeprecationLiteralToken", "committedDate": "2020-07-10T12:37:13Z", "type": "commit"}, {"oid": "c7f42aace81cc8272e14bdcf625cea75c0e47ba7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c7f42aace81cc8272e14bdcf625cea75c0e47ba7", "message": "Introduce separate syntax kinds for all documentation syntax", "committedDate": "2020-07-11T12:44:29Z", "type": "commit"}, {"oid": "dd1c79f726714c4c1e43ba493ddcca4482da4516", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dd1c79f726714c4c1e43ba493ddcca4482da4516", "message": "Revamp documentation parsing", "committedDate": "2020-07-13T11:02:08Z", "type": "commit"}, {"oid": "0c457a6196e4dffea3bf2dad08f699fa6a8d9149", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0c457a6196e4dffea3bf2dad08f699fa6a8d9149", "message": "Fix leading trivia parsing in DocumentationLexer", "committedDate": "2020-07-13T17:07:17Z", "type": "commit"}, {"oid": "d2c63e4bd2d52f7228747bebaf9770893898cfcf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2c63e4bd2d52f7228747bebaf9770893898cfcf", "message": "Fix multi line documentation parsing", "committedDate": "2020-07-14T04:35:02Z", "type": "commit"}, {"oid": "539b9a3249762df2d9ee53f93d80ded17d663cb6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/539b9a3249762df2d9ee53f93d80ded17d663cb6", "message": "Change documentation node names and generate tree", "committedDate": "2020-07-14T06:10:56Z", "type": "commit"}, {"oid": "69d41e9bf8bfa70b227df509adf47465e5350b13", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/69d41e9bf8bfa70b227df509adf47465e5350b13", "message": "Refactor code", "committedDate": "2020-07-14T07:02:16Z", "type": "commit"}, {"oid": "037a99c8cd7e235b40a9b508c4e5ad0647724b7a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/037a99c8cd7e235b40a9b508c4e5ad0647724b7a", "message": "Update test cases for node name changes", "committedDate": "2020-07-14T07:03:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE2MzA1Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r454163056", "bodyText": "what about the newlines? don't we need to add it to the trailing trivia?", "author": "SupunS", "createdAt": "2020-07-14T07:37:25Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaLexer.java", "diffHunk": "@@ -1362,6 +1306,70 @@ private STToken processSlashToken() {\n         }\n     }\n \n+    /**\n+     * Process and return documentation string.\n+     * <p>\n+     * <code>\n+     * DocumentationContentString := ( BlankSpace* # [DocumentationContent] )+\n+     * <br/>\n+     * DocumentationContent := (^ 0xA)* 0xA\n+     * <br/>\n+     * BlankSpace := Tab | Space\n+     * <br/>\n+     * Space := 0x20\n+     * <br/>\n+     * Tab := 0x9\n+     * </code>\n+     *\n+     * @return Documentation string token\n+     */\n+    private STToken processDocumentationContentString() {\n+        int nextChar = peek();\n+        while (!reader.isEOF()) {\n+            switch (nextChar) {\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                case LexerTerminals.NEWLINE:\n+\n+                    // Advance reader for the new line\n+                    if (peek() == LexerTerminals.CARRIAGE_RETURN && reader.peek(1) == LexerTerminals.NEWLINE) {\n+                        reader.advance();\n+                    }\n+                    reader.advance();\n+\n+                    // Look ahead and see if next line also belongs to the documentation.\n+                    // i.e. look for a `WS #` match\n+                    // If there's a match, advance reader for the next line as well.\n+                    // Otherwise terminate documentation content after the new line.\n+                    int lookAheadCount = 0;\n+                    int lookAheadChar = reader.peek(lookAheadCount);\n+                    while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+                        lookAheadCount++;\n+                        lookAheadChar = reader.peek(lookAheadCount);\n+                    }\n+\n+                    if (lookAheadChar != LexerTerminals.HASH) {\n+                        // Next line does not belong to documentation, hence break\n+                        break;\n+                    }\n+\n+                    reader.advance(lookAheadCount);\n+                    nextChar = peek();\n+                    continue;\n+                default:\n+                    reader.advance();\n+                    nextChar = peek();\n+                    continue;\n+            }\n+            break;\n+        }\n+\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        String lexeme = getLexeme();\n+        STNode trailingTrivia = STNodeFactory.createNodeList(new ArrayList<>(0)); // No trailing trivia", "originalCommit": "037a99c8cd7e235b40a9b508c4e5ad0647724b7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4MjI0MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r455282241", "bodyText": "New line is already included in the documentation string.\ne.g.\n#  line1\nfunction foo() { }\n\ndocumentation string would be \"# line1\\n\"\nThen in the documentation lexer it will be parsed as the trailing trivia of whatever the last token.", "author": "lochana-chathura", "createdAt": "2020-07-15T19:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE2MzA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE2NDc2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r454164763", "bodyText": "What does this method do? is it flattening the doc-lists?\nCan we do it right after getting the results from parseDocumentationString()? Then you don't have to traverse through the outer-list for a second time.", "author": "SupunS", "createdAt": "2020-07-14T07:40:44Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -12994,242 +12994,70 @@ private DiagnosticErrorCode validateArgMatchPatternOrder(SyntaxKind prevArgKind,\n         return errorCode;\n     }\n \n-    // --------------------------------- Documentation ---------------------------------\n-\n-    /*\n-     * This section parses documentation.\n-     * Ballerina flavored markdown (BFM) is supported by the documentation.\n-     *\n-     * During the parsing, parser will never go to the error handler.\n-     * In case of an error, simply missing token will be returned.\n-     */\n-\n     /**\n-     * Parse documentation string.\n-     * <p>\n-     * <code>\n-     * DocumentationString :=\n-     *          ( DocumentationLine\n-     *          | ReferenceDocumentationLine\n-     *          | DeprecationDocumentationLine\n-     *          | ParameterDocumentationLine\n-     *          | ReturnParameterDocumentationLine\n-     *          | InvalidDocumentationLine ) +\n-     * </code>\n-     * <p>\n-     * Refer {@link BallerinaLexer#readDocumentationToken}\n+     * Parse markdown documentation.\n      *\n-     * @return Parsed node\n+     * @return markdown documentation node\n      */\n-    private STNode parseDocumentationString() {\n-        List<STNode> docLines = new ArrayList<>();\n-        STToken nextToken = peek();\n-        while (nextToken.kind == SyntaxKind.HASH_TOKEN) {\n-            docLines.add(parseSingleDocumentationLine());\n-            nextToken = peek();\n-        }\n-\n-        STNode documentationLines = STNodeFactory.createNodeList(docLines);\n-        return STNodeFactory.createDocumentationStringNode(documentationLines);\n-    }\n+    private STNode parseMarkdownDocumentation() {\n+        List<STNode> markdownDocLineList = new ArrayList<>();\n \n-    /**\n-     * Parse a single documentation line.\n-     *\n-     * @return Parsed node\n-     */\n-    private STNode parseSingleDocumentationLine() {\n-        STNode hashToken = consume();\n+        // With multi-line documentation, there could be more than one documentation string.\n+        // e.g.\n+        // # line1 (this is captured as one documentation string)\n+        //\n+        // # line2 (this is captured as another documentation string)\n         STToken nextToken = peek();\n-        if (nextToken.kind == SyntaxKind.PLUS_TOKEN) {\n-            return parseParameterDocumentationLine(hashToken);\n-        }\n-        return parseDocumentationLine(hashToken);\n-    }\n-\n-    /**\n-     * Parse documentation line, deprecation documentation line and reference documentation line.\n-     *\n-     * @param hashToken Hash token at the beginning of the line\n-     * @return Parsed node\n-     */\n-    private STNode parseDocumentationLine(STNode hashToken) {\n-        List<STNode> docElements = parseDocumentationElements();\n-        STNode docElementList = STNodeFactory.createNodeList(docElements);\n-\n-        switch (docElements.size()) {\n-            case 0:\n-                // When documentation line is only a `#` token\n-                return createDocumentationLineNode(hashToken, docElementList);\n-            case 1:\n-                STNode docElement = docElements.get(0);\n-                if (docElement.kind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n-                    if (((STToken) docElement).text().startsWith(\"# Deprecated\")) {\n-                        return createDeprecationDocumentationLineNode(hashToken, docElementList);\n-                    }\n-                    return createDocumentationLineNode(hashToken, docElementList);\n-                }\n-                // Else fall through\n-            default:\n-                return createReferenceDocumentationLineNode(hashToken, docElementList);\n-        }\n-    }\n-\n-    private List<STNode> parseDocumentationElements() {\n-        List<STNode> docElements = new ArrayList<>();\n-        STNode docElement;\n-        SyntaxKind nextTokenKind = peek().kind;\n-        while (!isEndOfIntermediateDocumentation(nextTokenKind)) {\n-            if (nextTokenKind == SyntaxKind.DOCUMENTATION_DESCRIPTION) {\n-                docElement = consume();\n-\n-            } else {\n-                docElement = parseDocumentationReference();\n-            }\n-            docElements.add(docElement);\n-            nextTokenKind = peek().kind;\n-        }\n-        return docElements;\n-    }\n-\n-    private STNode parseDocumentationReference() {\n-        STNode referenceType = STNodeFactory.createEmptyNode();\n-        if (isDocumentReferenceType(peek().kind)) {\n-            referenceType = consume();\n+        while (nextToken.kind == SyntaxKind.DOCUMENTATION_STRING) {\n+            STToken documentationString = consume();\n+            STNode markdownDocLines = parseDocumentationString(documentationString);\n+            markdownDocLineList.add(markdownDocLines);\n+            nextToken = peek();\n         }\n \n-        STNode startBacktick = parseDocumentationBacktickToken();\n-        STNode backtickContent = parseBacktickContent();\n-        STNode endBacktick = parseDocumentationBacktickToken();\n-\n-        return STNodeFactory.createDocumentationReferenceNode(referenceType, startBacktick, backtickContent,\n-                endBacktick);\n-    }\n-\n-    private boolean isDocumentReferenceType(SyntaxKind kind) {\n-        switch (kind) {\n-            case TYPE_DOC_REFERENCE_TOKEN:\n-            case SERVICE_DOC_REFERENCE_TOKEN:\n-            case VARIABLE_DOC_REFERENCE_TOKEN:\n-            case VAR_DOC_REFERENCE_TOKEN:\n-            case ANNOTATION_DOC_REFERENCE_TOKEN:\n-            case MODULE_DOC_REFERENCE_TOKEN:\n-            case FUNCTION_DOC_REFERENCE_TOKEN:\n-            case PARAMETER_DOC_REFERENCE_TOKEN:\n-                return true;\n-            default:\n-                return false;\n-        }\n+        STNode arrangedMarkdownDocLines = rearrangeMarkdownDocumentationLines(markdownDocLineList);\n+        return STNodeFactory.createMarkdownDocumentationNode(arrangedMarkdownDocLines);\n     }\n \n     /**\n-     * Parse parameter documentation line and return parameter documentation line.\n+     * Parse documentation string.\n      *\n-     * @param hashToken Hash token at the beginning of the line\n-     * @return Parsed node\n+     * @return markdown documentation line list node\n      */\n-    private STNode parseParameterDocumentationLine(STNode hashToken) {\n-        STNode plusToken = consume();\n-        STNode parameterName = parseParameterName();\n-        STNode minusToken = parseMinusToken();\n-\n-        List<STNode> docElements = parseDocumentationElements();\n-        STNode docElementList = STNodeFactory.createNodeList(docElements);\n+    private STNode parseDocumentationString(STToken documentationStringToken) {\n+        List<STNode> leadingTriviaList = getLeadingTriviaList(documentationStringToken.leadingMinutiae());\n+        TextDocument textDocument = TextDocuments.from(documentationStringToken.text());\n \n-        SyntaxKind kind;\n-        if (parameterName.kind == SyntaxKind.RETURN_KEYWORD) {\n-            kind = SyntaxKind.RETURN_PARAMETER_DOCUMENTATION_LINE;\n-        } else {\n-            kind = SyntaxKind.PARAMETER_DOCUMENTATION_LINE;\n-        }\n+        DocumentationLexer documentationLexer = new DocumentationLexer(textDocument.getCharacterReader(),\n+                leadingTriviaList);\n+        AbstractTokenReader tokenReader = new TokenReader(documentationLexer);\n+        DocumentationParser documentationParser = new DocumentationParser(tokenReader);\n \n-        return STNodeFactory.createParameterDocumentationLineNode(kind, hashToken, plusToken, parameterName, minusToken,\n-                docElementList);\n+        return documentationParser.parse();\n     }\n \n-    private boolean isEndOfIntermediateDocumentation(SyntaxKind kind) {\n-        switch (kind) {\n-            case DOCUMENTATION_DESCRIPTION:\n-            case PLUS_TOKEN:\n-            case PARAMETER_NAME:\n-            case MINUS_TOKEN:\n-            case BACKTICK_TOKEN:\n-            case BACKTICK_CONTENT:\n-                return false;\n-            default:\n-                return !isDocumentReferenceType(kind);\n-        }\n-    }\n+    private List<STNode> getLeadingTriviaList(STNode leadingMinutiaeNode) {\n+        List<STNode> leadingTriviaList = new ArrayList<>();\n \n-    /**\n-     * Parse parameter name token.\n-     *\n-     * @return Parsed node\n-     */\n-    private STNode parseParameterName() {\n-        SyntaxKind tokenKind = peek().kind;\n-        if (tokenKind == SyntaxKind.PARAMETER_NAME || tokenKind == SyntaxKind.RETURN_KEYWORD) {\n-            return consume();\n-        } else {\n-            return STNodeFactory.createMissingToken(SyntaxKind.PARAMETER_NAME);\n+        int bucketCount = leadingMinutiaeNode.bucketCount();\n+        for (int i = 0; i < bucketCount; i++) {\n+            leadingTriviaList.add(leadingMinutiaeNode.childInBucket(i));\n         }\n+        return leadingTriviaList;\n     }\n \n-    /**\n-     * Parse minus token.\n-     *\n-     * @return Parsed node\n-     */\n-    private STNode parseMinusToken() {\n-        STToken token = peek();\n-        if (token.kind == SyntaxKind.MINUS_TOKEN) {\n-            return consume();\n-        } else {\n-            return STNodeFactory.createMissingToken(SyntaxKind.MINUS_TOKEN);\n-        }\n-    }\n+    private STNode rearrangeMarkdownDocumentationLines(List<STNode> markdownDocLineList) {", "originalCommit": "037a99c8cd7e235b40a9b508c4e5ad0647724b7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI4MzE5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r455283196", "bodyText": "yea flattening.\nyes we can. will add that fix.", "author": "lochana-chathura", "createdAt": "2020-07-15T19:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE2NDc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE3NDQ0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/24684#discussion_r454174445", "bodyText": "we can define this as a class-level final static variable, since its a constant.", "author": "SupunS", "createdAt": "2020-07-14T07:58:01Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/DocumentationLexer.java", "diffHunk": "@@ -0,0 +1,691 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.ballerinalang.compiler.internal.parser;\n+\n+\n+import io.ballerinalang.compiler.internal.parser.tree.STNode;\n+import io.ballerinalang.compiler.internal.parser.tree.STNodeFactory;\n+import io.ballerinalang.compiler.internal.parser.tree.STToken;\n+import io.ballerinalang.compiler.syntax.tree.SyntaxKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * A LL(k) lexer for documentation in ballerina.\n+ *\n+ * @since 2.0.0\n+ */\n+public class DocumentationLexer extends AbstractLexer {\n+\n+    public DocumentationLexer(CharReader charReader, List<STNode> leadingTriviaList) {\n+        super(charReader, ParserMode.DOCUMENTATION_INIT);\n+        this.leadingTriviaList = leadingTriviaList;\n+    }\n+\n+    /**\n+     * Get the next lexical token.\n+     *\n+     * @return Next lexical token.\n+     */\n+    @Override\n+    public STToken nextToken() {\n+        STToken token;\n+        switch (this.mode) {\n+            case DOCUMENTATION_INIT:\n+                processLeadingTrivia();\n+                token = readDocumentationInitToken();\n+                break;\n+            case DOCUMENTATION:\n+                this.leadingTriviaList = new ArrayList<>(0);\n+                token = readDocumentationToken();\n+                break;\n+            case DOCUMENTATION_INTERNAL:\n+                this.leadingTriviaList = new ArrayList<>(0);\n+                token = readDocumentationInternalToken();\n+                break;\n+            case DOCUMENTATION_PARAMETER:\n+                processLeadingTrivia();\n+                token = readDocumentationParameterToken();\n+                break;\n+            case DOCUMENTATION_REFERENCE_TYPE:\n+                processLeadingTrivia();\n+                token = readDocumentationReferenceTypeToken();\n+                break;\n+            case DOCUMENTATION_BACKTICK_CONTENT:\n+                this.leadingTriviaList = new ArrayList<>(0);\n+                token = readDocumentationBacktickContentToken();\n+                break;\n+            default:\n+                token = null;\n+        }\n+        return token;\n+    }\n+\n+    /*\n+     * Private Methods\n+     */\n+\n+    /**\n+     * Returns the next character from the reader, without consuming the stream.\n+     *\n+     * @return Next character\n+     */\n+    private int peek() {\n+        return this.reader.peek();\n+    }\n+\n+    /**\n+     * Get the text associated with the current token.\n+     *\n+     * @return Text associated with the current token.\n+     */\n+    private String getLexeme() {\n+        return reader.getMarkedChars();\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is an identifier start char.\n+     * </p>\n+     * <code>IdentifierInitialChar := A .. Z | a .. z | _ | UnicodeIdentifierChar</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier start char. <code>false</code> otherwise.\n+     */\n+    private boolean isIdentifierInitialChar(int c) {\n+        // TODO: pre-mark all possible characters, using a mask. And use that mask here to check\n+        if ('A' <= c && c <= 'Z') {\n+            return true;\n+        }\n+\n+        if ('a' <= c && c <= 'z') {\n+            return true;\n+        }\n+\n+        if (c == '_') {\n+            return true;\n+        }\n+\n+        // TODO: if (UnicodeIdentifierChar) return false;\n+        return false;\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is an identifier following char.\n+     * </p>\n+     * <code>IdentifierFollowingChar := IdentifierInitialChar | Digit</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character is an identifier following char. <code>false</code> otherwise.\n+     */\n+    private boolean isIdentifierFollowingChar(int c) {\n+        return isIdentifierInitialChar(c) || isDigit(c);\n+    }\n+\n+    /**\n+     * <p>\n+     * Check whether a given char is a digit.\n+     * </p>\n+     * <code>Digit := 0..9</code>\n+     *\n+     * @param c character to check\n+     * @return <code>true</code>, if the character represents a digit. <code>false</code> otherwise.\n+     */\n+    static boolean isDigit(int c) {\n+        return ('0' <= c && c <= '9');\n+    }\n+\n+    /**\n+     * Process leading trivia.\n+     */\n+    private void processLeadingTrivia() {\n+        // new leading trivia will be added to the current leading trivia list\n+        processSyntaxTrivia(this.leadingTriviaList, true);\n+    }\n+\n+    /**\n+     * Reset leading trivia.\n+     */\n+    private void resetLeadingTrivia() {\n+        this.leadingTriviaList = new ArrayList<>(0);\n+    }\n+\n+    /**\n+     * Process and return trailing trivia.\n+     *\n+     * @return Trailing trivia\n+     */\n+    private STNode processTrailingTrivia() {\n+        List<STNode> triviaList = new ArrayList<>(10);\n+        processSyntaxTrivia(triviaList, false);\n+        return STNodeFactory.createNodeList(triviaList);\n+    }\n+\n+    /**\n+     * Process syntax trivia and add it to the provided list.\n+     * <p>\n+     * <code>syntax-trivia := whitespace | end-of-line </code>\n+     *\n+     * @param triviaList List of trivia\n+     * @param isLeading Flag indicating whether the currently processing leading trivia or not\n+     */\n+    private void processSyntaxTrivia(List<STNode> triviaList, boolean isLeading) {\n+        while (!reader.isEOF()) {\n+            reader.mark();\n+            char c = reader.peek();\n+            switch (c) {\n+                case LexerTerminals.SPACE:\n+                case LexerTerminals.TAB:\n+                case LexerTerminals.FORM_FEED:\n+                    triviaList.add(processWhitespaces());\n+                    break;\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                case LexerTerminals.NEWLINE:\n+                    triviaList.add(processEndOfLine());\n+                    if (isLeading) {\n+                        break;\n+                    }\n+                    return;\n+                default:\n+                    return;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Process whitespace up to an end of line.\n+     * <p>\n+     * <code>whitespace := 0x9 | 0xC | 0x20</code>\n+     *\n+     * @return Whitespace trivia\n+     */\n+    private STNode processWhitespaces() {\n+        while (!reader.isEOF()) {\n+            char c = reader.peek();\n+            switch (c) {\n+                case LexerTerminals.SPACE:\n+                case LexerTerminals.TAB:\n+                case LexerTerminals.FORM_FEED:\n+                    reader.advance();\n+                    continue;\n+                case LexerTerminals.CARRIAGE_RETURN:\n+                case LexerTerminals.NEWLINE:\n+                    break;\n+                default:\n+                    break;\n+            }\n+            break;\n+        }\n+\n+        return STNodeFactory.createMinutiae(SyntaxKind.WHITESPACE_MINUTIAE, getLexeme());\n+    }\n+\n+    /**\n+     * Process end of line.\n+     * <p>\n+     * <code>end-of-line := 0xA | 0xD</code>\n+     *\n+     * @return End of line trivia\n+     */\n+    private STNode processEndOfLine() {\n+        char c = reader.peek();\n+        switch (c) {\n+            case LexerTerminals.NEWLINE:\n+                reader.advance();\n+                return STNodeFactory.createMinutiae(SyntaxKind.END_OF_LINE_MINUTIAE, getLexeme());\n+            case LexerTerminals.CARRIAGE_RETURN:\n+                reader.advance();\n+                if (reader.peek() == LexerTerminals.NEWLINE) {\n+                    reader.advance();\n+                }\n+                return STNodeFactory.createMinutiae(SyntaxKind.END_OF_LINE_MINUTIAE, getLexeme());\n+            default:\n+                throw new IllegalStateException();\n+        }\n+    }\n+\n+    private STToken getDocumentationSyntaxToken(SyntaxKind kind) {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        resetLeadingTrivia();\n+\n+        STNode trailingTrivia = processTrailingTrivia();\n+        // check for end of line minutiae and terminate current documentation mode.\n+        int bucketCount = trailingTrivia.bucketCount();\n+        if (bucketCount > 0 &&\n+                trailingTrivia.childInBucket(bucketCount - 1).kind == SyntaxKind.END_OF_LINE_MINUTIAE) {\n+            endMode();\n+        }\n+        return STNodeFactory.createToken(kind, leadingTrivia, trailingTrivia);\n+    }\n+\n+    private STToken getDocumentationSyntaxTokenWithNoTrivia(SyntaxKind kind) {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        resetLeadingTrivia();\n+\n+        // We reach here only for the hash token, minus token and backtick token in the documentation mode.\n+        // Trivia for those tokens can only be an end of line.\n+        // Rest of the trivia after that belongs to the documentation description or the backtick content.\n+        STNode trailingTrivia;\n+        List<STNode> triviaList = new ArrayList<>(1);\n+\n+        int nextChar = peek();\n+        if (nextChar == LexerTerminals.NEWLINE || nextChar == LexerTerminals.CARRIAGE_RETURN) {\n+            reader.mark();\n+            triviaList.add(processEndOfLine());\n+            // end of line reached, hence end documentation mode\n+            endMode();\n+        }\n+\n+        trailingTrivia = STNodeFactory.createNodeList(triviaList);\n+        return STNodeFactory.createToken(kind, leadingTrivia, trailingTrivia);\n+    }\n+\n+    private STToken getDocumentationLiteral(SyntaxKind kind) {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        resetLeadingTrivia();\n+\n+        String lexeme = getLexeme();\n+        STNode trailingTrivia = processTrailingTrivia();\n+\n+        // Check for end of line minutiae and terminate the current documentation mode.\n+        int bucketCount = trailingTrivia.bucketCount();\n+        if (bucketCount > 0 &&\n+                trailingTrivia.childInBucket(bucketCount - 1).kind == SyntaxKind.END_OF_LINE_MINUTIAE) {\n+            endMode();\n+        }\n+        return STNodeFactory.createLiteralValueToken(kind, lexeme, leadingTrivia, trailingTrivia);\n+    }\n+\n+    private STToken getDocumentationDescriptionToken() {\n+        STNode leadingTrivia = STNodeFactory.createNodeList(this.leadingTriviaList);\n+        resetLeadingTrivia();\n+        String lexeme = getLexeme();\n+        STNode trailingTrivia = processTrailingTrivia();\n+        return STNodeFactory.createLiteralValueToken(SyntaxKind.DOCUMENTATION_DESCRIPTION, lexeme, leadingTrivia,\n+                trailingTrivia);\n+    }\n+\n+    /*\n+     * ------------------------------------------------------------------------------------------------------------\n+     * DOCUMENTATION_INIT Mode\n+     * ------------------------------------------------------------------------------------------------------------\n+     */\n+\n+    private STToken readDocumentationInitToken() {\n+        reader.mark();\n+        if (reader.isEOF()) {\n+            return getDocumentationSyntaxToken(SyntaxKind.EOF_TOKEN);\n+        }\n+\n+        int nextChar = peek();\n+        if (nextChar == LexerTerminals.HASH) {\n+            reader.advance();\n+            startMode(ParserMode.DOCUMENTATION);\n+            return getDocumentationSyntaxTokenWithNoTrivia(SyntaxKind.HASH_TOKEN);\n+        } else {\n+            throw new IllegalStateException(\"documentation line should always start with a hash\");\n+        }\n+    }\n+\n+    /*\n+     * ------------------------------------------------------------------------------------------------------------\n+     * DOCUMENTATION Mode\n+     * ------------------------------------------------------------------------------------------------------------\n+     */\n+\n+    private STToken readDocumentationToken() {\n+        // Look ahead and see if next non-trivial char is a plus char or a hash char.\n+        // If it is a plus char, process trivial chars as leading trivia of the plus token.\n+        // If it is a hash char, look ahead and see if it is followed by a deprecation literal.\n+        // Else, let trivial chars be a part of the documentation description.\n+        int lookAheadCount = 0;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        if (lookAheadChar == LexerTerminals.PLUS) {\n+            return processPlusToken();\n+        } else if (lookAheadChar == LexerTerminals.HASH) {\n+            return processDeprecationLiteralToken(lookAheadCount);\n+        } else {\n+            return readDocumentationInternalToken();\n+        }\n+    }\n+\n+    private STToken processPlusToken() {\n+        processLeadingTrivia();\n+        reader.advance();\n+        switchMode(ParserMode.DOCUMENTATION_PARAMETER);\n+        return getDocumentationSyntaxToken(SyntaxKind.PLUS_TOKEN);\n+    }\n+\n+    private STToken processDeprecationLiteralToken(int lookAheadCount) {\n+        // Look ahead and see if next non-trivial char belongs to a deprecation literal.\n+        // There could be spaces and tabs in between.\n+        lookAheadCount++;\n+        int lookAheadChar = reader.peek(lookAheadCount);\n+\n+        int whitespaceCount = 0;\n+        while (lookAheadChar == LexerTerminals.SPACE || lookAheadChar == LexerTerminals.TAB) {\n+            lookAheadCount++;\n+            whitespaceCount++;\n+            lookAheadChar = reader.peek(lookAheadCount);\n+        }\n+\n+        // Look ahead for a \"Deprecated\" word match.\n+        char[] deprecatedChars = {'D', 'e', 'p', 'r', 'e', 'c', 'a', 't', 'e', 'd' };", "originalCommit": "037a99c8cd7e235b40a9b508c4e5ad0647724b7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}