{"pr_number": 25302, "pr_title": "Add object constructor expression support", "pr_createdAt": "2020-08-18T05:37:24Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302", "timeline": [{"oid": "41de2791988adbc0aba45daa280fb390539cc36d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/41de2791988adbc0aba45daa280fb390539cc36d", "message": "Add parser node transformer support for object-constructor-expression", "committedDate": "2020-08-18T05:20:50Z", "type": "commit"}, {"oid": "3866fa1d13b38d42a0bd36ead20aa19dd68227ad", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3866fa1d13b38d42a0bd36ead20aa19dd68227ad", "message": "Add object-ctor-expression front-end changes", "committedDate": "2020-08-18T05:24:56Z", "type": "commit"}, {"oid": "75a9734e7fa44743d2c9c826ac066b06bb4753ef", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/75a9734e7fa44743d2c9c826ac066b06bb4753ef", "message": "Taint analyzer changes for object-constructor-expression", "committedDate": "2020-08-18T05:29:14Z", "type": "commit"}, {"oid": "c938aed5d5c2c46cccf35c30eb365286c036c896", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c938aed5d5c2c46cccf35c30eb365286c036c896", "message": "Add test cases for object-constructor-expression", "committedDate": "2020-08-18T05:29:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkyODI2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r471928263", "bodyText": "\ud83c\udfd5\ufe0f  Not related to this PR", "author": "KRVPerera", "createdAt": "2020-08-18T05:46:20Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/semantics/analyzer/TypeChecker.java", "diffHunk": "@@ -2118,7 +2119,7 @@ public void visit(BLangSimpleVarRef varRefExpr) {\n             //  locally defined record type defs. This check should be removed once local var referencing is supported.\n             if (((symbol.tag & SymTag.VARIABLE) == SymTag.VARIABLE)) {\n                 BVarSymbol varSym = (BVarSymbol) symbol;\n-                checkSefReferences(varRefExpr.pos, env, varSym);\n+                checkSelfReferences(varRefExpr.pos, env, varSym);", "originalCommit": "c938aed5d5c2c46cccf35c30eb365286c036c896", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cc94f0c7a4ea8ddb418bfd7b397d9c178f42e3cc", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cc94f0c7a4ea8ddb418bfd7b397d9c178f42e3cc", "message": "Fix negative test case", "committedDate": "2020-08-18T05:51:05Z", "type": "commit"}, {"oid": "d2d65a4f748ec3036fb029bd7f5d19c98c466e39", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2d65a4f748ec3036fb029bd7f5d19c98c466e39", "message": "Remove unused attributes from BLangObjectCtorExpr", "committedDate": "2020-08-19T04:07:53Z", "type": "commit"}, {"oid": "1a228160fc0967f67ce2aff96e1d824065f19fd2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a228160fc0967f67ce2aff96e1d824065f19fd2", "message": "Add init method checks for object-ctor-expression", "committedDate": "2020-08-19T04:09:26Z", "type": "commit"}, {"oid": "6fa30a3fb1522039b4b36e6384f159ee177731a5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6fa30a3fb1522039b4b36e6384f159ee177731a5", "message": "Remove balos as cannot disable on old parser", "committedDate": "2020-08-19T04:44:44Z", "type": "commit"}, {"oid": "8d1062f8f8826a6f5b9d6a09e2c4579c1e1fd9cf", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/8d1062f8f8826a6f5b9d6a09e2c4579c1e1fd9cf", "message": "Fix code formatting issue", "committedDate": "2020-08-19T05:28:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjgyMzg1OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r472823858", "bodyText": "\ud83d\udd27 Need to remove all unused methods", "author": "KRVPerera", "createdAt": "2020-08-19T07:51:20Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/expressions/BLangObjectCtorExpr.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.tree.expressions;\n+\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.SimpleVariableNode;\n+import org.ballerinalang.model.tree.types.StructureTypeNode;\n+import org.ballerinalang.model.tree.types.TypeNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangObjectTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Represents the object-constructor-expr.\n+ *\n+ * @since slp3\n+ */\n+public class BLangObjectCtorExpr extends BLangExpression implements StructureTypeNode {\n+\n+    public BLangObjectTypeNode objectTypeNode;\n+    public BLangTypeInit typeInit;\n+    public BLangType referenceType;\n+\n+    public BLangObjectCtorExpr(BLangObjectTypeNode objectTypeNode) {\n+        super();\n+        this.objectTypeNode = objectTypeNode;\n+    }\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    /**\n+     * Returns the kind of this node.\n+     *\n+     * @return the kind of this node.\n+     */\n+    @Override\n+    public NodeKind getKind() {\n+\n+        return NodeKind.OBJECT_CTOR_EXPRESSION;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(\"OCE {\");\n+        sb.append(this.objectTypeNode.toString());\n+        sb.append(\"};\\n\");\n+        return sb.toString();\n+    }\n+\n+    @Override\n+    public boolean getIsAnonymous() {", "originalCommit": "8d1062f8f8826a6f5b9d6a09e2c4579c1e1fd9cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "700fdf265d65ca68beba9176f89ace237816f4f3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/700fdf265d65ca68beba9176f89ace237816f4f3", "message": "Remove StructureTypeNode interface from BLangObjectCtorExpr", "committedDate": "2020-08-19T09:19:37Z", "type": "commit"}, {"oid": "700fdf265d65ca68beba9176f89ace237816f4f3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/700fdf265d65ca68beba9176f89ace237816f4f3", "message": "Remove StructureTypeNode interface from BLangObjectCtorExpr", "committedDate": "2020-08-19T09:19:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5MzEwMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473893102", "bodyText": "Shall we add these grammar rules as a doc comment? you can check other places for a sample", "author": "lochana-chathura", "createdAt": "2020-08-20T11:14:56Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5MzM4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473893380", "bodyText": "these context starts  and closes are not necessary.", "author": "lochana-chathura", "createdAt": "2020-08-20T11:15:28Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn\n+     *\n+     * @param isRhsExpr\n+     * @param annots\n+     * @return Parsed node\n+     */\n+    private STNode parseObjectConstructorExpressionNode(boolean isRhsExpr, STNode annots) {\n+\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR);\n+\n+        STNode objectTypeQualifier;\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.CLIENT_KEYWORD) {\n+            startContext(ParserRuleContext.CLIENT_KEYWORD);", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5Mzk2MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473893960", "bodyText": "Since we come here after checking next token is CLIENT_KEYWORD, we can directly use consume() without going to parseClientKeyword()", "author": "lochana-chathura", "createdAt": "2020-08-20T11:16:41Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn\n+     *\n+     * @param isRhsExpr\n+     * @param annots\n+     * @return Parsed node\n+     */\n+    private STNode parseObjectConstructorExpressionNode(boolean isRhsExpr, STNode annots) {\n+\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR);\n+\n+        STNode objectTypeQualifier;\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.CLIENT_KEYWORD) {\n+            startContext(ParserRuleContext.CLIENT_KEYWORD);\n+            objectTypeQualifier = parseClientKeyword();", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5NTAyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473895023", "bodyText": "we need type-reference := identifier | qualified-identifier right? not a typeDescriptor\ncan use parseQualifiedIdentifier() for that.", "author": "lochana-chathura", "createdAt": "2020-08-20T11:18:43Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn\n+     *\n+     * @param isRhsExpr\n+     * @param annots\n+     * @return Parsed node\n+     */\n+    private STNode parseObjectConstructorExpressionNode(boolean isRhsExpr, STNode annots) {\n+\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR);\n+\n+        STNode objectTypeQualifier;\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.CLIENT_KEYWORD) {\n+            startContext(ParserRuleContext.CLIENT_KEYWORD);\n+            objectTypeQualifier = parseClientKeyword();\n+            endContext();\n+        } else {\n+            objectTypeQualifier = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode objectKeyword = parseObjectKeyword();\n+\n+        STNode typeDescriptor;\n+        nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            typeDescriptor = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_NEW_EXPR);", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQwMDQ5NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r474400494", "bodyText": "Please help check changed according to this and comment #25302 (comment)", "author": "KRVPerera", "createdAt": "2020-08-21T04:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5NTAyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjE0NDk0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r476144942", "bodyText": "Current way of parsing looks OK to me!", "author": "lochana-chathura", "createdAt": "2020-08-25T04:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5NTAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5NTUzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473895534", "bodyText": "Shall we change method name parseObjectConstructorExpressionNode to parseObjectConstructorExpression to be aligned with other expressions.", "author": "lochana-chathura", "createdAt": "2020-08-20T11:19:48Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn\n+     *\n+     * @param isRhsExpr\n+     * @param annots\n+     * @return Parsed node\n+     */\n+    private STNode parseObjectConstructorExpressionNode(boolean isRhsExpr, STNode annots) {", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5NjM1NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473896355", "bodyText": "don't need this context as well since we are already inside OBJECT_CONSTRUCTOR context", "author": "lochana-chathura", "createdAt": "2020-08-20T11:21:19Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn\n+     *\n+     * @param isRhsExpr\n+     * @param annots\n+     * @return Parsed node\n+     */\n+    private STNode parseObjectConstructorExpressionNode(boolean isRhsExpr, STNode annots) {\n+\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR);\n+\n+        STNode objectTypeQualifier;\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.CLIENT_KEYWORD) {\n+            startContext(ParserRuleContext.CLIENT_KEYWORD);\n+            objectTypeQualifier = parseClientKeyword();\n+            endContext();\n+        } else {\n+            objectTypeQualifier = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode objectKeyword = parseObjectKeyword();\n+\n+        STNode typeDescriptor;\n+        nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            typeDescriptor = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_NEW_EXPR);\n+        } else {\n+            typeDescriptor = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode objectCtorBody = parseObjectConstructorBody();\n+\n+        endContext();\n+\n+        return STNodeFactory.createObjectConstructorExpressionNode(annots,\n+                objectTypeQualifier, objectKeyword, typeDescriptor, objectCtorBody);\n+    }\n+\n+    private STNode parseObjectConstructorBody() {\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR_BODY);", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5NzEyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473897124", "bodyText": "I think currently parseObjectMembers() allows object-type-inclusion := * type-reference ; as well.\nI can fix this when adding error recovery though. :)", "author": "lochana-chathura", "createdAt": "2020-08-20T11:23:04Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn\n+     *\n+     * @param isRhsExpr\n+     * @param annots\n+     * @return Parsed node\n+     */\n+    private STNode parseObjectConstructorExpressionNode(boolean isRhsExpr, STNode annots) {\n+\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR);\n+\n+        STNode objectTypeQualifier;\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.CLIENT_KEYWORD) {\n+            startContext(ParserRuleContext.CLIENT_KEYWORD);\n+            objectTypeQualifier = parseClientKeyword();\n+            endContext();\n+        } else {\n+            objectTypeQualifier = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode objectKeyword = parseObjectKeyword();\n+\n+        STNode typeDescriptor;\n+        nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            typeDescriptor = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_NEW_EXPR);\n+        } else {\n+            typeDescriptor = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode objectCtorBody = parseObjectConstructorBody();\n+\n+        endContext();\n+\n+        return STNodeFactory.createObjectConstructorExpressionNode(annots,\n+                objectTypeQualifier, objectKeyword, typeDescriptor, objectCtorBody);\n+    }\n+\n+    private STNode parseObjectConstructorBody() {\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR_BODY);\n+\n+        STNode openBrace = parseOpenBrace();\n+        STNode objectMembers = parseObjectMembers();", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MDY3Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473950673", "bodyText": "Do we have to duplicate functions or can we set a class level boolean to handle this easily?\nAs an example.\neg:\nskipInclusion = true;\nSTNode objectMembers = parseObjectMembers();\nskipInclusion = false;\nThen conditionally handle at parseObjectMemberWithoutMeta.", "author": "KRVPerera", "createdAt": "2020-08-20T13:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5NzEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2Mzc0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473963740", "bodyText": "Class level variables can be dangerous since the parser is recursive-descent.\neg: an anon-object inside the object constructor - then the flag is set to true when the parser reaches the inner construct, where it should have been false\nPassing a flag to the method as a parameter would be fine though.", "author": "SupunS", "createdAt": "2020-08-20T13:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5NzEyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM5Mjk3MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r475392971", "bodyText": "Done with commit : df2ec9d", "author": "KRVPerera", "createdAt": "2020-08-24T07:26:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5NzEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5Nzg2Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473897866", "bodyText": "I think it is better to merge two nodes. @SupunS WDYT?", "author": "lochana-chathura", "createdAt": "2020-08-20T11:24:41Z", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -1125,6 +1125,56 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"ObjectConstructorExpressionNode\",\n+            \"base\": \"ExpressionNode\",\n+            \"kind\": \"OBJECT_CONSTRUCTOR\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"annotations\",\n+                    \"type\": \"AnnotationNode\",\n+                    \"occurrences\": \"MULTIPLE\"\n+                },\n+                {\n+                    \"name\": \"objectTypeQualifier\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"objectKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"typeDescriptor\",\n+                    \"type\": \"TypeDescriptorNode\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"objectConstructorBody\",\n+                    \"type\": \"ObjectConstructorBodyNode\"\n+                }\n+            ]\n+        },\n+        {\n+            \"name\": \"ObjectConstructorBodyNode\",\n+            \"base\": \"Node\",\n+            \"kind\": \"OBJECT_CONSTRUCTOR_BODY\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"openBraceToken\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"members\",\n+                    \"type\": \"Node\",\n+                    \"occurrences\": \"MULTIPLE\"\n+                },\n+                {\n+                    \"name\": \"closeBraceToken\",\n+                    \"type\": \"Token\"\n+                }\n+            ]\n+        },", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk3MTE2Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473971163", "bodyText": "+1", "author": "SupunS", "createdAt": "2020-08-20T13:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5Nzg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM5OTQ0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r474399448", "bodyText": "done", "author": "KRVPerera", "createdAt": "2020-08-21T04:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5Nzg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5OTc3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473899779", "bodyText": "{\n                    \"name\": \"qualifierList\",\n                    \"type\": \"Token\",\n                    \"occurrences\": \"MULTIPLE\"\n                }\nShall we use qualifierList instead?  bcz when there's a change to no of preceding qualifiers we don't need to change the syntax tree.\nCheck MethodDeclarationNode there's similar case with remote-qual := remote", "author": "lochana-chathura", "createdAt": "2020-08-20T11:28:22Z", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -1125,6 +1125,56 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"ObjectConstructorExpressionNode\",\n+            \"base\": \"ExpressionNode\",\n+            \"kind\": \"OBJECT_CONSTRUCTOR\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"annotations\",\n+                    \"type\": \"AnnotationNode\",\n+                    \"occurrences\": \"MULTIPLE\"\n+                },\n+                {\n+                    \"name\": \"objectTypeQualifier\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2NTc3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473965776", "bodyText": "+1", "author": "SupunS", "createdAt": "2020-08-20T13:22:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5OTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM5OTk4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r474399985", "bodyText": "I changed this. Accept as a qualifier list (not optional) and throw an exception on Node transformer for unexpected tokens hope this the correct way to handle this.", "author": "KRVPerera", "createdAt": "2020-08-21T04:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzg5OTc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkwMDMyNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473900324", "bodyText": "missing EOF newline", "author": "lochana-chathura", "createdAt": "2020-08-20T11:29:32Z", "path": "tests/jballerina-unit-test/src/test/resources/test-src/expressions/object/object_constructor_expression_negative.bal", "diffHunk": "@@ -0,0 +1,34 @@\n+// Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// test object reference type\n+\n+type SampleRec record {};\n+\n+var objCreatedViaConstructor = object SampleRec {};\n+\n+var notClient = object {\n+    private remote function remoteFunc() {}\n+};\n+\n+var invalidInit = object {\n+    private function init(int x) {}\n+};\n+\n+var objVariable = object {\n+    private function init() {\n+    }\n+};", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkwMDQwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473900400", "bodyText": "add new line", "author": "lochana-chathura", "createdAt": "2020-08-20T11:29:42Z", "path": "tests/jballerina-unit-test/src/test/resources/test-src/expressions/object/object_constructor_expression.bal", "diffHunk": "@@ -0,0 +1,155 @@\n+// Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+//\n+// WSO2 Inc. licenses this file to you under the Apache License,\n+// Version 2.0 (the \"License\"); you may not use this file except\n+// in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// test object field access\n+\n+type MO object {\n+    int x = 0;\n+};\n+\n+type MOO object {\n+    *MO;\n+    int n = 0;\n+\n+    public function init() {\n+        self.x = 5;\n+    }\n+};\n+\n+var objCreatedViaConstructor = object MOO {\n+    int n = 20;\n+    int y = 5;\n+\n+    public function init() {\n+        self.x = 4;\n+        self.y = 10;\n+    }\n+};\n+\n+function testObjectCreationViaObjectConstructor() {\n+    assertValueEquality(20, objCreatedViaConstructor.n);\n+    assertValueEquality(4, objCreatedViaConstructor.x);\n+    assertValueEquality(10, objCreatedViaConstructor.y);\n+}\n+\n+// Test annotation attachment and access\n+\n+public type ObjectData record {|\n+    string descriptor = \"\";\n+|};\n+\n+public annotation ObjectData OBJAnnots on type;\n+\n+var obj = @OBJAnnots { descriptor: \"ConstructedObject\" }\n+    object {\n+        int n = 0;\n+        function inc() {\n+            self.n += 1;\n+        }\n+    };\n+\n+function testObjectConstructorAnnotationAttachment() {\n+    typedesc<object{}> t = typeof obj;\n+    ObjectData annotationVal = <ObjectData>t.@OBJAnnots;\n+    assertValueEquality(\"ConstructedObject\", annotationVal.descriptor);\n+}\n+\n+function testObjectConstructorObjectFunctionInvocation() {\n+    obj.inc();\n+    assertTrue(obj.n == 1);\n+    obj.inc();\n+    assertTrue(obj.n == 2);\n+}\n+\n+//var remoteObject = @OBJAnnots { descriptor: \"ConstructedObject\" }\n+//    client object {\n+//        int n = 0;\n+//        remote function remoteFunc() {\n+//            self.n += 1;\n+//        }\n+//\n+//        function inc() {\n+//            self.n += 1;\n+//        }\n+//    };\n+//\n+//function testObjectConstructorClientKeyword() {\n+//    remoteObject->remoteFunc();\n+//    assertTrue(remoteObject.n == 1);\n+//    remoteObject.inc();\n+//    assertTrue(remoteObject.n == 2);\n+//}\n+\n+type MoAdvanced object {\n+    int n = 0;\n+\n+    public function setN(int userN) {\n+        self.n = userN;\n+    }\n+\n+    public function init() {\n+        self.n = 0;\n+    }\n+};\n+\n+function testObjectConstructorIncludedMethod() {\n+    var objWithIncludedMethod = object MoAdvanced {\n+\n+        public function init() {\n+            self.n = -1;\n+        }\n+\n+        public function setN(int userN) {\n+            self.n = userN;\n+        }\n+    };\n+\n+    objWithIncludedMethod.setN(200);\n+    assertTrue(objWithIncludedMethod.n == 200);\n+    objWithIncludedMethod.setN(100);\n+    assertTrue(objWithIncludedMethod.n == 100);\n+}\n+\n+// assertion helpers\n+\n+const ASSERTION_ERROR_REASON = \"AssertionError\";\n+\n+function assertTrue(any|error actual) {\n+    if actual is boolean && actual {\n+        return;\n+    }\n+\n+    panic error(ASSERTION_ERROR_REASON,\n+                message = \"expected 'true', found '\" + actual.toString () + \"'\");\n+}\n+\n+function assertFalse(any|error actual) {\n+    if actual is boolean && !actual {\n+        return;\n+    }\n+\n+    panic error(ASSERTION_ERROR_REASON,\n+                message = \"expected 'false', found '\" + actual.toString () + \"'\");\n+}\n+\n+function assertValueEquality(anydata|error expected, anydata|error actual) {\n+    if expected == actual {\n+        return;\n+    }\n+\n+    panic error(ASSERTION_ERROR_REASON,\n+                message = \"expected '\" + expected.toString() + \"', found '\" + actual.toString () + \"'\");\n+}", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkwMDQ4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473900489", "bodyText": "add new liine :)", "author": "lochana-chathura", "createdAt": "2020-08-20T11:29:53Z", "path": "tests/jballerina-unit-test/src/test/resources/test-src/balo/test_balo/object/test_objects.bal", "diffHunk": "@@ -303,4 +303,4 @@ public function testObjectReferingNonAbstractObjLoadedFromBalo() {\n     utils:assertEquality((), cemp1.setWorkingFromHomeAllowance(50));\n     utils:assertEquality(\"Contactless hello! John\", cemp1.getName());\n     utils:assertEquality(20, cemp1.Age());\n-}\n+}", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzkzOTkyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473939929", "bodyText": "If we invert the conditions of if-else stmts, we can reduce the number of nested levels.", "author": "SupunS", "createdAt": "2020-08-20T12:42:47Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -898,6 +901,104 @@ public BLangNode transform(ObjectTypeDescriptorNode objTypeDescNode) {\n         return deSugarTypeAsUserDefType(objectTypeNode);\n     }\n \n+    @Override\n+    public BLangNode transform(ObjectConstructorBodyNode objectConstructorBodyNode) {\n+        BLangObjectTypeNode objectTypeNode = (BLangObjectTypeNode) TreeBuilder.createObjectTypeNode();\n+        objectTypeNode.flagSet.add(Flag.ANONYMOUS);\n+\n+        NodeList<Node> members = objectConstructorBodyNode.members();\n+\n+        for (Node node : members) {\n+            BLangNode bLangNode = node.apply(this);\n+            if (bLangNode.getKind() == NodeKind.FUNCTION) {\n+                BLangFunction bLangFunction = (BLangFunction) bLangNode;\n+                bLangFunction.attachedFunction = true;\n+                bLangFunction.flagSet.add(Flag.ATTACHED);\n+                if (Names.USER_DEFINED_INIT_SUFFIX.value.equals(bLangFunction.name.value)) {\n+                    if (objectTypeNode.initFunction == null) {\n+                        if (bLangFunction.requiredParams.size() != 0) {\n+                            dlog.error(bLangFunction.pos, DiagnosticCode.OBJECT_CTOR_INIT_CANNOT_HAVE_PARAMETERS);", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MTk4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473941987", "bodyText": "Ideally we shouldn't reach here. So throwing an exception would be better.", "author": "SupunS", "createdAt": "2020-08-20T12:46:27Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -898,6 +901,104 @@ public BLangNode transform(ObjectTypeDescriptorNode objTypeDescNode) {\n         return deSugarTypeAsUserDefType(objectTypeNode);\n     }\n \n+    @Override\n+    public BLangNode transform(ObjectConstructorBodyNode objectConstructorBodyNode) {\n+        BLangObjectTypeNode objectTypeNode = (BLangObjectTypeNode) TreeBuilder.createObjectTypeNode();\n+        objectTypeNode.flagSet.add(Flag.ANONYMOUS);\n+\n+        NodeList<Node> members = objectConstructorBodyNode.members();\n+\n+        for (Node node : members) {\n+            BLangNode bLangNode = node.apply(this);\n+            if (bLangNode.getKind() == NodeKind.FUNCTION) {\n+                BLangFunction bLangFunction = (BLangFunction) bLangNode;\n+                bLangFunction.attachedFunction = true;\n+                bLangFunction.flagSet.add(Flag.ATTACHED);\n+                if (Names.USER_DEFINED_INIT_SUFFIX.value.equals(bLangFunction.name.value)) {\n+                    if (objectTypeNode.initFunction == null) {\n+                        if (bLangFunction.requiredParams.size() != 0) {\n+                            dlog.error(bLangFunction.pos, DiagnosticCode.OBJECT_CTOR_INIT_CANNOT_HAVE_PARAMETERS);\n+                            continue;\n+                        }\n+                        bLangFunction.objInitFunction = true;\n+                        objectTypeNode.initFunction = bLangFunction;\n+                    } else {\n+                        objectTypeNode.addFunction(bLangFunction);\n+                    }\n+                } else {\n+                    objectTypeNode.addFunction(bLangFunction);\n+                }\n+            } else if (bLangNode.getKind() == NodeKind.VARIABLE) {\n+                objectTypeNode.addField((BLangSimpleVariable) bLangNode);\n+            } else if (bLangNode.getKind() == NodeKind.USER_DEFINED_TYPE) {\n+                objectTypeNode.addTypeReference((BLangType) bLangNode);\n+            }\n+        }\n+\n+        objectTypeNode.isAnonymous = true;\n+        objectTypeNode.pos = getPosition(objectConstructorBodyNode);\n+        return objectTypeNode;\n+    }\n+\n+    @Override\n+    public BLangNode transform(ObjectConstructorExpressionNode objectConstructorExpressionNode) {\n+\n+        DiagnosticPos pos = getPositionWithoutMetadata(objectConstructorExpressionNode);\n+\n+        BLangObjectTypeNode objectTypeNode =\n+                (BLangObjectTypeNode) createTypeNode(objectConstructorExpressionNode.objectConstructorBody());\n+\n+        BLangObjectCtorExpr objectCtorExpression = TreeBuilder.createObjectCtorExpression(objectTypeNode);\n+        objectCtorExpression.pos = pos;\n+\n+        Optional<TypeDescriptorNode> typeDescriptor = objectConstructorExpressionNode.typeDescriptor();\n+\n+        typeDescriptor.ifPresent(typeDescriptorNode -> {\n+            BLangType type = createTypeNode(typeDescriptorNode);\n+            objectCtorExpression.addTypeReference(type);\n+        });\n+\n+        // create a type definition and attach annotations\n+        BLangTypeDefinition bLTypeDef = createTypeDefinitionWithTypeNode(objectTypeNode);\n+        Optional<Token> objectTypeQualifier = objectConstructorExpressionNode.objectTypeQualifier();\n+\n+        objectTypeQualifier.ifPresent(qualifier -> {\n+            if (qualifier.kind() == SyntaxKind.CLIENT_KEYWORD) {\n+                objectTypeNode.flagSet.add(Flag.CLIENT);\n+                bLTypeDef.flagSet.add(Flag.CLIENT);\n+                objectCtorExpression.isClient = true;\n+            } else {\n+                dlog.error(pos, DiagnosticCode.INVALID_TOKEN);", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MzIwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473943200", "bodyText": "Better to use the complete name BLangObjectConstructorExpression, since this is part of the public API.", "author": "SupunS", "createdAt": "2020-08-20T12:48:31Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/expressions/BLangObjectCtorExpr.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.tree.expressions;\n+\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.types.TypeNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangObjectTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+\n+\n+/**\n+ * Represents the object-constructor-expr.\n+ *\n+ * @since slp3\n+ */\n+public class BLangObjectCtorExpr extends BLangExpression {", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MzU0NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473943545", "bodyText": "extra newline", "author": "SupunS", "createdAt": "2020-08-20T12:49:06Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/tree/expressions/BLangObjectCtorExpr.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+\n+package org.wso2.ballerinalang.compiler.tree.expressions;\n+\n+import org.ballerinalang.jvm.util.exceptions.BallerinaException;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.types.TypeNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangObjectTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangType;\n+\n+\n+/**\n+ * Represents the object-constructor-expr.\n+ *\n+ * @since slp3\n+ */\n+public class BLangObjectCtorExpr extends BLangExpression {\n+\n+    public BLangObjectTypeNode objectTypeNode;\n+    public BLangTypeInit typeInit;\n+    public BLangType referenceType;\n+    public boolean isClient;\n+\n+    public BLangObjectCtorExpr(BLangObjectTypeNode objectTypeNode) {\n+        super();\n+        this.objectTypeNode = objectTypeNode;\n+        this.isClient = false;\n+    }\n+\n+    @Override\n+    public void accept(BLangNodeVisitor visitor) {\n+        visitor.visit(this);\n+    }\n+\n+    /**\n+     * Returns the kind of this node.\n+     *\n+     * @return the kind of this node.\n+     */\n+    @Override\n+    public NodeKind getKind() {\n+", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0MzkwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473943909", "bodyText": "Let's complete these parameters", "author": "SupunS", "createdAt": "2020-08-20T12:49:46Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn\n+     *\n+     * @param isRhsExpr\n+     * @param annots\n+     * @return Parsed node", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0ODQyNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473948426", "bodyText": "Here there are three possible paths:\n\nclient keyword --> parse the qualifiers\nobject keyword --> parse object\nnon of the above --> recover and re-parse\n\nThus, to handle these three cases we need a switch-case here. Refer parseFunctionBody() for a similar method.", "author": "SupunS", "createdAt": "2020-08-20T12:57:01Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn\n+     *\n+     * @param isRhsExpr\n+     * @param annots\n+     * @return Parsed node\n+     */\n+    private STNode parseObjectConstructorExpressionNode(boolean isRhsExpr, STNode annots) {\n+\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR);\n+\n+        STNode objectTypeQualifier;\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.CLIENT_KEYWORD) {", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM5MjQ4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r475392489", "bodyText": "Done", "author": "KRVPerera", "createdAt": "2020-08-24T07:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0ODQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0OTExNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473949117", "bodyText": "Same as my prev comment in L#4399", "author": "SupunS", "createdAt": "2020-08-20T12:58:09Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn\n+     *\n+     * @param isRhsExpr\n+     * @param annots\n+     * @return Parsed node\n+     */\n+    private STNode parseObjectConstructorExpressionNode(boolean isRhsExpr, STNode annots) {\n+\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR);\n+\n+        STNode objectTypeQualifier;\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.CLIENT_KEYWORD) {\n+            startContext(ParserRuleContext.CLIENT_KEYWORD);\n+            objectTypeQualifier = parseClientKeyword();\n+            endContext();\n+        } else {\n+            objectTypeQualifier = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode objectKeyword = parseObjectKeyword();\n+\n+        STNode typeDescriptor;\n+        nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN) {", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MDE2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473950168", "bodyText": "Shall we remove these additional newlines?", "author": "SupunS", "createdAt": "2020-08-20T12:59:55Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4374,6 +4377,64 @@ private STNode parseObjectTypeDescriptor() {\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * Parse object constructor expression.\n+     *\n+     * object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }\n+     * object-member := object-field | method-defn\n+     *\n+     * @param isRhsExpr\n+     * @param annots\n+     * @return Parsed node\n+     */\n+    private STNode parseObjectConstructorExpressionNode(boolean isRhsExpr, STNode annots) {\n+\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR);\n+\n+        STNode objectTypeQualifier;\n+        STToken nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.CLIENT_KEYWORD) {\n+            startContext(ParserRuleContext.CLIENT_KEYWORD);\n+            objectTypeQualifier = parseClientKeyword();\n+            endContext();\n+        } else {\n+            objectTypeQualifier = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode objectKeyword = parseObjectKeyword();\n+\n+        STNode typeDescriptor;\n+        nextToken = peek();\n+        if (nextToken.kind == SyntaxKind.IDENTIFIER_TOKEN) {\n+            typeDescriptor = parseTypeDescriptor(ParserRuleContext.TYPE_DESC_IN_NEW_EXPR);\n+        } else {\n+            typeDescriptor = STNodeFactory.createEmptyNode();\n+        }\n+\n+        STNode objectCtorBody = parseObjectConstructorBody();\n+", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MTk0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473951944", "bodyText": "We can add the package under <packages>. Then we don't have to update this xml for every new test class..", "author": "SupunS", "createdAt": "2020-08-20T13:02:48Z", "path": "tests/jballerina-unit-test/src/test/resources/testng-new-parser.xml", "diffHunk": "@@ -146,6 +146,7 @@\n             <class name=\"org.ballerinalang.test.statements.transaction.NestedTransactionTest\"/>\n             <class name=\"org.ballerinalang.test.statements.transaction.NestedRetryTransactionStmtsTest\" />\n             <class name=\"org.ballerinalang.test.statements.transaction.SetRollbackOnlyTest\" />\n+            <class name=\"org.ballerinalang.test.expressions.object.ObjectConstructorTest\" />", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk3MzEzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r473973130", "bodyText": "Should the name be \"typeReference\"?", "author": "SupunS", "createdAt": "2020-08-20T13:29:13Z", "path": "compiler/ballerina-treegen/src/main/resources/syntax_tree_descriptor.json", "diffHunk": "@@ -1125,6 +1125,56 @@\n                 }\n             ]\n         },\n+        {\n+            \"name\": \"ObjectConstructorExpressionNode\",\n+            \"base\": \"ExpressionNode\",\n+            \"kind\": \"OBJECT_CONSTRUCTOR\",\n+            \"attributes\": [\n+                {\n+                    \"name\": \"annotations\",\n+                    \"type\": \"AnnotationNode\",\n+                    \"occurrences\": \"MULTIPLE\"\n+                },\n+                {\n+                    \"name\": \"objectTypeQualifier\",\n+                    \"type\": \"Token\",\n+                    \"isOptional\": true\n+                },\n+                {\n+                    \"name\": \"objectKeyword\",\n+                    \"type\": \"Token\"\n+                },\n+                {\n+                    \"name\": \"typeDescriptor\",", "originalCommit": "700fdf265d65ca68beba9176f89ace237816f4f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f8eb452e29359a8d8632f7390b8b5c51515558dd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f8eb452e29359a8d8632f7390b8b5c51515558dd", "message": "Fix first code review suggestion by parser team", "committedDate": "2020-08-20T14:24:47Z", "type": "commit"}, {"oid": "40edc1d7bd229ca8f69813f9dde5b6ab13ad036c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/40edc1d7bd229ca8f69813f9dde5b6ab13ad036c", "message": "Change testng class to package level in xml", "committedDate": "2020-08-20T14:27:20Z", "type": "commit"}, {"oid": "bc7d3d171dc872437869dc0e005086fc1d45382f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bc7d3d171dc872437869dc0e005086fc1d45382f", "message": "Fix Parser suggestions for object-constructor-expr\n\nJoined object-constructor-body to object-constructor-expression\nUse existing object-type-qualifiers to parse client token\nChanged type definition to correct type-reference", "committedDate": "2020-08-21T04:15:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQwNjc2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r474406767", "bodyText": "Shall we use parseTypeReference() here rather than directly using parseQualifiedIdentifier()?", "author": "rdulmina", "createdAt": "2020-08-21T04:50:11Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4402,6 +4432,50 @@ private STNode parseObjectTypeQualifiers() {\n         return parseObjectTypeNextQualifiers(firstQualifier);\n     }\n \n+    /**\n+     /**\n+     * Parse object constructor expression type qualifiers.\n+     *\n+     * @return Parsed qualifier list with only client or empty node list\n+     */\n+    private STNode parseObjectConstructorExpressionQualifier() {\n+        STNode qualifier;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case CLIENT_KEYWORD:\n+                qualifier = parseClientKeyword();\n+                break;\n+            case OBJECT_KEYWORD:\n+                return STNodeFactory.createEmptyNodeList();\n+            default:\n+                recover(nextToken, ParserRuleContext.OBJECT_CONSTRUCTOR);\n+                return parseObjectConstructorExpressionQualifier();\n+        }\n+        return qualifier;\n+    }\n+\n+    /**\n+     /**\n+     * Parse object constructor expression type reference.\n+     *\n+     * @return Parsed type reference or empty node\n+     */\n+    private STNode parseObjectConstructorExpressionTypeReference() {\n+        STNode typeReference;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case IDENTIFIER_TOKEN:\n+                typeReference = parseQualifiedIdentifier(ParserRuleContext.TYPE_REFERENCE);", "originalCommit": "bc7d3d171dc872437869dc0e005086fc1d45382f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e07a3c949debfda2c73d0124de3dd071785598ac", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e07a3c949debfda2c73d0124de3dd071785598ac", "message": "change object-ctor-expr type-ref parsing logic", "committedDate": "2020-08-21T07:01:00Z", "type": "commit"}, {"oid": "b45c6382bf1051f25e60fda56e62a65e4e285d42", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b45c6382bf1051f25e60fda56e62a65e4e285d42", "message": "change object_*_expression.bal assertion logic", "committedDate": "2020-08-21T07:02:24Z", "type": "commit"}, {"oid": "df2ec9db2462323f69b6554eaa7446e660a652a7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/df2ec9db2462323f69b6554eaa7446e660a652a7", "message": "Disallow type inclusion inside object constructor", "committedDate": "2020-08-24T07:15:21Z", "type": "commit"}, {"oid": "12b6dc008dfccebc56c33489fe5af464b1e33cb7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/12b6dc008dfccebc56c33489fe5af464b1e33cb7", "message": "Fix coding style of object ctor negative tests", "committedDate": "2020-08-24T07:25:22Z", "type": "commit"}, {"oid": "1276780473fa52f93750570cdb880f1bd14b52a3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1276780473fa52f93750570cdb880f1bd14b52a3", "message": "Merge branch 'class-change' into krv_object_ctor_expression\n\n# Conflicts:\n#\tcompiler/ballerina-lang/src/main/java/org/ballerinalang/model/TreeBuilder.java\n#\tcompiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/NodeCloner.java\n#\tcompiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "committedDate": "2020-08-24T10:15:45Z", "type": "commit"}, {"oid": "b952e60f39c5fcbfb34628e4009cf6dbc491f924", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b952e60f39c5fcbfb34628e4009cf6dbc491f924", "message": "Update class changes parseObjectMember api call", "committedDate": "2020-08-24T10:20:52Z", "type": "commit"}, {"oid": "b952e60f39c5fcbfb34628e4009cf6dbc491f924", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b952e60f39c5fcbfb34628e4009cf6dbc491f924", "message": "Update class changes parseObjectMember api call", "committedDate": "2020-08-24T10:20:52Z", "type": "forcePushed"}, {"oid": "e47f09544553d5c024bf6f30fb26a2f64813a3a6", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e47f09544553d5c024bf6f30fb26a2f64813a3a6", "message": "Update docs for parseObjectMember", "committedDate": "2020-08-24T10:40:30Z", "type": "commit"}, {"oid": "b482031487decd0a4b6f60cb242924cad33dbf55", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b482031487decd0a4b6f60cb242924cad33dbf55", "message": "Merge remote-tracking branch 'up/class-change' into krv_object_ctor_expression", "committedDate": "2020-08-26T01:17:00Z", "type": "commit"}, {"oid": "a2c46768dd9fbb87d1769a80534b2f1bbbc044bd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a2c46768dd9fbb87d1769a80534b2f1bbbc044bd", "message": "Add object-constructor-expression parser tests", "committedDate": "2020-08-26T02:19:57Z", "type": "commit"}, {"oid": "7cabe7f37f79679cf84ffd0b21e39d2c03359b94", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7cabe7f37f79679cf84ffd0b21e39d2c03359b94", "message": "Add object-ctor-expr type-reference parser test", "committedDate": "2020-08-26T02:32:38Z", "type": "commit"}, {"oid": "589d4d42dc3c14c7877862c210f27122d1766e9b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/589d4d42dc3c14c7877862c210f27122d1766e9b", "message": "Clean code for object-constructor-expression body\n\nReduce if statement nested levels. Throw an exception for object-type\ninclusion. This is already handled at parser level.", "committedDate": "2020-08-26T02:58:59Z", "type": "commit"}, {"oid": "26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "message": "Add error for type inclusion in object-ctor body", "committedDate": "2020-08-26T03:28:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2NzE2OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477067169", "bodyText": "Shouldn't we return a qualifer list?\nList<STNode> qualifiers = new ArrayList<>();\nqualifiers.add(qualifier);\nreturn STNodeFactory.createNodeList(qualifiers);", "author": "lochana-chathura", "createdAt": "2020-08-26T06:38:26Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4523,6 +4555,50 @@ private STNode parseObjectTypeQualifiers() {\n         return parseObjectTypeNextQualifiers(firstQualifier);\n     }\n \n+    /**\n+     /**\n+     * Parse object constructor expression type qualifiers.\n+     *\n+     * @return Parsed qualifier list with only client or empty node list\n+     */\n+    private STNode parseObjectConstructorExpressionQualifier() {\n+        STNode qualifier;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case CLIENT_KEYWORD:\n+                qualifier = parseClientKeyword();\n+                break;\n+            case OBJECT_KEYWORD:\n+                return STNodeFactory.createEmptyNodeList();\n+            default:\n+                recover(nextToken, ParserRuleContext.OBJECT_CONSTRUCTOR);\n+                return parseObjectConstructorExpressionQualifier();\n+        }\n+        return qualifier;", "originalCommit": "26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2ODE0Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477068142", "bodyText": "Since we check if the next token is a CLIENT_KEYWORD(in this switch case) and reach here don't need to check it again inside parseClientKeyword() right?. can use consume() directly", "author": "lochana-chathura", "createdAt": "2020-08-26T06:40:49Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4523,6 +4555,50 @@ private STNode parseObjectTypeQualifiers() {\n         return parseObjectTypeNextQualifiers(firstQualifier);\n     }\n \n+    /**\n+     /**\n+     * Parse object constructor expression type qualifiers.\n+     *\n+     * @return Parsed qualifier list with only client or empty node list\n+     */\n+    private STNode parseObjectConstructorExpressionQualifier() {\n+        STNode qualifier;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case CLIENT_KEYWORD:\n+                qualifier = parseClientKeyword();", "originalCommit": "26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2ODQyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477068428", "bodyText": "extra line", "author": "lochana-chathura", "createdAt": "2020-08-26T06:41:30Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4523,6 +4555,50 @@ private STNode parseObjectTypeQualifiers() {\n         return parseObjectTypeNextQualifiers(firstQualifier);\n     }\n \n+    /**\n+     /**", "originalCommit": "26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEyNTIwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477125201", "bodyText": "thanks", "author": "KRVPerera", "createdAt": "2020-08-26T08:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2ODQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2ODU1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477068553", "bodyText": "extra line", "author": "lochana-chathura", "createdAt": "2020-08-26T06:41:45Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4523,6 +4555,50 @@ private STNode parseObjectTypeQualifiers() {\n         return parseObjectTypeNextQualifiers(firstQualifier);\n     }\n \n+    /**\n+     /**\n+     * Parse object constructor expression type qualifiers.\n+     *\n+     * @return Parsed qualifier list with only client or empty node list\n+     */\n+    private STNode parseObjectConstructorExpressionQualifier() {\n+        STNode qualifier;\n+        STToken nextToken = peek();\n+        switch (nextToken.kind) {\n+            case CLIENT_KEYWORD:\n+                qualifier = parseClientKeyword();\n+                break;\n+            case OBJECT_KEYWORD:\n+                return STNodeFactory.createEmptyNodeList();\n+            default:\n+                recover(nextToken, ParserRuleContext.OBJECT_CONSTRUCTOR);\n+                return parseObjectConstructorExpressionQualifier();\n+        }\n+        return qualifier;\n+    }\n+\n+    /**\n+     /**", "originalCommit": "26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA2ODkzOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477068938", "bodyText": "extra line.", "author": "lochana-chathura", "createdAt": "2020-08-26T06:42:42Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerinalang/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -4488,13 +4493,40 @@ private STNode parseObjectTypeDescriptor() {\n         STNode objectTypeQualifiers = parseObjectTypeQualifiers();\n         STNode objectKeyword = parseObjectKeyword();\n         STNode openBrace = parseOpenBrace();\n-        STNode objectMembers = parseObjectMembers();\n+        STNode objectMembers = parseObjectMembers(false);\n         STNode closeBrace = parseCloseBrace();\n         endContext();\n         return STNodeFactory.createObjectTypeDescriptorNode(objectTypeQualifiers, objectKeyword, openBrace,\n                 objectMembers, closeBrace);\n     }\n \n+    /**\n+     * <p>\n+     * Parse object constructor expression.\n+     * </p>\n+     * <code>object-constructor-expr :=\n+     *    [annots] [client] object [type-reference] {\n+     *       object-member*\n+     *    }</code>\n+     * <code>object-member := object-field | method-defn</code>\n+     *\n+     * @param annots annotations attached to object constructor\n+     * @return Parsed object constructor expression node\n+     */\n+    private STNode parseObjectConstructorExpression(STNode annots) {\n+        startContext(ParserRuleContext.OBJECT_CONSTRUCTOR);\n+        STNode objectTypeQualifier = parseObjectConstructorExpressionQualifier();\n+        STNode objectKeyword = parseObjectKeyword();\n+        STNode typeReference = parseObjectConstructorExpressionTypeReference();\n+        STNode openBrace = parseOpenBrace();\n+        STNode objectMembers = parseObjectMembers(true);\n+        STNode closeBrace = parseCloseBrace();\n+        endContext();\n+        return STNodeFactory.createObjectConstructorExpressionNode(annots,\n+                objectTypeQualifier, objectKeyword, typeReference, openBrace, objectMembers, closeBrace);\n+    }\n+\n+    /**", "originalCommit": "26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzEyMjM3OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477122378", "bodyText": "With the introduction of classes BLangObjectTypeNode should not have method implementations, only the method declarations. Shall we move this to a BLangClassDefinition", "author": "rdhananjaya", "createdAt": "2020-08-26T08:22:20Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -900,6 +902,95 @@ public BLangNode transform(ObjectTypeDescriptorNode objTypeDescNode) {\n         return deSugarTypeAsUserDefType(objectTypeNode);\n     }\n \n+    public BLangObjectTypeNode createObjectExpressionBody(NodeList<Node> members) {\n+        BLangObjectTypeNode objectTypeNode = (BLangObjectTypeNode) TreeBuilder.createObjectTypeNode();\n+        objectTypeNode.flagSet.add(Flag.ANONYMOUS);\n+\n+        for (Node node : members) {\n+            BLangNode bLangNode = node.apply(this);\n+            NodeKind nodeKind =  bLangNode.getKind();\n+            if (nodeKind == NodeKind.FUNCTION) {\n+                BLangFunction bLangFunction = (BLangFunction) bLangNode;\n+                bLangFunction.attachedFunction = true;\n+                bLangFunction.flagSet.add(Flag.ATTACHED);\n+                if (!Names.USER_DEFINED_INIT_SUFFIX.value.equals(bLangFunction.name.value)) {\n+                    objectTypeNode.addFunction(bLangFunction);\n+                    continue;\n+                }\n+                if (objectTypeNode.initFunction != null) {\n+                    objectTypeNode.addFunction(bLangFunction);\n+                    continue;\n+                }\n+                if (bLangFunction.requiredParams.size() != 0) {\n+                    dlog.error(bLangFunction.pos, DiagnosticCode.OBJECT_CTOR_INIT_CANNOT_HAVE_PARAMETERS);\n+                    continue;\n+                }\n+                bLangFunction.objInitFunction = true;\n+                objectTypeNode.initFunction = bLangFunction;\n+            } else if (nodeKind == NodeKind.VARIABLE) {\n+                objectTypeNode.addField((BLangSimpleVariable) bLangNode);\n+            } else if (nodeKind == NodeKind.USER_DEFINED_TYPE) {\n+                dlog.error(bLangNode.pos, DiagnosticCode.OBJECT_CTOR_DOES_NOT_SUPPORT_TYPE_REFERENCE_MEMBERS);\n+            }\n+        }\n+\n+        objectTypeNode.isAnonymous = true;\n+        return objectTypeNode;\n+    }\n+\n+    @Override\n+    public BLangNode transform(ObjectConstructorExpressionNode objectConstructorExpressionNode) {\n+\n+        DiagnosticPos pos = getPositionWithoutMetadata(objectConstructorExpressionNode);\n+\n+        BLangObjectTypeNode objectTypeNode = createObjectExpressionBody(objectConstructorExpressionNode.members());", "originalCommit": "26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NzIxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477277219", "bodyText": "Any other method in TreeBuilder doesn't seem to take arguments. I'm not completely sure why it was designed like that but I think it would be better to adhere to that constraint.", "author": "rdhananjaya", "createdAt": "2020-08-26T12:54:44Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -900,6 +902,95 @@ public BLangNode transform(ObjectTypeDescriptorNode objTypeDescNode) {\n         return deSugarTypeAsUserDefType(objectTypeNode);\n     }\n \n+    public BLangObjectTypeNode createObjectExpressionBody(NodeList<Node> members) {\n+        BLangObjectTypeNode objectTypeNode = (BLangObjectTypeNode) TreeBuilder.createObjectTypeNode();\n+        objectTypeNode.flagSet.add(Flag.ANONYMOUS);\n+\n+        for (Node node : members) {\n+            BLangNode bLangNode = node.apply(this);\n+            NodeKind nodeKind =  bLangNode.getKind();\n+            if (nodeKind == NodeKind.FUNCTION) {\n+                BLangFunction bLangFunction = (BLangFunction) bLangNode;\n+                bLangFunction.attachedFunction = true;\n+                bLangFunction.flagSet.add(Flag.ATTACHED);\n+                if (!Names.USER_DEFINED_INIT_SUFFIX.value.equals(bLangFunction.name.value)) {\n+                    objectTypeNode.addFunction(bLangFunction);\n+                    continue;\n+                }\n+                if (objectTypeNode.initFunction != null) {\n+                    objectTypeNode.addFunction(bLangFunction);\n+                    continue;\n+                }\n+                if (bLangFunction.requiredParams.size() != 0) {\n+                    dlog.error(bLangFunction.pos, DiagnosticCode.OBJECT_CTOR_INIT_CANNOT_HAVE_PARAMETERS);\n+                    continue;\n+                }\n+                bLangFunction.objInitFunction = true;\n+                objectTypeNode.initFunction = bLangFunction;\n+            } else if (nodeKind == NodeKind.VARIABLE) {\n+                objectTypeNode.addField((BLangSimpleVariable) bLangNode);\n+            } else if (nodeKind == NodeKind.USER_DEFINED_TYPE) {\n+                dlog.error(bLangNode.pos, DiagnosticCode.OBJECT_CTOR_DOES_NOT_SUPPORT_TYPE_REFERENCE_MEMBERS);\n+            }\n+        }\n+\n+        objectTypeNode.isAnonymous = true;\n+        return objectTypeNode;\n+    }\n+\n+    @Override\n+    public BLangNode transform(ObjectConstructorExpressionNode objectConstructorExpressionNode) {\n+\n+        DiagnosticPos pos = getPositionWithoutMetadata(objectConstructorExpressionNode);\n+\n+        BLangObjectTypeNode objectTypeNode = createObjectExpressionBody(objectConstructorExpressionNode.members());\n+        objectTypeNode.pos = pos;\n+        BLangObjectConstructorExpression objectCtorExpression = TreeBuilder.createObjectCtorExpression(objectTypeNode);", "originalCommit": "26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4NTAwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477285007", "bodyText": "We don't seem to use this objectCtorExpression again, shall we remove this maybe", "author": "rdhananjaya", "createdAt": "2020-08-26T13:06:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3NzIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3OTQ0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477279448", "bodyText": "Shall we add a comment explaining that there is a desugaring happening here", "author": "rdhananjaya", "createdAt": "2020-08-26T12:58:11Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -900,6 +902,95 @@ public BLangNode transform(ObjectTypeDescriptorNode objTypeDescNode) {\n         return deSugarTypeAsUserDefType(objectTypeNode);\n     }\n \n+    public BLangObjectTypeNode createObjectExpressionBody(NodeList<Node> members) {\n+        BLangObjectTypeNode objectTypeNode = (BLangObjectTypeNode) TreeBuilder.createObjectTypeNode();\n+        objectTypeNode.flagSet.add(Flag.ANONYMOUS);\n+\n+        for (Node node : members) {\n+            BLangNode bLangNode = node.apply(this);\n+            NodeKind nodeKind =  bLangNode.getKind();\n+            if (nodeKind == NodeKind.FUNCTION) {\n+                BLangFunction bLangFunction = (BLangFunction) bLangNode;\n+                bLangFunction.attachedFunction = true;\n+                bLangFunction.flagSet.add(Flag.ATTACHED);\n+                if (!Names.USER_DEFINED_INIT_SUFFIX.value.equals(bLangFunction.name.value)) {\n+                    objectTypeNode.addFunction(bLangFunction);\n+                    continue;\n+                }\n+                if (objectTypeNode.initFunction != null) {\n+                    objectTypeNode.addFunction(bLangFunction);\n+                    continue;\n+                }\n+                if (bLangFunction.requiredParams.size() != 0) {\n+                    dlog.error(bLangFunction.pos, DiagnosticCode.OBJECT_CTOR_INIT_CANNOT_HAVE_PARAMETERS);\n+                    continue;\n+                }\n+                bLangFunction.objInitFunction = true;\n+                objectTypeNode.initFunction = bLangFunction;\n+            } else if (nodeKind == NodeKind.VARIABLE) {\n+                objectTypeNode.addField((BLangSimpleVariable) bLangNode);\n+            } else if (nodeKind == NodeKind.USER_DEFINED_TYPE) {\n+                dlog.error(bLangNode.pos, DiagnosticCode.OBJECT_CTOR_DOES_NOT_SUPPORT_TYPE_REFERENCE_MEMBERS);\n+            }\n+        }\n+\n+        objectTypeNode.isAnonymous = true;\n+        return objectTypeNode;\n+    }\n+\n+    @Override\n+    public BLangNode transform(ObjectConstructorExpressionNode objectConstructorExpressionNode) {\n+", "originalCommit": "26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4MTExMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25302#discussion_r477281110", "bodyText": "no need to break the line I think", "author": "rdhananjaya", "createdAt": "2020-08-26T13:00:42Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -900,6 +902,95 @@ public BLangNode transform(ObjectTypeDescriptorNode objTypeDescNode) {\n         return deSugarTypeAsUserDefType(objectTypeNode);\n     }\n \n+    public BLangObjectTypeNode createObjectExpressionBody(NodeList<Node> members) {\n+        BLangObjectTypeNode objectTypeNode = (BLangObjectTypeNode) TreeBuilder.createObjectTypeNode();\n+        objectTypeNode.flagSet.add(Flag.ANONYMOUS);\n+\n+        for (Node node : members) {\n+            BLangNode bLangNode = node.apply(this);\n+            NodeKind nodeKind =  bLangNode.getKind();\n+            if (nodeKind == NodeKind.FUNCTION) {\n+                BLangFunction bLangFunction = (BLangFunction) bLangNode;\n+                bLangFunction.attachedFunction = true;\n+                bLangFunction.flagSet.add(Flag.ATTACHED);\n+                if (!Names.USER_DEFINED_INIT_SUFFIX.value.equals(bLangFunction.name.value)) {\n+                    objectTypeNode.addFunction(bLangFunction);\n+                    continue;\n+                }\n+                if (objectTypeNode.initFunction != null) {\n+                    objectTypeNode.addFunction(bLangFunction);\n+                    continue;\n+                }\n+                if (bLangFunction.requiredParams.size() != 0) {\n+                    dlog.error(bLangFunction.pos, DiagnosticCode.OBJECT_CTOR_INIT_CANNOT_HAVE_PARAMETERS);\n+                    continue;\n+                }\n+                bLangFunction.objInitFunction = true;\n+                objectTypeNode.initFunction = bLangFunction;\n+            } else if (nodeKind == NodeKind.VARIABLE) {\n+                objectTypeNode.addField((BLangSimpleVariable) bLangNode);\n+            } else if (nodeKind == NodeKind.USER_DEFINED_TYPE) {\n+                dlog.error(bLangNode.pos, DiagnosticCode.OBJECT_CTOR_DOES_NOT_SUPPORT_TYPE_REFERENCE_MEMBERS);\n+            }\n+        }\n+\n+        objectTypeNode.isAnonymous = true;\n+        return objectTypeNode;\n+    }\n+\n+    @Override\n+    public BLangNode transform(ObjectConstructorExpressionNode objectConstructorExpressionNode) {\n+\n+        DiagnosticPos pos = getPositionWithoutMetadata(objectConstructorExpressionNode);\n+\n+        BLangObjectTypeNode objectTypeNode = createObjectExpressionBody(objectConstructorExpressionNode.members());\n+        objectTypeNode.pos = pos;\n+        BLangObjectConstructorExpression objectCtorExpression = TreeBuilder.createObjectCtorExpression(objectTypeNode);\n+        objectCtorExpression.pos = pos;\n+\n+        Optional<TypeDescriptorNode> typeReference = objectConstructorExpressionNode.typeReference();\n+        typeReference.ifPresent(typeReferenceNode -> {\n+            objectCtorExpression.addTypeReference(createTypeNode(typeReferenceNode));\n+        });\n+\n+        BLangTypeDefinition bLTypeDef = createTypeDefinitionWithTypeNode(objectTypeNode);\n+\n+        NodeList<Token> objectConstructorQualifierList = objectConstructorExpressionNode.objectTypeQualifiers();\n+        for (Token qualifier : objectConstructorQualifierList) {\n+            if (qualifier.kind() == SyntaxKind.CLIENT_KEYWORD) {\n+                objectTypeNode.flagSet.add(Flag.CLIENT);\n+                objectCtorExpression.isClient = true;\n+            } else {\n+                throw new RuntimeException(\"Syntax kind is not supported: \" + qualifier.kind());\n+            }\n+        }\n+        bLTypeDef.annAttachments = applyAll(objectConstructorExpressionNode.annotations());\n+        addToTop(bLTypeDef);\n+\n+        BLangIdentifier identifier = (BLangIdentifier) TreeBuilder.createIdentifierNode();\n+        BLangUserDefinedType userDefinedType = createUserDefinedType(pos,\n+                identifier, bLTypeDef.name);", "originalCommit": "26b96cbf2d6bd8a5c4da44dd1015283fd9ddf306", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}