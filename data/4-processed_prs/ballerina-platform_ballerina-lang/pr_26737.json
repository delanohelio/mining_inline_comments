{"pr_number": 26737, "pr_title": "Refactor code position selection for code actions", "pr_createdAt": "2020-11-04T07:00:42Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737", "timeline": [{"oid": "bb93e1ccc8b72324d34af34a7e932e6f5e665632", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bb93e1ccc8b72324d34af34a7e932e6f5e665632", "message": "Refactor code action selection logic\n\nRefactor code action selection logic to consider documentation, tree node position, etc.", "committedDate": "2020-11-04T19:16:45Z", "type": "forcePushed"}, {"oid": "f1e69b4a63dd40d4e388a58c82f48599153ef3f3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f1e69b4a63dd40d4e388a58c82f48599153ef3f3", "message": "Refactor code position selection for a code action\n\nRefactor the logic for selecting the position to display/not display the code actions.", "committedDate": "2020-11-05T04:17:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzkzODU4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r517938589", "bodyText": "kind is an enum here. So you can directly use the kinds in the cases instead of the string", "author": "nadeeshaan", "createdAt": "2020-11-05T10:17:54Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java", "diffHunk": "@@ -183,4 +201,121 @@ public static CodeActionNodeType topLevelNodeInLine(LSContext context, TextDocum\n \n         return lsDiagnostics;\n     }\n+\n+    /**\n+     * Returns an object that is included with codeStart, bodyStart and bodyEnd positions of a given node.\n+     *\n+     * @param node Node for which the positions are calculated\n+     * @return {@link NodePositions} of the given node\n+     */\n+    private static NodePositions getNodeSelectionPositions(Node node) {\n+        if (!(node instanceof NonTerminalNode)) {\n+            return new NodePositions(null, null, null);\n+        }\n+        NonTerminalNode member = (NonTerminalNode) node;\n+        int codeStartLine = member.lineRange().startLine().line() + getNumberOfDocLines(member);\n+        Position startCodePosition = new Position(codeStartLine, member.lineRange().startLine().offset());\n+\n+        switch (member.kind().name()) {\n+            case \"FUNCTION_DEFINITION\":", "originalCommit": "f1e69b4a63dd40d4e388a58c82f48599153ef3f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyNzcyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r518527720", "bodyText": "Updated.", "author": "prabushi", "createdAt": "2020-11-06T05:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzkzODU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk0MDA1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r517940051", "bodyText": "You can directly cast in to the specific node type and access the APIs such as openBrace()", "author": "nadeeshaan", "createdAt": "2020-11-05T10:20:04Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java", "diffHunk": "@@ -183,4 +201,121 @@ public static CodeActionNodeType topLevelNodeInLine(LSContext context, TextDocum\n \n         return lsDiagnostics;\n     }\n+\n+    /**\n+     * Returns an object that is included with codeStart, bodyStart and bodyEnd positions of a given node.\n+     *\n+     * @param node Node for which the positions are calculated\n+     * @return {@link NodePositions} of the given node\n+     */\n+    private static NodePositions getNodeSelectionPositions(Node node) {\n+        if (!(node instanceof NonTerminalNode)) {\n+            return new NodePositions(null, null, null);\n+        }\n+        NonTerminalNode member = (NonTerminalNode) node;\n+        int codeStartLine = member.lineRange().startLine().line() + getNumberOfDocLines(member);\n+        Position startCodePosition = new Position(codeStartLine, member.lineRange().startLine().offset());\n+\n+        switch (member.kind().name()) {\n+            case \"FUNCTION_DEFINITION\":\n+            case \"OBJECT_METHOD_DEFINITION\":\n+                for (Node child : member.children()) {", "originalCommit": "f1e69b4a63dd40d4e388a58c82f48599153ef3f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUyODY0NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r518528644", "bodyText": "Updated.", "author": "prabushi", "createdAt": "2020-11-06T05:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk0MDA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk0MDc0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r517940749", "bodyText": "Is it possible to use an offset based calculation here?", "author": "nadeeshaan", "createdAt": "2020-11-05T10:21:14Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java", "diffHunk": "@@ -183,4 +201,121 @@ public static CodeActionNodeType topLevelNodeInLine(LSContext context, TextDocum\n \n         return lsDiagnostics;\n     }\n+\n+    /**\n+     * Returns an object that is included with codeStart, bodyStart and bodyEnd positions of a given node.\n+     *\n+     * @param node Node for which the positions are calculated\n+     * @return {@link NodePositions} of the given node\n+     */\n+    private static NodePositions getNodeSelectionPositions(Node node) {\n+        if (!(node instanceof NonTerminalNode)) {\n+            return new NodePositions(null, null, null);\n+        }\n+        NonTerminalNode member = (NonTerminalNode) node;\n+        int codeStartLine = member.lineRange().startLine().line() + getNumberOfDocLines(member);\n+        Position startCodePosition = new Position(codeStartLine, member.lineRange().startLine().offset());\n+\n+        switch (member.kind().name()) {\n+            case \"FUNCTION_DEFINITION\":\n+            case \"OBJECT_METHOD_DEFINITION\":\n+                for (Node child : member.children()) {\n+                    if (child instanceof FunctionBodyBlockNode) {\n+                        return createNodePositions(child.lineRange(), startCodePosition);\n+                    }\n+                }\n+                break;\n+            case \"SERVICE_DECLARATION\":\n+                for (Node child : member.children()) {\n+                    if (child instanceof ServiceBodyNode) {\n+                        return createNodePositions(child.lineRange(), startCodePosition);\n+                    }\n+                }\n+                break;\n+            case \"METHOD_DECLARATION\":\n+                LineRange methodLineRange = member.lineRange();\n+                Position methodEndCodeBodyPosition = new Position(methodLineRange.endLine().line(),\n+                        methodLineRange.endLine().offset());\n+                return new NodePositions(startCodePosition, methodEndCodeBodyPosition, methodEndCodeBodyPosition);\n+            case \"CLASS_DEFINITION\":\n+            case \"TYPE_DEFINITION\":\n+                Position startCodeBodyPosition = null;\n+                for (Node child : member.children()) {\n+                    if (child instanceof IdentifierToken) {\n+                        LineRange identifierLineRange = child.lineRange();\n+                        startCodeBodyPosition = new Position(identifierLineRange.endLine().line(),\n+                                identifierLineRange.endLine().offset());\n+                        break;\n+                    }\n+                }\n+                LineRange typeLineRange = member.lineRange();\n+                Position typeEndCodeBodyPosition = new Position(typeLineRange.endLine().line(),\n+                        typeLineRange.endLine().offset());\n+                return new NodePositions(startCodePosition, startCodeBodyPosition, typeEndCodeBodyPosition);\n+        }\n+        return new NodePositions(startCodePosition, null, null);\n+    }\n+\n+    /**\n+     * Returns the number of API documentation lines.\n+     *\n+     * @param member Node for which the doc lines are calculated\n+     * @return Number of documentation lines\n+     */\n+    private static int getNumberOfDocLines(NonTerminalNode member) {\n+        if (member.children().size() > 0 && member.children().get(0) instanceof MetadataNode) {\n+            LineRange docLineRange = member.children().get(0).lineRange();\n+            return docLineRange.endLine().line() - docLineRange.startLine().line() + 1;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Checks if a give position is within a given range.\n+     *\n+     * @param start Start position of the range\n+     * @param end End position of the range\n+     * @param position Cursor position\n+     * @param isEndInclusive If the range is included with end position or not\n+     * @return If the position is within the range or not\n+     */\n+    private static boolean isWithinRange(Position start, Position end, Position position, boolean isEndInclusive) {", "originalCommit": "f1e69b4a63dd40d4e388a58c82f48599153ef3f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0NTc5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r518545795", "bodyText": "Implementation is done based on the actual positions relative to the editor. If we are to do offset based calculation, we have to track the cumulative offset values up to these positions instead of the positions themselves. Are there any advantages of using offset over positions? IMO, using positions is more comprehensible to map with the editor and easy to debug whereas with offsets we will have to traverse through children to calculate the cumulative value up to a particular node. Wdyt?", "author": "prabushi", "createdAt": "2020-11-06T06:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk0MDc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0NjYzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r518546631", "bodyText": "In ballerina syntax tree, positions are already captured as cumulative values. So there will be no issue with that.", "author": "nadeeshaan", "createdAt": "2020-11-06T06:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk0MDc0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE2MTE5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r519161191", "bodyText": "Updated the logic with offset calculations.", "author": "prabushi", "createdAt": "2020-11-07T10:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk0MDc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk0MTE1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r517941153", "bodyText": "Do we need this? Isn't it possible to do the calculations on the fly?", "author": "nadeeshaan", "createdAt": "2020-11-05T10:21:51Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java", "diffHunk": "@@ -183,4 +201,121 @@ public static CodeActionNodeType topLevelNodeInLine(LSContext context, TextDocum\n \n         return lsDiagnostics;\n     }\n+\n+    /**\n+     * Returns an object that is included with codeStart, bodyStart and bodyEnd positions of a given node.\n+     *\n+     * @param node Node for which the positions are calculated\n+     * @return {@link NodePositions} of the given node\n+     */\n+    private static NodePositions getNodeSelectionPositions(Node node) {\n+        if (!(node instanceof NonTerminalNode)) {\n+            return new NodePositions(null, null, null);\n+        }\n+        NonTerminalNode member = (NonTerminalNode) node;\n+        int codeStartLine = member.lineRange().startLine().line() + getNumberOfDocLines(member);\n+        Position startCodePosition = new Position(codeStartLine, member.lineRange().startLine().offset());\n+\n+        switch (member.kind().name()) {\n+            case \"FUNCTION_DEFINITION\":\n+            case \"OBJECT_METHOD_DEFINITION\":\n+                for (Node child : member.children()) {\n+                    if (child instanceof FunctionBodyBlockNode) {\n+                        return createNodePositions(child.lineRange(), startCodePosition);\n+                    }\n+                }\n+                break;\n+            case \"SERVICE_DECLARATION\":\n+                for (Node child : member.children()) {\n+                    if (child instanceof ServiceBodyNode) {\n+                        return createNodePositions(child.lineRange(), startCodePosition);\n+                    }\n+                }\n+                break;\n+            case \"METHOD_DECLARATION\":\n+                LineRange methodLineRange = member.lineRange();\n+                Position methodEndCodeBodyPosition = new Position(methodLineRange.endLine().line(),\n+                        methodLineRange.endLine().offset());\n+                return new NodePositions(startCodePosition, methodEndCodeBodyPosition, methodEndCodeBodyPosition);\n+            case \"CLASS_DEFINITION\":\n+            case \"TYPE_DEFINITION\":\n+                Position startCodeBodyPosition = null;\n+                for (Node child : member.children()) {\n+                    if (child instanceof IdentifierToken) {\n+                        LineRange identifierLineRange = child.lineRange();\n+                        startCodeBodyPosition = new Position(identifierLineRange.endLine().line(),\n+                                identifierLineRange.endLine().offset());\n+                        break;\n+                    }\n+                }\n+                LineRange typeLineRange = member.lineRange();\n+                Position typeEndCodeBodyPosition = new Position(typeLineRange.endLine().line(),\n+                        typeLineRange.endLine().offset());\n+                return new NodePositions(startCodePosition, startCodeBodyPosition, typeEndCodeBodyPosition);\n+        }\n+        return new NodePositions(startCodePosition, null, null);\n+    }\n+\n+    /**\n+     * Returns the number of API documentation lines.\n+     *\n+     * @param member Node for which the doc lines are calculated\n+     * @return Number of documentation lines\n+     */\n+    private static int getNumberOfDocLines(NonTerminalNode member) {\n+        if (member.children().size() > 0 && member.children().get(0) instanceof MetadataNode) {\n+            LineRange docLineRange = member.children().get(0).lineRange();\n+            return docLineRange.endLine().line() - docLineRange.startLine().line() + 1;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * Checks if a give position is within a given range.\n+     *\n+     * @param start Start position of the range\n+     * @param end End position of the range\n+     * @param position Cursor position\n+     * @param isEndInclusive If the range is included with end position or not\n+     * @return If the position is within the range or not\n+     */\n+    private static boolean isWithinRange(Position start, Position end, Position position, boolean isEndInclusive) {\n+        if (start == null || end == null || position == null) {\n+            return false;\n+        }\n+\n+        if (position.getLine() > start.getLine() && position.getLine() < end.getLine()) {\n+            return true;\n+        } else if (position.getLine() == start.getLine()) {\n+            return position.getCharacter() >= start.getCharacter() && (position.getLine() < end.getLine()\n+                    || (position.getLine() == end.getLine() && (position.getCharacter() < end.getCharacter()\n+                    || isEndInclusive && position.getCharacter() == end.getCharacter())));\n+        } else if (position.getLine() == end.getLine()) {\n+            return (position.getCharacter() < end.getCharacter() || (isEndInclusive\n+                    && position.getCharacter() == end.getCharacter())) && (position.getLine() > start.getLine()\n+                    || (position.getLine() == start.getLine() && position.getCharacter() >= start.getCharacter()));\n+        }\n+        return false;\n+    }\n+\n+    private static NodePositions createNodePositions(LineRange lineRange, Position startCodePosition) {\n+        Position startCodeBodyPosition = new Position(lineRange.startLine().line(), lineRange.startLine().offset());\n+        Position endCodeBodyPosition = new Position(lineRange.endLine().line(), lineRange.endLine().offset());\n+        return new NodePositions(startCodePosition, startCodeBodyPosition, endCodeBodyPosition);\n+    }\n+\n+    /**\n+     * Inner class to hold on to the positions of a node.\n+     */\n+    private static class NodePositions {", "originalCommit": "f1e69b4a63dd40d4e388a58c82f48599153ef3f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzNjA2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r518536064", "bodyText": "At least two of these positions are required for each node position related decision. And if we are to calculate these values separately we have to repeat some operations, such as calculating the number of doc lines, iterating children to get the body start node, etc., where we could calculate all within a single execution if we save them in an object.", "author": "prabushi", "createdAt": "2020-11-06T05:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk0MTE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTE2MTIyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r519161228", "bodyText": "This was removed with offset based calculations.", "author": "prabushi", "createdAt": "2020-11-07T10:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk0MTE1Mw=="}], "type": "inlineReview"}, {"oid": "72d85999510c8b19dd6be73070c5a7d25ed2ae02", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/72d85999510c8b19dd6be73070c5a7d25ed2ae02", "message": "Refactor code position selection for a code action\n\nRefactor the logic for selecting the position to display/not display the code actions.", "committedDate": "2020-11-06T05:11:27Z", "type": "forcePushed"}, {"oid": "d3ffccd7014df91f1782533e237a5f5ea0cc7153", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d3ffccd7014df91f1782533e237a5f5ea0cc7153", "message": "Refactor code position selection for a code action\n\nRefactor the logic for selecting the position to display/not display the code actions.", "committedDate": "2020-11-06T05:16:36Z", "type": "forcePushed"}, {"oid": "869bf6193db9e13cd2e97b3201d3df09cc99f59b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/869bf6193db9e13cd2e97b3201d3df09cc99f59b", "message": "Refactor code position selection for code actions\n\nRefactor the logic for selecting the position to display/not display the code actions.", "committedDate": "2020-11-07T09:05:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MDA3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r519540070", "bodyText": "let's not check for nulls here. Use Optional.isEmpty() and Optionnal.isPresent() APIs", "author": "nadeeshaan", "createdAt": "2020-11-09T03:55:26Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java", "diffHunk": "@@ -183,4 +197,124 @@ public static CodeActionNodeType topLevelNodeInLine(LSContext context, TextDocum\n \n         return lsDiagnostics;\n     }\n+\n+    /**\n+     * Returns if given position's offset is within the code body of give node.\n+     *\n+     * @param node Node in which the code body is considered\n+     * @param positionOffset Offset of the position\n+     * @return {@link Boolean} If within the body or not\n+     */\n+    private static boolean isWithinBody(Node node, int positionOffset) {\n+        if (!(node instanceof NonTerminalNode)) {\n+            return false;\n+        }\n+\n+        switch (node.kind()) {\n+            case FUNCTION_DEFINITION:\n+            case OBJECT_METHOD_DEFINITION:\n+                TextRange functionBodyTextRange = ((FunctionDefinitionNode) node).functionBody().textRange();\n+                return isWithinRange(positionOffset, functionBodyTextRange.startOffset(),\n+                        functionBodyTextRange.endOffset());\n+            case SERVICE_DECLARATION:\n+                TextRange serviceBodyTextRange = ((ServiceDeclarationNode) node).serviceBody().textRange();\n+                return isWithinRange(positionOffset, serviceBodyTextRange.startOffset(),\n+                        serviceBodyTextRange.endOffset());\n+            case CLASS_DEFINITION:\n+                ClassDefinitionNode classDefinitionNode = (ClassDefinitionNode) node;\n+                return isWithinRange(positionOffset, classDefinitionNode.openBrace().textRange().startOffset(),\n+                        classDefinitionNode.closeBrace().textRange().endOffset());\n+            case TYPE_DEFINITION:\n+                TypeDefinitionNode typeDefinitionNode = (TypeDefinitionNode) node;\n+                return isWithinRange(positionOffset,\n+                        typeDefinitionNode.typeDescriptor().textRange().startOffset(),\n+                        typeDefinitionNode.semicolonToken().textRange().startOffset());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns if given position's offset is within the starting code segment of give node.\n+     *\n+     * @param node Node in which the code start segment is considered\n+     * @param positionOffset Offset of the position\n+     * @return {@link Boolean} If within the start segment or not\n+     */\n+    private static boolean isWithinStartCodeSegment(Node node, int positionOffset) {\n+        if (!(node instanceof NonTerminalNode)) {\n+            return false;\n+        }\n+\n+        switch (node.kind()) {\n+            case FUNCTION_DEFINITION:\n+            case OBJECT_METHOD_DEFINITION:\n+                FunctionDefinitionNode functionDefinitionNode = (FunctionDefinitionNode) node;\n+                MetadataNode functionMetadataNode = functionDefinitionNode.metadata().orElse(null);", "originalCommit": "869bf6193db9e13cd2e97b3201d3df09cc99f59b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4MDE1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r519580153", "bodyText": "Updated.", "author": "prabushi", "createdAt": "2020-11-09T06:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MDY0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r519540640", "bodyText": "Missing the default case, Where we can just return false", "author": "nadeeshaan", "createdAt": "2020-11-09T03:58:31Z", "path": "language-server/modules/langserver-core/src/main/java/org/ballerinalang/langserver/codeaction/CodeActionUtil.java", "diffHunk": "@@ -183,4 +197,124 @@ public static CodeActionNodeType topLevelNodeInLine(LSContext context, TextDocum\n \n         return lsDiagnostics;\n     }\n+\n+    /**\n+     * Returns if given position's offset is within the code body of give node.\n+     *\n+     * @param node Node in which the code body is considered\n+     * @param positionOffset Offset of the position\n+     * @return {@link Boolean} If within the body or not\n+     */\n+    private static boolean isWithinBody(Node node, int positionOffset) {\n+        if (!(node instanceof NonTerminalNode)) {\n+            return false;\n+        }\n+\n+        switch (node.kind()) {\n+            case FUNCTION_DEFINITION:\n+            case OBJECT_METHOD_DEFINITION:\n+                TextRange functionBodyTextRange = ((FunctionDefinitionNode) node).functionBody().textRange();\n+                return isWithinRange(positionOffset, functionBodyTextRange.startOffset(),\n+                        functionBodyTextRange.endOffset());\n+            case SERVICE_DECLARATION:\n+                TextRange serviceBodyTextRange = ((ServiceDeclarationNode) node).serviceBody().textRange();\n+                return isWithinRange(positionOffset, serviceBodyTextRange.startOffset(),\n+                        serviceBodyTextRange.endOffset());\n+            case CLASS_DEFINITION:\n+                ClassDefinitionNode classDefinitionNode = (ClassDefinitionNode) node;\n+                return isWithinRange(positionOffset, classDefinitionNode.openBrace().textRange().startOffset(),\n+                        classDefinitionNode.closeBrace().textRange().endOffset());\n+            case TYPE_DEFINITION:\n+                TypeDefinitionNode typeDefinitionNode = (TypeDefinitionNode) node;\n+                return isWithinRange(positionOffset,\n+                        typeDefinitionNode.typeDescriptor().textRange().startOffset(),\n+                        typeDefinitionNode.semicolonToken().textRange().startOffset());\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Returns if given position's offset is within the starting code segment of give node.\n+     *\n+     * @param node Node in which the code start segment is considered\n+     * @param positionOffset Offset of the position\n+     * @return {@link Boolean} If within the start segment or not\n+     */\n+    private static boolean isWithinStartCodeSegment(Node node, int positionOffset) {\n+        if (!(node instanceof NonTerminalNode)) {\n+            return false;\n+        }\n+\n+        switch (node.kind()) {\n+            case FUNCTION_DEFINITION:\n+            case OBJECT_METHOD_DEFINITION:\n+                FunctionDefinitionNode functionDefinitionNode = (FunctionDefinitionNode) node;\n+                MetadataNode functionMetadataNode = functionDefinitionNode.metadata().orElse(null);\n+                int functionStartOffset;\n+                if (functionMetadataNode != null) {\n+                    functionStartOffset = functionMetadataNode.textRange().endOffset();\n+                } else {\n+                    functionStartOffset = functionDefinitionNode.textRange().startOffset() - 1;\n+                }\n+                return isWithinRange(positionOffset, functionStartOffset,\n+                        functionDefinitionNode.functionBody().textRange().startOffset());\n+            case SERVICE_DECLARATION:\n+                ServiceDeclarationNode serviceDeclarationNode = (ServiceDeclarationNode) node;\n+                MetadataNode serviceMetadataNode = serviceDeclarationNode.metadata().orElse(null);\n+                int serviceStartOffset;\n+                if (serviceMetadataNode != null) {\n+                    serviceStartOffset = serviceMetadataNode.textRange().endOffset();\n+                } else {\n+                    serviceStartOffset = serviceDeclarationNode.textRange().startOffset() - 1;\n+                }\n+                return isWithinRange(positionOffset, serviceStartOffset,\n+                        serviceDeclarationNode.serviceBody().textRange().startOffset());\n+            case METHOD_DECLARATION:\n+                MethodDeclarationNode methodDeclarationNode = (MethodDeclarationNode) node;\n+                MetadataNode methodMetadataNode = methodDeclarationNode.metadata().orElse(null);\n+                int methodStartOffset;\n+                if (methodMetadataNode != null) {\n+                    methodStartOffset = methodMetadataNode.textRange().endOffset();\n+                } else {\n+                    methodStartOffset = methodDeclarationNode.textRange().startOffset() - 1;\n+                }\n+                return isWithinRange(positionOffset, methodStartOffset,\n+                        methodDeclarationNode.semicolon().textRange().endOffset());\n+            case CLASS_DEFINITION:\n+                ClassDefinitionNode classDefinitionNode = (ClassDefinitionNode) node;\n+                MetadataNode classMetadataNode = classDefinitionNode.metadata().orElse(null);\n+                int classStartOffset;\n+                if (classMetadataNode != null) {\n+                    classStartOffset = classMetadataNode.textRange().endOffset();\n+                } else {\n+                    classStartOffset = classDefinitionNode.textRange().startOffset() - 1;\n+                }\n+                return isWithinRange(positionOffset, classStartOffset,\n+                        classDefinitionNode.openBrace().textRange().endOffset());\n+            case TYPE_DEFINITION:\n+                TypeDefinitionNode typeDefinitionNode = (TypeDefinitionNode) node;\n+                MetadataNode typeMetadataNode = typeDefinitionNode.metadata().orElse(null);\n+                int typeStartOffset;\n+                if (typeMetadataNode != null) {\n+                    typeStartOffset = typeMetadataNode.textRange().endOffset();\n+                } else {\n+                    typeStartOffset = typeDefinitionNode.textRange().startOffset() - 1;\n+                }\n+                return isWithinRange(positionOffset, typeStartOffset,\n+                        typeDefinitionNode.typeDescriptor().textRange().startOffset());\n+        }", "originalCommit": "869bf6193db9e13cd2e97b3201d3df09cc99f59b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU4MDE4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26737#discussion_r519580181", "bodyText": "Updated.", "author": "prabushi", "createdAt": "2020-11-09T06:42:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU0MDY0MA=="}], "type": "inlineReview"}, {"oid": "c7134377a2faa88240fc2f46138d0dd7edf66b63", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c7134377a2faa88240fc2f46138d0dd7edf66b63", "message": "Refactor code position selection for code actions\n\nRefactor the logic for selecting the position to display/not display the code actions.", "committedDate": "2020-11-09T06:09:55Z", "type": "forcePushed"}, {"oid": "3d06d307ea3870f48fdfd67c73e6c0ade1c0749f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3d06d307ea3870f48fdfd67c73e6c0ade1c0749f", "message": "Refactor code position selection for code actions\n\nRefactor the logic for selecting the position to display/not display the code actions.", "committedDate": "2020-11-09T06:34:30Z", "type": "forcePushed"}, {"oid": "045192af68d3aa4a85192f0c4d3dce78e37a59f5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/045192af68d3aa4a85192f0c4d3dce78e37a59f5", "message": "Refactor code position selection for code actions\n\nRefactor the logic for selecting the position to display/not display the code actions.", "committedDate": "2020-11-09T06:39:57Z", "type": "commit"}, {"oid": "045192af68d3aa4a85192f0c4d3dce78e37a59f5", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/045192af68d3aa4a85192f0c4d3dce78e37a59f5", "message": "Refactor code position selection for code actions\n\nRefactor the logic for selecting the position to display/not display the code actions.", "committedDate": "2020-11-09T06:39:57Z", "type": "forcePushed"}]}