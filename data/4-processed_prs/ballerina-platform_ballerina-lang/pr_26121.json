{"pr_number": 26121, "pr_title": "[Formatter] Add several new node implementations", "pr_createdAt": "2020-09-28T04:10:26Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121", "timeline": [{"oid": "562fad8df48203fa7d9ba30f7caa03e74d1189ac", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/562fad8df48203fa7d9ba30f7caa03e74d1189ac", "message": "Add several node implementations\n\nImportDeclarationNode, ServiceDeclarationNode, ExplicitNewExpressionNode, ParenthesizedArgList, ServiceBodyNode, QualifiedNameReferenceNode, ReturnTypeDescriptorNode, OptionalTypeDescriptorNode, ExpressionStatementNode, CheckExpressionNode, RemoteMethodCallActionNode, SimpleNameReferenceNode, TypeDefinitionNode, SingletonTypeDescriptorNode", "committedDate": "2020-09-25T21:11:36Z", "type": "commit"}, {"oid": "cbe2ae652ec6017566c3bce493b48a2de90279c7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/cbe2ae652ec6017566c3bce493b48a2de90279c7", "message": "Add some more nodes\n\nWhileStatementNode, BracedExpressionNode, AssignmentStatementNode, CompoundAssignmentStatementNode, DoStatementNode, ForEachStatementNode, BinaryExpressionNode, OnFailClauseNode, ReturnStatementNode, FunctionCallExpressionNode", "committedDate": "2020-09-28T03:46:13Z", "type": "commit"}, {"oid": "718a81afe866ca9273c113676aa2d38b1a3e8f45", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/718a81afe866ca9273c113676aa2d38b1a3e8f45", "message": "Fix formatting issues", "committedDate": "2020-09-28T04:04:28Z", "type": "commit"}, {"oid": "a775b9cadbd9a21307035b40d50e91dc8e229ffe", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a775b9cadbd9a21307035b40d50e91dc8e229ffe", "message": "Fix checkstyle issues", "committedDate": "2020-09-28T04:41:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDYwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495690609", "bodyText": "no need of a WS after the last component of the module name?", "author": "SupunS", "createdAt": "2020-09-28T05:04:23Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);", "originalCommit": "a775b9cadbd9a21307035b40d50e91dc8e229ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0NzU1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495747553", "bodyText": "Fixed.\nIt is needed if a prefix or version is specified, else it should not be there.", "author": "IrushiL", "createdAt": "2020-09-28T07:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDg2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495690864", "bodyText": "here also should keep a trailing ws", "author": "SupunS", "createdAt": "2020-09-28T05:05:36Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);", "originalCommit": "a775b9cadbd9a21307035b40d50e91dc8e229ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0NzkwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495747900", "bodyText": "Fixed to have a trailing WS if there is a prefix defined.", "author": "IrushiL", "createdAt": "2020-09-28T07:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDkwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495690900", "bodyText": "same as above", "author": "SupunS", "createdAt": "2020-09-28T05:05:45Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);", "originalCommit": "a775b9cadbd9a21307035b40d50e91dc8e229ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0ODQ0Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495748446", "bodyText": "Here a trailing WS is not required AFAIU.", "author": "IrushiL", "createdAt": "2020-09-28T07:46:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MDkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTMxOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495691319", "bodyText": "last token inside every method should get the  trailing whitesapces and  newlines from this.trailingWS and this.trailingNL.\nLet's follow that pattern religiously in all methods :)", "author": "SupunS", "createdAt": "2020-09-28T05:07:40Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);", "originalCommit": "a775b9cadbd9a21307035b40d50e91dc8e229ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0ODY1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495748651", "bodyText": "Fixed", "author": "IrushiL", "createdAt": "2020-09-28T07:46:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTY5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495691697", "bodyText": "I think its good to add all the child nodes of the import decl node along with this..\nsuch as ImportVersionNode, ImportPrefixNode", "author": "SupunS", "createdAt": "2020-09-28T05:09:29Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {", "originalCommit": "a775b9cadbd9a21307035b40d50e91dc8e229ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc0ODg2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495748865", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-09-28T07:47:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MTY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MjEwOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495692109", "bodyText": "if theres an on-fail clause, then we shouldn't use this.trailingWS and this.trailingNL\nSame goes for all other places where on-fail clause applies", "author": "SupunS", "createdAt": "2020-09-28T05:11:07Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), 1, 0);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(), 1, 0);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), this.trailingWS, this.trailingNL);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), 0, 0);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, 0);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(), this.trailingWS, this.trailingNL);\n+\n+        if (whileStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), 1, 0);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);", "originalCommit": "a775b9cadbd9a21307035b40d50e91dc8e229ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MDQ4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495780483", "bodyText": "Fixed", "author": "IrushiL", "createdAt": "2020-09-28T08:44:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MjEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MzQ1OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495693459", "bodyText": "I feel we should keep a WS after the last expression.", "author": "SupunS", "createdAt": "2020-09-28T05:17:08Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);", "originalCommit": "a775b9cadbd9a21307035b40d50e91dc8e229ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MDU0OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495780549", "bodyText": "Fixed", "author": "IrushiL", "createdAt": "2020-09-28T08:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5MzQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5NDE5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495694191", "bodyText": "Might need a WS after the binding pattern. otherwise will cause a syntax error", "author": "SupunS", "createdAt": "2020-09-28T05:20:10Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,392 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 0, 0);\n+\n+        if (importDeclarationNode.orgName().isPresent()) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, 0, 0);\n+\n+        if (importDeclarationNode.version().isPresent()) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (importDeclarationNode.prefix().isPresent()) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), 0, 1);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 0, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), 1, 0);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(), 1, 0);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), this.trailingWS, this.trailingNL);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), 0, 0);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, 0);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(), this.trailingWS, this.trailingNL);\n+\n+        if (whileStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), 1, 0);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                this.trailingWS, this.trailingNL);\n+\n+        if (doStatementNode.onFailClause().isPresent()) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 0, 0);", "originalCommit": "a775b9cadbd9a21307035b40d50e91dc8e229ffe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MDY3Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495780676", "bodyText": "Fixed", "author": "IrushiL", "createdAt": "2020-09-28T08:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTY5NDE5MQ=="}], "type": "inlineReview"}, {"oid": "79c525c19eeed07ce810afdb3aa2eb4753eef6a4", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/79c525c19eeed07ce810afdb3aa2eb4753eef6a4", "message": "Fix the import declaration statements", "committedDate": "2020-09-28T07:42:01Z", "type": "commit"}, {"oid": "c30db141252806ea0e358151d09f38f8c860f358", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c30db141252806ea0e358151d09f38f8c860f358", "message": "Fix review comments", "committedDate": "2020-09-28T08:42:35Z", "type": "commit"}, {"oid": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "message": "Fix issues in the indentation logic", "committedDate": "2020-09-28T11:55:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzQzOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495887439", "bodyText": "moving this inside the below if (hasOnFailClause) { block would be cleaner..", "author": "SupunS", "createdAt": "2020-09-28T12:04:47Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        boolean hasOnFailClause = forEachStatementNode.onFailClause().isPresent();\n+\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 1, 0);\n+        Token inKeyword = formatToken(forEachStatementNode.inKeyword(), 1, 0);\n+        Node actionOrExpressionNode = formatNode(forEachStatementNode.actionOrExpressionNode(), 1, 0);\n+        StatementNode blockStatement = formatNode(forEachStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);", "originalCommit": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMDI5NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495900295", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-09-28T12:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzgzMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495887830", "bodyText": "should use global var for WS and NL", "author": "SupunS", "createdAt": "2020-09-28T12:05:31Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);", "originalCommit": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMDg4Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495900883", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-09-28T12:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzkzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495887934", "bodyText": "should use global var for WS and NL", "author": "SupunS", "createdAt": "2020-09-28T12:05:44Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);", "originalCommit": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMTA2NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495901065", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-09-28T12:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4NzkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODI5Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495888292", "bodyText": "should use global var for WS and NL", "author": "SupunS", "createdAt": "2020-09-28T12:06:21Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);", "originalCommit": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMTIyOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495901229", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-09-28T12:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODM3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495888375", "bodyText": "should use global var for trailingNL", "author": "SupunS", "createdAt": "2020-09-28T12:06:32Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);", "originalCommit": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMTQzOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495901439", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-09-28T12:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODYxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495888614", "bodyText": "should use global var for WS and NL", "author": "SupunS", "createdAt": "2020-09-28T12:07:00Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(doStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            doStatementNode = doStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return doStatementNode.modify()\n+                .withDoKeyword(doKeyword)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ForEachStatementNode transform(ForEachStatementNode forEachStatementNode) {\n+        boolean hasOnFailClause = forEachStatementNode.onFailClause().isPresent();\n+\n+        Token forEachKeyword = formatToken(forEachStatementNode.forEachKeyword(), 1, 0);\n+        TypedBindingPatternNode typedBindingPattern = formatNode(forEachStatementNode.typedBindingPattern(), 1, 0);\n+        Token inKeyword = formatToken(forEachStatementNode.inKeyword(), 1, 0);\n+        Node actionOrExpressionNode = formatNode(forEachStatementNode.actionOrExpressionNode(), 1, 0);\n+        StatementNode blockStatement = formatNode(forEachStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(forEachStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            forEachStatementNode = forEachStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return forEachStatementNode.modify()\n+                .withForEachKeyword(forEachKeyword)\n+                .withTypedBindingPattern(typedBindingPattern)\n+                .withInKeyword(inKeyword)\n+                .withActionOrExpressionNode(actionOrExpressionNode)\n+                .withBlockStatement(blockStatement)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BinaryExpressionNode transform(BinaryExpressionNode binaryExpressionNode) {\n+        Node lhsExpr = formatNode(binaryExpressionNode.lhsExpr(), 1, 0);\n+        Token operator = formatToken(binaryExpressionNode.operator(), 1, 0);\n+        Node rhsExpr = formatNode(binaryExpressionNode.rhsExpr(), this.trailingWS, this.trailingNL);\n+\n+        return binaryExpressionNode.modify()\n+                .withLhsExpr(lhsExpr)\n+                .withOperator(operator)\n+                .withRhsExpr(rhsExpr)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OnFailClauseNode transform(OnFailClauseNode onFailClauseNode) {\n+        Token onKeyword = formatToken(onFailClauseNode.onKeyword(), 1, 0);\n+        Token failKeyword = formatToken(onFailClauseNode.failKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptor = formatNode(onFailClauseNode.typeDescriptor(), 1, 0);\n+        IdentifierToken failErrorName = formatToken(onFailClauseNode.failErrorName(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(onFailClauseNode.blockStatement(), 0, 1);", "originalCommit": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMzA4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495903087", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-09-28T12:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4ODYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4OTAwNQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495889005", "bodyText": "moving this inside the below if (hasOnFailClause) { block would be cleaner..", "author": "SupunS", "createdAt": "2020-09-28T12:07:51Z", "path": "misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/NewFormattingTreeModifier.java", "diffHunk": "@@ -399,6 +429,436 @@ public RecordFieldWithDefaultValueNode transform(RecordFieldWithDefaultValueNode\n                 .apply();\n     }\n \n+    @Override\n+    public ImportDeclarationNode transform(ImportDeclarationNode importDeclarationNode) {\n+        Token importKeyword = formatToken(importDeclarationNode.importKeyword(), 1, 0);\n+\n+        boolean hasOrgName = importDeclarationNode.orgName().isPresent();\n+        boolean hasVersion = importDeclarationNode.version().isPresent();\n+        boolean hasPrefix = importDeclarationNode.prefix().isPresent();\n+\n+        if (hasOrgName) {\n+            ImportOrgNameNode orgName = formatNode(importDeclarationNode.orgName().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withOrgName(orgName).apply();\n+        }\n+        SeparatedNodeList<IdentifierToken> moduleNames = formatSeparatedNodeList(importDeclarationNode.moduleName(),\n+                0, 0, 0, 0, (hasVersion || hasPrefix) ? 1 : 0, 0);\n+\n+        if (hasVersion) {\n+            ImportVersionNode version = formatNode(importDeclarationNode.version().get(), hasPrefix ? 1 : 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withVersion(version).apply();\n+        }\n+        if (hasPrefix) {\n+            ImportPrefixNode prefix = formatNode(importDeclarationNode.prefix().get(), 0, 0);\n+            importDeclarationNode = importDeclarationNode.modify().withPrefix(prefix).apply();\n+        }\n+        Token semicolon = formatToken(importDeclarationNode.semicolon(), this.trailingWS, this.trailingNL);\n+\n+        return importDeclarationNode.modify()\n+                .withImportKeyword(importKeyword)\n+                .withModuleName(moduleNames)\n+                .withSemicolon(semicolon)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportOrgNameNode transform(ImportOrgNameNode importOrgNameNode) {\n+        Token orgName = formatToken(importOrgNameNode.orgName(), 0, 0);\n+        Token slashToken = formatToken(importOrgNameNode.slashToken(), 0, 0);\n+\n+        return importOrgNameNode.modify()\n+                .withOrgName(orgName)\n+                .withSlashToken(slashToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportPrefixNode transform(ImportPrefixNode importPrefixNode) {\n+        Token asKeyword = formatToken(importPrefixNode.asKeyword(), 1, 0);\n+        Token prefix = formatToken(importPrefixNode.prefix(), 0, 0);\n+\n+        return importPrefixNode.modify()\n+                .withAsKeyword(asKeyword)\n+                .withPrefix(prefix)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ImportVersionNode transform(ImportVersionNode importVersionNode) {\n+        Token versionKeyword = formatToken(importVersionNode.versionKeyword(), 1, 0);\n+        SeparatedNodeList<Token> versionNumber = formatSeparatedNodeList(importVersionNode.versionNumber(),\n+                0, 0, 0, 0, this.trailingWS, 0);\n+\n+        return importVersionNode.modify()\n+                .withVersionKeyword(versionKeyword)\n+                .withVersionNumber(versionNumber)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceDeclarationNode transform(ServiceDeclarationNode serviceDeclarationNode) {\n+        if (serviceDeclarationNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(serviceDeclarationNode.metadata().get(), 1, 0);\n+            serviceDeclarationNode = serviceDeclarationNode.modify().withMetadata(metadata).apply();\n+        }\n+\n+        Token serviceKeyword = formatToken(serviceDeclarationNode.serviceKeyword(), 1, 0);\n+        IdentifierToken serviceName = formatToken(serviceDeclarationNode.serviceName(), 1, 0);\n+        Token onKeyword = formatToken(serviceDeclarationNode.onKeyword(), 1, 0);\n+        SeparatedNodeList<ExpressionNode> expressions =\n+                formatSeparatedNodeList(serviceDeclarationNode.expressions(), 0, 0, 1, 0);\n+        Node serviceBody = formatNode(serviceDeclarationNode.serviceBody(), this.trailingWS, this.trailingNL);\n+\n+        return serviceDeclarationNode.modify()\n+                .withServiceKeyword(serviceKeyword)\n+                .withServiceName(serviceName)\n+                .withOnKeyword(onKeyword)\n+                .withExpressions(expressions)\n+                .withServiceBody(serviceBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExplicitNewExpressionNode transform(ExplicitNewExpressionNode explicitNewExpressionNode) {\n+        Token newKeywordToken = formatToken(explicitNewExpressionNode.newKeyword(), 1, 0);\n+        TypeDescriptorNode typeDescriptorNode = formatNode(explicitNewExpressionNode.typeDescriptor(), 0, 0);\n+        ParenthesizedArgList parenthesizedArgList = formatNode(explicitNewExpressionNode.parenthesizedArgList(), 0, 0);\n+\n+        return explicitNewExpressionNode.modify()\n+                .withNewKeyword(newKeywordToken)\n+                .withTypeDescriptor(typeDescriptorNode)\n+                .withParenthesizedArgList(parenthesizedArgList)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ParenthesizedArgList transform(ParenthesizedArgList parenthesizedArgList) {\n+        Token openParenToken = formatToken(parenthesizedArgList.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(parenthesizedArgList\n+                .arguments(), 0, 0, 0, 0);\n+        Token closeParenToken = formatToken(parenthesizedArgList.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return parenthesizedArgList.modify()\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ServiceBodyNode transform(ServiceBodyNode serviceBodyNode) {\n+        Token openBraceToken = formatToken(serviceBodyNode.openBraceToken(), 0, 1);\n+        indent(); // increase indentation for the statements to follow.\n+        NodeList<Node> resources = formatNodeList(serviceBodyNode.resources(), 0, 1, 0, 1);\n+        unindent(); // reset the indentation\n+        Token closeBraceToken = formatToken(serviceBodyNode.closeBraceToken(), this.trailingWS, this.trailingNL);\n+\n+        return serviceBodyNode.modify()\n+                .withOpenBraceToken(openBraceToken)\n+                .withResources(resources)\n+                .withCloseBraceToken(closeBraceToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public QualifiedNameReferenceNode transform(QualifiedNameReferenceNode qualifiedNameReferenceNode) {\n+        Token modulePrefix = formatToken(qualifiedNameReferenceNode.modulePrefix(), 0, 0);\n+        Token colon = formatToken((Token) qualifiedNameReferenceNode.colon(), 0, 0);\n+        IdentifierToken identifier = formatToken(qualifiedNameReferenceNode.identifier(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return qualifiedNameReferenceNode.modify()\n+                .withModulePrefix(modulePrefix)\n+                .withColon(colon)\n+                .withIdentifier(identifier)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ReturnTypeDescriptorNode transform(ReturnTypeDescriptorNode returnTypeDescriptorNode) {\n+        Token returnsKeyword = formatToken(returnTypeDescriptorNode.returnsKeyword(), 1, 0);\n+        NodeList<AnnotationNode> annotations = formatNodeList(returnTypeDescriptorNode.annotations(), 0, 0, 1, 0);\n+        Node type = formatNode(returnTypeDescriptorNode.type(), 1, 0);\n+\n+        return returnTypeDescriptorNode.modify()\n+                .withReturnsKeyword(returnsKeyword)\n+                .withAnnotations(annotations)\n+                .withType(type)\n+                .apply();\n+    }\n+\n+    @Override\n+    public OptionalTypeDescriptorNode transform(OptionalTypeDescriptorNode optionalTypeDescriptorNode) {\n+        Node typeDescriptor = formatNode(optionalTypeDescriptorNode.typeDescriptor(), 0, 0);\n+        Token questionMarkToken = formatToken(optionalTypeDescriptorNode.questionMarkToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return optionalTypeDescriptorNode.modify()\n+                .withTypeDescriptor(typeDescriptor)\n+                .withQuestionMarkToken(questionMarkToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public ExpressionStatementNode transform(ExpressionStatementNode expressionStatementNode) {\n+        ExpressionNode expression = formatNode(expressionStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(expressionStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return expressionStatementNode.modify()\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CheckExpressionNode transform(CheckExpressionNode checkExpressionNode) {\n+        Token checkKeyword = formatToken(checkExpressionNode.checkKeyword(), 1, 0);\n+        ExpressionNode expressionNode = formatNode(checkExpressionNode.expression(), this.trailingWS, this.trailingNL);\n+\n+        return checkExpressionNode.modify()\n+                .withCheckKeyword(checkKeyword)\n+                .withExpression(expressionNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public RemoteMethodCallActionNode transform(RemoteMethodCallActionNode remoteMethodCallActionNode) {\n+        ExpressionNode expression = formatNode(remoteMethodCallActionNode.expression(), 0, 0);\n+        Token rightArrowToken = formatToken(remoteMethodCallActionNode.rightArrowToken(), 0, 0);\n+        SimpleNameReferenceNode methodName = formatNode(remoteMethodCallActionNode.methodName(), 0, 0);\n+        Token openParenToken = formatToken(remoteMethodCallActionNode.openParenToken(), 0, 0);\n+        SeparatedNodeList<FunctionArgumentNode> arguments = formatSeparatedNodeList(remoteMethodCallActionNode\n+                .arguments(), 1, 0, 0, 0);\n+        Token closeParenToken = formatToken(remoteMethodCallActionNode.closeParenToken(), this.trailingWS, this.trailingNL);\n+\n+        return remoteMethodCallActionNode.modify()\n+                .withExpression(expression)\n+                .withRightArrowToken(rightArrowToken)\n+                .withMethodName(methodName)\n+                .withOpenParenToken(openParenToken)\n+                .withArguments(arguments)\n+                .withCloseParenToken(closeParenToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SimpleNameReferenceNode transform(SimpleNameReferenceNode simpleNameReferenceNode) {\n+        Token name = formatToken(simpleNameReferenceNode.name(), this.trailingWS, this.trailingNL);\n+\n+        return simpleNameReferenceNode.modify()\n+                .withName(name)\n+                .apply();\n+    }\n+\n+    @Override\n+    public TypeDefinitionNode transform(TypeDefinitionNode typeDefinitionNode) {\n+        if (typeDefinitionNode.metadata().isPresent()) {\n+            MetadataNode metadata = formatNode(typeDefinitionNode.metadata().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withMetadata(metadata).apply();\n+        }\n+        if (typeDefinitionNode.visibilityQualifier().isPresent()) {\n+            Token visibilityQualifier = formatToken(typeDefinitionNode.visibilityQualifier().get(), 1, 0);\n+            typeDefinitionNode = typeDefinitionNode.modify().withVisibilityQualifier(visibilityQualifier).apply();\n+        }\n+\n+        Token typeKeyword = formatToken(typeDefinitionNode.typeKeyword(), 1, 0);\n+        Token typeName = formatToken(typeDefinitionNode.typeName(), 1, 0);\n+        Node typeDescriptor = formatNode(typeDefinitionNode.typeDescriptor(), 1, 0);\n+        Token semicolonToken = formatToken(typeDefinitionNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return typeDefinitionNode.modify()\n+                .withTypeKeyword(typeKeyword)\n+                .withTypeName(typeName)\n+                .withTypeDescriptor(typeDescriptor)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public SingletonTypeDescriptorNode transform(SingletonTypeDescriptorNode singletonTypeDescriptorNode) {\n+        ExpressionNode simpleContExprNode = formatNode(singletonTypeDescriptorNode.simpleContExprNode(), 1, 0);\n+        return singletonTypeDescriptorNode.modify()\n+                .withSimpleContExprNode(simpleContExprNode)\n+                .apply();\n+    }\n+\n+    @Override\n+    public WhileStatementNode transform(WhileStatementNode whileStatementNode) {\n+        boolean hasOnFailClause = whileStatementNode.onFailClause().isPresent();\n+        Token whileKeyword = formatToken(whileStatementNode.whileKeyword(), 1, 0);\n+        ExpressionNode condition = formatNode(whileStatementNode.condition(), 1, 0);\n+        BlockStatementNode whileBody = formatNode(whileStatementNode.whileBody(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);\n+\n+        if (hasOnFailClause) {\n+            OnFailClauseNode onFailClause = formatNode(whileStatementNode.onFailClause().get(),\n+                    this.trailingWS, this.trailingNL);\n+            whileStatementNode = whileStatementNode.modify().withOnFailClause(onFailClause).apply();\n+        }\n+\n+        return whileStatementNode.modify()\n+                .withWhileKeyword(whileKeyword)\n+                .withCondition(condition)\n+                .withWhileBody(whileBody)\n+                .apply();\n+    }\n+\n+    @Override\n+    public BracedExpressionNode transform(BracedExpressionNode bracedExpressionNode) {\n+        Token openParen = formatToken(bracedExpressionNode.openParen(), 0, 0);\n+        ExpressionNode expression = formatNode(bracedExpressionNode.expression(), 0, 0);\n+        Token closeParen = formatToken(bracedExpressionNode.closeParen(), this.trailingWS, this.trailingNL);\n+\n+        return bracedExpressionNode.modify()\n+                .withOpenParen(openParen)\n+                .withExpression(expression)\n+                .withCloseParen(closeParen)\n+                .apply();\n+    }\n+\n+    @Override\n+    public AssignmentStatementNode transform(AssignmentStatementNode assignmentStatementNode) {\n+        Node varRef = formatNode(assignmentStatementNode.varRef(), 1, 0);\n+        Token equalsToken = formatToken(assignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode expression = formatNode(assignmentStatementNode.expression(), 0, 0);\n+        Token semicolonToken = formatToken(assignmentStatementNode.semicolonToken(), this.trailingWS, this.trailingNL);\n+\n+        return assignmentStatementNode.modify()\n+                .withVarRef(varRef)\n+                .withEqualsToken(equalsToken)\n+                .withExpression(expression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public CompoundAssignmentStatementNode transform(CompoundAssignmentStatementNode compoundAssignmentStatementNode) {\n+        ExpressionNode lhsExpression = formatNode(compoundAssignmentStatementNode.lhsExpression(), 1, 0);\n+        Token binaryOperator = formatToken(compoundAssignmentStatementNode.binaryOperator(), 0, 0);\n+        Token equalsToken = formatToken(compoundAssignmentStatementNode.equalsToken(), 1, 0);\n+        ExpressionNode rhsExpression = formatNode(compoundAssignmentStatementNode.rhsExpression(), 0, 0);\n+        Token semicolonToken = formatToken(compoundAssignmentStatementNode.semicolonToken(),\n+                this.trailingWS, this.trailingNL);\n+\n+        return compoundAssignmentStatementNode.modify()\n+                .withLhsExpression(lhsExpression)\n+                .withBinaryOperator(binaryOperator)\n+                .withEqualsToken(equalsToken)\n+                .withRhsExpression(rhsExpression)\n+                .withSemicolonToken(semicolonToken)\n+                .apply();\n+    }\n+\n+    @Override\n+    public DoStatementNode transform(DoStatementNode doStatementNode) {\n+        boolean hasOnFailClause = doStatementNode.onFailClause().isPresent();\n+\n+        Token doKeyword = formatToken(doStatementNode.doKeyword(), 1, 0);\n+        BlockStatementNode blockStatement = formatNode(doStatementNode.blockStatement(),\n+                hasOnFailClause ? 1 : this.trailingWS, hasOnFailClause ? 0 : this.trailingNL);", "originalCommit": "5bd7b0d855a3e4ed165fc3da4b34b7de38a82199", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMjI0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26121#discussion_r495902247", "bodyText": "Done", "author": "IrushiL", "createdAt": "2020-09-28T12:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTg4OTAwNQ=="}], "type": "inlineReview"}, {"oid": "db8f6043c52588827582ab0229d0383934bfe3f0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/db8f6043c52588827582ab0229d0383934bfe3f0", "message": "Fix review comments and add nodes UnionTypeDescriptorNode and NilTypeDescriptorNode", "committedDate": "2020-09-28T12:27:44Z", "type": "commit"}, {"oid": "db8f6043c52588827582ab0229d0383934bfe3f0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/db8f6043c52588827582ab0229d0383934bfe3f0", "message": "Fix review comments and add nodes UnionTypeDescriptorNode and NilTypeDescriptorNode", "committedDate": "2020-09-28T12:27:44Z", "type": "forcePushed"}, {"oid": "e8ac3142d6cf30c49158ce31044ab757d17723c0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e8ac3142d6cf30c49158ce31044ab757d17723c0", "message": "Fix a review comment and a checkstyle issue", "committedDate": "2020-09-28T12:32:54Z", "type": "commit"}]}