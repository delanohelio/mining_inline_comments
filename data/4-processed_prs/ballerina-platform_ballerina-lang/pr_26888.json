{"pr_number": 26888, "pr_title": "Add parser support for isolated services and object constructor expressions", "pr_createdAt": "2020-11-12T09:52:40Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888", "timeline": [{"oid": "b17e06b7ac40506c49b65e8fc9224913e39b58bd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b17e06b7ac40506c49b65e8fc9224913e39b58bd", "message": "Add parser support for isolated object constructor", "committedDate": "2020-11-12T08:32:48Z", "type": "commit"}, {"oid": "7355b33d43b6557f61d18990367430f67ea6299b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7355b33d43b6557f61d18990367430f67ea6299b", "message": "Add parser support for isolated service declaration", "committedDate": "2020-11-12T09:12:43Z", "type": "commit"}, {"oid": "3a291970a3bb996382c260628b88d6bd5395d543", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3a291970a3bb996382c260628b88d6bd5395d543", "message": "Disable failing LS tests due to new way of qualifier parsing", "committedDate": "2020-11-13T06:49:27Z", "type": "commit"}, {"oid": "066dcb56dc0c66fe98d4d17635301d218edc3c96", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/066dcb56dc0c66fe98d4d17635301d218edc3c96", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into Isolated-qual", "committedDate": "2020-11-16T05:22:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU5MDA3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r526590079", "bodyText": "Can we move these two lines to a separate function since it is repeated in many places", "author": "rdulmina", "createdAt": "2020-11-19T04:41:31Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3874,131 +3886,141 @@ private STNode parseTerminalExpression(STNode annots, boolean isRhsExpr, boolean\n             case FALSE_KEYWORD:\n             case DECIMAL_FLOATING_POINT_LITERAL_TOKEN:\n             case HEX_FLOATING_POINT_LITERAL_TOKEN:\n+                reportInvalidExpressionAnnots(annots, qualifiers);\n+                reportInvalidQualifierList(qualifiers);", "originalCommit": "066dcb56dc0c66fe98d4d17635301d218edc3c96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU5NDYwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r526594601", "bodyText": "This is not about this PR but can we change the name of this method to something like updateANodeInListWithLeadingInvalidNode since we are adding an invalid node as leading minutia.", "author": "rdulmina", "createdAt": "2020-11-19T04:57:53Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -6196,22 +6165,56 @@ private STNode parseCompoundBinaryOperator() {\n      * Parse service declaration.\n      * <p>\n      * <code>\n-     * service-decl := metadata service [variable-name] on expression-list service-body-block\n+     * service-decl := metadata [isolated-qual] service [variable-name] on expression-list service-body-block\n      * <br/>\n      * expression-list := expression (, expression)*\n      * </code>\n      *\n-     * @param metadata Metadata\n+     * @param metadata   Metadata\n+     * @param qualifiers Preceding qualifiers\n      * @return Parsed node\n      */\n-    private STNode parseServiceDecl(STNode metadata) {\n+    private STNode parseServiceDecl(STNode metadata, List<STNode> qualifiers) {\n         startContext(ParserRuleContext.SERVICE_DECL);\n+        STNode qualNodeList = createServiceDeclQualNodeList(qualifiers);\n         STNode serviceKeyword = parseServiceKeyword();\n-        STNode serviceDecl = parseServiceRhs(metadata, serviceKeyword);\n+        STNode serviceDecl = parseServiceRhs(metadata, qualNodeList, serviceKeyword);\n         endContext();\n         return serviceDecl;\n     }\n \n+    private STNode createServiceDeclQualNodeList(List<STNode> qualifierList) {\n+        // Validate qualifiers and create a STNodeList\n+        List<STNode> validatedList = new ArrayList<>();\n+\n+        for (int i = 0; i < qualifierList.size(); i++) {\n+            STNode qualifier = qualifierList.get(i);\n+            int nextIndex = i + 1;\n+\n+            if (isDuplicate(validatedList, qualifier.kind)) {\n+                updateLastNodeInListWithInvalidNode(validatedList, qualifier,\n+                        DiagnosticErrorCode.ERROR_DUPLICATE_QUALIFIER, ((STToken) qualifier).text());\n+                continue;\n+            }\n+\n+            if (qualifier.kind == SyntaxKind.ISOLATED_KEYWORD) {\n+                validatedList.add(qualifier);\n+                continue;\n+            }\n+\n+            // We only reach here for invalid qualfiers\n+            if (qualifierList.size() == nextIndex) {\n+                addInvalidNodeToNextToken(qualifier, DiagnosticErrorCode.ERROR_QUALIFIER_NOT_ALLOWED,\n+                        ((STToken) qualifier).text());\n+            } else {\n+                updateANodeInListWithInvalidNode(qualifierList, nextIndex, qualifier,", "originalCommit": "066dcb56dc0c66fe98d4d17635301d218edc3c96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU5OTU0OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r526599548", "bodyText": "Do we need to address isolated client object {.. case in error handler?", "author": "rdulmina", "createdAt": "2020-11-19T05:15:46Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParserErrorHandler.java", "diffHunk": "@@ -924,7 +924,8 @@ protected Result seekMatch(ParserRuleContext currentCtx, int lookahead, int curr\n                     hasMatch = nextToken.kind == SyntaxKind.CLOSE_PAREN_TOKEN;\n                     break;\n                 case OBJECT_CONSTRUCTOR_QUALIFIER:\n-                    hasMatch = nextToken.kind == SyntaxKind.CLIENT_KEYWORD;\n+                    hasMatch = nextToken.kind == SyntaxKind.CLIENT_KEYWORD ||\n+                            nextToken.kind == SyntaxKind.ISOLATED_KEYWORD;", "originalCommit": "066dcb56dc0c66fe98d4d17635301d218edc3c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYwMDEyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r526600121", "bodyText": "Currently, it is not handled right?", "author": "rdulmina", "createdAt": "2020-11-19T05:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU5OTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM4MjMyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r527382327", "bodyText": "In error handler we don't have a proper way to solve this issue. But, in a very few cases we have handled it like below.\n    private static final ParserRuleContext[] OBJECT_CONSTRUCTOR_START =\n            { ParserRuleContext.OBJECT_KEYWORD, ParserRuleContext.ISOLATED_KEYWORD, \n              ParserRuleContext.CLIENT_KEYWORD };\n\n    private static final ParserRuleContext[] OBJECT_CONSTRUCTOR_WITHOUT_ISOLATED =\n            { ParserRuleContext.OBJECT_KEYWORD, ParserRuleContext.CLIENT_KEYWORD };\n\n    private static final ParserRuleContext[] OBJECT_CONSTRUCTOR_WITHOUT_CLIENT =\n            { ParserRuleContext.OBJECT_KEYWORD, ParserRuleContext.ISOLATED_KEYWORD };\nBut, my concern with above logic is; it adds cyclic alternative paths.\nFor example, something like isolated client isolated client isolated is an alternative path.\nSo, If we assume LOOKAHEAD_LIMIT = 5 and entry point is OBJECT_CONSTRUCTOR_START,\nIn 2 qualifier case: we check for 2 + 2x1 + 2x1x1 + 2x1x1x1 + 2x1x1x1x1 = 10 alternative qualifier paths.\nIn 4 qualifier case: we check for 4 + 4x3 + 4x3x3 + 4x3x3x3 + 4x3x3x3x3 = 484 alternative qualifier paths.\nwhich are all unnecessary. (IINM)\nWe could rather define rules like below. (aliasing OBJECT_CONSTRUCTOR_QUALIFIER)\ncase FIRST_OBJECT_CONSTRUCTOR_QUALIFIER:\ncase SECOND_OBJECT_CONSTRUCTOR_QUALIFIER:\n       hasMatch = nextToken.kind == SyntaxKind.CLIENT_KEYWORD || \n                  nextToken.kind == SyntaxKind.ISOLATED_KEYWORD;\n       break;\nIn 2 qualifier case: we check for 2 alternative qualifier paths.\nIn 4 qualifier case: we check for 4 alternative qualifier paths.\nor do we need to worry about this? @SupunS @rdulmina", "author": "lochana-chathura", "createdAt": "2020-11-20T04:12:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU5OTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ2NzIyNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r527467227", "bodyText": "I think second option is a viable and a simple solution.", "author": "SupunS", "createdAt": "2020-11-20T06:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU5OTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ2ODUwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r527468501", "bodyText": "+1", "author": "rdulmina", "createdAt": "2020-11-20T06:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjU5OTU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYwMDg0Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r526600847", "bodyText": "This snippet is duplicated in 20+ place.\nCan't we do this in a single  place like before?", "author": "SupunS", "createdAt": "2020-11-19T05:20:15Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3874,131 +3886,141 @@ private STNode parseTerminalExpression(STNode annots, boolean isRhsExpr, boolean\n             case FALSE_KEYWORD:\n             case DECIMAL_FLOATING_POINT_LITERAL_TOKEN:\n             case HEX_FLOATING_POINT_LITERAL_TOKEN:\n+                reportInvalidExpressionAnnots(annots, qualifiers);\n+                reportInvalidQualifierList(qualifiers);", "originalCommit": "066dcb56dc0c66fe98d4d17635301d218edc3c96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY2OTk2OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r526669968", "bodyText": "If we employ the previous approach we have following issues when re-parsing the parseTerminalExpression().\n\nValidation will take place again and invalid nodes are reported twice. We can avoid this using a flag though.\nWe can't go to recovery with the qualifiers. Bcz we have already validated them before reaching the recovery method call.\n\nI'll try to think of another way.", "author": "lochana-chathura", "createdAt": "2020-11-19T08:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYwMDg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYyMDk5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r526620991", "bodyText": "parsing the type-def qualifiers may not be the best approach. May be we could introduce a separate method?\nFor. e.g: in an expression context, transactional is a valid expression, not a qualifier. so we should not parse it as a qualifier.", "author": "SupunS", "createdAt": "2020-11-19T06:24:33Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3847,24 +3855,28 @@ private STNode parseTerminalExpression(boolean isRhsExpr, boolean allowActions,\n         return parseTerminalExpression(annots, isRhsExpr, allowActions, isInConditionalExpr);\n     }\n \n+    private STNode parseTerminalExpression(STNode annots, boolean isRhsExpr, boolean allowActions,\n+                                           boolean isInConditionalExpr) {\n+        List<STNode> qualifiers = new ArrayList<>();\n+        return parseTerminalExpression(annots, qualifiers, isRhsExpr, allowActions, isInConditionalExpr);\n+    }\n+\n     /**\n      * Parse terminal expressions. A terminal expression has the highest precedence level\n      * out of all expressions, and will be at the leaves of an expression tree.\n      *\n      * @param annots       Annotations\n+     * @param qualifiers   Initial qualifiers\n      * @param isRhsExpr    Is a rhs expression\n      * @param allowActions Allow actions\n      * @return Parsed node\n      */\n-    private STNode parseTerminalExpression(STNode annots, boolean isRhsExpr, boolean allowActions,\n-                                           boolean isInConditionalExpr) {\n+    private STNode parseTerminalExpression(STNode annots, List<STNode> qualifiers, boolean isRhsExpr,\n+                                           boolean allowActions, boolean isInConditionalExpr) {\n         // Whenever a new expression start is added, make sure to\n         // add it to all the other places as well.\n+        parseTypeDescQualifiers(qualifiers);", "originalCommit": "066dcb56dc0c66fe98d4d17635301d218edc3c96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ca37e29b56c661468fffb16811971af29d40aecd", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ca37e29b56c661468fffb16811971af29d40aecd", "message": "Add review suggestions", "committedDate": "2020-11-19T12:28:50Z", "type": "commit"}, {"oid": "6a82034322a8a29c65401fa30c3d644697dad171", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6a82034322a8a29c65401fa30c3d644697dad171", "message": "Merge branch 'master' of https://github.com/ballerina-platform/ballerina-lang into Isolated-qual", "committedDate": "2020-11-20T04:00:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzQ2MTcyMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26888#discussion_r527461720", "bodyText": "Can we use isValidExprStart method here?", "author": "SupunS", "createdAt": "2020-11-20T06:24:22Z", "path": "compiler/ballerina-parser/src/main/java/io/ballerina/compiler/internal/parser/BallerinaParser.java", "diffHunk": "@@ -3966,38 +3996,65 @@ private STNode parseTerminalExpression(STNode annots, boolean isRhsExpr, boolean\n                 break;\n         }\n \n-        Solution solution = recover(nextToken, ParserRuleContext.TERMINAL_EXPRESSION, annots, isRhsExpr, allowActions,\n+        recover(peek(), ParserRuleContext.TERMINAL_EXPRESSION, annots, qualifiers, isRhsExpr, allowActions,\n                 isInConditionalExpr);\n-\n-        if (solution.action == Action.KEEP) {\n-            if (nextToken.kind == SyntaxKind.XML_KEYWORD) {\n-                return parseXMLTemplateExpression();\n-            }\n-\n-            return parseStringTemplateExpression();\n-        }\n-\n-        return parseTerminalExpression(annots, isRhsExpr, allowActions, isInConditionalExpr);\n+        return parseTerminalExpression(annots, qualifiers, isRhsExpr, allowActions, isInConditionalExpr);\n     }\n \n-    private void validateExpressionAnnotations(STToken nextToken, STNode annots) {\n+    private void validateExprAnnotsAndQualifiers(STToken nextToken, STNode annots, List<STNode> qualifiers) {\n         switch (nextToken.kind) {\n-            case CLIENT_KEYWORD:\n-            case OBJECT_KEYWORD:\n-            case FUNCTION_KEYWORD:\n-            case ISOLATED_KEYWORD:\n+            case DECIMAL_INTEGER_LITERAL_TOKEN:\n+            case HEX_INTEGER_LITERAL_TOKEN:\n+            case STRING_LITERAL_TOKEN:\n+            case NULL_KEYWORD:\n+            case TRUE_KEYWORD:\n+            case FALSE_KEYWORD:\n+            case DECIMAL_FLOATING_POINT_LITERAL_TOKEN:\n+            case HEX_FLOATING_POINT_LITERAL_TOKEN:\n+            case IDENTIFIER_TOKEN:\n+            case OPEN_PAREN_TOKEN:\n+            case CHECK_KEYWORD:\n+            case CHECKPANIC_KEYWORD:\n+            case OPEN_BRACE_TOKEN:\n+            case TYPEOF_KEYWORD:\n+            case PLUS_TOKEN:\n+            case MINUS_TOKEN:\n+            case NEGATION_TOKEN:\n+            case EXCLAMATION_MARK_TOKEN:\n+            case TRAP_KEYWORD:\n+            case OPEN_BRACKET_TOKEN:\n+            case LT_TOKEN:\n+            case TABLE_KEYWORD:\n+            case STREAM_KEYWORD:\n+            case FROM_KEYWORD:\n+            case ERROR_KEYWORD:\n+            case LET_KEYWORD:\n+            case BACKTICK_TOKEN:\n+            case XML_KEYWORD:\n+            case STRING_KEYWORD:\n+            case NEW_KEYWORD:\n+            case FLUSH_KEYWORD:\n+            case LEFT_ARROW_TOKEN:\n+            case WAIT_KEYWORD:\n+            case COMMIT_KEYWORD:\n+            case TRANSACTIONAL_KEYWORD:\n+            case BASE16_KEYWORD:\n+            case BASE64_KEYWORD:", "originalCommit": "6a82034322a8a29c65401fa30c3d644697dad171", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a09e3748f4a01bc99dd33d354039790a03d1640", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a09e3748f4a01bc99dd33d354039790a03d1640", "message": "Add second tier review suggestions", "committedDate": "2020-11-20T13:54:28Z", "type": "commit"}]}