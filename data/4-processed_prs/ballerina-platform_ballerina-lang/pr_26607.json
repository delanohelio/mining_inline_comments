{"pr_number": 26607, "pr_title": "Add an API to get the type of an expression", "pr_createdAt": "2020-10-26T19:24:31Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607", "timeline": [{"oid": "fbb17ef1c332fd16b619204ff0fd5ad7f4096b69", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fbb17ef1c332fd16b619204ff0fd5ad7f4096b69", "message": "Add a visitor to find the node in the given range", "committedDate": "2020-10-27T14:01:42Z", "type": "commit"}, {"oid": "f166de9f38213714a119436009e03339c8bba024", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f166de9f38213714a119436009e03339c8bba024", "message": "Add API for getting types of expressions", "committedDate": "2020-10-27T14:01:42Z", "type": "commit"}, {"oid": "c890e2290acbdb32c3500af27b55bf8cc3df1231", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c890e2290acbdb32c3500af27b55bf8cc3df1231", "message": "Fix position issues in raw template and type init desugaring", "committedDate": "2020-10-27T14:01:42Z", "type": "commit"}, {"oid": "4d239300c058cfc26568abcd591b32d79e96e747", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/4d239300c058cfc26568abcd591b32d79e96e747", "message": "Fix mapping constructor pos issues", "committedDate": "2020-10-27T14:01:42Z", "type": "commit"}, {"oid": "7c3324ddd84dd8ac7dd465823b5e7ced56aa2ded", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/7c3324ddd84dd8ac7dd465823b5e7ced56aa2ded", "message": "Add tests for expression type", "committedDate": "2020-10-27T14:01:43Z", "type": "commit"}, {"oid": "3ffa4afcb3cc371f21e4519671f68c377a6e6ed0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/3ffa4afcb3cc371f21e4519671f68c377a6e6ed0", "message": "Fix field access exprs", "committedDate": "2020-10-27T14:01:43Z", "type": "commit"}, {"oid": "ad0150ecd2314e7abacd8365898d17e836940da9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ad0150ecd2314e7abacd8365898d17e836940da9", "message": "Fix object constructor expr issues", "committedDate": "2020-10-27T14:01:43Z", "type": "commit"}, {"oid": "70af3ee0b0ffc349bb19bcc6eb1df15f186481d1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/70af3ee0b0ffc349bb19bcc6eb1df15f186481d1", "message": "Fix pos issues and node finder issues", "committedDate": "2020-10-27T14:01:43Z", "type": "commit"}, {"oid": "70af3ee0b0ffc349bb19bcc6eb1df15f186481d1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/70af3ee0b0ffc349bb19bcc6eb1df15f186481d1", "message": "Fix pos issues and node finder issues", "committedDate": "2020-10-27T14:01:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjczOTE1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r512739157", "bodyText": "Shall we mention if the range is not valid, we return an empty optional? Instead of returns null", "author": "nadeeshaan", "createdAt": "2020-10-27T14:27:39Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/SemanticModel.java", "diffHunk": "@@ -57,6 +58,15 @@\n      */\n     List<Symbol> moduleLevelSymbols();\n \n+    /**\n+     * Retrieves the type of the expression in the specified text range. If it's not a valid expression, returns null.", "originalCommit": "70af3ee0b0ffc349bb19bcc6eb1df15f186481d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1MDU2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r512750564", "bodyText": "Do we need this null check since we do the null check within the setEnclosingNode method ?", "author": "nadeeshaan", "createdAt": "2020-10-27T14:40:57Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/NodeFinder.java", "diffHunk": "@@ -0,0 +1,1484 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.tools.text.LineRange;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.elements.Flag;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangAnnotation;\n+import org.wso2.ballerinalang.compiler.tree.BLangAnnotationAttachment;\n+import org.wso2.ballerinalang.compiler.tree.BLangBlockFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangClassDefinition;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangErrorVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangExprFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangExternalFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangMarkdownDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.BLangMarkdownReferenceDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.BLangRecordVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangRetrySpec;\n+import org.wso2.ballerinalang.compiler.tree.BLangService;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTableKeySpecifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangTableKeyTypeConstraint;\n+import org.wso2.ballerinalang.compiler.tree.BLangTupleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.BLangXMLNS;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangDoClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangFromClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangJoinClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangLetClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangLimitClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnConflictClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOrderByClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOrderKey;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangSelectClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangWhereClause;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangAnnotAccessExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangArrowFunction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCheckPanickedExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCheckedExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCommitExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangConstRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangConstant;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangElvisExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangErrorVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangGroupExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIgnoreExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIndexBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIntRangeExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIsAssignableExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIsLikeExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLambdaFunction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLetExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkDownDeprecatedParametersDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkDownDeprecationDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownDocumentationLine;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownParameterDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownReturnParameterDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangNamedArgsExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangNumericLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryAction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRawTemplateLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRestArgsExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangServiceConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStatementExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStringTemplateLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTableConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTableMultiKeyExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTernaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTransactionalExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTrapExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTupleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeInit;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeTestExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypedescExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangUnaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWaitExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWaitForAllExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerFlushExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerReceive;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerSyncSendExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLAttribute;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLCommentLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementFilter;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLNavigationAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLProcInsLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLQName;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLQuotedString;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLSequenceLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLTextLiteral;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBlockStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBreak;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangCompoundAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangContinue;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangErrorDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangErrorVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangExpressionStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangFail;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForeach;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForkJoin;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangIf;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangLock;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangMatch;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangMatch.BLangMatchStructuredBindingPatternClause;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangPanic;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRecordDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRecordVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRetry;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRetryTransaction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRollback;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangSimpleVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTransaction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTupleDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTupleVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangWhile;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangWorkerSend;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangXMLNSStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangArrayType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangBuiltInRefTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangConstrainedType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangErrorType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangFiniteTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangFunctionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangIntersectionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangLetVariable;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangObjectTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangStreamType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangTableTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangTupleTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUnionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUserDefinedType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+import static org.ballerinalang.model.symbols.SymbolOrigin.VIRTUAL;\n+\n+/**\n+ * Finds the enclosing AST node for the given position.\n+ *\n+ * @since 2.0.0\n+ */\n+class NodeFinder extends BLangNodeVisitor {\n+\n+    private LineRange range;\n+    private BLangNode enclosingNode;\n+\n+    BLangNode lookup(BLangCompilationUnit unit, LineRange range) {\n+        this.range = range;\n+        this.enclosingNode = null;\n+\n+        for (TopLevelNode node : unit.topLevelNodes) {\n+            if (!PositionUtil.withinRange(this.range, node.getPosition()) || isLambdaFunction(node)) {\n+                continue;\n+            }\n+\n+            ((BLangNode) node).accept(this);\n+\n+            if (this.enclosingNode != null) {\n+                break;\n+            }\n+        }\n+\n+        return this.enclosingNode;\n+    }\n+\n+    private void lookupNodes(List<? extends BLangNode> nodes) {\n+        for (BLangNode node : nodes) {\n+            if (!PositionUtil.withinRange(this.range, node.pos)) {\n+                continue;\n+            }\n+\n+            node.accept(this);\n+\n+            if (this.enclosingNode == null && !node.internal && setEnclosingNode(node, node.pos)) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void lookupNode(BLangNode node) {\n+        if (node == null) {\n+            return;\n+        }\n+\n+        if (PositionUtil.withinRange(this.range, node.pos)) {\n+            node.accept(this);\n+        }\n+\n+        if (this.enclosingNode == null && !node.internal) {", "originalCommit": "70af3ee0b0ffc349bb19bcc6eb1df15f186481d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc2OTM5Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r512769397", "bodyText": "Modified the logic related to this a bit. The setEnclosingNode() is usually used for nodes with names (e.g., variables, constants), to see if the provided range is the range of the name of it. With this latest cleanup, this is now required since now, for the typical case, this does what setEnclosingNode() method does.", "author": "pubudu91", "createdAt": "2020-10-27T15:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1MDU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1NDgwMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r512754801", "bodyText": "Shall we introduce a base visitor with empty implementation for all the visitor methods? We have a couple of visitors now and for some node we have to duplicate this empty visitor methods.", "author": "nadeeshaan", "createdAt": "2020-10-27T14:45:48Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/NodeFinder.java", "diffHunk": "@@ -0,0 +1,1484 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.tools.text.LineRange;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.elements.Flag;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangAnnotation;\n+import org.wso2.ballerinalang.compiler.tree.BLangAnnotationAttachment;\n+import org.wso2.ballerinalang.compiler.tree.BLangBlockFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangClassDefinition;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangErrorVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangExprFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangExternalFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangMarkdownDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.BLangMarkdownReferenceDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.BLangRecordVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangRetrySpec;\n+import org.wso2.ballerinalang.compiler.tree.BLangService;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTableKeySpecifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangTableKeyTypeConstraint;\n+import org.wso2.ballerinalang.compiler.tree.BLangTupleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.BLangXMLNS;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangDoClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangFromClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangJoinClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangLetClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangLimitClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnConflictClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOrderByClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOrderKey;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangSelectClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangWhereClause;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangAnnotAccessExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangArrowFunction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCheckPanickedExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCheckedExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCommitExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangConstRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangConstant;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangElvisExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangErrorVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangGroupExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIgnoreExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIndexBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIntRangeExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIsAssignableExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIsLikeExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLambdaFunction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLetExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkDownDeprecatedParametersDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkDownDeprecationDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownDocumentationLine;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownParameterDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownReturnParameterDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangNamedArgsExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangNumericLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryAction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRawTemplateLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRestArgsExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangServiceConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStatementExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStringTemplateLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTableConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTableMultiKeyExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTernaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTransactionalExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTrapExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTupleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeInit;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeTestExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypedescExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangUnaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWaitExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWaitForAllExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerFlushExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerReceive;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerSyncSendExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLAttribute;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLCommentLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementFilter;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLNavigationAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLProcInsLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLQName;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLQuotedString;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLSequenceLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLTextLiteral;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBlockStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBreak;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangCompoundAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangContinue;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangErrorDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangErrorVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangExpressionStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangFail;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForeach;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForkJoin;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangIf;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangLock;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangMatch;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangMatch.BLangMatchStructuredBindingPatternClause;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangPanic;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRecordDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRecordVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRetry;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRetryTransaction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRollback;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangSimpleVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTransaction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTupleDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTupleVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangWhile;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangWorkerSend;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangXMLNSStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangArrayType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangBuiltInRefTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangConstrainedType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangErrorType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangFiniteTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangFunctionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangIntersectionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangLetVariable;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangObjectTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangStreamType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangTableTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangTupleTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUnionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUserDefinedType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+import static org.ballerinalang.model.symbols.SymbolOrigin.VIRTUAL;\n+\n+/**\n+ * Finds the enclosing AST node for the given position.\n+ *\n+ * @since 2.0.0\n+ */\n+class NodeFinder extends BLangNodeVisitor {\n+\n+    private LineRange range;\n+    private BLangNode enclosingNode;\n+\n+    BLangNode lookup(BLangCompilationUnit unit, LineRange range) {\n+        this.range = range;\n+        this.enclosingNode = null;\n+\n+        for (TopLevelNode node : unit.topLevelNodes) {\n+            if (!PositionUtil.withinRange(this.range, node.getPosition()) || isLambdaFunction(node)) {\n+                continue;\n+            }\n+\n+            ((BLangNode) node).accept(this);\n+\n+            if (this.enclosingNode != null) {\n+                break;\n+            }\n+        }\n+\n+        return this.enclosingNode;\n+    }\n+\n+    private void lookupNodes(List<? extends BLangNode> nodes) {\n+        for (BLangNode node : nodes) {\n+            if (!PositionUtil.withinRange(this.range, node.pos)) {\n+                continue;\n+            }\n+\n+            node.accept(this);\n+\n+            if (this.enclosingNode == null && !node.internal && setEnclosingNode(node, node.pos)) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void lookupNode(BLangNode node) {\n+        if (node == null) {\n+            return;\n+        }\n+\n+        if (PositionUtil.withinRange(this.range, node.pos)) {\n+            node.accept(this);\n+        }\n+\n+        if (this.enclosingNode == null && !node.internal) {\n+            setEnclosingNode(node, node.pos);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangImportPackage importPkgNode) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLNS xmlnsNode) {\n+        lookupNode(xmlnsNode.namespaceURI);\n+    }\n+\n+    @Override\n+    public void visit(BLangFunction funcNode) {\n+        lookupNodes(funcNode.requiredParams);\n+        lookupNode(funcNode.restParam);\n+        lookupNode(funcNode.returnTypeNode);\n+        lookupNode(funcNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangBlockFunctionBody blockFuncBody) {\n+        lookupNodes(blockFuncBody.stmts);\n+    }\n+\n+    @Override\n+    public void visit(BLangExprFunctionBody exprFuncBody) {\n+        lookupNode(exprFuncBody.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangExternalFunctionBody externFuncBody) {\n+        lookupNodes(externFuncBody.annAttachments);\n+    }\n+\n+    @Override\n+    public void visit(BLangService serviceNode) {\n+        lookupNodes(serviceNode.resourceFunctions);\n+        lookupNodes(serviceNode.annAttachments);\n+        lookupNodes(serviceNode.attachedExprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypeDefinition typeDefinition) {\n+        lookupNode(typeDefinition.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangConstant constant) {\n+        if (setEnclosingNode(constant, constant.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(constant.typeNode);\n+        lookupNode(constant.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVariable varNode) {\n+        lookupNode(varNode.typeNode);\n+        lookupNode(varNode.expr);\n+        setEnclosingNode(varNode, varNode.name.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangIdentifier identifierNode) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangAnnotation annotationNode) {\n+        if (setEnclosingNode(annotationNode, annotationNode.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(annotationNode.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangAnnotationAttachment annAttachmentNode) {\n+        if (setEnclosingNode(annAttachmentNode, annAttachmentNode.annotationName.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(annAttachmentNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTableKeySpecifier tableKeySpecifierNode) {\n+        // TODO: How to figure out the symbols for the specified keys\n+    }\n+\n+    @Override\n+    public void visit(BLangTableKeyTypeConstraint tableKeyTypeConstraint) {\n+        lookupNode(tableKeyTypeConstraint.keyType);\n+    }\n+\n+    @Override\n+    public void visit(BLangBlockStmt blockNode) {\n+        lookupNodes(blockNode.stmts);\n+    }\n+\n+    @Override\n+    public void visit(BLangLock.BLangLockStmt lockStmtNode) {\n+        lookupNode(lockStmtNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangLock.BLangUnLockStmt unLockNode) {\n+        lookupNode(unLockNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVariableDef varDefNode) {\n+        lookupNode(varDefNode.var);\n+    }\n+\n+    @Override\n+    public void visit(BLangAssignment assignNode) {\n+        lookupNode(assignNode.varRef);\n+        lookupNode(assignNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangCompoundAssignment compoundAssignNode) {\n+        lookupNode(compoundAssignNode.varRef);\n+        lookupNode(compoundAssignNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangRetry retryNode) {\n+        lookupNode(retryNode.retryBody);\n+        lookupNode(retryNode.retrySpec);\n+    }\n+\n+    @Override\n+    public void visit(BLangRetryTransaction retryTransaction) {\n+        lookupNode(retryTransaction.transaction);\n+        lookupNode(retryTransaction.retrySpec);\n+    }\n+\n+    @Override\n+    public void visit(BLangRetrySpec retrySpec) {\n+        lookupNode(retrySpec.retryManagerType);\n+        lookupNodes(retrySpec.argExprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangContinue continueNode) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangBreak breakNode) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangReturn returnNode) {\n+        lookupNode(returnNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangPanic panicNode) {\n+        lookupNode(panicNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLNSStatement xmlnsStmtNode) {\n+        lookupNode(xmlnsStmtNode.xmlnsDecl);\n+    }\n+\n+    @Override\n+    public void visit(BLangExpressionStmt exprStmtNode) {\n+        lookupNode(exprStmtNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIf ifNode) {\n+        lookupNode(ifNode.expr);\n+        lookupNode(ifNode.body);\n+        lookupNode(ifNode.elseStmt);\n+    }\n+\n+    @Override\n+    public void visit(BLangQueryAction queryAction) {\n+        lookupNodes(queryAction.queryClauseList);\n+        lookupNode(queryAction.doClause);\n+    }\n+\n+    @Override\n+    public void visit(BLangMatch matchNode) {\n+        lookupNode(matchNode.expr);\n+        lookupNodes(matchNode.patternClauses);\n+    }\n+\n+    @Override\n+    public void visit(BLangMatch.BLangMatchTypedBindingPatternClause patternClauseNode) {\n+        lookupNode(patternClauseNode.matchExpr);\n+        lookupNode(patternClauseNode.variable);\n+        lookupNode(patternClauseNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangForeach foreach) {\n+        lookupNode((BLangNode) foreach.variableDefinitionNode);\n+        lookupNode(foreach.collection);\n+        lookupNode(foreach.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangFromClause fromClause) {\n+        lookupNode(fromClause.collection);\n+        lookupNode((BLangNode) fromClause.variableDefinitionNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangJoinClause joinClause) {\n+        lookupNode(joinClause.collection);\n+        lookupNode((BLangNode) joinClause.variableDefinitionNode);\n+        lookupNode((BLangNode) joinClause.onClause);\n+    }\n+\n+    @Override\n+    public void visit(BLangLetClause letClause) {\n+        for (BLangLetVariable var : letClause.letVarDeclarations) {\n+            lookupNode((BLangNode) var.definitionNode);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangOnClause onClause) {\n+        lookupNode(onClause.lhsExpr);\n+        lookupNode(onClause.rhsExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangOrderKey orderKeyClause) {\n+        lookupNode(orderKeyClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangOrderByClause orderByClause) {\n+        for (OrderKeyNode key : orderByClause.orderByKeyList) {\n+            lookupNode((BLangNode) key);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangSelectClause selectClause) {\n+        lookupNode(selectClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangWhereClause whereClause) {\n+        lookupNode(whereClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangDoClause doClause) {\n+        lookupNode(doClause.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangOnConflictClause onConflictClause) {\n+        lookupNode(onConflictClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangLimitClause limitClause) {\n+        lookupNode(limitClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangWhile whileNode) {\n+        lookupNode(whileNode.expr);\n+        lookupNode(whileNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangLock lockNode) {\n+        lookupNode(lockNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangTransaction transactionNode) {\n+        lookupNode(transactionNode.transactionBody);\n+    }\n+\n+    @Override\n+    public void visit(BLangTupleDestructure stmt) {\n+        lookupNode(stmt.expr);\n+        lookupNode(stmt.varRef);\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordDestructure stmt) {\n+        lookupNode(stmt.expr);\n+        lookupNode(stmt.varRef);\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorDestructure stmt) {\n+        lookupNode(stmt.expr);\n+        lookupNode(stmt.varRef);\n+    }\n+\n+    @Override\n+    public void visit(BLangForkJoin forkJoin) {\n+        lookupNodes(forkJoin.workers);\n+    }\n+\n+    @Override\n+    public void visit(BLangWorkerSend workerSendNode) {\n+        if (setEnclosingNode(workerSendNode.expr, workerSendNode.expr.pos)) {\n+            return;\n+        }\n+\n+        setEnclosingNode(workerSendNode, workerSendNode.workerIdentifier.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangWorkerReceive workerReceiveNode) {\n+        setEnclosingNode(workerReceiveNode, workerReceiveNode.workerIdentifier.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangRollback rollbackNode) {\n+        lookupNode(rollbackNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangLiteral literalExpr) {\n+        // Do nothing", "originalCommit": "70af3ee0b0ffc349bb19bcc6eb1df15f186481d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1NzM3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r512757379", "bodyText": "Calling the super methods throws assertion error", "author": "nadeeshaan", "createdAt": "2020-10-27T14:48:53Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/NodeFinder.java", "diffHunk": "@@ -0,0 +1,1484 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.tools.text.LineRange;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.elements.Flag;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangAnnotation;\n+import org.wso2.ballerinalang.compiler.tree.BLangAnnotationAttachment;\n+import org.wso2.ballerinalang.compiler.tree.BLangBlockFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangClassDefinition;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangErrorVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangExprFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangExternalFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangMarkdownDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.BLangMarkdownReferenceDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.BLangRecordVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangRetrySpec;\n+import org.wso2.ballerinalang.compiler.tree.BLangService;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTableKeySpecifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangTableKeyTypeConstraint;\n+import org.wso2.ballerinalang.compiler.tree.BLangTupleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.BLangXMLNS;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangDoClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangFromClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangJoinClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangLetClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangLimitClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnConflictClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOrderByClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOrderKey;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangSelectClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangWhereClause;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangAnnotAccessExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangArrowFunction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCheckPanickedExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCheckedExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCommitExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangConstRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangConstant;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangElvisExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangErrorVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangGroupExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIgnoreExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIndexBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIntRangeExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIsAssignableExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIsLikeExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLambdaFunction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLetExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkDownDeprecatedParametersDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkDownDeprecationDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownDocumentationLine;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownParameterDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownReturnParameterDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangNamedArgsExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangNumericLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryAction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRawTemplateLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRestArgsExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangServiceConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStatementExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStringTemplateLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTableConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTableMultiKeyExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTernaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTransactionalExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTrapExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTupleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeInit;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeTestExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypedescExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangUnaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWaitExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWaitForAllExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerFlushExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerReceive;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerSyncSendExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLAttribute;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLCommentLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementFilter;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLNavigationAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLProcInsLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLQName;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLQuotedString;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLSequenceLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLTextLiteral;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBlockStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBreak;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangCompoundAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangContinue;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangErrorDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangErrorVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangExpressionStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangFail;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForeach;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForkJoin;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangIf;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangLock;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangMatch;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangMatch.BLangMatchStructuredBindingPatternClause;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangPanic;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRecordDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRecordVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRetry;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRetryTransaction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRollback;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangSimpleVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTransaction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTupleDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTupleVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangWhile;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangWorkerSend;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangXMLNSStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangArrayType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangBuiltInRefTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangConstrainedType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangErrorType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangFiniteTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangFunctionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangIntersectionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangLetVariable;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangObjectTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangStreamType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangTableTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangTupleTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUnionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUserDefinedType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+import static org.ballerinalang.model.symbols.SymbolOrigin.VIRTUAL;\n+\n+/**\n+ * Finds the enclosing AST node for the given position.\n+ *\n+ * @since 2.0.0\n+ */\n+class NodeFinder extends BLangNodeVisitor {\n+\n+    private LineRange range;\n+    private BLangNode enclosingNode;\n+\n+    BLangNode lookup(BLangCompilationUnit unit, LineRange range) {\n+        this.range = range;\n+        this.enclosingNode = null;\n+\n+        for (TopLevelNode node : unit.topLevelNodes) {\n+            if (!PositionUtil.withinRange(this.range, node.getPosition()) || isLambdaFunction(node)) {\n+                continue;\n+            }\n+\n+            ((BLangNode) node).accept(this);\n+\n+            if (this.enclosingNode != null) {\n+                break;\n+            }\n+        }\n+\n+        return this.enclosingNode;\n+    }\n+\n+    private void lookupNodes(List<? extends BLangNode> nodes) {\n+        for (BLangNode node : nodes) {\n+            if (!PositionUtil.withinRange(this.range, node.pos)) {\n+                continue;\n+            }\n+\n+            node.accept(this);\n+\n+            if (this.enclosingNode == null && !node.internal && setEnclosingNode(node, node.pos)) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void lookupNode(BLangNode node) {\n+        if (node == null) {\n+            return;\n+        }\n+\n+        if (PositionUtil.withinRange(this.range, node.pos)) {\n+            node.accept(this);\n+        }\n+\n+        if (this.enclosingNode == null && !node.internal) {\n+            setEnclosingNode(node, node.pos);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangImportPackage importPkgNode) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLNS xmlnsNode) {\n+        lookupNode(xmlnsNode.namespaceURI);\n+    }\n+\n+    @Override\n+    public void visit(BLangFunction funcNode) {\n+        lookupNodes(funcNode.requiredParams);\n+        lookupNode(funcNode.restParam);\n+        lookupNode(funcNode.returnTypeNode);\n+        lookupNode(funcNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangBlockFunctionBody blockFuncBody) {\n+        lookupNodes(blockFuncBody.stmts);\n+    }\n+\n+    @Override\n+    public void visit(BLangExprFunctionBody exprFuncBody) {\n+        lookupNode(exprFuncBody.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangExternalFunctionBody externFuncBody) {\n+        lookupNodes(externFuncBody.annAttachments);\n+    }\n+\n+    @Override\n+    public void visit(BLangService serviceNode) {\n+        lookupNodes(serviceNode.resourceFunctions);\n+        lookupNodes(serviceNode.annAttachments);\n+        lookupNodes(serviceNode.attachedExprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypeDefinition typeDefinition) {\n+        lookupNode(typeDefinition.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangConstant constant) {\n+        if (setEnclosingNode(constant, constant.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(constant.typeNode);\n+        lookupNode(constant.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVariable varNode) {\n+        lookupNode(varNode.typeNode);\n+        lookupNode(varNode.expr);\n+        setEnclosingNode(varNode, varNode.name.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangIdentifier identifierNode) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangAnnotation annotationNode) {\n+        if (setEnclosingNode(annotationNode, annotationNode.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(annotationNode.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangAnnotationAttachment annAttachmentNode) {\n+        if (setEnclosingNode(annAttachmentNode, annAttachmentNode.annotationName.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(annAttachmentNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTableKeySpecifier tableKeySpecifierNode) {\n+        // TODO: How to figure out the symbols for the specified keys\n+    }\n+\n+    @Override\n+    public void visit(BLangTableKeyTypeConstraint tableKeyTypeConstraint) {\n+        lookupNode(tableKeyTypeConstraint.keyType);\n+    }\n+\n+    @Override\n+    public void visit(BLangBlockStmt blockNode) {\n+        lookupNodes(blockNode.stmts);\n+    }\n+\n+    @Override\n+    public void visit(BLangLock.BLangLockStmt lockStmtNode) {\n+        lookupNode(lockStmtNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangLock.BLangUnLockStmt unLockNode) {\n+        lookupNode(unLockNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVariableDef varDefNode) {\n+        lookupNode(varDefNode.var);\n+    }\n+\n+    @Override\n+    public void visit(BLangAssignment assignNode) {\n+        lookupNode(assignNode.varRef);\n+        lookupNode(assignNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangCompoundAssignment compoundAssignNode) {\n+        lookupNode(compoundAssignNode.varRef);\n+        lookupNode(compoundAssignNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangRetry retryNode) {\n+        lookupNode(retryNode.retryBody);\n+        lookupNode(retryNode.retrySpec);\n+    }\n+\n+    @Override\n+    public void visit(BLangRetryTransaction retryTransaction) {\n+        lookupNode(retryTransaction.transaction);\n+        lookupNode(retryTransaction.retrySpec);\n+    }\n+\n+    @Override\n+    public void visit(BLangRetrySpec retrySpec) {\n+        lookupNode(retrySpec.retryManagerType);\n+        lookupNodes(retrySpec.argExprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangContinue continueNode) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangBreak breakNode) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangReturn returnNode) {\n+        lookupNode(returnNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangPanic panicNode) {\n+        lookupNode(panicNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLNSStatement xmlnsStmtNode) {\n+        lookupNode(xmlnsStmtNode.xmlnsDecl);\n+    }\n+\n+    @Override\n+    public void visit(BLangExpressionStmt exprStmtNode) {\n+        lookupNode(exprStmtNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIf ifNode) {\n+        lookupNode(ifNode.expr);\n+        lookupNode(ifNode.body);\n+        lookupNode(ifNode.elseStmt);\n+    }\n+\n+    @Override\n+    public void visit(BLangQueryAction queryAction) {\n+        lookupNodes(queryAction.queryClauseList);\n+        lookupNode(queryAction.doClause);\n+    }\n+\n+    @Override\n+    public void visit(BLangMatch matchNode) {\n+        lookupNode(matchNode.expr);\n+        lookupNodes(matchNode.patternClauses);\n+    }\n+\n+    @Override\n+    public void visit(BLangMatch.BLangMatchTypedBindingPatternClause patternClauseNode) {\n+        lookupNode(patternClauseNode.matchExpr);\n+        lookupNode(patternClauseNode.variable);\n+        lookupNode(patternClauseNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangForeach foreach) {\n+        lookupNode((BLangNode) foreach.variableDefinitionNode);\n+        lookupNode(foreach.collection);\n+        lookupNode(foreach.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangFromClause fromClause) {\n+        lookupNode(fromClause.collection);\n+        lookupNode((BLangNode) fromClause.variableDefinitionNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangJoinClause joinClause) {\n+        lookupNode(joinClause.collection);\n+        lookupNode((BLangNode) joinClause.variableDefinitionNode);\n+        lookupNode((BLangNode) joinClause.onClause);\n+    }\n+\n+    @Override\n+    public void visit(BLangLetClause letClause) {\n+        for (BLangLetVariable var : letClause.letVarDeclarations) {\n+            lookupNode((BLangNode) var.definitionNode);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangOnClause onClause) {\n+        lookupNode(onClause.lhsExpr);\n+        lookupNode(onClause.rhsExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangOrderKey orderKeyClause) {\n+        lookupNode(orderKeyClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangOrderByClause orderByClause) {\n+        for (OrderKeyNode key : orderByClause.orderByKeyList) {\n+            lookupNode((BLangNode) key);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangSelectClause selectClause) {\n+        lookupNode(selectClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangWhereClause whereClause) {\n+        lookupNode(whereClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangDoClause doClause) {\n+        lookupNode(doClause.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangOnConflictClause onConflictClause) {\n+        lookupNode(onConflictClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangLimitClause limitClause) {\n+        lookupNode(limitClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangWhile whileNode) {\n+        lookupNode(whileNode.expr);\n+        lookupNode(whileNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangLock lockNode) {\n+        lookupNode(lockNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangTransaction transactionNode) {\n+        lookupNode(transactionNode.transactionBody);\n+    }\n+\n+    @Override\n+    public void visit(BLangTupleDestructure stmt) {\n+        lookupNode(stmt.expr);\n+        lookupNode(stmt.varRef);\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordDestructure stmt) {\n+        lookupNode(stmt.expr);\n+        lookupNode(stmt.varRef);\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorDestructure stmt) {\n+        lookupNode(stmt.expr);\n+        lookupNode(stmt.varRef);\n+    }\n+\n+    @Override\n+    public void visit(BLangForkJoin forkJoin) {\n+        lookupNodes(forkJoin.workers);\n+    }\n+\n+    @Override\n+    public void visit(BLangWorkerSend workerSendNode) {\n+        if (setEnclosingNode(workerSendNode.expr, workerSendNode.expr.pos)) {\n+            return;\n+        }\n+\n+        setEnclosingNode(workerSendNode, workerSendNode.workerIdentifier.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangWorkerReceive workerReceiveNode) {\n+        setEnclosingNode(workerReceiveNode, workerReceiveNode.workerIdentifier.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangRollback rollbackNode) {\n+        lookupNode(rollbackNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangLiteral literalExpr) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangConstRef constRef) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangNumericLiteral literalExpr) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordLiteral recordLiteral) {\n+        for (RecordLiteralNode.RecordField field : recordLiteral.fields) {\n+            lookupNode((BLangNode) field);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangTupleVarRef varRefExpr) {\n+        if (setEnclosingNode(varRefExpr, varRefExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(varRefExpr.expressions);\n+        lookupNode((BLangNode) varRefExpr.restParam);\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordVarRef varRefExpr) {\n+        // TODO: implement this\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorVarRef varRefExpr) {\n+        if (setEnclosingNode(varRefExpr, varRefExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(varRefExpr.message);\n+        lookupNodes(varRefExpr.detail);\n+        lookupNode(varRefExpr.cause);\n+        lookupNode(varRefExpr.restVar);\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVarRef varRefExpr) {\n+        if (setEnclosingNode(varRefExpr, varRefExpr.variableName.pos)) {\n+            return;\n+        }\n+\n+        setEnclosingNode(varRefExpr, varRefExpr.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangFieldBasedAccess fieldAccessExpr) {\n+        if (setEnclosingNode(fieldAccessExpr, fieldAccessExpr.field.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(fieldAccessExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIndexBasedAccess indexAccessExpr) {\n+        lookupNode(indexAccessExpr.expr);\n+        lookupNode(indexAccessExpr.indexExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangInvocation invocationExpr) {\n+        if (setEnclosingNode(invocationExpr, invocationExpr.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(invocationExpr.requiredArgs);\n+        lookupNodes(invocationExpr.restArgs);\n+        lookupNode(invocationExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypeInit typeInit) {\n+        lookupNode(typeInit.userDefinedType);\n+        lookupNodes(typeInit.argsExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangInvocation.BLangActionInvocation actionInvocationExpr) {\n+        if (setEnclosingNode(actionInvocationExpr, actionInvocationExpr.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(actionInvocationExpr.requiredArgs);\n+        lookupNodes(actionInvocationExpr.restArgs);\n+        lookupNode(actionInvocationExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTernaryExpr ternaryExpr) {\n+        if (setEnclosingNode(ternaryExpr, ternaryExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(ternaryExpr.expr);\n+        lookupNode(ternaryExpr.thenExpr);\n+        lookupNode(ternaryExpr.elseExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangWaitExpr awaitExpr) {\n+        if (setEnclosingNode(awaitExpr, awaitExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(awaitExpr.exprList);\n+    }\n+\n+    @Override\n+    public void visit(BLangTrapExpr trapExpr) {\n+        if (setEnclosingNode(trapExpr, trapExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(trapExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangBinaryExpr binaryExpr) {\n+        lookupNode(binaryExpr.lhsExpr);\n+        lookupNode(binaryExpr.rhsExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangElvisExpr elvisExpr) {\n+        lookupNode(elvisExpr.lhsExpr);\n+        lookupNode(elvisExpr.rhsExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangGroupExpr groupExpr) {\n+        lookupNode(groupExpr.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangLetExpression letExpr) {\n+        for (BLangLetVariable var : letExpr.letVarDeclarations) {\n+            lookupNode((BLangNode) var.definitionNode);\n+        }\n+\n+        lookupNode(letExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangListConstructorExpr listConstructorExpr) {\n+        lookupNodes(listConstructorExpr.exprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangTableConstructorExpr tableConstructorExpr) {\n+        lookupNode(tableConstructorExpr.tableKeySpecifier);\n+        lookupNodes(tableConstructorExpr.recordLiteralList);\n+    }\n+\n+    @Override\n+    public void visit(BLangListConstructorExpr.BLangTupleLiteral tupleLiteral) {\n+        lookupNodes(tupleLiteral.exprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangListConstructorExpr.BLangArrayLiteral arrayLiteral) {\n+        lookupNodes(arrayLiteral.exprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangUnaryExpr unaryExpr) {\n+        lookupNode(unaryExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypedescExpr typedescExpr) {\n+        lookupNode(typedescExpr.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypeConversionExpr conversionExpr) {\n+        lookupNodes(conversionExpr.annAttachments);\n+        lookupNode(conversionExpr.typeNode);\n+        lookupNode(conversionExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLQName xmlQName) {\n+        if (setEnclosingNode(xmlQName, xmlQName.pos)\n+                || setEnclosingNode(xmlQName, xmlQName.prefix.pos)) {\n+            return;\n+        }\n+\n+        setEnclosingNode(xmlQName, xmlQName.localname.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLAttribute xmlAttribute) {\n+\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLElementLiteral xmlElementLiteral) {\n+        lookupNode(xmlElementLiteral.startTagName);\n+        lookupNodes(xmlElementLiteral.attributes);\n+        lookupNodes(xmlElementLiteral.children);\n+        lookupNode(xmlElementLiteral.endTagName);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLTextLiteral xmlTextLiteral) {\n+        lookupNode(xmlTextLiteral.concatExpr);\n+        lookupNodes(xmlTextLiteral.textFragments);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLCommentLiteral xmlCommentLiteral) {\n+        if (setEnclosingNode(xmlCommentLiteral, xmlCommentLiteral.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(xmlCommentLiteral.concatExpr);\n+        lookupNodes(xmlCommentLiteral.textFragments);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLProcInsLiteral xmlProcInsLiteral) {\n+        lookupNode(xmlProcInsLiteral.dataConcatExpr);\n+        lookupNodes(xmlProcInsLiteral.dataFragments);\n+        lookupNode(xmlProcInsLiteral.target);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLQuotedString xmlQuotedString) {\n+        lookupNode(xmlQuotedString.concatExpr);\n+        lookupNodes(xmlQuotedString.textFragments);\n+    }\n+\n+    @Override\n+    public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n+        lookupNodes(stringTemplateLiteral.exprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        lookupNodes(rawTemplateLiteral.strings);\n+        lookupNodes(rawTemplateLiteral.insertions);\n+    }\n+\n+    @Override\n+    public void visit(BLangLambdaFunction bLangLambdaFunction) {\n+        if (setEnclosingNode(bLangLambdaFunction, bLangLambdaFunction.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(bLangLambdaFunction.function);\n+    }\n+\n+    @Override\n+    public void visit(BLangArrowFunction bLangArrowFunction) {\n+        if (setEnclosingNode(bLangArrowFunction, bLangArrowFunction.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(bLangArrowFunction.params);\n+        lookupNode(bLangArrowFunction.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangIntRangeExpression intRangeExpression) {\n+        if (setEnclosingNode(intRangeExpression, intRangeExpression.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(intRangeExpression.startExpr);\n+        lookupNode(intRangeExpression.endExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangRestArgsExpression bLangVarArgsExpression) {\n+        if (setEnclosingNode(bLangVarArgsExpression, bLangVarArgsExpression.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(bLangVarArgsExpression.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangNamedArgsExpression bLangNamedArgsExpression) {\n+        if (setEnclosingNode(bLangNamedArgsExpression, bLangNamedArgsExpression.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(bLangNamedArgsExpression.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIsAssignableExpr assignableExpr) {\n+        if (setEnclosingNode(assignableExpr, assignableExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(assignableExpr.lhsExpr);\n+        lookupNode(assignableExpr.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangCheckedExpr checkedExpr) {\n+        if (setEnclosingNode(checkedExpr, checkedExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(checkedExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangFail failExpr) {\n+        if (setEnclosingNode(failExpr, failExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(failExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangCheckPanickedExpr checkPanickedExpr) {\n+        if (setEnclosingNode(checkPanickedExpr, checkPanickedExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(checkPanickedExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangServiceConstructorExpr serviceConstructorExpr) {\n+        if (setEnclosingNode(serviceConstructorExpr, serviceConstructorExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(serviceConstructorExpr.serviceNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypeTestExpr typeTestExpr) {\n+        lookupNode(typeTestExpr.expr);\n+        lookupNode(typeTestExpr.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangIsLikeExpr typeTestExpr) {\n+        lookupNode(typeTestExpr.expr);\n+        lookupNode(typeTestExpr.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangIgnoreExpr ignoreExpr) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangAnnotAccessExpr annotAccessExpr) {\n+        setEnclosingNode(annotAccessExpr, annotAccessExpr.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangQueryExpr queryExpr) {\n+        if (setEnclosingNode(queryExpr, queryExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(queryExpr.queryClauseList);\n+    }\n+\n+    @Override\n+    public void visit(BLangTableMultiKeyExpr tableMultiKeyExpr) {", "originalCommit": "70af3ee0b0ffc349bb19bcc6eb1df15f186481d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc3MTg1MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r512771851", "bodyText": "Was intentional, since these are not yet supported. Throwing an unsupported expression exception would be more appropriate i guess?", "author": "pubudu91", "createdAt": "2020-10-27T15:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1NzM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5NDE3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r512894179", "bodyText": "This will be OK during the development until we finish the implementation. Otherwise these might cause broken usages even for valid cases. We had such issues with earlier LS visitor implementations", "author": "nadeeshaan", "createdAt": "2020-10-27T17:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1NzM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxNDg1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513214857", "bodyText": "Throwing an error here goes against the idea of having a base-visitor with empty impl, isn't it?", "author": "SupunS", "createdAt": "2020-10-28T06:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1NzM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIzNjAwNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513236004", "bodyText": "@SupunS yeah, we override the base expectation", "author": "nadeeshaan", "createdAt": "2020-10-28T07:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1NzM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1OTczNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r512759737", "bodyText": "Calls the super here", "author": "nadeeshaan", "createdAt": "2020-10-27T14:51:35Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/NodeFinder.java", "diffHunk": "@@ -0,0 +1,1484 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.tools.text.LineRange;\n+import org.ballerinalang.model.clauses.OrderKeyNode;\n+import org.ballerinalang.model.elements.Flag;\n+import org.ballerinalang.model.tree.NodeKind;\n+import org.ballerinalang.model.tree.TopLevelNode;\n+import org.ballerinalang.model.tree.expressions.RecordLiteralNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangAnnotation;\n+import org.wso2.ballerinalang.compiler.tree.BLangAnnotationAttachment;\n+import org.wso2.ballerinalang.compiler.tree.BLangBlockFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangClassDefinition;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangErrorVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangExprFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangExternalFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangMarkdownDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.BLangMarkdownReferenceDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.BLangNode;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.BLangRecordVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangRetrySpec;\n+import org.wso2.ballerinalang.compiler.tree.BLangService;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTableKeySpecifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangTableKeyTypeConstraint;\n+import org.wso2.ballerinalang.compiler.tree.BLangTupleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.BLangXMLNS;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangDoClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangFromClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangJoinClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangLetClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangLimitClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnConflictClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOrderByClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOrderKey;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangSelectClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangWhereClause;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangAnnotAccessExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangArrowFunction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCheckPanickedExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCheckedExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCommitExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangConstRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangConstant;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangElvisExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangErrorVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangGroupExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIgnoreExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIndexBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIntRangeExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIsAssignableExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIsLikeExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLambdaFunction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLetExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkDownDeprecatedParametersDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkDownDeprecationDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownDocumentationLine;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownParameterDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownReturnParameterDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangNamedArgsExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangNumericLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryAction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRawTemplateLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRestArgsExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangServiceConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStatementExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStringTemplateLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTableConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTableMultiKeyExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTernaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTransactionalExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTrapExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTupleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeInit;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeTestExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypedescExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangUnaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWaitExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWaitForAllExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerFlushExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerReceive;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerSyncSendExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLAttribute;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLCommentLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementFilter;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLNavigationAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLProcInsLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLQName;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLQuotedString;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLSequenceLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLTextLiteral;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBlockStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBreak;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangCompoundAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangContinue;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangErrorDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangErrorVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangExpressionStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangFail;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForeach;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForkJoin;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangIf;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangLock;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangMatch;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangMatch.BLangMatchStructuredBindingPatternClause;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangPanic;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRecordDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRecordVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRetry;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRetryTransaction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRollback;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangSimpleVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTransaction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTupleDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTupleVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangWhile;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangWorkerSend;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangXMLNSStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangArrayType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangBuiltInRefTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangConstrainedType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangErrorType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangFiniteTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangFunctionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangIntersectionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangLetVariable;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangObjectTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangStreamType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangTableTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangTupleTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUnionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUserDefinedType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+import static org.ballerinalang.model.symbols.SymbolOrigin.VIRTUAL;\n+\n+/**\n+ * Finds the enclosing AST node for the given position.\n+ *\n+ * @since 2.0.0\n+ */\n+class NodeFinder extends BLangNodeVisitor {\n+\n+    private LineRange range;\n+    private BLangNode enclosingNode;\n+\n+    BLangNode lookup(BLangCompilationUnit unit, LineRange range) {\n+        this.range = range;\n+        this.enclosingNode = null;\n+\n+        for (TopLevelNode node : unit.topLevelNodes) {\n+            if (!PositionUtil.withinRange(this.range, node.getPosition()) || isLambdaFunction(node)) {\n+                continue;\n+            }\n+\n+            ((BLangNode) node).accept(this);\n+\n+            if (this.enclosingNode != null) {\n+                break;\n+            }\n+        }\n+\n+        return this.enclosingNode;\n+    }\n+\n+    private void lookupNodes(List<? extends BLangNode> nodes) {\n+        for (BLangNode node : nodes) {\n+            if (!PositionUtil.withinRange(this.range, node.pos)) {\n+                continue;\n+            }\n+\n+            node.accept(this);\n+\n+            if (this.enclosingNode == null && !node.internal && setEnclosingNode(node, node.pos)) {\n+                return;\n+            }\n+        }\n+    }\n+\n+    private void lookupNode(BLangNode node) {\n+        if (node == null) {\n+            return;\n+        }\n+\n+        if (PositionUtil.withinRange(this.range, node.pos)) {\n+            node.accept(this);\n+        }\n+\n+        if (this.enclosingNode == null && !node.internal) {\n+            setEnclosingNode(node, node.pos);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangImportPackage importPkgNode) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLNS xmlnsNode) {\n+        lookupNode(xmlnsNode.namespaceURI);\n+    }\n+\n+    @Override\n+    public void visit(BLangFunction funcNode) {\n+        lookupNodes(funcNode.requiredParams);\n+        lookupNode(funcNode.restParam);\n+        lookupNode(funcNode.returnTypeNode);\n+        lookupNode(funcNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangBlockFunctionBody blockFuncBody) {\n+        lookupNodes(blockFuncBody.stmts);\n+    }\n+\n+    @Override\n+    public void visit(BLangExprFunctionBody exprFuncBody) {\n+        lookupNode(exprFuncBody.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangExternalFunctionBody externFuncBody) {\n+        lookupNodes(externFuncBody.annAttachments);\n+    }\n+\n+    @Override\n+    public void visit(BLangService serviceNode) {\n+        lookupNodes(serviceNode.resourceFunctions);\n+        lookupNodes(serviceNode.annAttachments);\n+        lookupNodes(serviceNode.attachedExprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypeDefinition typeDefinition) {\n+        lookupNode(typeDefinition.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangConstant constant) {\n+        if (setEnclosingNode(constant, constant.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(constant.typeNode);\n+        lookupNode(constant.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVariable varNode) {\n+        lookupNode(varNode.typeNode);\n+        lookupNode(varNode.expr);\n+        setEnclosingNode(varNode, varNode.name.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangIdentifier identifierNode) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangAnnotation annotationNode) {\n+        if (setEnclosingNode(annotationNode, annotationNode.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(annotationNode.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangAnnotationAttachment annAttachmentNode) {\n+        if (setEnclosingNode(annAttachmentNode, annAttachmentNode.annotationName.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(annAttachmentNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTableKeySpecifier tableKeySpecifierNode) {\n+        // TODO: How to figure out the symbols for the specified keys\n+    }\n+\n+    @Override\n+    public void visit(BLangTableKeyTypeConstraint tableKeyTypeConstraint) {\n+        lookupNode(tableKeyTypeConstraint.keyType);\n+    }\n+\n+    @Override\n+    public void visit(BLangBlockStmt blockNode) {\n+        lookupNodes(blockNode.stmts);\n+    }\n+\n+    @Override\n+    public void visit(BLangLock.BLangLockStmt lockStmtNode) {\n+        lookupNode(lockStmtNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangLock.BLangUnLockStmt unLockNode) {\n+        lookupNode(unLockNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVariableDef varDefNode) {\n+        lookupNode(varDefNode.var);\n+    }\n+\n+    @Override\n+    public void visit(BLangAssignment assignNode) {\n+        lookupNode(assignNode.varRef);\n+        lookupNode(assignNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangCompoundAssignment compoundAssignNode) {\n+        lookupNode(compoundAssignNode.varRef);\n+        lookupNode(compoundAssignNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangRetry retryNode) {\n+        lookupNode(retryNode.retryBody);\n+        lookupNode(retryNode.retrySpec);\n+    }\n+\n+    @Override\n+    public void visit(BLangRetryTransaction retryTransaction) {\n+        lookupNode(retryTransaction.transaction);\n+        lookupNode(retryTransaction.retrySpec);\n+    }\n+\n+    @Override\n+    public void visit(BLangRetrySpec retrySpec) {\n+        lookupNode(retrySpec.retryManagerType);\n+        lookupNodes(retrySpec.argExprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangContinue continueNode) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangBreak breakNode) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangReturn returnNode) {\n+        lookupNode(returnNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangPanic panicNode) {\n+        lookupNode(panicNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLNSStatement xmlnsStmtNode) {\n+        lookupNode(xmlnsStmtNode.xmlnsDecl);\n+    }\n+\n+    @Override\n+    public void visit(BLangExpressionStmt exprStmtNode) {\n+        lookupNode(exprStmtNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIf ifNode) {\n+        lookupNode(ifNode.expr);\n+        lookupNode(ifNode.body);\n+        lookupNode(ifNode.elseStmt);\n+    }\n+\n+    @Override\n+    public void visit(BLangQueryAction queryAction) {\n+        lookupNodes(queryAction.queryClauseList);\n+        lookupNode(queryAction.doClause);\n+    }\n+\n+    @Override\n+    public void visit(BLangMatch matchNode) {\n+        lookupNode(matchNode.expr);\n+        lookupNodes(matchNode.patternClauses);\n+    }\n+\n+    @Override\n+    public void visit(BLangMatch.BLangMatchTypedBindingPatternClause patternClauseNode) {\n+        lookupNode(patternClauseNode.matchExpr);\n+        lookupNode(patternClauseNode.variable);\n+        lookupNode(patternClauseNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangForeach foreach) {\n+        lookupNode((BLangNode) foreach.variableDefinitionNode);\n+        lookupNode(foreach.collection);\n+        lookupNode(foreach.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangFromClause fromClause) {\n+        lookupNode(fromClause.collection);\n+        lookupNode((BLangNode) fromClause.variableDefinitionNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangJoinClause joinClause) {\n+        lookupNode(joinClause.collection);\n+        lookupNode((BLangNode) joinClause.variableDefinitionNode);\n+        lookupNode((BLangNode) joinClause.onClause);\n+    }\n+\n+    @Override\n+    public void visit(BLangLetClause letClause) {\n+        for (BLangLetVariable var : letClause.letVarDeclarations) {\n+            lookupNode((BLangNode) var.definitionNode);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangOnClause onClause) {\n+        lookupNode(onClause.lhsExpr);\n+        lookupNode(onClause.rhsExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangOrderKey orderKeyClause) {\n+        lookupNode(orderKeyClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangOrderByClause orderByClause) {\n+        for (OrderKeyNode key : orderByClause.orderByKeyList) {\n+            lookupNode((BLangNode) key);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangSelectClause selectClause) {\n+        lookupNode(selectClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangWhereClause whereClause) {\n+        lookupNode(whereClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangDoClause doClause) {\n+        lookupNode(doClause.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangOnConflictClause onConflictClause) {\n+        lookupNode(onConflictClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangLimitClause limitClause) {\n+        lookupNode(limitClause.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangWhile whileNode) {\n+        lookupNode(whileNode.expr);\n+        lookupNode(whileNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangLock lockNode) {\n+        lookupNode(lockNode.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangTransaction transactionNode) {\n+        lookupNode(transactionNode.transactionBody);\n+    }\n+\n+    @Override\n+    public void visit(BLangTupleDestructure stmt) {\n+        lookupNode(stmt.expr);\n+        lookupNode(stmt.varRef);\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordDestructure stmt) {\n+        lookupNode(stmt.expr);\n+        lookupNode(stmt.varRef);\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorDestructure stmt) {\n+        lookupNode(stmt.expr);\n+        lookupNode(stmt.varRef);\n+    }\n+\n+    @Override\n+    public void visit(BLangForkJoin forkJoin) {\n+        lookupNodes(forkJoin.workers);\n+    }\n+\n+    @Override\n+    public void visit(BLangWorkerSend workerSendNode) {\n+        if (setEnclosingNode(workerSendNode.expr, workerSendNode.expr.pos)) {\n+            return;\n+        }\n+\n+        setEnclosingNode(workerSendNode, workerSendNode.workerIdentifier.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangWorkerReceive workerReceiveNode) {\n+        setEnclosingNode(workerReceiveNode, workerReceiveNode.workerIdentifier.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangRollback rollbackNode) {\n+        lookupNode(rollbackNode.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangLiteral literalExpr) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangConstRef constRef) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangNumericLiteral literalExpr) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordLiteral recordLiteral) {\n+        for (RecordLiteralNode.RecordField field : recordLiteral.fields) {\n+            lookupNode((BLangNode) field);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangTupleVarRef varRefExpr) {\n+        if (setEnclosingNode(varRefExpr, varRefExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(varRefExpr.expressions);\n+        lookupNode((BLangNode) varRefExpr.restParam);\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordVarRef varRefExpr) {\n+        // TODO: implement this\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorVarRef varRefExpr) {\n+        if (setEnclosingNode(varRefExpr, varRefExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(varRefExpr.message);\n+        lookupNodes(varRefExpr.detail);\n+        lookupNode(varRefExpr.cause);\n+        lookupNode(varRefExpr.restVar);\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVarRef varRefExpr) {\n+        if (setEnclosingNode(varRefExpr, varRefExpr.variableName.pos)) {\n+            return;\n+        }\n+\n+        setEnclosingNode(varRefExpr, varRefExpr.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangFieldBasedAccess fieldAccessExpr) {\n+        if (setEnclosingNode(fieldAccessExpr, fieldAccessExpr.field.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(fieldAccessExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIndexBasedAccess indexAccessExpr) {\n+        lookupNode(indexAccessExpr.expr);\n+        lookupNode(indexAccessExpr.indexExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangInvocation invocationExpr) {\n+        if (setEnclosingNode(invocationExpr, invocationExpr.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(invocationExpr.requiredArgs);\n+        lookupNodes(invocationExpr.restArgs);\n+        lookupNode(invocationExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypeInit typeInit) {\n+        lookupNode(typeInit.userDefinedType);\n+        lookupNodes(typeInit.argsExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangInvocation.BLangActionInvocation actionInvocationExpr) {\n+        if (setEnclosingNode(actionInvocationExpr, actionInvocationExpr.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(actionInvocationExpr.requiredArgs);\n+        lookupNodes(actionInvocationExpr.restArgs);\n+        lookupNode(actionInvocationExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTernaryExpr ternaryExpr) {\n+        if (setEnclosingNode(ternaryExpr, ternaryExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(ternaryExpr.expr);\n+        lookupNode(ternaryExpr.thenExpr);\n+        lookupNode(ternaryExpr.elseExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangWaitExpr awaitExpr) {\n+        if (setEnclosingNode(awaitExpr, awaitExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(awaitExpr.exprList);\n+    }\n+\n+    @Override\n+    public void visit(BLangTrapExpr trapExpr) {\n+        if (setEnclosingNode(trapExpr, trapExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(trapExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangBinaryExpr binaryExpr) {\n+        lookupNode(binaryExpr.lhsExpr);\n+        lookupNode(binaryExpr.rhsExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangElvisExpr elvisExpr) {\n+        lookupNode(elvisExpr.lhsExpr);\n+        lookupNode(elvisExpr.rhsExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangGroupExpr groupExpr) {\n+        lookupNode(groupExpr.expression);\n+    }\n+\n+    @Override\n+    public void visit(BLangLetExpression letExpr) {\n+        for (BLangLetVariable var : letExpr.letVarDeclarations) {\n+            lookupNode((BLangNode) var.definitionNode);\n+        }\n+\n+        lookupNode(letExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangListConstructorExpr listConstructorExpr) {\n+        lookupNodes(listConstructorExpr.exprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangTableConstructorExpr tableConstructorExpr) {\n+        lookupNode(tableConstructorExpr.tableKeySpecifier);\n+        lookupNodes(tableConstructorExpr.recordLiteralList);\n+    }\n+\n+    @Override\n+    public void visit(BLangListConstructorExpr.BLangTupleLiteral tupleLiteral) {\n+        lookupNodes(tupleLiteral.exprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangListConstructorExpr.BLangArrayLiteral arrayLiteral) {\n+        lookupNodes(arrayLiteral.exprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangUnaryExpr unaryExpr) {\n+        lookupNode(unaryExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypedescExpr typedescExpr) {\n+        lookupNode(typedescExpr.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypeConversionExpr conversionExpr) {\n+        lookupNodes(conversionExpr.annAttachments);\n+        lookupNode(conversionExpr.typeNode);\n+        lookupNode(conversionExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLQName xmlQName) {\n+        if (setEnclosingNode(xmlQName, xmlQName.pos)\n+                || setEnclosingNode(xmlQName, xmlQName.prefix.pos)) {\n+            return;\n+        }\n+\n+        setEnclosingNode(xmlQName, xmlQName.localname.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLAttribute xmlAttribute) {\n+\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLElementLiteral xmlElementLiteral) {\n+        lookupNode(xmlElementLiteral.startTagName);\n+        lookupNodes(xmlElementLiteral.attributes);\n+        lookupNodes(xmlElementLiteral.children);\n+        lookupNode(xmlElementLiteral.endTagName);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLTextLiteral xmlTextLiteral) {\n+        lookupNode(xmlTextLiteral.concatExpr);\n+        lookupNodes(xmlTextLiteral.textFragments);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLCommentLiteral xmlCommentLiteral) {\n+        if (setEnclosingNode(xmlCommentLiteral, xmlCommentLiteral.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(xmlCommentLiteral.concatExpr);\n+        lookupNodes(xmlCommentLiteral.textFragments);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLProcInsLiteral xmlProcInsLiteral) {\n+        lookupNode(xmlProcInsLiteral.dataConcatExpr);\n+        lookupNodes(xmlProcInsLiteral.dataFragments);\n+        lookupNode(xmlProcInsLiteral.target);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLQuotedString xmlQuotedString) {\n+        lookupNode(xmlQuotedString.concatExpr);\n+        lookupNodes(xmlQuotedString.textFragments);\n+    }\n+\n+    @Override\n+    public void visit(BLangStringTemplateLiteral stringTemplateLiteral) {\n+        lookupNodes(stringTemplateLiteral.exprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangRawTemplateLiteral rawTemplateLiteral) {\n+        lookupNodes(rawTemplateLiteral.strings);\n+        lookupNodes(rawTemplateLiteral.insertions);\n+    }\n+\n+    @Override\n+    public void visit(BLangLambdaFunction bLangLambdaFunction) {\n+        if (setEnclosingNode(bLangLambdaFunction, bLangLambdaFunction.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(bLangLambdaFunction.function);\n+    }\n+\n+    @Override\n+    public void visit(BLangArrowFunction bLangArrowFunction) {\n+        if (setEnclosingNode(bLangArrowFunction, bLangArrowFunction.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(bLangArrowFunction.params);\n+        lookupNode(bLangArrowFunction.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangIntRangeExpression intRangeExpression) {\n+        if (setEnclosingNode(intRangeExpression, intRangeExpression.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(intRangeExpression.startExpr);\n+        lookupNode(intRangeExpression.endExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangRestArgsExpression bLangVarArgsExpression) {\n+        if (setEnclosingNode(bLangVarArgsExpression, bLangVarArgsExpression.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(bLangVarArgsExpression.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangNamedArgsExpression bLangNamedArgsExpression) {\n+        if (setEnclosingNode(bLangNamedArgsExpression, bLangNamedArgsExpression.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(bLangNamedArgsExpression.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIsAssignableExpr assignableExpr) {\n+        if (setEnclosingNode(assignableExpr, assignableExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(assignableExpr.lhsExpr);\n+        lookupNode(assignableExpr.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangCheckedExpr checkedExpr) {\n+        if (setEnclosingNode(checkedExpr, checkedExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(checkedExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangFail failExpr) {\n+        if (setEnclosingNode(failExpr, failExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(failExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangCheckPanickedExpr checkPanickedExpr) {\n+        if (setEnclosingNode(checkPanickedExpr, checkPanickedExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(checkPanickedExpr.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangServiceConstructorExpr serviceConstructorExpr) {\n+        if (setEnclosingNode(serviceConstructorExpr, serviceConstructorExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(serviceConstructorExpr.serviceNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangTypeTestExpr typeTestExpr) {\n+        lookupNode(typeTestExpr.expr);\n+        lookupNode(typeTestExpr.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangIsLikeExpr typeTestExpr) {\n+        lookupNode(typeTestExpr.expr);\n+        lookupNode(typeTestExpr.typeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangIgnoreExpr ignoreExpr) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangAnnotAccessExpr annotAccessExpr) {\n+        setEnclosingNode(annotAccessExpr, annotAccessExpr.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangQueryExpr queryExpr) {\n+        if (setEnclosingNode(queryExpr, queryExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(queryExpr.queryClauseList);\n+    }\n+\n+    @Override\n+    public void visit(BLangTableMultiKeyExpr tableMultiKeyExpr) {\n+        super.visit(tableMultiKeyExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTransactionalExpr transactionalExpr) {\n+        super.visit(transactionalExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangCommitExpr commitExpr) {\n+        setEnclosingNode(commitExpr, commitExpr.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangValueType valueType) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangArrayType arrayType) {\n+        if (setEnclosingNode(arrayType, arrayType.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(arrayType.elemtype);\n+    }\n+\n+    @Override\n+    public void visit(BLangBuiltInRefTypeNode builtInRefType) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangConstrainedType constrainedType) {\n+        lookupNode(constrainedType.constraint);\n+    }\n+\n+    @Override\n+    public void visit(BLangStreamType streamType) {\n+        if (setEnclosingNode(streamType, streamType.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(streamType.constraint);\n+        lookupNode(streamType.error);\n+    }\n+\n+    @Override\n+    public void visit(BLangTableTypeNode tableType) {\n+        if (setEnclosingNode(tableType, tableType.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(tableType.constraint);\n+        lookupNode(tableType.tableKeySpecifier);\n+        lookupNode(tableType.tableKeyTypeConstraint);\n+    }\n+\n+    @Override\n+    public void visit(BLangUserDefinedType userDefinedType) {\n+        if (userDefinedType.type.tsymbol.origin == VIRTUAL\n+                || setEnclosingNode(userDefinedType, userDefinedType.pos)) {\n+            return;\n+        }\n+\n+        setEnclosingNode(userDefinedType, userDefinedType.typeName.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangFunctionTypeNode functionTypeNode) {\n+        if (setEnclosingNode(functionTypeNode, functionTypeNode.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(functionTypeNode.params);\n+        lookupNode(functionTypeNode.restParam);\n+        lookupNode(functionTypeNode.returnTypeNode);\n+    }\n+\n+    @Override\n+    public void visit(BLangUnionTypeNode unionTypeNode) {\n+        if (setEnclosingNode(unionTypeNode, unionTypeNode.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(unionTypeNode.memberTypeNodes);\n+    }\n+\n+    @Override\n+    public void visit(BLangIntersectionTypeNode intersectionTypeNode) {\n+        if (setEnclosingNode(intersectionTypeNode, intersectionTypeNode.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(intersectionTypeNode.constituentTypeNodes);\n+    }\n+\n+    @Override\n+    public void visit(BLangClassDefinition classDefinition) {\n+        // skip the generated class def for services\n+        if (classDefinition.flagSet.contains(Flag.SERVICE)) {\n+            return;\n+        }\n+\n+        lookupNodes(classDefinition.annAttachments);\n+        lookupNodes(classDefinition.fields);\n+        lookupNodes(classDefinition.referencedFields);\n+        lookupNode(classDefinition.initFunction);\n+        lookupNodes(classDefinition.functions);\n+        lookupNodes(classDefinition.typeRefs);\n+        setEnclosingNode(classDefinition, classDefinition.name.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangObjectTypeNode objectTypeNode) {\n+        if (setEnclosingNode(objectTypeNode, objectTypeNode.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(objectTypeNode.fields);\n+        lookupNodes(objectTypeNode.functions);\n+        lookupNodes(objectTypeNode.typeRefs);\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordTypeNode recordTypeNode) {\n+        if (setEnclosingNode(recordTypeNode, recordTypeNode.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(recordTypeNode.fields);\n+        lookupNodes(recordTypeNode.typeRefs);\n+    }\n+\n+    @Override\n+    public void visit(BLangFiniteTypeNode finiteTypeNode) {\n+        if (setEnclosingNode(finiteTypeNode, finiteTypeNode.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(finiteTypeNode.valueSpace);\n+    }\n+\n+    @Override\n+    public void visit(BLangTupleTypeNode tupleTypeNode) {\n+        if (setEnclosingNode(tupleTypeNode, tupleTypeNode.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(tupleTypeNode.memberTypeNodes);\n+        lookupNode(tupleTypeNode.restParamType);\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorType errorType) {\n+        if (setEnclosingNode(errorType, errorType.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(errorType.detailType);\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVarRef.BLangLocalVarRef localVarRef) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVarRef.BLangFieldVarRef fieldVarRef) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVarRef.BLangPackageVarRef packageVarRef) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVarRef.BLangFunctionVarRef functionVarRef) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangSimpleVarRef.BLangTypeLoad typeLoad) {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    public void visit(BLangIndexBasedAccess.BLangStructFieldAccessExpr fieldAccessExpr) {\n+        lookupNode(fieldAccessExpr.expr);\n+        setEnclosingNode(fieldAccessExpr, fieldAccessExpr.indexExpr.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangFieldBasedAccess.BLangStructFunctionVarRef functionVarRef) {\n+        if (setEnclosingNode(functionVarRef, functionVarRef.pos)\n+                || setEnclosingNode(functionVarRef, functionVarRef.field.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(functionVarRef.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIndexBasedAccess.BLangMapAccessExpr mapKeyAccessExpr) {\n+        if (setEnclosingNode(mapKeyAccessExpr, mapKeyAccessExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(mapKeyAccessExpr.expr);\n+        lookupNode(mapKeyAccessExpr.indexExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIndexBasedAccess.BLangArrayAccessExpr arrayIndexAccessExpr) {\n+        if (setEnclosingNode(arrayIndexAccessExpr, arrayIndexAccessExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(arrayIndexAccessExpr.expr);\n+        lookupNode(arrayIndexAccessExpr.indexExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIndexBasedAccess.BLangTableAccessExpr tableKeyAccessExpr) {\n+        if (setEnclosingNode(tableKeyAccessExpr, tableKeyAccessExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(tableKeyAccessExpr.expr);\n+        lookupNode(tableKeyAccessExpr.indexExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIndexBasedAccess.BLangXMLAccessExpr xmlAccessExpr) {\n+        if (setEnclosingNode(xmlAccessExpr, xmlAccessExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(xmlAccessExpr.expr);\n+        lookupNode(xmlAccessExpr.indexExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordLiteral.BLangMapLiteral mapLiteral) {\n+        for (RecordLiteralNode.RecordField field : mapLiteral.fields) {\n+            lookupNode((BLangNode) field);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordLiteral.BLangStructLiteral structLiteral) {\n+        for (RecordLiteralNode.RecordField field : structLiteral.fields) {\n+            lookupNode((BLangNode) field);\n+        }\n+    }\n+\n+    @Override\n+    public void visit(BLangInvocation.BFunctionPointerInvocation bFunctionPointerInvocation) {\n+        if (setEnclosingNode(bFunctionPointerInvocation, bFunctionPointerInvocation.pos)\n+                || setEnclosingNode(bFunctionPointerInvocation, bFunctionPointerInvocation.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(bFunctionPointerInvocation.requiredArgs);\n+        lookupNodes(bFunctionPointerInvocation.restArgs);\n+    }\n+\n+    @Override\n+    public void visit(BLangInvocation.BLangAttachedFunctionInvocation iExpr) {\n+        if (setEnclosingNode(iExpr, iExpr.pos)\n+                || setEnclosingNode(iExpr, iExpr.name.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(iExpr.expr);\n+        lookupNodes(iExpr.requiredArgs);\n+        lookupNodes(iExpr.restArgs);\n+    }\n+\n+    @Override\n+    public void visit(BLangListConstructorExpr.BLangJSONArrayLiteral jsonArrayLiteral) {\n+        if (setEnclosingNode(jsonArrayLiteral, jsonArrayLiteral.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(jsonArrayLiteral.exprs);\n+    }\n+\n+    @Override\n+    public void visit(BLangIndexBasedAccess.BLangJSONAccessExpr jsonAccessExpr) {\n+        if (setEnclosingNode(jsonAccessExpr, jsonAccessExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(jsonAccessExpr.expr);\n+        lookupNode(jsonAccessExpr.indexExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangIndexBasedAccess.BLangStringAccessExpr stringAccessExpr) {\n+        if (setEnclosingNode(stringAccessExpr, stringAccessExpr.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(stringAccessExpr.expr);\n+        lookupNode(stringAccessExpr.indexExpr);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLNS.BLangLocalXMLNS xmlnsNode) {\n+        if (setEnclosingNode(xmlnsNode, xmlnsNode.pos)\n+                || setEnclosingNode(xmlnsNode, xmlnsNode.prefix.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(xmlnsNode.namespaceURI);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLNS.BLangPackageXMLNS xmlnsNode) {\n+        if (setEnclosingNode(xmlnsNode, xmlnsNode.pos)\n+                || setEnclosingNode(xmlnsNode, xmlnsNode.prefix.pos)) {\n+            return;\n+        }\n+\n+        lookupNode(xmlnsNode.namespaceURI);\n+    }\n+\n+    @Override\n+    public void visit(BLangXMLSequenceLiteral bLangXMLSequenceLiteral) {\n+        if (setEnclosingNode(bLangXMLSequenceLiteral, bLangXMLSequenceLiteral.pos)) {\n+            return;\n+        }\n+\n+        lookupNodes(bLangXMLSequenceLiteral.xmlItems);\n+    }\n+\n+    @Override\n+    public void visit(BLangStatementExpression bLangStatementExpression) {\n+        lookupNode(bLangStatementExpression.stmt);\n+        lookupNode(bLangStatementExpression.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangMarkdownDocumentationLine bLangMarkdownDocumentationLine) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangMarkdownParameterDocumentation bLangDocumentationParameter) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangMarkdownReturnParameterDocumentation bLangMarkdownReturnParameterDocumentation) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangMarkDownDeprecationDocumentation bLangMarkDownDeprecationDocumentation) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangMarkDownDeprecatedParametersDocumentation bLangMarkDownDeprecatedParametersDocumentation) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangMarkdownDocumentation bLangMarkdownDocumentation) {\n+        // ignore\n+    }\n+\n+    @Override\n+    public void visit(BLangTupleVariable bLangTupleVariable) {\n+        lookupNodes(bLangTupleVariable.memberVariables);\n+        lookupNode(bLangTupleVariable.restVariable);\n+        lookupNode(bLangTupleVariable.expr);\n+    }\n+\n+    @Override\n+    public void visit(BLangTupleVariableDef bLangTupleVariableDef) {\n+        lookupNode(bLangTupleVariableDef.var);\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordVariable bLangRecordVariable) {\n+        for (BLangRecordVariable.BLangRecordVariableKeyValue var : bLangRecordVariable.variableList) {\n+            lookupNode(var.valueBindingPattern);\n+        }\n+        lookupNode((BLangNode) bLangRecordVariable.restParam);\n+        lookupNodes(bLangRecordVariable.annAttachments);\n+    }\n+\n+    @Override\n+    public void visit(BLangRecordVariableDef bLangRecordVariableDef) {\n+        lookupNode(bLangRecordVariableDef.var);\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorVariable bLangErrorVariable) {\n+        lookupNode(bLangErrorVariable.message);\n+\n+        for (BLangErrorVariable.BLangErrorDetailEntry detail : bLangErrorVariable.detail) {\n+            lookupNode(detail.valueBindingPattern);\n+        }\n+\n+        lookupNode(bLangErrorVariable.detailExpr);\n+        lookupNode(bLangErrorVariable.cause);\n+        lookupNode(bLangErrorVariable.reasonMatchConst);\n+        lookupNode(bLangErrorVariable.restDetail);\n+    }\n+\n+    @Override\n+    public void visit(BLangErrorVariableDef bLangErrorVariableDef) {\n+        lookupNode(bLangErrorVariableDef.errorVariable);\n+    }\n+\n+    @Override\n+    public void visit(BLangMatch.BLangMatchStaticBindingPatternClause bLangMatchStmtStaticBindingPatternClause) {\n+        lookupNode(bLangMatchStmtStaticBindingPatternClause.matchExpr);\n+        lookupNode(bLangMatchStmtStaticBindingPatternClause.literal);\n+        lookupNode(bLangMatchStmtStaticBindingPatternClause.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangMatchStructuredBindingPatternClause bLangMatchStmtStructuredBindingPatternClause) {\n+        lookupNode(bLangMatchStmtStructuredBindingPatternClause.bindingPatternVariable);\n+        lookupNode(bLangMatchStmtStructuredBindingPatternClause.typeGuardExpr);\n+        lookupNode(bLangMatchStmtStructuredBindingPatternClause.matchExpr);\n+        lookupNode(bLangMatchStmtStructuredBindingPatternClause.body);\n+    }\n+\n+    @Override\n+    public void visit(BLangWorkerFlushExpr workerFlushExpr) {\n+        if (setEnclosingNode(workerFlushExpr, workerFlushExpr.pos)) {\n+            return;\n+        }\n+\n+        setEnclosingNode(workerFlushExpr, workerFlushExpr.workerIdentifier.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangWorkerSyncSendExpr syncSendExpr) {\n+        if (setEnclosingNode(syncSendExpr, syncSendExpr.pos)\n+                || setEnclosingNode(syncSendExpr.expr, syncSendExpr.expr.pos)) {\n+            return;\n+        }\n+\n+        setEnclosingNode(syncSendExpr, syncSendExpr.workerIdentifier.pos);\n+    }\n+\n+    @Override\n+    public void visit(BLangWaitForAllExpr waitForAllExpr) {\n+        super.visit(waitForAllExpr);", "originalCommit": "70af3ee0b0ffc349bb19bcc6eb1df15f186481d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dff7da6ce65b1842b2d2fc1e9cf9fa419fc562ad", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/dff7da6ce65b1842b2d2fc1e9cf9fa419fc562ad", "message": "Cleanup NodeFinder visitor", "committedDate": "2020-10-27T14:58:07Z", "type": "commit"}, {"oid": "ba46c6d5fdd2930976f0b61a0f6eed27660646db", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/ba46c6d5fdd2930976f0b61a0f6eed27660646db", "message": "Add a base node visitor with empty implementations", "committedDate": "2020-10-27T16:28:01Z", "type": "commit"}, {"oid": "1a3b62b5d8b24323601c193875d751cd4752abb1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a3b62b5d8b24323601c193875d751cd4752abb1", "message": "Fix broken test cases", "committedDate": "2020-10-27T16:28:24Z", "type": "commit"}, {"oid": "1a3b62b5d8b24323601c193875d751cd4752abb1", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/1a3b62b5d8b24323601c193875d751cd4752abb1", "message": "Fix broken test cases", "committedDate": "2020-10-27T16:28:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxMTM2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513211367", "bodyText": "We can optimize this.\nCheck this one: https://github.com/ballerina-platform/ballerina-lang/blob/master/misc/formatter/modules/formatter-core/src/main/java/org/ballerinalang/formatter/core/FormatterUtils.java#L47:L61", "author": "SupunS", "createdAt": "2020-10-28T06:43:18Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/PositionUtil.java", "diffHunk": "@@ -42,4 +43,22 @@ static boolean withinBlock(LinePosition cursorPos, Diagnostic.DiagnosticPosition\n                 || (startLine == endLine && startLine == cursorLine\n                 && startColumn <= cursorColumn && endColumn > cursorColumn);\n     }\n+\n+    static boolean withinRange(LineRange specifiedRange, Diagnostic.DiagnosticPosition nodePosition) {\n+        int startLine = nodePosition.getStartLine();\n+        int startOffset = nodePosition.getStartColumn();\n+        int endLine = nodePosition.getEndLine();\n+        int endOffset = nodePosition.getEndColumn();\n+\n+        int specifiedStartLine = specifiedRange.startLine().line();\n+        int specifiedEndLine = specifiedRange.endLine().line();\n+        int specifiedStartOffset = specifiedRange.startLine().offset();\n+        int specifiedEndOffset = specifiedRange.endLine().offset();\n+\n+        return (startLine < specifiedStartLine && endLine > specifiedEndLine)\n+                || (startLine < specifiedStartLine && endLine == specifiedEndLine && endOffset > specifiedEndOffset)\n+                || (startLine == specifiedStartLine && startOffset < specifiedStartOffset && endLine > specifiedEndLine)\n+                || (startLine == endLine && startLine == specifiedStartLine && specifiedStartLine == specifiedEndLine\n+                && startOffset <= specifiedStartOffset && endOffset >= specifiedEndOffset);", "originalCommit": "1a3b62b5d8b24323601c193875d751cd4752abb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMyOTc3MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513329770", "bodyText": "This doesn't seem to work in this case (tests failing). Here we're checking if a particular node encompasses the specified range. The above mentioned checks don't seem to cover all the cases for that. Will see if the checks can be simplified.", "author": "pubudu91", "createdAt": "2020-10-28T10:21:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxMTM2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMDQ4Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513420482", "bodyText": "Can write it as follows, if it feels more readable\nif (specifiedStartLine < startLine || specifiedEndLine > endLine) {\n    return false;\n}\n\nif (specifiedStartLine > startLine && specifiedEndLine < endLine) {\n    return true;\n}\n\nif (specifiedStartLine == startLine && specifiedEndLine == endLine) {\n    return specifiedStartOffset >= startOffset && specifiedEndOffset <= endOffset;\n}\n\nif (specifiedStartLine == startLine) {\n    return specifiedStartOffset >= startOffset;\n}\n\nreturn specifiedEndOffset <= endOffset;", "author": "pubudu91", "createdAt": "2020-10-28T12:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxMTM2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxMTkzMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513211931", "bodyText": "Should this be an abstract class? and probably called AbstractNodeVisitor?", "author": "SupunS", "createdAt": "2020-10-28T06:45:03Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/BaseVisitor.java", "diffHunk": "@@ -0,0 +1,988 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import org.wso2.ballerinalang.compiler.tree.BLangAnnotation;\n+import org.wso2.ballerinalang.compiler.tree.BLangAnnotationAttachment;\n+import org.wso2.ballerinalang.compiler.tree.BLangBlockFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangClassDefinition;\n+import org.wso2.ballerinalang.compiler.tree.BLangCompilationUnit;\n+import org.wso2.ballerinalang.compiler.tree.BLangErrorVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangExprFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangExternalFunctionBody;\n+import org.wso2.ballerinalang.compiler.tree.BLangFunction;\n+import org.wso2.ballerinalang.compiler.tree.BLangIdentifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangImportPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangMarkdownDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.BLangMarkdownReferenceDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.BLangNodeVisitor;\n+import org.wso2.ballerinalang.compiler.tree.BLangPackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangRecordVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangResource;\n+import org.wso2.ballerinalang.compiler.tree.BLangRetrySpec;\n+import org.wso2.ballerinalang.compiler.tree.BLangService;\n+import org.wso2.ballerinalang.compiler.tree.BLangSimpleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTableKeySpecifier;\n+import org.wso2.ballerinalang.compiler.tree.BLangTableKeyTypeConstraint;\n+import org.wso2.ballerinalang.compiler.tree.BLangTestablePackage;\n+import org.wso2.ballerinalang.compiler.tree.BLangTupleVariable;\n+import org.wso2.ballerinalang.compiler.tree.BLangTypeDefinition;\n+import org.wso2.ballerinalang.compiler.tree.BLangWorker;\n+import org.wso2.ballerinalang.compiler.tree.BLangXMLNS;\n+import org.wso2.ballerinalang.compiler.tree.bindingpatterns.BLangCaptureBindingPattern;\n+import org.wso2.ballerinalang.compiler.tree.bindingpatterns.BLangListBindingPattern;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangDoClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangFromClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangJoinClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangLetClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangLimitClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangMatchClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnConflictClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOnFailClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOrderByClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangOrderKey;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangSelectClause;\n+import org.wso2.ballerinalang.compiler.tree.clauses.BLangWhereClause;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangAnnotAccessExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangArrowFunction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangBinaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCheckPanickedExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCheckedExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangCommitExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangConstRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangConstant;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangElvisExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangErrorVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangFieldBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangGroupExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIgnoreExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIndexBasedAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIntRangeExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangInvocation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIsAssignableExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangIsLikeExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLambdaFunction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLetExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangListConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkDownDeprecatedParametersDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkDownDeprecationDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownDocumentationLine;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownParameterDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMarkdownReturnParameterDocumentation;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMatchExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangMatchGuard;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangNamedArgsExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangNumericLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangObjectConstructorExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryAction;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangQueryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRawTemplateLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangRestArgsExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangServiceConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangSimpleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStatementExpression;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangStringTemplateLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTableConstructorExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTableMultiKeyExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTernaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTransactionalExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTrapExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTupleVarRef;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeConversionExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeInit;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypeTestExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangTypedescExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangUnaryExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWaitExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWaitForAllExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerFlushExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerReceive;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangWorkerSyncSendExpr;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLAttribute;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLAttributeAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLCommentLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementFilter;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLElementLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLNavigationAccess;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLProcInsLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLQName;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLQuotedString;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLSequenceLiteral;\n+import org.wso2.ballerinalang.compiler.tree.expressions.BLangXMLTextLiteral;\n+import org.wso2.ballerinalang.compiler.tree.matchpatterns.BLangConstPattern;\n+import org.wso2.ballerinalang.compiler.tree.matchpatterns.BLangVarBindingPatternMatchPattern;\n+import org.wso2.ballerinalang.compiler.tree.matchpatterns.BLangWildCardMatchPattern;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBlockStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangBreak;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangCatch;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangCompoundAssignment;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangContinue;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangDo;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangErrorDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangErrorVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangExpressionStmt;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangFail;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForeach;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangForkJoin;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangIf;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangLock;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangMatch;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangMatchStatement;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangPanic;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRecordDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRecordVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRetry;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRetryTransaction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangReturn;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangRollback;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangSimpleVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangThrow;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTransaction;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTryCatchFinally;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTupleDestructure;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangTupleVariableDef;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangWhile;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangWorkerSend;\n+import org.wso2.ballerinalang.compiler.tree.statements.BLangXMLNSStatement;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangArrayType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangBuiltInRefTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangConstrainedType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangErrorType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangFiniteTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangFunctionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangIntersectionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangLetVariable;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangObjectTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangRecordTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangStreamType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangTableTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangTupleTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUnionTypeNode;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangUserDefinedType;\n+import org.wso2.ballerinalang.compiler.tree.types.BLangValueType;\n+\n+/**\n+ * A default visitor with empty implementations for the visit methods, to be used as the base visitor in visitors\n+ * implemented.\n+ *\n+ * @since 2.0.0\n+ */\n+class BaseVisitor extends BLangNodeVisitor {", "originalCommit": "1a3b62b5d8b24323601c193875d751cd4752abb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxMjgzOQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513212839", "bodyText": "SymbolFinder can also extends from this visitor. There are methods with empty impl in that class. We can get rid of them too.", "author": "SupunS", "createdAt": "2020-10-28T06:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxMTkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzI0MjYzNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513242636", "bodyText": "Yeah, can be.\nWas planning on doing the refactoring to SymbolFinder with a separate PR to avoid unnecessary noise in this PR.", "author": "pubudu91", "createdAt": "2020-10-28T08:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzIxMTkzMQ=="}], "type": "inlineReview"}, {"oid": "815831dc656aae0c509edb2836b4443840a45fd2", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/815831dc656aae0c509edb2836b4443840a45fd2", "message": "Add tests for casting and checking exprs", "committedDate": "2020-10-28T09:49:02Z", "type": "commit"}, {"oid": "e3ac140205f21d33f2568ca1cdcba06f3ee6e1b7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/e3ac140205f21d33f2568ca1cdcba06f3ee6e1b7", "message": "Implement missing visit() methods", "committedDate": "2020-10-28T10:22:48Z", "type": "commit"}, {"oid": "9f520ad9aadc158381271986e639445e7d28598f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9f520ad9aadc158381271986e639445e7d28598f", "message": "Refactor withinRange() logic", "committedDate": "2020-10-28T13:58:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjExMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513632112", "bodyText": "Why we are returning NULLs inTypesFactory.getTypeDescriptor(node.type) ? shouldn't it return an optional type-desc ?", "author": "rasika", "createdAt": "2020-10-28T17:29:05Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/BallerinaSemanticModel.java", "diffHunk": "@@ -131,6 +133,22 @@ public BallerinaSemanticModel(BLangPackage bLangPackage, CompilerContext context\n         return compiledSymbols;\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Optional<BallerinaTypeDescriptor> getType(String fileName, LineRange range) {\n+        BLangCompilationUnit compilationUnit = getCompilationUnit(fileName);\n+        NodeFinder nodeFinder = new NodeFinder();\n+        BLangNode node = nodeFinder.lookup(compilationUnit, range);\n+\n+        if (node == null) {\n+            return Optional.empty();\n+        }\n+\n+        return Optional.ofNullable(TypesFactory.getTypeDescriptor(node.type));", "originalCommit": "9f520ad9aadc158381271986e639445e7d28598f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1NjYzMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513656633", "bodyText": "We have kept the factories to return the relevant instance or null. Returning an Optional value straight from the factory may not be desirable for some of the uses of it. e.g., populating a list of types (in the union for instance). If we return Optional from the factory, then the list would be a null allowing list: List<Optional<BallerinaTypeDescriptor>>", "author": "pubudu91", "createdAt": "2020-10-28T18:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyNjgyMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513926822", "bodyText": "When populating a list of types still we call TypesFactory.getTypeDescriptor() per each type right? I am not sure how usage of null avoid a null allowing list. Idea of using Optional<T> for a function-return is to explicitly notify that the value can be present or not. Otherwise, API user deliberately need to go and check the function implementation. Since this is a public API I still believe Optional<BallerinaTypeDescriptor> is the way to go. WDYT @nadeeshaan @SupunS  ?", "author": "rasika", "createdAt": "2020-10-29T03:42:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkzOTYzNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26607#discussion_r513939634", "bodyText": "I think, what @rasika says is valid if we are exposing this particular API to the public. IIRC we had to expose it to public due to the project API limitation. I would say, as long as we hide it as a public API, this is ok. WDYT @rasika , @pubudu91?", "author": "nadeeshaan", "createdAt": "2020-10-29T03:59:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjExMg=="}], "type": "inlineReview"}]}