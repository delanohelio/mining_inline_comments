{"pr_number": 25351, "pr_title": "Add back writing instructions to BIR binary", "pr_createdAt": "2020-08-20T08:24:50Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351", "timeline": [{"oid": "b157441134c1e0919823628aa744e49703c667e9", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b157441134c1e0919823628aa744e49703c667e9", "message": "Revert \"Merge pull request #22622 from Kishanthan/fix-22513\"\n\nThis reverts commit 0df85689656bca782d23589b60865c648bbc0f40, reversing\nchanges made to 1e4650ad7763559229716110d66bf541d4adf66e.", "committedDate": "2020-08-20T08:21:12Z", "type": "commit"}, {"oid": "998d383ae33545b1f20a25a231a53be8caad684a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/998d383ae33545b1f20a25a231a53be8caad684a", "message": "Add NewTable write instruction logic", "committedDate": "2020-08-20T08:21:23Z", "type": "commit"}, {"oid": "13e44a8ac324a62d50331ecbab6b761f7d710640", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/13e44a8ac324a62d50331ecbab6b761f7d710640", "message": "Remove commented out code", "committedDate": "2020-08-20T08:22:29Z", "type": "commit"}, {"oid": "fe80e9a74ef67bdebf445f608adeb67f34871944", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe80e9a74ef67bdebf445f608adeb67f34871944", "message": "Bump bir version to 53", "committedDate": "2020-08-20T08:44:55Z", "type": "commit"}, {"oid": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6fc3de447ec3361b9ab93c473a6610544ffe80f8", "message": "Merge master branch", "committedDate": "2020-08-25T07:33:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMjMyNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476312326", "bodyText": "Shall we remove Todo and commented out code", "author": "riyafa", "createdAt": "2020-08-25T09:30:57Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -178,10 +184,14 @@ private BPackageSymbol definePackage(PackageID packageId, RepoHierarchy packageR\n             BPackageSymbol pkgSymbol = definePackage(dataInStream);\n             this.env = prevEnv;\n             return pkgSymbol;\n-        } catch (Throwable e) {\n+        } catch (IOException e) {\n             // TODO dlog.error();\n+            throw new BLangCompilerException(e.getMessage(), e);\n+            //            return null;", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMjc2Mg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476312762", "bodyText": "Same here shall we remove Todo and commented out code?", "author": "riyafa", "createdAt": "2020-08-25T09:31:41Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -178,10 +184,14 @@ private BPackageSymbol definePackage(PackageID packageId, RepoHierarchy packageR\n             BPackageSymbol pkgSymbol = definePackage(dataInStream);\n             this.env = prevEnv;\n             return pkgSymbol;\n-        } catch (Throwable e) {\n+        } catch (IOException e) {\n             // TODO dlog.error();\n+            throw new BLangCompilerException(e.getMessage(), e);\n+            //            return null;\n+        } catch (Throwable e) {\n             // TODO format error\n             throw new BLangCompilerException(e.getMessage(), e);\n+            //            return null;", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMzUyMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476313523", "bodyText": "Shall we create an issue to track the Todo also indicating what could be a possible better way so that it can be fixed in the future?", "author": "riyafa", "createdAt": "2020-08-25T09:32:56Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -378,10 +402,22 @@ private void defineFunction(DataInputStream dataInStream) throws IOException {\n \n         defineMarkDownDocAttachment(invokableSymbol, readDocBytes(dataInStream));\n \n+        dataInStream.skip(dataInStream.readLong()); // read and skip method body\n+\n         scopeToDefine.define(invokableSymbol.name, invokableSymbol);\n     }\n \n+    private void skipPosition(DataInputStream dataInStream) throws IOException {\n+        // TODO find a better way to skip this", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxMzg4OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476313889", "bodyText": "can't we use a for loop to readInt 5 times instead of repeating code?", "author": "riyafa", "createdAt": "2020-08-25T09:33:32Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -378,10 +402,22 @@ private void defineFunction(DataInputStream dataInStream) throws IOException {\n \n         defineMarkDownDocAttachment(invokableSymbol, readDocBytes(dataInStream));\n \n+        dataInStream.skip(dataInStream.readLong()); // read and skip method body\n+\n         scopeToDefine.define(invokableSymbol.name, invokableSymbol);\n     }\n \n+    private void skipPosition(DataInputStream dataInStream) throws IOException {\n+        // TODO find a better way to skip this\n+        dataInStream.readInt();\n+        dataInStream.readInt();\n+        dataInStream.readInt();\n+        dataInStream.readInt();\n+        dataInStream.readInt();", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNDY3OQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476314679", "bodyText": "If this constant is to be used outside of this class wouldn't it be better to move it to a relevant Contants class instead of making in public?", "author": "riyafa", "createdAt": "2020-08-25T09:34:45Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -849,18 +889,18 @@ private PackageID createPackageID(String orgName, String pkgName, String pkgVers\n     }\n \n     private class BIRTypeReader {\n-        static final int SERVICE_TYPE_TAG = 51;\n+        public static final int SERVICE_TYPE_TAG = 51;", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNjM1OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476316358", "bodyText": "we can combine this with the above line", "author": "riyafa", "createdAt": "2020-08-25T09:37:21Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRBinaryWriter.java", "diffHunk": "@@ -324,4 +426,59 @@ private int addByteCPEntry(int value) {\n     private void writeType(ByteBuf buf, BType type) {\n         buf.writeInt(cp.addShapeCPEntry(type));\n     }\n+\n+    void writeAnnotAttachments(ByteBuf buff,\n+                                       BIRInstructionWriter insWriter,", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNzI5MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476317291", "bodyText": "shall we create an issue to track the todo indicating how to properly use the operand here?", "author": "riyafa", "createdAt": "2020-08-25T09:39:02Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxNzc3NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476317775", "bodyText": "Shall we create an issue about why it should return an integer to make sure it is fixed?", "author": "riyafa", "createdAt": "2020-08-25T09:39:51Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here\n+        addCpAndWriteString(lock.localVar.variableDcl.name.value);\n+        addCpAndWriteString(lock.field);\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Unlock unlock) {\n+        writePosition(unlock.pos);\n+        buf.writeByte(unlock.kind.getValue());\n+        addCpAndWriteString(unlock.unlockBB.id.value);\n+    }\n+\n+\n+    public void visit(BIRTerminator.Return birReturn) {\n+        writePosition(birReturn.pos);\n+        buf.writeByte(birReturn.kind.getValue());\n+    }\n+\n+    public void visit(BIRTerminator.Branch birBranch) {\n+        writePosition(birBranch.pos);\n+        buf.writeByte(birBranch.kind.getValue());\n+        birBranch.op.accept(this);\n+        // true:BB\n+        addCpAndWriteString(birBranch.trueBB.id.value);\n+        // false:BB\n+        addCpAndWriteString(birBranch.falseBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Wait waitEntry) {\n+        writePosition(waitEntry.pos);\n+        buf.writeByte(waitEntry.kind.getValue());\n+        buf.writeInt(waitEntry.exprList.size());\n+        for (BIROperand expr : waitEntry.exprList) {\n+            expr.accept(this);\n+        }\n+        waitEntry.lhsOp.accept(this);\n+        addCpAndWriteString(waitEntry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Flush entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte(entry.kind.getValue());\n+        buf.writeInt(entry.channels.length);\n+        for (BIRNode.ChannelDetails detail : entry.channels) {\n+            addCpAndWriteString(detail.name);\n+            buf.writeBoolean(detail.channelInSameStrand);\n+            buf.writeBoolean(detail.send);\n+        }\n+        entry.lhsOp.accept(this);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerReceive entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.workerName.getValue()));\n+        entry.lhsOp.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerSend entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.channel.getValue()));\n+        entry.data.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        buf.writeBoolean(entry.isSync);\n+        if (entry.isSync) {\n+            entry.lhsOp.accept(this);\n+        }\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WaitAll waitAll) {\n+        writePosition(waitAll.pos);\n+        buf.writeByte((waitAll.kind.getValue()));\n+        waitAll.lhsOp.accept(this);\n+        buf.writeInt(waitAll.keys.size());\n+        waitAll.keys.forEach(key -> buf.writeInt(addStringCPEntry(key)));\n+        waitAll.valueExprs.forEach(val -> val.accept(this));\n+        addCpAndWriteString(waitAll.thenBB.id.value);\n+    }\n+\n+    // Non-terminating instructions\n+\n+    @Override\n+    public void visit(BIRNonTerminator.NewTable newTable) {\n+        writePosition(newTable.pos);\n+        writeType(newTable.type);\n+        newTable.lhsOp.accept(this);\n+        newTable.keyColOp.accept(this);\n+        newTable.dataOp.accept(this);\n+    }\n+\n+\n+    public void visit(BIRNonTerminator.Move birMove) {\n+        writePosition(birMove.pos);\n+        buf.writeByte(birMove.kind.getValue());\n+        birMove.rhsOp.accept(this);\n+        birMove.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRTerminator.Call birCall) {\n+        writePosition(birCall.pos);\n+        buf.writeByte(birCall.kind.getValue());\n+        PackageID calleePkg = birCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birCall.name.getValue()));\n+        buf.writeInt(birCall.args.size());\n+        for (BIROperand arg : birCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        addCpAndWriteString(birCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.AsyncCall birAsyncCall) {\n+        writePosition(birAsyncCall.pos);\n+        buf.writeByte(birAsyncCall.kind.getValue());\n+        PackageID calleePkg = birAsyncCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birAsyncCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birAsyncCall.name.getValue()));\n+        buf.writeInt(birAsyncCall.args.size());\n+        for (BIROperand arg : birAsyncCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birAsyncCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birAsyncCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+\n+        binaryWriter.writeAnnotAttachments(buf, this, birAsyncCall.annotAttachments);\n+        addCpAndWriteString(birAsyncCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FPCall fpCall) {\n+        writePosition(fpCall.pos);\n+        buf.writeByte(fpCall.kind.getValue());\n+        fpCall.fp.accept(this);\n+        buf.writeInt(fpCall.args.size());\n+        for (BIROperand arg : fpCall.args) {\n+            arg.accept(this);\n+        }\n+        if (fpCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            fpCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        buf.writeBoolean(fpCall.isAsync);\n+        addCpAndWriteString(fpCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRNonTerminator.BinaryOp birBinaryOp) {\n+        writePosition(birBinaryOp.pos);\n+        buf.writeByte(birBinaryOp.kind.getValue());\n+        birBinaryOp.rhsOp1.accept(this);\n+        birBinaryOp.rhsOp2.accept(this);\n+        birBinaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.UnaryOP birUnaryOp) {\n+        writePosition(birUnaryOp.pos);\n+        buf.writeByte(birUnaryOp.kind.getValue());\n+        birUnaryOp.rhsOp.accept(this);\n+        birUnaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.ConstantLoad birConstantLoad) {\n+        writePosition(birConstantLoad.pos);\n+        buf.writeByte(birConstantLoad.kind.getValue());\n+        writeType(birConstantLoad.type);\n+        birConstantLoad.lhsOp.accept(this);\n+\n+        BType type = birConstantLoad.type;\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.SIGNED32_INT:\n+            case TypeTags.SIGNED16_INT:\n+            case TypeTags.SIGNED8_INT:\n+            case TypeTags.UNSIGNED32_INT:\n+            case TypeTags.UNSIGNED16_INT:\n+            case TypeTags.UNSIGNED8_INT:\n+                buf.writeInt(cp.addCPEntry(new IntegerCPEntry((Long) birConstantLoad.value)));\n+                break;\n+            case TypeTags.BYTE:\n+                // TODO: birConstantLoad.value should return an Integer. This is a temporary fix", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxODIxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476318217", "bodyText": "Shall we track via an issue?", "author": "riyafa", "createdAt": "2020-08-25T09:40:30Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here\n+        addCpAndWriteString(lock.localVar.variableDcl.name.value);\n+        addCpAndWriteString(lock.field);\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Unlock unlock) {\n+        writePosition(unlock.pos);\n+        buf.writeByte(unlock.kind.getValue());\n+        addCpAndWriteString(unlock.unlockBB.id.value);\n+    }\n+\n+\n+    public void visit(BIRTerminator.Return birReturn) {\n+        writePosition(birReturn.pos);\n+        buf.writeByte(birReturn.kind.getValue());\n+    }\n+\n+    public void visit(BIRTerminator.Branch birBranch) {\n+        writePosition(birBranch.pos);\n+        buf.writeByte(birBranch.kind.getValue());\n+        birBranch.op.accept(this);\n+        // true:BB\n+        addCpAndWriteString(birBranch.trueBB.id.value);\n+        // false:BB\n+        addCpAndWriteString(birBranch.falseBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Wait waitEntry) {\n+        writePosition(waitEntry.pos);\n+        buf.writeByte(waitEntry.kind.getValue());\n+        buf.writeInt(waitEntry.exprList.size());\n+        for (BIROperand expr : waitEntry.exprList) {\n+            expr.accept(this);\n+        }\n+        waitEntry.lhsOp.accept(this);\n+        addCpAndWriteString(waitEntry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Flush entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte(entry.kind.getValue());\n+        buf.writeInt(entry.channels.length);\n+        for (BIRNode.ChannelDetails detail : entry.channels) {\n+            addCpAndWriteString(detail.name);\n+            buf.writeBoolean(detail.channelInSameStrand);\n+            buf.writeBoolean(detail.send);\n+        }\n+        entry.lhsOp.accept(this);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerReceive entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.workerName.getValue()));\n+        entry.lhsOp.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerSend entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.channel.getValue()));\n+        entry.data.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        buf.writeBoolean(entry.isSync);\n+        if (entry.isSync) {\n+            entry.lhsOp.accept(this);\n+        }\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WaitAll waitAll) {\n+        writePosition(waitAll.pos);\n+        buf.writeByte((waitAll.kind.getValue()));\n+        waitAll.lhsOp.accept(this);\n+        buf.writeInt(waitAll.keys.size());\n+        waitAll.keys.forEach(key -> buf.writeInt(addStringCPEntry(key)));\n+        waitAll.valueExprs.forEach(val -> val.accept(this));\n+        addCpAndWriteString(waitAll.thenBB.id.value);\n+    }\n+\n+    // Non-terminating instructions\n+\n+    @Override\n+    public void visit(BIRNonTerminator.NewTable newTable) {\n+        writePosition(newTable.pos);\n+        writeType(newTable.type);\n+        newTable.lhsOp.accept(this);\n+        newTable.keyColOp.accept(this);\n+        newTable.dataOp.accept(this);\n+    }\n+\n+\n+    public void visit(BIRNonTerminator.Move birMove) {\n+        writePosition(birMove.pos);\n+        buf.writeByte(birMove.kind.getValue());\n+        birMove.rhsOp.accept(this);\n+        birMove.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRTerminator.Call birCall) {\n+        writePosition(birCall.pos);\n+        buf.writeByte(birCall.kind.getValue());\n+        PackageID calleePkg = birCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birCall.name.getValue()));\n+        buf.writeInt(birCall.args.size());\n+        for (BIROperand arg : birCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        addCpAndWriteString(birCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.AsyncCall birAsyncCall) {\n+        writePosition(birAsyncCall.pos);\n+        buf.writeByte(birAsyncCall.kind.getValue());\n+        PackageID calleePkg = birAsyncCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birAsyncCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birAsyncCall.name.getValue()));\n+        buf.writeInt(birAsyncCall.args.size());\n+        for (BIROperand arg : birAsyncCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birAsyncCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birAsyncCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+\n+        binaryWriter.writeAnnotAttachments(buf, this, birAsyncCall.annotAttachments);\n+        addCpAndWriteString(birAsyncCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FPCall fpCall) {\n+        writePosition(fpCall.pos);\n+        buf.writeByte(fpCall.kind.getValue());\n+        fpCall.fp.accept(this);\n+        buf.writeInt(fpCall.args.size());\n+        for (BIROperand arg : fpCall.args) {\n+            arg.accept(this);\n+        }\n+        if (fpCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            fpCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        buf.writeBoolean(fpCall.isAsync);\n+        addCpAndWriteString(fpCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRNonTerminator.BinaryOp birBinaryOp) {\n+        writePosition(birBinaryOp.pos);\n+        buf.writeByte(birBinaryOp.kind.getValue());\n+        birBinaryOp.rhsOp1.accept(this);\n+        birBinaryOp.rhsOp2.accept(this);\n+        birBinaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.UnaryOP birUnaryOp) {\n+        writePosition(birUnaryOp.pos);\n+        buf.writeByte(birUnaryOp.kind.getValue());\n+        birUnaryOp.rhsOp.accept(this);\n+        birUnaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.ConstantLoad birConstantLoad) {\n+        writePosition(birConstantLoad.pos);\n+        buf.writeByte(birConstantLoad.kind.getValue());\n+        writeType(birConstantLoad.type);\n+        birConstantLoad.lhsOp.accept(this);\n+\n+        BType type = birConstantLoad.type;\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.SIGNED32_INT:\n+            case TypeTags.SIGNED16_INT:\n+            case TypeTags.SIGNED8_INT:\n+            case TypeTags.UNSIGNED32_INT:\n+            case TypeTags.UNSIGNED16_INT:\n+            case TypeTags.UNSIGNED8_INT:\n+                buf.writeInt(cp.addCPEntry(new IntegerCPEntry((Long) birConstantLoad.value)));\n+                break;\n+            case TypeTags.BYTE:\n+                // TODO: birConstantLoad.value should return an Integer. This is a temporary fix\n+                int byteValue = ((Number) birConstantLoad.value).intValue();\n+                buf.writeInt(cp.addCPEntry(new ByteCPEntry(byteValue)));\n+                break;\n+            case TypeTags.BOOLEAN:\n+                // Not adding to constant pool as it increases the size (bit vs integer)\n+                buf.writeBoolean((Boolean) birConstantLoad.value);\n+                break;\n+            case TypeTags.STRING:\n+            case TypeTags.CHAR_STRING:\n+            case TypeTags.DECIMAL:\n+                buf.writeInt(cp.addCPEntry(new StringCPEntry(birConstantLoad.value.toString())));\n+                break;\n+            case TypeTags.FLOAT:\n+                double value = birConstantLoad.value instanceof Double ? (double) birConstantLoad.value\n+                        : Double.parseDouble((String) birConstantLoad.value);\n+                buf.writeInt(cp.addCPEntry(new FloatCPEntry(value)));\n+                break;\n+            case TypeTags.NIL:\n+                break;\n+            default:\n+                throw new IllegalStateException(\"unsupported constant type: \" + type);\n+        }\n+    }\n+\n+    public void visit(NewStructure birNewStructure) {\n+        writePosition(birNewStructure.pos);\n+        buf.writeByte(birNewStructure.kind.getValue());\n+        birNewStructure.rhsOp.accept(this);\n+        birNewStructure.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.NewInstance newInstance) {\n+        writePosition(newInstance.pos);\n+        buf.writeByte(newInstance.kind.getValue());\n+        buf.writeBoolean(newInstance.isExternalDef);\n+        if (newInstance.isExternalDef) {\n+            assert newInstance.externalPackageId != null;\n+            buf.writeInt(addPkgCPEntry(newInstance.externalPackageId));\n+            buf.writeInt(addStringCPEntry(newInstance.objectName));\n+        } else {\n+            buf.writeInt(newInstance.def.index);\n+        }\n+        newInstance.lhsOp.accept(this);\n+    }\n+\n+    public void visit(NewArray birNewArray) {\n+        writePosition(birNewArray.pos);\n+        buf.writeByte(birNewArray.kind.getValue());\n+        writeType(birNewArray.type);\n+        birNewArray.lhsOp.accept(this);\n+        birNewArray.sizeOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.FieldAccess birFieldAccess) {\n+        writePosition(birFieldAccess.pos);\n+        buf.writeByte(birFieldAccess.kind.getValue());\n+        if (birFieldAccess.kind == InstructionKind.MAP_LOAD || birFieldAccess.kind == InstructionKind.ARRAY_LOAD) {\n+            buf.writeBoolean(birFieldAccess.optionalFieldAccess);\n+            buf.writeBoolean(birFieldAccess.fillingRead);\n+        }\n+        birFieldAccess.lhsOp.accept(this);\n+        birFieldAccess.keyOp.accept(this);\n+        birFieldAccess.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeCast birTypeCast) {\n+        writePosition(birTypeCast.pos);\n+        buf.writeByte(birTypeCast.kind.getValue());\n+        birTypeCast.lhsOp.accept(this);\n+        birTypeCast.rhsOp.accept(this);\n+        writeType(birTypeCast.type);\n+        buf.writeBoolean(birTypeCast.checkTypes);\n+    }\n+\n+    public void visit(BIRNonTerminator.IsLike birIsLike) {\n+        writePosition(birIsLike.pos);\n+        buf.writeByte(birIsLike.kind.getValue());\n+        writeType(birIsLike.type);\n+        birIsLike.lhsOp.accept(this);\n+        birIsLike.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeTest birTypeTest) {\n+        writePosition(birTypeTest.pos);\n+        buf.writeByte(birTypeTest.kind.getValue());\n+        writeType(birTypeTest.type);\n+        birTypeTest.lhsOp.accept(this);\n+        birTypeTest.rhsOp.accept(this);\n+    }\n+\n+    // Operands\n+    public void visit(BIROperand birOperand) {\n+        if (birOperand.variableDcl.ignoreVariable) {\n+            buf.writeBoolean(true);\n+            writeType(birOperand.variableDcl.type);\n+            return;\n+        }\n+\n+        buf.writeBoolean(false);\n+        buf.writeByte(birOperand.variableDcl.kind.getValue());\n+        buf.writeByte(birOperand.variableDcl.scope.getValue());\n+\n+        // TODO use the integer index of the variable.\n+        addCpAndWriteString(birOperand.variableDcl.name.value);\n+\n+        if (birOperand.variableDcl.kind == VarKind.GLOBAL || birOperand.variableDcl.kind == VarKind.CONSTANT) {\n+            int pkgIndex = addPkgCPEntry(((BIRGlobalVariableDcl) birOperand.variableDcl).pkgId);\n+            buf.writeInt(pkgIndex);\n+\n+            writeType(birOperand.variableDcl.type);\n+        }\n+    }\n+\n+    public void visit(BIRNonTerminator.NewError birNewError) {\n+        writePosition(birNewError.pos);\n+        buf.writeByte(birNewError.kind.getValue());\n+        writeType(birNewError.type);\n+        birNewError.lhsOp.accept(this);\n+        birNewError.messageOp.accept(this);\n+        birNewError.causeOp.accept(this);\n+        birNewError.detailOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.FPLoad fpLoad) {\n+        writePosition(fpLoad.pos);\n+        buf.writeByte(fpLoad.kind.getValue());\n+        fpLoad.lhsOp.accept(this);\n+\n+        PackageID pkgId = fpLoad.pkgId;\n+        int pkgIndex = addPkgCPEntry(pkgId);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(fpLoad.funcName.getValue()));\n+        writeType(fpLoad.retType);\n+\n+        buf.writeInt(fpLoad.closureMaps.size());\n+        for (BIROperand op : fpLoad.closureMaps) {\n+            op.accept(this);\n+        }\n+\n+        buf.writeInt(fpLoad.params.size());\n+        fpLoad.params.forEach(param -> {\n+            buf.writeByte(param.kind.getValue());\n+            writeType(param.type);\n+            buf.writeInt(addStringCPEntry(param.name.value));\n+        });\n+\n+    }\n+\n+    public void visit(BIRTerminator.Panic birPanic) {\n+        writePosition(birPanic.pos);\n+        buf.writeByte(birPanic.kind.getValue());\n+        birPanic.errorOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLElement newXMLElement) {\n+        writePosition(newXMLElement.pos);\n+        buf.writeByte(newXMLElement.kind.getValue());\n+        newXMLElement.lhsOp.accept(this);\n+        newXMLElement.startTagOp.accept(this);\n+        newXMLElement.defaultNsURIOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLText newXMLText) {\n+        writePosition(newXMLText.pos);\n+        buf.writeByte(newXMLText.kind.getValue());\n+        newXMLText.lhsOp.accept(this);\n+        newXMLText.textOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLQName newXMLQName) {\n+        writePosition(newXMLQName.pos);\n+        buf.writeByte(newXMLQName.kind.getValue());\n+        newXMLQName.lhsOp.accept(this);\n+        newXMLQName.localnameOp.accept(this);\n+        newXMLQName.nsURIOp.accept(this);\n+        newXMLQName.prefixOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewStringXMLQName newStringXMLQName) {\n+        writePosition(newStringXMLQName.pos);\n+        buf.writeByte(newStringXMLQName.kind.getValue());\n+        newStringXMLQName.lhsOp.accept(this);\n+        newStringXMLQName.stringQNameOP.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(XMLAccess xmlAccess) {\n+        writePosition(xmlAccess.pos);\n+        buf.writeByte(xmlAccess.kind.getValue());\n+        xmlAccess.lhsOp.accept(this);\n+        xmlAccess.rhsOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLComment newXMLComment) {\n+        writePosition(newXMLComment.pos);\n+        buf.writeByte(newXMLComment.kind.getValue());\n+        newXMLComment.lhsOp.accept(this);\n+        newXMLComment.textOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLProcIns newXMLProcIns) {\n+        writePosition(newXMLProcIns.pos);\n+        buf.writeByte(newXMLProcIns.kind.getValue());\n+        newXMLProcIns.lhsOp.accept(this);\n+        newXMLProcIns.dataOp.accept(this);\n+        newXMLProcIns.targetOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewTypeDesc newTypeDesc) {\n+        writePosition(newTypeDesc.pos);\n+        buf.writeByte(newTypeDesc.kind.getValue());\n+        newTypeDesc.lhsOp.accept(this);\n+        writeType(newTypeDesc.type);\n+    }\n+\n+    // Positions\n+    // TODO Refactor duplicate methods", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxODQ4NQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476318485", "bodyText": "I think we can remove this comment", "author": "riyafa", "createdAt": "2020-08-25T09:40:53Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here\n+        addCpAndWriteString(lock.localVar.variableDcl.name.value);\n+        addCpAndWriteString(lock.field);\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Unlock unlock) {\n+        writePosition(unlock.pos);\n+        buf.writeByte(unlock.kind.getValue());\n+        addCpAndWriteString(unlock.unlockBB.id.value);\n+    }\n+\n+\n+    public void visit(BIRTerminator.Return birReturn) {\n+        writePosition(birReturn.pos);\n+        buf.writeByte(birReturn.kind.getValue());\n+    }\n+\n+    public void visit(BIRTerminator.Branch birBranch) {\n+        writePosition(birBranch.pos);\n+        buf.writeByte(birBranch.kind.getValue());\n+        birBranch.op.accept(this);\n+        // true:BB\n+        addCpAndWriteString(birBranch.trueBB.id.value);\n+        // false:BB\n+        addCpAndWriteString(birBranch.falseBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Wait waitEntry) {\n+        writePosition(waitEntry.pos);\n+        buf.writeByte(waitEntry.kind.getValue());\n+        buf.writeInt(waitEntry.exprList.size());\n+        for (BIROperand expr : waitEntry.exprList) {\n+            expr.accept(this);\n+        }\n+        waitEntry.lhsOp.accept(this);\n+        addCpAndWriteString(waitEntry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Flush entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte(entry.kind.getValue());\n+        buf.writeInt(entry.channels.length);\n+        for (BIRNode.ChannelDetails detail : entry.channels) {\n+            addCpAndWriteString(detail.name);\n+            buf.writeBoolean(detail.channelInSameStrand);\n+            buf.writeBoolean(detail.send);\n+        }\n+        entry.lhsOp.accept(this);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerReceive entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.workerName.getValue()));\n+        entry.lhsOp.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerSend entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.channel.getValue()));\n+        entry.data.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        buf.writeBoolean(entry.isSync);\n+        if (entry.isSync) {\n+            entry.lhsOp.accept(this);\n+        }\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WaitAll waitAll) {\n+        writePosition(waitAll.pos);\n+        buf.writeByte((waitAll.kind.getValue()));\n+        waitAll.lhsOp.accept(this);\n+        buf.writeInt(waitAll.keys.size());\n+        waitAll.keys.forEach(key -> buf.writeInt(addStringCPEntry(key)));\n+        waitAll.valueExprs.forEach(val -> val.accept(this));\n+        addCpAndWriteString(waitAll.thenBB.id.value);\n+    }\n+\n+    // Non-terminating instructions\n+\n+    @Override\n+    public void visit(BIRNonTerminator.NewTable newTable) {\n+        writePosition(newTable.pos);\n+        writeType(newTable.type);\n+        newTable.lhsOp.accept(this);\n+        newTable.keyColOp.accept(this);\n+        newTable.dataOp.accept(this);\n+    }\n+\n+\n+    public void visit(BIRNonTerminator.Move birMove) {\n+        writePosition(birMove.pos);\n+        buf.writeByte(birMove.kind.getValue());\n+        birMove.rhsOp.accept(this);\n+        birMove.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRTerminator.Call birCall) {\n+        writePosition(birCall.pos);\n+        buf.writeByte(birCall.kind.getValue());\n+        PackageID calleePkg = birCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birCall.name.getValue()));\n+        buf.writeInt(birCall.args.size());\n+        for (BIROperand arg : birCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        addCpAndWriteString(birCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.AsyncCall birAsyncCall) {\n+        writePosition(birAsyncCall.pos);\n+        buf.writeByte(birAsyncCall.kind.getValue());\n+        PackageID calleePkg = birAsyncCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birAsyncCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birAsyncCall.name.getValue()));\n+        buf.writeInt(birAsyncCall.args.size());\n+        for (BIROperand arg : birAsyncCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birAsyncCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birAsyncCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+\n+        binaryWriter.writeAnnotAttachments(buf, this, birAsyncCall.annotAttachments);\n+        addCpAndWriteString(birAsyncCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FPCall fpCall) {\n+        writePosition(fpCall.pos);\n+        buf.writeByte(fpCall.kind.getValue());\n+        fpCall.fp.accept(this);\n+        buf.writeInt(fpCall.args.size());\n+        for (BIROperand arg : fpCall.args) {\n+            arg.accept(this);\n+        }\n+        if (fpCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            fpCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        buf.writeBoolean(fpCall.isAsync);\n+        addCpAndWriteString(fpCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRNonTerminator.BinaryOp birBinaryOp) {\n+        writePosition(birBinaryOp.pos);\n+        buf.writeByte(birBinaryOp.kind.getValue());\n+        birBinaryOp.rhsOp1.accept(this);\n+        birBinaryOp.rhsOp2.accept(this);\n+        birBinaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.UnaryOP birUnaryOp) {\n+        writePosition(birUnaryOp.pos);\n+        buf.writeByte(birUnaryOp.kind.getValue());\n+        birUnaryOp.rhsOp.accept(this);\n+        birUnaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.ConstantLoad birConstantLoad) {\n+        writePosition(birConstantLoad.pos);\n+        buf.writeByte(birConstantLoad.kind.getValue());\n+        writeType(birConstantLoad.type);\n+        birConstantLoad.lhsOp.accept(this);\n+\n+        BType type = birConstantLoad.type;\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.SIGNED32_INT:\n+            case TypeTags.SIGNED16_INT:\n+            case TypeTags.SIGNED8_INT:\n+            case TypeTags.UNSIGNED32_INT:\n+            case TypeTags.UNSIGNED16_INT:\n+            case TypeTags.UNSIGNED8_INT:\n+                buf.writeInt(cp.addCPEntry(new IntegerCPEntry((Long) birConstantLoad.value)));\n+                break;\n+            case TypeTags.BYTE:\n+                // TODO: birConstantLoad.value should return an Integer. This is a temporary fix\n+                int byteValue = ((Number) birConstantLoad.value).intValue();\n+                buf.writeInt(cp.addCPEntry(new ByteCPEntry(byteValue)));\n+                break;\n+            case TypeTags.BOOLEAN:\n+                // Not adding to constant pool as it increases the size (bit vs integer)\n+                buf.writeBoolean((Boolean) birConstantLoad.value);\n+                break;\n+            case TypeTags.STRING:\n+            case TypeTags.CHAR_STRING:\n+            case TypeTags.DECIMAL:\n+                buf.writeInt(cp.addCPEntry(new StringCPEntry(birConstantLoad.value.toString())));\n+                break;\n+            case TypeTags.FLOAT:\n+                double value = birConstantLoad.value instanceof Double ? (double) birConstantLoad.value\n+                        : Double.parseDouble((String) birConstantLoad.value);\n+                buf.writeInt(cp.addCPEntry(new FloatCPEntry(value)));\n+                break;\n+            case TypeTags.NIL:\n+                break;\n+            default:\n+                throw new IllegalStateException(\"unsupported constant type: \" + type);\n+        }\n+    }\n+\n+    public void visit(NewStructure birNewStructure) {\n+        writePosition(birNewStructure.pos);\n+        buf.writeByte(birNewStructure.kind.getValue());\n+        birNewStructure.rhsOp.accept(this);\n+        birNewStructure.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.NewInstance newInstance) {\n+        writePosition(newInstance.pos);\n+        buf.writeByte(newInstance.kind.getValue());\n+        buf.writeBoolean(newInstance.isExternalDef);\n+        if (newInstance.isExternalDef) {\n+            assert newInstance.externalPackageId != null;\n+            buf.writeInt(addPkgCPEntry(newInstance.externalPackageId));\n+            buf.writeInt(addStringCPEntry(newInstance.objectName));\n+        } else {\n+            buf.writeInt(newInstance.def.index);\n+        }\n+        newInstance.lhsOp.accept(this);\n+    }\n+\n+    public void visit(NewArray birNewArray) {\n+        writePosition(birNewArray.pos);\n+        buf.writeByte(birNewArray.kind.getValue());\n+        writeType(birNewArray.type);\n+        birNewArray.lhsOp.accept(this);\n+        birNewArray.sizeOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.FieldAccess birFieldAccess) {\n+        writePosition(birFieldAccess.pos);\n+        buf.writeByte(birFieldAccess.kind.getValue());\n+        if (birFieldAccess.kind == InstructionKind.MAP_LOAD || birFieldAccess.kind == InstructionKind.ARRAY_LOAD) {\n+            buf.writeBoolean(birFieldAccess.optionalFieldAccess);\n+            buf.writeBoolean(birFieldAccess.fillingRead);\n+        }\n+        birFieldAccess.lhsOp.accept(this);\n+        birFieldAccess.keyOp.accept(this);\n+        birFieldAccess.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeCast birTypeCast) {\n+        writePosition(birTypeCast.pos);\n+        buf.writeByte(birTypeCast.kind.getValue());\n+        birTypeCast.lhsOp.accept(this);\n+        birTypeCast.rhsOp.accept(this);\n+        writeType(birTypeCast.type);\n+        buf.writeBoolean(birTypeCast.checkTypes);\n+    }\n+\n+    public void visit(BIRNonTerminator.IsLike birIsLike) {\n+        writePosition(birIsLike.pos);\n+        buf.writeByte(birIsLike.kind.getValue());\n+        writeType(birIsLike.type);\n+        birIsLike.lhsOp.accept(this);\n+        birIsLike.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeTest birTypeTest) {\n+        writePosition(birTypeTest.pos);\n+        buf.writeByte(birTypeTest.kind.getValue());\n+        writeType(birTypeTest.type);\n+        birTypeTest.lhsOp.accept(this);\n+        birTypeTest.rhsOp.accept(this);\n+    }\n+\n+    // Operands\n+    public void visit(BIROperand birOperand) {\n+        if (birOperand.variableDcl.ignoreVariable) {\n+            buf.writeBoolean(true);\n+            writeType(birOperand.variableDcl.type);\n+            return;\n+        }\n+\n+        buf.writeBoolean(false);\n+        buf.writeByte(birOperand.variableDcl.kind.getValue());\n+        buf.writeByte(birOperand.variableDcl.scope.getValue());\n+\n+        // TODO use the integer index of the variable.\n+        addCpAndWriteString(birOperand.variableDcl.name.value);\n+\n+        if (birOperand.variableDcl.kind == VarKind.GLOBAL || birOperand.variableDcl.kind == VarKind.CONSTANT) {\n+            int pkgIndex = addPkgCPEntry(((BIRGlobalVariableDcl) birOperand.variableDcl).pkgId);\n+            buf.writeInt(pkgIndex);\n+\n+            writeType(birOperand.variableDcl.type);\n+        }\n+    }\n+\n+    public void visit(BIRNonTerminator.NewError birNewError) {\n+        writePosition(birNewError.pos);\n+        buf.writeByte(birNewError.kind.getValue());\n+        writeType(birNewError.type);\n+        birNewError.lhsOp.accept(this);\n+        birNewError.messageOp.accept(this);\n+        birNewError.causeOp.accept(this);\n+        birNewError.detailOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.FPLoad fpLoad) {\n+        writePosition(fpLoad.pos);\n+        buf.writeByte(fpLoad.kind.getValue());\n+        fpLoad.lhsOp.accept(this);\n+\n+        PackageID pkgId = fpLoad.pkgId;\n+        int pkgIndex = addPkgCPEntry(pkgId);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(fpLoad.funcName.getValue()));\n+        writeType(fpLoad.retType);\n+\n+        buf.writeInt(fpLoad.closureMaps.size());\n+        for (BIROperand op : fpLoad.closureMaps) {\n+            op.accept(this);\n+        }\n+\n+        buf.writeInt(fpLoad.params.size());\n+        fpLoad.params.forEach(param -> {\n+            buf.writeByte(param.kind.getValue());\n+            writeType(param.type);\n+            buf.writeInt(addStringCPEntry(param.name.value));\n+        });\n+\n+    }\n+\n+    public void visit(BIRTerminator.Panic birPanic) {\n+        writePosition(birPanic.pos);\n+        buf.writeByte(birPanic.kind.getValue());\n+        birPanic.errorOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLElement newXMLElement) {\n+        writePosition(newXMLElement.pos);\n+        buf.writeByte(newXMLElement.kind.getValue());\n+        newXMLElement.lhsOp.accept(this);\n+        newXMLElement.startTagOp.accept(this);\n+        newXMLElement.defaultNsURIOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLText newXMLText) {\n+        writePosition(newXMLText.pos);\n+        buf.writeByte(newXMLText.kind.getValue());\n+        newXMLText.lhsOp.accept(this);\n+        newXMLText.textOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLQName newXMLQName) {\n+        writePosition(newXMLQName.pos);\n+        buf.writeByte(newXMLQName.kind.getValue());\n+        newXMLQName.lhsOp.accept(this);\n+        newXMLQName.localnameOp.accept(this);\n+        newXMLQName.nsURIOp.accept(this);\n+        newXMLQName.prefixOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewStringXMLQName newStringXMLQName) {\n+        writePosition(newStringXMLQName.pos);\n+        buf.writeByte(newStringXMLQName.kind.getValue());\n+        newStringXMLQName.lhsOp.accept(this);\n+        newStringXMLQName.stringQNameOP.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(XMLAccess xmlAccess) {\n+        writePosition(xmlAccess.pos);\n+        buf.writeByte(xmlAccess.kind.getValue());\n+        xmlAccess.lhsOp.accept(this);\n+        xmlAccess.rhsOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLComment newXMLComment) {\n+        writePosition(newXMLComment.pos);\n+        buf.writeByte(newXMLComment.kind.getValue());\n+        newXMLComment.lhsOp.accept(this);\n+        newXMLComment.textOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewXMLProcIns newXMLProcIns) {\n+        writePosition(newXMLProcIns.pos);\n+        buf.writeByte(newXMLProcIns.kind.getValue());\n+        newXMLProcIns.lhsOp.accept(this);\n+        newXMLProcIns.dataOp.accept(this);\n+        newXMLProcIns.targetOp.accept(this);\n+    }\n+\n+    @Override\n+    public void visit(NewTypeDesc newTypeDesc) {\n+        writePosition(newTypeDesc.pos);\n+        buf.writeByte(newTypeDesc.kind.getValue());\n+        newTypeDesc.lhsOp.accept(this);\n+        writeType(newTypeDesc.type);\n+    }\n+\n+    // Positions\n+    // TODO Refactor duplicate methods\n+    void writePosition(DiagnosticPos pos) {\n+        int sLine = Integer.MIN_VALUE;\n+        int eLine = Integer.MIN_VALUE;\n+        int sCol = Integer.MIN_VALUE;\n+        int eCol = Integer.MIN_VALUE;\n+        String sourceFileName = \"\";\n+        if (pos != null) {\n+            sLine = pos.sLine;\n+            eLine = pos.eLine;\n+            sCol = pos.sCol;\n+            eCol = pos.eCol;\n+            if (pos.src != null) {\n+                sourceFileName = pos.src.cUnitName;\n+            }\n+        }\n+        buf.writeInt(sLine);\n+        buf.writeInt(eLine);\n+        buf.writeInt(sCol);\n+        buf.writeInt(eCol);\n+        buf.writeInt(addStringCPEntry(sourceFileName));\n+    }\n+\n+    void writePosition(ByteBuf buf, DiagnosticPos pos) {\n+        int sLine = Integer.MIN_VALUE;\n+        int eLine = Integer.MIN_VALUE;\n+        int sCol = Integer.MIN_VALUE;\n+        int eCol = Integer.MIN_VALUE;\n+        String sourceFileName = \"\";\n+        if (pos != null) {\n+            sLine = pos.sLine;\n+            eLine = pos.eLine;\n+            sCol = pos.sCol;\n+            eCol = pos.eCol;\n+            if (pos.src != null) {\n+                sourceFileName = pos.src.cUnitName;\n+            }\n+        }\n+        buf.writeInt(sLine);\n+        buf.writeInt(eLine);\n+        buf.writeInt(sCol);\n+        buf.writeInt(eCol);\n+        buf.writeInt(addStringCPEntry(sourceFileName));\n+    }\n+\n+    int addPkgCPEntry(PackageID packageID) {\n+        int orgCPIndex = addStringCPEntry(packageID.orgName.value);\n+        int nameCPIndex = addStringCPEntry(packageID.name.value);\n+        int versionCPIndex = addStringCPEntry(packageID.version.value);\n+        return cp.addCPEntry(new CPEntry.PackageCPEntry(orgCPIndex, nameCPIndex, versionCPIndex));\n+    }\n+\n+    // private methods", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxODc1Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476318757", "bodyText": "Is this a new class?", "author": "riyafa", "createdAt": "2020-08-25T09:41:18Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIyNzEwMA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r477227100", "bodyText": "This is reverted commit hence licence header should be ok.", "author": "warunalakshitha", "createdAt": "2020-08-26T11:24:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMxODc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyMDQzMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476320432", "bodyText": "Since we have buf.writeByte(1); and buf.writeByte(0); in multiple places wouldn't it be nice to have constants for 1 and 0 indicating what they mean in this context? If that makes sense \ud83d\ude42", "author": "riyafa", "createdAt": "2020-08-25T09:44:04Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here\n+        addCpAndWriteString(lock.localVar.variableDcl.name.value);\n+        addCpAndWriteString(lock.field);\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Unlock unlock) {\n+        writePosition(unlock.pos);\n+        buf.writeByte(unlock.kind.getValue());\n+        addCpAndWriteString(unlock.unlockBB.id.value);\n+    }\n+\n+\n+    public void visit(BIRTerminator.Return birReturn) {\n+        writePosition(birReturn.pos);\n+        buf.writeByte(birReturn.kind.getValue());\n+    }\n+\n+    public void visit(BIRTerminator.Branch birBranch) {\n+        writePosition(birBranch.pos);\n+        buf.writeByte(birBranch.kind.getValue());\n+        birBranch.op.accept(this);\n+        // true:BB\n+        addCpAndWriteString(birBranch.trueBB.id.value);\n+        // false:BB\n+        addCpAndWriteString(birBranch.falseBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Wait waitEntry) {\n+        writePosition(waitEntry.pos);\n+        buf.writeByte(waitEntry.kind.getValue());\n+        buf.writeInt(waitEntry.exprList.size());\n+        for (BIROperand expr : waitEntry.exprList) {\n+            expr.accept(this);\n+        }\n+        waitEntry.lhsOp.accept(this);\n+        addCpAndWriteString(waitEntry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Flush entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte(entry.kind.getValue());\n+        buf.writeInt(entry.channels.length);\n+        for (BIRNode.ChannelDetails detail : entry.channels) {\n+            addCpAndWriteString(detail.name);\n+            buf.writeBoolean(detail.channelInSameStrand);\n+            buf.writeBoolean(detail.send);\n+        }\n+        entry.lhsOp.accept(this);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerReceive entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.workerName.getValue()));\n+        entry.lhsOp.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerSend entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.channel.getValue()));\n+        entry.data.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        buf.writeBoolean(entry.isSync);\n+        if (entry.isSync) {\n+            entry.lhsOp.accept(this);\n+        }\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WaitAll waitAll) {\n+        writePosition(waitAll.pos);\n+        buf.writeByte((waitAll.kind.getValue()));\n+        waitAll.lhsOp.accept(this);\n+        buf.writeInt(waitAll.keys.size());\n+        waitAll.keys.forEach(key -> buf.writeInt(addStringCPEntry(key)));\n+        waitAll.valueExprs.forEach(val -> val.accept(this));\n+        addCpAndWriteString(waitAll.thenBB.id.value);\n+    }\n+\n+    // Non-terminating instructions\n+\n+    @Override\n+    public void visit(BIRNonTerminator.NewTable newTable) {\n+        writePosition(newTable.pos);\n+        writeType(newTable.type);\n+        newTable.lhsOp.accept(this);\n+        newTable.keyColOp.accept(this);\n+        newTable.dataOp.accept(this);\n+    }\n+\n+\n+    public void visit(BIRNonTerminator.Move birMove) {\n+        writePosition(birMove.pos);\n+        buf.writeByte(birMove.kind.getValue());\n+        birMove.rhsOp.accept(this);\n+        birMove.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRTerminator.Call birCall) {\n+        writePosition(birCall.pos);\n+        buf.writeByte(birCall.kind.getValue());\n+        PackageID calleePkg = birCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birCall.name.getValue()));\n+        buf.writeInt(birCall.args.size());\n+        for (BIROperand arg : birCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIzMzY4Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r477233686", "bodyText": "Encoding 1 means true and and 0 means false. For me 1 and 0 more readable for me than replace it with constants.", "author": "warunalakshitha", "createdAt": "2020-08-26T11:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyMDQzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTA1NDE4MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r479054180", "bodyText": "I thought for someone like me who doesn't know what 1 and 0 stand for, it would make a lot of sense if it is a constant like TRUE_VAL for 1", "author": "riyafa", "createdAt": "2020-08-28T09:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyMDQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyMTAxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r476321017", "bodyText": "Shall we create issues for Todos so they will be fixed later?", "author": "riyafa", "createdAt": "2020-08-25T09:45:03Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRInstructionWriter.java", "diffHunk": "@@ -0,0 +1,606 @@\n+/*\n+ *  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  WSO2 Inc. licenses this file to you under the Apache License,\n+ *  Version 2.0 (the \"License\"); you may not use this file except\n+ *  in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing,\n+ *  software distributed under the License is distributed on an\n+ *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ *  KIND, either express or implied.  See the License for the\n+ *  specific language governing permissions and limitations\n+ *  under the License.\n+ */\n+package org.wso2.ballerinalang.compiler.bir.writer;\n+\n+import io.netty.buffer.ByteBuf;\n+import org.ballerinalang.compiler.BLangCompilerException;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRBasicBlock;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNode.BIRGlobalVariableDcl;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewArray;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStringXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewStructure;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewTypeDesc;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLComment;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLElement;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLProcIns;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLQName;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.NewXMLText;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRNonTerminator.XMLAccess;\n+import org.wso2.ballerinalang.compiler.bir.model.BIROperand;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRTerminator;\n+import org.wso2.ballerinalang.compiler.bir.model.BIRVisitor;\n+import org.wso2.ballerinalang.compiler.bir.model.InstructionKind;\n+import org.wso2.ballerinalang.compiler.bir.model.VarKind;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.ByteCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.FloatCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.IntegerCPEntry;\n+import org.wso2.ballerinalang.compiler.bir.writer.CPEntry.StringCPEntry;\n+import org.wso2.ballerinalang.compiler.semantics.model.types.BType;\n+import org.wso2.ballerinalang.compiler.util.TypeTags;\n+import org.wso2.ballerinalang.compiler.util.diagnotic.DiagnosticPos;\n+\n+import java.util.List;\n+\n+/**\n+ * Responsible for serializing BIR instructions and operands.\n+ *\n+ * @since 0.980.0\n+ */\n+public class BIRInstructionWriter extends BIRVisitor {\n+    private ByteBuf buf;\n+    private BIRTypeWriter typeWriter;\n+    private ConstantPool cp;\n+    private BIRBinaryWriter binaryWriter;\n+\n+    public BIRInstructionWriter(ByteBuf buf, BIRTypeWriter typeWriter, ConstantPool cp,\n+                                BIRBinaryWriter birBinaryWriter) {\n+        this.buf = buf;\n+        this.typeWriter = typeWriter;\n+        this.binaryWriter = birBinaryWriter;\n+        this.cp = cp;\n+    }\n+\n+    public void writeBBs(List<BIRBasicBlock> bbList) {\n+        buf.writeInt(bbList.size());\n+        bbList.forEach(bb -> bb.accept(this));\n+    }\n+\n+    public void visit(BIRBasicBlock birBasicBlock) {\n+        //Name of the basic block\n+        addCpAndWriteString(birBasicBlock.id.value);\n+        // Number of instructions\n+        // Adding the terminator instruction as well.\n+        buf.writeInt(birBasicBlock.instructions.size() + 1);\n+            birBasicBlock.instructions.forEach(instruction -> instruction.accept(this));\n+        if (birBasicBlock.terminator == null) {\n+            throw new BLangCompilerException(\"Basic block without a terminator : \" + birBasicBlock.id);\n+        }\n+        birBasicBlock.terminator.accept(this);\n+    }\n+\n+    public void writeErrorTable(List<BIRNode.BIRErrorEntry> errorEntries) {\n+        buf.writeInt(errorEntries.size());\n+        errorEntries.forEach(birErrorEntry -> birErrorEntry.accept(this));\n+    }\n+\n+    public void visit(BIRNode.BIRErrorEntry errorEntry) {\n+        addCpAndWriteString(errorEntry.trapBB.id.value);\n+        addCpAndWriteString(errorEntry.endBB.id.value);\n+        errorEntry.errorOp.accept(this);\n+        addCpAndWriteString(errorEntry.targetBB.id.value);\n+    }\n+\n+    // Terminating instructions\n+\n+    public void visit(BIRTerminator.GOTO birGoto) {\n+        writePosition(birGoto.pos);\n+        buf.writeByte(birGoto.kind.getValue());\n+        addCpAndWriteString(birGoto.targetBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Lock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FieldLock lock) {\n+        writePosition(lock.pos);\n+        buf.writeByte(lock.kind.getValue());\n+        // TODO properly use operand instead of variablDcl.name here\n+        addCpAndWriteString(lock.localVar.variableDcl.name.value);\n+        addCpAndWriteString(lock.field);\n+        addCpAndWriteString(lock.lockedBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Unlock unlock) {\n+        writePosition(unlock.pos);\n+        buf.writeByte(unlock.kind.getValue());\n+        addCpAndWriteString(unlock.unlockBB.id.value);\n+    }\n+\n+\n+    public void visit(BIRTerminator.Return birReturn) {\n+        writePosition(birReturn.pos);\n+        buf.writeByte(birReturn.kind.getValue());\n+    }\n+\n+    public void visit(BIRTerminator.Branch birBranch) {\n+        writePosition(birBranch.pos);\n+        buf.writeByte(birBranch.kind.getValue());\n+        birBranch.op.accept(this);\n+        // true:BB\n+        addCpAndWriteString(birBranch.trueBB.id.value);\n+        // false:BB\n+        addCpAndWriteString(birBranch.falseBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Wait waitEntry) {\n+        writePosition(waitEntry.pos);\n+        buf.writeByte(waitEntry.kind.getValue());\n+        buf.writeInt(waitEntry.exprList.size());\n+        for (BIROperand expr : waitEntry.exprList) {\n+            expr.accept(this);\n+        }\n+        waitEntry.lhsOp.accept(this);\n+        addCpAndWriteString(waitEntry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.Flush entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte(entry.kind.getValue());\n+        buf.writeInt(entry.channels.length);\n+        for (BIRNode.ChannelDetails detail : entry.channels) {\n+            addCpAndWriteString(detail.name);\n+            buf.writeBoolean(detail.channelInSameStrand);\n+            buf.writeBoolean(detail.send);\n+        }\n+        entry.lhsOp.accept(this);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerReceive entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.workerName.getValue()));\n+        entry.lhsOp.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WorkerSend entry) {\n+        writePosition(entry.pos);\n+        buf.writeByte((entry.kind.getValue()));\n+        buf.writeInt(addStringCPEntry(entry.channel.getValue()));\n+        entry.data.accept(this);\n+        buf.writeBoolean(entry.isSameStrand);\n+        buf.writeBoolean(entry.isSync);\n+        if (entry.isSync) {\n+            entry.lhsOp.accept(this);\n+        }\n+        addCpAndWriteString(entry.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.WaitAll waitAll) {\n+        writePosition(waitAll.pos);\n+        buf.writeByte((waitAll.kind.getValue()));\n+        waitAll.lhsOp.accept(this);\n+        buf.writeInt(waitAll.keys.size());\n+        waitAll.keys.forEach(key -> buf.writeInt(addStringCPEntry(key)));\n+        waitAll.valueExprs.forEach(val -> val.accept(this));\n+        addCpAndWriteString(waitAll.thenBB.id.value);\n+    }\n+\n+    // Non-terminating instructions\n+\n+    @Override\n+    public void visit(BIRNonTerminator.NewTable newTable) {\n+        writePosition(newTable.pos);\n+        writeType(newTable.type);\n+        newTable.lhsOp.accept(this);\n+        newTable.keyColOp.accept(this);\n+        newTable.dataOp.accept(this);\n+    }\n+\n+\n+    public void visit(BIRNonTerminator.Move birMove) {\n+        writePosition(birMove.pos);\n+        buf.writeByte(birMove.kind.getValue());\n+        birMove.rhsOp.accept(this);\n+        birMove.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRTerminator.Call birCall) {\n+        writePosition(birCall.pos);\n+        buf.writeByte(birCall.kind.getValue());\n+        PackageID calleePkg = birCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birCall.name.getValue()));\n+        buf.writeInt(birCall.args.size());\n+        for (BIROperand arg : birCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        addCpAndWriteString(birCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.AsyncCall birAsyncCall) {\n+        writePosition(birAsyncCall.pos);\n+        buf.writeByte(birAsyncCall.kind.getValue());\n+        PackageID calleePkg = birAsyncCall.calleePkg;\n+        int pkgIndex = addPkgCPEntry(calleePkg);\n+        buf.writeBoolean(birAsyncCall.isVirtual);\n+        buf.writeInt(pkgIndex);\n+        buf.writeInt(addStringCPEntry(birAsyncCall.name.getValue()));\n+        buf.writeInt(birAsyncCall.args.size());\n+        for (BIROperand arg : birAsyncCall.args) {\n+            arg.accept(this);\n+        }\n+        if (birAsyncCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            birAsyncCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+\n+        binaryWriter.writeAnnotAttachments(buf, this, birAsyncCall.annotAttachments);\n+        addCpAndWriteString(birAsyncCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRTerminator.FPCall fpCall) {\n+        writePosition(fpCall.pos);\n+        buf.writeByte(fpCall.kind.getValue());\n+        fpCall.fp.accept(this);\n+        buf.writeInt(fpCall.args.size());\n+        for (BIROperand arg : fpCall.args) {\n+            arg.accept(this);\n+        }\n+        if (fpCall.lhsOp != null) {\n+            buf.writeByte(1);\n+            fpCall.lhsOp.accept(this);\n+        } else {\n+            buf.writeByte(0);\n+        }\n+        buf.writeBoolean(fpCall.isAsync);\n+        addCpAndWriteString(fpCall.thenBB.id.value);\n+    }\n+\n+    public void visit(BIRNonTerminator.BinaryOp birBinaryOp) {\n+        writePosition(birBinaryOp.pos);\n+        buf.writeByte(birBinaryOp.kind.getValue());\n+        birBinaryOp.rhsOp1.accept(this);\n+        birBinaryOp.rhsOp2.accept(this);\n+        birBinaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.UnaryOP birUnaryOp) {\n+        writePosition(birUnaryOp.pos);\n+        buf.writeByte(birUnaryOp.kind.getValue());\n+        birUnaryOp.rhsOp.accept(this);\n+        birUnaryOp.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.ConstantLoad birConstantLoad) {\n+        writePosition(birConstantLoad.pos);\n+        buf.writeByte(birConstantLoad.kind.getValue());\n+        writeType(birConstantLoad.type);\n+        birConstantLoad.lhsOp.accept(this);\n+\n+        BType type = birConstantLoad.type;\n+        switch (type.tag) {\n+            case TypeTags.INT:\n+            case TypeTags.SIGNED32_INT:\n+            case TypeTags.SIGNED16_INT:\n+            case TypeTags.SIGNED8_INT:\n+            case TypeTags.UNSIGNED32_INT:\n+            case TypeTags.UNSIGNED16_INT:\n+            case TypeTags.UNSIGNED8_INT:\n+                buf.writeInt(cp.addCPEntry(new IntegerCPEntry((Long) birConstantLoad.value)));\n+                break;\n+            case TypeTags.BYTE:\n+                // TODO: birConstantLoad.value should return an Integer. This is a temporary fix\n+                int byteValue = ((Number) birConstantLoad.value).intValue();\n+                buf.writeInt(cp.addCPEntry(new ByteCPEntry(byteValue)));\n+                break;\n+            case TypeTags.BOOLEAN:\n+                // Not adding to constant pool as it increases the size (bit vs integer)\n+                buf.writeBoolean((Boolean) birConstantLoad.value);\n+                break;\n+            case TypeTags.STRING:\n+            case TypeTags.CHAR_STRING:\n+            case TypeTags.DECIMAL:\n+                buf.writeInt(cp.addCPEntry(new StringCPEntry(birConstantLoad.value.toString())));\n+                break;\n+            case TypeTags.FLOAT:\n+                double value = birConstantLoad.value instanceof Double ? (double) birConstantLoad.value\n+                        : Double.parseDouble((String) birConstantLoad.value);\n+                buf.writeInt(cp.addCPEntry(new FloatCPEntry(value)));\n+                break;\n+            case TypeTags.NIL:\n+                break;\n+            default:\n+                throw new IllegalStateException(\"unsupported constant type: \" + type);\n+        }\n+    }\n+\n+    public void visit(NewStructure birNewStructure) {\n+        writePosition(birNewStructure.pos);\n+        buf.writeByte(birNewStructure.kind.getValue());\n+        birNewStructure.rhsOp.accept(this);\n+        birNewStructure.lhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.NewInstance newInstance) {\n+        writePosition(newInstance.pos);\n+        buf.writeByte(newInstance.kind.getValue());\n+        buf.writeBoolean(newInstance.isExternalDef);\n+        if (newInstance.isExternalDef) {\n+            assert newInstance.externalPackageId != null;\n+            buf.writeInt(addPkgCPEntry(newInstance.externalPackageId));\n+            buf.writeInt(addStringCPEntry(newInstance.objectName));\n+        } else {\n+            buf.writeInt(newInstance.def.index);\n+        }\n+        newInstance.lhsOp.accept(this);\n+    }\n+\n+    public void visit(NewArray birNewArray) {\n+        writePosition(birNewArray.pos);\n+        buf.writeByte(birNewArray.kind.getValue());\n+        writeType(birNewArray.type);\n+        birNewArray.lhsOp.accept(this);\n+        birNewArray.sizeOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.FieldAccess birFieldAccess) {\n+        writePosition(birFieldAccess.pos);\n+        buf.writeByte(birFieldAccess.kind.getValue());\n+        if (birFieldAccess.kind == InstructionKind.MAP_LOAD || birFieldAccess.kind == InstructionKind.ARRAY_LOAD) {\n+            buf.writeBoolean(birFieldAccess.optionalFieldAccess);\n+            buf.writeBoolean(birFieldAccess.fillingRead);\n+        }\n+        birFieldAccess.lhsOp.accept(this);\n+        birFieldAccess.keyOp.accept(this);\n+        birFieldAccess.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeCast birTypeCast) {\n+        writePosition(birTypeCast.pos);\n+        buf.writeByte(birTypeCast.kind.getValue());\n+        birTypeCast.lhsOp.accept(this);\n+        birTypeCast.rhsOp.accept(this);\n+        writeType(birTypeCast.type);\n+        buf.writeBoolean(birTypeCast.checkTypes);\n+    }\n+\n+    public void visit(BIRNonTerminator.IsLike birIsLike) {\n+        writePosition(birIsLike.pos);\n+        buf.writeByte(birIsLike.kind.getValue());\n+        writeType(birIsLike.type);\n+        birIsLike.lhsOp.accept(this);\n+        birIsLike.rhsOp.accept(this);\n+    }\n+\n+    public void visit(BIRNonTerminator.TypeTest birTypeTest) {\n+        writePosition(birTypeTest.pos);\n+        buf.writeByte(birTypeTest.kind.getValue());\n+        writeType(birTypeTest.type);\n+        birTypeTest.lhsOp.accept(this);\n+        birTypeTest.rhsOp.accept(this);\n+    }\n+\n+    // Operands\n+    public void visit(BIROperand birOperand) {\n+        if (birOperand.variableDcl.ignoreVariable) {\n+            buf.writeBoolean(true);\n+            writeType(birOperand.variableDcl.type);\n+            return;\n+        }\n+\n+        buf.writeBoolean(false);\n+        buf.writeByte(birOperand.variableDcl.kind.getValue());\n+        buf.writeByte(birOperand.variableDcl.scope.getValue());\n+\n+        // TODO use the integer index of the variable.", "originalCommit": "6fc3de447ec3361b9ab93c473a6610544ffe80f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI0NTAwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r477245003", "bodyText": "refer #25440", "author": "warunalakshitha", "createdAt": "2020-08-26T11:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMyMTAxNw=="}], "type": "inlineReview"}, {"oid": "46639394b946bb5ad6c123916ec8bf1013f0c92b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/46639394b946bb5ad6c123916ec8bf1013f0c92b", "message": "Add function body with basic blocks and instructions\n\nUpdating the ksy file with BIR basic block and instruction models.", "committedDate": "2020-08-26T11:07:36Z", "type": "commit"}, {"oid": "24d8a372b83f922eb16e4edf5d5ceb494f4adf40", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/24d8a372b83f922eb16e4edf5d5ceb494f4adf40", "message": "Update BIR spec with error_table and woker_channel details", "committedDate": "2020-08-26T11:08:01Z", "type": "commit"}, {"oid": "78097e0824967f6b240c214b969115f167feacba", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/78097e0824967f6b240c214b969115f167feacba", "message": "Add instruction_call structure to BIR spec", "committedDate": "2020-08-26T11:08:13Z", "type": "commit"}, {"oid": "0199cbcfacca35cb0177519e47f0796dbb050350", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0199cbcfacca35cb0177519e47f0796dbb050350", "message": "Refactor BIR instruction writer\n\nWith this change the instructions will be written in a consistent\nmanner as forst position and then the kind value.", "committedDate": "2020-08-26T11:08:37Z", "type": "commit"}, {"oid": "98a9030d160a7242b902a35cb286163a2b084d1d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/98a9030d160a7242b902a35cb286163a2b084d1d", "message": "Address code review suggestions", "committedDate": "2020-08-26T12:17:36Z", "type": "commit"}, {"oid": "98a9030d160a7242b902a35cb286163a2b084d1d", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/98a9030d160a7242b902a35cb286163a2b084d1d", "message": "Address code review suggestions", "committedDate": "2020-08-26T12:17:36Z", "type": "forcePushed"}, {"oid": "a29f5093829b120fcb2340779cf147da5ddf17e0", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a29f5093829b120fcb2340779cf147da5ddf17e0", "message": "Remove bir.ksy file", "committedDate": "2020-08-27T11:29:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQyODkxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r478428914", "bodyText": "Shall we have the method after the call to maintain vertical ordering?", "author": "riyafa", "createdAt": "2020-08-27T13:43:02Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -378,10 +398,19 @@ private void defineFunction(DataInputStream dataInStream) throws IOException {\n \n         defineMarkDownDocAttachment(invokableSymbol, readDocBytes(dataInStream));\n \n+        dataInStream.skip(dataInStream.readLong()); // read and skip method body\n+\n         scopeToDefine.define(invokableSymbol.name, invokableSymbol);\n     }\n \n+    private void skipPosition(DataInputStream dataInStream) throws IOException {", "originalCommit": "a29f5093829b120fcb2340779cf147da5ddf17e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQyOTQ0MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r478429440", "bodyText": "Is this a dangling comment?", "author": "riyafa", "createdAt": "2020-08-27T13:43:47Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRBinaryWriter.java", "diffHunk": "@@ -196,7 +226,75 @@ private void writeFunction(ByteBuf buf, BIRNode.BIRFunction birFunction) {\n \n         writeTaintTable(buf, birFunction.taintTable);\n \n-        DocAttachmentWriter.writeMarkdownDocAttachment(buf, birFunction.markdownDocAttachment, cp);\n+        typeWriter.writeMarkdownDocAttachment(buf, birFunction.markdownDocAttachment);\n+\n+        ByteBuf birbuf = Unpooled.buffer();\n+        BIRInstructionWriter funcInsWriter = new BIRInstructionWriter(birbuf, cp, this);\n+\n+        // Arg count\n+        birbuf.writeInt(birFunction.argsCount);\n+        // Local variables", "originalCommit": "a29f5093829b120fcb2340779cf147da5ddf17e0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg4MTAwNg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r478881006", "bodyText": "No since it is not java doc format ex./**", "author": "warunalakshitha", "createdAt": "2020-08-28T07:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQyOTQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg5NjIyMQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r478896221", "bodyText": "I meant I don't see any local variables below the comment", "author": "riyafa", "createdAt": "2020-08-28T07:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQyOTQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODQzMDM4MQ==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r478430381", "bodyText": "Is this really conctant? \ud83d\ude42", "author": "riyafa", "createdAt": "2020-08-27T13:45:04Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/bir/writer/BIRBinaryWriter.java", "diffHunk": "@@ -233,27 +333,29 @@ private void writeAnnotation(ByteBuf buf, BIRNode.BIRAnnotation birAnnotation) {\n         }\n \n         writeType(buf, birAnnotation.annotationType);\n-        DocAttachmentWriter.writeMarkdownDocAttachment(buf, birAnnotation.markdownDocAttachment, cp);\n+        typeWriter.writeMarkdownDocAttachment(buf, birAnnotation.markdownDocAttachment);\n     }\n \n     private void writeConstants(ByteBuf buf, List<BIRNode.BIRConstant> birConstList) {\n+        BIRTypeWriter constTypeWriter = new BIRTypeWriter(buf, cp);\n         buf.writeInt(birConstList.size());\n-        birConstList.forEach(constant -> writeConstant(buf, constant));\n+        birConstList.forEach(constant -> writeConstant(buf, constTypeWriter, constant));\n     }\n \n-    private void writeConstant(ByteBuf buf, BIRNode.BIRConstant birConstant) {\n+    private void writeConstant(ByteBuf buf, BIRTypeWriter typeWriter, BIRNode.BIRConstant birConstant) {\n         // Annotation name CP Index\n         buf.writeInt(addStringCPEntry(birConstant.name.value));\n         buf.writeInt(birConstant.flags);\n \n-        DocAttachmentWriter.writeMarkdownDocAttachment(buf, birConstant.markdownDocAttachment, cp);\n+        typeWriter.writeMarkdownDocAttachment(buf, birConstant.markdownDocAttachment);\n \n         writeType(buf, birConstant.type);\n \n-        // write the length of the constant value, so that it can be skipped.\n+        // write the length of the conctant value, so that it can be skipped.", "originalCommit": "a29f5093829b120fcb2340779cf147da5ddf17e0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d2bf6808e33e363946961010150ed4a9aab02b0c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2bf6808e33e363946961010150ed4a9aab02b0c", "message": "Address review suggestions", "committedDate": "2020-08-28T08:18:58Z", "type": "commit"}, {"oid": "d2bf6808e33e363946961010150ed4a9aab02b0c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/d2bf6808e33e363946961010150ed4a9aab02b0c", "message": "Address review suggestions", "committedDate": "2020-08-28T08:18:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTAyMzY1OA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/25351#discussion_r479023658", "bodyText": "We can call the skipPosition method here if we pass it a parameter. skipPosition(dataInStream, 4); we can add a comment above the call if it makes sense", "author": "riyafa", "createdAt": "2020-08-28T09:31:41Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/BIRPackageSymbolEnter.java", "diffHunk": "@@ -330,9 +340,15 @@ private void defineImportPackage(DataInputStream dataInStream) throws IOExceptio\n     }\n \n     private void defineFunction(DataInputStream dataInStream) throws IOException {\n+        dataInStream.readInt(); // skip line start\n+        dataInStream.readInt(); // skip line end\n+        dataInStream.readInt(); // skip col start\n+        dataInStream.readInt(); // skip col end", "originalCommit": "d2bf6808e33e363946961010150ed4a9aab02b0c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c5b20a5409ea8922185efcbb6a91f96ab210287e", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/c5b20a5409ea8922185efcbb6a91f96ab210287e", "message": "Refactor skip position logic", "committedDate": "2020-08-31T06:57:00Z", "type": "commit"}]}