{"pr_number": 23478, "pr_title": "Fix union types with finite types in transformer", "pr_createdAt": "2020-05-25T11:41:53Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/23478", "timeline": [{"oid": "bb6b899068892fa0cfbbc9e0bea9b69f919c6965", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/bb6b899068892fa0cfbbc9e0bea9b69f919c6965", "message": "Fix union types with finite types in transformer", "committedDate": "2020-05-25T11:54:06Z", "type": "forcePushed"}, {"oid": "9b15b9564699314e8e4b64a4b0c327de68cad35f", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/9b15b9564699314e8e4b64a4b0c327de68cad35f", "message": "Fix union types with finite types in transformer", "committedDate": "2020-05-25T14:47:05Z", "type": "forcePushed"}, {"oid": "6defeb567dbd2d8538fdf81f8b0f00c503bd3ad3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6defeb567dbd2d8538fdf81f8b0f00c503bd3ad3", "message": "Fix union types with finite types in transformer", "committedDate": "2020-05-26T05:25:05Z", "type": "commit"}, {"oid": "6defeb567dbd2d8538fdf81f8b0f00c503bd3ad3", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/6defeb567dbd2d8538fdf81f8b0f00c503bd3ad3", "message": "Fix union types with finite types in transformer", "committedDate": "2020-05-26T05:25:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI3Nzk1Mw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23478#discussion_r430277953", "bodyText": "If you wan't to add another top-level node can achieve with additionalTopLevelNodes.add(bLTypeDef), these nodes will be added to current compilation unit in here or here. The idea is if someone started transformation from modulePart, they will get the compilation unit with additional top level nodes. if someone just wanted to tranform a inner node; still possible with accept() method(and might result a list of BLang nodes).", "author": "rasika", "createdAt": "2020-05-26T09:27:29Z", "path": "compiler/ballerina-lang/src/main/java/org/wso2/ballerinalang/compiler/parser/BLangNodeTransformer.java", "diffHunk": "@@ -466,10 +470,91 @@ public BLangNode transform(TypeDefinitionNode typeDefNode) {\n \n     @Override\n     public BLangNode transform(UnionTypeDescriptorNode unionTypeDescriptorNode) {\n-        BLangType rhsTypeNode = createTypeNode(unionTypeDescriptorNode.rightTypeDesc());\n-        BLangType lhsTypeNode = createTypeNode(unionTypeDescriptorNode.leftTypeDesc());\n+        List<TypeDescriptorNode> nodes = flattenUnionType(unionTypeDescriptorNode);\n+\n+        List<TypeDescriptorNode> finiteTypeElements = new ArrayList<>();\n+        List<List<TypeDescriptorNode>> unionTypeElementsCollection = new ArrayList<>();\n+        for (TypeDescriptorNode type : nodes) {\n+            if (type.kind() == SyntaxKind.SINGLETON_TYPE_DESC) {\n+                finiteTypeElements.add(type);\n+                unionTypeElementsCollection.add(new ArrayList<>());\n+            } else {\n+                List<TypeDescriptorNode> lastOfOthers;\n+                if (unionTypeElementsCollection.isEmpty()) {\n+                    lastOfOthers = new ArrayList<>();\n+                    unionTypeElementsCollection.add(lastOfOthers);\n+                } else {\n+                    lastOfOthers = unionTypeElementsCollection.get(unionTypeElementsCollection.size() - 1);\n+                }\n+\n+                lastOfOthers.add(type);\n+            }\n+        }\n+\n+        List<TypeDescriptorNode> unionElements = new ArrayList<>();\n+        reverseFlatMap(unionTypeElementsCollection, unionElements);\n+\n+        BLangFiniteTypeNode bLangFiniteTypeNode = (BLangFiniteTypeNode) TreeBuilder.createFiniteTypeNode();\n+        for (TypeDescriptorNode finiteTypeEl : finiteTypeElements) {\n+            SingletonTypeDescriptorNode singletonTypeNode = (SingletonTypeDescriptorNode) finiteTypeEl;\n+            BLangLiteral literal = createSimpleLiteral(singletonTypeNode.simpleContExprNode());\n+            bLangFiniteTypeNode.addValue(literal);\n+        }\n+\n+        if (unionElements.isEmpty()) {\n+            return bLangFiniteTypeNode;\n+        }\n \n-        return addUnionType(lhsTypeNode, rhsTypeNode, getPosition(unionTypeDescriptorNode));\n+        BLangUnionTypeNode unionTypeNode = (BLangUnionTypeNode) TreeBuilder.createUnionTypeNode();\n+        for (TypeDescriptorNode unionElement : unionElements) {\n+            unionTypeNode.memberTypeNodes.add(createTypeNode(unionElement));\n+        }\n+\n+        if (!finiteTypeElements.isEmpty()) {\n+            unionTypeNode.memberTypeNodes.add(deSugarFiniteTypeAsUserDefType(bLangFiniteTypeNode));\n+        }\n+        return unionTypeNode;\n+    }\n+\n+    private List<TypeDescriptorNode> flattenUnionType(UnionTypeDescriptorNode unionTypeDescriptorNode) {\n+        List<TypeDescriptorNode> list = new ArrayList<>();\n+        list.add(unionTypeDescriptorNode.leftTypeDesc());\n+        while (unionTypeDescriptorNode.rightTypeDesc().kind() == SyntaxKind.UNION_TYPE_DESC) {\n+            unionTypeDescriptorNode = (UnionTypeDescriptorNode) unionTypeDescriptorNode.rightTypeDesc();\n+            list.add(unionTypeDescriptorNode.leftTypeDesc());\n+        }\n+        list.add(unionTypeDescriptorNode.rightTypeDesc());\n+        return list;\n+    }\n+\n+    private <T> void reverseFlatMap(List<List<T>> listOfLists, List<T> result) {\n+        for (int i = listOfLists.size() - 1; i >= 0; i--) {\n+            result.addAll(listOfLists.get(i));\n+        }\n+    }\n+\n+    private BLangUserDefinedType deSugarFiniteTypeAsUserDefType(BLangFiniteTypeNode toIndirect) {\n+        DiagnosticPos pos = toIndirect.pos;\n+        BLangUserDefinedType bLUserDefinedType;\n+        BLangTypeDefinition bLTypeDef = (BLangTypeDefinition) TreeBuilder.createTypeDefinition();\n+\n+        // Generate a name for the anonymous object\n+        String genName = anonymousModelHelper.getNextAnonymousTypeKey(diagnosticSource.pkgID);\n+        IdentifierNode anonTypeGenName = createIdentifier(pos, genName);\n+        bLTypeDef.setName(anonTypeGenName);\n+        bLTypeDef.flagSet.add(Flag.PUBLIC);\n+        bLTypeDef.flagSet.add(Flag.ANONYMOUS);\n+\n+        bLTypeDef.typeNode = toIndirect;\n+        bLTypeDef.pos = pos;\n+        currentCompilationUnit.addTopLevelNode(bLTypeDef);", "originalCommit": "6defeb567dbd2d8538fdf81f8b0f00c503bd3ad3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI4MjY5MA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23478#discussion_r430282690", "bodyText": "Ya I tried that, but the I got the types added in wrong oder. I wanted to get them in exact order as the old parser.\nI'll improve this to keep the topNode, but have new private method addToTop, that will ignore it if it started form an inner node.", "author": "manuranga", "createdAt": "2020-05-26T09:35:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI3Nzk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI4ODQxNA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23478#discussion_r430288414", "bodyText": "Another option is to mention the index with additionalTopLevelNodes.add(<index>, bLTypeDef) and maintain an index?", "author": "rasika", "createdAt": "2020-05-26T09:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI3Nzk1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDMxMTY2Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/23478#discussion_r430311667", "bodyText": "I'll fix this with my next pr", "author": "manuranga", "createdAt": "2020-05-26T10:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI3Nzk1Mw=="}], "type": "inlineReview"}]}