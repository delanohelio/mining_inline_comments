{"pr_number": 26805, "pr_title": "Implement API for getting the lang lib functions allowed by method call expr", "pr_createdAt": "2020-11-06T17:31:53Z", "pr_url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805", "timeline": [{"oid": "b27c6b6f05c2d99e8331ed10c57b1f057932edad", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/b27c6b6f05c2d99e8331ed10c57b1f057932edad", "message": "Fix lang server tests", "committedDate": "2020-11-06T19:11:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNjg5Ng==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519526896", "bodyText": "Lang libs are looped twice, here and at L#80. Can we do it in a single loop?", "author": "SupunS", "createdAt": "2020-11-09T02:53:39Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {", "originalCommit": "b27c6b6f05c2d99e8331ed10c57b1f057932edad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0NDQwNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519644407", "bodyText": "Ack. I think we can, by populating the lang lib map on-demand, instead of populating the function list at the lang lib initialization.", "author": "pubudu91", "createdAt": "2020-11-09T08:56:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNjg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNzQ2NA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519527464", "bodyText": "Can there be symbols in the lang.value module without the LANG_LIB flag?", "author": "SupunS", "createdAt": "2020-11-09T02:55:53Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {\n+            String key = entry.getKey();\n+            BPackageSymbol value = entry.getValue();\n+\n+            Map<String, BInvokableSymbol> methods = new HashMap<>();\n+\n+            for (Map.Entry<Name, Scope.ScopeEntry> nameScopeEntry : value.scope.entries.entrySet()) {\n+                BSymbol symbol = nameScopeEntry.getValue().symbol;\n+\n+                if (symbol.kind != SymbolKind.FUNCTION) {\n+                    continue;\n+                }\n+\n+                BInvokableSymbol invSymbol = (BInvokableSymbol) symbol;\n+\n+                if (Symbols.isFlagOn(invSymbol.flags, Flags.PUBLIC) && !invSymbol.params.isEmpty() &&\n+                        key.compareToIgnoreCase(invSymbol.params.get(0).type.getKind().name()) == 0) {\n+                    methods.put(invSymbol.name.value, invSymbol);\n+                }\n+            }\n+\n+            langLibMethods.put(key, methods);\n+        }\n+\n+        populateLangValueLibrary(langLibs, langLibMethods);\n+        return langLibMethods;\n+    }\n+\n+    private static void populateLangValueLibrary(Map<String, BPackageSymbol> langLibs,\n+                                                 Map<String, Map<String, BInvokableSymbol>> langLibMethods) {\n+        BPackageSymbol langValue = langLibs.get(LANG_VALUE);\n+        Map<String, BInvokableSymbol> methods = new HashMap<>();\n+\n+        for (Map.Entry<Name, Scope.ScopeEntry> nameScopeEntry : langValue.scope.entries.entrySet()) {\n+            BSymbol symbol = nameScopeEntry.getValue().symbol;\n+\n+            if (symbol.kind != SymbolKind.FUNCTION || !Symbols.isFlagOn(symbol.flags, Flags.LANG_LIB)) {", "originalCommit": "b27c6b6f05c2d99e8331ed10c57b1f057932edad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0NzE3Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519647177", "bodyText": "There can be I guess. Currently we have added the LANG_LIB flag to lang lib functions. I guess we can get rid of the flag check", "author": "pubudu91", "createdAt": "2020-11-09T09:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNzQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY4OTA4Nw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519689087", "bodyText": "Checked this. Forgot that I explicitly checked the lang lib flag to filter out the module init, start, stop functions.", "author": "pubudu91", "createdAt": "2020-11-09T10:06:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyNzQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUyODAwMw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519528003", "bodyText": "Can rename:\nkey -> pkgName\nvalue to pkgSymbol", "author": "SupunS", "createdAt": "2020-11-09T02:58:22Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:\n+                return INT.getName();\n+            case FLOAT:\n+                return FLOAT.getName();\n+            case DECIMAL:\n+                return DECIMAL.getName();\n+            case STRING:\n+                return STRING.getName();\n+            case BOOLEAN:\n+                return BOOLEAN.getName();\n+            case ARRAY:\n+            case TUPLE:\n+                return ARRAY.getName();\n+            case STREAM:\n+                return STREAM.getName();\n+            case OBJECT:\n+                return OBJECT.getName();\n+            case RECORD:\n+            case MAP:\n+                return MAP.getName();\n+            case ERROR:\n+                return ERROR.getName();\n+            case FUTURE:\n+                return FUTURE.getName();\n+            case TYPEDESC:\n+                return TYPEDESC.getName();\n+            case XML:\n+                return XML.getName();\n+            case TABLE:\n+                return TABLE.getName();\n+            default:\n+                return \"value\";\n+        }\n+    }\n+\n+    private static Map<String, Map<String, BInvokableSymbol>> getLangLibMethods(Map<String, BPackageSymbol> langLibs) {\n+        Map<String, Map<String, BInvokableSymbol>> langLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<String, BPackageSymbol> entry : langLibs.entrySet()) {\n+            String key = entry.getKey();\n+            BPackageSymbol value = entry.getValue();", "originalCommit": "b27c6b6f05c2d99e8331ed10c57b1f057932edad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUzMDAxNw==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519530017", "bodyText": "will the number of name components be 2 in future as well? What if we check for startsWith(\"lang.\")?", "author": "nadeeshaan", "createdAt": "2020-11-09T03:07:31Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {", "originalCommit": "b27c6b6f05c2d99e8331ed10c57b1f057932edad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0ODczMg==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519648732", "bodyText": "Good point. Don't think there's a restriction on that. But it's also unlikely that there'd be multiple components because a lang library usually corresponds to a basic type (which is typically a single word).", "author": "pubudu91", "createdAt": "2020-11-09T09:03:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUzMDAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTUzMjEyOA==", "url": "https://github.com/ballerina-platform/ballerina-lang/pull/26805#discussion_r519532128", "bodyText": "We can simplify the cases and the returns here. What if get the common cases to the bottom where we can directly call getName() over the typeDescKind", "author": "nadeeshaan", "createdAt": "2020-11-09T03:16:59Z", "path": "compiler/ballerina-lang/src/main/java/io/ballerina/compiler/api/impl/LangLibrary.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ * WSO2 Inc. licenses this file to you under the Apache License,\n+ * Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.ballerina.compiler.api.impl;\n+\n+import io.ballerina.compiler.api.symbols.FunctionSymbol;\n+import io.ballerina.compiler.api.symbols.TypeDescKind;\n+import org.ballerinalang.model.elements.PackageID;\n+import org.ballerinalang.model.symbols.SymbolKind;\n+import org.wso2.ballerinalang.compiler.semantics.model.Scope;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolEnv;\n+import org.wso2.ballerinalang.compiler.semantics.model.SymbolTable;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BInvokableSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BPackageSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.BSymbol;\n+import org.wso2.ballerinalang.compiler.semantics.model.symbols.Symbols;\n+import org.wso2.ballerinalang.compiler.util.CompilerContext;\n+import org.wso2.ballerinalang.compiler.util.Name;\n+import org.wso2.ballerinalang.compiler.util.Names;\n+import org.wso2.ballerinalang.util.Flags;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ARRAY;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.BOOLEAN;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.DECIMAL;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.ERROR;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FLOAT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.FUTURE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.INT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.MAP;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.OBJECT;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STREAM;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.STRING;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TABLE;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.TYPEDESC;\n+import static io.ballerina.compiler.api.symbols.TypeDescKind.XML;\n+\n+\n+/**\n+ * A class to hold the lang library function info required for types.\n+ *\n+ * @since 2.0.0\n+ */\n+public class LangLibrary {\n+\n+    private static final CompilerContext.Key<LangLibrary> LANG_LIB_KEY = new CompilerContext.Key<>();\n+    private static final String LANG_VALUE = \"value\";\n+\n+    private final Map<String, Map<String, BInvokableSymbol>> langLibMethods;\n+    private final Map<String, List<FunctionSymbol>> wrappedLangLibMethods;\n+    private final SymbolFactory symbolFactory;\n+\n+    private LangLibrary(CompilerContext context) {\n+        context.put(LANG_LIB_KEY, this);\n+\n+        symbolFactory = SymbolFactory.getInstance(context);\n+        SymbolTable symbolTable = SymbolTable.getInstance(context);\n+        Map<String, BPackageSymbol> langLibs = new HashMap<>();\n+        wrappedLangLibMethods = new HashMap<>();\n+\n+        for (Map.Entry<BPackageSymbol, SymbolEnv> entry : symbolTable.pkgEnvMap.entrySet()) {\n+            BPackageSymbol module = entry.getKey();\n+            PackageID moduleID = module.pkgID;\n+\n+            if (Names.BALLERINA_ORG.equals(moduleID.orgName) &&\n+                    (moduleID.nameComps.size() == 2 && Names.LANG.equals(moduleID.nameComps.get(0)))) {\n+                langLibs.put(moduleID.nameComps.get(1).value, module);\n+            }\n+        }\n+\n+        langLibMethods = getLangLibMethods(langLibs);\n+    }\n+\n+    public static LangLibrary getInstance(CompilerContext context) {\n+        LangLibrary langLib = context.get(LANG_LIB_KEY);\n+        if (langLib == null) {\n+            langLib = new LangLibrary(context);\n+        }\n+\n+        return langLib;\n+    }\n+\n+    /**\n+     * Given a type descriptor kind, return the list of lang library functions that can be called using a method call\n+     * expr, on an expression of that type.\n+     *\n+     * @param typeDescKind A type descriptor kind\n+     * @return The associated list of lang library functions\n+     */\n+    public List<FunctionSymbol> getMethods(TypeDescKind typeDescKind) {\n+        String langLibName = getAssociatedLangLibName(typeDescKind);\n+\n+        if (wrappedLangLibMethods.containsKey(langLibName)) {\n+            return wrappedLangLibMethods.get(langLibName);\n+        }\n+\n+        Map<String, BInvokableSymbol> methods = langLibMethods.get(langLibName);\n+\n+        List<FunctionSymbol> wrappedMethods = new ArrayList<>();\n+        wrappedLangLibMethods.put(langLibName, wrappedMethods);\n+        populateMethodList(wrappedMethods, methods);\n+\n+        // Add the common functions in lang.value to types which have an associated lang library.\n+        if (!LANG_VALUE.equals(langLibName)) {\n+            populateMethodList(wrappedMethods, langLibMethods.get(LANG_VALUE));\n+        }\n+\n+        return wrappedMethods;\n+    }\n+\n+    // Private Methods\n+\n+    private void populateMethodList(List<FunctionSymbol> list, Map<String, BInvokableSymbol> langLib) {\n+        for (Map.Entry<String, BInvokableSymbol> entry : langLib.entrySet()) {\n+            FunctionSymbol method = symbolFactory.createFunctionSymbol(entry.getValue(), entry.getKey());\n+            list.add(method);\n+        }\n+    }\n+\n+    private String getAssociatedLangLibName(TypeDescKind typeDescKind) {\n+        switch (typeDescKind) {\n+            case INT:\n+            case BYTE:", "originalCommit": "b27c6b6f05c2d99e8331ed10c57b1f057932edad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f5b1625eac71c75eb5c06bca83b385d02c24ec51", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f5b1625eac71c75eb5c06bca83b385d02c24ec51", "message": "Add an API for getting the lang lib methods given a type kind", "committedDate": "2020-11-09T10:12:04Z", "type": "commit"}, {"oid": "f91939214db57878bbd13eb90dbe809b255245be", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f91939214db57878bbd13eb90dbe809b255245be", "message": "Rename builtinMethods() -> langLibMethods()", "committedDate": "2020-11-09T10:12:08Z", "type": "commit"}, {"oid": "fe11d2efbeb473930c9fa1a614d9bff2bca10ac7", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/fe11d2efbeb473930c9fa1a614d9bff2bca10ac7", "message": "Implement langLibMethods() API", "committedDate": "2020-11-09T10:12:09Z", "type": "commit"}, {"oid": "447813f1a18c202bf4519aa53608d9b529bf393b", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/447813f1a18c202bf4519aa53608d9b529bf393b", "message": "Add test cases for lang lib methods", "committedDate": "2020-11-09T10:12:09Z", "type": "commit"}, {"oid": "f56ed05804b9be2fb3bcf07120c419a541417c4c", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/f56ed05804b9be2fb3bcf07120c419a541417c4c", "message": "Fix lang server tests", "committedDate": "2020-11-09T10:12:09Z", "type": "commit"}, {"oid": "a795a9d14349ad87e589f118e6b00569faf1c00a", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/a795a9d14349ad87e589f118e6b00569faf1c00a", "message": "Refactor names and lang lib mapping logic", "committedDate": "2020-11-09T10:12:09Z", "type": "commit"}, {"oid": "0de9eb30e702edc7a766bca088ebfea0bc64b013", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0de9eb30e702edc7a766bca088ebfea0bc64b013", "message": "Improve lang lib function extraction logic", "committedDate": "2020-11-09T11:57:17Z", "type": "commit"}, {"oid": "0de9eb30e702edc7a766bca088ebfea0bc64b013", "url": "https://github.com/ballerina-platform/ballerina-lang/commit/0de9eb30e702edc7a766bca088ebfea0bc64b013", "message": "Improve lang lib function extraction logic", "committedDate": "2020-11-09T11:57:17Z", "type": "forcePushed"}]}