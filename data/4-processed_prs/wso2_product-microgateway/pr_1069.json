{"pr_number": 1069, "pr_title": "Java interceptor feature- provide payload modification", "pr_createdAt": "2020-02-29T06:57:55Z", "pr_url": "https://github.com/wso2/product-microgateway/pull/1069", "timeline": [{"oid": "ad5e5910f4401c26ae1e97fb3518c0b35dff15fd", "url": "https://github.com/wso2/product-microgateway/commit/ad5e5910f4401c26ae1e97fb3518c0b35dff15fd", "message": "Fix #992 - Add payload modification methods and test cases", "committedDate": "2020-02-29T04:06:08Z", "type": "commit"}, {"oid": "733abfce2a952eb526b09ce0b9d756d51dfda321", "url": "https://github.com/wso2/product-microgateway/commit/733abfce2a952eb526b09ce0b9d756d51dfda321", "message": "Fix #992 - Change payload modification method interfaces", "committedDate": "2020-02-29T04:06:34Z", "type": "commit"}, {"oid": "9c1248918116b395796ed3796cffb31a910731f0", "url": "https://github.com/wso2/product-microgateway/commit/9c1248918116b395796ed3796cffb31a910731f0", "message": "Fix #992 - Fix the test cases", "committedDate": "2020-02-29T06:54:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMjUwMw==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386012503", "bodyText": "Suggested change", "author": "praminda", "createdAt": "2020-02-29T08:35:02Z", "path": "components/micro-gateway-interceptor/src/main/java/org/wso2/micro/gateway/interceptor/Constants.java", "diffHunk": "@@ -26,5 +26,22 @@\n     public static final String EXPECT_HEADER = \"expect\";\n     public static final String HUNDRED_CONTINUE = \"100-continue\";\n     public static final String CONTENT_TYPE_HEADER = \"content-type\";\n+    public static final String RESOURCE_PATH = \"rawPath\";\n+    public static final String REQUEST_METHOD = \"method\";\n+    public static final String REQUEST_HTTP_VERSION = \"httpVersion\";\n+    public static final String PATH_INFO = \"extraPathInfo\";\n+    public static final String USER_INFO = \"userAgent\";\n+    public static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n+    public static final String OCTET_STREAM = \"application/octet-stream\";\n+    public static final String STATUS_CODE = \"statusCode\";\n+    public static final String RESOLVED_REQUESTED_URI = \"resolvedRequestedURI\";\n+    public static final String LOCAL_ADDRESS = \"localAddress\";\n+    public static final String REMOTE_ADDRESS = \"remoteAddress\";\n+    public static final String HOST = \"host\";\n+    public static final String PORT = \"port\";\n+    public static final String RESPOND_DONE = \"respond_done\";\n+    public static final String RESPONSE_OBJECT = \"response_object\";\n+    public static final String READABLE_BYTE_CHANNEL = \"ReadableByteChannel\";\n+", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMjYxMQ==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386012611", "bodyText": "Suggested change", "author": "praminda", "createdAt": "2020-02-29T08:36:54Z", "path": "components/micro-gateway-interceptor/src/main/java/org/wso2/micro/gateway/interceptor/Entity.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.micro.gateway.interceptor;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.scheduling.Scheduler;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.jvm.values.XMLValue;\n+import org.ballerinalang.jvm.values.api.BValueCreator;\n+import org.ballerinalang.jvm.values.api.BXML;\n+import org.ballerinalang.mime.nativeimpl.AbstractGetPayloadHandler;\n+import org.ballerinalang.mime.nativeimpl.EntityHeaders;\n+import org.ballerinalang.mime.nativeimpl.MimeEntityBody;\n+import org.ballerinalang.mime.util.MimeConstants;\n+import org.ballerinalang.mime.util.MimeUtil;\n+import org.ballerinalang.stdlib.io.channels.base.Channel;\n+import org.ballerinalang.stdlib.io.utils.IOConstants;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.channels.ByteChannel;\n+\n+/**\n+ * Represents the headers and body of a message. This can be used to represent both the entity of a top level message\n+ * and an entity(body part) inside of a multipart entity.\n+ */\n+public class Entity {\n+\n+    private static final Logger log = LoggerFactory.getLogger(\"ballerina\");\n+    private ObjectValue entityObj;\n+\n+    public Entity(ObjectValue entity) {\n+        this.entityObj = entity;\n+    }\n+\n+    public Entity() {\n+        this.entityObj = BallerinaValues\n+                .createObjectValue(MimeConstants.PROTOCOL_MIME_PKG_ID, MimeConstants.ENTITY, new Object());\n+    }\n+\n+    /**\n+     * Checks whether the requested header key exists in the header map.\n+     *\n+     * @param headerName The header name.\n+     * @return Returns true if the specified header key exists\n+     */\n+    public boolean hasHeader(String headerName) {\n+        return EntityHeaders.hasHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Returns the value of the specified header. If the specified header key maps to multiple values, the first of\n+     * these values is returned.\n+     *\n+     * @param headerName The header name.\n+     * @return The first header value for the specified header name. Null is returned if header does not present.\n+     */\n+    public String getHeader(String headerName) {\n+        if (hasHeader(headerName)) {\n+            return EntityHeaders.getHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets all the header values to which the specified header key maps to.\n+     *\n+     * @param headerName The header name.\n+     * @return The header values the specified header key maps to. Null is returned if header does not present.\n+     */\n+    public String[] getHeaders(String headerName) {\n+        if (hasHeader(headerName)) {\n+            ArrayValue headerArray = EntityHeaders.getHeaders(entityObj, headerName, Constants.LEADING_HEADER);\n+            String[] stringArray;\n+            if ((stringArray = headerArray.getStringArray()) != null) {\n+                return stringArray;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Sets the specified header to the entity. If a mapping already exists for the specified header key, the existing\n+     * header value is replaced with the specified header value.\n+     *\n+     * @param headerName  The header name.\n+     * @param headerValue The header value.\n+     */\n+    public void setHeader(String headerName, String headerValue) {\n+        EntityHeaders.setHeader(entityObj, headerName, headerValue, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Adds the specified header to the entity. Existing header values are not replaced.\n+     *\n+     * @param headerName  The header name.\n+     * @param headerValue The header value.\n+     */\n+    public void addHeader(String headerName, String headerValue) {\n+        EntityHeaders.addHeader(entityObj, headerName, headerValue, Constants.LEADING_HEADER);\n+\n+    }\n+\n+    /**\n+     * Removes the specified header from the entity.\n+     *\n+     * @param headerName The header name.\n+     */\n+    public void removeHeader(String headerName) {\n+        EntityHeaders.removeHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Removes all the headers from the entity.\n+     */\n+    public void removeAllHeaders() {\n+        EntityHeaders.removeAllHeaders(entityObj, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Gets all the names of the headers of the entity. If headers are not present returns an empty array.\n+     *\n+     * @return An array of all the header names.\n+     */\n+    public String[] getHeaderNames() {\n+        ArrayValue headerNames = EntityHeaders.getHeaderNames(entityObj, Constants.LEADING_HEADER);\n+\n+        if (headerNames.getValues() != null) {\n+            Object[] headerObjects = headerNames.getValues();\n+            String[] headers = new String[headerObjects.length];\n+            for (int index = 0; index < headerObjects.length; index++) {\n+                headers[index] = headerObjects[index].toString();\n+            }\n+            return headers;\n+        }\n+        return new String[0];\n+    }\n+\n+    /**\n+     * Extracts `json` payload from the entity. If the content type is not JSON, an exception will be thrown.\n+     *\n+     * @return The `json` payload of the request.\n+     * @throws InterceptorException If error while getting json payload.\n+     */\n+    public JSONObject getJson() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.JSON);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            String jsonPayload = MimeUtil\n+                    .getMessageAsString(entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE));\n+            return new JSONObject(jsonPayload);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Extracts `xml` payload from the entity. If the content type is not XML, an exception will be thrown.\n+     *\n+     * @return {@link BXML} The `xml` payload of the request.\n+     * @throws InterceptorException If error while getting xml payload.\n+     */\n+    public BXML getXml() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.XML);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return (BXML) entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Extracts `text` payload from the entity. If the content type is not text, an exception will be thrown.\n+     *\n+     * @return The `text` payload of the request.\n+     * @throws InterceptorException If error while getting text payload.\n+     */\n+    public String getText() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.TEXT);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return  entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE).toString();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given an entity, gets the entity body as a byte channel\n+     *\n+     * @return {@link ByteChannel} A byte channel from which the message payload can be read.\n+     * @throws InterceptorException If error while getting byte channel of the entity.\n+     */\n+    public ByteChannel getByteChannel() throws InterceptorException {\n+        Object byteChannel = MimeEntityBody.getByteChannel(entityObj);\n+        if (byteChannel instanceof ErrorValue) {\n+            throw new InterceptorException(\"Error while getting byte channel from the entity\",\n+                    ((ErrorValue) byteChannel).getCause());\n+        }\n+        ObjectValue byteChannelObject = (ObjectValue) byteChannel;\n+        Channel channel = ((Channel) byteChannelObject.getNativeData(IOConstants.BYTE_CHANNEL_NAME));\n+        return channel.getByteChannel();\n+    }\n+\n+    /**\n+     * Gets the entity payload as a `byte[]`.\n+     *\n+     * @return The byte[] representation of the message payload\n+     * @throws InterceptorException If error while getting byte array of the entity.\n+     */\n+    public byte[] getByteArray() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.BLOB);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return (byte[]) entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given an entity, gets its body parts. If the entity body is not a set of body parts an exception will be thrown.\n+     *\n+     * @return An array of body parts{@link Entity[]} extracted from the entity body\n+     * @throws InterceptorException If error while getting byte array of the entity.\n+     */\n+    public Entity[] getBodyParts() throws InterceptorException {\n+        Object arrayValue = MimeEntityBody.getBodyParts(entityObj);\n+        if (arrayValue instanceof ErrorValue) {\n+            throw new InterceptorException(\"Error while getting byte array from the request\",\n+                    ((ErrorValue) arrayValue).getCause());\n+        }\n+        Object[] entityObjects = ((ArrayValue) arrayValue).getValues();\n+        Entity[] entities = new Entity[entityObjects.length];\n+        for (int index = 0; index < entityObjects.length; index++) {\n+            entities[index] = new Entity((ObjectValue) entityObjects[index]);\n+        }\n+        return entities;\n+    }\n+\n+    /**\n+     * Sets a json {@link JSONObject} as the payload to the entity.\n+     *\n+     * @param jsonPayload {@link JSONObject} The json payload.\n+     */\n+    public void setJson(JSONObject jsonPayload) {\n+        MimeEntityBody.setJson(entityObj, JSONParser.parse(jsonPayload.toString()), MimeConstants.APPLICATION_JSON);\n+    }\n+\n+    /**\n+     * Sets a xml to the entity.\n+     *\n+     * @param xmlPayload The xml {@link BXML} payload.\n+     */\n+    public void setXml(BXML xmlPayload) {\n+        MimeEntityBody.setXml(entityObj, (XMLValue) xmlPayload, MimeConstants.APPLICATION_XML);\n+    }\n+\n+    /**\n+     * Sets a string text content to the entity.\n+     *\n+     * @param textPayload The text payload.\n+     */\n+    public void setText(String textPayload) {\n+        MimeEntityBody.setText(entityObj, textPayload, MimeConstants.TEXT_PLAIN);\n+    }\n+\n+    /**\n+     * Sets a byte[] content to the entity.\n+     *\n+     * @param binaryPayload The byte[] payload.\n+     */\n+    public void setBinary(byte[] binaryPayload) {\n+        MimeEntityBody.setByteArray(entityObj, (ArrayValue) BValueCreator.createArrayValue(binaryPayload),\n+                MimeConstants.OCTET_STREAM);\n+    }\n+\n+    /**\n+     * Set multiparts as the payload.\n+     *\n+     * @param bodyParts   The entities which make up the message body\n+     * @param contentType The content type of the top level message. Set this to override the default\n+     *                    `content-type` header value which is 'multipart/form-data'\n+     */\n+    public void setBodyParts(Entity[] bodyParts, String contentType) {\n+        if (contentType == null) {\n+            contentType = Constants.MULTIPART_FORM_DATA;\n+        }\n+        ObjectValue[] entityObjects = new ObjectValue[bodyParts.length];\n+        for (int index = 0; index < bodyParts.length; index++) {\n+            entityObjects[index] = bodyParts[index].getEntityObj();\n+        }\n+        ArrayValue arrValues = (ArrayValue) BValueCreator\n+                .createArrayValue(entityObjects, new BArrayType(BTypes.typeAny));\n+        MimeEntityBody.setBodyParts(entityObj, arrValues, contentType);\n+    }\n+\n+    /**\n+     * Sets a `ByteChannel`  to the entity.\n+     *\n+     * @param channel - A `ByteChannel` {@link Channel} through which the message payload can be read\n+     * @param contentType The content type of the top level message. Set this to override the default\n+     *                    `content-type` header value which is 'application/octet-stream'\n+     */\n+    public void setByteChannel(Channel channel, String contentType) {\n+        if (contentType == null) {\n+            contentType = Constants.OCTET_STREAM;\n+        }\n+        ObjectValue channelObj = BallerinaValues\n+                .createObjectValue(IOConstants.IO_PACKAGE_ID, Constants.READABLE_BYTE_CHANNEL);\n+        channelObj.addNativeData(IOConstants.BYTE_CHANNEL_NAME, channel);\n+        MimeEntityBody.setByteChannel(entityObj, channelObj, contentType);\n+    }\n+\n+    /**\n+     * Returns the java native object of the ballerina level mime:Entity object.\n+     *\n+     * @return Native ballerina object {@link ObjectValue} representing the entity.\n+     */\n+    public ObjectValue getEntityObj() {\n+        return entityObj;\n+    }\n+\n+    private void constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType type)\n+            throws InterceptorException {\n+        MGWBlockingCallBack callback = new MGWBlockingCallBack(Scheduler.getStrand());\n+        try {\n+            AbstractGetPayloadHandler.constructNonBlockingDataSource(callback, entityObj, type);\n+            callback.sync();\n+        } catch (Exception e) {\n+            // we need to catch all the exceptions including runtime thrown from ballerina side in order to avoid the\n+            // call back syncing process.\n+            String msg = \"Error while getting the payload with type : \" + type.toString();\n+            log.error(msg, e);\n+            callback.notifyFailure();\n+            throw new InterceptorException(msg, e);\n+        }\n+\n+    }\n+\n+\n+\n+}\n+", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMjYxNg==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386012616", "bodyText": "Suggested change", "author": "praminda", "createdAt": "2020-02-29T08:36:59Z", "path": "components/micro-gateway-interceptor/src/main/java/org/wso2/micro/gateway/interceptor/Entity.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.micro.gateway.interceptor;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.scheduling.Scheduler;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.jvm.values.XMLValue;\n+import org.ballerinalang.jvm.values.api.BValueCreator;\n+import org.ballerinalang.jvm.values.api.BXML;\n+import org.ballerinalang.mime.nativeimpl.AbstractGetPayloadHandler;\n+import org.ballerinalang.mime.nativeimpl.EntityHeaders;\n+import org.ballerinalang.mime.nativeimpl.MimeEntityBody;\n+import org.ballerinalang.mime.util.MimeConstants;\n+import org.ballerinalang.mime.util.MimeUtil;\n+import org.ballerinalang.stdlib.io.channels.base.Channel;\n+import org.ballerinalang.stdlib.io.utils.IOConstants;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.channels.ByteChannel;\n+\n+/**\n+ * Represents the headers and body of a message. This can be used to represent both the entity of a top level message\n+ * and an entity(body part) inside of a multipart entity.\n+ */\n+public class Entity {\n+\n+    private static final Logger log = LoggerFactory.getLogger(\"ballerina\");\n+    private ObjectValue entityObj;\n+\n+    public Entity(ObjectValue entity) {\n+        this.entityObj = entity;\n+    }\n+\n+    public Entity() {\n+        this.entityObj = BallerinaValues\n+                .createObjectValue(MimeConstants.PROTOCOL_MIME_PKG_ID, MimeConstants.ENTITY, new Object());\n+    }\n+\n+    /**\n+     * Checks whether the requested header key exists in the header map.\n+     *\n+     * @param headerName The header name.\n+     * @return Returns true if the specified header key exists\n+     */\n+    public boolean hasHeader(String headerName) {\n+        return EntityHeaders.hasHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Returns the value of the specified header. If the specified header key maps to multiple values, the first of\n+     * these values is returned.\n+     *\n+     * @param headerName The header name.\n+     * @return The first header value for the specified header name. Null is returned if header does not present.\n+     */\n+    public String getHeader(String headerName) {\n+        if (hasHeader(headerName)) {\n+            return EntityHeaders.getHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets all the header values to which the specified header key maps to.\n+     *\n+     * @param headerName The header name.\n+     * @return The header values the specified header key maps to. Null is returned if header does not present.\n+     */\n+    public String[] getHeaders(String headerName) {\n+        if (hasHeader(headerName)) {\n+            ArrayValue headerArray = EntityHeaders.getHeaders(entityObj, headerName, Constants.LEADING_HEADER);\n+            String[] stringArray;\n+            if ((stringArray = headerArray.getStringArray()) != null) {\n+                return stringArray;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Sets the specified header to the entity. If a mapping already exists for the specified header key, the existing\n+     * header value is replaced with the specified header value.\n+     *\n+     * @param headerName  The header name.\n+     * @param headerValue The header value.\n+     */\n+    public void setHeader(String headerName, String headerValue) {\n+        EntityHeaders.setHeader(entityObj, headerName, headerValue, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Adds the specified header to the entity. Existing header values are not replaced.\n+     *\n+     * @param headerName  The header name.\n+     * @param headerValue The header value.\n+     */\n+    public void addHeader(String headerName, String headerValue) {\n+        EntityHeaders.addHeader(entityObj, headerName, headerValue, Constants.LEADING_HEADER);\n+\n+    }\n+\n+    /**\n+     * Removes the specified header from the entity.\n+     *\n+     * @param headerName The header name.\n+     */\n+    public void removeHeader(String headerName) {\n+        EntityHeaders.removeHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Removes all the headers from the entity.\n+     */\n+    public void removeAllHeaders() {\n+        EntityHeaders.removeAllHeaders(entityObj, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Gets all the names of the headers of the entity. If headers are not present returns an empty array.\n+     *\n+     * @return An array of all the header names.\n+     */\n+    public String[] getHeaderNames() {\n+        ArrayValue headerNames = EntityHeaders.getHeaderNames(entityObj, Constants.LEADING_HEADER);\n+\n+        if (headerNames.getValues() != null) {\n+            Object[] headerObjects = headerNames.getValues();\n+            String[] headers = new String[headerObjects.length];\n+            for (int index = 0; index < headerObjects.length; index++) {\n+                headers[index] = headerObjects[index].toString();\n+            }\n+            return headers;\n+        }\n+        return new String[0];\n+    }\n+\n+    /**\n+     * Extracts `json` payload from the entity. If the content type is not JSON, an exception will be thrown.\n+     *\n+     * @return The `json` payload of the request.\n+     * @throws InterceptorException If error while getting json payload.\n+     */\n+    public JSONObject getJson() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.JSON);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            String jsonPayload = MimeUtil\n+                    .getMessageAsString(entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE));\n+            return new JSONObject(jsonPayload);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Extracts `xml` payload from the entity. If the content type is not XML, an exception will be thrown.\n+     *\n+     * @return {@link BXML} The `xml` payload of the request.\n+     * @throws InterceptorException If error while getting xml payload.\n+     */\n+    public BXML getXml() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.XML);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return (BXML) entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Extracts `text` payload from the entity. If the content type is not text, an exception will be thrown.\n+     *\n+     * @return The `text` payload of the request.\n+     * @throws InterceptorException If error while getting text payload.\n+     */\n+    public String getText() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.TEXT);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return  entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE).toString();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given an entity, gets the entity body as a byte channel\n+     *\n+     * @return {@link ByteChannel} A byte channel from which the message payload can be read.\n+     * @throws InterceptorException If error while getting byte channel of the entity.\n+     */\n+    public ByteChannel getByteChannel() throws InterceptorException {\n+        Object byteChannel = MimeEntityBody.getByteChannel(entityObj);\n+        if (byteChannel instanceof ErrorValue) {\n+            throw new InterceptorException(\"Error while getting byte channel from the entity\",\n+                    ((ErrorValue) byteChannel).getCause());\n+        }\n+        ObjectValue byteChannelObject = (ObjectValue) byteChannel;\n+        Channel channel = ((Channel) byteChannelObject.getNativeData(IOConstants.BYTE_CHANNEL_NAME));\n+        return channel.getByteChannel();\n+    }\n+\n+    /**\n+     * Gets the entity payload as a `byte[]`.\n+     *\n+     * @return The byte[] representation of the message payload\n+     * @throws InterceptorException If error while getting byte array of the entity.\n+     */\n+    public byte[] getByteArray() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.BLOB);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return (byte[]) entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given an entity, gets its body parts. If the entity body is not a set of body parts an exception will be thrown.\n+     *\n+     * @return An array of body parts{@link Entity[]} extracted from the entity body\n+     * @throws InterceptorException If error while getting byte array of the entity.\n+     */\n+    public Entity[] getBodyParts() throws InterceptorException {\n+        Object arrayValue = MimeEntityBody.getBodyParts(entityObj);\n+        if (arrayValue instanceof ErrorValue) {\n+            throw new InterceptorException(\"Error while getting byte array from the request\",\n+                    ((ErrorValue) arrayValue).getCause());\n+        }\n+        Object[] entityObjects = ((ArrayValue) arrayValue).getValues();\n+        Entity[] entities = new Entity[entityObjects.length];\n+        for (int index = 0; index < entityObjects.length; index++) {\n+            entities[index] = new Entity((ObjectValue) entityObjects[index]);\n+        }\n+        return entities;\n+    }\n+\n+    /**\n+     * Sets a json {@link JSONObject} as the payload to the entity.\n+     *\n+     * @param jsonPayload {@link JSONObject} The json payload.\n+     */\n+    public void setJson(JSONObject jsonPayload) {\n+        MimeEntityBody.setJson(entityObj, JSONParser.parse(jsonPayload.toString()), MimeConstants.APPLICATION_JSON);\n+    }\n+\n+    /**\n+     * Sets a xml to the entity.\n+     *\n+     * @param xmlPayload The xml {@link BXML} payload.\n+     */\n+    public void setXml(BXML xmlPayload) {\n+        MimeEntityBody.setXml(entityObj, (XMLValue) xmlPayload, MimeConstants.APPLICATION_XML);\n+    }\n+\n+    /**\n+     * Sets a string text content to the entity.\n+     *\n+     * @param textPayload The text payload.\n+     */\n+    public void setText(String textPayload) {\n+        MimeEntityBody.setText(entityObj, textPayload, MimeConstants.TEXT_PLAIN);\n+    }\n+\n+    /**\n+     * Sets a byte[] content to the entity.\n+     *\n+     * @param binaryPayload The byte[] payload.\n+     */\n+    public void setBinary(byte[] binaryPayload) {\n+        MimeEntityBody.setByteArray(entityObj, (ArrayValue) BValueCreator.createArrayValue(binaryPayload),\n+                MimeConstants.OCTET_STREAM);\n+    }\n+\n+    /**\n+     * Set multiparts as the payload.\n+     *\n+     * @param bodyParts   The entities which make up the message body\n+     * @param contentType The content type of the top level message. Set this to override the default\n+     *                    `content-type` header value which is 'multipart/form-data'\n+     */\n+    public void setBodyParts(Entity[] bodyParts, String contentType) {\n+        if (contentType == null) {\n+            contentType = Constants.MULTIPART_FORM_DATA;\n+        }\n+        ObjectValue[] entityObjects = new ObjectValue[bodyParts.length];\n+        for (int index = 0; index < bodyParts.length; index++) {\n+            entityObjects[index] = bodyParts[index].getEntityObj();\n+        }\n+        ArrayValue arrValues = (ArrayValue) BValueCreator\n+                .createArrayValue(entityObjects, new BArrayType(BTypes.typeAny));\n+        MimeEntityBody.setBodyParts(entityObj, arrValues, contentType);\n+    }\n+\n+    /**\n+     * Sets a `ByteChannel`  to the entity.\n+     *\n+     * @param channel - A `ByteChannel` {@link Channel} through which the message payload can be read\n+     * @param contentType The content type of the top level message. Set this to override the default\n+     *                    `content-type` header value which is 'application/octet-stream'\n+     */\n+    public void setByteChannel(Channel channel, String contentType) {\n+        if (contentType == null) {\n+            contentType = Constants.OCTET_STREAM;\n+        }\n+        ObjectValue channelObj = BallerinaValues\n+                .createObjectValue(IOConstants.IO_PACKAGE_ID, Constants.READABLE_BYTE_CHANNEL);\n+        channelObj.addNativeData(IOConstants.BYTE_CHANNEL_NAME, channel);\n+        MimeEntityBody.setByteChannel(entityObj, channelObj, contentType);\n+    }\n+\n+    /**\n+     * Returns the java native object of the ballerina level mime:Entity object.\n+     *\n+     * @return Native ballerina object {@link ObjectValue} representing the entity.\n+     */\n+    public ObjectValue getEntityObj() {\n+        return entityObj;\n+    }\n+\n+    private void constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType type)\n+            throws InterceptorException {\n+        MGWBlockingCallBack callback = new MGWBlockingCallBack(Scheduler.getStrand());\n+        try {\n+            AbstractGetPayloadHandler.constructNonBlockingDataSource(callback, entityObj, type);\n+            callback.sync();\n+        } catch (Exception e) {\n+            // we need to catch all the exceptions including runtime thrown from ballerina side in order to avoid the\n+            // call back syncing process.\n+            String msg = \"Error while getting the payload with type : \" + type.toString();\n+            log.error(msg, e);\n+            callback.notifyFailure();\n+            throw new InterceptorException(msg, e);\n+        }\n+\n+    }\n+\n+\n+", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMjYyNw==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386012627", "bodyText": "Suggested change", "author": "praminda", "createdAt": "2020-02-29T08:37:11Z", "path": "components/micro-gateway-interceptor/src/main/java/org/wso2/micro/gateway/interceptor/Entity.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.micro.gateway.interceptor;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.scheduling.Scheduler;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.jvm.values.XMLValue;\n+import org.ballerinalang.jvm.values.api.BValueCreator;\n+import org.ballerinalang.jvm.values.api.BXML;\n+import org.ballerinalang.mime.nativeimpl.AbstractGetPayloadHandler;\n+import org.ballerinalang.mime.nativeimpl.EntityHeaders;\n+import org.ballerinalang.mime.nativeimpl.MimeEntityBody;\n+import org.ballerinalang.mime.util.MimeConstants;\n+import org.ballerinalang.mime.util.MimeUtil;\n+import org.ballerinalang.stdlib.io.channels.base.Channel;\n+import org.ballerinalang.stdlib.io.utils.IOConstants;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.channels.ByteChannel;\n+\n+/**\n+ * Represents the headers and body of a message. This can be used to represent both the entity of a top level message\n+ * and an entity(body part) inside of a multipart entity.\n+ */\n+public class Entity {\n+\n+    private static final Logger log = LoggerFactory.getLogger(\"ballerina\");\n+    private ObjectValue entityObj;\n+\n+    public Entity(ObjectValue entity) {\n+        this.entityObj = entity;\n+    }\n+\n+    public Entity() {\n+        this.entityObj = BallerinaValues\n+                .createObjectValue(MimeConstants.PROTOCOL_MIME_PKG_ID, MimeConstants.ENTITY, new Object());\n+    }\n+\n+    /**\n+     * Checks whether the requested header key exists in the header map.\n+     *\n+     * @param headerName The header name.\n+     * @return Returns true if the specified header key exists\n+     */\n+    public boolean hasHeader(String headerName) {\n+        return EntityHeaders.hasHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Returns the value of the specified header. If the specified header key maps to multiple values, the first of\n+     * these values is returned.\n+     *\n+     * @param headerName The header name.\n+     * @return The first header value for the specified header name. Null is returned if header does not present.\n+     */\n+    public String getHeader(String headerName) {\n+        if (hasHeader(headerName)) {\n+            return EntityHeaders.getHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets all the header values to which the specified header key maps to.\n+     *\n+     * @param headerName The header name.\n+     * @return The header values the specified header key maps to. Null is returned if header does not present.\n+     */\n+    public String[] getHeaders(String headerName) {\n+        if (hasHeader(headerName)) {\n+            ArrayValue headerArray = EntityHeaders.getHeaders(entityObj, headerName, Constants.LEADING_HEADER);\n+            String[] stringArray;\n+            if ((stringArray = headerArray.getStringArray()) != null) {\n+                return stringArray;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Sets the specified header to the entity. If a mapping already exists for the specified header key, the existing\n+     * header value is replaced with the specified header value.\n+     *\n+     * @param headerName  The header name.\n+     * @param headerValue The header value.\n+     */\n+    public void setHeader(String headerName, String headerValue) {\n+        EntityHeaders.setHeader(entityObj, headerName, headerValue, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Adds the specified header to the entity. Existing header values are not replaced.\n+     *\n+     * @param headerName  The header name.\n+     * @param headerValue The header value.\n+     */\n+    public void addHeader(String headerName, String headerValue) {\n+        EntityHeaders.addHeader(entityObj, headerName, headerValue, Constants.LEADING_HEADER);\n+\n+    }\n+\n+    /**\n+     * Removes the specified header from the entity.\n+     *\n+     * @param headerName The header name.\n+     */\n+    public void removeHeader(String headerName) {\n+        EntityHeaders.removeHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Removes all the headers from the entity.\n+     */\n+    public void removeAllHeaders() {\n+        EntityHeaders.removeAllHeaders(entityObj, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Gets all the names of the headers of the entity. If headers are not present returns an empty array.\n+     *\n+     * @return An array of all the header names.\n+     */\n+    public String[] getHeaderNames() {\n+        ArrayValue headerNames = EntityHeaders.getHeaderNames(entityObj, Constants.LEADING_HEADER);\n+\n+        if (headerNames.getValues() != null) {\n+            Object[] headerObjects = headerNames.getValues();\n+            String[] headers = new String[headerObjects.length];\n+            for (int index = 0; index < headerObjects.length; index++) {\n+                headers[index] = headerObjects[index].toString();\n+            }\n+            return headers;\n+        }\n+        return new String[0];\n+    }\n+\n+    /**\n+     * Extracts `json` payload from the entity. If the content type is not JSON, an exception will be thrown.\n+     *\n+     * @return The `json` payload of the request.\n+     * @throws InterceptorException If error while getting json payload.\n+     */\n+    public JSONObject getJson() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.JSON);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            String jsonPayload = MimeUtil\n+                    .getMessageAsString(entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE));\n+            return new JSONObject(jsonPayload);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Extracts `xml` payload from the entity. If the content type is not XML, an exception will be thrown.\n+     *\n+     * @return {@link BXML} The `xml` payload of the request.\n+     * @throws InterceptorException If error while getting xml payload.\n+     */\n+    public BXML getXml() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.XML);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return (BXML) entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Extracts `text` payload from the entity. If the content type is not text, an exception will be thrown.\n+     *\n+     * @return The `text` payload of the request.\n+     * @throws InterceptorException If error while getting text payload.\n+     */\n+    public String getText() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.TEXT);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return  entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE).toString();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given an entity, gets the entity body as a byte channel\n+     *\n+     * @return {@link ByteChannel} A byte channel from which the message payload can be read.\n+     * @throws InterceptorException If error while getting byte channel of the entity.\n+     */\n+    public ByteChannel getByteChannel() throws InterceptorException {\n+        Object byteChannel = MimeEntityBody.getByteChannel(entityObj);\n+        if (byteChannel instanceof ErrorValue) {\n+            throw new InterceptorException(\"Error while getting byte channel from the entity\",\n+                    ((ErrorValue) byteChannel).getCause());\n+        }\n+        ObjectValue byteChannelObject = (ObjectValue) byteChannel;\n+        Channel channel = ((Channel) byteChannelObject.getNativeData(IOConstants.BYTE_CHANNEL_NAME));\n+        return channel.getByteChannel();\n+    }\n+\n+    /**\n+     * Gets the entity payload as a `byte[]`.\n+     *\n+     * @return The byte[] representation of the message payload\n+     * @throws InterceptorException If error while getting byte array of the entity.\n+     */\n+    public byte[] getByteArray() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.BLOB);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return (byte[]) entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given an entity, gets its body parts. If the entity body is not a set of body parts an exception will be thrown.\n+     *\n+     * @return An array of body parts{@link Entity[]} extracted from the entity body\n+     * @throws InterceptorException If error while getting byte array of the entity.\n+     */\n+    public Entity[] getBodyParts() throws InterceptorException {\n+        Object arrayValue = MimeEntityBody.getBodyParts(entityObj);\n+        if (arrayValue instanceof ErrorValue) {\n+            throw new InterceptorException(\"Error while getting byte array from the request\",\n+                    ((ErrorValue) arrayValue).getCause());\n+        }\n+        Object[] entityObjects = ((ArrayValue) arrayValue).getValues();\n+        Entity[] entities = new Entity[entityObjects.length];\n+        for (int index = 0; index < entityObjects.length; index++) {\n+            entities[index] = new Entity((ObjectValue) entityObjects[index]);\n+        }\n+        return entities;\n+    }\n+\n+    /**\n+     * Sets a json {@link JSONObject} as the payload to the entity.\n+     *\n+     * @param jsonPayload {@link JSONObject} The json payload.\n+     */\n+    public void setJson(JSONObject jsonPayload) {\n+        MimeEntityBody.setJson(entityObj, JSONParser.parse(jsonPayload.toString()), MimeConstants.APPLICATION_JSON);\n+    }\n+\n+    /**\n+     * Sets a xml to the entity.\n+     *\n+     * @param xmlPayload The xml {@link BXML} payload.\n+     */\n+    public void setXml(BXML xmlPayload) {\n+        MimeEntityBody.setXml(entityObj, (XMLValue) xmlPayload, MimeConstants.APPLICATION_XML);\n+    }\n+\n+    /**\n+     * Sets a string text content to the entity.\n+     *\n+     * @param textPayload The text payload.\n+     */\n+    public void setText(String textPayload) {\n+        MimeEntityBody.setText(entityObj, textPayload, MimeConstants.TEXT_PLAIN);\n+    }\n+\n+    /**\n+     * Sets a byte[] content to the entity.\n+     *\n+     * @param binaryPayload The byte[] payload.\n+     */\n+    public void setBinary(byte[] binaryPayload) {\n+        MimeEntityBody.setByteArray(entityObj, (ArrayValue) BValueCreator.createArrayValue(binaryPayload),\n+                MimeConstants.OCTET_STREAM);\n+    }\n+\n+    /**\n+     * Set multiparts as the payload.\n+     *\n+     * @param bodyParts   The entities which make up the message body\n+     * @param contentType The content type of the top level message. Set this to override the default\n+     *                    `content-type` header value which is 'multipart/form-data'\n+     */\n+    public void setBodyParts(Entity[] bodyParts, String contentType) {\n+        if (contentType == null) {\n+            contentType = Constants.MULTIPART_FORM_DATA;\n+        }\n+        ObjectValue[] entityObjects = new ObjectValue[bodyParts.length];\n+        for (int index = 0; index < bodyParts.length; index++) {\n+            entityObjects[index] = bodyParts[index].getEntityObj();\n+        }\n+        ArrayValue arrValues = (ArrayValue) BValueCreator\n+                .createArrayValue(entityObjects, new BArrayType(BTypes.typeAny));\n+        MimeEntityBody.setBodyParts(entityObj, arrValues, contentType);\n+    }\n+\n+    /**\n+     * Sets a `ByteChannel`  to the entity.\n+     *\n+     * @param channel - A `ByteChannel` {@link Channel} through which the message payload can be read\n+     * @param contentType The content type of the top level message. Set this to override the default\n+     *                    `content-type` header value which is 'application/octet-stream'\n+     */\n+    public void setByteChannel(Channel channel, String contentType) {\n+        if (contentType == null) {\n+            contentType = Constants.OCTET_STREAM;\n+        }\n+        ObjectValue channelObj = BallerinaValues\n+                .createObjectValue(IOConstants.IO_PACKAGE_ID, Constants.READABLE_BYTE_CHANNEL);\n+        channelObj.addNativeData(IOConstants.BYTE_CHANNEL_NAME, channel);\n+        MimeEntityBody.setByteChannel(entityObj, channelObj, contentType);\n+    }\n+\n+    /**\n+     * Returns the java native object of the ballerina level mime:Entity object.\n+     *\n+     * @return Native ballerina object {@link ObjectValue} representing the entity.\n+     */\n+    public ObjectValue getEntityObj() {\n+        return entityObj;\n+    }\n+\n+    private void constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType type)\n+            throws InterceptorException {\n+        MGWBlockingCallBack callback = new MGWBlockingCallBack(Scheduler.getStrand());\n+        try {\n+            AbstractGetPayloadHandler.constructNonBlockingDataSource(callback, entityObj, type);\n+            callback.sync();\n+        } catch (Exception e) {\n+            // we need to catch all the exceptions including runtime thrown from ballerina side in order to avoid the\n+            // call back syncing process.\n+            String msg = \"Error while getting the payload with type : \" + type.toString();\n+            log.error(msg, e);\n+            callback.notifyFailure();\n+            throw new InterceptorException(msg, e);\n+        }\n+\n+    }\n+\n+", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMjY1NA==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386012654", "bodyText": "Suggested change", "author": "praminda", "createdAt": "2020-02-29T08:37:32Z", "path": "components/micro-gateway-interceptor/src/main/java/org/wso2/micro/gateway/interceptor/Entity.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *  http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.wso2.micro.gateway.interceptor;\n+\n+import org.ballerinalang.jvm.BallerinaValues;\n+import org.ballerinalang.jvm.JSONParser;\n+import org.ballerinalang.jvm.scheduling.Scheduler;\n+import org.ballerinalang.jvm.types.BArrayType;\n+import org.ballerinalang.jvm.types.BTypes;\n+import org.ballerinalang.jvm.values.ArrayValue;\n+import org.ballerinalang.jvm.values.ErrorValue;\n+import org.ballerinalang.jvm.values.ObjectValue;\n+import org.ballerinalang.jvm.values.XMLValue;\n+import org.ballerinalang.jvm.values.api.BValueCreator;\n+import org.ballerinalang.jvm.values.api.BXML;\n+import org.ballerinalang.mime.nativeimpl.AbstractGetPayloadHandler;\n+import org.ballerinalang.mime.nativeimpl.EntityHeaders;\n+import org.ballerinalang.mime.nativeimpl.MimeEntityBody;\n+import org.ballerinalang.mime.util.MimeConstants;\n+import org.ballerinalang.mime.util.MimeUtil;\n+import org.ballerinalang.stdlib.io.channels.base.Channel;\n+import org.ballerinalang.stdlib.io.utils.IOConstants;\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.channels.ByteChannel;\n+\n+/**\n+ * Represents the headers and body of a message. This can be used to represent both the entity of a top level message\n+ * and an entity(body part) inside of a multipart entity.\n+ */\n+public class Entity {\n+\n+    private static final Logger log = LoggerFactory.getLogger(\"ballerina\");\n+    private ObjectValue entityObj;\n+\n+    public Entity(ObjectValue entity) {\n+        this.entityObj = entity;\n+    }\n+\n+    public Entity() {\n+        this.entityObj = BallerinaValues\n+                .createObjectValue(MimeConstants.PROTOCOL_MIME_PKG_ID, MimeConstants.ENTITY, new Object());\n+    }\n+\n+    /**\n+     * Checks whether the requested header key exists in the header map.\n+     *\n+     * @param headerName The header name.\n+     * @return Returns true if the specified header key exists\n+     */\n+    public boolean hasHeader(String headerName) {\n+        return EntityHeaders.hasHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Returns the value of the specified header. If the specified header key maps to multiple values, the first of\n+     * these values is returned.\n+     *\n+     * @param headerName The header name.\n+     * @return The first header value for the specified header name. Null is returned if header does not present.\n+     */\n+    public String getHeader(String headerName) {\n+        if (hasHeader(headerName)) {\n+            return EntityHeaders.getHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Gets all the header values to which the specified header key maps to.\n+     *\n+     * @param headerName The header name.\n+     * @return The header values the specified header key maps to. Null is returned if header does not present.\n+     */\n+    public String[] getHeaders(String headerName) {\n+        if (hasHeader(headerName)) {\n+            ArrayValue headerArray = EntityHeaders.getHeaders(entityObj, headerName, Constants.LEADING_HEADER);\n+            String[] stringArray;\n+            if ((stringArray = headerArray.getStringArray()) != null) {\n+                return stringArray;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Sets the specified header to the entity. If a mapping already exists for the specified header key, the existing\n+     * header value is replaced with the specified header value.\n+     *\n+     * @param headerName  The header name.\n+     * @param headerValue The header value.\n+     */\n+    public void setHeader(String headerName, String headerValue) {\n+        EntityHeaders.setHeader(entityObj, headerName, headerValue, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Adds the specified header to the entity. Existing header values are not replaced.\n+     *\n+     * @param headerName  The header name.\n+     * @param headerValue The header value.\n+     */\n+    public void addHeader(String headerName, String headerValue) {\n+        EntityHeaders.addHeader(entityObj, headerName, headerValue, Constants.LEADING_HEADER);\n+\n+    }\n+\n+    /**\n+     * Removes the specified header from the entity.\n+     *\n+     * @param headerName The header name.\n+     */\n+    public void removeHeader(String headerName) {\n+        EntityHeaders.removeHeader(entityObj, headerName, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Removes all the headers from the entity.\n+     */\n+    public void removeAllHeaders() {\n+        EntityHeaders.removeAllHeaders(entityObj, Constants.LEADING_HEADER);\n+    }\n+\n+    /**\n+     * Gets all the names of the headers of the entity. If headers are not present returns an empty array.\n+     *\n+     * @return An array of all the header names.\n+     */\n+    public String[] getHeaderNames() {\n+        ArrayValue headerNames = EntityHeaders.getHeaderNames(entityObj, Constants.LEADING_HEADER);\n+\n+        if (headerNames.getValues() != null) {\n+            Object[] headerObjects = headerNames.getValues();\n+            String[] headers = new String[headerObjects.length];\n+            for (int index = 0; index < headerObjects.length; index++) {\n+                headers[index] = headerObjects[index].toString();\n+            }\n+            return headers;\n+        }\n+        return new String[0];\n+    }\n+\n+    /**\n+     * Extracts `json` payload from the entity. If the content type is not JSON, an exception will be thrown.\n+     *\n+     * @return The `json` payload of the request.\n+     * @throws InterceptorException If error while getting json payload.\n+     */\n+    public JSONObject getJson() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.JSON);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            String jsonPayload = MimeUtil\n+                    .getMessageAsString(entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE));\n+            return new JSONObject(jsonPayload);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Extracts `xml` payload from the entity. If the content type is not XML, an exception will be thrown.\n+     *\n+     * @return {@link BXML} The `xml` payload of the request.\n+     * @throws InterceptorException If error while getting xml payload.\n+     */\n+    public BXML getXml() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.XML);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return (BXML) entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Extracts `text` payload from the entity. If the content type is not text, an exception will be thrown.\n+     *\n+     * @return The `text` payload of the request.\n+     * @throws InterceptorException If error while getting text payload.\n+     */\n+    public String getText() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.TEXT);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return  entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE).toString();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given an entity, gets the entity body as a byte channel\n+     *\n+     * @return {@link ByteChannel} A byte channel from which the message payload can be read.\n+     * @throws InterceptorException If error while getting byte channel of the entity.\n+     */\n+    public ByteChannel getByteChannel() throws InterceptorException {\n+        Object byteChannel = MimeEntityBody.getByteChannel(entityObj);\n+        if (byteChannel instanceof ErrorValue) {\n+            throw new InterceptorException(\"Error while getting byte channel from the entity\",\n+                    ((ErrorValue) byteChannel).getCause());\n+        }\n+        ObjectValue byteChannelObject = (ObjectValue) byteChannel;\n+        Channel channel = ((Channel) byteChannelObject.getNativeData(IOConstants.BYTE_CHANNEL_NAME));\n+        return channel.getByteChannel();\n+    }\n+\n+    /**\n+     * Gets the entity payload as a `byte[]`.\n+     *\n+     * @return The byte[] representation of the message payload\n+     * @throws InterceptorException If error while getting byte array of the entity.\n+     */\n+    public byte[] getByteArray() throws InterceptorException {\n+        constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType.BLOB);\n+        if (entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE) != null) {\n+            return (byte[]) entityObj.getNativeData(MimeConstants.MESSAGE_DATA_SOURCE);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Given an entity, gets its body parts. If the entity body is not a set of body parts an exception will be thrown.\n+     *\n+     * @return An array of body parts{@link Entity[]} extracted from the entity body\n+     * @throws InterceptorException If error while getting byte array of the entity.\n+     */\n+    public Entity[] getBodyParts() throws InterceptorException {\n+        Object arrayValue = MimeEntityBody.getBodyParts(entityObj);\n+        if (arrayValue instanceof ErrorValue) {\n+            throw new InterceptorException(\"Error while getting byte array from the request\",\n+                    ((ErrorValue) arrayValue).getCause());\n+        }\n+        Object[] entityObjects = ((ArrayValue) arrayValue).getValues();\n+        Entity[] entities = new Entity[entityObjects.length];\n+        for (int index = 0; index < entityObjects.length; index++) {\n+            entities[index] = new Entity((ObjectValue) entityObjects[index]);\n+        }\n+        return entities;\n+    }\n+\n+    /**\n+     * Sets a json {@link JSONObject} as the payload to the entity.\n+     *\n+     * @param jsonPayload {@link JSONObject} The json payload.\n+     */\n+    public void setJson(JSONObject jsonPayload) {\n+        MimeEntityBody.setJson(entityObj, JSONParser.parse(jsonPayload.toString()), MimeConstants.APPLICATION_JSON);\n+    }\n+\n+    /**\n+     * Sets a xml to the entity.\n+     *\n+     * @param xmlPayload The xml {@link BXML} payload.\n+     */\n+    public void setXml(BXML xmlPayload) {\n+        MimeEntityBody.setXml(entityObj, (XMLValue) xmlPayload, MimeConstants.APPLICATION_XML);\n+    }\n+\n+    /**\n+     * Sets a string text content to the entity.\n+     *\n+     * @param textPayload The text payload.\n+     */\n+    public void setText(String textPayload) {\n+        MimeEntityBody.setText(entityObj, textPayload, MimeConstants.TEXT_PLAIN);\n+    }\n+\n+    /**\n+     * Sets a byte[] content to the entity.\n+     *\n+     * @param binaryPayload The byte[] payload.\n+     */\n+    public void setBinary(byte[] binaryPayload) {\n+        MimeEntityBody.setByteArray(entityObj, (ArrayValue) BValueCreator.createArrayValue(binaryPayload),\n+                MimeConstants.OCTET_STREAM);\n+    }\n+\n+    /**\n+     * Set multiparts as the payload.\n+     *\n+     * @param bodyParts   The entities which make up the message body\n+     * @param contentType The content type of the top level message. Set this to override the default\n+     *                    `content-type` header value which is 'multipart/form-data'\n+     */\n+    public void setBodyParts(Entity[] bodyParts, String contentType) {\n+        if (contentType == null) {\n+            contentType = Constants.MULTIPART_FORM_DATA;\n+        }\n+        ObjectValue[] entityObjects = new ObjectValue[bodyParts.length];\n+        for (int index = 0; index < bodyParts.length; index++) {\n+            entityObjects[index] = bodyParts[index].getEntityObj();\n+        }\n+        ArrayValue arrValues = (ArrayValue) BValueCreator\n+                .createArrayValue(entityObjects, new BArrayType(BTypes.typeAny));\n+        MimeEntityBody.setBodyParts(entityObj, arrValues, contentType);\n+    }\n+\n+    /**\n+     * Sets a `ByteChannel`  to the entity.\n+     *\n+     * @param channel - A `ByteChannel` {@link Channel} through which the message payload can be read\n+     * @param contentType The content type of the top level message. Set this to override the default\n+     *                    `content-type` header value which is 'application/octet-stream'\n+     */\n+    public void setByteChannel(Channel channel, String contentType) {\n+        if (contentType == null) {\n+            contentType = Constants.OCTET_STREAM;\n+        }\n+        ObjectValue channelObj = BallerinaValues\n+                .createObjectValue(IOConstants.IO_PACKAGE_ID, Constants.READABLE_BYTE_CHANNEL);\n+        channelObj.addNativeData(IOConstants.BYTE_CHANNEL_NAME, channel);\n+        MimeEntityBody.setByteChannel(entityObj, channelObj, contentType);\n+    }\n+\n+    /**\n+     * Returns the java native object of the ballerina level mime:Entity object.\n+     *\n+     * @return Native ballerina object {@link ObjectValue} representing the entity.\n+     */\n+    public ObjectValue getEntityObj() {\n+        return entityObj;\n+    }\n+\n+    private void constructPayloadBlockingCallBack(AbstractGetPayloadHandler.SourceType type)\n+            throws InterceptorException {\n+        MGWBlockingCallBack callback = new MGWBlockingCallBack(Scheduler.getStrand());\n+        try {\n+            AbstractGetPayloadHandler.constructNonBlockingDataSource(callback, entityObj, type);\n+            callback.sync();\n+        } catch (Exception e) {\n+            // we need to catch all the exceptions including runtime thrown from ballerina side in order to avoid the\n+            // call back syncing process.\n+            String msg = \"Error while getting the payload with type : \" + type.toString();\n+            log.error(msg, e);\n+            callback.notifyFailure();\n+            throw new InterceptorException(msg, e);\n+        }\n+", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMjc3Ng==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386012776", "bodyText": "Missing License header\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.wso2.micro.gateway.interceptor;\n          \n          \n            \n            /*\n          \n          \n            \n             *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n          \n          \n            \n             *\n          \n          \n            \n             *  Licensed under the Apache License, Version 2.0 (the \"License\");\n          \n          \n            \n             *  you may not use this file except in compliance with the License.\n          \n          \n            \n             *  You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *  http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             *  Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             *  distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             *  See the License for the specific language governing permissions and\n          \n          \n            \n             *  limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            package org.wso2.micro.gateway.interceptor;", "author": "praminda", "createdAt": "2020-02-29T08:40:30Z", "path": "components/micro-gateway-interceptor/src/main/java/org/wso2/micro/gateway/interceptor/Utils.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.wso2.micro.gateway.interceptor;", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMjgwMA==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386012800", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.wso2.micro.gateway.interceptor;\n          \n          \n            \n            /*\n          \n          \n            \n             *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n          \n          \n            \n             *\n          \n          \n            \n             *  Licensed under the Apache License, Version 2.0 (the \"License\");\n          \n          \n            \n             *  you may not use this file except in compliance with the License.\n          \n          \n            \n             *  You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *  http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             *  Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             *  distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             *  See the License for the specific language governing permissions and\n          \n          \n            \n             *  limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            package org.wso2.micro.gateway.interceptor;", "author": "praminda", "createdAt": "2020-02-29T08:40:48Z", "path": "components/micro-gateway-interceptor/src/main/java/org/wso2/micro/gateway/interceptor/MGWBlockingCallBack.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.wso2.micro.gateway.interceptor;", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMjgzOA==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386012838", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.wso2.micro.gateway.interceptor;\n          \n          \n            \n            /*\n          \n          \n            \n             *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n          \n          \n            \n             *\n          \n          \n            \n             *  Licensed under the Apache License, Version 2.0 (the \"License\");\n          \n          \n            \n             *  you may not use this file except in compliance with the License.\n          \n          \n            \n             *  You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *  http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             *  Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             *  distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             *  See the License for the specific language governing permissions and\n          \n          \n            \n             *  limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            package org.wso2.micro.gateway.interceptor;", "author": "praminda", "createdAt": "2020-02-29T08:41:00Z", "path": "components/micro-gateway-interceptor/src/main/java/org/wso2/micro/gateway/interceptor/InterceptorUtils.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package org.wso2.micro.gateway.interceptor;", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMjk3NA==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386012974", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.wso2.micro.gateway.tests.interceptor;\n          \n          \n            \n            /*\n          \n          \n            \n             *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n          \n          \n            \n             *\n          \n          \n            \n             *  Licensed under the Apache License, Version 2.0 (the \"License\");\n          \n          \n            \n             *  you may not use this file except in compliance with the License.\n          \n          \n            \n             *  You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *  http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             *  Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             *  distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             *  See the License for the specific language governing permissions and\n          \n          \n            \n             *  limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            package org.wso2.micro.gateway.tests.interceptor;", "author": "praminda", "createdAt": "2020-02-29T08:43:27Z", "path": "tests/src/main/java/org/wso2/micro/gateway/tests/interceptor/TestInterceptor.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package org.wso2.micro.gateway.tests.interceptor;", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMzAzMA==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386013030", "bodyText": "Suggested change", "author": "praminda", "createdAt": "2020-02-29T08:44:41Z", "path": "tests/src/main/java/org/wso2/micro/gateway/tests/interceptor/TestInterceptor.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package org.wso2.micro.gateway.tests.interceptor;\n+\n+import org.json.JSONObject;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.wso2.micro.gateway.interceptor.Caller;\n+import org.wso2.micro.gateway.interceptor.Interceptor;\n+import org.wso2.micro.gateway.interceptor.InterceptorException;\n+import org.wso2.micro.gateway.interceptor.Request;\n+import org.wso2.micro.gateway.interceptor.Response;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.channels.ByteChannel;\n+import java.nio.channels.Channels;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+/**\n+ * Implements sample interceptor for the integration test cases.\n+ */\n+public class TestInterceptor implements Interceptor {\n+\n+    private static final Logger log = LoggerFactory.getLogger(\"ballerina\");\n+    private  String responseString = \"\";\n+\n+    @Override\n+    public boolean interceptRequest(Caller caller, Request request) {\n+        responseString = \"\";\n+        String contentType = request.getHeader(\"content-type\");\n+        appendResponseString(contentType);\n+        appendResponseString(getAllHeaders(request));\n+        appendResponseString(request.getRequestPath());\n+        appendResponseString(request.getRequestHttpMethod());\n+        appendResponseString(request.getRequestHttpVersion());\n+        appendResponseString(request.getQueryParams().toString());\n+        appendResponseString(request.getQueryParamValue(\"test\"));\n+        if (\"application/json\".equals(contentType)) {\n+            try {\n+                appendResponseString(request.getJsonPayload().toString());\n+            } catch (InterceptorException e) {\n+                log.error(\"Error while getting json payload \", e);\n+            }\n+        }\n+\n+        if (\"application/xml\".equals(contentType) || \"text/xml\".equals(contentType)) {\n+            try {\n+                appendResponseString(request.getXmlPayload().toString());\n+            } catch (InterceptorException e) {\n+                log.error(\"Error while getting xml payload \", e);\n+            }\n+        }\n+\n+        if (\"application/x-www-form-urlencoded\".equals(contentType)) {\n+            appendResponseString(getByteChannel(request));\n+        }\n+\n+        respondFromRequest(caller);\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean interceptResponse(Caller caller, Response response) {\n+        String contentType = response.getHeader(\"content-type\");\n+        Response response1 = new Response();\n+        response1.setResponseCode(201);\n+        response1.addHeader(\"test\", \"value1\");\n+        response1.setHeader(\"content-type\", contentType);\n+        JSONObject responseObject = new JSONObject();\n+        responseObject.put(\"name\", \"jon doe\");\n+        responseObject.put(\"age\", \"22\");\n+        responseObject.put(\"city\", \"chicago\");\n+        response1.setJsonPayload(responseObject);\n+        caller.respond(response1);\n+        return false;\n+    }\n+\n+    public String getAllHeaders(Request request) {\n+        String headerString = \"\";\n+        String[] headers = request.getHeaderNames();\n+        for (String heeader : headers) {\n+            headerString += heeader + \":\";\n+        }\n+        return headerString;\n+    }\n+\n+    public String getByteChannel(Request request) {\n+        try {\n+            ByteChannel byteChannel = request.getByteChannel();\n+            InputStream in = Channels.newInputStream(byteChannel);\n+            StringBuilder textBuilder = new StringBuilder();\n+            try (Reader reader = new BufferedReader(\n+                    new InputStreamReader(in, Charset.forName(StandardCharsets.UTF_8.name())))) {\n+                int c = 0;\n+                while ((c = reader.read()) != -1) {\n+                    textBuilder.append((char) c);\n+                }\n+                return textBuilder.toString();\n+            }\n+        } catch (InterceptorException | IOException e) {\n+            log.error(\"Error while reading the the byte channel\", e);\n+        }\n+        return \"\";\n+    }\n+\n+    public void respondFromRequest(Caller caller) {\n+        Response response = new Response();\n+        response.setTextPayload(responseString);\n+        caller.respond(response);\n+    }\n+\n+    public  void appendResponseString(String response) {\n+        responseString += \":\" + response;\n+    }\n+}\n+", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMzA0MA==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386013040", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package org.wso2.micro.gateway.tests.interceptor;\n          \n          \n            \n            /*\n          \n          \n            \n             *  Copyright (c) 2020, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.\n          \n          \n            \n             *\n          \n          \n            \n             *  Licensed under the Apache License, Version 2.0 (the \"License\");\n          \n          \n            \n             *  you may not use this file except in compliance with the License.\n          \n          \n            \n             *  You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *  http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             *  Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             *  distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             *  See the License for the specific language governing permissions and\n          \n          \n            \n             *  limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            package org.wso2.micro.gateway.tests.interceptor;", "author": "praminda", "createdAt": "2020-02-29T08:45:04Z", "path": "tests/src/test/java/org/wso2/micro/gateway/tests/interceptor/JavaInterceptorTestCase.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.wso2.micro.gateway.tests.interceptor;", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMzA0NQ==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386013045", "bodyText": "Suggested change", "author": "praminda", "createdAt": "2020-02-29T08:45:14Z", "path": "tests/src/test/java/org/wso2/micro/gateway/tests/interceptor/JavaInterceptorTestCase.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.wso2.micro.gateway.tests.interceptor;\n+\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+import org.wso2.micro.gateway.tests.common.ResponseConstants;\n+import org.wso2.micro.gateway.tests.util.HttpClientRequest;\n+import org.wso2.micro.gateway.tests.util.HttpResponse;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * This test class is used to test java request and response interceptors data retrieval operations. I.E get operations\n+ * of the request and response\n+ */\n+public class JavaInterceptorTestCase extends InterceptorTestCase {\n+", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMzA1MA==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386013050", "bodyText": "Suggested change", "author": "praminda", "createdAt": "2020-02-29T08:45:23Z", "path": "tests/src/test/java/org/wso2/micro/gateway/tests/interceptor/JavaInterceptorTestCase.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.wso2.micro.gateway.tests.interceptor;\n+\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+import org.wso2.micro.gateway.tests.common.ResponseConstants;\n+import org.wso2.micro.gateway.tests.util.HttpClientRequest;\n+import org.wso2.micro.gateway.tests.util.HttpResponse;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * This test class is used to test java request and response interceptors data retrieval operations. I.E get operations\n+ * of the request and response\n+ */\n+public class JavaInterceptorTestCase extends InterceptorTestCase {\n+\n+\n+    @Test(description = \"Test java interceptor request data retrieval with json payload\")\n+    public void testGetRequestJsonBodyInterceptor() throws Exception {\n+        Map<String, String> headers = new HashMap<>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        headers.put(HttpHeaderNames.CONTENT_TYPE.toString(), \"application/json\");\n+        HttpResponse response = HttpClientRequest\n+                .doPost(getServiceURLHttp(\"/petstore/v1/user?test=value1&test2=value2\"), \"{'hello':'world'}\", headers);\n+        Assert.assertNotNull(response);\n+        Assert.assertEquals(response.getData(), ResponseConstants.JSON_RESPONSE);\n+        Assert.assertEquals(response.getResponseCode(), 200, \"Response code mismatched\");\n+    }\n+\n+    @Test(description = \"Test java interceptor request data retrieval with  xml payload\")\n+    public void testGetRequestXmlBodyInterceptor() throws Exception {\n+        Map<String, String> headers = new HashMap<>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        headers.put(HttpHeaderNames.CONTENT_TYPE.toString(), \"text/xml\");\n+        String xmlPayload = \"<test><msg>hello</msg></test>\";\n+        HttpResponse response = HttpClientRequest\n+                .doPost(getServiceURLHttp(\"/petstore/v1/user?test=value1&test2=value2\"), xmlPayload, headers);\n+        Assert.assertNotNull(response);\n+        Assert.assertEquals(response.getData(), ResponseConstants.XML_RESPONSE);\n+        Assert.assertEquals(response.getResponseCode(), 200, \"Response code mismatched\");\n+    }\n+\n+    @Test(description = \"Test java interceptor response set json payload\")\n+    public void testSetResponseXmlBodyInterceptor() throws Exception {\n+        Map<String, String> headers = new HashMap<>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse response = HttpClientRequest\n+                .doGet(getServiceURLHttp(\"/petstore/v1/pet/1\"), headers);\n+        Assert.assertNotNull(response);\n+        Assert.assertEquals(response.getHeaders().get(\"test\"), \"value1\");\n+        Assert.assertTrue(response.getData().contains(\"jon doe\"));\n+        Assert.assertEquals(response.getResponseCode(), 201, \"Response code mismatched\");\n+    }\n+\n+", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxMzA1NA==", "url": "https://github.com/wso2/product-microgateway/pull/1069#discussion_r386013054", "bodyText": "Suggested change", "author": "praminda", "createdAt": "2020-02-29T08:45:31Z", "path": "tests/src/test/java/org/wso2/micro/gateway/tests/interceptor/JavaInterceptorTestCase.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package org.wso2.micro.gateway.tests.interceptor;\n+\n+import io.netty.handler.codec.http.HttpHeaderNames;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.Test;\n+import org.wso2.micro.gateway.tests.common.ResponseConstants;\n+import org.wso2.micro.gateway.tests.util.HttpClientRequest;\n+import org.wso2.micro.gateway.tests.util.HttpResponse;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * This test class is used to test java request and response interceptors data retrieval operations. I.E get operations\n+ * of the request and response\n+ */\n+public class JavaInterceptorTestCase extends InterceptorTestCase {\n+\n+\n+    @Test(description = \"Test java interceptor request data retrieval with json payload\")\n+    public void testGetRequestJsonBodyInterceptor() throws Exception {\n+        Map<String, String> headers = new HashMap<>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        headers.put(HttpHeaderNames.CONTENT_TYPE.toString(), \"application/json\");\n+        HttpResponse response = HttpClientRequest\n+                .doPost(getServiceURLHttp(\"/petstore/v1/user?test=value1&test2=value2\"), \"{'hello':'world'}\", headers);\n+        Assert.assertNotNull(response);\n+        Assert.assertEquals(response.getData(), ResponseConstants.JSON_RESPONSE);\n+        Assert.assertEquals(response.getResponseCode(), 200, \"Response code mismatched\");\n+    }\n+\n+    @Test(description = \"Test java interceptor request data retrieval with  xml payload\")\n+    public void testGetRequestXmlBodyInterceptor() throws Exception {\n+        Map<String, String> headers = new HashMap<>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        headers.put(HttpHeaderNames.CONTENT_TYPE.toString(), \"text/xml\");\n+        String xmlPayload = \"<test><msg>hello</msg></test>\";\n+        HttpResponse response = HttpClientRequest\n+                .doPost(getServiceURLHttp(\"/petstore/v1/user?test=value1&test2=value2\"), xmlPayload, headers);\n+        Assert.assertNotNull(response);\n+        Assert.assertEquals(response.getData(), ResponseConstants.XML_RESPONSE);\n+        Assert.assertEquals(response.getResponseCode(), 200, \"Response code mismatched\");\n+    }\n+\n+    @Test(description = \"Test java interceptor response set json payload\")\n+    public void testSetResponseXmlBodyInterceptor() throws Exception {\n+        Map<String, String> headers = new HashMap<>();\n+        headers.put(HttpHeaderNames.AUTHORIZATION.toString(), \"Bearer \" + jwtTokenProd);\n+        HttpResponse response = HttpClientRequest\n+                .doGet(getServiceURLHttp(\"/petstore/v1/pet/1\"), headers);\n+        Assert.assertNotNull(response);\n+        Assert.assertEquals(response.getHeaders().get(\"test\"), \"value1\");\n+        Assert.assertTrue(response.getData().contains(\"jon doe\"));\n+        Assert.assertEquals(response.getResponseCode(), 201, \"Response code mismatched\");\n+    }\n+\n+\n+    @AfterClass\n+    public void stop() throws Exception {\n+        //Stop all the mock servers\n+        super.finalize();\n+    }\n+}\n+\n+", "originalCommit": "9c1248918116b395796ed3796cffb31a910731f0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9855a166b25dfe0c7236131460df04079bc0d775", "url": "https://github.com/wso2/product-microgateway/commit/9855a166b25dfe0c7236131460df04079bc0d775", "message": "Apply suggestions from code review\n\nCo-Authored-By: Praminda <pramindabj@gmail.com>", "committedDate": "2020-02-29T08:51:59Z", "type": "commit"}]}