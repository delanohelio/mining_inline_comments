{"pr_number": 1368, "pr_title": "Introduce conditional throttling", "pr_createdAt": "2020-08-05T08:03:07Z", "pr_url": "https://github.com/wso2/product-microgateway/pull/1368", "timeline": [{"oid": "1b93b7b9c0ecabf786326ea7239196dced684e41", "url": "https://github.com/wso2/product-microgateway/commit/1b93b7b9c0ecabf786326ea7239196dced684e41", "message": "throttle: Publish conditional properties\n\nConfigurations are added to enable conditional data publishing.\nThis is required to prevent unneccesaray processing of conditional\nthrottle data.", "committedDate": "2020-08-05T07:35:06Z", "type": "commit"}, {"oid": "b08c97259ee6b07012509215d0756cc69af4230d", "url": "https://github.com/wso2/product-microgateway/commit/b08c97259ee6b07012509215d0756cc69af4230d", "message": "throttle: Extract condition info from key\n\ninterop is used to get the regex functionalities missing in b7a", "committedDate": "2020-08-05T07:35:06Z", "type": "commit"}, {"oid": "2831fb891ca0322263db73b32644c428f523da6e", "url": "https://github.com/wso2/product-microgateway/commit/2831fb891ca0322263db73b32644c428f523da6e", "message": "throttle: Store conditions in a map", "committedDate": "2020-08-05T07:35:06Z", "type": "commit"}, {"oid": "4d835af03ddfb08d4be3583b785f38096e8bde6c", "url": "https://github.com/wso2/product-microgateway/commit/4d835af03ddfb08d4be3583b785f38096e8bde6c", "message": "throttle: Add conditional info dto\n\nUsed to easily pass around the data required to evaluated\nconditional throttle decisions.", "committedDate": "2020-08-05T07:35:06Z", "type": "commit"}, {"oid": "a6c441bcec5f737b61998a4815c1003e67ab7fa6", "url": "https://github.com/wso2/product-microgateway/commit/a6c441bcec5f737b61998a4815c1003e67ab7fa6", "message": "throttle: Evaluate conditional decisions", "committedDate": "2020-08-05T07:35:06Z", "type": "commit"}, {"oid": "97b056be2bd6a025096f3615e4c95be37dad441a", "url": "https://github.com/wso2/product-microgateway/commit/97b056be2bd6a025096f3615e4c95be37dad441a", "message": "throttle: Evaluate TM decisions separately\n\n(Api, resource) level decisions and other level of decisions are\nnow separately evaluated because with conditional throttling,\nlogic to check API and resource level throttling has changed.", "committedDate": "2020-08-05T07:56:41Z", "type": "commit"}, {"oid": "f75d2009ebdde09634ae2654a766be92b5c3255d", "url": "https://github.com/wso2/product-microgateway/commit/f75d2009ebdde09634ae2654a766be92b5c3255d", "message": "throttle: Publish jwt claims\n\nif jwt claim conditions and backend jwt is enabled, publish jwt\nclaims in the throttle event", "committedDate": "2020-08-05T07:57:12Z", "type": "commit"}, {"oid": "d4449279dca17e2be3898964f46701494a5af0ac", "url": "https://github.com/wso2/product-microgateway/commit/d4449279dca17e2be3898964f46701494a5af0ac", "message": "throttle: Evaluate jwt claim decisions", "committedDate": "2020-08-05T07:57:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjE5ODMzOA==", "url": "https://github.com/wso2/product-microgateway/pull/1368#discussion_r466198338", "bodyText": "Suggested change", "author": "praminda", "createdAt": "2020-08-06T07:23:54Z", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "diffHunk": "@@ -61,6 +67,86 @@ public function isRequestThrottled(string key) returns [boolean, boolean] {\n     return [isThrottled, false];\n }\n \n+# Decide whether request details provided in arguments is throttled or not by the global traffic manager.\n+# This function is deinfed to evalute only API and Resource level throttling decisions recieved from the\n+# traffic manager.\n+#\n+# + key - throttle key of the request\n+# + info - request details required to make conditional throttle decisions\n+# + return - [is request throttled, should stop on quota]\n+public function isApiThrottledByTM(string key, ConditionalThrottleInfo? info) returns [boolean, boolean] {\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data map : \" + throttleDataMap.toString());\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data key : \" + key);\n+    boolean isThrottled = false;\n+    boolean stopOnQuota = false;\n+\n+    if (enabledGlobalTMEventPublishing == false) {\n+        return [false, false];\n+    }\n+    boolean hasThrottledCondition = conditionDataMap.hasKey(key);\n+    printDebug(KEY_THROTTLE_UTIL, \"hasThrottledCondition : \" + hasThrottledCondition.toString());\n+\n+    if (hasThrottledCondition && (info is ConditionalThrottleInfo)) {\n+        // get the condition groups for provided throttleKey\n+        map<ConditionDto[]> conditionGrps = conditionDataMap.get(key);\n+        string? conditionKey = ();\n+\n+        // iterate through all available conditions and find if the current request\n+        // attributes are eligible to be throttled by the available throttled conditions\n+        foreach var [name, dto] in conditionGrps.entries() {\n+            if (DEFAULT_THROTTLE_CONDITION != name) {\n+                boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+                if (isPipelineThrottled) {\n+                    conditionKey = name;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (conditionKey is () && conditionGrps.hasKey(DEFAULT_THROTTLE_CONDITION)) {\n+            ConditionDto[] dto = conditionGrps.get(DEFAULT_THROTTLE_CONDITION);\n+            boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+            if (!isPipelineThrottled) {\n+                conditionKey = DEFAULT_THROTTLE_CONDITION;\n+", "originalCommit": "d4449279dca17e2be3898964f46701494a5af0ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwMTc1Mw==", "url": "https://github.com/wso2/product-microgateway/pull/1368#discussion_r466201753", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    _ = throttleDataMap.remove(key);\n          \n          \n            \n                                    _ = throttleDataMap.remove(combinedThrottleKey);", "author": "praminda", "createdAt": "2020-08-06T07:30:41Z", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "diffHunk": "@@ -61,6 +67,86 @@ public function isRequestThrottled(string key) returns [boolean, boolean] {\n     return [isThrottled, false];\n }\n \n+# Decide whether request details provided in arguments is throttled or not by the global traffic manager.\n+# This function is deinfed to evalute only API and Resource level throttling decisions recieved from the\n+# traffic manager.\n+#\n+# + key - throttle key of the request\n+# + info - request details required to make conditional throttle decisions\n+# + return - [is request throttled, should stop on quota]\n+public function isApiThrottledByTM(string key, ConditionalThrottleInfo? info) returns [boolean, boolean] {\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data map : \" + throttleDataMap.toString());\n+    printDebug(KEY_THROTTLE_UTIL, \"throttle data key : \" + key);\n+    boolean isThrottled = false;\n+    boolean stopOnQuota = false;\n+\n+    if (enabledGlobalTMEventPublishing == false) {\n+        return [false, false];\n+    }\n+    boolean hasThrottledCondition = conditionDataMap.hasKey(key);\n+    printDebug(KEY_THROTTLE_UTIL, \"hasThrottledCondition : \" + hasThrottledCondition.toString());\n+\n+    if (hasThrottledCondition && (info is ConditionalThrottleInfo)) {\n+        // get the condition groups for provided throttleKey\n+        map<ConditionDto[]> conditionGrps = conditionDataMap.get(key);\n+        string? conditionKey = ();\n+\n+        // iterate through all available conditions and find if the current request\n+        // attributes are eligible to be throttled by the available throttled conditions\n+        foreach var [name, dto] in conditionGrps.entries() {\n+            if (DEFAULT_THROTTLE_CONDITION != name) {\n+                boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+                if (isPipelineThrottled) {\n+                    conditionKey = name;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (conditionKey is () && conditionGrps.hasKey(DEFAULT_THROTTLE_CONDITION)) {\n+            ConditionDto[] dto = conditionGrps.get(DEFAULT_THROTTLE_CONDITION);\n+            boolean isPipelineThrottled = isThrottledByCondition(dto, info);\n+            if (!isPipelineThrottled) {\n+                conditionKey = DEFAULT_THROTTLE_CONDITION;\n+\n+            }\n+        }\n+\n+        // if we detect the request is throttled by a condition. Then check the validity of throttle\n+        // decision from the throttle event data available in the throttleDataMap\n+        if (conditionKey is string) {\n+            printDebug(KEY_THROTTLE_UTIL, \"throttled with condition: \" + conditionKey);\n+            string combinedThrottleKey = key + \"_\" + conditionKey;\n+\n+            // if throttle data is not available for the combined key, conditional throttle decision\n+            // is no longer valid\n+            if (!throttleDataMap.hasKey(combinedThrottleKey)) {\n+                return [false, false];\n+            }\n+            var dto = throttleDataMap.get(combinedThrottleKey);\n+            if (dto is GlobalThrottleStreamDTO) {\n+                int currentTime = time:currentTime().time;\n+                int? resetTimestamp = dto.resetTimestamp;\n+                stopOnQuota = true;\n+                if (resetTimestamp is int) {\n+                    if (resetTimestamp < currentTime) {\n+                        _ = throttleDataMap.remove(key);", "originalCommit": "d4449279dca17e2be3898964f46701494a5af0ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjIwMzI5OQ==", "url": "https://github.com/wso2/product-microgateway/pull/1368#discussion_r466203299", "bodyText": "check decode.customClaims.hasKey scenario", "author": "praminda", "createdAt": "2020-08-06T07:33:45Z", "path": "components/micro-gateway-core/src/main/ballerina/src/gateway/utils/throttle_util.bal", "diffHunk": "@@ -241,3 +351,227 @@ function modifyIpWithNumericRanges(IPRangeDTO ipRange) {\n     }\n }\n \n+\n+# Build a list of `ConditionDto`s from the provided base64 encoded condition list.\n+#\n+# + base64Conditions - A base64 encoded json string containing the list of conditions\n+# evaluated by the throttle engine to take the throttle decision.\n+# + return - A list of conditions evaluated during making the throttle decision. Incase of an\n+# error during converting the conditions, empty `ConditionDto[]` will be returned\n+function extractConditionDto(string base64Conditions) returns ConditionDto[] {\n+    ConditionDto[] conditions = [];\n+    byte[]|error base64Decoded = encoding:decodeBase64Url(base64Conditions);\n+    if (base64Decoded is byte[]) {\n+        string|error result = strings:fromBytes(base64Decoded);\n+        if (result is error) {\n+            printError(KEY_THROTTLE_UTIL, result.reason(), result);\n+        }\n+\n+        string conditionsPayload = <string>result;\n+        json[] | error jsonPayload = <json[]>conditionsPayload.fromJsonString();\n+\n+        if (jsonPayload is json[]) {\n+            printDebug(KEY_THROTTLE_UTIL, \"Decoded throttle conditions json :\" + jsonPayload.toJsonString());\n+\n+            foreach json condition in jsonPayload {\n+                ConditionDto conditionDto = {};\n+                var jIpSpecific = condition.ipspecific;\n+                var jIpRange = condition.iprange;\n+                var jHeader = condition.header;\n+                var jQuery = condition.queryparametertype;\n+                var jJwt = condition.jwtclaims;\n+\n+                // Build IP condition DTOs\n+                if (jIpSpecific is json) {\n+                    IPCondition ip = {\n+                        specificIp: jIpSpecific.specificIp.toString(),\n+                        invert: <boolean>jIpSpecific.invert\n+                    };\n+                    conditionDto.ipCondition = ip;\n+                } else if (jIpRange is json) {\n+                    IPCondition ip = {\n+                        startingIp: jIpRange.startingIp.toString(),\n+                        endingIp: jIpRange.endingIp.toString(),\n+                        invert: <boolean>jIpRange.invert\n+                    };\n+                    conditionDto.ipRangeCondition = ip;\n+                }\n+\n+                // Build header condition DTOs\n+                if (jHeader is json) {\n+                    var header = HeaderConditions.constructFrom(jHeader);\n+                    if (header is HeaderConditions) {\n+                        conditionDto.headerConditions = header;\n+                    } else {\n+                        printError(KEY_THROTTLE_UTIL, \"HeaderCondition is not in the expected format\", header);\n+                    }\n+                }\n+\n+                // Build query param condition DTOs\n+                if (jQuery is json) {\n+                    var query = QueryParamConditions.constructFrom(jQuery);\n+                    if (query is QueryParamConditions) {\n+                        conditionDto.queryParamConditions = query;\n+                    } else {\n+                        printError(KEY_THROTTLE_UTIL, \"QueryParamCondition is not in the expected format\", query);\n+                    }\n+                }\n+\n+                // Build jwt condition DTOs\n+                if (jJwt is json) {\n+                    var jwt = JwtConditions.constructFrom(jJwt);\n+                    if (jwt is JwtConditions) {\n+                        conditionDto.jwtClaimConditions = jwt;\n+                    } else {\n+                        printError(KEY_THROTTLE_UTIL, \"JwtConditions is not in the expected format\", jwt);\n+                    }\n+                }\n+\n+                conditions.push(conditionDto);\n+            }\n+        } else {\n+            printError(KEY_THROTTLE_UTIL, \"Couldn't build a valid json from the throttle conditions\", jsonPayload);\n+        }\n+    } else {\n+        printError(KEY_THROTTLE_UTIL, \"Couldn't decode throttle conditions\", base64Decoded);\n+    }\n+\n+    return conditions;\n+}\n+\n+# Check if the request is throttled by an advanced throttle condition.\n+# Such as IP, header, query param based conditions.\n+#\n+# + conditions - throttled conditions recieved from global throttle engine\n+# + info - information required to derive conditional throttle status\n+# + return - `true` if throttled by a condition, `false` otherwise\n+function isThrottledByCondition(ConditionDto[] conditions, ConditionalThrottleInfo info) returns boolean {\n+    boolean isThrottled = false;\n+\n+    foreach ConditionDto condition in conditions {\n+        // We initially set throttled flag to true. Then we move onto evaluating all conditions and\n+        // set the flag to false accordingly. This is done in this way to implement the `AND` logic\n+        // between each condition inside a condition group.\n+        isThrottled = true;\n+        HeaderConditions? headerConditions = condition?.headerConditions;\n+        IPCondition? ipCondition = condition?.ipCondition;\n+        IPCondition? ipRangeCondition = condition?.ipRangeCondition;\n+        QueryParamConditions? queryConditions = condition?.queryParamConditions;\n+        JwtConditions? claimConditions = condition?.jwtClaimConditions;\n+\n+        if (ipCondition is IPCondition) {\n+            if (!isMatchingIp(info.clientIp, ipCondition)) {\n+                isThrottled = false;\n+            }\n+        } else if (ipRangeCondition is IPCondition) {\n+            if (!isWithinIpRange(info.clientIp, ipRangeCondition)) {\n+                isThrottled = false;\n+            }\n+        }\n+        if (info.isHeaderConditionsEnabled && (headerConditions is HeaderConditions)) {\n+            if (!isHeaderPresent(info.request, headerConditions)) {\n+                isThrottled = false;\n+            }\n+        }\n+        if (info.isQueryConditionsEnabled && (queryConditions is QueryParamConditions)) {\n+            if (!isQueryParamPresent(info.request, queryConditions)) {\n+                isThrottled = false;\n+            }\n+        }\n+        if (info.isJwtConditionsEnabled && (claimConditions is JwtConditions)) {\n+            if (!isClaimPresent(info.request, claimConditions)) {\n+                isThrottled = false;\n+            }\n+        }\n+\n+        if (isThrottled) {\n+            break;\n+        }\n+    }\n+\n+    return isThrottled;\n+}\n+\n+function isMatchingIp(string clientIp, IPCondition ipCondition) returns boolean {\n+    string longIp = ipToBigInteger(clientIp);\n+    boolean isMatched = (longIp == ipCondition.specificIp);\n+\n+    if (ipCondition.invert) {\n+        return !isMatched;\n+    }\n+\n+    return isMatched;\n+}\n+\n+function isWithinIpRange(string clientIp, IPCondition ipCondition) returns boolean {\n+    boolean isMatched = isIpWithinRange(clientIp, ipCondition.startingIp, ipCondition.endingIp);\n+\n+    if (ipCondition.invert) {\n+        return !isMatched;\n+    }\n+\n+    return isMatched;\n+}\n+\n+function isHeaderPresent(http:Request req, HeaderConditions conditions) returns boolean {\n+    boolean status = true;\n+\n+    foreach var [name, value] in conditions.values.entries() {\n+        if (req.hasHeader(name)) {\n+            string headerVal = req.getHeader(name);\n+            if (headerVal != \"\") {\n+                status = status && isPatternMatched(value, headerVal);\n+            } else {\n+                status = false;\n+                break;\n+            }\n+        }\n+    }\n+\n+    status = conditions.invert ? !status : status;\n+    return status;\n+}\n+\n+function isQueryParamPresent(http:Request req, QueryParamConditions conditions) returns boolean {\n+    boolean status = true;\n+\n+    foreach var [name, value] in conditions.values.entries() {\n+        string? paramValue = req.getQueryParamValue(name);\n+        if (paramValue is string) {\n+            if (paramValue != \"\") {\n+                status = status && isPatternMatched(value, paramValue);\n+            } else {\n+                status = false;\n+                break;\n+            }\n+        }\n+    }\n+\n+    status = conditions.invert ? !status : status;\n+    return status;\n+}\n+\n+function isClaimPresent(http:Request req, QueryParamConditions conditions) returns boolean {\n+    boolean status = true;\n+    string? assertion = req.hasHeader(jwtheaderName) ? req.getHeader(jwtheaderName) : ();\n+\n+    if (assertion is string) {\n+        jwt:JwtPayload | error decoded = decodeJWTPayload(assertion);\n+        if (decoded is jwt:JwtPayload) {\n+            foreach var [name, value] in conditions.values.entries() {\n+                if (decoded.hasKey(name)) {\n+                    printInfo(\"TEST\", \"present in decoded : \" + decoded.get(name).toString());", "originalCommit": "d4449279dca17e2be3898964f46701494a5af0ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3c01269e7436d13b3c78758837a03e60df840f37", "url": "https://github.com/wso2/product-microgateway/commit/3c01269e7436d13b3c78758837a03e60df840f37", "message": "throttle: Check jwt claims in customClaims", "committedDate": "2020-08-07T14:24:09Z", "type": "commit"}, {"oid": "3c01269e7436d13b3c78758837a03e60df840f37", "url": "https://github.com/wso2/product-microgateway/commit/3c01269e7436d13b3c78758837a03e60df840f37", "message": "throttle: Check jwt claims in customClaims", "committedDate": "2020-08-07T14:24:09Z", "type": "forcePushed"}]}