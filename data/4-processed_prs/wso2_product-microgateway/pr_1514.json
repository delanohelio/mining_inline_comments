{"pr_number": 1514, "pr_title": "Init cpp filters", "pr_createdAt": "2020-12-02T07:28:44Z", "pr_url": "https://github.com/wso2/product-microgateway/pull/1514", "timeline": [{"oid": "cf6698745ae84a9f2aef3f9cb2a8668e71e94d90", "url": "https://github.com/wso2/product-microgateway/commit/cf6698745ae84a9f2aef3f9cb2a8668e71e94d90", "message": "init mgw envoy cpp filter", "committedDate": "2020-12-02T07:27:13Z", "type": "commit"}, {"oid": "a43e9830de4c129cde5d8d413a271c08ab844416", "url": "https://github.com/wso2/product-microgateway/commit/a43e9830de4c129cde5d8d413a271c08ab844416", "message": "Add do_ci.sh", "committedDate": "2020-12-02T07:38:23Z", "type": "commit"}, {"oid": "2ac00b83aaffc3a9763f395b979d5f257ea3a7cd", "url": "https://github.com/wso2/product-microgateway/commit/2ac00b83aaffc3a9763f395b979d5f257ea3a7cd", "message": "Add comments", "committedDate": "2020-12-07T06:03:31Z", "type": "commit"}, {"oid": "198ffdea76c450f6f95ed46c98fa44f0afe32868", "url": "https://github.com/wso2/product-microgateway/commit/198ffdea76c450f6f95ed46c98fa44f0afe32868", "message": "fix typo", "committedDate": "2020-12-07T06:55:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM3ODI1OQ==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537378259", "bodyText": "Storing the payload in a class level variable would cause issues in multithreaded approaches.", "author": "jsdjayanga", "createdAt": "2020-12-07T10:04:37Z", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;\n+  // We read metadata under ext_authz filter and if find a key \"payload\", \n+  // then decide to modify the payload.\n+  std::string PayloadMetadataKey = \"payload\";\n+  // Reading metadata under external authorization\n+  const auto* payload = &Config::Metadata::metadataValue(\n+      metadata, HttpFilterNames::get().ExtAuthorization, PayloadMetadataKey);\n+\n+  if (payload != nullptr && (payload->kind_case() == ProtobufWkt::Value::kStringValue)) {\n+    modified_body_ = payload->string_value();", "originalCommit": "198ffdea76c450f6f95ed46c98fa44f0afe32868", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjQ3OA==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537556478", "bodyText": "Filter obj are initiated per request stream, this will not break multithreaded scenarios. referring https://www.envoyproxy.io/docs/envoy/latest/intro/life_of_a_request#http-filter-chain-processing", "author": "AmaliMatharaarachchi", "createdAt": "2020-12-07T14:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM3ODI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM3OTc0Mw==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537379743", "bodyText": "If method decodeHeaders() is called before setDecoderFilterCallbacks() method, code will break at this line", "author": "jsdjayanga", "createdAt": "2020-12-07T10:06:51Z", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());", "originalCommit": "198ffdea76c450f6f95ed46c98fa44f0afe32868", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzU1NjU4Mg==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537556582", "bodyText": "setDecoderFilterCallbacks is called at the filter initiation. Therefore it will be called before other decode methods. https://github.com/envoyproxy/envoy/blob/9aa5c75d6be62cda62a1e00a12b681a8377db9ca/include/envoy/http/filter.h#L620", "author": "AmaliMatharaarachchi", "createdAt": "2020-12-07T14:38:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM3OTc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NzYwMQ==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537387601", "bodyText": "What is the usage of this variable?", "author": "jsdjayanga", "createdAt": "2020-12-07T10:18:21Z", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;", "originalCommit": "198ffdea76c450f6f95ed46c98fa44f0afe32868", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAzMjA0NQ==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r538032045", "bodyText": "Thanks. fixed", "author": "AmaliMatharaarachchi", "createdAt": "2020-12-08T04:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4NzYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4Nzg1NA==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537387854", "bodyText": "This can be a const", "author": "jsdjayanga", "createdAt": "2020-12-07T10:18:41Z", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);\n+  // if stream is not ended, stop continueing to other filters and buffer.\n+  if (!end_stream) {\n+    return Http::FilterDataStatus::StopIterationAndBuffer;\n+  }\n+  // once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+void Filter::setPayload(std::string new_payload, const Buffer::Instance* decoding_buffer,\n+                     Http::RequestHeaderMap* req_headers) {\n+  ENVOY_LOG(debug, \"Modifying payload ...\");\n+  // create a new buffer instance with new payload data.\n+  Buffer::OwnedImpl modified_body(new_payload);\n+\n+  //if we never got a payload from the downstream/ header only request.\n+  if (decoding_buffer == nullptr) {\n+    // We are not streaming back this this payload data so we set streaming_filter = false.\n+    req_callbacks_->addDecodedData(modified_body, false);\n+  }\n+  else {\n+    // Since we modifying the existing payload, we drain the data buffer and add new data.\n+    req_callbacks_->modifyDecodingBuffer([&modified_body](Buffer::Instance& data) {\n+      data.drain(data.length());\n+      data.move(modified_body);\n+    });\n+  }\n+  // Since we modified the payload, need to set new content length.\n+  decoding_buffer = req_callbacks_->decodingBuffer();\n+  req_headers->setContentLength(decoding_buffer->length());\n+  ENVOY_LOG(debug, \"payload successfully modified\");\n+}\n+\n+bool Filter::readMetadata(const envoy::config::core::v3::Metadata* metadata) {\n+  std::string jsonJWTPayload;\n+  // We read metadata under ext_authz filter and if find a key \"payload\", \n+  // then decide to modify the payload.\n+  std::string PayloadMetadataKey = \"payload\";", "originalCommit": "198ffdea76c450f6f95ed46c98fa44f0afe32868", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAzMTkzOA==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r538031938", "bodyText": "Thanks. Fixed", "author": "AmaliMatharaarachchi", "createdAt": "2020-12-08T04:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM4Nzg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5NzY5MQ==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537497691", "bodyText": "Refactor trace logs. avoid toString()", "author": "AmaliMatharaarachchi", "createdAt": "2020-12-07T13:16:25Z", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. \n+  if (!end_stream) {\n+    return Http::FilterHeadersStatus::StopIteration;\n+  }\n+  //once the stream is complete (end_stream == true), we modify the payload.\n+  setPayload(modified_body_, req_callbacks_->decodingBuffer(), req_headers_);\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::decodeData(Buffer::Instance& data, bool end_stream) {\n+\n+  // if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterDataStatus::Continue;\n+  }\n+\n+  ENVOY_LOG(trace, \"decodeData with data = {} , end_stream = {}\", data.toString(), end_stream);", "originalCommit": "198ffdea76c450f6f95ed46c98fa44f0afe32868", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5ODUyMQ==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537498521", "bodyText": "Let's drain the buffer since we modify the payload anyway. to avoid complications like buffer overflows.", "author": "AmaliMatharaarachchi", "createdAt": "2020-12-07T13:17:37Z", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+void Filter::setDecoderFilterCallbacks(Http::StreamDecoderFilterCallbacks& callbacks) {\n+  req_callbacks_ = &callbacks;\n+}\n+\n+Http::FilterHeadersStatus Filter::decodeHeaders(Http::RequestHeaderMap& headers, bool end_stream) {\n+  ENVOY_LOG(trace, \"decodeHeaders with end_stream = {}\", end_stream);\n+  req_headers_ = &headers;\n+  // read metadata and check we need to modify the request body\n+  set_body_ = readMetadata(&req_callbacks_->streamInfo().dynamicMetadata());\n+  //if we do not modify the body we continue to other filters\n+  if (!set_body_) {\n+    return Http::FilterHeadersStatus::Continue;\n+  }\n+  // if stream is not ended, stop continueing to other filters and buffer. ", "originalCommit": "198ffdea76c450f6f95ed46c98fa44f0afe32868", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5ODgyNw==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537498827", "bodyText": "Check and handle if\u00a0ending stream happens in decodeTrailers.", "author": "AmaliMatharaarachchi", "createdAt": "2020-12-07T13:18:10Z", "path": "envoy-filters/mgw-source/filters/http/mgw/mgw.cc", "diffHunk": "@@ -0,0 +1,136 @@\n+#include \"mgw-source/filters/http/mgw/mgw.h\"\n+\n+#include \"envoy/config/core/v3/base.pb.h\"\n+\n+#include \"common/common/assert.h\"\n+#include \"common/common/enum_to_int.h\"\n+#include \"common/buffer/buffer_impl.h\"\n+#include \"common/http/utility.h\"\n+#include \"common/router/config_impl.h\"\n+\n+#include \"extensions/filters/http/well_known_names.h\"\n+\n+namespace Envoy {\n+namespace Extensions {\n+namespace HttpFilters {\n+namespace MGW {\n+\n+Filter::Filter() {}\n+\n+// Http::StreamFilterBase\n+void Filter::onDestroy() { ENVOY_LOG(debug, \"filter destroyed\"); }\n+\n+// Http::StreamEncoderFilter\n+Http::FilterHeadersStatus Filter::encode100ContinueHeaders(Http::ResponseHeaderMap&) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterHeadersStatus Filter::encodeHeaders(Http::ResponseHeaderMap&, bool) {\n+  return Http::FilterHeadersStatus::Continue;\n+}\n+\n+Http::FilterDataStatus Filter::encodeData(Buffer::Instance&, bool) {\n+  return Http::FilterDataStatus::Continue;\n+}\n+\n+Http::FilterTrailersStatus Filter::encodeTrailers(Http::ResponseTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;\n+}\n+\n+Http::FilterMetadataStatus Filter::encodeMetadata(Http::MetadataMap&) {\n+  return Http::FilterMetadataStatus::Continue;\n+}\n+\n+void Filter::setEncoderFilterCallbacks(Http::StreamEncoderFilterCallbacks& callbacks) {\n+  res_callbacks_ = &callbacks;\n+}\n+\n+// Http::StreamDecoderFilter\n+Http::FilterTrailersStatus Filter::decodeTrailers(Http::RequestTrailerMap&) {\n+  return Http::FilterTrailersStatus::Continue;", "originalCommit": "198ffdea76c450f6f95ed46c98fa44f0afe32868", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQ5OTE4MA==", "url": "https://github.com/wso2/product-microgateway/pull/1514#discussion_r537499180", "bodyText": "Need a release build script for the envoy image", "author": "AmaliMatharaarachchi", "createdAt": "2020-12-07T13:18:45Z", "path": "envoy-filters/ci/do_ci.sh", "diffHunk": "@@ -0,0 +1,35 @@\n+#!/bin/bash -e\n+\n+# TODO (amalimatharaarachchi) Write a release build script.", "originalCommit": "198ffdea76c450f6f95ed46c98fa44f0afe32868", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fade6cc81cd67c608e3bbeb6d93bdea9d7e6b047", "url": "https://github.com/wso2/product-microgateway/commit/fade6cc81cd67c608e3bbeb6d93bdea9d7e6b047", "message": "fix review comments", "committedDate": "2020-12-08T04:44:30Z", "type": "commit"}, {"oid": "87ac1eec95e8895ea71024222c92383b6cad3d70", "url": "https://github.com/wso2/product-microgateway/commit/87ac1eec95e8895ea71024222c92383b6cad3d70", "message": "perf improvement", "committedDate": "2020-12-08T04:54:48Z", "type": "commit"}]}