{"pr_number": 1717, "pr_title": "Support Collections decoding", "pr_createdAt": "2020-06-25T15:41:55Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1717", "timeline": [{"oid": "bf319e79666d956e96787bc81ebd5e5eea223428", "url": "https://github.com/firebase/firebase-android-sdk/commit/bf319e79666d956e96787bc81ebd5e5eea223428", "message": "support map decoding", "committedDate": "2020-06-25T15:40:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzY4OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r445657689", "bodyText": "Are there better ways to deal with Exceptions?\nor avoid using reflect?", "author": "James201311", "createdAt": "2020-06-25T15:46:30Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +148,83 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return List.class.isAssignableFrom(clazz)\n+        || Map.class.isAssignableFrom(clazz)\n+        || Set.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else if (List.class.isAssignableFrom(clazz)) {\n+      // TODO: support List\n+    } else if (Set.class.isAssignableFrom(clazz)) {\n+      // TODO: support List\n+    }\n+    return null;\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = null;\n+    try {\n+      map = classToken.getRawType().getDeclaredConstructor().newInstance();\n+    } catch (Exception e) {\n+      throw new IllegalArgumentException(\n+          classToken.getRawType()\n+              + \" cannot be initialized.\\n\"\n+              + \"Do not pass abstract class and an interface.\\n\"\n+              + e);\n+    }", "originalCommit": "bf319e79666d956e96787bc81ebd5e5eea223428", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzAyNTM1MA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r447025350", "bodyText": "We don't want to use reflection, I would say let's start with supporting HashMap and LinkedHashMap and add support for any others later if we have to.\nIn general users should be encouraged to have fields of interface type Map not concrete implementations, so I think supporting Map, HashMap and LinkedHashMap should be good enough.", "author": "vkryachko", "createdAt": "2020-06-29T14:42:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NzY4OQ=="}], "type": "inlineReview"}, {"oid": "9e970b341c89ba6096e2c9bb39e8114e59ba7fc1", "url": "https://github.com/firebase/firebase-android-sdk/commit/9e970b341c89ba6096e2c9bb39e8114e59ba7fc1", "message": "Merge branch 'firebase_encoders' into yizhaoh.map_decode", "committedDate": "2020-06-25T18:53:33Z", "type": "commit"}, {"oid": "158c95f240e5ca933cfbbc0be986f75b370a5995", "url": "https://github.com/firebase/firebase-android-sdk/commit/158c95f240e5ca933cfbbc0be986f75b370a5995", "message": "put map decoding into a seperate test file", "committedDate": "2020-06-25T19:05:15Z", "type": "commit"}, {"oid": "e32b2bdef7e94f5de45982b765e7ccc84bf3d174", "url": "https://github.com/firebase/firebase-android-sdk/commit/e32b2bdef7e94f5de45982b765e7ccc84bf3d174", "message": "decode collection", "committedDate": "2020-06-26T13:40:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzA0Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r446193046", "bodyText": "same as above", "author": "James201311", "createdAt": "2020-06-26T13:44:46Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +148,101 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = null;\n+    try {\n+      map = classToken.getRawType().getDeclaredConstructor().newInstance();\n+    } catch (Exception e) {\n+      throw new IllegalArgumentException(\n+          classToken.getRawType()\n+              + \" cannot be initialized.\\n\"\n+              + \"Do not pass abstract class and an interface.\\n\"\n+              + e);\n+    }\n+\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = null;\n+    try {\n+      collection = classToken.getRawType().getDeclaredConstructor().newInstance();\n+    } catch (Exception e) {\n+      throw new IllegalArgumentException(\n+          classToken.getRawType()\n+              + \" cannot be initialized.\\n\"\n+              + \"Do not pass abstract class and an interface.\\n\"\n+              + e);\n+    }", "originalCommit": "e32b2bdef7e94f5de45982b765e7ccc84bf3d174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MTMwNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r446441305", "bodyText": "?", "author": "rlazo", "createdAt": "2020-06-26T22:45:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjE5MzA0Ng=="}], "type": "inlineReview"}, {"oid": "a83522134cc3908e71c6564dbfa0e572f942da33", "url": "https://github.com/firebase/firebase-android-sdk/commit/a83522134cc3908e71c6564dbfa0e572f942da33", "message": "remove reflect, implement newInstance method to create supported type", "committedDate": "2020-06-29T18:08:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NDY5Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r447844697", "bodyText": "Consider throwing EncodingException instead as this is the exception we advertise can be thrown.", "author": "vkryachko", "createdAt": "2020-06-30T17:07:33Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = newInstance(classToken);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      collection.add(decode(componentTypeToken));\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    if (clazz.equals(HashMap.class) || clazz.equals(Map.class)) {\n+      return (T) new HashMap<>();\n+    } else if (clazz.equals(LinkedHashMap.class)) {\n+      return (T) new LinkedHashMap<>();\n+    } else if (clazz.equals(TreeMap.class) || clazz.equals(SortedMap.class)) {\n+      return (T) new TreeMap<>();\n+    } else if (clazz.equals(ArrayList.class) || clazz.equals(List.class)) {\n+      return (T) new ArrayList<>();\n+    } else if (clazz.equals(ArrayDeque.class)\n+        || clazz.equals(Deque.class)\n+        || clazz.equals(Queue.class)) {\n+      return (T) new ArrayDeque<>();\n+    } else if (clazz.equals(PriorityQueue.class)) {\n+      return (T) new PriorityQueue<>();\n+    } else if (clazz.equals(HashSet.class) || clazz.equals(Set.class)) {\n+      return (T) new HashSet<>();\n+    } else if (clazz.equals(LinkedHashSet.class)) {\n+      return (T) new LinkedHashSet<>();\n+    } else if (clazz.equals(TreeSet.class) || clazz.equals(SortedSet.class)) {\n+      return (T) new TreeSet<>();\n+    }\n+    throw new IllegalArgumentException(classToken + \" not supported.\");", "originalCommit": "a83522134cc3908e71c6564dbfa0e572f942da33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NjIzMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r447846233", "bodyText": "Not sure how useful these are in the context of DTOs so we may want to remove them not to encourage folks to model queues with their json payloads, but I don't feel strongly.\nSame for priority queue below.", "author": "vkryachko", "createdAt": "2020-06-30T17:09:59Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = newInstance(classToken);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      collection.add(decode(componentTypeToken));\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    if (clazz.equals(HashMap.class) || clazz.equals(Map.class)) {\n+      return (T) new HashMap<>();\n+    } else if (clazz.equals(LinkedHashMap.class)) {\n+      return (T) new LinkedHashMap<>();\n+    } else if (clazz.equals(TreeMap.class) || clazz.equals(SortedMap.class)) {\n+      return (T) new TreeMap<>();\n+    } else if (clazz.equals(ArrayList.class) || clazz.equals(List.class)) {\n+      return (T) new ArrayList<>();\n+    } else if (clazz.equals(ArrayDeque.class)\n+        || clazz.equals(Deque.class)\n+        || clazz.equals(Queue.class)) {", "originalCommit": "a83522134cc3908e71c6564dbfa0e572f942da33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg4MDAyMg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r447880022", "bodyText": "Not sure if I understand correctly, the reason discouraging people from using queues is that the order of the decoded Json is not preserved?\nBut we should also support that if a client of Firestore doesn't want to have a dedicated network model(DTOs), but he wants to store the ordered results(get from orderby('x')) into a queue without mapping them.", "author": "James201311", "createdAt": "2020-06-30T18:04:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NjIzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDQ5NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449624495", "bodyText": "makes sense", "author": "vkryachko", "createdAt": "2020-07-03T15:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg0NjIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyMzc4MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449623781", "bodyText": "Looks like these 2 methods do more than one thing, consider splitting their functionality in to map and collection specific stuff, context: https://en.wikipedia.org/wiki/Single-responsibility_principle", "author": "vkryachko", "createdAt": "2020-07-03T15:00:08Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -67,6 +80,8 @@\n       return decodePrimitive(classToken);\n     } else if (isSingleValue(classToken)) {\n       return decodeSingleValue(classToken);\n+    } else if (isPreDefinedObject(classToken)) {\n+      return decodePreDefinedObject(classToken);", "originalCommit": "a83522134cc3908e71c6564dbfa0e572f942da33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDE1OQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449624159", "bodyText": "Same here, I would suggest you have 2 methods newMap, newCollection", "author": "vkryachko", "createdAt": "2020-07-03T15:00:58Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);", "originalCommit": "a83522134cc3908e71c6564dbfa0e572f942da33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYyNDY4Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1717#discussion_r449624687", "bodyText": "EncodingException", "author": "vkryachko", "createdAt": "2020-07-03T15:02:16Z", "path": "encoders/firebase-decoders-json/src/json/java/com/google/firebase/decoders/json/JsonDataDecoderBuilderContext.java", "diffHunk": "@@ -145,6 +160,109 @@\n     return null;\n   }\n \n+  private <T> boolean isPreDefinedObject(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    return Collection.class.isAssignableFrom(clazz) || Map.class.isAssignableFrom(clazz);\n+  }\n+\n+  private <T> T decodePreDefinedObject(TypeToken.ClassToken<T> classToken) throws IOException {\n+    Class<T> clazz = classToken.getRawType();\n+    if (Map.class.isAssignableFrom(clazz)) {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeMap((TypeToken.ClassToken<Map>) classToken);\n+      return t;\n+    } else {\n+      @SuppressWarnings(\"unchecked\")\n+      T t = (T) decodeCollection((TypeToken.ClassToken<Collection>) classToken);\n+      return t;\n+    }\n+  }\n+\n+  private <K, V, T extends Map<K, V>> T decodeMap(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<K> keyTypeToken = classToken.getTypeArguments().at(0);\n+    TypeToken<V> valTypeToken = classToken.getTypeArguments().at(1);\n+    if (!isSingleValue(keyTypeToken))\n+      throw new IllegalArgumentException(keyTypeToken + \" cannot be used as Map key.\");\n+\n+    T map = newInstance(classToken);\n+    reader.beginObject();\n+    while (reader.hasNext()) {\n+      String keyLiteral = reader.nextName();\n+      K key = getActualKey(keyLiteral, keyTypeToken.getRawType());\n+      V val = decode(valTypeToken);\n+      V replaced = map.put(key, val);\n+      if (replaced != null) {\n+        throw new IllegalArgumentException(\"duplicate key: \" + key);\n+      }\n+    }\n+    reader.endObject();\n+\n+    return map;\n+  }\n+\n+  private <E, T extends Collection<E>> T decodeCollection(TypeToken.ClassToken<T> classToken)\n+      throws IOException {\n+    TypeToken<E> componentTypeToken = classToken.getTypeArguments().at(0);\n+    T collection = newInstance(classToken);\n+    reader.beginArray();\n+    while (reader.hasNext()) {\n+      collection.add(decode(componentTypeToken));\n+    }\n+    reader.endArray();\n+    return collection;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <T> T newInstance(TypeToken.ClassToken<T> classToken) {\n+    Class<T> clazz = classToken.getRawType();\n+    if (clazz.equals(HashMap.class) || clazz.equals(Map.class)) {\n+      return (T) new HashMap<>();\n+    } else if (clazz.equals(LinkedHashMap.class)) {\n+      return (T) new LinkedHashMap<>();\n+    } else if (clazz.equals(TreeMap.class) || clazz.equals(SortedMap.class)) {\n+      return (T) new TreeMap<>();\n+    } else if (clazz.equals(ArrayList.class) || clazz.equals(List.class)) {\n+      return (T) new ArrayList<>();\n+    } else if (clazz.equals(ArrayDeque.class)\n+        || clazz.equals(Deque.class)\n+        || clazz.equals(Queue.class)) {\n+      return (T) new ArrayDeque<>();\n+    } else if (clazz.equals(PriorityQueue.class)) {\n+      return (T) new PriorityQueue<>();\n+    } else if (clazz.equals(HashSet.class) || clazz.equals(Set.class)) {\n+      return (T) new HashSet<>();\n+    } else if (clazz.equals(LinkedHashSet.class)) {\n+      return (T) new LinkedHashSet<>();\n+    } else if (clazz.equals(TreeSet.class) || clazz.equals(SortedSet.class)) {\n+      return (T) new TreeSet<>();\n+    }\n+    throw new IllegalArgumentException(classToken + \" not supported.\");\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private <K> K getActualKey(String keyLiteral, Class<K> clazz) {\n+    if (clazz.equals(Integer.class)) {\n+      return (K) (Integer) Integer.parseInt(keyLiteral);\n+    } else if (clazz.equals(Double.class)) {\n+      return (K) (Double) Double.parseDouble(keyLiteral);\n+    } else if (clazz.equals(Float.class)) {\n+      return (K) (Float) Float.parseFloat(keyLiteral);\n+    } else if (clazz.equals(Short.class)) {\n+      return (K) (Short) Short.parseShort(keyLiteral);\n+    } else if (clazz.equals(Long.class)) {\n+      return (K) (Long) Long.parseLong(keyLiteral);\n+    } else if (clazz.equals(Character.class)) {\n+      return (K) (Character) keyLiteral.charAt(0);\n+    } else if (clazz.equals(Byte.class)) {\n+      return (K) (Byte) Byte.parseByte(keyLiteral);\n+    } else if (clazz.equals(String.class)) {\n+      return (K) keyLiteral;\n+    } else {\n+      throw new IllegalArgumentException(\"Excepted Single Value Type. \" + clazz + \" was found.\");", "originalCommit": "a83522134cc3908e71c6564dbfa0e572f942da33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "url": "https://github.com/firebase/firebase-android-sdk/commit/951637cb03f284fd0726ef89b42ca03cbbe9fbe2", "message": "address comment", "committedDate": "2020-07-06T14:15:03Z", "type": "commit"}, {"oid": "91d72db9b35a68e12a9b54c71ce38b53d26edc7e", "url": "https://github.com/firebase/firebase-android-sdk/commit/91d72db9b35a68e12a9b54c71ce38b53d26edc7e", "message": "address comments", "committedDate": "2020-07-23T14:47:13Z", "type": "commit"}]}