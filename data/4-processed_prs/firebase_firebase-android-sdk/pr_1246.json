{"pr_number": 1246, "pr_title": "Add FirebaseCrashlyticsReportManager", "pr_createdAt": "2020-02-14T17:05:00Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1246", "timeline": [{"oid": "28ad043c81c132f7e5781cc47cfd4ceaaf562326", "url": "https://github.com/firebase/firebase-android-sdk/commit/28ad043c81c132f7e5781cc47cfd4ceaaf562326", "message": "Add FirebaseCrashlyticsReportManager\n\nHandles the interaction between Crashlytics lifecycle events and\ncrash reports (capture, persistence, and sending).", "committedDate": "2020-02-14T17:02:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2NTg3Mw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1246#discussion_r379565873", "bodyText": "It's pretty weird to mock a task. The only thing this seems to do different from just creating a resolved Task is that it captures values passed to addOnCompleteListener, but that's really not something you should be testing for, and it's not obvious that these tests actually care about that anyway. Is there any reason not to just use Tasks.forResult() and Tasks.forException() instead?", "author": "bklimt", "createdAt": "2020-02-14T17:55:58Z", "path": "firebase-crashlytics/src/androidTest/java/com/google/firebase/crashlytics/internal/common/FirebaseCrashlyticsReportManagerTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.crashlytics.internal.common;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.android.gms.tasks.OnCompleteListener;\n+import com.google.android.gms.tasks.Task;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport;\n+import com.google.firebase.crashlytics.internal.persistence.CrashlyticsReportPersistence;\n+import com.google.firebase.crashlytics.internal.send.DataTransportCrashlyticsReportSender;\n+import com.google.firebase.crashlytics.internal.settings.model.AppSettingsData;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+public class FirebaseCrashlyticsReportManagerTest {\n+\n+  @Mock private CrashlyticsReportDataCapture dataCapture;\n+\n+  @Mock private CrashlyticsReportPersistence reportPersistence;\n+\n+  @Mock private DataTransportCrashlyticsReportSender reportSender;\n+\n+  @Mock private CurrentTimeProvider mockCurrentTimeProvider;\n+\n+  private FirebaseCrashlyticsReportManager reportManager;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+\n+    reportManager =\n+        new FirebaseCrashlyticsReportManager(\n+            dataCapture, reportPersistence, reportSender, mockCurrentTimeProvider);\n+  }\n+\n+  @Test\n+  public void testOnSessionBegin_persistsReportForSessionId() {\n+    final String sessionId = \"testSessionId\";\n+    final long timestamp = System.currentTimeMillis();\n+    when(mockCurrentTimeProvider.getCurrentTimeMillis()).thenReturn(timestamp);\n+    final long timestampSeconds = timestamp / 1000;\n+    final CrashlyticsReport mockReport = mock(CrashlyticsReport.class);\n+    when(dataCapture.captureReportData(anyString(), anyLong())).thenReturn(mockReport);\n+\n+    reportManager.onSessionBegin(sessionId);\n+\n+    verify(dataCapture).captureReportData(sessionId, timestampSeconds);\n+    verify(reportPersistence).persistReport(mockReport);\n+  }\n+\n+  @Test\n+  public void testOnFatalEvent_persistsFatalEventForSessionId() {\n+    final String eventType = \"crash\";\n+    final Exception exceptionEvent = new Exception(\"fatal\");\n+    final Thread eventThread = Thread.currentThread();\n+\n+    final String sessionId = \"testSessionId\";\n+    final long timestamp = System.currentTimeMillis();\n+    when(mockCurrentTimeProvider.getCurrentTimeMillis()).thenReturn(timestamp);\n+    final long timestampSeconds = timestamp / 1000;\n+    final CrashlyticsReport.Session.Event mockEvent = mock(CrashlyticsReport.Session.Event.class);\n+    when(dataCapture.captureEventData(\n+            any(Throwable.class), any(Thread.class), anyString(), anyLong(), anyInt(), anyInt()))\n+        .thenReturn(mockEvent);\n+\n+    reportManager.onSessionBegin(sessionId);\n+    reportManager.onFatalEvent(exceptionEvent, eventThread);\n+\n+    verify(dataCapture)\n+        .captureEventData(exceptionEvent, eventThread, eventType, timestampSeconds, 4, 8);\n+    verify(reportPersistence).persistEvent(mockEvent, sessionId);\n+  }\n+\n+  @Test\n+  public void onSessionsFinalize_finalizesReports() {\n+    final String sessionId = \"testSessionId\";\n+    reportManager.onSessionBegin(sessionId);\n+    reportManager.onSessionsFinalize();\n+\n+    verify(reportPersistence).finalizeReports(sessionId);\n+  }\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void onReportSend_successfulReportsAreDeleted() {\n+    final String orgId = \"testOrgId\";\n+    final String sessionId1 = \"sessionId1\";\n+    final String sessionId2 = \"sessionId2\";\n+\n+    final AppSettingsData appSettings =\n+        new AppSettingsData(null, null, null, null, null, orgId, false);\n+\n+    final List<CrashlyticsReport> finalizedReports = new ArrayList<>();\n+    final CrashlyticsReport mockReport1 = mockReport(sessionId1, orgId);\n+    final CrashlyticsReport mockReport2 = mockReport(sessionId2, orgId);\n+    finalizedReports.add(mockReport1);\n+    finalizedReports.add(mockReport2);\n+\n+    when(reportPersistence.loadFinalizedReports()).thenReturn(finalizedReports);\n+\n+    final ArgumentCaptor<OnCompleteListener> testCompletionListener1 =\n+        ArgumentCaptor.forClass(OnCompleteListener.class);\n+    final ArgumentCaptor<OnCompleteListener> testCompletionListener2 =\n+        ArgumentCaptor.forClass(OnCompleteListener.class);\n+\n+    final Task<CrashlyticsReport> mockTask1 =\n+        mockSuccessfulTask(mockReport1, testCompletionListener1);\n+    final Task<CrashlyticsReport> mockTask2 =\n+        mockFailedTask(new Exception(\"fail\"), testCompletionListener2);\n+\n+    when(reportSender.sendReport(mockReport1)).thenReturn(mockTask1);\n+    when(reportSender.sendReport(mockReport2)).thenReturn(mockTask2);\n+\n+    reportManager.onReportSend(appSettings);\n+\n+    verify(reportSender).sendReport(mockReport1);\n+    verify(reportSender).sendReport(mockReport2);\n+\n+    testCompletionListener1.getValue().onComplete(mockTask1);\n+    testCompletionListener2.getValue().onComplete(mockTask2);\n+\n+    verify(reportPersistence).deleteFinalizedReport(sessionId1);\n+    verify(reportPersistence, never()).deleteFinalizedReport(sessionId2);\n+  }\n+\n+  private CrashlyticsReport mockReport(String sessionId, String orgId) {\n+    final CrashlyticsReport mockReport = mock(CrashlyticsReport.class);\n+    final CrashlyticsReport.Session mockSession = mock(CrashlyticsReport.Session.class);\n+    when(mockSession.getIdentifier()).thenReturn(sessionId);\n+    when(mockReport.getSession()).thenReturn(mockSession);\n+    when(mockReport.withOrganizationId(orgId)).thenReturn(mockReport);\n+    return mockReport;\n+  }\n+\n+  private Task<CrashlyticsReport> mockSuccessfulTask(\n+      CrashlyticsReport result, ArgumentCaptor<OnCompleteListener> completionListener) {\n+    return mockTask(result, null, completionListener);\n+  }\n+\n+  private Task<CrashlyticsReport> mockFailedTask(\n+      Exception exception, ArgumentCaptor<OnCompleteListener> completionListener) {\n+    return mockTask(null, exception, completionListener);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Task<CrashlyticsReport> mockTask(", "originalCommit": "28ad043c81c132f7e5781cc47cfd4ceaaf562326", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU3MjU5Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1246#discussion_r379572596", "bodyText": "Because I'm not super familiar with all the ins and outs of the Tasks API. :) Thanks for letting me know about these! Depending on what I do with the completion callback, these may change anyhow.", "author": "mrwillis21", "createdAt": "2020-02-14T18:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2NTg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2Njc1Ng==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1246#discussion_r379566756", "bodyText": "Some short javadoc comments on these lifecycle methods would be nice. In particular, it's not obvious why a session \"ending\" is different from a session \"finalizing\", and it's not obvious which should be called first, or why you might ever call one without the other.", "author": "bklimt", "createdAt": "2020-02-14T17:57:52Z", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/common/FirebaseCrashlyticsReportManager.java", "diffHunk": "@@ -0,0 +1,102 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.crashlytics.internal.common;\n+\n+import com.google.android.gms.tasks.Task;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport;\n+import com.google.firebase.crashlytics.internal.persistence.CrashlyticsReportPersistence;\n+import com.google.firebase.crashlytics.internal.send.DataTransportCrashlyticsReportSender;\n+import com.google.firebase.crashlytics.internal.settings.model.AppSettingsData;\n+import java.util.List;\n+\n+/**\n+ * This class handles Crashlytics lifecycle events and manages capture, persistence, and sending of\n+ * reports to Firebase Crashlytics.\n+ */\n+public class FirebaseCrashlyticsReportManager {\n+\n+  private static final String EVENT_TYPE_CRASH = \"crash\";\n+  private static final int EVENT_THREAD_IMPORTANCE = 4;\n+  private static final int MAX_CHAINED_EXCEPTION_DEPTH = 8;\n+\n+  private final CrashlyticsReportDataCapture dataCapture;\n+  private final CrashlyticsReportPersistence reportPersistence;\n+  private final DataTransportCrashlyticsReportSender reportsSender;\n+  private final CurrentTimeProvider currentTimeProvider;\n+\n+  private String currentSessionId;\n+\n+  public FirebaseCrashlyticsReportManager(\n+      CrashlyticsReportDataCapture dataCapture,\n+      CrashlyticsReportPersistence reportPersistence,\n+      DataTransportCrashlyticsReportSender reportsSender,\n+      CurrentTimeProvider currentTimeProvider) {\n+    this.dataCapture = dataCapture;\n+    this.reportPersistence = reportPersistence;\n+    this.reportsSender = reportsSender;\n+    this.currentTimeProvider = currentTimeProvider;\n+  }\n+\n+  public void onSessionBegin(String sessionId) {\n+    final long timestamp = currentTimeProvider.getCurrentTimeMillis() / 1000;\n+    currentSessionId = sessionId;\n+\n+    final CrashlyticsReport capturedReport = dataCapture.captureReportData(sessionId, timestamp);\n+\n+    reportPersistence.persistReport(capturedReport);\n+  }\n+\n+  public void onFatalEvent(Throwable event, Thread thread) {\n+    final long timestamp = currentTimeProvider.getCurrentTimeMillis() / 1000;\n+\n+    final CrashlyticsReport.Session.Event capturedEvent =\n+        dataCapture.captureEventData(\n+            event,\n+            thread,\n+            EVENT_TYPE_CRASH,\n+            timestamp,\n+            EVENT_THREAD_IMPORTANCE,\n+            MAX_CHAINED_EXCEPTION_DEPTH);\n+\n+    reportPersistence.persistEvent(capturedEvent, currentSessionId);\n+  }\n+\n+  public void onSessionEnd() {\n+    currentSessionId = null;\n+  }\n+\n+  public void onSessionsFinalize() {", "originalCommit": "28ad043c81c132f7e5781cc47cfd4ceaaf562326", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU3MjY1NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1246#discussion_r379572655", "bodyText": "\ud83d\udc4d", "author": "mrwillis21", "createdAt": "2020-02-14T18:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2Njc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2Nzg4MQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1246#discussion_r379567881", "bodyText": "Since this class isn't an interface, and doesn't implement an interface, it's a little weird for all of these methods to be named like they are events. For example, why is this onReportSend instead of sendReport?\nIf you are planning on making this into an interface later, then maybe it's okay, but still something to think about.", "author": "bklimt", "createdAt": "2020-02-14T18:00:24Z", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/common/FirebaseCrashlyticsReportManager.java", "diffHunk": "@@ -0,0 +1,102 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.crashlytics.internal.common;\n+\n+import com.google.android.gms.tasks.Task;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport;\n+import com.google.firebase.crashlytics.internal.persistence.CrashlyticsReportPersistence;\n+import com.google.firebase.crashlytics.internal.send.DataTransportCrashlyticsReportSender;\n+import com.google.firebase.crashlytics.internal.settings.model.AppSettingsData;\n+import java.util.List;\n+\n+/**\n+ * This class handles Crashlytics lifecycle events and manages capture, persistence, and sending of\n+ * reports to Firebase Crashlytics.\n+ */\n+public class FirebaseCrashlyticsReportManager {\n+\n+  private static final String EVENT_TYPE_CRASH = \"crash\";\n+  private static final int EVENT_THREAD_IMPORTANCE = 4;\n+  private static final int MAX_CHAINED_EXCEPTION_DEPTH = 8;\n+\n+  private final CrashlyticsReportDataCapture dataCapture;\n+  private final CrashlyticsReportPersistence reportPersistence;\n+  private final DataTransportCrashlyticsReportSender reportsSender;\n+  private final CurrentTimeProvider currentTimeProvider;\n+\n+  private String currentSessionId;\n+\n+  public FirebaseCrashlyticsReportManager(\n+      CrashlyticsReportDataCapture dataCapture,\n+      CrashlyticsReportPersistence reportPersistence,\n+      DataTransportCrashlyticsReportSender reportsSender,\n+      CurrentTimeProvider currentTimeProvider) {\n+    this.dataCapture = dataCapture;\n+    this.reportPersistence = reportPersistence;\n+    this.reportsSender = reportsSender;\n+    this.currentTimeProvider = currentTimeProvider;\n+  }\n+\n+  public void onSessionBegin(String sessionId) {\n+    final long timestamp = currentTimeProvider.getCurrentTimeMillis() / 1000;\n+    currentSessionId = sessionId;\n+\n+    final CrashlyticsReport capturedReport = dataCapture.captureReportData(sessionId, timestamp);\n+\n+    reportPersistence.persistReport(capturedReport);\n+  }\n+\n+  public void onFatalEvent(Throwable event, Thread thread) {\n+    final long timestamp = currentTimeProvider.getCurrentTimeMillis() / 1000;\n+\n+    final CrashlyticsReport.Session.Event capturedEvent =\n+        dataCapture.captureEventData(\n+            event,\n+            thread,\n+            EVENT_TYPE_CRASH,\n+            timestamp,\n+            EVENT_THREAD_IMPORTANCE,\n+            MAX_CHAINED_EXCEPTION_DEPTH);\n+\n+    reportPersistence.persistEvent(capturedEvent, currentSessionId);\n+  }\n+\n+  public void onSessionEnd() {\n+    currentSessionId = null;\n+  }\n+\n+  public void onSessionsFinalize() {\n+    reportPersistence.finalizeReports(currentSessionId);\n+  }\n+\n+  public void onReportSend(AppSettingsData appSettingsData) {", "originalCommit": "28ad043c81c132f7e5781cc47cfd4ceaaf562326", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU3MTcxNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1246#discussion_r379571715", "bodyText": "I actually had planned on making it an interface later. :)", "author": "mrwillis21", "createdAt": "2020-02-14T18:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2Nzg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU3MDI2Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1246#discussion_r379570267", "bodyText": "It's usually kind of a smell to use addOnCompleteListener instead of continueWith, but it's not obviously wrong here. The implications are:\n\nAll of the sends will run in parallel.\nThis caller won't ever know if they succeeded or failed (or even finished).\nThe callback will happen on the UI Thread.\n\nImplication #2 seems intentional, and #3 seems unintentional. I'm not sure about #1. It might be a good idea to add a comment about the threading expectations of this method.", "author": "bklimt", "createdAt": "2020-02-14T18:05:55Z", "path": "firebase-crashlytics/src/main/java/com/google/firebase/crashlytics/internal/common/FirebaseCrashlyticsReportManager.java", "diffHunk": "@@ -0,0 +1,102 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.crashlytics.internal.common;\n+\n+import com.google.android.gms.tasks.Task;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport;\n+import com.google.firebase.crashlytics.internal.persistence.CrashlyticsReportPersistence;\n+import com.google.firebase.crashlytics.internal.send.DataTransportCrashlyticsReportSender;\n+import com.google.firebase.crashlytics.internal.settings.model.AppSettingsData;\n+import java.util.List;\n+\n+/**\n+ * This class handles Crashlytics lifecycle events and manages capture, persistence, and sending of\n+ * reports to Firebase Crashlytics.\n+ */\n+public class FirebaseCrashlyticsReportManager {\n+\n+  private static final String EVENT_TYPE_CRASH = \"crash\";\n+  private static final int EVENT_THREAD_IMPORTANCE = 4;\n+  private static final int MAX_CHAINED_EXCEPTION_DEPTH = 8;\n+\n+  private final CrashlyticsReportDataCapture dataCapture;\n+  private final CrashlyticsReportPersistence reportPersistence;\n+  private final DataTransportCrashlyticsReportSender reportsSender;\n+  private final CurrentTimeProvider currentTimeProvider;\n+\n+  private String currentSessionId;\n+\n+  public FirebaseCrashlyticsReportManager(\n+      CrashlyticsReportDataCapture dataCapture,\n+      CrashlyticsReportPersistence reportPersistence,\n+      DataTransportCrashlyticsReportSender reportsSender,\n+      CurrentTimeProvider currentTimeProvider) {\n+    this.dataCapture = dataCapture;\n+    this.reportPersistence = reportPersistence;\n+    this.reportsSender = reportsSender;\n+    this.currentTimeProvider = currentTimeProvider;\n+  }\n+\n+  public void onSessionBegin(String sessionId) {\n+    final long timestamp = currentTimeProvider.getCurrentTimeMillis() / 1000;\n+    currentSessionId = sessionId;\n+\n+    final CrashlyticsReport capturedReport = dataCapture.captureReportData(sessionId, timestamp);\n+\n+    reportPersistence.persistReport(capturedReport);\n+  }\n+\n+  public void onFatalEvent(Throwable event, Thread thread) {\n+    final long timestamp = currentTimeProvider.getCurrentTimeMillis() / 1000;\n+\n+    final CrashlyticsReport.Session.Event capturedEvent =\n+        dataCapture.captureEventData(\n+            event,\n+            thread,\n+            EVENT_TYPE_CRASH,\n+            timestamp,\n+            EVENT_THREAD_IMPORTANCE,\n+            MAX_CHAINED_EXCEPTION_DEPTH);\n+\n+    reportPersistence.persistEvent(capturedEvent, currentSessionId);\n+  }\n+\n+  public void onSessionEnd() {\n+    currentSessionId = null;\n+  }\n+\n+  public void onSessionsFinalize() {\n+    reportPersistence.finalizeReports(currentSessionId);\n+  }\n+\n+  public void onReportSend(AppSettingsData appSettingsData) {\n+    final List<CrashlyticsReport> reportsToSend = reportPersistence.loadFinalizedReports();\n+    for (CrashlyticsReport report : reportsToSend) {\n+      reportsSender\n+          .sendReport(report.withOrganizationId(appSettingsData.organizationId))\n+          .addOnCompleteListener(this::onReportSendComplete);", "originalCommit": "28ad043c81c132f7e5781cc47cfd4ceaaf562326", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU3MjIzNw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1246#discussion_r379572237", "bodyText": "Hmm, I was just following the instructions here: https://developers.google.com/android/guides/tasks\nDefinitely good points. I'll follow up with you on this.", "author": "mrwillis21", "createdAt": "2020-02-14T18:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU3MDI2Nw=="}], "type": "inlineReview"}, {"oid": "20a346f247f46b5e89c96c8acf3f5b4a946f7fe6", "url": "https://github.com/firebase/firebase-android-sdk/commit/20a346f247f46b5e89c96c8acf3f5b4a946f7fe6", "message": "PR feedback", "committedDate": "2020-02-14T20:48:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0NjQ5Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1246#discussion_r379646492", "bodyText": "This can't be right. successfulTask was already declared to be successful, so this isn't going to do anything. I know I said before that it's important to wait on a task to know the test is ready to proceed, but this task is created right here in this method, and there's no work that it waits on, so this really isn't doing anything. So, if there's something that needs to happen before the test continues, make sure to wait on that, but this seems like a no-op as it is.", "author": "bklimt", "createdAt": "2020-02-14T21:12:47Z", "path": "firebase-crashlytics/src/androidTest/java/com/google/firebase/crashlytics/internal/common/FirebaseCrashlyticsReportManagerTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+// Copyright 2020 Google LLC\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//      http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+package com.google.firebase.crashlytics.internal.common;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.ArgumentMatchers.anyLong;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.android.gms.tasks.Task;\n+import com.google.android.gms.tasks.Tasks;\n+import com.google.firebase.crashlytics.internal.model.CrashlyticsReport;\n+import com.google.firebase.crashlytics.internal.persistence.CrashlyticsReportPersistence;\n+import com.google.firebase.crashlytics.internal.send.DataTransportCrashlyticsReportSender;\n+import com.google.firebase.crashlytics.internal.settings.model.AppSettingsData;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mock;\n+import org.mockito.MockitoAnnotations;\n+\n+public class FirebaseCrashlyticsReportManagerTest {\n+\n+  @Mock private CrashlyticsReportDataCapture dataCapture;\n+\n+  @Mock private CrashlyticsReportPersistence reportPersistence;\n+\n+  @Mock private DataTransportCrashlyticsReportSender reportSender;\n+\n+  @Mock private CurrentTimeProvider mockCurrentTimeProvider;\n+\n+  private FirebaseCrashlyticsReportManager reportManager;\n+\n+  @Before\n+  public void setUp() {\n+    MockitoAnnotations.initMocks(this);\n+\n+    reportManager =\n+        new FirebaseCrashlyticsReportManager(\n+            dataCapture, reportPersistence, reportSender, mockCurrentTimeProvider);\n+  }\n+\n+  @Test\n+  public void testOnSessionBegin_persistsReportForSessionId() {\n+    final String sessionId = \"testSessionId\";\n+    final long timestamp = System.currentTimeMillis();\n+    when(mockCurrentTimeProvider.getCurrentTimeMillis()).thenReturn(timestamp);\n+    final long timestampSeconds = timestamp / 1000;\n+    final CrashlyticsReport mockReport = mock(CrashlyticsReport.class);\n+    when(dataCapture.captureReportData(anyString(), anyLong())).thenReturn(mockReport);\n+\n+    reportManager.onBeginSession(sessionId);\n+\n+    verify(dataCapture).captureReportData(sessionId, timestampSeconds);\n+    verify(reportPersistence).persistReport(mockReport);\n+  }\n+\n+  @Test\n+  public void testOnFatalEvent_persistsFatalEventForSessionId() {\n+    final String eventType = \"crash\";\n+    final Exception exceptionEvent = new Exception(\"fatal\");\n+    final Thread eventThread = Thread.currentThread();\n+\n+    final String sessionId = \"testSessionId\";\n+    final long timestamp = System.currentTimeMillis();\n+    when(mockCurrentTimeProvider.getCurrentTimeMillis()).thenReturn(timestamp);\n+    final long timestampSeconds = timestamp / 1000;\n+    final CrashlyticsReport.Session.Event mockEvent = mock(CrashlyticsReport.Session.Event.class);\n+    when(dataCapture.captureEventData(\n+            any(Throwable.class), any(Thread.class), anyString(), anyLong(), anyInt(), anyInt()))\n+        .thenReturn(mockEvent);\n+\n+    reportManager.onBeginSession(sessionId);\n+    reportManager.onFatalEvent(exceptionEvent, eventThread);\n+\n+    verify(dataCapture)\n+        .captureEventData(exceptionEvent, eventThread, eventType, timestampSeconds, 4, 8);\n+    verify(reportPersistence).persistEvent(mockEvent, sessionId);\n+  }\n+\n+  @Test\n+  public void onSessionsFinalize_finalizesReports() {\n+    final String sessionId = \"testSessionId\";\n+    reportManager.onBeginSession(sessionId);\n+    reportManager.onFinalizeSessions();\n+\n+    verify(reportPersistence).finalizeReports(sessionId);\n+  }\n+\n+  @Test\n+  @SuppressWarnings(\"unchecked\")\n+  public void onReportSend_successfulReportsAreDeleted() throws InterruptedException {\n+    final String orgId = \"testOrgId\";\n+    final String sessionId1 = \"sessionId1\";\n+    final String sessionId2 = \"sessionId2\";\n+\n+    final AppSettingsData appSettings =\n+        new AppSettingsData(null, null, null, null, null, orgId, false);\n+\n+    final List<CrashlyticsReport> finalizedReports = new ArrayList<>();\n+    final CrashlyticsReport mockReport1 = mockReport(sessionId1, orgId);\n+    final CrashlyticsReport mockReport2 = mockReport(sessionId2, orgId);\n+    finalizedReports.add(mockReport1);\n+    finalizedReports.add(mockReport2);\n+\n+    when(reportPersistence.loadFinalizedReports()).thenReturn(finalizedReports);\n+\n+    final Task<CrashlyticsReport> successfulTask = Tasks.forResult(mockReport1);\n+    final Task<CrashlyticsReport> failedTask = Tasks.forException(new Exception(\"fail\"));\n+\n+    when(reportSender.sendReport(mockReport1)).thenReturn(successfulTask);\n+    when(reportSender.sendReport(mockReport2)).thenReturn(failedTask);\n+\n+    reportManager.onSendReports(appSettings);\n+\n+    verify(reportSender).sendReport(mockReport1);\n+    verify(reportSender).sendReport(mockReport2);\n+\n+    try {\n+      Tasks.await(successfulTask);", "originalCommit": "20a346f247f46b5e89c96c8acf3f5b4a946f7fe6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0OTY5NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1246#discussion_r379649694", "bodyText": "Cool, I actually wasn't sure about this point, so I just cargo-culted it from my other tests, but  I did think it was a bit odd. I'll remove it. :)", "author": "mrwillis21", "createdAt": "2020-02-14T21:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0NjQ5Mg=="}], "type": "inlineReview"}, {"oid": "2ea703e215c572a9e8b56717be633c33701e9ab0", "url": "https://github.com/firebase/firebase-android-sdk/commit/2ea703e215c572a9e8b56717be633c33701e9ab0", "message": "Remove awaits on pre-completed tasks", "committedDate": "2020-02-14T21:47:42Z", "type": "commit"}]}