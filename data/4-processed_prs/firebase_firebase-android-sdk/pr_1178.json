{"pr_number": 1178, "pr_title": "Add explicit FieldValue canonicalization", "pr_createdAt": "2020-01-30T02:01:54Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1178", "timeline": [{"oid": "9ad59dc8ee8a1f22bd1fb6013086a2f451d30767", "url": "https://github.com/firebase/firebase-android-sdk/commit/9ad59dc8ee8a1f22bd1fb6013086a2f451d30767", "message": "Add explicit FieldValue canonicalization", "committedDate": "2020-01-30T02:00:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMTE4Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373131187", "bodyText": "buildTimestampCanonicalId reads weirdly and is the third form for names in this file:\n\nnumberEquals\ncompareNumber\nbuildNumberCanonicalId\n\nIt seems like these could all have the same shape.\nIdeas:\n\n\nmake these verbless, i.e. have\nprivate static void canonicalId(StringBuilder builder, Value value) ...\nand these helpers can then just drop the \"build\" prefix.\n\n\nuse a verb like \"canonify\" and then these become e.g. \"canonifyTimestamp\".", "author": "wilhuff", "createdAt": "2020-01-30T18:55:09Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -249,4 +249,87 @@ private static int compareMaps(MapValue left, MapValue right) {\n     // Only equal if both iterators are exhausted.\n     return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n   }\n+\n+  /** Generate the canonical ID for the provided field value (as used in Target serialization). */\n+  public static String canonicalId(Value value) {\n+    StringBuilder builder = new StringBuilder();\n+    buildCanonicalId(builder, value);\n+    return builder.toString();\n+  }\n+\n+  // TODO(mrschmidt): Use in target serialization and migrate all existing TargetData\n+  private static void buildCanonicalId(StringBuilder builder, Value value) {\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        builder.append(\"null\");\n+        break;\n+      case BOOLEAN_VALUE:\n+        builder.append(value.getBooleanValue());\n+        break;\n+      case INTEGER_VALUE:\n+        builder.append(value.getIntegerValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        builder.append(value.getDoubleValue());\n+        break;\n+      case TIMESTAMP_VALUE:\n+        buildTimestampCanonicalId(builder, value.getTimestampValue());\n+        break;\n+      case STRING_VALUE:\n+        builder.append(value.getStringValue());\n+        break;\n+      case BYTES_VALUE:\n+        builder.append(Util.toDebugString(value.getBytesValue()));\n+        break;\n+      case REFERENCE_VALUE:\n+        // TODO(mrschmidt): Use document key only\n+        builder.append(value.getReferenceValue());\n+        break;\n+      case GEO_POINT_VALUE:\n+        buildGeoPointCanonicalId(builder, value.getGeoPointValue());\n+        break;\n+      case ARRAY_VALUE:\n+        buildArrayCanonicalId(builder, value.getArrayValue());\n+        break;\n+      case MAP_VALUE:\n+        buildObjectCanonicalId(builder, value.getMapValue());\n+        break;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  private static void buildTimestampCanonicalId(StringBuilder builder, Timestamp timestamp) {", "originalCommit": "9ad59dc8ee8a1f22bd1fb6013086a2f451d30767", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2NjMwMw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373266303", "bodyText": "I couldn't bring myself to use canonify or canonicalize. I used stringify, but am open to feedback, even if that means canonify.", "author": "schmidt-sebastian", "createdAt": "2020-01-31T00:34:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMTE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcwOTkzNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373709935", "bodyText": "\"stringify\" doesn't really tie into canonical ID though and I think that's probably more important. I don't have any better suggestions though, so feel free to put it back to makeCanonicalId or whatever it was.", "author": "wilhuff", "createdAt": "2020-01-31T22:16:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMTE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcyOTkxNA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373729914", "bodyText": "I will rename these methods to use \"canonify\" instead. Apparently other people are using this terminology too: https://docs.cfengine.com/docs/3.12/reference-functions-canonify.html", "author": "schmidt-sebastian", "createdAt": "2020-01-31T23:32:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMTE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMzM1Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373133352", "bodyText": "This is indistinguishable from a user-supplied object that happens to have these parameters. While JSON-like seems useful we could avoid collisions altogether if we made this look like an object constructor instead.\nSomething like geo(lat:%s,lng:%s) or even just geo(%s, %s).", "author": "wilhuff", "createdAt": "2020-01-30T18:59:36Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -249,4 +249,87 @@ private static int compareMaps(MapValue left, MapValue right) {\n     // Only equal if both iterators are exhausted.\n     return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n   }\n+\n+  /** Generate the canonical ID for the provided field value (as used in Target serialization). */\n+  public static String canonicalId(Value value) {\n+    StringBuilder builder = new StringBuilder();\n+    buildCanonicalId(builder, value);\n+    return builder.toString();\n+  }\n+\n+  // TODO(mrschmidt): Use in target serialization and migrate all existing TargetData\n+  private static void buildCanonicalId(StringBuilder builder, Value value) {\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        builder.append(\"null\");\n+        break;\n+      case BOOLEAN_VALUE:\n+        builder.append(value.getBooleanValue());\n+        break;\n+      case INTEGER_VALUE:\n+        builder.append(value.getIntegerValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        builder.append(value.getDoubleValue());\n+        break;\n+      case TIMESTAMP_VALUE:\n+        buildTimestampCanonicalId(builder, value.getTimestampValue());\n+        break;\n+      case STRING_VALUE:\n+        builder.append(value.getStringValue());\n+        break;\n+      case BYTES_VALUE:\n+        builder.append(Util.toDebugString(value.getBytesValue()));\n+        break;\n+      case REFERENCE_VALUE:\n+        // TODO(mrschmidt): Use document key only\n+        builder.append(value.getReferenceValue());\n+        break;\n+      case GEO_POINT_VALUE:\n+        buildGeoPointCanonicalId(builder, value.getGeoPointValue());\n+        break;\n+      case ARRAY_VALUE:\n+        buildArrayCanonicalId(builder, value.getArrayValue());\n+        break;\n+      case MAP_VALUE:\n+        buildObjectCanonicalId(builder, value.getMapValue());\n+        break;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  private static void buildTimestampCanonicalId(StringBuilder builder, Timestamp timestamp) {\n+    builder.append(String.format(\"{s:%s,n:%s}\", timestamp.getSeconds(), timestamp.getNanos()));\n+  }\n+\n+  private static void buildGeoPointCanonicalId(StringBuilder builder, LatLng latLng) {\n+    builder.append(String.format(\"{lat:%s,lng:%s}\", latLng.getLatitude(), latLng.getLongitude()));", "originalCommit": "9ad59dc8ee8a1f22bd1fb6013086a2f451d30767", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2NjQ3NA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373266474", "bodyText": "I wanted to keep the IDs short. geo(%s, %s) certainly is short enough and solves the ambiguity.", "author": "schmidt-sebastian", "createdAt": "2020-01-31T00:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMzM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMzY1Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373133657", "bodyText": "Are you intending to make it an invariant that MapValues are always sorted by key? I don't recall seeing this in your other PR adding protovalue.ObjectValue.Builder.\nIf not, we probably need to sort the strings here :-(. I think maintaining the invariant is probably better though.\nNote that server-supplied MapValues already conform to this invariant.", "author": "wilhuff", "createdAt": "2020-01-30T19:00:16Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -249,4 +249,87 @@ private static int compareMaps(MapValue left, MapValue right) {\n     // Only equal if both iterators are exhausted.\n     return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n   }\n+\n+  /** Generate the canonical ID for the provided field value (as used in Target serialization). */\n+  public static String canonicalId(Value value) {\n+    StringBuilder builder = new StringBuilder();\n+    buildCanonicalId(builder, value);\n+    return builder.toString();\n+  }\n+\n+  // TODO(mrschmidt): Use in target serialization and migrate all existing TargetData\n+  private static void buildCanonicalId(StringBuilder builder, Value value) {\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        builder.append(\"null\");\n+        break;\n+      case BOOLEAN_VALUE:\n+        builder.append(value.getBooleanValue());\n+        break;\n+      case INTEGER_VALUE:\n+        builder.append(value.getIntegerValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        builder.append(value.getDoubleValue());\n+        break;\n+      case TIMESTAMP_VALUE:\n+        buildTimestampCanonicalId(builder, value.getTimestampValue());\n+        break;\n+      case STRING_VALUE:\n+        builder.append(value.getStringValue());\n+        break;\n+      case BYTES_VALUE:\n+        builder.append(Util.toDebugString(value.getBytesValue()));\n+        break;\n+      case REFERENCE_VALUE:\n+        // TODO(mrschmidt): Use document key only\n+        builder.append(value.getReferenceValue());\n+        break;\n+      case GEO_POINT_VALUE:\n+        buildGeoPointCanonicalId(builder, value.getGeoPointValue());\n+        break;\n+      case ARRAY_VALUE:\n+        buildArrayCanonicalId(builder, value.getArrayValue());\n+        break;\n+      case MAP_VALUE:\n+        buildObjectCanonicalId(builder, value.getMapValue());\n+        break;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  private static void buildTimestampCanonicalId(StringBuilder builder, Timestamp timestamp) {\n+    builder.append(String.format(\"{s:%s,n:%s}\", timestamp.getSeconds(), timestamp.getNanos()));\n+  }\n+\n+  private static void buildGeoPointCanonicalId(StringBuilder builder, LatLng latLng) {\n+    builder.append(String.format(\"{lat:%s,lng:%s}\", latLng.getLatitude(), latLng.getLongitude()));\n+  }\n+\n+  private static void buildObjectCanonicalId(StringBuilder builder, MapValue mapValue) {\n+    builder.append(\"{\");\n+    boolean first = true;\n+    for (Map.Entry<String, Value> entry : mapValue.getFieldsMap().entrySet()) {", "originalCommit": "9ad59dc8ee8a1f22bd1fb6013086a2f451d30767", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2NzE5OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373267198", "bodyText": "MapValues are backed by a LinkedHashMap, and keeping this sorted in ObjectValue.Builder would be pretty expensive. Even though it feels like the wrong thing to do here, I don't see a good solution that doesn't involve resorting here. I experimented with sorted views, but in the end we probably don't need to go too crazy as large maps in Query constraints are hopefully uncommon.", "author": "schmidt-sebastian", "createdAt": "2020-01-31T00:37:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzEzMzY1Nw=="}], "type": "inlineReview"}, {"oid": "a3f3b79b8d684b83edeb2167055582b6032a3d54", "url": "https://github.com/firebase/firebase-android-sdk/commit/a3f3b79b8d684b83edeb2167055582b6032a3d54", "message": "Feedback", "committedDate": "2020-01-31T00:41:13Z", "type": "commit"}, {"oid": "cc3941934357f8f0d7e60b059d79f039cf801ccd", "url": "https://github.com/firebase/firebase-android-sdk/commit/cc3941934357f8f0d7e60b059d79f039cf801ccd", "message": "Update ProtoValues.java", "committedDate": "2020-01-31T19:30:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxODYzNg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373718636", "bodyText": "Building a binary tree to sort the entries is pretty wasteful in terms of memory allocation. It's also pessimistic because building the tree is always going to cost O(n lg(n)). An alternative would be to collect the keys into an ArrayList and sort that. That has the benefit of allocating less memory and also runs in O(n) if the list is already sorted.", "author": "wilhuff", "createdAt": "2020-01-31T22:46:33Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -249,4 +250,92 @@ private static int compareMaps(MapValue left, MapValue right) {\n     // Only equal if both iterators are exhausted.\n     return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n   }\n+\n+  /** Generate the canonical ID for the provided field value (as used in Target serialization). */\n+  public static String canonicalId(Value value) {\n+    StringBuilder builder = new StringBuilder();\n+    stringifyValue(builder, value);\n+    return builder.toString();\n+  }\n+\n+  // TODO(mrschmidt): Use in target serialization and migrate all existing TargetData\n+  private static void stringifyValue(StringBuilder builder, Value value) {\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        builder.append(\"null\");\n+        break;\n+      case BOOLEAN_VALUE:\n+        builder.append(value.getBooleanValue());\n+        break;\n+      case INTEGER_VALUE:\n+        builder.append(value.getIntegerValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        builder.append(value.getDoubleValue());\n+        break;\n+      case TIMESTAMP_VALUE:\n+        stringifyTimestamp(builder, value.getTimestampValue());\n+        break;\n+      case STRING_VALUE:\n+        builder.append(value.getStringValue());\n+        break;\n+      case BYTES_VALUE:\n+        builder.append(Util.toDebugString(value.getBytesValue()));\n+        break;\n+      case REFERENCE_VALUE:\n+        // TODO(mrschmidt): Use document key only\n+        builder.append(value.getReferenceValue());\n+        break;\n+      case GEO_POINT_VALUE:\n+        stringifyGeoPoint(builder, value.getGeoPointValue());\n+        break;\n+      case ARRAY_VALUE:\n+        stringifyArray(builder, value.getArrayValue());\n+        break;\n+      case MAP_VALUE:\n+        stringifyObject(builder, value.getMapValue());\n+        break;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  private static void stringifyTimestamp(StringBuilder builder, Timestamp timestamp) {\n+    builder.append(String.format(\"time(%s,%s)\", timestamp.getSeconds(), timestamp.getNanos()));\n+  }\n+\n+  private static void stringifyGeoPoint(StringBuilder builder, LatLng latLng) {\n+    builder.append(String.format(\"geo(%s,%s)\", latLng.getLatitude(), latLng.getLongitude()));\n+  }\n+\n+  private static void stringifyObject(StringBuilder builder, MapValue mapValue) {\n+    // Even though MapValue are likely sorted correctly based on their insertion order (e.g. when\n+    // received from the backend), local modifications can bring elements out of order. We need to\n+    // re-sort the elements to ensure that canonical IDs are independent of insertion order.\n+    SortedMap<String, Value> sortedMap = new TreeMap<>(mapValue.getFieldsMap());", "originalCommit": "cc3941934357f8f0d7e60b059d79f039cf801ccd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczMjY0OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373732648", "bodyText": "I went through different implementations for optimize for both runtime complexity and readability. While I still think that using large Maps here is kind of an anti-pattern (especially given our lack of truncation support),  adding an extra line here to pre-sort the keys (and performing a key-based lookup on the HashMap) might be a worthy tradeoff. Updated.", "author": "schmidt-sebastian", "createdAt": "2020-01-31T23:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzcxODYzNg=="}], "type": "inlineReview"}, {"oid": "2ef1826c2a922bd9fea0ff70ff888f8dcc751856", "url": "https://github.com/firebase/firebase-android-sdk/commit/2ef1826c2a922bd9fea0ff70ff888f8dcc751856", "message": "More Feedback", "committedDate": "2020-01-31T23:46:42Z", "type": "commit"}, {"oid": "b3b6a77b5121c7d486288c40f80453886f79d70b", "url": "https://github.com/firebase/firebase-android-sdk/commit/b3b6a77b5121c7d486288c40f80453886f79d70b", "message": "Merge", "committedDate": "2020-01-31T23:47:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNTcyMA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373735720", "bodyText": "You can make this keys.sort() if you want.", "author": "wilhuff", "createdAt": "2020-02-01T00:03:10Z", "path": "firebase-firestore/src/main/java/com/google/firebase/firestore/model/value/ProtoValues.java", "diffHunk": "@@ -249,4 +251,93 @@ private static int compareMaps(MapValue left, MapValue right) {\n     // Only equal if both iterators are exhausted.\n     return Util.compareBooleans(iterator1.hasNext(), iterator2.hasNext());\n   }\n+\n+  /** Generate the canonical ID for the provided field value (as used in Target serialization). */\n+  public static String canonicalId(Value value) {\n+    StringBuilder builder = new StringBuilder();\n+    canonifyValue(builder, value);\n+    return builder.toString();\n+  }\n+\n+  // TODO(mrschmidt): Use in target serialization and migrate all existing TargetData\n+  private static void canonifyValue(StringBuilder builder, Value value) {\n+    switch (value.getValueTypeCase()) {\n+      case NULL_VALUE:\n+        builder.append(\"null\");\n+        break;\n+      case BOOLEAN_VALUE:\n+        builder.append(value.getBooleanValue());\n+        break;\n+      case INTEGER_VALUE:\n+        builder.append(value.getIntegerValue());\n+        break;\n+      case DOUBLE_VALUE:\n+        builder.append(value.getDoubleValue());\n+        break;\n+      case TIMESTAMP_VALUE:\n+        canonifyTimestamp(builder, value.getTimestampValue());\n+        break;\n+      case STRING_VALUE:\n+        builder.append(value.getStringValue());\n+        break;\n+      case BYTES_VALUE:\n+        builder.append(Util.toDebugString(value.getBytesValue()));\n+        break;\n+      case REFERENCE_VALUE:\n+        // TODO(mrschmidt): Use document key only\n+        builder.append(value.getReferenceValue());\n+        break;\n+      case GEO_POINT_VALUE:\n+        canonifyGeoPoint(builder, value.getGeoPointValue());\n+        break;\n+      case ARRAY_VALUE:\n+        canonifyArray(builder, value.getArrayValue());\n+        break;\n+      case MAP_VALUE:\n+        canonifyObject(builder, value.getMapValue());\n+        break;\n+      default:\n+        throw fail(\"Invalid value type: \" + value.getValueTypeCase());\n+    }\n+  }\n+\n+  private static void canonifyTimestamp(StringBuilder builder, Timestamp timestamp) {\n+    builder.append(String.format(\"time(%s,%s)\", timestamp.getSeconds(), timestamp.getNanos()));\n+  }\n+\n+  private static void canonifyGeoPoint(StringBuilder builder, LatLng latLng) {\n+    builder.append(String.format(\"geo(%s,%s)\", latLng.getLatitude(), latLng.getLongitude()));\n+  }\n+\n+  private static void canonifyObject(StringBuilder builder, MapValue mapValue) {\n+    // Even though MapValue are likely sorted correctly based on their insertion order (e.g. when\n+    // received from the backend), local modifications can bring elements out of order. We need to\n+    // re-sort the elements to ensure that canonical IDs are independent of insertion order.\n+    List<String> keys = new ArrayList<>(mapValue.getFieldsMap().keySet());\n+    Collections.sort(keys);", "originalCommit": "b3b6a77b5121c7d486288c40f80453886f79d70b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczOTM2NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373739365", "bodyText": "Done", "author": "schmidt-sebastian", "createdAt": "2020-02-01T00:25:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNTcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc0NjM3Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1178#discussion_r373746377", "bodyText": "TIL: List.sort() is API Level 24.", "author": "schmidt-sebastian", "createdAt": "2020-02-01T01:22:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzczNTcyMA=="}], "type": "inlineReview"}, {"oid": "5b1d303eb441d858b1672486b92ef39342cfda86", "url": "https://github.com/firebase/firebase-android-sdk/commit/5b1d303eb441d858b1672486b92ef39342cfda86", "message": "Update ProtoValues.java", "committedDate": "2020-02-01T00:25:14Z", "type": "commit"}, {"oid": "51d86841544a3f657386da611238f15458461542", "url": "https://github.com/firebase/firebase-android-sdk/commit/51d86841544a3f657386da611238f15458461542", "message": "Revert Collections.sort()", "committedDate": "2020-02-01T01:21:50Z", "type": "commit"}]}