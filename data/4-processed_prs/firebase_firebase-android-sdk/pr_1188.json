{"pr_number": 1188, "pr_title": "Fix queriesCannotBeSortedByAnUncommittedServerTimestamp test", "pr_createdAt": "2020-02-03T21:45:45Z", "pr_url": "https://github.com/firebase/firebase-android-sdk/pull/1188", "timeline": [{"oid": "c7ae01581b85432b6bc6080f2313f1cfbe0a9cf8", "url": "https://github.com/firebase/firebase-android-sdk/commit/c7ae01581b85432b6bc6080f2313f1cfbe0a9cf8", "message": "Fix flaky queriesCannotBeSortedByAnUncommittedServerTimestamp test", "committedDate": "2020-02-03T21:42:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM1OTA5Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1188#discussion_r374359092", "bodyText": "This line changed", "author": "schmidt-sebastian", "createdAt": "2020-02-03T21:46:05Z", "path": "firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java", "diffHunk": "@@ -461,44 +461,49 @@ public void queriesCannotBeSortedByAnUncommittedServerTimestamp() {\n     TaskCompletionSource<Void> offlineCallbackDone = new TaskCompletionSource<>();\n     TaskCompletionSource<Void> onlineCallbackDone = new TaskCompletionSource<>();\n \n-    collection.addSnapshotListener(\n-        (snapshot, error) -> {\n-          assertNotNull(snapshot);\n-\n-          // Skip the initial empty snapshot.\n-          if (snapshot.isEmpty()) return;\n-\n-          assertThat(snapshot.getDocuments()).hasSize(1);\n-          DocumentSnapshot docSnap = snapshot.getDocuments().get(0);\n-\n-          if (snapshot.getMetadata().hasPendingWrites()) {\n-            // Offline snapshot. Since the server timestamp is uncommitted, we shouldn't be able to\n-            // query by it.\n-            assertThrows(\n-                IllegalArgumentException.class,\n-                () ->\n-                    collection\n-                        .orderBy(\"timestamp\")\n-                        .endAt(docSnap)\n-                        .addSnapshotListener((snapshot2, error2) -> {}));\n-            offlineCallbackDone.setResult(null);\n-          } else {\n-            // Online snapshot. Since the server timestamp is committed, we should be able to query\n-            // by it.\n-            collection\n-                .orderBy(\"timestamp\")\n-                .endAt(docSnap)\n-                .addSnapshotListener((snapshot2, error2) -> {});\n-            onlineCallbackDone.setResult(null);\n-          }\n-        });\n+    ListenerRegistration listenerRegistration =", "originalCommit": "c7ae01581b85432b6bc6080f2313f1cfbe0a9cf8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk3Njc5OA==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1188#discussion_r374976798", "bodyText": "FYI: You can enable a whitespace insensitive diff in the github UI which highlights these differences essentially just like your comments. You could just advise the reviewer enable that mode with less effort.", "author": "wilhuff", "createdAt": "2020-02-04T23:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM1OTA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk4NTg0Nw==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1188#discussion_r374985847", "bodyText": "Whooaa. I wish I had known this about two years ago. Thanks!", "author": "schmidt-sebastian", "createdAt": "2020-02-04T23:39:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM1OTA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM1OTE3NQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1188#discussion_r374359175", "bodyText": "These tree lines changed", "author": "schmidt-sebastian", "createdAt": "2020-02-03T21:46:16Z", "path": "firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java", "diffHunk": "@@ -461,44 +461,49 @@ public void queriesCannotBeSortedByAnUncommittedServerTimestamp() {\n     TaskCompletionSource<Void> offlineCallbackDone = new TaskCompletionSource<>();\n     TaskCompletionSource<Void> onlineCallbackDone = new TaskCompletionSource<>();\n \n-    collection.addSnapshotListener(\n-        (snapshot, error) -> {\n-          assertNotNull(snapshot);\n-\n-          // Skip the initial empty snapshot.\n-          if (snapshot.isEmpty()) return;\n-\n-          assertThat(snapshot.getDocuments()).hasSize(1);\n-          DocumentSnapshot docSnap = snapshot.getDocuments().get(0);\n-\n-          if (snapshot.getMetadata().hasPendingWrites()) {\n-            // Offline snapshot. Since the server timestamp is uncommitted, we shouldn't be able to\n-            // query by it.\n-            assertThrows(\n-                IllegalArgumentException.class,\n-                () ->\n-                    collection\n-                        .orderBy(\"timestamp\")\n-                        .endAt(docSnap)\n-                        .addSnapshotListener((snapshot2, error2) -> {}));\n-            offlineCallbackDone.setResult(null);\n-          } else {\n-            // Online snapshot. Since the server timestamp is committed, we should be able to query\n-            // by it.\n-            collection\n-                .orderBy(\"timestamp\")\n-                .endAt(docSnap)\n-                .addSnapshotListener((snapshot2, error2) -> {});\n-            onlineCallbackDone.setResult(null);\n-          }\n-        });\n+    ListenerRegistration listenerRegistration =\n+        collection.addSnapshotListener(\n+            (snapshot, error) -> {\n+              assertNotNull(snapshot);\n+\n+              // Skip the initial empty snapshot.\n+              if (snapshot.isEmpty()) return;\n+\n+              assertThat(snapshot.getDocuments()).hasSize(1);\n+              DocumentSnapshot docSnap = snapshot.getDocuments().get(0);\n+\n+              if (snapshot.getMetadata().hasPendingWrites()) {\n+                // Offline snapshot. Since the server timestamp is uncommitted, we shouldn't be able\n+                // to query by it.\n+                assertThrows(\n+                    IllegalArgumentException.class,\n+                    () ->\n+                        collection\n+                            .orderBy(\"timestamp\")\n+                            .endAt(docSnap)\n+                            .addSnapshotListener((snapshot2, error2) -> {}));\n+                // Use `trySetResult` since the callbacks fires twice if the WatchStream\n+                // acknowledges the Write before the WriteStream.\n+                offlineCallbackDone.trySetResult(null);", "originalCommit": "c7ae01581b85432b6bc6080f2313f1cfbe0a9cf8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM1OTIxNQ==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1188#discussion_r374359215", "bodyText": "This line changed", "author": "schmidt-sebastian", "createdAt": "2020-02-03T21:46:23Z", "path": "firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java", "diffHunk": "@@ -461,44 +461,49 @@ public void queriesCannotBeSortedByAnUncommittedServerTimestamp() {\n     TaskCompletionSource<Void> offlineCallbackDone = new TaskCompletionSource<>();\n     TaskCompletionSource<Void> onlineCallbackDone = new TaskCompletionSource<>();\n \n-    collection.addSnapshotListener(\n-        (snapshot, error) -> {\n-          assertNotNull(snapshot);\n-\n-          // Skip the initial empty snapshot.\n-          if (snapshot.isEmpty()) return;\n-\n-          assertThat(snapshot.getDocuments()).hasSize(1);\n-          DocumentSnapshot docSnap = snapshot.getDocuments().get(0);\n-\n-          if (snapshot.getMetadata().hasPendingWrites()) {\n-            // Offline snapshot. Since the server timestamp is uncommitted, we shouldn't be able to\n-            // query by it.\n-            assertThrows(\n-                IllegalArgumentException.class,\n-                () ->\n-                    collection\n-                        .orderBy(\"timestamp\")\n-                        .endAt(docSnap)\n-                        .addSnapshotListener((snapshot2, error2) -> {}));\n-            offlineCallbackDone.setResult(null);\n-          } else {\n-            // Online snapshot. Since the server timestamp is committed, we should be able to query\n-            // by it.\n-            collection\n-                .orderBy(\"timestamp\")\n-                .endAt(docSnap)\n-                .addSnapshotListener((snapshot2, error2) -> {});\n-            onlineCallbackDone.setResult(null);\n-          }\n-        });\n+    ListenerRegistration listenerRegistration =\n+        collection.addSnapshotListener(\n+            (snapshot, error) -> {\n+              assertNotNull(snapshot);\n+\n+              // Skip the initial empty snapshot.\n+              if (snapshot.isEmpty()) return;\n+\n+              assertThat(snapshot.getDocuments()).hasSize(1);\n+              DocumentSnapshot docSnap = snapshot.getDocuments().get(0);\n+\n+              if (snapshot.getMetadata().hasPendingWrites()) {\n+                // Offline snapshot. Since the server timestamp is uncommitted, we shouldn't be able\n+                // to query by it.\n+                assertThrows(\n+                    IllegalArgumentException.class,\n+                    () ->\n+                        collection\n+                            .orderBy(\"timestamp\")\n+                            .endAt(docSnap)\n+                            .addSnapshotListener((snapshot2, error2) -> {}));\n+                // Use `trySetResult` since the callbacks fires twice if the WatchStream\n+                // acknowledges the Write before the WriteStream.\n+                offlineCallbackDone.trySetResult(null);\n+              } else {\n+                // Online snapshot. Since the server timestamp is committed, we should be able to\n+                // query by it.\n+                collection\n+                    .orderBy(\"timestamp\")\n+                    .endAt(docSnap)\n+                    .addSnapshotListener((snapshot2, error2) -> {});\n+                onlineCallbackDone.trySetResult(null);", "originalCommit": "c7ae01581b85432b6bc6080f2313f1cfbe0a9cf8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM1OTI2Mg==", "url": "https://github.com/firebase/firebase-android-sdk/pull/1188#discussion_r374359262", "bodyText": "This is new", "author": "schmidt-sebastian", "createdAt": "2020-02-03T21:46:29Z", "path": "firebase-firestore/src/androidTest/java/com/google/firebase/firestore/ValidationTest.java", "diffHunk": "@@ -461,44 +461,49 @@ public void queriesCannotBeSortedByAnUncommittedServerTimestamp() {\n     TaskCompletionSource<Void> offlineCallbackDone = new TaskCompletionSource<>();\n     TaskCompletionSource<Void> onlineCallbackDone = new TaskCompletionSource<>();\n \n-    collection.addSnapshotListener(\n-        (snapshot, error) -> {\n-          assertNotNull(snapshot);\n-\n-          // Skip the initial empty snapshot.\n-          if (snapshot.isEmpty()) return;\n-\n-          assertThat(snapshot.getDocuments()).hasSize(1);\n-          DocumentSnapshot docSnap = snapshot.getDocuments().get(0);\n-\n-          if (snapshot.getMetadata().hasPendingWrites()) {\n-            // Offline snapshot. Since the server timestamp is uncommitted, we shouldn't be able to\n-            // query by it.\n-            assertThrows(\n-                IllegalArgumentException.class,\n-                () ->\n-                    collection\n-                        .orderBy(\"timestamp\")\n-                        .endAt(docSnap)\n-                        .addSnapshotListener((snapshot2, error2) -> {}));\n-            offlineCallbackDone.setResult(null);\n-          } else {\n-            // Online snapshot. Since the server timestamp is committed, we should be able to query\n-            // by it.\n-            collection\n-                .orderBy(\"timestamp\")\n-                .endAt(docSnap)\n-                .addSnapshotListener((snapshot2, error2) -> {});\n-            onlineCallbackDone.setResult(null);\n-          }\n-        });\n+    ListenerRegistration listenerRegistration =\n+        collection.addSnapshotListener(\n+            (snapshot, error) -> {\n+              assertNotNull(snapshot);\n+\n+              // Skip the initial empty snapshot.\n+              if (snapshot.isEmpty()) return;\n+\n+              assertThat(snapshot.getDocuments()).hasSize(1);\n+              DocumentSnapshot docSnap = snapshot.getDocuments().get(0);\n+\n+              if (snapshot.getMetadata().hasPendingWrites()) {\n+                // Offline snapshot. Since the server timestamp is uncommitted, we shouldn't be able\n+                // to query by it.\n+                assertThrows(\n+                    IllegalArgumentException.class,\n+                    () ->\n+                        collection\n+                            .orderBy(\"timestamp\")\n+                            .endAt(docSnap)\n+                            .addSnapshotListener((snapshot2, error2) -> {}));\n+                // Use `trySetResult` since the callbacks fires twice if the WatchStream\n+                // acknowledges the Write before the WriteStream.\n+                offlineCallbackDone.trySetResult(null);\n+              } else {\n+                // Online snapshot. Since the server timestamp is committed, we should be able to\n+                // query by it.\n+                collection\n+                    .orderBy(\"timestamp\")\n+                    .endAt(docSnap)\n+                    .addSnapshotListener((snapshot2, error2) -> {});\n+                onlineCallbackDone.trySetResult(null);\n+              }\n+            });\n \n     DocumentReference document = collection.document();\n     document.set(map(\"timestamp\", FieldValue.serverTimestamp()));\n     waitFor(offlineCallbackDone.getTask());\n \n     waitFor(collection.firestore.getClient().enableNetwork());\n     waitFor(onlineCallbackDone.getTask());\n+\n+    listenerRegistration.remove();", "originalCommit": "c7ae01581b85432b6bc6080f2313f1cfbe0a9cf8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}