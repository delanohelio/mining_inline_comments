{"pr_number": 2620, "pr_title": "API8 Fixing Data Impl", "pr_createdAt": "2020-05-22T17:40:08Z", "pr_url": "https://github.com/SpongePowered/Sponge/pull/2620", "timeline": [{"oid": "f3c98dd27204e8181525d92c657a099855405c42", "url": "https://github.com/SpongePowered/Sponge/commit/f3c98dd27204e8181525d92c657a099855405c42", "message": "looking better", "committedDate": "2020-05-23T11:11:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjI4NA==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542284", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n          \n          \n            \n                private final Map<Class<?>, DataBuilder<?>> builders = new IdentityHashMap<>();", "author": "ImMorpheus", "createdAt": "2020-05-23T12:34:12Z", "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjMyNg==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542326", "bodyText": "You can replace contains + put with putIfAbsent and check the return value", "author": "ImMorpheus", "createdAt": "2020-05-23T12:34:59Z", "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjM2Nw==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542367", "bodyText": "Same as above", "author": "ImMorpheus", "createdAt": "2020-05-23T12:35:25Z", "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {\n+            if (!(builder instanceof AbstractDataBuilder)) {\n+                SpongeImpl.getLogger().warn(\"A custom DataBuilder is not extending AbstractDataBuilder! It is recommended that \"\n+                                            + \"the custom data builder does extend it to gain automated content versioning updates and maintain \"\n+                                            + \"simplicity. The offending builder's class is: {}\", builder.getClass());\n+            }\n+            this.builders.put(clazz, builder);\n+        } else {\n+            SpongeImpl.getLogger().warn(\"A DataBuilder has already been registered for {}. Attempted to register {} instead.\", clazz,\n+                    builder.getClass());\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> void registerContentUpdater(Class<T> clazz, DataContentUpdater updater) {\n+        Preconditions.checkNotNull(updater, \"DataContentUpdater was null!\");\n+        if (!this.updatersMap.containsKey(Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"))) {", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjQ0NQ==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542445", "bodyText": "Replace contains + get with get and check if the return value is null", "author": "ImMorpheus", "createdAt": "2020-05-23T12:36:34Z", "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {\n+            if (!(builder instanceof AbstractDataBuilder)) {\n+                SpongeImpl.getLogger().warn(\"A custom DataBuilder is not extending AbstractDataBuilder! It is recommended that \"\n+                                            + \"the custom data builder does extend it to gain automated content versioning updates and maintain \"\n+                                            + \"simplicity. The offending builder's class is: {}\", builder.getClass());\n+            }\n+            this.builders.put(clazz, builder);\n+        } else {\n+            SpongeImpl.getLogger().warn(\"A DataBuilder has already been registered for {}. Attempted to register {} instead.\", clazz,\n+                    builder.getClass());\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> void registerContentUpdater(Class<T> clazz, DataContentUpdater updater) {\n+        Preconditions.checkNotNull(updater, \"DataContentUpdater was null!\");\n+        if (!this.updatersMap.containsKey(Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"))) {\n+            this.updatersMap.put(clazz, new ArrayList<>());\n+        }\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(clazz);\n+        updaters.add(updater);\n+        Collections.sort(updaters, Constants.Functional.DATA_CONTENT_UPDATER_COMPARATOR);\n+    }\n+\n+    public void registerCustomDataContentUpdater(DataContentUpdater updater) {\n+        this.customDataUpdaters.add(updater);\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<DataContentUpdater> getWrappedContentUpdater(Class<T> clazz, final int fromVersion, final int toVersion) {\n+        Preconditions.checkArgument(fromVersion != toVersion, \"Attempting to convert to the same version!\");\n+        Preconditions.checkArgument(fromVersion < toVersion, \"Attempting to backwards convert data! This isn't supported!\");\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(\n+            Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"));\n+        if (updaters == null) {\n+            return Optional.empty();\n+        }\n+        return getWrappedContentUpdater(clazz, fromVersion, toVersion, updaters);\n+    }\n+\n+    private static Optional<DataContentUpdater> getWrappedContentUpdater(Class<?> clazz, int fromVersion, int toVersion, List<DataContentUpdater> updaters) {\n+        ImmutableList.Builder<DataContentUpdater> builder = ImmutableList.builder();\n+        int version = fromVersion;\n+        for (DataContentUpdater updater : updaters) {\n+            if (updater.getInputVersion() == version) {\n+                if (updater.getOutputVersion() > toVersion) {\n+                    continue;\n+                }\n+                version = updater.getOutputVersion();\n+                builder.add(updater);\n+            }\n+        }\n+        if (version < toVersion || version > toVersion) { // There wasn't a registered updater for the version being requested\n+            Exception e = new IllegalStateException(\"The requested content version for: \" + clazz.getSimpleName() + \" was requested, \"\n+                                                    + \"\\nhowever, the versions supplied: from \"+ fromVersion + \" to \" + toVersion + \" is impossible\"\n+                                                    + \"\\nas the latest version registered is: \" + version+\". Please notify the developer of\"\n+                                                    + \"\\nthe requested consumed DataSerializable of this error.\");\n+            e.printStackTrace();\n+            return Optional.empty();\n+        }\n+        return Optional.of(new DataUpdaterDelegate(builder.build(), fromVersion, toVersion));\n+    }\n+\n+    @Override\n+    @SuppressWarnings({\"unchecked\"})\n+    public <T extends DataSerializable> Optional<DataBuilder<T>> getBuilder(Class<T> clazz) {\n+        Preconditions.checkNotNull(clazz);\n+        if (this.builders.containsKey(clazz)) {", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjQ2Mw==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542463", "bodyText": "You can replace contains + put with putIfAbsent and check the return value", "author": "ImMorpheus", "createdAt": "2020-05-23T12:36:58Z", "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {\n+            if (!(builder instanceof AbstractDataBuilder)) {\n+                SpongeImpl.getLogger().warn(\"A custom DataBuilder is not extending AbstractDataBuilder! It is recommended that \"\n+                                            + \"the custom data builder does extend it to gain automated content versioning updates and maintain \"\n+                                            + \"simplicity. The offending builder's class is: {}\", builder.getClass());\n+            }\n+            this.builders.put(clazz, builder);\n+        } else {\n+            SpongeImpl.getLogger().warn(\"A DataBuilder has already been registered for {}. Attempted to register {} instead.\", clazz,\n+                    builder.getClass());\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> void registerContentUpdater(Class<T> clazz, DataContentUpdater updater) {\n+        Preconditions.checkNotNull(updater, \"DataContentUpdater was null!\");\n+        if (!this.updatersMap.containsKey(Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"))) {\n+            this.updatersMap.put(clazz, new ArrayList<>());\n+        }\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(clazz);\n+        updaters.add(updater);\n+        Collections.sort(updaters, Constants.Functional.DATA_CONTENT_UPDATER_COMPARATOR);\n+    }\n+\n+    public void registerCustomDataContentUpdater(DataContentUpdater updater) {\n+        this.customDataUpdaters.add(updater);\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<DataContentUpdater> getWrappedContentUpdater(Class<T> clazz, final int fromVersion, final int toVersion) {\n+        Preconditions.checkArgument(fromVersion != toVersion, \"Attempting to convert to the same version!\");\n+        Preconditions.checkArgument(fromVersion < toVersion, \"Attempting to backwards convert data! This isn't supported!\");\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(\n+            Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"));\n+        if (updaters == null) {\n+            return Optional.empty();\n+        }\n+        return getWrappedContentUpdater(clazz, fromVersion, toVersion, updaters);\n+    }\n+\n+    private static Optional<DataContentUpdater> getWrappedContentUpdater(Class<?> clazz, int fromVersion, int toVersion, List<DataContentUpdater> updaters) {\n+        ImmutableList.Builder<DataContentUpdater> builder = ImmutableList.builder();\n+        int version = fromVersion;\n+        for (DataContentUpdater updater : updaters) {\n+            if (updater.getInputVersion() == version) {\n+                if (updater.getOutputVersion() > toVersion) {\n+                    continue;\n+                }\n+                version = updater.getOutputVersion();\n+                builder.add(updater);\n+            }\n+        }\n+        if (version < toVersion || version > toVersion) { // There wasn't a registered updater for the version being requested\n+            Exception e = new IllegalStateException(\"The requested content version for: \" + clazz.getSimpleName() + \" was requested, \"\n+                                                    + \"\\nhowever, the versions supplied: from \"+ fromVersion + \" to \" + toVersion + \" is impossible\"\n+                                                    + \"\\nas the latest version registered is: \" + version+\". Please notify the developer of\"\n+                                                    + \"\\nthe requested consumed DataSerializable of this error.\");\n+            e.printStackTrace();\n+            return Optional.empty();\n+        }\n+        return Optional.of(new DataUpdaterDelegate(builder.build(), fromVersion, toVersion));\n+    }\n+\n+    @Override\n+    @SuppressWarnings({\"unchecked\"})\n+    public <T extends DataSerializable> Optional<DataBuilder<T>> getBuilder(Class<T> clazz) {\n+        Preconditions.checkNotNull(clazz);\n+        if (this.builders.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.builders.get(clazz));\n+        } else if (this.immutableDataBuilderMap.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.immutableDataBuilderMap.get(clazz));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<T> deserialize(Class<T> clazz, final DataView dataView) {\n+        final Optional<DataBuilder<T>> optional = this.getBuilder(clazz);\n+        return optional.flatMap(tDataBuilder -> tDataBuilder.build(dataView));\n+    }\n+\n+    @Override\n+    public <T extends DataHolder.Immutable<T>, B extends DataHolderBuilder.Immutable<T, B>> void register(Class<T> holderClass, B builder) {\n+        if (!this.immutableDataBuilderMap.containsKey(Preconditions.checkNotNull(holderClass))) {", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjQ3Ng==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542476", "bodyText": "Same as above", "author": "ImMorpheus", "createdAt": "2020-05-23T12:37:13Z", "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {\n+            if (!(builder instanceof AbstractDataBuilder)) {\n+                SpongeImpl.getLogger().warn(\"A custom DataBuilder is not extending AbstractDataBuilder! It is recommended that \"\n+                                            + \"the custom data builder does extend it to gain automated content versioning updates and maintain \"\n+                                            + \"simplicity. The offending builder's class is: {}\", builder.getClass());\n+            }\n+            this.builders.put(clazz, builder);\n+        } else {\n+            SpongeImpl.getLogger().warn(\"A DataBuilder has already been registered for {}. Attempted to register {} instead.\", clazz,\n+                    builder.getClass());\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> void registerContentUpdater(Class<T> clazz, DataContentUpdater updater) {\n+        Preconditions.checkNotNull(updater, \"DataContentUpdater was null!\");\n+        if (!this.updatersMap.containsKey(Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"))) {\n+            this.updatersMap.put(clazz, new ArrayList<>());\n+        }\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(clazz);\n+        updaters.add(updater);\n+        Collections.sort(updaters, Constants.Functional.DATA_CONTENT_UPDATER_COMPARATOR);\n+    }\n+\n+    public void registerCustomDataContentUpdater(DataContentUpdater updater) {\n+        this.customDataUpdaters.add(updater);\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<DataContentUpdater> getWrappedContentUpdater(Class<T> clazz, final int fromVersion, final int toVersion) {\n+        Preconditions.checkArgument(fromVersion != toVersion, \"Attempting to convert to the same version!\");\n+        Preconditions.checkArgument(fromVersion < toVersion, \"Attempting to backwards convert data! This isn't supported!\");\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(\n+            Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"));\n+        if (updaters == null) {\n+            return Optional.empty();\n+        }\n+        return getWrappedContentUpdater(clazz, fromVersion, toVersion, updaters);\n+    }\n+\n+    private static Optional<DataContentUpdater> getWrappedContentUpdater(Class<?> clazz, int fromVersion, int toVersion, List<DataContentUpdater> updaters) {\n+        ImmutableList.Builder<DataContentUpdater> builder = ImmutableList.builder();\n+        int version = fromVersion;\n+        for (DataContentUpdater updater : updaters) {\n+            if (updater.getInputVersion() == version) {\n+                if (updater.getOutputVersion() > toVersion) {\n+                    continue;\n+                }\n+                version = updater.getOutputVersion();\n+                builder.add(updater);\n+            }\n+        }\n+        if (version < toVersion || version > toVersion) { // There wasn't a registered updater for the version being requested\n+            Exception e = new IllegalStateException(\"The requested content version for: \" + clazz.getSimpleName() + \" was requested, \"\n+                                                    + \"\\nhowever, the versions supplied: from \"+ fromVersion + \" to \" + toVersion + \" is impossible\"\n+                                                    + \"\\nas the latest version registered is: \" + version+\". Please notify the developer of\"\n+                                                    + \"\\nthe requested consumed DataSerializable of this error.\");\n+            e.printStackTrace();\n+            return Optional.empty();\n+        }\n+        return Optional.of(new DataUpdaterDelegate(builder.build(), fromVersion, toVersion));\n+    }\n+\n+    @Override\n+    @SuppressWarnings({\"unchecked\"})\n+    public <T extends DataSerializable> Optional<DataBuilder<T>> getBuilder(Class<T> clazz) {\n+        Preconditions.checkNotNull(clazz);\n+        if (this.builders.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.builders.get(clazz));\n+        } else if (this.immutableDataBuilderMap.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.immutableDataBuilderMap.get(clazz));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<T> deserialize(Class<T> clazz, final DataView dataView) {\n+        final Optional<DataBuilder<T>> optional = this.getBuilder(clazz);\n+        return optional.flatMap(tDataBuilder -> tDataBuilder.build(dataView));\n+    }\n+\n+    @Override\n+    public <T extends DataHolder.Immutable<T>, B extends DataHolderBuilder.Immutable<T, B>> void register(Class<T> holderClass, B builder) {\n+        if (!this.immutableDataBuilderMap.containsKey(Preconditions.checkNotNull(holderClass))) {\n+            this.immutableDataBuilderMap.put(holderClass, Preconditions.checkNotNull(builder));\n+        } else {\n+            throw new IllegalStateException(\"Already registered the DataUtil for \" + holderClass.getCanonicalName());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends DataHolder.Immutable<T>, B extends DataHolderBuilder.Immutable<T, B>> Optional<B> getImmutableBuilder(Class<T> holderClass) {\n+        return Optional.ofNullable((B) this.immutableDataBuilderMap.get(Preconditions.checkNotNull(holderClass)));\n+    }\n+\n+    public static void finalizeRegistration() {\n+        allowRegistrations = false;\n+        registerKeyListeners();\n+    }\n+\n+    @Override\n+    public void registerLegacyManipulatorIds(String legacyId, DataRegistration registration) {\n+        Preconditions.checkState(allowRegistrations);\n+        if (this.legacyRegistrations.containsKey(legacyId)) {", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjU3MA==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542570", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Map<PluginContainer, List<SpongeDataRegistration>> pluginRegistrations = new HashMap<>();\n          \n          \n            \n                private final Map<PluginContainer, List<SpongeDataRegistration>> pluginRegistrations = new IdentityHashMap<>();", "author": "ImMorpheus", "createdAt": "2020-05-23T12:38:09Z", "path": "src/main/java/org/spongepowered/common/data/SpongeDataManager.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.MapMaker;\n+import com.google.common.collect.Maps;\n+import com.google.common.reflect.TypeToken;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import net.minecraft.nbt.CompoundNBT;\n+import net.minecraft.nbt.INBT;\n+import net.minecraft.nbt.ListNBT;\n+import net.minecraft.util.registry.Registry;\n+import ninja.leaping.configurate.objectmapping.serialize.TypeSerializers;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.CatalogType;\n+import org.spongepowered.api.data.DataHolder;\n+import org.spongepowered.api.data.DataHolderBuilder;\n+import org.spongepowered.api.data.DataManager;\n+import org.spongepowered.api.data.DataManipulator;\n+import org.spongepowered.api.data.DataManipulator.Mutable;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.AbstractDataBuilder;\n+import org.spongepowered.api.data.persistence.DataBuilder;\n+import org.spongepowered.api.data.persistence.DataContainer;\n+import org.spongepowered.api.data.persistence.DataContentUpdater;\n+import org.spongepowered.api.data.persistence.DataSerializable;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.api.data.persistence.DataTranslator;\n+import org.spongepowered.api.data.persistence.DataView;\n+import org.spongepowered.api.data.persistence.Queries;\n+import org.spongepowered.api.plugin.PluginContainer;\n+import org.spongepowered.common.SpongeImpl;\n+import org.spongepowered.common.bridge.data.CustomDataHolderBridge;\n+import org.spongepowered.common.config.DataSerializableTypeSerializer;\n+import org.spongepowered.common.data.persistence.NbtTranslator;\n+import org.spongepowered.common.registry.MappedRegistry;\n+import org.spongepowered.common.registry.SpongeCatalogRegistry;\n+import org.spongepowered.common.util.Constants;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+@Singleton\n+public final class SpongeDataManager implements DataManager {\n+    private static final SpongeDataManager INSTANCE = new SpongeDataManager();\n+\n+    private static final TypeToken<CatalogType> catalogTypeToken = TypeToken.of(CatalogType.class);\n+    private static final TypeToken<DataSerializable> dataSerializableTypeToken = TypeToken.of(DataSerializable.class);\n+\n+    static {\n+        TypeSerializers.getDefaultSerializers().registerPredicate(\n+            // We have a separate type serializer for CatalogTypes, so we explicitly discount them here.\n+            // See https://github.com/SpongePowered/SpongeCommon/issues/1348\n+            x -> dataSerializableTypeToken.isSupertypeOf(x) && !catalogTypeToken.isSupertypeOf(x), new DataSerializableTypeSerializer()\n+        );\n+    }\n+\n+    // Builders\n+    private final Map<Class<?>, DataBuilder<?>> builders = Maps.newHashMap();\n+\n+\n+    private final Map<Class<? extends DataHolder.Immutable<?>>, DataHolderBuilder.Immutable<?, ?>> immutableDataBuilderMap = new MapMaker()\n+        .concurrencyLevel(4)\n+        .makeMap();\n+    // Content updaters\n+    private final Map<Class<? extends DataSerializable>, List<DataContentUpdater>> updatersMap = new IdentityHashMap<>();\n+\n+\n+    static boolean allowRegistrations = true;\n+    private List<DataContentUpdater> customDataUpdaters = new ArrayList<>();\n+\n+\n+    public static SpongeDataManager getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Inject\n+    private SpongeDataManager() {}\n+\n+    @Override\n+    public <T extends DataSerializable> void registerBuilder(Class<T> clazz, DataBuilder<T> builder) {\n+        Preconditions.checkNotNull(clazz);\n+        Preconditions.checkNotNull(builder);\n+        if (!this.builders.containsKey(clazz)) {\n+            if (!(builder instanceof AbstractDataBuilder)) {\n+                SpongeImpl.getLogger().warn(\"A custom DataBuilder is not extending AbstractDataBuilder! It is recommended that \"\n+                                            + \"the custom data builder does extend it to gain automated content versioning updates and maintain \"\n+                                            + \"simplicity. The offending builder's class is: {}\", builder.getClass());\n+            }\n+            this.builders.put(clazz, builder);\n+        } else {\n+            SpongeImpl.getLogger().warn(\"A DataBuilder has already been registered for {}. Attempted to register {} instead.\", clazz,\n+                    builder.getClass());\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> void registerContentUpdater(Class<T> clazz, DataContentUpdater updater) {\n+        Preconditions.checkNotNull(updater, \"DataContentUpdater was null!\");\n+        if (!this.updatersMap.containsKey(Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"))) {\n+            this.updatersMap.put(clazz, new ArrayList<>());\n+        }\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(clazz);\n+        updaters.add(updater);\n+        Collections.sort(updaters, Constants.Functional.DATA_CONTENT_UPDATER_COMPARATOR);\n+    }\n+\n+    public void registerCustomDataContentUpdater(DataContentUpdater updater) {\n+        this.customDataUpdaters.add(updater);\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<DataContentUpdater> getWrappedContentUpdater(Class<T> clazz, final int fromVersion, final int toVersion) {\n+        Preconditions.checkArgument(fromVersion != toVersion, \"Attempting to convert to the same version!\");\n+        Preconditions.checkArgument(fromVersion < toVersion, \"Attempting to backwards convert data! This isn't supported!\");\n+        final List<DataContentUpdater> updaters = this.updatersMap.get(\n+            Preconditions.checkNotNull(clazz, \"DataSerializable class was null!\"));\n+        if (updaters == null) {\n+            return Optional.empty();\n+        }\n+        return getWrappedContentUpdater(clazz, fromVersion, toVersion, updaters);\n+    }\n+\n+    private static Optional<DataContentUpdater> getWrappedContentUpdater(Class<?> clazz, int fromVersion, int toVersion, List<DataContentUpdater> updaters) {\n+        ImmutableList.Builder<DataContentUpdater> builder = ImmutableList.builder();\n+        int version = fromVersion;\n+        for (DataContentUpdater updater : updaters) {\n+            if (updater.getInputVersion() == version) {\n+                if (updater.getOutputVersion() > toVersion) {\n+                    continue;\n+                }\n+                version = updater.getOutputVersion();\n+                builder.add(updater);\n+            }\n+        }\n+        if (version < toVersion || version > toVersion) { // There wasn't a registered updater for the version being requested\n+            Exception e = new IllegalStateException(\"The requested content version for: \" + clazz.getSimpleName() + \" was requested, \"\n+                                                    + \"\\nhowever, the versions supplied: from \"+ fromVersion + \" to \" + toVersion + \" is impossible\"\n+                                                    + \"\\nas the latest version registered is: \" + version+\". Please notify the developer of\"\n+                                                    + \"\\nthe requested consumed DataSerializable of this error.\");\n+            e.printStackTrace();\n+            return Optional.empty();\n+        }\n+        return Optional.of(new DataUpdaterDelegate(builder.build(), fromVersion, toVersion));\n+    }\n+\n+    @Override\n+    @SuppressWarnings({\"unchecked\"})\n+    public <T extends DataSerializable> Optional<DataBuilder<T>> getBuilder(Class<T> clazz) {\n+        Preconditions.checkNotNull(clazz);\n+        if (this.builders.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.builders.get(clazz));\n+        } else if (this.immutableDataBuilderMap.containsKey(clazz)) {\n+            return Optional.of((DataBuilder<T>) this.immutableDataBuilderMap.get(clazz));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    @Override\n+    public <T extends DataSerializable> Optional<T> deserialize(Class<T> clazz, final DataView dataView) {\n+        final Optional<DataBuilder<T>> optional = this.getBuilder(clazz);\n+        return optional.flatMap(tDataBuilder -> tDataBuilder.build(dataView));\n+    }\n+\n+    @Override\n+    public <T extends DataHolder.Immutable<T>, B extends DataHolderBuilder.Immutable<T, B>> void register(Class<T> holderClass, B builder) {\n+        if (!this.immutableDataBuilderMap.containsKey(Preconditions.checkNotNull(holderClass))) {\n+            this.immutableDataBuilderMap.put(holderClass, Preconditions.checkNotNull(builder));\n+        } else {\n+            throw new IllegalStateException(\"Already registered the DataUtil for \" + holderClass.getCanonicalName());\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T extends DataHolder.Immutable<T>, B extends DataHolderBuilder.Immutable<T, B>> Optional<B> getImmutableBuilder(Class<T> holderClass) {\n+        return Optional.ofNullable((B) this.immutableDataBuilderMap.get(Preconditions.checkNotNull(holderClass)));\n+    }\n+\n+    public static void finalizeRegistration() {\n+        allowRegistrations = false;\n+        registerKeyListeners();\n+    }\n+\n+    @Override\n+    public void registerLegacyManipulatorIds(String legacyId, DataRegistration registration) {\n+        Preconditions.checkState(allowRegistrations);\n+        if (this.legacyRegistrations.containsKey(legacyId)) {\n+            throw new IllegalStateException(\"Legacy registration id already registered: id\" + legacyId + \" for registration: \" + registration);\n+        }\n+        this.legacyRegistrations.put(legacyId, (SpongeDataRegistration) registration);\n+    }\n+\n+    public Optional<DataRegistration> getRegistrationForLegacyId(String id) {\n+        return Optional.ofNullable(this.legacyRegistrations.get(id));\n+    }\n+\n+    @SuppressWarnings(value = {\"unchecked\", \"rawtypes\"})\n+    @Override\n+    public <T> Optional<DataTranslator<T>> getTranslator(Class<T> objectClass) {\n+        final Registry<DataTranslator> registry = SpongeImpl.getRegistry().getCatalogRegistry().getRegistry(DataTranslator.class);\n+        final DataTranslator reverseMapping = ((MappedRegistry<DataTranslator, Class>) registry).getReverseMapping(objectClass);\n+        return Optional.ofNullable(reverseMapping);\n+    }\n+\n+    @Override\n+    public Collection<DataRegistration> getAllRegistrationsFor(PluginContainer container) {\n+\n+        return Collections.unmodifiableCollection(this.pluginRegistrations.getOrDefault(container, Collections.emptyList()));\n+    }\n+\n+    @Override\n+    public DataContainer createContainer() {\n+        return new MemoryDataContainer();\n+    }\n+\n+    @Override\n+    public DataContainer createContainer(DataView.SafetyMode safety) {\n+        return new MemoryDataContainer(safety);\n+    }\n+\n+    void validateRegistration(SpongeDataRegistration registration) {\n+        Preconditions.checkState(allowRegistrations);\n+\n+        CatalogKey key = registration.key;\n+        PluginContainer plugin = registration.plugin;\n+\n+        Map<Key, DataProvider> dataProviderMap = registration.dataProviderMap;\n+        Map<TypeToken, DataStore> dataStoreMap = registration.dataStoreMap;\n+        List<Key<?>> keys = registration.keys;\n+\n+        // TODO\n+    }\n+\n+    public static boolean areRegistrationsComplete() {\n+        return !allowRegistrations;\n+    }\n+\n+    private final Map<PluginContainer, List<SpongeDataRegistration>> pluginRegistrations = new HashMap<>();", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MjcwNA==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542704", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Map<TypeToken, DataStore> dataStoreMap = new HashMap<>();\n          \n          \n            \n                Map<TypeToken, DataStore> dataStoreMap = new IdentityHashMap<>();", "author": "ImMorpheus", "createdAt": "2020-05-23T12:40:27Z", "path": "src/main/java/org/spongepowered/common/data/SpongeDataRegistrationBuilder.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.reflect.TypeToken;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.DuplicateDataStoreException;\n+import org.spongepowered.api.data.DuplicateProviderException;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.common.SpongeImplHooks;\n+import org.spongepowered.common.util.SpongeCatalogBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class SpongeDataRegistrationBuilder extends SpongeCatalogBuilder<DataRegistration, DataRegistration.Builder> implements DataRegistration.Builder{\n+\n+    Map<Key, DataProvider> dataProviderMap = new HashMap<>();\n+    Map<TypeToken, DataStore> dataStoreMap = new HashMap<>();", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0Mjg0Mw==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542843", "bodyText": "Collections#addAll", "author": "ImMorpheus", "createdAt": "2020-05-23T12:41:49Z", "path": "src/main/java/org/spongepowered/common/data/SpongeDataRegistrationBuilder.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.reflect.TypeToken;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.DuplicateDataStoreException;\n+import org.spongepowered.api.data.DuplicateProviderException;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.common.SpongeImplHooks;\n+import org.spongepowered.common.util.SpongeCatalogBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class SpongeDataRegistrationBuilder extends SpongeCatalogBuilder<DataRegistration, DataRegistration.Builder> implements DataRegistration.Builder{\n+\n+    Map<Key, DataProvider> dataProviderMap = new HashMap<>();\n+    Map<TypeToken, DataStore> dataStoreMap = new HashMap<>();\n+    List<Key<?>> keys = new ArrayList<>();\n+\n+    @Override\n+    public DataRegistration.Builder store(DataStore store) throws DuplicateDataStoreException {\n+        this.dataStoreMap.put(store.getSupportedToken(), store);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder provider(DataProvider<?, ?> provider) throws DuplicateProviderException {\n+        this.dataProviderMap.put(provider.getKey(), provider);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder key(Key<?> key) {\n+        this.keys.add(key);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder key(Key<?> key, Key<?>... others) {\n+        this.keys.add(key);\n+        this.keys.addAll(Arrays.asList(others));", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0Mjg2MA==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429542860", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.dataStoreMap = new HashMap<>();\n          \n          \n            \n                    this.dataStoreMap = new IdentityHashMap<>();", "author": "ImMorpheus", "createdAt": "2020-05-23T12:42:03Z", "path": "src/main/java/org/spongepowered/common/data/SpongeDataRegistrationBuilder.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.data;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.reflect.TypeToken;\n+import org.spongepowered.api.CatalogKey;\n+import org.spongepowered.api.data.DataProvider;\n+import org.spongepowered.api.data.DataRegistration;\n+import org.spongepowered.api.data.DuplicateDataStoreException;\n+import org.spongepowered.api.data.DuplicateProviderException;\n+import org.spongepowered.api.data.Key;\n+import org.spongepowered.api.data.persistence.DataStore;\n+import org.spongepowered.common.SpongeImplHooks;\n+import org.spongepowered.common.util.SpongeCatalogBuilder;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public final class SpongeDataRegistrationBuilder extends SpongeCatalogBuilder<DataRegistration, DataRegistration.Builder> implements DataRegistration.Builder{\n+\n+    Map<Key, DataProvider> dataProviderMap = new HashMap<>();\n+    Map<TypeToken, DataStore> dataStoreMap = new HashMap<>();\n+    List<Key<?>> keys = new ArrayList<>();\n+\n+    @Override\n+    public DataRegistration.Builder store(DataStore store) throws DuplicateDataStoreException {\n+        this.dataStoreMap.put(store.getSupportedToken(), store);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder provider(DataProvider<?, ?> provider) throws DuplicateProviderException {\n+        this.dataProviderMap.put(provider.getKey(), provider);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder key(Key<?> key) {\n+        this.keys.add(key);\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder key(Key<?> key, Key<?>... others) {\n+        this.keys.add(key);\n+        this.keys.addAll(Arrays.asList(others));\n+        return this;\n+    }\n+\n+    @Override\n+    public DataRegistration.Builder key(Iterable<Key<?>> keys) {\n+        keys.forEach(this.keys::add);\n+        return this;\n+    }\n+\n+    @Override\n+    protected DataRegistration build(CatalogKey key) {\n+        // TODO restrictions?\n+        return new SpongeDataRegistration(key, SpongeImplHooks.getActiveModContainer(), this);\n+    }\n+\n+    @Override\n+    public SpongeDataRegistrationBuilder reset() {\n+        super.reset();\n+        this.dataProviderMap = new HashMap<>();\n+        this.dataStoreMap = new HashMap<>();", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MzExNA==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429543114", "bodyText": "Replace get + put with computeIfAbsent", "author": "ImMorpheus", "createdAt": "2020-05-23T12:45:23Z", "path": "src/main/java/org/spongepowered/common/registry/SpongeCatalogRegistry.java", "diffHunk": "@@ -302,6 +308,22 @@ public SpongeCatalogRegistry registerRegistry(Class<CatalogType> catalogClass, C\n         return this;\n     }\n \n+    private <T extends CatalogType> SpongeCatalogRegistry registerCallbackRegistry(Class<T> catalogClass, CatalogKey key, BiConsumer<ResourceLocation, T> callback) {\n+        checkNotNull(catalogClass);\n+        checkNotNull(key);\n+\n+        if (this.registries.get(key) != null) {", "originalCommit": "f3c98dd27204e8181525d92c657a099855405c42", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0OTQ3Mg==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429549472", "bodyText": "but it throws exception if present", "author": "Faithcaio", "createdAt": "2020-05-23T14:11:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MzExNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1MTM3Nw==", "url": "https://github.com/SpongePowered/Sponge/pull/2620#discussion_r429551377", "bodyText": "final CallbackRegistry<T> previous = this.registries.putIfAbsent(key, (Registry<CatalogType>) registry);\nif (previous != null) {\n    throw ...\n}\n\n(Same with compute, but putIfAbsent is fine since registry is used later and it doesn't need to be constructed lazily)", "author": "ImMorpheus", "createdAt": "2020-05-23T14:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU0MzExNA=="}], "type": "inlineReview"}, {"oid": "d453bc0329726c53176b029cfa5c7d29eca13dbe", "url": "https://github.com/SpongePowered/Sponge/commit/d453bc0329726c53176b029cfa5c7d29eca13dbe", "message": "comments", "committedDate": "2020-05-23T19:06:54Z", "type": "forcePushed"}, {"oid": "1849345bb44af620308c36a4cb1f90cfaf9add1d", "url": "https://github.com/SpongePowered/Sponge/commit/1849345bb44af620308c36a4cb1f90cfaf9add1d", "message": "move stuff back from invalid", "committedDate": "2020-05-24T07:29:06Z", "type": "commit"}, {"oid": "bb7acdb7d2e7bef817f8439638330df6ccd30bf5", "url": "https://github.com/SpongePowered/Sponge/commit/bb7acdb7d2e7bef817f8439638330df6ccd30bf5", "message": "implement custom data", "committedDate": "2020-05-24T07:32:33Z", "type": "commit"}, {"oid": "accf6b84ce69209969e2402ae755d1dcf2b60bb5", "url": "https://github.com/SpongePowered/Sponge/commit/accf6b84ce69209969e2402ae755d1dcf2b60bb5", "message": "keylistener", "committedDate": "2020-05-24T07:33:34Z", "type": "commit"}, {"oid": "accf6b84ce69209969e2402ae755d1dcf2b60bb5", "url": "https://github.com/SpongePowered/Sponge/commit/accf6b84ce69209969e2402ae755d1dcf2b60bb5", "message": "keylistener", "committedDate": "2020-05-24T07:33:34Z", "type": "forcePushed"}]}