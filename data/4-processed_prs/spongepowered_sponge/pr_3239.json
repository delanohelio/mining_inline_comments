{"pr_number": 3239, "pr_title": "Porting the portals", "pr_createdAt": "2020-12-18T20:07:28Z", "pr_url": "https://github.com/SpongePowered/Sponge/pull/3239", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2NzgzNQ==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546067835", "bodyText": "This is a respawn and makes sense to not do anything with the logic here.", "author": "Zidane", "createdAt": "2020-12-18T20:11:31Z", "path": "src/mixins/java/org/spongepowered/common/mixin/core/entity/player/ServerPlayerEntityMixin.java", "diffHunk": "@@ -468,26 +495,144 @@ public void teleportTo(net.minecraft.world.server.ServerWorld world, double x, d\n     }\n \n     /**\n-     * @author zidane - November 21st, 2020 - Minecraft 1.15.2\n-     * @reason Call to EntityUtil to handle dimension changes\n+     * This is effectively an overwrite of changeDimension: required due to\n+     * Forge changing the signature.\n+     *\n+     * @author dualspiral - 18th December 2020 - 1.16.4\n+     *\n+     * @param originalDestinationWorld The original target world\n+     * @param spongeTeleporter performs additional teleportation logic, as required.\n+     * @return The {@link Entity} that is either this one, or replaces this one\n      */\n-    @javax.annotation.Nullable\n-    @Overwrite\n-    public Entity changeDimension(ServerWorld destination) {\n+    @SuppressWarnings(\"ConstantConditions\")\n+    @Nullable\n+    public Entity bridge$changeDimension(final ServerWorld originalDestinationWorld, final SpongeTeleporter spongeTeleporter) {\n+        // Sponge Start\n         if (this.shadow$getCommandSenderWorld().isClientSide || this.removed) {\n             return (ServerPlayerEntity) (Object) this;\n         }\n \n-        final WrappedITeleporterPortalType portalType = new WrappedITeleporterPortalType((PlatformITeleporterBridge) destination.getPortalForcer(), null);\n-\n         try (final CauseStackManager.StackFrame frame = PhaseTracker.getCauseStackManager().pushCauseFrame()) {\n             frame.pushCause(this);\n-            frame.pushCause(portalType);\n-            frame.addContext(EventContextKeys.MOVEMENT_TYPE, MovementTypes.PORTAL);\n+            // frame.pushCause(spongeTeleporter); // TODO: Expose the SpongeTeleporter interface as Teleporter...ish?\n+            frame.addContext(EventContextKeys.MOVEMENT_TYPE, spongeTeleporter.getMovementType());\n \n-            EntityUtil.invokePortalTo((ServerPlayerEntity) (Object) this, portalType, destination);\n-            return (ServerPlayerEntity) (Object) this;\n-        }\n+            final ChangeEntityWorldEvent.Pre preChangeEvent =\n+                PlatformHooks.getInstance().getEventHooks().callChangeEntityWorldEventPre((Entity) (Object) this, originalDestinationWorld);\n+            if (preChangeEvent.isCancelled()) {\n+                return (Entity) (Object) this;\n+            }\n+            final ServerWorld targetWorld = (ServerWorld) preChangeEvent.getDestinationWorld();\n+            final Vector3d currentPosition = VecHelper.toVector3d(this.position());\n+            // Sponge End\n+            this.isChangingDimension = true;\n+            ServerWorld serverworld = this.shadow$getLevel();\n+            RegistryKey<World> registrykey = serverworld.dimension();\n+            if (registrykey == World.END && targetWorld.dimension() == World.OVERWORLD && spongeTeleporter.isVanilla()) { // avoids modded dimensions\n+                this.shadow$unRide();\n+                this.shadow$getLevel().removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                if (!this.wonGame) {\n+                    this.wonGame = true;\n+                    this.connection.send(new SChangeGameStatePacket(SChangeGameStatePacket.WIN_GAME, this.seenCredits ? 0.0F : 1.0F));\n+                    this.seenCredits = true;\n+                }\n+\n+                // TODO: Figure out the reposition step (though that might just be a respawn)", "originalCommit": "1754dff19e45c5c12a9705bd731de9ad828c4586", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2ODIzMA==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546068230", "bodyText": "Once the server can run, I can figure out if we'll need to send fake respawn packets or not (to clear Vanilla client chunk caches).\nMay need to keep in mind, if not, will need to call the packet hook for this.", "author": "Zidane", "createdAt": "2020-12-18T20:12:26Z", "path": "src/mixins/java/org/spongepowered/common/mixin/core/entity/player/ServerPlayerEntityMixin.java", "diffHunk": "@@ -468,26 +495,144 @@ public void teleportTo(net.minecraft.world.server.ServerWorld world, double x, d\n     }\n \n     /**\n-     * @author zidane - November 21st, 2020 - Minecraft 1.15.2\n-     * @reason Call to EntityUtil to handle dimension changes\n+     * This is effectively an overwrite of changeDimension: required due to\n+     * Forge changing the signature.\n+     *\n+     * @author dualspiral - 18th December 2020 - 1.16.4\n+     *\n+     * @param originalDestinationWorld The original target world\n+     * @param spongeTeleporter performs additional teleportation logic, as required.\n+     * @return The {@link Entity} that is either this one, or replaces this one\n      */\n-    @javax.annotation.Nullable\n-    @Overwrite\n-    public Entity changeDimension(ServerWorld destination) {\n+    @SuppressWarnings(\"ConstantConditions\")\n+    @Nullable\n+    public Entity bridge$changeDimension(final ServerWorld originalDestinationWorld, final SpongeTeleporter spongeTeleporter) {\n+        // Sponge Start\n         if (this.shadow$getCommandSenderWorld().isClientSide || this.removed) {\n             return (ServerPlayerEntity) (Object) this;\n         }\n \n-        final WrappedITeleporterPortalType portalType = new WrappedITeleporterPortalType((PlatformITeleporterBridge) destination.getPortalForcer(), null);\n-\n         try (final CauseStackManager.StackFrame frame = PhaseTracker.getCauseStackManager().pushCauseFrame()) {\n             frame.pushCause(this);\n-            frame.pushCause(portalType);\n-            frame.addContext(EventContextKeys.MOVEMENT_TYPE, MovementTypes.PORTAL);\n+            // frame.pushCause(spongeTeleporter); // TODO: Expose the SpongeTeleporter interface as Teleporter...ish?\n+            frame.addContext(EventContextKeys.MOVEMENT_TYPE, spongeTeleporter.getMovementType());\n \n-            EntityUtil.invokePortalTo((ServerPlayerEntity) (Object) this, portalType, destination);\n-            return (ServerPlayerEntity) (Object) this;\n-        }\n+            final ChangeEntityWorldEvent.Pre preChangeEvent =\n+                PlatformHooks.getInstance().getEventHooks().callChangeEntityWorldEventPre((Entity) (Object) this, originalDestinationWorld);\n+            if (preChangeEvent.isCancelled()) {\n+                return (Entity) (Object) this;\n+            }\n+            final ServerWorld targetWorld = (ServerWorld) preChangeEvent.getDestinationWorld();\n+            final Vector3d currentPosition = VecHelper.toVector3d(this.position());\n+            // Sponge End\n+            this.isChangingDimension = true;\n+            ServerWorld serverworld = this.shadow$getLevel();\n+            RegistryKey<World> registrykey = serverworld.dimension();\n+            if (registrykey == World.END && targetWorld.dimension() == World.OVERWORLD && spongeTeleporter.isVanilla()) { // avoids modded dimensions\n+                this.shadow$unRide();\n+                this.shadow$getLevel().removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                if (!this.wonGame) {\n+                    this.wonGame = true;\n+                    this.connection.send(new SChangeGameStatePacket(SChangeGameStatePacket.WIN_GAME, this.seenCredits ? 0.0F : 1.0F));\n+                    this.seenCredits = true;\n+                }\n+\n+                // TODO: Figure out the reposition step (though that might just be a respawn)\n+                return (Entity) (Object) this;\n+            } else {\n+                IWorldInfo iworldinfo = targetWorld.getLevelData();\n+                this.connection.send(new SRespawnPacket(targetWorld.dimensionType(), targetWorld.dimension(),", "originalCommit": "1754dff19e45c5c12a9705bd731de9ad828c4586", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2OTM4Ng==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546069386", "bodyText": "I wonder if we need to run this if the type is NETHER and not Vanilla's NETHER.\nIt may only be used for the dimension triggers which we wouldn't then, been a while since I read up on this.", "author": "Zidane", "createdAt": "2020-12-18T20:15:11Z", "path": "src/mixins/java/org/spongepowered/common/mixin/core/entity/player/ServerPlayerEntityMixin.java", "diffHunk": "@@ -468,26 +495,144 @@ public void teleportTo(net.minecraft.world.server.ServerWorld world, double x, d\n     }\n \n     /**\n-     * @author zidane - November 21st, 2020 - Minecraft 1.15.2\n-     * @reason Call to EntityUtil to handle dimension changes\n+     * This is effectively an overwrite of changeDimension: required due to\n+     * Forge changing the signature.\n+     *\n+     * @author dualspiral - 18th December 2020 - 1.16.4\n+     *\n+     * @param originalDestinationWorld The original target world\n+     * @param spongeTeleporter performs additional teleportation logic, as required.\n+     * @return The {@link Entity} that is either this one, or replaces this one\n      */\n-    @javax.annotation.Nullable\n-    @Overwrite\n-    public Entity changeDimension(ServerWorld destination) {\n+    @SuppressWarnings(\"ConstantConditions\")\n+    @Nullable\n+    public Entity bridge$changeDimension(final ServerWorld originalDestinationWorld, final SpongeTeleporter spongeTeleporter) {\n+        // Sponge Start\n         if (this.shadow$getCommandSenderWorld().isClientSide || this.removed) {\n             return (ServerPlayerEntity) (Object) this;\n         }\n \n-        final WrappedITeleporterPortalType portalType = new WrappedITeleporterPortalType((PlatformITeleporterBridge) destination.getPortalForcer(), null);\n-\n         try (final CauseStackManager.StackFrame frame = PhaseTracker.getCauseStackManager().pushCauseFrame()) {\n             frame.pushCause(this);\n-            frame.pushCause(portalType);\n-            frame.addContext(EventContextKeys.MOVEMENT_TYPE, MovementTypes.PORTAL);\n+            // frame.pushCause(spongeTeleporter); // TODO: Expose the SpongeTeleporter interface as Teleporter...ish?\n+            frame.addContext(EventContextKeys.MOVEMENT_TYPE, spongeTeleporter.getMovementType());\n \n-            EntityUtil.invokePortalTo((ServerPlayerEntity) (Object) this, portalType, destination);\n-            return (ServerPlayerEntity) (Object) this;\n-        }\n+            final ChangeEntityWorldEvent.Pre preChangeEvent =\n+                PlatformHooks.getInstance().getEventHooks().callChangeEntityWorldEventPre((Entity) (Object) this, originalDestinationWorld);\n+            if (preChangeEvent.isCancelled()) {\n+                return (Entity) (Object) this;\n+            }\n+            final ServerWorld targetWorld = (ServerWorld) preChangeEvent.getDestinationWorld();\n+            final Vector3d currentPosition = VecHelper.toVector3d(this.position());\n+            // Sponge End\n+            this.isChangingDimension = true;\n+            ServerWorld serverworld = this.shadow$getLevel();\n+            RegistryKey<World> registrykey = serverworld.dimension();\n+            if (registrykey == World.END && targetWorld.dimension() == World.OVERWORLD && spongeTeleporter.isVanilla()) { // avoids modded dimensions\n+                this.shadow$unRide();\n+                this.shadow$getLevel().removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                if (!this.wonGame) {\n+                    this.wonGame = true;\n+                    this.connection.send(new SChangeGameStatePacket(SChangeGameStatePacket.WIN_GAME, this.seenCredits ? 0.0F : 1.0F));\n+                    this.seenCredits = true;\n+                }\n+\n+                // TODO: Figure out the reposition step (though that might just be a respawn)\n+                return (Entity) (Object) this;\n+            } else {\n+                IWorldInfo iworldinfo = targetWorld.getLevelData();\n+                this.connection.send(new SRespawnPacket(targetWorld.dimensionType(), targetWorld.dimension(),\n+                        BiomeManager.obfuscateSeed(targetWorld.getSeed()), this.gameMode.getGameModeForPlayer(),\n+                        this.gameMode.getPreviousGameModeForPlayer(), targetWorld.isDebug(), targetWorld.isFlat(), true));\n+                this.connection.send(new SServerDifficultyPacket(iworldinfo.getDifficulty(), iworldinfo.isDifficultyLocked()));\n+                PlayerList playerlist = this.server.getPlayerList();\n+                playerlist.sendPlayerPermissionLevel((ServerPlayerEntity) (Object) this);\n+                serverworld.removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                this.removed = false;\n+                // Sponge Start: Redirect the find portal call to the teleporter.\n+\n+                // TODO: This could house the Reposition Event, with some flag on SpongeTeleporter that can be set to cause this to happen later\n+                //  for mods.\n+                //  This can then hold our custom portal logic (basically any edits to findDimensionEntryPoint that we might need to do)\n+                final PortalInfo portalinfo = spongeTeleporter.getPortalInfo((Entity) (Object) this, targetWorld, this::shadow$findDimensionEntryPoint);\n+                // Sponge End\n+                if (portalinfo != null) {\n+                    // Sponge Start: wrap the teleportation logic within a function to allow for modification\n+                    // of the teleporter, as well as calling events(?)\n+                    final Vector3d originalDestination = new Vector3d(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                    final Entity e = spongeTeleporter.performTeleport((Entity) (Object) this, serverworld, targetWorld, this.xRot, spawnPortal -> {\n+                        // Sponge End\n+                        serverworld.getProfiler().push(\"moving\");\n+                        if (registrykey == World.OVERWORLD && targetWorld.dimension() == World.NETHER) {", "originalCommit": "1754dff19e45c5c12a9705bd731de9ad828c4586", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2OTgzOA==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546069838", "bodyText": "Where is spawnPortal being fed from?", "author": "Zidane", "createdAt": "2020-12-18T20:16:13Z", "path": "src/mixins/java/org/spongepowered/common/mixin/core/entity/player/ServerPlayerEntityMixin.java", "diffHunk": "@@ -468,26 +495,144 @@ public void teleportTo(net.minecraft.world.server.ServerWorld world, double x, d\n     }\n \n     /**\n-     * @author zidane - November 21st, 2020 - Minecraft 1.15.2\n-     * @reason Call to EntityUtil to handle dimension changes\n+     * This is effectively an overwrite of changeDimension: required due to\n+     * Forge changing the signature.\n+     *\n+     * @author dualspiral - 18th December 2020 - 1.16.4\n+     *\n+     * @param originalDestinationWorld The original target world\n+     * @param spongeTeleporter performs additional teleportation logic, as required.\n+     * @return The {@link Entity} that is either this one, or replaces this one\n      */\n-    @javax.annotation.Nullable\n-    @Overwrite\n-    public Entity changeDimension(ServerWorld destination) {\n+    @SuppressWarnings(\"ConstantConditions\")\n+    @Nullable\n+    public Entity bridge$changeDimension(final ServerWorld originalDestinationWorld, final SpongeTeleporter spongeTeleporter) {\n+        // Sponge Start\n         if (this.shadow$getCommandSenderWorld().isClientSide || this.removed) {\n             return (ServerPlayerEntity) (Object) this;\n         }\n \n-        final WrappedITeleporterPortalType portalType = new WrappedITeleporterPortalType((PlatformITeleporterBridge) destination.getPortalForcer(), null);\n-\n         try (final CauseStackManager.StackFrame frame = PhaseTracker.getCauseStackManager().pushCauseFrame()) {\n             frame.pushCause(this);\n-            frame.pushCause(portalType);\n-            frame.addContext(EventContextKeys.MOVEMENT_TYPE, MovementTypes.PORTAL);\n+            // frame.pushCause(spongeTeleporter); // TODO: Expose the SpongeTeleporter interface as Teleporter...ish?\n+            frame.addContext(EventContextKeys.MOVEMENT_TYPE, spongeTeleporter.getMovementType());\n \n-            EntityUtil.invokePortalTo((ServerPlayerEntity) (Object) this, portalType, destination);\n-            return (ServerPlayerEntity) (Object) this;\n-        }\n+            final ChangeEntityWorldEvent.Pre preChangeEvent =\n+                PlatformHooks.getInstance().getEventHooks().callChangeEntityWorldEventPre((Entity) (Object) this, originalDestinationWorld);\n+            if (preChangeEvent.isCancelled()) {\n+                return (Entity) (Object) this;\n+            }\n+            final ServerWorld targetWorld = (ServerWorld) preChangeEvent.getDestinationWorld();\n+            final Vector3d currentPosition = VecHelper.toVector3d(this.position());\n+            // Sponge End\n+            this.isChangingDimension = true;\n+            ServerWorld serverworld = this.shadow$getLevel();\n+            RegistryKey<World> registrykey = serverworld.dimension();\n+            if (registrykey == World.END && targetWorld.dimension() == World.OVERWORLD && spongeTeleporter.isVanilla()) { // avoids modded dimensions\n+                this.shadow$unRide();\n+                this.shadow$getLevel().removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                if (!this.wonGame) {\n+                    this.wonGame = true;\n+                    this.connection.send(new SChangeGameStatePacket(SChangeGameStatePacket.WIN_GAME, this.seenCredits ? 0.0F : 1.0F));\n+                    this.seenCredits = true;\n+                }\n+\n+                // TODO: Figure out the reposition step (though that might just be a respawn)\n+                return (Entity) (Object) this;\n+            } else {\n+                IWorldInfo iworldinfo = targetWorld.getLevelData();\n+                this.connection.send(new SRespawnPacket(targetWorld.dimensionType(), targetWorld.dimension(),\n+                        BiomeManager.obfuscateSeed(targetWorld.getSeed()), this.gameMode.getGameModeForPlayer(),\n+                        this.gameMode.getPreviousGameModeForPlayer(), targetWorld.isDebug(), targetWorld.isFlat(), true));\n+                this.connection.send(new SServerDifficultyPacket(iworldinfo.getDifficulty(), iworldinfo.isDifficultyLocked()));\n+                PlayerList playerlist = this.server.getPlayerList();\n+                playerlist.sendPlayerPermissionLevel((ServerPlayerEntity) (Object) this);\n+                serverworld.removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                this.removed = false;\n+                // Sponge Start: Redirect the find portal call to the teleporter.\n+\n+                // TODO: This could house the Reposition Event, with some flag on SpongeTeleporter that can be set to cause this to happen later\n+                //  for mods.\n+                //  This can then hold our custom portal logic (basically any edits to findDimensionEntryPoint that we might need to do)\n+                final PortalInfo portalinfo = spongeTeleporter.getPortalInfo((Entity) (Object) this, targetWorld, this::shadow$findDimensionEntryPoint);\n+                // Sponge End\n+                if (portalinfo != null) {\n+                    // Sponge Start: wrap the teleportation logic within a function to allow for modification\n+                    // of the teleporter, as well as calling events(?)\n+                    final Vector3d originalDestination = new Vector3d(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                    final Entity e = spongeTeleporter.performTeleport((Entity) (Object) this, serverworld, targetWorld, this.xRot, spawnPortal -> {", "originalCommit": "1754dff19e45c5c12a9705bd731de9ad828c4586", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MTE1NA==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546071154", "bodyText": "Forge - it's to allow mod ITeleporters to prevent the creation of an end platforms.", "author": "dualspiral", "createdAt": "2020-12-18T20:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA2OTgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MDM5OQ==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546070399", "bodyText": "I heavily debated running this for Vanilla's END or END dimension types (since they will use the END generator).\nThe problem is the Vanilla code, no matter what, puts the platform there. Someone could get angry in a custom end having a build at  spawn get overwrote due to this. For Vanilla END, we can state that is game mechanics.", "author": "Zidane", "createdAt": "2020-12-18T20:17:35Z", "path": "src/mixins/java/org/spongepowered/common/mixin/core/entity/player/ServerPlayerEntityMixin.java", "diffHunk": "@@ -468,26 +495,144 @@ public void teleportTo(net.minecraft.world.server.ServerWorld world, double x, d\n     }\n \n     /**\n-     * @author zidane - November 21st, 2020 - Minecraft 1.15.2\n-     * @reason Call to EntityUtil to handle dimension changes\n+     * This is effectively an overwrite of changeDimension: required due to\n+     * Forge changing the signature.\n+     *\n+     * @author dualspiral - 18th December 2020 - 1.16.4\n+     *\n+     * @param originalDestinationWorld The original target world\n+     * @param spongeTeleporter performs additional teleportation logic, as required.\n+     * @return The {@link Entity} that is either this one, or replaces this one\n      */\n-    @javax.annotation.Nullable\n-    @Overwrite\n-    public Entity changeDimension(ServerWorld destination) {\n+    @SuppressWarnings(\"ConstantConditions\")\n+    @Nullable\n+    public Entity bridge$changeDimension(final ServerWorld originalDestinationWorld, final SpongeTeleporter spongeTeleporter) {\n+        // Sponge Start\n         if (this.shadow$getCommandSenderWorld().isClientSide || this.removed) {\n             return (ServerPlayerEntity) (Object) this;\n         }\n \n-        final WrappedITeleporterPortalType portalType = new WrappedITeleporterPortalType((PlatformITeleporterBridge) destination.getPortalForcer(), null);\n-\n         try (final CauseStackManager.StackFrame frame = PhaseTracker.getCauseStackManager().pushCauseFrame()) {\n             frame.pushCause(this);\n-            frame.pushCause(portalType);\n-            frame.addContext(EventContextKeys.MOVEMENT_TYPE, MovementTypes.PORTAL);\n+            // frame.pushCause(spongeTeleporter); // TODO: Expose the SpongeTeleporter interface as Teleporter...ish?\n+            frame.addContext(EventContextKeys.MOVEMENT_TYPE, spongeTeleporter.getMovementType());\n \n-            EntityUtil.invokePortalTo((ServerPlayerEntity) (Object) this, portalType, destination);\n-            return (ServerPlayerEntity) (Object) this;\n-        }\n+            final ChangeEntityWorldEvent.Pre preChangeEvent =\n+                PlatformHooks.getInstance().getEventHooks().callChangeEntityWorldEventPre((Entity) (Object) this, originalDestinationWorld);\n+            if (preChangeEvent.isCancelled()) {\n+                return (Entity) (Object) this;\n+            }\n+            final ServerWorld targetWorld = (ServerWorld) preChangeEvent.getDestinationWorld();\n+            final Vector3d currentPosition = VecHelper.toVector3d(this.position());\n+            // Sponge End\n+            this.isChangingDimension = true;\n+            ServerWorld serverworld = this.shadow$getLevel();\n+            RegistryKey<World> registrykey = serverworld.dimension();\n+            if (registrykey == World.END && targetWorld.dimension() == World.OVERWORLD && spongeTeleporter.isVanilla()) { // avoids modded dimensions\n+                this.shadow$unRide();\n+                this.shadow$getLevel().removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                if (!this.wonGame) {\n+                    this.wonGame = true;\n+                    this.connection.send(new SChangeGameStatePacket(SChangeGameStatePacket.WIN_GAME, this.seenCredits ? 0.0F : 1.0F));\n+                    this.seenCredits = true;\n+                }\n+\n+                // TODO: Figure out the reposition step (though that might just be a respawn)\n+                return (Entity) (Object) this;\n+            } else {\n+                IWorldInfo iworldinfo = targetWorld.getLevelData();\n+                this.connection.send(new SRespawnPacket(targetWorld.dimensionType(), targetWorld.dimension(),\n+                        BiomeManager.obfuscateSeed(targetWorld.getSeed()), this.gameMode.getGameModeForPlayer(),\n+                        this.gameMode.getPreviousGameModeForPlayer(), targetWorld.isDebug(), targetWorld.isFlat(), true));\n+                this.connection.send(new SServerDifficultyPacket(iworldinfo.getDifficulty(), iworldinfo.isDifficultyLocked()));\n+                PlayerList playerlist = this.server.getPlayerList();\n+                playerlist.sendPlayerPermissionLevel((ServerPlayerEntity) (Object) this);\n+                serverworld.removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                this.removed = false;\n+                // Sponge Start: Redirect the find portal call to the teleporter.\n+\n+                // TODO: This could house the Reposition Event, with some flag on SpongeTeleporter that can be set to cause this to happen later\n+                //  for mods.\n+                //  This can then hold our custom portal logic (basically any edits to findDimensionEntryPoint that we might need to do)\n+                final PortalInfo portalinfo = spongeTeleporter.getPortalInfo((Entity) (Object) this, targetWorld, this::shadow$findDimensionEntryPoint);\n+                // Sponge End\n+                if (portalinfo != null) {\n+                    // Sponge Start: wrap the teleportation logic within a function to allow for modification\n+                    // of the teleporter, as well as calling events(?)\n+                    final Vector3d originalDestination = new Vector3d(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                    final Entity e = spongeTeleporter.performTeleport((Entity) (Object) this, serverworld, targetWorld, this.xRot, spawnPortal -> {\n+                        // Sponge End\n+                        serverworld.getProfiler().push(\"moving\");\n+                        if (registrykey == World.OVERWORLD && targetWorld.dimension() == World.NETHER) {\n+                            this.enteredNetherPosition = this.shadow$position();\n+                        // Sponge Start: only enter this branch if we're going through portal logic\n+                        } else if (spawnPortal && targetWorld.dimension() == World.END) {", "originalCommit": "1754dff19e45c5c12a9705bd731de9ad828c4586", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MDYyNg==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546070626", "bodyText": "Should run this after instance check (589)", "author": "Zidane", "createdAt": "2020-12-18T20:18:06Z", "path": "src/mixins/java/org/spongepowered/common/mixin/core/entity/player/ServerPlayerEntityMixin.java", "diffHunk": "@@ -468,26 +495,144 @@ public void teleportTo(net.minecraft.world.server.ServerWorld world, double x, d\n     }\n \n     /**\n-     * @author zidane - November 21st, 2020 - Minecraft 1.15.2\n-     * @reason Call to EntityUtil to handle dimension changes\n+     * This is effectively an overwrite of changeDimension: required due to\n+     * Forge changing the signature.\n+     *\n+     * @author dualspiral - 18th December 2020 - 1.16.4\n+     *\n+     * @param originalDestinationWorld The original target world\n+     * @param spongeTeleporter performs additional teleportation logic, as required.\n+     * @return The {@link Entity} that is either this one, or replaces this one\n      */\n-    @javax.annotation.Nullable\n-    @Overwrite\n-    public Entity changeDimension(ServerWorld destination) {\n+    @SuppressWarnings(\"ConstantConditions\")\n+    @Nullable\n+    public Entity bridge$changeDimension(final ServerWorld originalDestinationWorld, final SpongeTeleporter spongeTeleporter) {\n+        // Sponge Start\n         if (this.shadow$getCommandSenderWorld().isClientSide || this.removed) {\n             return (ServerPlayerEntity) (Object) this;\n         }\n \n-        final WrappedITeleporterPortalType portalType = new WrappedITeleporterPortalType((PlatformITeleporterBridge) destination.getPortalForcer(), null);\n-\n         try (final CauseStackManager.StackFrame frame = PhaseTracker.getCauseStackManager().pushCauseFrame()) {\n             frame.pushCause(this);\n-            frame.pushCause(portalType);\n-            frame.addContext(EventContextKeys.MOVEMENT_TYPE, MovementTypes.PORTAL);\n+            // frame.pushCause(spongeTeleporter); // TODO: Expose the SpongeTeleporter interface as Teleporter...ish?\n+            frame.addContext(EventContextKeys.MOVEMENT_TYPE, spongeTeleporter.getMovementType());\n \n-            EntityUtil.invokePortalTo((ServerPlayerEntity) (Object) this, portalType, destination);\n-            return (ServerPlayerEntity) (Object) this;\n-        }\n+            final ChangeEntityWorldEvent.Pre preChangeEvent =\n+                PlatformHooks.getInstance().getEventHooks().callChangeEntityWorldEventPre((Entity) (Object) this, originalDestinationWorld);\n+            if (preChangeEvent.isCancelled()) {\n+                return (Entity) (Object) this;\n+            }\n+            final ServerWorld targetWorld = (ServerWorld) preChangeEvent.getDestinationWorld();\n+            final Vector3d currentPosition = VecHelper.toVector3d(this.position());\n+            // Sponge End\n+            this.isChangingDimension = true;\n+            ServerWorld serverworld = this.shadow$getLevel();\n+            RegistryKey<World> registrykey = serverworld.dimension();\n+            if (registrykey == World.END && targetWorld.dimension() == World.OVERWORLD && spongeTeleporter.isVanilla()) { // avoids modded dimensions\n+                this.shadow$unRide();\n+                this.shadow$getLevel().removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                if (!this.wonGame) {\n+                    this.wonGame = true;\n+                    this.connection.send(new SChangeGameStatePacket(SChangeGameStatePacket.WIN_GAME, this.seenCredits ? 0.0F : 1.0F));\n+                    this.seenCredits = true;\n+                }\n+\n+                // TODO: Figure out the reposition step (though that might just be a respawn)\n+                return (Entity) (Object) this;\n+            } else {\n+                IWorldInfo iworldinfo = targetWorld.getLevelData();\n+                this.connection.send(new SRespawnPacket(targetWorld.dimensionType(), targetWorld.dimension(),\n+                        BiomeManager.obfuscateSeed(targetWorld.getSeed()), this.gameMode.getGameModeForPlayer(),\n+                        this.gameMode.getPreviousGameModeForPlayer(), targetWorld.isDebug(), targetWorld.isFlat(), true));\n+                this.connection.send(new SServerDifficultyPacket(iworldinfo.getDifficulty(), iworldinfo.isDifficultyLocked()));\n+                PlayerList playerlist = this.server.getPlayerList();\n+                playerlist.sendPlayerPermissionLevel((ServerPlayerEntity) (Object) this);\n+                serverworld.removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                this.removed = false;\n+                // Sponge Start: Redirect the find portal call to the teleporter.\n+\n+                // TODO: This could house the Reposition Event, with some flag on SpongeTeleporter that can be set to cause this to happen later\n+                //  for mods.\n+                //  This can then hold our custom portal logic (basically any edits to findDimensionEntryPoint that we might need to do)\n+                final PortalInfo portalinfo = spongeTeleporter.getPortalInfo((Entity) (Object) this, targetWorld, this::shadow$findDimensionEntryPoint);\n+                // Sponge End\n+                if (portalinfo != null) {\n+                    // Sponge Start: wrap the teleportation logic within a function to allow for modification\n+                    // of the teleporter, as well as calling events(?)\n+                    final Vector3d originalDestination = new Vector3d(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                    final Entity e = spongeTeleporter.performTeleport((Entity) (Object) this, serverworld, targetWorld, this.xRot, spawnPortal -> {\n+                        // Sponge End\n+                        serverworld.getProfiler().push(\"moving\");\n+                        if (registrykey == World.OVERWORLD && targetWorld.dimension() == World.NETHER) {\n+                            this.enteredNetherPosition = this.shadow$position();\n+                        // Sponge Start: only enter this branch if we're going through portal logic\n+                        } else if (spawnPortal && targetWorld.dimension() == World.END) {\n+                            // Sponge End\n+                            this.shadow$createEndPlatform(targetWorld, new BlockPos(portalinfo.pos));\n+                        }\n+\n+                        serverworld.getProfiler().pop();\n+                        serverworld.getProfiler().push(\"placing\");\n+                        this.shadow$setLevel(targetWorld);\n+                        targetWorld.addDuringPortalTeleport((ServerPlayerEntity) (Object) this);\n+                        this.shadow$setRot(portalinfo.yRot, portalinfo.xRot);\n+                        this.shadow$moveTo(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                        serverworld.getProfiler().pop();\n+                        // Sponge Start: return this entity\n+                        return (Entity) (Object) this;\n+                    });\n+                    // Sponge End\n+                    // This is done here (it's not in Forge) to ensure that it's done. This is to ensure\n+                    // advancements are triggered.\n+                    this.shadow$triggerDimensionChangeTriggers(serverworld);", "originalCommit": "1754dff19e45c5c12a9705bd731de9ad828c4586", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MTM0Nw==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546071347", "bodyText": "Here is the big difference between my version of this and yours.\nIn my version, I run reposition logic by finding where the portal will put you but I don't place any portal blocks. If the event succeeds, I run the logic again based on the event's position and put the blocks there. I did this to prevent cancelling reposition would end up having to roll back blocks in the PhaseTracker.\nBasically I run it in the lamdba which, truthfully, was a giant giant pain...", "author": "Zidane", "createdAt": "2020-12-18T20:19:50Z", "path": "src/mixins/java/org/spongepowered/common/mixin/core/entity/player/ServerPlayerEntityMixin.java", "diffHunk": "@@ -468,26 +495,144 @@ public void teleportTo(net.minecraft.world.server.ServerWorld world, double x, d\n     }\n \n     /**\n-     * @author zidane - November 21st, 2020 - Minecraft 1.15.2\n-     * @reason Call to EntityUtil to handle dimension changes\n+     * This is effectively an overwrite of changeDimension: required due to\n+     * Forge changing the signature.\n+     *\n+     * @author dualspiral - 18th December 2020 - 1.16.4\n+     *\n+     * @param originalDestinationWorld The original target world\n+     * @param spongeTeleporter performs additional teleportation logic, as required.\n+     * @return The {@link Entity} that is either this one, or replaces this one\n      */\n-    @javax.annotation.Nullable\n-    @Overwrite\n-    public Entity changeDimension(ServerWorld destination) {\n+    @SuppressWarnings(\"ConstantConditions\")\n+    @Nullable\n+    public Entity bridge$changeDimension(final ServerWorld originalDestinationWorld, final SpongeTeleporter spongeTeleporter) {\n+        // Sponge Start\n         if (this.shadow$getCommandSenderWorld().isClientSide || this.removed) {\n             return (ServerPlayerEntity) (Object) this;\n         }\n \n-        final WrappedITeleporterPortalType portalType = new WrappedITeleporterPortalType((PlatformITeleporterBridge) destination.getPortalForcer(), null);\n-\n         try (final CauseStackManager.StackFrame frame = PhaseTracker.getCauseStackManager().pushCauseFrame()) {\n             frame.pushCause(this);\n-            frame.pushCause(portalType);\n-            frame.addContext(EventContextKeys.MOVEMENT_TYPE, MovementTypes.PORTAL);\n+            // frame.pushCause(spongeTeleporter); // TODO: Expose the SpongeTeleporter interface as Teleporter...ish?\n+            frame.addContext(EventContextKeys.MOVEMENT_TYPE, spongeTeleporter.getMovementType());\n \n-            EntityUtil.invokePortalTo((ServerPlayerEntity) (Object) this, portalType, destination);\n-            return (ServerPlayerEntity) (Object) this;\n-        }\n+            final ChangeEntityWorldEvent.Pre preChangeEvent =\n+                PlatformHooks.getInstance().getEventHooks().callChangeEntityWorldEventPre((Entity) (Object) this, originalDestinationWorld);\n+            if (preChangeEvent.isCancelled()) {\n+                return (Entity) (Object) this;\n+            }\n+            final ServerWorld targetWorld = (ServerWorld) preChangeEvent.getDestinationWorld();\n+            final Vector3d currentPosition = VecHelper.toVector3d(this.position());\n+            // Sponge End\n+            this.isChangingDimension = true;\n+            ServerWorld serverworld = this.shadow$getLevel();\n+            RegistryKey<World> registrykey = serverworld.dimension();\n+            if (registrykey == World.END && targetWorld.dimension() == World.OVERWORLD && spongeTeleporter.isVanilla()) { // avoids modded dimensions\n+                this.shadow$unRide();\n+                this.shadow$getLevel().removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                if (!this.wonGame) {\n+                    this.wonGame = true;\n+                    this.connection.send(new SChangeGameStatePacket(SChangeGameStatePacket.WIN_GAME, this.seenCredits ? 0.0F : 1.0F));\n+                    this.seenCredits = true;\n+                }\n+\n+                // TODO: Figure out the reposition step (though that might just be a respawn)\n+                return (Entity) (Object) this;\n+            } else {\n+                IWorldInfo iworldinfo = targetWorld.getLevelData();\n+                this.connection.send(new SRespawnPacket(targetWorld.dimensionType(), targetWorld.dimension(),\n+                        BiomeManager.obfuscateSeed(targetWorld.getSeed()), this.gameMode.getGameModeForPlayer(),\n+                        this.gameMode.getPreviousGameModeForPlayer(), targetWorld.isDebug(), targetWorld.isFlat(), true));\n+                this.connection.send(new SServerDifficultyPacket(iworldinfo.getDifficulty(), iworldinfo.isDifficultyLocked()));\n+                PlayerList playerlist = this.server.getPlayerList();\n+                playerlist.sendPlayerPermissionLevel((ServerPlayerEntity) (Object) this);\n+                serverworld.removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                this.removed = false;\n+                // Sponge Start: Redirect the find portal call to the teleporter.\n+\n+                // TODO: This could house the Reposition Event, with some flag on SpongeTeleporter that can be set to cause this to happen later\n+                //  for mods.\n+                //  This can then hold our custom portal logic (basically any edits to findDimensionEntryPoint that we might need to do)\n+                final PortalInfo portalinfo = spongeTeleporter.getPortalInfo((Entity) (Object) this, targetWorld, this::shadow$findDimensionEntryPoint);\n+                // Sponge End\n+                if (portalinfo != null) {\n+                    // Sponge Start: wrap the teleportation logic within a function to allow for modification\n+                    // of the teleporter, as well as calling events(?)\n+                    final Vector3d originalDestination = new Vector3d(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                    final Entity e = spongeTeleporter.performTeleport((Entity) (Object) this, serverworld, targetWorld, this.xRot, spawnPortal -> {\n+                        // Sponge End\n+                        serverworld.getProfiler().push(\"moving\");\n+                        if (registrykey == World.OVERWORLD && targetWorld.dimension() == World.NETHER) {\n+                            this.enteredNetherPosition = this.shadow$position();\n+                        // Sponge Start: only enter this branch if we're going through portal logic\n+                        } else if (spawnPortal && targetWorld.dimension() == World.END) {\n+                            // Sponge End\n+                            this.shadow$createEndPlatform(targetWorld, new BlockPos(portalinfo.pos));\n+                        }\n+\n+                        serverworld.getProfiler().pop();\n+                        serverworld.getProfiler().push(\"placing\");\n+                        this.shadow$setLevel(targetWorld);\n+                        targetWorld.addDuringPortalTeleport((ServerPlayerEntity) (Object) this);\n+                        this.shadow$setRot(portalinfo.yRot, portalinfo.xRot);\n+                        this.shadow$moveTo(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                        serverworld.getProfiler().pop();\n+                        // Sponge Start: return this entity\n+                        return (Entity) (Object) this;\n+                    });\n+                    // Sponge End\n+                    // This is done here (it's not in Forge) to ensure that it's done. This is to ensure\n+                    // advancements are triggered.\n+                    this.shadow$triggerDimensionChangeTriggers(serverworld);\n+                    // Sponge Start: make sure the right object was returned\n+                    if (e != (Object) this) {\n+                        throw new IllegalArgumentException(String.format(\"Teleporter %s \"\n+                                + \"did not return the expected player entity: got %s, expected PlayerEntity %s\", spongeTeleporter, e, this));\n+                    }\n+\n+                    // If we need to reposition: well... reposition.\n+                    // Downside: portals won't come with us, but with how it's implemented in Forge,\n+                    // not sure how we'd do this\n+                    final Vector3d destination = VecHelper.toVector3d(this.shadow$position());\n+                    final ChangeEntityWorldEvent.Reposition reposition = SpongeEventFactory.createChangeEntityWorldEventReposition(", "originalCommit": "1754dff19e45c5c12a9705bd731de9ad828c4586", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MjYxNw==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546072617", "bodyText": "This is the big problem I have.\nFor vanilla, that's okay. We can do some magic with getExitPortal (or just copy/modify a redirection of it), and that's what my one of my TODOs is about. So if this is a route we wanted to go down, I would have spent some time doing that for vanilla logic - this wouldn't remain here if vanilla logic is running.\nFor Forge, there's very little we can do because there's no way to feed in the requested position to the mod.", "author": "dualspiral", "createdAt": "2020-12-18T20:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MTM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MzQxNw==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546073417", "bodyText": "You are correct, in my version if a mod passed in their own lambda we would call no events. It was definitely a flaw but I accepted it cause the whole thing is asinine to begin with.............", "author": "Zidane", "createdAt": "2020-12-18T20:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3MTM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3NDkwNA==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546074904", "bodyText": "This should only be called if it is actually a portal else API usages of NetherPortalType will have the swoosh sound which would be odd imo.", "author": "Zidane", "createdAt": "2020-12-18T20:27:43Z", "path": "src/mixins/java/org/spongepowered/common/mixin/core/entity/player/ServerPlayerEntityMixin.java", "diffHunk": "@@ -468,26 +495,144 @@ public void teleportTo(net.minecraft.world.server.ServerWorld world, double x, d\n     }\n \n     /**\n-     * @author zidane - November 21st, 2020 - Minecraft 1.15.2\n-     * @reason Call to EntityUtil to handle dimension changes\n+     * This is effectively an overwrite of changeDimension: required due to\n+     * Forge changing the signature.\n+     *\n+     * @author dualspiral - 18th December 2020 - 1.16.4\n+     *\n+     * @param originalDestinationWorld The original target world\n+     * @param spongeTeleporter performs additional teleportation logic, as required.\n+     * @return The {@link Entity} that is either this one, or replaces this one\n      */\n-    @javax.annotation.Nullable\n-    @Overwrite\n-    public Entity changeDimension(ServerWorld destination) {\n+    @SuppressWarnings(\"ConstantConditions\")\n+    @Nullable\n+    public Entity bridge$changeDimension(final ServerWorld originalDestinationWorld, final SpongeTeleporter spongeTeleporter) {\n+        // Sponge Start\n         if (this.shadow$getCommandSenderWorld().isClientSide || this.removed) {\n             return (ServerPlayerEntity) (Object) this;\n         }\n \n-        final WrappedITeleporterPortalType portalType = new WrappedITeleporterPortalType((PlatformITeleporterBridge) destination.getPortalForcer(), null);\n-\n         try (final CauseStackManager.StackFrame frame = PhaseTracker.getCauseStackManager().pushCauseFrame()) {\n             frame.pushCause(this);\n-            frame.pushCause(portalType);\n-            frame.addContext(EventContextKeys.MOVEMENT_TYPE, MovementTypes.PORTAL);\n+            // frame.pushCause(spongeTeleporter); // TODO: Expose the SpongeTeleporter interface as Teleporter...ish?\n+            frame.addContext(EventContextKeys.MOVEMENT_TYPE, spongeTeleporter.getMovementType());\n \n-            EntityUtil.invokePortalTo((ServerPlayerEntity) (Object) this, portalType, destination);\n-            return (ServerPlayerEntity) (Object) this;\n-        }\n+            final ChangeEntityWorldEvent.Pre preChangeEvent =\n+                PlatformHooks.getInstance().getEventHooks().callChangeEntityWorldEventPre((Entity) (Object) this, originalDestinationWorld);\n+            if (preChangeEvent.isCancelled()) {\n+                return (Entity) (Object) this;\n+            }\n+            final ServerWorld targetWorld = (ServerWorld) preChangeEvent.getDestinationWorld();\n+            final Vector3d currentPosition = VecHelper.toVector3d(this.position());\n+            // Sponge End\n+            this.isChangingDimension = true;\n+            ServerWorld serverworld = this.shadow$getLevel();\n+            RegistryKey<World> registrykey = serverworld.dimension();\n+            if (registrykey == World.END && targetWorld.dimension() == World.OVERWORLD && spongeTeleporter.isVanilla()) { // avoids modded dimensions\n+                this.shadow$unRide();\n+                this.shadow$getLevel().removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                if (!this.wonGame) {\n+                    this.wonGame = true;\n+                    this.connection.send(new SChangeGameStatePacket(SChangeGameStatePacket.WIN_GAME, this.seenCredits ? 0.0F : 1.0F));\n+                    this.seenCredits = true;\n+                }\n+\n+                // TODO: Figure out the reposition step (though that might just be a respawn)\n+                return (Entity) (Object) this;\n+            } else {\n+                IWorldInfo iworldinfo = targetWorld.getLevelData();\n+                this.connection.send(new SRespawnPacket(targetWorld.dimensionType(), targetWorld.dimension(),\n+                        BiomeManager.obfuscateSeed(targetWorld.getSeed()), this.gameMode.getGameModeForPlayer(),\n+                        this.gameMode.getPreviousGameModeForPlayer(), targetWorld.isDebug(), targetWorld.isFlat(), true));\n+                this.connection.send(new SServerDifficultyPacket(iworldinfo.getDifficulty(), iworldinfo.isDifficultyLocked()));\n+                PlayerList playerlist = this.server.getPlayerList();\n+                playerlist.sendPlayerPermissionLevel((ServerPlayerEntity) (Object) this);\n+                serverworld.removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                this.removed = false;\n+                // Sponge Start: Redirect the find portal call to the teleporter.\n+\n+                // TODO: This could house the Reposition Event, with some flag on SpongeTeleporter that can be set to cause this to happen later\n+                //  for mods.\n+                //  This can then hold our custom portal logic (basically any edits to findDimensionEntryPoint that we might need to do)\n+                final PortalInfo portalinfo = spongeTeleporter.getPortalInfo((Entity) (Object) this, targetWorld, this::shadow$findDimensionEntryPoint);\n+                // Sponge End\n+                if (portalinfo != null) {\n+                    // Sponge Start: wrap the teleportation logic within a function to allow for modification\n+                    // of the teleporter, as well as calling events(?)\n+                    final Vector3d originalDestination = new Vector3d(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                    final Entity e = spongeTeleporter.performTeleport((Entity) (Object) this, serverworld, targetWorld, this.xRot, spawnPortal -> {\n+                        // Sponge End\n+                        serverworld.getProfiler().push(\"moving\");\n+                        if (registrykey == World.OVERWORLD && targetWorld.dimension() == World.NETHER) {\n+                            this.enteredNetherPosition = this.shadow$position();\n+                        // Sponge Start: only enter this branch if we're going through portal logic\n+                        } else if (spawnPortal && targetWorld.dimension() == World.END) {\n+                            // Sponge End\n+                            this.shadow$createEndPlatform(targetWorld, new BlockPos(portalinfo.pos));\n+                        }\n+\n+                        serverworld.getProfiler().pop();\n+                        serverworld.getProfiler().push(\"placing\");\n+                        this.shadow$setLevel(targetWorld);\n+                        targetWorld.addDuringPortalTeleport((ServerPlayerEntity) (Object) this);\n+                        this.shadow$setRot(portalinfo.yRot, portalinfo.xRot);\n+                        this.shadow$moveTo(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                        serverworld.getProfiler().pop();\n+                        // Sponge Start: return this entity\n+                        return (Entity) (Object) this;\n+                    });\n+                    // Sponge End\n+                    // This is done here (it's not in Forge) to ensure that it's done. This is to ensure\n+                    // advancements are triggered.\n+                    this.shadow$triggerDimensionChangeTriggers(serverworld);\n+                    // Sponge Start: make sure the right object was returned\n+                    if (e != (Object) this) {\n+                        throw new IllegalArgumentException(String.format(\"Teleporter %s \"\n+                                + \"did not return the expected player entity: got %s, expected PlayerEntity %s\", spongeTeleporter, e, this));\n+                    }\n+\n+                    // If we need to reposition: well... reposition.\n+                    // Downside: portals won't come with us, but with how it's implemented in Forge,\n+                    // not sure how we'd do this\n+                    final Vector3d destination = VecHelper.toVector3d(this.shadow$position());\n+                    final ChangeEntityWorldEvent.Reposition reposition = SpongeEventFactory.createChangeEntityWorldEventReposition(\n+                            PhaseTracker.getCauseStackManager().getCurrentCause(),\n+                            (org.spongepowered.api.entity.Entity) this,\n+                            (org.spongepowered.api.world.server.ServerWorld) serverworld,\n+                            currentPosition,\n+                            destination,\n+                            (org.spongepowered.api.world.server.ServerWorld) originalDestinationWorld,\n+                            originalDestination,\n+                            (org.spongepowered.api.world.server.ServerWorld) targetWorld\n+                    );\n+                    if (reposition.isCancelled()) {\n+                        // send them back to the original destination\n+                        this.shadow$setPos(originalDestination.getX(), originalDestination.getY(), originalDestination.getZ());\n+                    } else if (reposition.getDestinationPosition() != destination) {\n+                        final Vector3d finalPosition = reposition.getDestinationPosition();\n+                        this.shadow$setPos(finalPosition.getX(), finalPosition.getY(), finalPosition.getZ());\n+                    }\n+                    // Sponge End\n+                    this.gameMode.setLevel(targetWorld);\n+                    this.connection.send(new SPlayerAbilitiesPacket(this.abilities));\n+                    playerlist.sendLevelInfo((ServerPlayerEntity) (Object) this, targetWorld);\n+                    playerlist.sendAllPlayerInfo((ServerPlayerEntity) (Object) this);\n+\n+                    for (EffectInstance effectinstance : this.shadow$getActiveEffects()) {\n+                        this.connection.send(new SPlayEntityEffectPacket(this.shadow$getId(), effectinstance));\n+                    }\n+\n+                    this.connection.send(new SPlaySoundEventPacket(1032, BlockPos.ZERO, 0, false));", "originalCommit": "1754dff19e45c5c12a9705bd731de9ad828c4586", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3NTExMQ==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546075111", "bodyText": "Assuming this code is copied to a util method for handling post teleport logic.", "author": "Zidane", "createdAt": "2020-12-18T20:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3NDkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3Njc4NA==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546076784", "bodyText": "If it is effectively an overwrite, make it one. With auditing, these overwrites like up like a Christmas tree, ensures we don't overlook it.", "author": "Zidane", "createdAt": "2020-12-18T20:32:17Z", "path": "vanilla/src/mixins/java/org/spongepowered/vanilla/mixin/core/entity/player/ServerPlayerEntityMixin_Vanilla.java", "diffHunk": "@@ -81,6 +83,18 @@\n         }\n     }\n \n+    /**\n+     * @author dualspiral - 18th December 2020 - 1.16.4\n+     * @reason This is effectively an overwrite, redirecting the vanilla", "originalCommit": "1754dff19e45c5c12a9705bd731de9ad828c4586", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjA3ODIxMg==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546078212", "bodyText": "So if we keep the strategy of doing reposition like this, we need to rollback the portal blocks in the PhaseTracker, issue a ticket for the chunk pos the player is going to, and call moveTo instead.", "author": "Zidane", "createdAt": "2020-12-18T20:35:52Z", "path": "src/mixins/java/org/spongepowered/common/mixin/core/entity/player/ServerPlayerEntityMixin.java", "diffHunk": "@@ -468,26 +495,144 @@ public void teleportTo(net.minecraft.world.server.ServerWorld world, double x, d\n     }\n \n     /**\n-     * @author zidane - November 21st, 2020 - Minecraft 1.15.2\n-     * @reason Call to EntityUtil to handle dimension changes\n+     * This is effectively an overwrite of changeDimension: required due to\n+     * Forge changing the signature.\n+     *\n+     * @author dualspiral - 18th December 2020 - 1.16.4\n+     *\n+     * @param originalDestinationWorld The original target world\n+     * @param spongeTeleporter performs additional teleportation logic, as required.\n+     * @return The {@link Entity} that is either this one, or replaces this one\n      */\n-    @javax.annotation.Nullable\n-    @Overwrite\n-    public Entity changeDimension(ServerWorld destination) {\n+    @SuppressWarnings(\"ConstantConditions\")\n+    @Nullable\n+    public Entity bridge$changeDimension(final ServerWorld originalDestinationWorld, final SpongeTeleporter spongeTeleporter) {\n+        // Sponge Start\n         if (this.shadow$getCommandSenderWorld().isClientSide || this.removed) {\n             return (ServerPlayerEntity) (Object) this;\n         }\n \n-        final WrappedITeleporterPortalType portalType = new WrappedITeleporterPortalType((PlatformITeleporterBridge) destination.getPortalForcer(), null);\n-\n         try (final CauseStackManager.StackFrame frame = PhaseTracker.getCauseStackManager().pushCauseFrame()) {\n             frame.pushCause(this);\n-            frame.pushCause(portalType);\n-            frame.addContext(EventContextKeys.MOVEMENT_TYPE, MovementTypes.PORTAL);\n+            // frame.pushCause(spongeTeleporter); // TODO: Expose the SpongeTeleporter interface as Teleporter...ish?\n+            frame.addContext(EventContextKeys.MOVEMENT_TYPE, spongeTeleporter.getMovementType());\n \n-            EntityUtil.invokePortalTo((ServerPlayerEntity) (Object) this, portalType, destination);\n-            return (ServerPlayerEntity) (Object) this;\n-        }\n+            final ChangeEntityWorldEvent.Pre preChangeEvent =\n+                PlatformHooks.getInstance().getEventHooks().callChangeEntityWorldEventPre((Entity) (Object) this, originalDestinationWorld);\n+            if (preChangeEvent.isCancelled()) {\n+                return (Entity) (Object) this;\n+            }\n+            final ServerWorld targetWorld = (ServerWorld) preChangeEvent.getDestinationWorld();\n+            final Vector3d currentPosition = VecHelper.toVector3d(this.position());\n+            // Sponge End\n+            this.isChangingDimension = true;\n+            ServerWorld serverworld = this.shadow$getLevel();\n+            RegistryKey<World> registrykey = serverworld.dimension();\n+            if (registrykey == World.END && targetWorld.dimension() == World.OVERWORLD && spongeTeleporter.isVanilla()) { // avoids modded dimensions\n+                this.shadow$unRide();\n+                this.shadow$getLevel().removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                if (!this.wonGame) {\n+                    this.wonGame = true;\n+                    this.connection.send(new SChangeGameStatePacket(SChangeGameStatePacket.WIN_GAME, this.seenCredits ? 0.0F : 1.0F));\n+                    this.seenCredits = true;\n+                }\n+\n+                // TODO: Figure out the reposition step (though that might just be a respawn)\n+                return (Entity) (Object) this;\n+            } else {\n+                IWorldInfo iworldinfo = targetWorld.getLevelData();\n+                this.connection.send(new SRespawnPacket(targetWorld.dimensionType(), targetWorld.dimension(),\n+                        BiomeManager.obfuscateSeed(targetWorld.getSeed()), this.gameMode.getGameModeForPlayer(),\n+                        this.gameMode.getPreviousGameModeForPlayer(), targetWorld.isDebug(), targetWorld.isFlat(), true));\n+                this.connection.send(new SServerDifficultyPacket(iworldinfo.getDifficulty(), iworldinfo.isDifficultyLocked()));\n+                PlayerList playerlist = this.server.getPlayerList();\n+                playerlist.sendPlayerPermissionLevel((ServerPlayerEntity) (Object) this);\n+                serverworld.removePlayerImmediately((ServerPlayerEntity) (Object) this);\n+                this.removed = false;\n+                // Sponge Start: Redirect the find portal call to the teleporter.\n+\n+                // TODO: This could house the Reposition Event, with some flag on SpongeTeleporter that can be set to cause this to happen later\n+                //  for mods.\n+                //  This can then hold our custom portal logic (basically any edits to findDimensionEntryPoint that we might need to do)\n+                final PortalInfo portalinfo = spongeTeleporter.getPortalInfo((Entity) (Object) this, targetWorld, this::shadow$findDimensionEntryPoint);\n+                // Sponge End\n+                if (portalinfo != null) {\n+                    // Sponge Start: wrap the teleportation logic within a function to allow for modification\n+                    // of the teleporter, as well as calling events(?)\n+                    final Vector3d originalDestination = new Vector3d(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                    final Entity e = spongeTeleporter.performTeleport((Entity) (Object) this, serverworld, targetWorld, this.xRot, spawnPortal -> {\n+                        // Sponge End\n+                        serverworld.getProfiler().push(\"moving\");\n+                        if (registrykey == World.OVERWORLD && targetWorld.dimension() == World.NETHER) {\n+                            this.enteredNetherPosition = this.shadow$position();\n+                        // Sponge Start: only enter this branch if we're going through portal logic\n+                        } else if (spawnPortal && targetWorld.dimension() == World.END) {\n+                            // Sponge End\n+                            this.shadow$createEndPlatform(targetWorld, new BlockPos(portalinfo.pos));\n+                        }\n+\n+                        serverworld.getProfiler().pop();\n+                        serverworld.getProfiler().push(\"placing\");\n+                        this.shadow$setLevel(targetWorld);\n+                        targetWorld.addDuringPortalTeleport((ServerPlayerEntity) (Object) this);\n+                        this.shadow$setRot(portalinfo.yRot, portalinfo.xRot);\n+                        this.shadow$moveTo(portalinfo.pos.x, portalinfo.pos.y, portalinfo.pos.z);\n+                        serverworld.getProfiler().pop();\n+                        // Sponge Start: return this entity\n+                        return (Entity) (Object) this;\n+                    });\n+                    // Sponge End\n+                    // This is done here (it's not in Forge) to ensure that it's done. This is to ensure\n+                    // advancements are triggered.\n+                    this.shadow$triggerDimensionChangeTriggers(serverworld);\n+                    // Sponge Start: make sure the right object was returned\n+                    if (e != (Object) this) {\n+                        throw new IllegalArgumentException(String.format(\"Teleporter %s \"\n+                                + \"did not return the expected player entity: got %s, expected PlayerEntity %s\", spongeTeleporter, e, this));\n+                    }\n+\n+                    // If we need to reposition: well... reposition.\n+                    // Downside: portals won't come with us, but with how it's implemented in Forge,\n+                    // not sure how we'd do this\n+                    final Vector3d destination = VecHelper.toVector3d(this.shadow$position());\n+                    final ChangeEntityWorldEvent.Reposition reposition = SpongeEventFactory.createChangeEntityWorldEventReposition(\n+                            PhaseTracker.getCauseStackManager().getCurrentCause(),\n+                            (org.spongepowered.api.entity.Entity) this,\n+                            (org.spongepowered.api.world.server.ServerWorld) serverworld,\n+                            currentPosition,\n+                            destination,\n+                            (org.spongepowered.api.world.server.ServerWorld) originalDestinationWorld,\n+                            originalDestination,\n+                            (org.spongepowered.api.world.server.ServerWorld) targetWorld\n+                    );\n+                    if (reposition.isCancelled()) {\n+                        // send them back to the original destination\n+                        this.shadow$setPos(originalDestination.getX(), originalDestination.getY(), originalDestination.getZ());\n+                    } else if (reposition.getDestinationPosition() != destination) {\n+                        final Vector3d finalPosition = reposition.getDestinationPosition();\n+                        this.shadow$setPos(finalPosition.getX(), finalPosition.getY(), finalPosition.getZ());", "originalCommit": "1754dff19e45c5c12a9705bd731de9ad828c4586", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "281f5574823626d92cfb061415446fe74ede6ae3", "url": "https://github.com/SpongePowered/Sponge/commit/281f5574823626d92cfb061415446fe74ede6ae3", "message": "A bit more work: not done as I need to go but starting to take shape for the reposition event.", "committedDate": "2020-12-18T21:44:42Z", "type": "forcePushed"}, {"oid": "5d740e3282ec066574af8af318b12910beece740", "url": "https://github.com/SpongePowered/Sponge/commit/5d740e3282ec066574af8af318b12910beece740", "message": "Porting the portals, part I\n\nA bit more work: not done as I need to go but starting to take shape for the reposition event.\n\nRationalise change dimension code into one place with multiple bridge methods", "committedDate": "2020-12-19T15:29:32Z", "type": "forcePushed"}, {"oid": "5563c886d623c384380d7fe88f1427d204b0dde1", "url": "https://github.com/SpongePowered/Sponge/commit/5563c886d623c384380d7fe88f1427d204b0dde1", "message": "Resolve some more comments", "committedDate": "2020-12-20T14:36:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjM5MTcwOA==", "url": "https://github.com/SpongePowered/Sponge/pull/3239#discussion_r546391708", "bodyText": "missing shadow$ prefix", "author": "ImMorpheus", "createdAt": "2020-12-20T15:29:02Z", "path": "src/mixins/java/org/spongepowered/common/mixin/core/entity/EntityMixin.java", "diffHunk": "@@ -161,14 +171,21 @@\n     @Shadow public abstract void shadow$clearFire();\n     @Shadow protected abstract void shadow$setSharedFlag(int flag, boolean set);\n     @Shadow public abstract EntityDataManager shadow$getEntityData();\n+    @Shadow public abstract void shadow$moveTo(double x, double y, double z);\n     @Shadow public abstract void shadow$absMoveTo(double x, double y, double z, float yaw, float pitch);\n     @Shadow public abstract net.minecraft.util.math.vector.Vector3d shadow$getDeltaMovement();\n     @Shadow public abstract void shadow$setDeltaMovement(net.minecraft.util.math.vector.Vector3d motion);\n+    @Shadow public abstract void shadow$unRide();\n+    @Shadow protected abstract Optional<TeleportationRepositioner.Result> shadow$getExitPortal(\n+            net.minecraft.world.server.ServerWorld targetWorld, BlockPos targetPosition, boolean isNether);\n+    @Shadow protected abstract net.minecraft.util.math.vector.Vector3d shadow$getRelativePortalPosition(Direction.Axis direction$axis,\n+            TeleportationRepositioner.Result teleportationrepositioner$result);\n+    @Shadow protected abstract void shadow$removeAfterChangingDimensions();\n     // @formatter:on\n \n+    @Shadow public abstract EntityType<?> getType();", "originalCommit": "dbb8fc0d364c041868e4194bee758dfeca2feeb2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0628056267d1e38162571a05b18c0bdb2c4a5b60", "url": "https://github.com/SpongePowered/Sponge/commit/0628056267d1e38162571a05b18c0bdb2c4a5b60", "message": "Start sorting out PortalType logic", "committedDate": "2020-12-20T18:21:06Z", "type": "forcePushed"}, {"oid": "c433d3aeddd1726defecc90ddf641878f872aba5", "url": "https://github.com/SpongePowered/Sponge/commit/c433d3aeddd1726defecc90ddf641878f872aba5", "message": "Porting the portals\n\nRationalise change dimension code into one place with multiple bridge methods", "committedDate": "2020-12-20T21:01:45Z", "type": "forcePushed"}, {"oid": "45bf91f337a1c0a7426242fcf381dfe0e66654c9", "url": "https://github.com/SpongePowered/Sponge/commit/45bf91f337a1c0a7426242fcf381dfe0e66654c9", "message": "Porting the portals\n\nRationalise change dimension code into one place with multiple bridge methods", "committedDate": "2020-12-21T15:23:41Z", "type": "forcePushed"}, {"oid": "0aeea2f0f8ff68b1d841f433ffa16ce36db35ae4", "url": "https://github.com/SpongePowered/Sponge/commit/0aeea2f0f8ff68b1d841f433ffa16ce36db35ae4", "message": "Don't get the parameters the wrong way around", "committedDate": "2020-12-21T16:55:51Z", "type": "forcePushed"}, {"oid": "2a364f183dcd9d452165447b89f0a77e1a6b493a", "url": "https://github.com/SpongePowered/Sponge/commit/2a364f183dcd9d452165447b89f0a77e1a6b493a", "message": "Porting the portals\n\nRationalise change dimension code into one place with multiple bridge methods", "committedDate": "2020-12-21T17:13:59Z", "type": "commit"}, {"oid": "2a364f183dcd9d452165447b89f0a77e1a6b493a", "url": "https://github.com/SpongePowered/Sponge/commit/2a364f183dcd9d452165447b89f0a77e1a6b493a", "message": "Porting the portals\n\nRationalise change dimension code into one place with multiple bridge methods", "committedDate": "2020-12-21T17:13:59Z", "type": "forcePushed"}]}