{"pr_number": 3044, "pr_title": "Update pagination service from invalid", "pr_createdAt": "2020-07-05T13:58:33Z", "pr_url": "https://github.com/SpongePowered/Sponge/pull/3044", "timeline": [{"oid": "a24feac97dd8cc965e2699549a81e59b02327a22", "url": "https://github.com/SpongePowered/Sponge/commit/a24feac97dd8cc965e2699549a81e59b02327a22", "message": "Move common.service.pagination out of invalid", "committedDate": "2020-07-08T17:16:06Z", "type": "forcePushed"}, {"oid": "61183ad73761d9b5fff06fedd6d7a0c031af226a", "url": "https://github.com/SpongePowered/Sponge/commit/61183ad73761d9b5fff06fedd6d7a0c031af226a", "message": "Couple of fixes\n\nMake sure we compile with UTF-8 or it breaks special characters used in the pagination list\nAttempt to work around a Style#getBold stackoverflow\nFix footer padding being 1 characters too long (not a fan of decrementing but I found no better way)\nFix padding color always using title's color\nRemove unused methods and parameters", "committedDate": "2020-08-02T13:06:01Z", "type": "forcePushed"}, {"oid": "98cee530f2cf4c39f73858cd503ddd57aedc42ce", "url": "https://github.com/SpongePowered/Sponge/commit/98cee530f2cf4c39f73858cd503ddd57aedc42ce", "message": "Register pagination command on startup", "committedDate": "2020-08-07T07:26:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2MzgxMQ==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r470963811", "bodyText": "This should only run if the service wasn't replaced, this will throw a class cast exception otherwise.", "author": "dualspiral", "createdAt": "2020-08-15T10:33:49Z", "path": "src/main/java/org/spongepowered/common/command/manager/SpongeCommandManager.java", "diffHunk": "@@ -524,6 +526,15 @@ public void init() {\n         } catch (final CommandFailedRegistrationException ex) {\n             throw new RuntimeException(\"Failed to create root Sponge command!\", ex);\n         }\n+        try {\n+            SpongeParameterizedCommandRegistrar.INSTANCE.register(\n+                    Launcher.getInstance().getCommonPlugin(),\n+                    ((SpongePaginationService) Sponge.getServiceProvider().paginationService()).createPaginationCommand(),", "originalCommit": "98cee530f2cf4c39f73858cd503ddd57aedc42ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2NTg4MA==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r470965880", "bodyText": "Oh right, I assumed it can't be replaced for some reason.", "author": "RedNesto", "createdAt": "2020-08-15T11:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2MzgxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2NDEwNQ==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r470964105", "bodyText": "Any reason that this is split into ValueParser and ValueCompleter? In general, they should just be one ValueParameter if this is the case (the docs say if a ValueParameter is passed it will use the completer there).", "author": "dualspiral", "createdAt": "2020-08-15T10:37:38Z", "path": "src/main/java/org/spongepowered/common/service/pagination/SpongePaginationService.java", "diffHunk": "@@ -143,105 +131,94 @@ private SourcePaginations getPaginationStateForPlayer(Player source, boolean cre\n         return this.playerActivePaginations.get(source.getUniqueId(), k -> create ? new SourcePaginations() : null);\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    private CommandSpec buildPaginationCommand() {\n-\n-        final ActivePaginationCommandElement paginationElement = new ActivePaginationCommandElement(t(\"pagination-id\"));\n+    public Command.Parameterized createPaginationCommand() {\n+        Parameter.Value<ActivePagination> paginationIdParameter = Parameter.builder(ActivePagination.class)\n+                .parser(new ActivePaginationParser())\n+                .setSuggestions(new ActivePaginationCompleter())\n+                .setKey(\"pagination-id\")\n+                .build();\n \n-        CommandSpec next = CommandSpec.builder()\n-                .description(t(\"Go to the next page\"))\n-                .executor((src, args) -> {\n-                    args.<ActivePagination>getOne(\"pagination-id\").get().nextPage();\n+        Command.Parameterized next = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the next page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).nextPage();\n                     return CommandResult.success();\n                 }).build();\n \n-        CommandSpec prev = CommandSpec.builder()\n-                .description(t(\"Go to the previous page\"))\n-                .executor((src, args) -> {\n-                    args.<ActivePagination>getOne(\"pagination-id\").get().previousPage();\n+        Command.Parameterized prev = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the previous page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).previousPage();\n                     return CommandResult.success();\n                 }).build();\n \n-        CommandElement pageArgs = integer(t(\"page\"));\n+        Parameter.Value<Integer> pageParameter = integerNumber().setKey(\"page\").build();\n \n-        CommandExecutor pageExecutor = (src, args) -> {\n-            args.<ActivePagination>getOne(\"pagination-id\").get().specificPage(args.<Integer>getOne(\"page\").get());\n+        CommandExecutor pageExecutor = (context) -> {\n+            context.requireOne(paginationIdParameter).specificPage(context.requireOne(pageParameter));\n             return CommandResult.success();\n         };\n \n-        CommandSpec page = CommandSpec.builder()\n-                        .description(t(\"Go to a specific page\"))\n-                        .arguments(pageArgs)\n-                        .executor(pageExecutor).build();\n-\n-        //Fallback to page arguments\n-        ChildCommandElementExecutor childDispatcher = new ChildCommandElementExecutor(pageExecutor);\n-        childDispatcher.register(next, \"next\", \"n\");\n-        childDispatcher.register(prev, \"prev\", \"p\", \"previous\");\n-        childDispatcher.register(page, \"page\");\n+        Command.Parameterized page = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to a specific page\"))\n+                .parameter(pageParameter)\n+                .setExecutor(pageExecutor)\n+                .build();\n \n         //We create the child manually in order to force that paginationElement is required for all children + fallback\n         //https://github.com/SpongePowered/SpongeAPI/issues/1272\n-        return CommandSpec.builder().arguments(paginationElement, firstParsing(childDispatcher, pageArgs))\n-                .executor(childDispatcher)\n-                .description(t(\"Helper command for paginations occurring\"))\n+        return Command.builder()\n+                .parameters(paginationIdParameter, firstOf(pageParameter,\n+                        subcommand(next, \"next\", \"n\"),\n+                        subcommand(prev, \"prev\", \"p\", \"previous\"),\n+                        subcommand(page, \"page\")))\n+                .child(page, \"page\")\n+                .setExecutor(page)\n+                .setShortDescription(TextComponent.of(\"Helper command for paginations occurring\"))\n                 .build();\n     }\n \n-    private class ActivePaginationCommandElement extends CommandElement {\n-\n-        protected ActivePaginationCommandElement(@Nullable Text key) {\n-            super(key);\n-        }\n+    private class ActivePaginationParser implements ValueParser<ActivePagination> {", "originalCommit": "98cee530f2cf4c39f73858cd503ddd57aedc42ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2NjA1Nw==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r470966057", "bodyText": "I missed that part, will do !", "author": "RedNesto", "createdAt": "2020-08-15T11:03:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2NDEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2NDIwOQ==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r470964209", "bodyText": "All static calls must be qualified - no static imports for this.", "author": "dualspiral", "createdAt": "2020-08-15T10:39:23Z", "path": "src/main/java/org/spongepowered/common/service/pagination/SpongePaginationService.java", "diffHunk": "@@ -143,105 +131,94 @@ private SourcePaginations getPaginationStateForPlayer(Player source, boolean cre\n         return this.playerActivePaginations.get(source.getUniqueId(), k -> create ? new SourcePaginations() : null);\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    private CommandSpec buildPaginationCommand() {\n-\n-        final ActivePaginationCommandElement paginationElement = new ActivePaginationCommandElement(t(\"pagination-id\"));\n+    public Command.Parameterized createPaginationCommand() {\n+        Parameter.Value<ActivePagination> paginationIdParameter = Parameter.builder(ActivePagination.class)\n+                .parser(new ActivePaginationParser())\n+                .setSuggestions(new ActivePaginationCompleter())\n+                .setKey(\"pagination-id\")\n+                .build();\n \n-        CommandSpec next = CommandSpec.builder()\n-                .description(t(\"Go to the next page\"))\n-                .executor((src, args) -> {\n-                    args.<ActivePagination>getOne(\"pagination-id\").get().nextPage();\n+        Command.Parameterized next = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the next page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).nextPage();\n                     return CommandResult.success();\n                 }).build();\n \n-        CommandSpec prev = CommandSpec.builder()\n-                .description(t(\"Go to the previous page\"))\n-                .executor((src, args) -> {\n-                    args.<ActivePagination>getOne(\"pagination-id\").get().previousPage();\n+        Command.Parameterized prev = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the previous page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).previousPage();\n                     return CommandResult.success();\n                 }).build();\n \n-        CommandElement pageArgs = integer(t(\"page\"));\n+        Parameter.Value<Integer> pageParameter = integerNumber().setKey(\"page\").build();\n \n-        CommandExecutor pageExecutor = (src, args) -> {\n-            args.<ActivePagination>getOne(\"pagination-id\").get().specificPage(args.<Integer>getOne(\"page\").get());\n+        CommandExecutor pageExecutor = (context) -> {\n+            context.requireOne(paginationIdParameter).specificPage(context.requireOne(pageParameter));\n             return CommandResult.success();\n         };\n \n-        CommandSpec page = CommandSpec.builder()\n-                        .description(t(\"Go to a specific page\"))\n-                        .arguments(pageArgs)\n-                        .executor(pageExecutor).build();\n-\n-        //Fallback to page arguments\n-        ChildCommandElementExecutor childDispatcher = new ChildCommandElementExecutor(pageExecutor);\n-        childDispatcher.register(next, \"next\", \"n\");\n-        childDispatcher.register(prev, \"prev\", \"p\", \"previous\");\n-        childDispatcher.register(page, \"page\");\n+        Command.Parameterized page = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to a specific page\"))\n+                .parameter(pageParameter)\n+                .setExecutor(pageExecutor)\n+                .build();\n \n         //We create the child manually in order to force that paginationElement is required for all children + fallback\n         //https://github.com/SpongePowered/SpongeAPI/issues/1272\n-        return CommandSpec.builder().arguments(paginationElement, firstParsing(childDispatcher, pageArgs))\n-                .executor(childDispatcher)\n-                .description(t(\"Helper command for paginations occurring\"))\n+        return Command.builder()\n+                .parameters(paginationIdParameter, firstOf(pageParameter,", "originalCommit": "98cee530f2cf4c39f73858cd503ddd57aedc42ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2NDMzMA==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r470964330", "bodyText": "@Zidane likes final things.\n(When possible, variables and classes should be final)", "author": "dualspiral", "createdAt": "2020-08-15T10:40:45Z", "path": "src/main/java/org/spongepowered/common/service/pagination/SpongePaginationService.java", "diffHunk": "@@ -143,105 +131,94 @@ private SourcePaginations getPaginationStateForPlayer(Player source, boolean cre\n         return this.playerActivePaginations.get(source.getUniqueId(), k -> create ? new SourcePaginations() : null);\n     }\n \n-    @SuppressWarnings(\"deprecation\")\n-    private CommandSpec buildPaginationCommand() {\n-\n-        final ActivePaginationCommandElement paginationElement = new ActivePaginationCommandElement(t(\"pagination-id\"));\n+    public Command.Parameterized createPaginationCommand() {\n+        Parameter.Value<ActivePagination> paginationIdParameter = Parameter.builder(ActivePagination.class)\n+                .parser(new ActivePaginationParser())\n+                .setSuggestions(new ActivePaginationCompleter())\n+                .setKey(\"pagination-id\")\n+                .build();\n \n-        CommandSpec next = CommandSpec.builder()\n-                .description(t(\"Go to the next page\"))\n-                .executor((src, args) -> {\n-                    args.<ActivePagination>getOne(\"pagination-id\").get().nextPage();\n+        Command.Parameterized next = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the next page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).nextPage();\n                     return CommandResult.success();\n                 }).build();\n \n-        CommandSpec prev = CommandSpec.builder()\n-                .description(t(\"Go to the previous page\"))\n-                .executor((src, args) -> {\n-                    args.<ActivePagination>getOne(\"pagination-id\").get().previousPage();\n+        Command.Parameterized prev = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the previous page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).previousPage();\n                     return CommandResult.success();\n                 }).build();\n \n-        CommandElement pageArgs = integer(t(\"page\"));\n+        Parameter.Value<Integer> pageParameter = integerNumber().setKey(\"page\").build();", "originalCommit": "98cee530f2cf4c39f73858cd503ddd57aedc42ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDk2NDM5Ng==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r470964396", "bodyText": "Static acesses from the same class should also be qualified with the class name.", "author": "dualspiral", "createdAt": "2020-08-15T10:41:41Z", "path": "src/main/java/org/spongepowered/common/service/pagination/SpongePaginationBuilder.java", "diffHunk": "@@ -28,23 +28,27 @@\n import static com.google.common.base.Preconditions.checkState;\n \n import com.google.common.collect.ImmutableList;\n+import net.kyori.adventure.text.Component;\n+import net.kyori.adventure.text.TextComponent;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n import org.spongepowered.api.service.pagination.PaginationList;\n-import org.spongepowered.api.text.Text;\n \n import javax.annotation.Nullable;\n \n public class SpongePaginationBuilder implements PaginationList.Builder {\n \n+    private static final @NonNull TextComponent EQUALS_TEXT = TextComponent.of(\"=\");\n+\n     private final SpongePaginationService service;\n     @Nullable\n-    private Iterable<Text> contents;\n+    private Iterable<Component> contents;\n     @Nullable\n-    private Text title;\n+    private Component title;\n     @Nullable\n-    private Text header;\n+    private Component header;\n     @Nullable\n-    private Text footer;\n-    private Text paginationSpacer = Text.of(\"=\");\n+    private Component footer;\n+    private Component paginationSpacer = EQUALS_TEXT;", "originalCommit": "98cee530f2cf4c39f73858cd503ddd57aedc42ce", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7b02c40b5eda99157e51d8b00edb9e44377a1da7", "url": "https://github.com/SpongePowered/Sponge/commit/7b02c40b5eda99157e51d8b00edb9e44377a1da7", "message": "Replace anonymous guava Function with method reference", "committedDate": "2020-08-17T15:58:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2OTIzNg==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471669236", "bodyText": "Is there a reason for this toBuilder().build()? The following compiles fine:\nfinal Component component = TextComponent.empty();\nTextComponent.builder().style(component.style()).build();\n\nI haven't run it though - if there is a problem that you've worked around, we need to report it to Adventure.", "author": "dualspiral", "createdAt": "2020-08-17T18:07:54Z", "path": "src/main/java/org/spongepowered/common/service/pagination/PaginationCalculator.java", "diffHunk": "@@ -218,82 +213,57 @@ int getWidth(Component text) {\n     Component center(Component text, Component padding) {\n         int inputLength = this.getWidth(text);\n         //Minecraft breaks lines when the next character would be > then LINE_WIDTH, this seems most graceful way to fail\n-        if (inputLength >= LINE_WIDTH) {\n+        if (inputLength >= PaginationCalculator.LINE_WIDTH) {\n             return text;\n         }\n         final Component textWithSpaces = this.addSpaces(TextComponent.space(), text);\n \n         //Minecraft breaks lines when the next character would be > then LINE_WIDTH\n-        boolean addSpaces = this.getWidth(textWithSpaces) <= LINE_WIDTH;\n+        final boolean addSpaces = this.getWidth(textWithSpaces) <= PaginationCalculator.LINE_WIDTH;\n \n-        //TODO: suspect, why are we changing the style of the padding, they may want different styles on the padding.\n-        Component styledPadding = this.withStyle(padding, text);\n-        int paddingLength = this.getWidth(styledPadding);\n+        int paddingLength = this.getWidth(padding);\n         final TextComponent.Builder output = TextComponent.builder();\n \n         //Using 0 width unicode symbols as padding throws us into an unending loop, replace them with the default padding\n-        if(paddingLength < 1) {\n+        if (paddingLength < 1) {\n             padding = TextComponent.of(\"=\");\n-            styledPadding = this.withStyle(padding, text);\n-            paddingLength = this.getWidth(styledPadding);\n+            paddingLength = this.getWidth(padding);\n         }\n \n         //if we only need padding\n         if (inputLength == 0) {\n-            this.addPadding(padding, output, GenericMath.floor((double) LINE_WIDTH / paddingLength));\n+            this.addPadding(padding, output, GenericMath.floor((double) PaginationCalculator.LINE_WIDTH / paddingLength));\n         } else {\n-            if(addSpaces) {\n+            if (addSpaces) {\n                 text = textWithSpaces;\n                 inputLength = this.getWidth(textWithSpaces);\n             }\n \n-            int paddingNecessary = LINE_WIDTH - inputLength;\n+            final int paddingNecessary = PaginationCalculator.LINE_WIDTH - inputLength;\n \n-            int paddingCount = GenericMath.floor(paddingNecessary / paddingLength);\n+            final int paddingCount = GenericMath.floor(paddingNecessary / paddingLength);\n             //pick a halfway point\n-            int beforePadding = GenericMath.floor(paddingCount / 2.0);\n+            final int beforePadding = GenericMath.floor(paddingCount / 2.0);\n             //Do not use ceil, this prevents floating point errors.\n-            int afterPadding = paddingCount - beforePadding;\n+            final int afterPadding = paddingCount - beforePadding - 1;\n \n-            this.addPadding(styledPadding, output, beforePadding);\n+            this.addPadding(padding, output, beforePadding);\n             output.append(text);\n-            this.addPadding(styledPadding, output, afterPadding);\n+            this.addPadding(padding, output, afterPadding);\n         }\n \n         return this.finalizeBuilder(text, output);\n     }\n \n-    /**\n-     * Gives the first text argument the style of the second.\n-     *\n-     * @param text The text to stylize\n-     * @param styled The styled text\n-     * @return The original text now stylized\n-     */\n-    private Component withStyle(Component text, Component styled) {\n-        return text.style(styled.style());\n-    }\n-\n-    /**\n-     * Gives the first text argument the color of the second.\n-     *\n-     * @param text The text to color\n-     * @param colored The colored text\n-     * @return The original text now colored\n-     */\n-    private Component withColor(Component text, Component colored) {\n-        return text.color(colored.color());\n-    }\n-\n     /**\n      * Finalizes the builder used in centering text.\n      *\n      * @param text The text to get the style from\n      * @param build The work in progress text builder\n      * @return The finalized, properly styled text.\n      */\n-    private Component finalizeBuilder(Component text,TextComponent.Builder build) {\n-        return build.style(text.style()).build();\n+    private Component finalizeBuilder(final Component text, final TextComponent.Builder build) {\n+        return build.style(text.style().toBuilder().build()).build();", "originalCommit": "7b02c40b5eda99157e51d8b00edb9e44377a1da7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcwNzgxMg==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471707812", "bodyText": "Oh I didn't put a comment there to explain.\nIt seems to be needed to avoid StackOverflowExceptions that happen later for some reason. I mentioned it to kashike and AFAIK we're not sure why this happens.", "author": "RedNesto", "createdAt": "2020-08-17T18:48:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2OTIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcyOTI5NA==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471729294", "bodyText": "Is there an issue reported for this? I imagine it's probably on the Adventure end but it needs to be reported somewhere. (edit: it wasn't)\nOnce done, add a comment linking to that issue so if some poor soul wants more information (and perhaps wants to have a stab at fixing it), they can do so.", "author": "dualspiral", "createdAt": "2020-08-17T19:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2OTIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTczNzg0OQ==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471737849", "bodyText": "Well I don't even know if the issue lies in the library or the SpongeCommon glue code. I should talk to kashike about it again I think.", "author": "RedNesto", "createdAt": "2020-08-17T19:49:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2OTIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc2MDU3MA==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471760570", "bodyText": "Oh, I just looked and I know exactly what's going on. It's basically the fact that the Minecraft Style object is being cached for a given Adventure Style object, but when you use Minecraft's Style#setStyle it also sets the parent of the child's style. In this case, the parent and the child have been supplied with the same Style reference, so when the parent style is set... it's itself.\nSponge error. We basically should not be caching mutable objects (edit: without copying them when we use them).", "author": "dualspiral", "createdAt": "2020-08-17T20:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2OTIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTc2OTU0Mw==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471769543", "bodyText": "44be61c", "author": "dualspiral", "createdAt": "2020-08-17T20:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2OTIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0NzgxOQ==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r472047819", "bodyText": "Amazing, thank you ! I hope this is the last force push I have to do for this PR.", "author": "RedNesto", "createdAt": "2020-08-18T09:35:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2OTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MTA3Ng==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471671076", "bodyText": "As above.", "author": "dualspiral", "createdAt": "2020-08-17T18:10:44Z", "path": "src/main/java/org/spongepowered/common/service/pagination/PaginationCalculator.java", "diffHunk": "@@ -306,12 +276,12 @@ private Component finalizeBuilder(Component text,TextComponent.Builder build) {\n      * @param text The text to add to\n      * @return The text with the added spaces\n      */\n-    private Component addSpaces(Component spaces, Component text) {\n+    private Component addSpaces(final Component spaces, final Component text) {\n         return TextComponent.builder()\n                 .append(spaces)\n                 .append(text)\n                 .append(spaces)\n-                .style(text.style())\n+                .style(text.style().toBuilder().build())", "originalCommit": "7b02c40b5eda99157e51d8b00edb9e44377a1da7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3Mzg4Mg==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471673882", "bodyText": "More of a note for the future - but storing an optional just feels wrong. It's being used to avoid optional (re)creation in getters, but... how often are the getters called? Not often I'm sure! The sendTo method actually unwraps the optional into a null.\nPerhaps this is a good time to ditch the optionals and just have nullable fields.", "author": "dualspiral", "createdAt": "2020-08-17T18:16:15Z", "path": "src/main/java/org/spongepowered/common/service/pagination/SpongePaginationList.java", "diffHunk": "@@ -46,19 +45,23 @@\n import java.util.stream.Collectors;\n import java.util.stream.StreamSupport;\n \n+import javax.annotation.Nullable;\n+\n @SuppressWarnings(\"OptionalUsedAsFieldOrParameterType\")\n-public class SpongePaginationList implements PaginationList {\n+public final class SpongePaginationList implements PaginationList {\n \n     private final SpongePaginationService service;\n-    private final Iterable<Text> contents;\n-    private final Optional<Text> title;\n-    private final Optional<Text> header;\n-    private final Optional<Text> footer;\n-    private final Text paginationSpacer;\n+    private final Iterable<Component> contents;\n+    private final Optional<Component> title;", "originalCommit": "7b02c40b5eda99157e51d8b00edb9e44377a1da7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY4NDE3MA==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471684170", "bodyText": "Comment should be ditched.", "author": "dualspiral", "createdAt": "2020-08-17T18:28:41Z", "path": "src/main/java/org/spongepowered/common/service/pagination/SpongePaginationService.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.service.pagination;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.MapMaker;\n+import com.google.inject.Singleton;\n+import net.kyori.adventure.audience.Audience;\n+import net.kyori.adventure.text.TextComponent;\n+import org.spongepowered.api.command.Command;\n+import org.spongepowered.api.command.CommandExecutor;\n+import org.spongepowered.api.command.CommandResult;\n+import org.spongepowered.api.command.exception.ArgumentParseException;\n+import org.spongepowered.api.command.parameter.ArgumentReader;\n+import org.spongepowered.api.command.parameter.CommandContext;\n+import org.spongepowered.api.command.parameter.Parameter;\n+import org.spongepowered.api.command.parameter.managed.ValueParameter;\n+import org.spongepowered.api.entity.living.player.Player;\n+import org.spongepowered.api.service.pagination.PaginationList;\n+import org.spongepowered.api.service.pagination.PaginationService;\n+import org.spongepowered.api.util.Nameable;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+@Singleton\n+public final class SpongePaginationService implements PaginationService {\n+\n+    static final class SourcePaginations {\n+\n+        private final Map<UUID, ActivePagination> paginations = new ConcurrentHashMap<>();\n+        @Nullable private volatile UUID lastUuid;\n+\n+        @Nullable public ActivePagination get(final UUID uuid) {\n+            return this.paginations.get(uuid);\n+        }\n+\n+        public void put(final ActivePagination pagination) {\n+            synchronized (this.paginations) {\n+                this.paginations.put(pagination.getId(), pagination);\n+                this.lastUuid = pagination.getId();\n+            }\n+        }\n+\n+        public Set<UUID> keys() {\n+            return this.paginations.keySet();\n+        }\n+\n+        @Nullable\n+        public UUID getLastUuid() {\n+            return this.lastUuid;\n+        }\n+    }\n+\n+    private final ConcurrentMap<Audience, SourcePaginations> activePaginations = new MapMaker().weakKeys().makeMap();\n+\n+    // We have a second active pagination system because of the way Players are handled by the server.\n+    // As Players are recreated every time they die in game, just storing the player in a weak map will\n+    // cause the player to be removed form the map upon death. Thus, player paginations get redirected\n+    // through to this cache instead, which last for 10 minutes from last access.\n+    private final Cache<UUID, SourcePaginations> playerActivePaginations = Caffeine.newBuilder().expireAfterAccess(10, TimeUnit.MINUTES)\n+            .build();\n+\n+    @Override\n+    public PaginationList.Builder builder() {\n+        return new SpongePaginationBuilder(this);\n+    }\n+\n+    @Nullable\n+    SourcePaginations getPaginationState(final Audience source, final boolean create) {\n+        if (source instanceof Player) {\n+            return this.getPaginationStateForPlayer((Player) source, create);\n+        }\n+\n+        return this.getPaginationStateForNonPlayer(source, create);\n+    }\n+\n+    @Nullable\n+    private SourcePaginations getPaginationStateForNonPlayer(final Audience source, final boolean create) {\n+        SourcePaginations ret = this.activePaginations.get(source);\n+        if (ret == null && create) {\n+            ret = new SourcePaginations();\n+            final SourcePaginations existing = this.activePaginations.putIfAbsent(source, ret);\n+            if (existing != null) {\n+                ret = existing;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    @Nullable\n+    private SourcePaginations getPaginationStateForPlayer(final Player source, final boolean create) {\n+        return this.playerActivePaginations.get(source.getUniqueId(), k -> create ? new SourcePaginations() : null);\n+    }\n+\n+    public Command.Parameterized createPaginationCommand() {\n+        final Parameter.Value<ActivePagination> paginationIdParameter = Parameter.builder(ActivePagination.class)\n+                .parser(new ActivePaginationParameter())\n+                .setKey(\"pagination-id\")\n+                .build();\n+\n+        final Command.Parameterized next = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the next page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).nextPage();\n+                    return CommandResult.success();\n+                }).build();\n+\n+        final Command.Parameterized prev = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the previous page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).previousPage();\n+                    return CommandResult.success();\n+                }).build();\n+\n+        final Parameter.Value<Integer> pageParameter = Parameter.integerNumber().setKey(\"page\").build();\n+\n+        final CommandExecutor pageExecutor = (context) -> {\n+            context.requireOne(paginationIdParameter).specificPage(context.requireOne(pageParameter));\n+            return CommandResult.success();\n+        };\n+\n+        final Command.Parameterized page = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to a specific page\"))\n+                .parameter(pageParameter)\n+                .setExecutor(pageExecutor)\n+                .build();\n+\n+        //We create the child manually in order to force that paginationElement is required for all children + fallback", "originalCommit": "7b02c40b5eda99157e51d8b00edb9e44377a1da7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY4ODI4MQ==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471688281", "bodyText": ".first(Audience.class) -> .getAudience() (audiences do have special handling in command causes)", "author": "dualspiral", "createdAt": "2020-08-17T18:31:36Z", "path": "src/main/java/org/spongepowered/common/service/pagination/SpongePaginationService.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.service.pagination;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.MapMaker;\n+import com.google.inject.Singleton;\n+import net.kyori.adventure.audience.Audience;\n+import net.kyori.adventure.text.TextComponent;\n+import org.spongepowered.api.command.Command;\n+import org.spongepowered.api.command.CommandExecutor;\n+import org.spongepowered.api.command.CommandResult;\n+import org.spongepowered.api.command.exception.ArgumentParseException;\n+import org.spongepowered.api.command.parameter.ArgumentReader;\n+import org.spongepowered.api.command.parameter.CommandContext;\n+import org.spongepowered.api.command.parameter.Parameter;\n+import org.spongepowered.api.command.parameter.managed.ValueParameter;\n+import org.spongepowered.api.entity.living.player.Player;\n+import org.spongepowered.api.service.pagination.PaginationList;\n+import org.spongepowered.api.service.pagination.PaginationService;\n+import org.spongepowered.api.util.Nameable;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+@Singleton\n+public final class SpongePaginationService implements PaginationService {\n+\n+    static final class SourcePaginations {\n+\n+        private final Map<UUID, ActivePagination> paginations = new ConcurrentHashMap<>();\n+        @Nullable private volatile UUID lastUuid;\n+\n+        @Nullable public ActivePagination get(final UUID uuid) {\n+            return this.paginations.get(uuid);\n+        }\n+\n+        public void put(final ActivePagination pagination) {\n+            synchronized (this.paginations) {\n+                this.paginations.put(pagination.getId(), pagination);\n+                this.lastUuid = pagination.getId();\n+            }\n+        }\n+\n+        public Set<UUID> keys() {\n+            return this.paginations.keySet();\n+        }\n+\n+        @Nullable\n+        public UUID getLastUuid() {\n+            return this.lastUuid;\n+        }\n+    }\n+\n+    private final ConcurrentMap<Audience, SourcePaginations> activePaginations = new MapMaker().weakKeys().makeMap();\n+\n+    // We have a second active pagination system because of the way Players are handled by the server.\n+    // As Players are recreated every time they die in game, just storing the player in a weak map will\n+    // cause the player to be removed form the map upon death. Thus, player paginations get redirected\n+    // through to this cache instead, which last for 10 minutes from last access.\n+    private final Cache<UUID, SourcePaginations> playerActivePaginations = Caffeine.newBuilder().expireAfterAccess(10, TimeUnit.MINUTES)\n+            .build();\n+\n+    @Override\n+    public PaginationList.Builder builder() {\n+        return new SpongePaginationBuilder(this);\n+    }\n+\n+    @Nullable\n+    SourcePaginations getPaginationState(final Audience source, final boolean create) {\n+        if (source instanceof Player) {\n+            return this.getPaginationStateForPlayer((Player) source, create);\n+        }\n+\n+        return this.getPaginationStateForNonPlayer(source, create);\n+    }\n+\n+    @Nullable\n+    private SourcePaginations getPaginationStateForNonPlayer(final Audience source, final boolean create) {\n+        SourcePaginations ret = this.activePaginations.get(source);\n+        if (ret == null && create) {\n+            ret = new SourcePaginations();\n+            final SourcePaginations existing = this.activePaginations.putIfAbsent(source, ret);\n+            if (existing != null) {\n+                ret = existing;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    @Nullable\n+    private SourcePaginations getPaginationStateForPlayer(final Player source, final boolean create) {\n+        return this.playerActivePaginations.get(source.getUniqueId(), k -> create ? new SourcePaginations() : null);\n+    }\n+\n+    public Command.Parameterized createPaginationCommand() {\n+        final Parameter.Value<ActivePagination> paginationIdParameter = Parameter.builder(ActivePagination.class)\n+                .parser(new ActivePaginationParameter())\n+                .setKey(\"pagination-id\")\n+                .build();\n+\n+        final Command.Parameterized next = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the next page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).nextPage();\n+                    return CommandResult.success();\n+                }).build();\n+\n+        final Command.Parameterized prev = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the previous page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).previousPage();\n+                    return CommandResult.success();\n+                }).build();\n+\n+        final Parameter.Value<Integer> pageParameter = Parameter.integerNumber().setKey(\"page\").build();\n+\n+        final CommandExecutor pageExecutor = (context) -> {\n+            context.requireOne(paginationIdParameter).specificPage(context.requireOne(pageParameter));\n+            return CommandResult.success();\n+        };\n+\n+        final Command.Parameterized page = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to a specific page\"))\n+                .parameter(pageParameter)\n+                .setExecutor(pageExecutor)\n+                .build();\n+\n+        //We create the child manually in order to force that paginationElement is required for all children + fallback\n+        //https://github.com/SpongePowered/SpongeAPI/issues/1272\n+        return Command.builder()\n+                .parameters(paginationIdParameter, Parameter.firstOf(pageParameter,\n+                        Parameter.subcommand(next, \"next\", \"n\"),\n+                        Parameter.subcommand(prev, \"prev\", \"p\", \"previous\"),\n+                        Parameter.subcommand(page, \"page\")))\n+                .child(page, \"page\")\n+                .setExecutor(page)\n+                .setShortDescription(TextComponent.of(\"Helper command for paginations occurring\"))\n+                .build();\n+    }\n+\n+    private final class ActivePaginationParameter implements ValueParameter<ActivePagination> {\n+\n+        @Override\n+        public Optional<? extends ActivePagination> getValue(final Parameter.Key<? super ActivePagination> parameterKey,\n+                final ArgumentReader.Mutable reader,\n+                final CommandContext.Builder context) throws ArgumentParseException {\n+            final Audience source = context.getCause().first(Audience.class)\n+                    .orElseThrow(() -> reader.createException(TextComponent.of(\"No usable source found\")));\n+\n+            final SourcePaginations paginations = SpongePaginationService.this.getPaginationState(source, false);\n+            if (paginations == null) {\n+                final String name = source instanceof Nameable ? ((Nameable) source).getName() : source.toString();\n+                throw reader.createException(TextComponent.of(String.format(\"Source %s has no paginations!\", name)));\n+            }\n+\n+            final UUID id;\n+            final ArgumentReader.Immutable state = reader.getImmutable();\n+            try {\n+                id = UUID.fromString(reader.parseString());\n+            } catch (final IllegalArgumentException ex) {\n+                if (paginations.getLastUuid() != null) {\n+                    reader.setState(state);\n+                    return Optional.ofNullable(paginations.get(paginations.getLastUuid()));\n+                }\n+                throw reader.createException(TextComponent.of(\"Input was not a valid UUID!\"));\n+            }\n+            final ActivePagination pagination = paginations.get(id);\n+            if (pagination == null) {\n+                throw reader.createException(TextComponent.of(\"No pagination registered for id \" + id));\n+            }\n+            return Optional.ofNullable(paginations.get(id));\n+        }\n+\n+        @Override\n+        public List<String> complete(final CommandContext context) {\n+            return context.getCause().first(Audience.class)", "originalCommit": "7b02c40b5eda99157e51d8b00edb9e44377a1da7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY4ODY3NA==", "url": "https://github.com/SpongePowered/Sponge/pull/3044#discussion_r471688674", "bodyText": ".first(Audience.class) -> .getAudience()", "author": "dualspiral", "createdAt": "2020-08-17T18:31:54Z", "path": "src/main/java/org/spongepowered/common/service/pagination/SpongePaginationService.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * This file is part of Sponge, licensed under the MIT License (MIT).\n+ *\n+ * Copyright (c) SpongePowered <https://www.spongepowered.org>\n+ * Copyright (c) contributors\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package org.spongepowered.common.service.pagination;\n+\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.MapMaker;\n+import com.google.inject.Singleton;\n+import net.kyori.adventure.audience.Audience;\n+import net.kyori.adventure.text.TextComponent;\n+import org.spongepowered.api.command.Command;\n+import org.spongepowered.api.command.CommandExecutor;\n+import org.spongepowered.api.command.CommandResult;\n+import org.spongepowered.api.command.exception.ArgumentParseException;\n+import org.spongepowered.api.command.parameter.ArgumentReader;\n+import org.spongepowered.api.command.parameter.CommandContext;\n+import org.spongepowered.api.command.parameter.Parameter;\n+import org.spongepowered.api.command.parameter.managed.ValueParameter;\n+import org.spongepowered.api.entity.living.player.Player;\n+import org.spongepowered.api.service.pagination.PaginationList;\n+import org.spongepowered.api.service.pagination.PaginationService;\n+import org.spongepowered.api.util.Nameable;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.annotation.Nullable;\n+\n+@Singleton\n+public final class SpongePaginationService implements PaginationService {\n+\n+    static final class SourcePaginations {\n+\n+        private final Map<UUID, ActivePagination> paginations = new ConcurrentHashMap<>();\n+        @Nullable private volatile UUID lastUuid;\n+\n+        @Nullable public ActivePagination get(final UUID uuid) {\n+            return this.paginations.get(uuid);\n+        }\n+\n+        public void put(final ActivePagination pagination) {\n+            synchronized (this.paginations) {\n+                this.paginations.put(pagination.getId(), pagination);\n+                this.lastUuid = pagination.getId();\n+            }\n+        }\n+\n+        public Set<UUID> keys() {\n+            return this.paginations.keySet();\n+        }\n+\n+        @Nullable\n+        public UUID getLastUuid() {\n+            return this.lastUuid;\n+        }\n+    }\n+\n+    private final ConcurrentMap<Audience, SourcePaginations> activePaginations = new MapMaker().weakKeys().makeMap();\n+\n+    // We have a second active pagination system because of the way Players are handled by the server.\n+    // As Players are recreated every time they die in game, just storing the player in a weak map will\n+    // cause the player to be removed form the map upon death. Thus, player paginations get redirected\n+    // through to this cache instead, which last for 10 minutes from last access.\n+    private final Cache<UUID, SourcePaginations> playerActivePaginations = Caffeine.newBuilder().expireAfterAccess(10, TimeUnit.MINUTES)\n+            .build();\n+\n+    @Override\n+    public PaginationList.Builder builder() {\n+        return new SpongePaginationBuilder(this);\n+    }\n+\n+    @Nullable\n+    SourcePaginations getPaginationState(final Audience source, final boolean create) {\n+        if (source instanceof Player) {\n+            return this.getPaginationStateForPlayer((Player) source, create);\n+        }\n+\n+        return this.getPaginationStateForNonPlayer(source, create);\n+    }\n+\n+    @Nullable\n+    private SourcePaginations getPaginationStateForNonPlayer(final Audience source, final boolean create) {\n+        SourcePaginations ret = this.activePaginations.get(source);\n+        if (ret == null && create) {\n+            ret = new SourcePaginations();\n+            final SourcePaginations existing = this.activePaginations.putIfAbsent(source, ret);\n+            if (existing != null) {\n+                ret = existing;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    @Nullable\n+    private SourcePaginations getPaginationStateForPlayer(final Player source, final boolean create) {\n+        return this.playerActivePaginations.get(source.getUniqueId(), k -> create ? new SourcePaginations() : null);\n+    }\n+\n+    public Command.Parameterized createPaginationCommand() {\n+        final Parameter.Value<ActivePagination> paginationIdParameter = Parameter.builder(ActivePagination.class)\n+                .parser(new ActivePaginationParameter())\n+                .setKey(\"pagination-id\")\n+                .build();\n+\n+        final Command.Parameterized next = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the next page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).nextPage();\n+                    return CommandResult.success();\n+                }).build();\n+\n+        final Command.Parameterized prev = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to the previous page\"))\n+                .setExecutor((context) -> {\n+                    context.requireOne(paginationIdParameter).previousPage();\n+                    return CommandResult.success();\n+                }).build();\n+\n+        final Parameter.Value<Integer> pageParameter = Parameter.integerNumber().setKey(\"page\").build();\n+\n+        final CommandExecutor pageExecutor = (context) -> {\n+            context.requireOne(paginationIdParameter).specificPage(context.requireOne(pageParameter));\n+            return CommandResult.success();\n+        };\n+\n+        final Command.Parameterized page = Command.builder()\n+                .setShortDescription(TextComponent.of(\"Go to a specific page\"))\n+                .parameter(pageParameter)\n+                .setExecutor(pageExecutor)\n+                .build();\n+\n+        //We create the child manually in order to force that paginationElement is required for all children + fallback\n+        //https://github.com/SpongePowered/SpongeAPI/issues/1272\n+        return Command.builder()\n+                .parameters(paginationIdParameter, Parameter.firstOf(pageParameter,\n+                        Parameter.subcommand(next, \"next\", \"n\"),\n+                        Parameter.subcommand(prev, \"prev\", \"p\", \"previous\"),\n+                        Parameter.subcommand(page, \"page\")))\n+                .child(page, \"page\")\n+                .setExecutor(page)\n+                .setShortDescription(TextComponent.of(\"Helper command for paginations occurring\"))\n+                .build();\n+    }\n+\n+    private final class ActivePaginationParameter implements ValueParameter<ActivePagination> {\n+\n+        @Override\n+        public Optional<? extends ActivePagination> getValue(final Parameter.Key<? super ActivePagination> parameterKey,\n+                final ArgumentReader.Mutable reader,\n+                final CommandContext.Builder context) throws ArgumentParseException {\n+            final Audience source = context.getCause().first(Audience.class)", "originalCommit": "7b02c40b5eda99157e51d8b00edb9e44377a1da7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f5c884dd0b1f25245dfffe9a99c0406b96a3da8b", "url": "https://github.com/SpongePowered/Sponge/commit/f5c884dd0b1f25245dfffe9a99c0406b96a3da8b", "message": "Make common.service.pagination compile\n\nAlso use namespaced commands to avoid ambiguity with mods/plugins commands", "committedDate": "2020-08-18T09:01:25Z", "type": "commit"}, {"oid": "9d63bd80bbc2aa84e66c3c27fa9eebc96ac396d2", "url": "https://github.com/SpongePowered/Sponge/commit/9d63bd80bbc2aa84e66c3c27fa9eebc96ac396d2", "message": "Couple of fixes\n\nMake sure we compile with UTF-8 or it breaks special characters used in the pagination list\nAttempt to work around a Style#getBold stackoverflow\nFix footer padding being 1 characters too long (not a fan of decrementing but I found no better way)\nFix padding color always using title's color\nRemove unused methods and parameters", "committedDate": "2020-08-18T09:01:25Z", "type": "commit"}, {"oid": "2243a40afeb9f12cb1a2c31f51cd3abc1a568e6c", "url": "https://github.com/SpongePowered/Sponge/commit/2243a40afeb9f12cb1a2c31f51cd3abc1a568e6c", "message": "Register pagination command on startup", "committedDate": "2020-08-18T09:01:25Z", "type": "commit"}, {"oid": "312dc48fd1d6fc016eafa125c676bf3314a5442d", "url": "https://github.com/SpongePowered/Sponge/commit/312dc48fd1d6fc016eafa125c676bf3314a5442d", "message": "Address feedback\n\n- merge ActivePaginationParser & Completer\n- remove static imports except for Preconditions\n- fix possible CCE when registering pagination command", "committedDate": "2020-08-18T09:01:25Z", "type": "commit"}, {"oid": "1f250258c3d8332bcd535cb84efa2da333156ce6", "url": "https://github.com/SpongePowered/Sponge/commit/1f250258c3d8332bcd535cb84efa2da333156ce6", "message": "Add finals everywhere", "committedDate": "2020-08-18T09:01:25Z", "type": "commit"}, {"oid": "86d96a2fd1248020407c6c6182556cdfb1f9eadb", "url": "https://github.com/SpongePowered/Sponge/commit/86d96a2fd1248020407c6c6182556cdfb1f9eadb", "message": "Replace anonymous guava Function with method reference", "committedDate": "2020-08-18T09:01:26Z", "type": "commit"}, {"oid": "2533046ee9a352e323c05278713862d407b521e8", "url": "https://github.com/SpongePowered/Sponge/commit/2533046ee9a352e323c05278713862d407b521e8", "message": "Address feedback - pass 2\n\n- stop copying Styles in PaginationCalculator to avoid StackOverflows,\n fixed in 44be61c0dbc79069f82c174b63d7a68aa254c1b7 thanks dual !\n- replace Optional fields by nullable ones\n- remove outdated comment\n- use CommandCause#getAudience instead of Cause#first\n\nAlso fix a possible NPE in ActivePaginationParameter#complete", "committedDate": "2020-08-18T09:36:33Z", "type": "commit"}, {"oid": "2533046ee9a352e323c05278713862d407b521e8", "url": "https://github.com/SpongePowered/Sponge/commit/2533046ee9a352e323c05278713862d407b521e8", "message": "Address feedback - pass 2\n\n- stop copying Styles in PaginationCalculator to avoid StackOverflows,\n fixed in 44be61c0dbc79069f82c174b63d7a68aa254c1b7 thanks dual !\n- replace Optional fields by nullable ones\n- remove outdated comment\n- use CommandCause#getAudience instead of Cause#first\n\nAlso fix a possible NPE in ActivePaginationParameter#complete", "committedDate": "2020-08-18T09:36:33Z", "type": "forcePushed"}]}