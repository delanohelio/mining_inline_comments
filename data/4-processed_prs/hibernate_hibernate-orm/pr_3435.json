{"pr_number": 3435, "pr_title": "Circularity detection, EmbeddedId and other fixes", "pr_createdAt": "2020-06-16T19:45:21Z", "pr_url": "https://github.com/hibernate/hibernate-orm/pull/3435", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4Nzk0OQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r441187949", "bodyText": "It seems the above code snippet performance could be improved as following:\nfinal List<Fetch> fullPathFetches = visitedNavigablePath.get( fullPath );\nif ( fullPathFetches != null ) {\n    return fullPathFetches;\n}\n\nIt would incur only retrieval once instead of twice. Given that the map value is collection which is never null, we could simplify accordingly. Your code snippet would be mandatory if null is a possible value, though.", "author": "NathanQingyangXu", "createdAt": "2020-06-16T22:59:10Z", "path": "hibernate-core/src/main/java/org/hibernate/loader/ast/internal/LoaderSelectBuilder.java", "diffHunk": "@@ -419,15 +426,21 @@ private void applyOrdering(TableGroup tableGroup, OrderByFragment orderByFragmen\n \t\tlog.tracef( \"Starting visitation of FetchParent's Fetchables : %s\", fetchParent.getNavigablePath() );\n \n \t\tfinal List<Fetch> fetches = new ArrayList<>();\n+\t\tString fullPath = fetchParent.getNavigablePath().getFullPath();\n+\t\tif ( visitedNavigablePath.containsKey( fullPath ) ) {\n+\t\t\treturn visitedNavigablePath.get( fullPath );\n+\t\t}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4OTA4Mg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r441189082", "bodyText": "moving the declaration of 'fetches' before the above statement would improve code readability a little bit. As a general rule, putting variable declaration as near its usage as possible decrease human brain memorizing pressure, I think.", "author": "NathanQingyangXu", "createdAt": "2020-06-16T23:02:33Z", "path": "hibernate-core/src/main/java/org/hibernate/loader/ast/internal/LoaderSelectBuilder.java", "diffHunk": "@@ -419,15 +426,21 @@ private void applyOrdering(TableGroup tableGroup, OrderByFragment orderByFragmen\n \t\tlog.tracef( \"Starting visitation of FetchParent's Fetchables : %s\", fetchParent.getNavigablePath() );\n \n \t\tfinal List<Fetch> fetches = new ArrayList<>();\n+\t\tString fullPath = fetchParent.getNavigablePath().getFullPath();\n+\t\tif ( visitedNavigablePath.containsKey( fullPath ) ) {\n+\t\t\treturn visitedNavigablePath.get( fullPath );\n+\t\t}\n \n \t\tfinal BiConsumer<Fetchable, Boolean> processor = createFetchableBiConsumer( fetchParent, querySpec, creationState, fetches );", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4OTU0MA==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r441189540", "bodyText": "I am a little bit shamed to point out adding another space char after ( in the above new code would make the format more consistent. Super minor for sure.", "author": "NathanQingyangXu", "createdAt": "2020-06-16T23:04:08Z", "path": "hibernate-core/src/main/java/org/hibernate/loader/ast/internal/LoaderSelectBuilder.java", "diffHunk": "@@ -495,7 +508,7 @@ else if ( fetchDepth > maximumFetchDepth ) {\n \t\t\t}\n \n \t\t\ttry {\n-\t\t\t\tif ( !( fetchable instanceof BasicValuedModelPart ) ) {\n+\t\t\t\tif ( !( fetchable instanceof BasicValuedModelPart ) && !(fetchable instanceof EmbeddedAttributeMapping ) ) {", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MDkwNw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r441190907", "bodyText": "I saw there is some code duplication above (283-284 vs 251-252). Maybe we can eliminate it to avoid changing both when future refactoring is needed.", "author": "NathanQingyangXu", "createdAt": "2020-06-16T23:08:10Z", "path": "hibernate-core/src/main/java/org/hibernate/mapping/Column.java", "diffHunk": "@@ -276,6 +276,17 @@ public String getSqlType(Dialect dialect, Mapping mapping) throws HibernateExcep\n \t\treturn sqlType;\n \t}\n \n+\tprivate Type getType(Mapping mapping, Type type) {\n+\t\twhile ( !( type instanceof JdbcMapping ) ) {\n+\t\t\t//ManyToOneType doesn't implement JdbcMapping\n+\t\t\ttype = mapping.getIdentifierType( ( (EntityType) type ).getAssociatedEntityName() );\n+\t\t\tif ( type instanceof ComponentType ) {\n+\t\t\t\ttype = ( (ComponentType) type ).getSubtypes()[getTypeIndex()];", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MjcxNg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r441192716", "bodyText": "we can save a pair of {} in the lambda, though not a big deal", "author": "NathanQingyangXu", "createdAt": "2020-06-16T23:13:47Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/EmbeddableMappingType.java", "diffHunk": "@@ -345,7 +345,18 @@ public void visitJdbcTypes(\n \t\t\tClause clause,\n \t\t\tTypeConfiguration typeConfiguration) {\n \t\tattributeMappings.forEach(\n-\t\t\t\t(s, attributeMapping) -> attributeMapping.visitJdbcTypes( action, clause, typeConfiguration )\n+\t\t\t\t(s, attributeMapping) -> {\n+\t\t\t\t\tif ( attributeMapping instanceof ToOneAttributeMapping ) {\n+\t\t\t\t\t\t( (ToOneAttributeMapping) attributeMapping ).getKeyTargetMatchPart().visitJdbcTypes(\n+\t\t\t\t\t\t\t\taction,\n+\t\t\t\t\t\t\t\tclause,\n+\t\t\t\t\t\t\t\ttypeConfiguration\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\tattributeMapping.visitJdbcTypes( action, clause, typeConfiguration );\n+\t\t\t\t\t}\n+\t\t\t\t}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5MzM0Mg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r441193342", "bodyText": "I am pretty sure System.arrayCopy seems to be much more performant, though not a big deal.", "author": "NathanQingyangXu", "createdAt": "2020-06-16T23:15:47Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/EmbeddedForeignKeyDescriptor.java", "diffHunk": "@@ -330,17 +324,18 @@ public void visitTargetColumns(ColumnConsumer consumer) {\n \t}\n \n \t@Override\n-\tpublic boolean areTargetColumnNamesEqualsTo(String[] columnNames) {\n-\t\tint length = columnNames.length;\n-\t\tif ( length != targetColumnExpressions.size() ) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tfor ( int i = 0; i < length; i++ ) {\n-\t\t\tif ( !targetColumnExpressions.contains( columnNames[i] ) ) {\n-\t\t\t\treturn false;\n+\tpublic AssociationKey getAssociationKey() {\n+\t\tif ( associationKey == null ) {\n+\t\t\tString[] associationKeyColumns = new String[keyColumnExpressions.size()];\n+\t\t\tint i = 0;\n+\t\t\tfor ( String keyColumnExpression : this.keyColumnExpressions ) {\n+\t\t\t\tassociationKeyColumns[i] = keyColumnExpression;\n+\t\t\t\ti++;\n \t\t\t}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwMzA2Mg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r445103062", "bodyText": "It seems LinkedHashMap shares the same problem with HashMap in that the initialCapacity is not the same as expectedSize except the loadFactor is specified as 1. Only ConcurrentHashMap is immune with this annoying problem. If CollectionHelper doesn't support util static factory method for it, we might well create one there.", "author": "NathanQingyangXu", "createdAt": "2020-06-24T18:53:42Z", "path": "hibernate-core/src/main/java/org/hibernate/persister/entity/JoinedSubclassEntityPersister.java", "diffHunk": "@@ -525,17 +526,36 @@ else if ( persistentClass.isDiscriminatorValueNotNull() ) {\n \n \t\tint subclassSpan = persistentClass.getSubclassSpan() + 1;\n \t\tsubclassClosure = new String[subclassSpan];\n-\t\tsubclassClosure[subclassSpan - 1] = getEntityName();\n+\t\tint subclassSpanMinusOne = subclassSpan - 1;\n+\t\tsubclassClosure[subclassSpanMinusOne] = getEntityName();\n \t\tif ( persistentClass.isPolymorphic() ) {\n \t\t\tsubclassesByDiscriminatorValue.put( discriminatorValue, getEntityName() );\n \n-\t\t\tdiscriminatorValuesByTableName = new LinkedHashMap<>( subclassSpan + 1 );\n-\t\t\tsubclassNameByTableName = CollectionHelper.mapOfSize( subclassSpan + 1);\n+\t\t\tint initialCapacity = subclassSpan + 1;\n+\t\t\tdiscriminatorValuesByTableName = new LinkedHashMap<>( initialCapacity );\n+\t\t\tdiscriminatorColumnNameByTableName = new LinkedHashMap<>( initialCapacity );", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEwMzkyMw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r445103923", "bodyText": "seems combining the above two if together in one if leads to better readability, though not a big deal", "author": "NathanQingyangXu", "createdAt": "2020-06-24T18:55:13Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/ToOneAttributeMapping.java", "diffHunk": "@@ -169,101 +176,145 @@ public Fetch resolveCircularFetch(\n \t\t\tNavigablePath fetchablePath,\n \t\t\tFetchParent fetchParent,\n \t\t\tDomainResultCreationState creationState) {\n-\t\t// NOTE - a circular fetch reference ultimately needs 2 pieces of information:\n-\t\t//\t\t1) The NavigablePath that is circular (`fetchablePath`)\n-\t\t//\t\t2) The NavigablePath to the entity-valued-reference that is the \"other side\" of the circularity\n+\t\tfinal AssociationKey associationKey = foreignKeyDescriptor.getAssociationKey();\n+\n+\t\tif ( creationState.isAssociationKeyVisited( associationKey ) ) {\n+\t\t\tNavigablePath parent = fetchablePath.getParent();\n+\t\t\tModelPart modelPart = creationState.resolveModelPart( parent );\n+\t\t\tif ( modelPart instanceof EmbeddedIdentifierMappingImpl ) {\n+\t\t\t\twhile ( parent.getFullPath().endsWith( EntityIdentifierMapping.ROLE_LOCAL_NAME ) ) {\n+\t\t\t\t\tparent = parent.getParent();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\twhile ( modelPart instanceof EmbeddableValuedFetchable ) {\n+\t\t\t\tparent = parent.getParent();\n+\t\t\t\tmodelPart = creationState.resolveModelPart( parent );\n+\t\t\t}\n \n-\t\tfinal ModelPart parentModelPart = fetchParent.getReferencedModePart();\n+\t\t\tif ( this.mappedBy != null && parent.getFullPath().endsWith( this.mappedBy ) ) {\n+\t\t\t\t/*\n+\t\t\t\t\tclass Child {\n+\t\t\t\t\t\t@OneToOne(mappedBy = \"biologicalChild\")\n+\t\t\t\t\t\tprivate Mother mother;\n+\t\t\t\t\t}\n \n-\t\tif ( ! Fetchable.class.isInstance( parentModelPart ) ) {\n-\t\t\t// the `fetchParent` would have to be a Fetch as well for this to be circular...\n-\t\t\treturn null;\n-\t\t}\n+\t\t\t\t\tclass Mother {\n+\t\t\t\t\t\t@OneToOne\n+\t\t\t\t\t\tprivate Child biologicalChild;\n+\t\t\t\t\t}\n \n-\t\tfinal FetchParent associationFetchParent = fetchParent.resolveContainingAssociationParent();\n-\t\tif ( associationFetchParent == null ) {\n-\t\t\treturn null;\n-\t\t}\n-\t\tfinal ModelPart referencedModePart = associationFetchParent.getReferencedModePart();\n-\t\tassert referencedModePart instanceof Association;\n+\t\t\t\t\tfetchablePath= Mother.biologicalChild.mother\n+\t\t\t\t\tthis.mappedBy = \"biologicalChild\"\n+\t\t\t\t\tparent.getFullPath() = \"Mother.biologicalChild\"\n+\t\t\t\t */\n+\t\t\t\treturn createCircularBiDirectionalFetch(\n+\t\t\t\t\t\tfetchablePath,\n+\t\t\t\t\t\tfetchParent,\n+\t\t\t\t\t\tparent.getParent(),\n+\t\t\t\t\t\tLockMode.READ\n+\t\t\t\t);\n+\t\t\t}\n \n-\t\tfinal Association associationParent = (Association) referencedModePart;\n+\t\t\t/*\n+\t\t\t\tcheck if mappedBy is on the other side of the association\n+\t\t\t */\n+\t\t\tfinal String otherSideMappedBy = getOthrerSideMappedBy( modelPart, parent.getParent(), creationState );\n+\t\t\tif ( otherSideMappedBy != null ) {\n+\t\t\t\t\t/*\n+\t\t\t\t\t\tclass Child {\n+\t\t\t\t\t\t\t@OneToOne(mappedBy = \"biologicalChild\")\n+\t\t\t\t\t\t\tprivate Mother mother;\n+\t\t\t\t\t\t}\n \n-\t\tif ( foreignKeyDescriptor.equals( associationParent.getForeignKeyDescriptor() ) ) {\n-\t\t\t// we need to determine the NavigablePath referring to the entity that the bi-dir\n-\t\t\t// fetch will \"return\" for its Assembler.  so we walk \"up\" the FetchParent graph\n-\t\t\t// to find the \"referenced entity\" reference\n+\t\t\t\t\t\tclass Mother {\n+\t\t\t\t\t\t\t@OneToOne\n+\t\t\t\t\t\t\tprivate Child biologicalChild;\n+\t\t\t\t\t\t}\n \n-\t\t\treturn createBiDirectionalFetch( fetchablePath, fetchParent );\n-\t\t}\n+\t\t\t\t\t\tfetchablePath = \"Child.mother.biologicalChild\"\n+\t\t\t\t\t\totherSideAssociationModelPart = ToOneAttributeMapping(\"Child.mother\")\n+\t\t\t\t\t\totherSideMappedBy = \"biologicalChild\"\n \n-\t\t// this is the case of a JoinTable\n-\t\t// \tPARENT(id)\n-\t\t// \tPARENT_CHILD(parent_id, child_id)\n-\t\t// \tCHILD(id)\n-\t\t// \tthe FKDescriptor for the association `Parent.child` will be\n-\t\t//\t\tPARENT_CHILD.child.id -> CHILD.id\n-\t\t// and the FKDescriptor for the association `Child.parent` will be\n-\t\t//\t\tPARENT_CHILD.parent.id -> PARENT.id\n-\t\t// in such a case the associationParent.getIdentifyingColumnExpressions() is PARENT_CHILD.parent_id\n-\t\t// while the getIdentifyingColumnExpressions for this association is PARENT_CHILD.child_id\n-\t\t// so we will check if the parentAssociation ForeignKey Target match with the association entity identifier table and columns\n-\t\tfinal ForeignKeyDescriptor associationParentForeignKeyDescriptor = associationParent.getForeignKeyDescriptor();\n-\t\tif ( referencedModePart instanceof ToOneAttributeMapping\n-\t\t\t\t&& ( (ToOneAttributeMapping) referencedModePart ).getDeclaringType() == getPartMappingType() ) {\n-\t\t\tif ( this.foreignKeyDescriptor.getReferringTableExpression()\n-\t\t\t\t\t.equals( associationParentForeignKeyDescriptor.getReferringTableExpression() ) ) {\n-\t\t\t\tfinal SingleTableEntityPersister entityPersister = (SingleTableEntityPersister) getDeclaringType();\n-\t\t\t\tif ( associationParentForeignKeyDescriptor.getTargetTableExpression()\n-\t\t\t\t\t\t.equals( entityPersister.getTableName() ) ) {\n-\t\t\t\t\tfinal String[] identifierColumnNames = entityPersister.getIdentifierColumnNames();\n-\t\t\t\t\tif ( associationParentForeignKeyDescriptor.areTargetColumnNamesEqualsTo( identifierColumnNames ) ) {\n-\t\t\t\t\t\treturn createBiDirectionalFetch( fetchablePath, fetchParent );\n-\t\t\t\t\t}\n-\t\t\t\t\treturn null;\n+\t\t\t\t\t */\n+\n+\t\t\t\tif ( fetchablePath.getFullPath().endsWith( otherSideMappedBy ) ) {\n+\t\t\t\t\treturn createCircularBiDirectionalFetch(\n+\t\t\t\t\t\t\tfetchablePath,\n+\t\t\t\t\t\t\tfetchParent,\n+\t\t\t\t\t\t\tparent.getParent(),\n+\t\t\t\t\t\t\tLockMode.READ\n+\t\t\t\t\t);\n \t\t\t\t}\n+\t\t\t}\n+\t\t\t/*\n+\t\t\t\t\t\tclass Child {\n+\t\t\t\t\t\t\t@OneToOne\n+\t\t\t\t\t\t\tprivate Mother mother;\n+\t\t\t\t\t\t}\n \n+\t\t\t\t\t\tclass Mother {\n+\t\t\t\t\t\t\t@OneToOne\n+\t\t\t\t\t\t\tprivate Child stepMother;\n+\t\t\t\t\t\t}\n+\n+\t\t\t\tWe have a cirularity but it is not bidirectional\n+\t\t\t */\n+\t\t\tif ( referringPrimaryKey ) {\n+\t\t\t\tfinal TableGroup parentTableGroup = creationState\n+\t\t\t\t\t\t.getSqlAstCreationState()\n+\t\t\t\t\t\t.getFromClauseAccess()\n+\t\t\t\t\t\t.getTableGroup( fetchParent.getNavigablePath() );\n+\t\t\t\treturn new CircularFetchImpl(\n+\t\t\t\t\t\tgetEntityMappingType(),\n+\t\t\t\t\t\tgetTiming(),\n+\t\t\t\t\t\tfetchablePath,\n+\t\t\t\t\t\tfetchParent,\n+\t\t\t\t\t\tthis,\n+\t\t\t\t\t\tfetchablePath,\n+\t\t\t\t\t\tforeignKeyDescriptor.createDomainResult( fetchablePath, parentTableGroup, creationState )\n+\t\t\t\t);\n \t\t\t}\n \t\t}\n \t\treturn null;\n \t}\n \n-\tprivate Fetch createBiDirectionalFetch(NavigablePath fetchablePath, FetchParent fetchParent) {\n-\t\tfinal EntityResultGraphNode referencedEntityReference = resolveEntityGraphNode( fetchParent );\n+\tprivate String getOthrerSideMappedBy(\n+\t\t\tModelPart modelPart,\n+\t\t\tNavigablePath parentOfParent,\n+\t\t\tDomainResultCreationState creationState) {\n+\t\tif ( modelPart instanceof ToOneAttributeMapping ) {\n+\t\t\treturn ( (ToOneAttributeMapping) modelPart ).getMappedBy();\n+\t\t}\n \n-\t\tif ( referencedEntityReference == null ) {\n-\t\t\tthrow new HibernateException(\n-\t\t\t\t\t\"Could not locate entity-valued reference for circular path `\" + fetchablePath + \"`\"\n-\t\t\t);\n+\t\tif ( modelPart instanceof EntityCollectionPart ) {\n+\t\t\tif ( parentOfParent.getFullPath().endsWith( EntityIdentifierMapping.ROLE_LOCAL_NAME ) ) {\n+\t\t\t\tparentOfParent = parentOfParent.getParent();\n+\t\t\t}\n+\t\t\treturn ( (PluralAttributeMapping) creationState.resolveModelPart( parentOfParent ) ).getMappedBy();\n \t\t}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5MzEyMg==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r445193122", "bodyText": "why not include columns into hashCode as well? It has been used in equals already. Keep from using it doesn't violate the consistency between hashCode and equals, but it is a little bit confusing.", "author": "NathanQingyangXu", "createdAt": "2020-06-24T21:53:09Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/AssociationKey.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n+ * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n+ */\n+package org.hibernate.metamodel.mapping;\n+\n+import java.util.List;\n+\n+/**\n+ * @author Andrea Boriero\n+ */\n+public class AssociationKey {\n+\tprivate final String table;\n+\tprivate final List<String> columns;\n+\n+\tpublic AssociationKey(String table, List<String> columns) {\n+\t\tthis.table = table;\n+\t\tthis.columns = columns;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif ( this == o ) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif ( o == null || getClass() != o.getClass() ) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tfinal AssociationKey that = (AssociationKey) o;\n+\t\treturn table.equals( that.table ) && columns.equals( that.columns );\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn table.hashCode();\n+\t}", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5NDMxMA==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r445194310", "bodyText": "I would use , columns=[...] instead of , columns={..} for '{}' is usually used for map. Not a big deal for sure.", "author": "NathanQingyangXu", "createdAt": "2020-06-24T21:55:56Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/AssociationKey.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Hibernate, Relational Persistence for Idiomatic Java\n+ *\n+ * License: GNU Lesser General Public License (LGPL), version 2.1 or later\n+ * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html\n+ */\n+package org.hibernate.metamodel.mapping;\n+\n+import java.util.List;\n+\n+/**\n+ * @author Andrea Boriero\n+ */\n+public class AssociationKey {\n+\tprivate final String table;\n+\tprivate final List<String> columns;\n+\n+\tpublic AssociationKey(String table, List<String> columns) {\n+\t\tthis.table = table;\n+\t\tthis.columns = columns;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif ( this == o ) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif ( o == null || getClass() != o.getClass() ) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tfinal AssociationKey that = (AssociationKey) o;\n+\t\treturn table.equals( that.table ) && columns.equals( that.columns );\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn table.hashCode();\n+\t}\n+\n+\tprivate String str;\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tif ( str == null ) {\n+\t\t\tstr = \"AssociationKey(table=\" + table + \", columns={\" + String.join( \",\", columns ) + \"})\";", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5NjA3OQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3435#discussion_r445196079", "bodyText": "Do we allow for the possibility that associationKeyColumns is mutable later? Otherwise Collections.singletonList() would be more appropriate and less confusing.", "author": "NathanQingyangXu", "createdAt": "2020-06-24T22:00:11Z", "path": "hibernate-core/src/main/java/org/hibernate/metamodel/mapping/internal/SimpleForeignKeyDescriptor.java", "diffHunk": "@@ -285,32 +288,25 @@ public EntityMappingType findContainingEntityMapping() {\n \t\tthrow new UnsupportedOperationException();\n \t}\n \n-\t@Override\n-\tpublic String getReferringTableExpression() {\n-\t\treturn keyColumnContainingTable;\n-\t}\n-\n \t@Override\n \tpublic void visitReferringColumns(ColumnConsumer consumer) {\n \t\tconsumer.accept( keyColumnContainingTable, keyColumnExpression, jdbcMapping );\n \t}\n \n-\t@Override\n-\tpublic String getTargetTableExpression() {\n-\t\treturn targetColumnContainingTable;\n-\t}\n-\n \t@Override\n \tpublic void visitTargetColumns(ColumnConsumer consumer) {\n \t\tconsumer.accept( targetColumnContainingTable, targetColumnExpression, jdbcMapping );\n \t}\n \n \t@Override\n-\tpublic boolean areTargetColumnNamesEqualsTo(String[] columnNames) {\n-\t\tif ( columnNames.length != 1 ) {\n-\t\t\treturn false;\n+\tpublic AssociationKey getAssociationKey() {\n+\t\tif ( associationKey == null ) {\n+\t\t\tList<String> associationKeyColumns = new ArrayList<>( 1 );\n+\t\t\tassociationKeyColumns.add( keyColumnExpression );\n+\n+\t\t\tassociationKey = new AssociationKey( keyColumnContainingTable, associationKeyColumns );", "originalCommit": null, "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "511d4d55cd67db07f8f268174eb601fe986cbed4", "url": "https://github.com/hibernate/hibernate-orm/commit/511d4d55cd67db07f8f268174eb601fe986cbed4", "message": "Add more tests", "committedDate": "2020-06-26T09:15:46Z", "type": "commit"}, {"oid": "ead64b3ec98966ee7db2f33a3433d12fd2dc4d7c", "url": "https://github.com/hibernate/hibernate-orm/commit/ead64b3ec98966ee7db2f33a3433d12fd2dc4d7c", "message": " Add AssociationKey for bidirectionality detection", "committedDate": "2020-06-26T09:15:46Z", "type": "commit"}, {"oid": "47eee7cfe47c41d03ef8d388d809653e4c200a0a", "url": "https://github.com/hibernate/hibernate-orm/commit/47eee7cfe47c41d03ef8d388d809653e4c200a0a", "message": "Re-enabled additional tests", "committedDate": "2020-06-26T09:15:46Z", "type": "commit"}, {"oid": "2d0aad36b8087968ef0cf345aaa5de55cb16f47c", "url": "https://github.com/hibernate/hibernate-orm/commit/2d0aad36b8087968ef0cf345aaa5de55cb16f47c", "message": "Fix PluralAttribute manyToMany FK target part determination", "committedDate": "2020-06-26T09:15:46Z", "type": "commit"}, {"oid": "567b6cc076c937cd87781c1e59a0d807f0e932b2", "url": "https://github.com/hibernate/hibernate-orm/commit/567b6cc076c937cd87781c1e59a0d807f0e932b2", "message": "Re-enabled additional tests", "committedDate": "2020-06-26T09:15:46Z", "type": "commit"}, {"oid": "79e52038971cd9e2eee44734a4d6dc51e650860a", "url": "https://github.com/hibernate/hibernate-orm/commit/79e52038971cd9e2eee44734a4d6dc51e650860a", "message": "Re-enabled additional tests", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "cdc0e3f81769a313b75627b40fed6f5a90cc3a44", "url": "https://github.com/hibernate/hibernate-orm/commit/cdc0e3f81769a313b75627b40fed6f5a90cc3a44", "message": "Re-enabled additional tests", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "7fd6e4fbea4f069225c852078c51acf1bd633677", "url": "https://github.com/hibernate/hibernate-orm/commit/7fd6e4fbea4f069225c852078c51acf1bd633677", "message": "Fix issue with fetch a ManyToOne with join table using inner join", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "23ffe42b6c011d910e0b2d21a79da59e4606809b", "url": "https://github.com/hibernate/hibernate-orm/commit/23ffe42b6c011d910e0b2d21a79da59e4606809b", "message": "Fix joined subclass discriminator column determination", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "dfb3511923f008a49c9ceaa51b190b9f711d8835", "url": "https://github.com/hibernate/hibernate-orm/commit/dfb3511923f008a49c9ceaa51b190b9f711d8835", "message": "Re-enabled additional tests", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "3ad68d3f8850fbfbaf989c39ecda55a5c624986f", "url": "https://github.com/hibernate/hibernate-orm/commit/3ad68d3f8850fbfbaf989c39ecda55a5c624986f", "message": "Fix issue with circularity detection", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "b84d41a66cad4773055e974649506bc8e9eeeee6", "url": "https://github.com/hibernate/hibernate-orm/commit/b84d41a66cad4773055e974649506bc8e9eeeee6", "message": "Re-enabled additional tests", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "d85bf402e3023f9b75bc4b2b1b9fde6b03326659", "url": "https://github.com/hibernate/hibernate-orm/commit/d85bf402e3023f9b75bc4b2b1b9fde6b03326659", "message": "Re-enabled additional tests", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "dca850f5add24892722b6fd471076990911c7f3d", "url": "https://github.com/hibernate/hibernate-orm/commit/dca850f5add24892722b6fd471076990911c7f3d", "message": "Re-enabled additional tests", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "6aefe00c1ead690b54d6ac9e5e2d24f936eea923", "url": "https://github.com/hibernate/hibernate-orm/commit/6aefe00c1ead690b54d6ac9e5e2d24f936eea923", "message": "EagerCollectionFetch generates collection and index fetches twice", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "3c7a208b962ea0badb635869a6f2e69ba2b46e12", "url": "https://github.com/hibernate/hibernate-orm/commit/3c7a208b962ea0badb635869a6f2e69ba2b46e12", "message": "Removed unnecessary visitedNavigablePath from LoaderSelectBuilder and added bidirectionalPropertyName for circularity detection", "committedDate": "2020-06-26T09:15:47Z", "type": "commit"}, {"oid": "3c7a208b962ea0badb635869a6f2e69ba2b46e12", "url": "https://github.com/hibernate/hibernate-orm/commit/3c7a208b962ea0badb635869a6f2e69ba2b46e12", "message": "Removed unnecessary visitedNavigablePath from LoaderSelectBuilder and added bidirectionalPropertyName for circularity detection", "committedDate": "2020-06-26T09:15:47Z", "type": "forcePushed"}]}