{"pr_number": 3453, "pr_title": "HHH-14097 Fix redundant SQLs issue for fetch entity graph", "pr_createdAt": "2020-07-04T11:26:15Z", "pr_url": "https://github.com/hibernate/hibernate-orm/pull/3453", "timeline": [{"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3MzM0Mw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r450073343", "bodyText": "Since this is an example in documentation, I think it would be clearer to just use the string (as it was)?\nIf you really want to use a constant in documentation, we should also show the import statement, or use the fully qualified classname.", "author": "Sanne", "createdAt": "2020-07-06T08:45:18Z", "path": "documentation/src/test/java/org/hibernate/userguide/fetching/GraphFetchingTest.java", "diffHunk": "@@ -89,7 +85,7 @@ public void test() {\n \t\t\t\tEmployee.class,\n \t\t\t\tuserId,\n \t\t\t\tCollections.singletonMap(\n-\t\t\t\t\t\"javax.persistence.fetchgraph\",\n+\t\t\t\t\tGraphSemantic.FETCH.getJpaHintName(),", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDEyODMyNw==", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r450128327", "bodyText": "Thanks. Didn't realize that. Reverted back the changes to the class. Thanks.", "author": "NathanQingyangXu", "createdAt": "2020-07-06T10:24:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA3MzM0Mw=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI3OTE2NA==", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r450279164", "bodyText": "I'm not sure about this, are we entirely sure that the fetch graph is no longer needed at this point?\nWouldn't it be possible for the fetch grapth to need to span multiple load events?\nIF this is correct, should line 285 be removed as it seems redundant?", "author": "Sanne", "createdAt": "2020-07-06T14:55:12Z", "path": "hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java", "diffHunk": "@@ -206,62 +206,91 @@ public static void initializeEntityEntryLoadedState(\n \t\tString entityName = persister.getEntityName();\n \t\tString[] propertyNames = persister.getPropertyNames();\n \t\tfinal Type[] types = persister.getPropertyTypes();\n-\t\t\n-\t\tfinal GraphImplementor<?> fetchGraphContext = session.getFetchGraphLoadContext();\n-\t\t\n-\t\tfor ( int i = 0; i < hydratedState.length; i++ ) {\n-\t\t\tfinal Object value = hydratedState[i];\n-\t\t\tif ( debugEnabled ) {\n-\t\t\t\tLOG.debugf(\n-\t\t\t\t\t\"Processing attribute `%s` : value = %s\",\n-\t\t\t\t\tpropertyNames[i],\n-\t\t\t\t\tvalue == LazyPropertyInitializer.UNFETCHED_PROPERTY ? \"<un-fetched>\" : value == PropertyAccessStrategyBackRefImpl.UNKNOWN ? \"<unknown>\" : value\n-\t\t\t\t);\n-\t\t\t}\n \n-\t\t\tif ( value == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n+\t\tGraphImplementor fetchGraphContext = session.getFetchGraphLoadContext();\n+\t\tif ( fetchGraphContext != null && !fetchGraphContext.appliesTo( entity.getClass() ) ) {\n+\t\t\tLOG.warnf( \"Entity graph specified is not applicable to the entity [%s]. Ignored.\", entity);\n+\t\t\tfetchGraphContext = null;\n+\t\t\tsession.setFetchGraphLoadContext( null );\n+\t\t}\n+\n+\t\ttry {\n+\t\t\tfor ( int i = 0; i < hydratedState.length; i++ ) {\n+\t\t\t\tfinal Object value = hydratedState[i];\n \t\t\t\tif ( debugEnabled ) {\n-\t\t\t\t\tLOG.debugf( \"Resolving <un-fetched> attribute : `%s`\", propertyNames[i] );\n+\t\t\t\t\tLOG.debugf(\n+\t\t\t\t\t\t\t\"Processing attribute `%s` : value = %s\",\n+\t\t\t\t\t\t\tpropertyNames[i],\n+\t\t\t\t\t\t\tvalue == LazyPropertyInitializer.UNFETCHED_PROPERTY ?\n+\t\t\t\t\t\t\t\t\t\"<un-fetched>\" :\n+\t\t\t\t\t\t\t\t\tvalue == PropertyAccessStrategyBackRefImpl.UNKNOWN ? \"<unknown>\" : value\n+\t\t\t\t\t);\n \t\t\t\t}\n \n-\t\t\t\t// IMPLEMENTATION NOTE: This is a lazy property on a bytecode-enhanced entity.\n-\t\t\t\t// hydratedState[i] needs to remain LazyPropertyInitializer.UNFETCHED_PROPERTY so that\n-\t\t\t\t// setPropertyValues() below (ultimately AbstractEntityTuplizer#setPropertyValues) works properly\n-\t\t\t\t// No resolution is necessary, unless the lazy property is a collection.\n-\t\t\t\tif ( types[i].isCollectionType() ) {\n-\t\t\t\t\t// IMPLEMENTATION NOTE: this is a lazy collection property on a bytecode-enhanced entity.\n-\t\t\t\t\t// HHH-10989: We need to resolve the collection so that a CollectionReference is added to StatefulPersistentContext.\n-\t\t\t\t\t// As mentioned above, hydratedState[i] needs to remain LazyPropertyInitializer.UNFETCHED_PROPERTY\n-\t\t\t\t\t// so do not assign the resolved, uninitialized PersistentCollection back to hydratedState[i].\n-\t\t\t\t\tBoolean overridingEager = getOverridingEager( session, entityName, propertyNames[i], types[i], debugEnabled );\n-\t\t\t\t\ttypes[i].resolve( value, session, entity, overridingEager );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\telse if ( value != PropertyAccessStrategyBackRefImpl.UNKNOWN ) {\n-\t\t\t\tif ( debugEnabled ) {\n-\t\t\t\t\tfinal boolean isLazyEnhanced = persister.getBytecodeEnhancementMetadata()\n-\t\t\t\t\t\t.getLazyAttributesMetadata()\n-\t\t\t\t\t\t.getLazyAttributeNames()\n-\t\t\t\t\t\t.contains( propertyNames[i] );\n-\t\t\t\t\tLOG.debugf( \"Attribute (`%s`)  - enhanced for lazy-loading? - %s\", propertyNames[i], isLazyEnhanced );\n+\t\t\t\tif ( value == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n+\t\t\t\t\tif ( debugEnabled ) {\n+\t\t\t\t\t\tLOG.debugf( \"Resolving <un-fetched> attribute : `%s`\", propertyNames[i] );\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// IMPLEMENTATION NOTE: This is a lazy property on a bytecode-enhanced entity.\n+\t\t\t\t\t// hydratedState[i] needs to remain LazyPropertyInitializer.UNFETCHED_PROPERTY so that\n+\t\t\t\t\t// setPropertyValues() below (ultimately AbstractEntityTuplizer#setPropertyValues) works properly\n+\t\t\t\t\t// No resolution is necessary, unless the lazy property is a collection.\n+\t\t\t\t\tif ( types[i].isCollectionType() ) {\n+\t\t\t\t\t\t// IMPLEMENTATION NOTE: this is a lazy collection property on a bytecode-enhanced entity.\n+\t\t\t\t\t\t// HHH-10989: We need to resolve the collection so that a CollectionReference is added to StatefulPersistentContext.\n+\t\t\t\t\t\t// As mentioned above, hydratedState[i] needs to remain LazyPropertyInitializer.UNFETCHED_PROPERTY\n+\t\t\t\t\t\t// so do not assign the resolved, uninitialized PersistentCollection back to hydratedState[i].\n+\t\t\t\t\t\tBoolean overridingEager = getOverridingEager(\n+\t\t\t\t\t\t\t\tsession,\n+\t\t\t\t\t\t\t\tentityName,\n+\t\t\t\t\t\t\t\tpropertyNames[i],\n+\t\t\t\t\t\t\t\ttypes[i],\n+\t\t\t\t\t\t\t\tdebugEnabled\n+\t\t\t\t\t\t);\n+\t\t\t\t\t\ttypes[i].resolve( value, session, entity, overridingEager );\n+\t\t\t\t\t}\n \t\t\t\t}\n+\t\t\t\telse if ( value != PropertyAccessStrategyBackRefImpl.UNKNOWN ) {\n+\t\t\t\t\tif ( debugEnabled ) {\n+\t\t\t\t\t\tfinal boolean isLazyEnhanced = persister.getBytecodeEnhancementMetadata()\n+\t\t\t\t\t\t\t\t.getLazyAttributesMetadata()\n+\t\t\t\t\t\t\t\t.getLazyAttributeNames()\n+\t\t\t\t\t\t\t\t.contains( propertyNames[i] );\n+\t\t\t\t\t\tLOG.debugf(\n+\t\t\t\t\t\t\t\t\"Attribute (`%s`)  - enhanced for lazy-loading? - %s\",\n+\t\t\t\t\t\t\t\tpropertyNames[i],\n+\t\t\t\t\t\t\t\tisLazyEnhanced\n+\t\t\t\t\t\t);\n+\t\t\t\t\t}\n \n-\t\t\t\t// we know value != LazyPropertyInitializer.UNFETCHED_PROPERTY\n-\t\t\t\tBoolean overridingEager = getOverridingEager( session, entityName, propertyNames[i], types[i], debugEnabled );\n-\t\t\t\thydratedState[i] = types[i].isEntityType()\n-\t\t\t\t\t\t? entityResolver.resolve( (EntityType) types[i], value, session, entity, overridingEager )\n-\t\t\t\t\t\t: types[i].resolve( value, session, entity, overridingEager );\n-\t\t\t}\n-\t\t\telse {\n-\t\t\t\tif ( debugEnabled ) {\n-\t\t\t\t\tLOG.debugf( \"Skipping <unknown> attribute : `%s`\", propertyNames[i] );\n+\t\t\t\t\t// we know value != LazyPropertyInitializer.UNFETCHED_PROPERTY\n+\t\t\t\t\tBoolean overridingEager = getOverridingEager(\n+\t\t\t\t\t\t\tsession,\n+\t\t\t\t\t\t\tentityName,\n+\t\t\t\t\t\t\tpropertyNames[i],\n+\t\t\t\t\t\t\ttypes[i],\n+\t\t\t\t\t\t\tdebugEnabled\n+\t\t\t\t\t);\n+\t\t\t\t\thydratedState[i] = types[i].isEntityType()\n+\t\t\t\t\t\t\t? entityResolver.resolve( (EntityType) types[i], value, session, entity, overridingEager )\n+\t\t\t\t\t\t\t: types[i].resolve( value, session, entity, overridingEager );\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tif ( debugEnabled ) {\n+\t\t\t\t\t\tLOG.debugf( \"Skipping <unknown> attribute : `%s`\", propertyNames[i] );\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t}\n \n-\t\t\tif ( session.getFetchGraphLoadContext() != fetchGraphContext ) {\n \t\t\t\tsession.setFetchGraphLoadContext( fetchGraphContext );\n \t\t\t}\n \t\t}\n+\t\tfinally {\n+\t\t\t// HHH-14097\n+\t\t\t// Fetch entity graph should be applied only once on top level (for root hydrated object)\n+\t\t\t// e.g., see org.hibernate.loader.Loader for details\n+\t\t\tsession.setFetchGraphLoadContext( null );", "originalCommit": null, "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI4OTk1NQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r450289955", "bodyText": "For non-toplevel traversal, Line #285 will take effect to backtrack to upper level after the above statement. The above statement will impact only top level (I made it explicitly by including \"on top level\" in the comments above). I admit the code change is difficult to understand for basically 'fetch graph' implementing is sort of based on hack (existing v5 infrastructure makes it difficult to implement elegantly), but v6 makes the implementation much easier and more elegant (it has well-designed context info accessible). After this PR gets merged, I'll port it into v6 to see whether the issue still remains.", "author": "NathanQingyangXu", "createdAt": "2020-07-06T15:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI3OTE2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTU3NDMyOA==", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r451574328", "bodyText": "I doubled checked and found the backtracking is working as expected (without it our graph testing cases would fail). Could you take a new look at this PR? Thanks.", "author": "NathanQingyangXu", "createdAt": "2020-07-08T14:09:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI3OTE2NA=="}], "type": "inlineReview"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": null, "url": null, "message": null, "committedDate": null, "type": "forcePushed"}, {"oid": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b", "url": "https://github.com/hibernate/hibernate-orm/commit/ee8244368eaab6c4df55bb2d4157ea15abb41a4b", "message": "HHH-14097 fix bug that redundant SQLs might be issued for 'FETCH' entity graph", "committedDate": "2020-07-07T13:17:04Z", "type": "commit"}, {"oid": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b", "url": "https://github.com/hibernate/hibernate-orm/commit/ee8244368eaab6c4df55bb2d4157ea15abb41a4b", "message": "HHH-14097 fix bug that redundant SQLs might be issued for 'FETCH' entity graph", "committedDate": "2020-07-07T13:17:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDg1NzU1NQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r450857555", "bodyText": "The above content was copied from v6's counterpart. Thought the basic explanation of the two types of entity graph modes is supposed to exist in v5 as well.\nGiven the content has existed in v6 already, we don't need to bother merging this part to v6 as well.", "author": "NathanQingyangXu", "createdAt": "2020-07-07T13:19:54Z", "path": "documentation/src/main/asciidoc/userguide/chapters/fetching/Fetching.adoc", "diffHunk": "@@ -188,8 +188,15 @@ In both cases, this resolves to exactly one database query to get all that infor\n [[fetching-strategies-dynamic-fetching-entity-graph]]\n === Dynamic fetching via JPA entity graph\n \n-JPA 2.1 introduced entity graphs so the application developer has more control over fetch plans.\n+JPA 2.1 introduced ``entity graph`` so the application developer has more control over fetch plans. It has two modes to choose from:\n \n+fetch graph:::\n+In this case, all attributes specified in the entity graph will be treated as FetchType.EAGER, and all attributes not specified will *ALWAYS* be treated as FetchType.LAZY.\n+\n+load graph:::\n+In this case, all attributes specified in the entity graph will be treated as FetchType.EAGER, but attributes not specified use their static mapping specification.\n+\n+Below is an `fetch graph` dynamic fetching example:", "originalCommit": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NTM3NQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r450985375", "bodyText": "just a minor but I think the session.setFetchGraphLoadContext( null ); is redundant", "author": "dreab8", "createdAt": "2020-07-07T16:16:54Z", "path": "hibernate-core/src/main/java/org/hibernate/engine/internal/TwoPhaseLoad.java", "diffHunk": "@@ -206,62 +206,91 @@ public static void initializeEntityEntryLoadedState(\n \t\tString entityName = persister.getEntityName();\n \t\tString[] propertyNames = persister.getPropertyNames();\n \t\tfinal Type[] types = persister.getPropertyTypes();\n-\t\t\n-\t\tfinal GraphImplementor<?> fetchGraphContext = session.getFetchGraphLoadContext();\n-\t\t\n-\t\tfor ( int i = 0; i < hydratedState.length; i++ ) {\n-\t\t\tfinal Object value = hydratedState[i];\n-\t\t\tif ( debugEnabled ) {\n-\t\t\t\tLOG.debugf(\n-\t\t\t\t\t\"Processing attribute `%s` : value = %s\",\n-\t\t\t\t\tpropertyNames[i],\n-\t\t\t\t\tvalue == LazyPropertyInitializer.UNFETCHED_PROPERTY ? \"<un-fetched>\" : value == PropertyAccessStrategyBackRefImpl.UNKNOWN ? \"<unknown>\" : value\n-\t\t\t\t);\n-\t\t\t}\n \n-\t\t\tif ( value == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {\n+\t\tGraphImplementor fetchGraphContext = session.getFetchGraphLoadContext();\n+\t\tif ( fetchGraphContext != null && !fetchGraphContext.appliesTo( entity.getClass() ) ) {\n+\t\t\tLOG.warnf( \"Entity graph specified is not applicable to the entity [%s]. Ignored.\", entity);\n+\t\t\tfetchGraphContext = null;\n+\t\t\tsession.setFetchGraphLoadContext( null );", "originalCommit": "ee8244368eaab6c4df55bb2d4157ea15abb41a4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTA1MDE0NQ==", "url": "https://github.com/hibernate/hibernate-orm/pull/3453#discussion_r451050145", "bodyText": "I think it is necessary because without setting it, the downstream will still try to locate some property as per the context grabbed from session.getFetchGraphLoadContext(), not from the local variable of fetchGraphContext. See the org.hibernate.engine.internal.TwoPhaseLoad#isEagerFetchGraph(SharedSessionContractImplementor session, String associationName, Type associationType) for details.\nI am sorry the current fetch entity graph implementation is so difficult to understand (and maintain). Luckily its status is improved much more in v6.", "author": "NathanQingyangXu", "createdAt": "2020-07-07T18:06:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk4NTM3NQ=="}], "type": "inlineReview"}]}