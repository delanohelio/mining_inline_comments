{"pr_number": 9502, "pr_title": "Add implementation for returning clause for update-by-query usecase to storage engine", "pr_createdAt": "2020-01-13T08:54:56Z", "pr_url": "https://github.com/crate/crate/pull/9502", "timeline": [{"oid": "5c3d2dbad1ec8aa44a4d9a273bef2b6be285f868", "url": "https://github.com/crate/crate/commit/5c3d2dbad1ec8aa44a4d9a273bef2b6be285f868", "message": "Merge all result row logic into ShardDMLExecutor", "committedDate": "2020-01-13T08:57:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2MzA4NQ==", "url": "https://github.com/crate/crate/pull/9502#discussion_r365763085", "bodyText": "I am not really happy with this solution, it smells like MultiActionListener in a bad way. but it is still better than moving 8 lambdas around. Any good idea here ? Could be of course also just an interface with 2 implementation for each result type.", "author": "mkleen", "createdAt": "2020-01-13T11:48:03Z", "path": "sql/src/main/java/io/crate/execution/engine/indexing/ShardDMLExecutor.java", "diffHunk": "@@ -155,12 +160,78 @@ private static String getLocalNodeId(ClusterService clusterService) {\n         return nodeId;\n     }\n \n-    private static long processShardResponse(ShardResponse shardResponse) {\n+    private static List<Object[]> intialResultRows() {\n+        return new ArrayList<>();\n+    }\n+\n+    private static long initialRowCount() {\n+        return 0L;\n+    }\n+\n+    private static long processRowCount(ShardResponse shardResponse) {\n+        return processResponse(shardResponse, ShardResponse::successRowCount);\n+    }\n+\n+    private static long combineRowCounts(long a, long b) {\n+        return a + b;\n+    }\n+\n+    private static Iterable<Row> finishRowCount(Long rowCount) {\n+        return Collections.singletonList(new Row1(rowCount == null ? 0L : rowCount));\n+    }\n+\n+    private static List<Object[]> combineResultRows(List<Object[]> a, List<Object[]> b) {\n+        var result = new ArrayList<Object[]>();\n+        result.addAll(a);\n+        result.addAll(b);\n+        return result;\n+    }\n+\n+    private static Iterable<Row> finishResultRows(List<Object[]> result) {\n+        return Lists2.map(result, RowN::new);\n+    }\n+\n+    private static List<Object[]> processResulRows(ShardResponse shardResponse) {\n+        return processResponse(shardResponse, ShardResponse::getResultRows);\n+    }\n+\n+    private static <A> A processResponse(ShardResponse shardResponse, Function<ShardResponse, A> f) {\n         Exception failure = shardResponse.failure();\n         if (failure != null) {\n             Throwables.throwIfUnchecked(failure);\n             throw new RuntimeException(failure);\n         }\n-        return shardResponse.successRowCount();\n+        return f.apply(shardResponse);\n+    }\n+\n+    public static final ResultProcessing<Long> ROW_COUNT_PROCESSING = new ResultProcessing<>(\n+        ShardDMLExecutor.initialRowCount(),\n+        ShardDMLExecutor::processRowCount,\n+        ShardDMLExecutor::combineRowCounts,\n+        ShardDMLExecutor::finishRowCount\n+    );\n+\n+    public static final ResultProcessing<List<Object[]>> RESULT_ROW_PROCESSING = new ResultProcessing<>(\n+        ShardDMLExecutor.intialResultRows(),\n+        ShardDMLExecutor::processResulRows,\n+        ShardDMLExecutor::combineResultRows,\n+        ShardDMLExecutor::finishResultRows\n+    );\n+\n+    public static class ResultProcessing<Result> {", "originalCommit": "ffb5aecb8d7a030aeb8a13bc34ae0e47c2ae0c1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDMyNQ==", "url": "https://github.com/crate/crate/pull/9502#discussion_r365764325", "bodyText": "I don't like it, to return a value of a super class when the current value is null. One solution would be to not extend from DMLProjection and just handle the return types accordingly here.", "author": "mkleen", "createdAt": "2020-01-13T11:51:23Z", "path": "sql/src/main/java/io/crate/execution/dsl/projection/UpdateProjection.java", "diffHunk": "@@ -118,6 +136,14 @@ public ProjectionType projectionType() {\n         return visitor.visitUpdateProjection(this, context);\n     }\n \n+    @Override\n+    public List<? extends Symbol> outputs() {\n+        if (output == null) {\n+            return super.outputs();", "originalCommit": "ffb5aecb8d7a030aeb8a13bc34ae0e47c2ae0c1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc5MDAwMA==", "url": "https://github.com/crate/crate/pull/9502#discussion_r365790000", "bodyText": "+1 for not extending DMLProjection", "author": "mfussenegger", "createdAt": "2020-01-13T12:59:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2NDMyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc2OTg4MQ==", "url": "https://github.com/crate/crate/pull/9502#discussion_r365769881", "bodyText": "My bad, stupid copy paste bug from my last pr.", "author": "mkleen", "createdAt": "2020-01-13T12:06:31Z", "path": "sql/src/main/java/io/crate/execution/dsl/projection/UpdateProjection.java", "diffHunk": "@@ -82,11 +93,18 @@ public UpdateProjection(StreamInput in) throws IOException {\n         if (allOn4_1) {\n             int returnValuesSize = in.readVInt();\n             if (returnValuesSize > 0) {\n-                returnValues = new Symbol[assignmentsSize];", "originalCommit": "ffb5aecb8d7a030aeb8a13bc34ae0e47c2ae0c1f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc5MTAzOA==", "url": "https://github.com/crate/crate/pull/9502#discussion_r365791038", "bodyText": "In most cases we put the responsibility to built the InputColumn symbols to who-ever is creating the projection and then add an assertion that the symbols in the arguments must not contain Field/Reference. See FilterProjection for an example.", "author": "mfussenegger", "createdAt": "2020-01-13T13:01:35Z", "path": "sql/src/main/java/io/crate/execution/dsl/projection/UpdateProjection.java", "diffHunk": "@@ -48,14 +53,20 @@ public UpdateProjection(Symbol uidSymbol,\n                             Symbol[] assignments,\n                             Version version,\n                             @Nullable Symbol[] returnValues,\n+                            @Nullable Field[] output,\n                             @Nullable Long requiredVersion) {\n         super(uidSymbol);\n         this.assignmentsColumns = assignmentsColumns;\n         this.assignments = assignments;\n         this.allOn4_1 = version.onOrAfter(Version.V_4_1_0);\n         this.returnValues = returnValues;\n+        if (output != null) {\n+            this.output = new Symbol[output.length];\n+            for (int i = 0; i < output.length; i++) {\n+                this.output[i] = (new InputColumn(i, output[i].valueType()));", "originalCommit": "ada60739fb425e5470fc794c8f39f15aa3b017a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc5MTg5Mw==", "url": "https://github.com/crate/crate/pull/9502#discussion_r365791893", "bodyText": "This looks very much like a java.util.stream.Collector, could we maybe utilize something there?", "author": "mfussenegger", "createdAt": "2020-01-13T13:03:48Z", "path": "sql/src/main/java/io/crate/execution/engine/indexing/ShardDMLExecutor.java", "diffHunk": "@@ -155,12 +160,78 @@ private static String getLocalNodeId(ClusterService clusterService) {\n         return nodeId;\n     }\n \n-    private static long processShardResponse(ShardResponse shardResponse) {\n+    private static List<Object[]> intialResultRows() {\n+        return new ArrayList<>();\n+    }\n+\n+    private static long initialRowCount() {\n+        return 0L;\n+    }\n+\n+    private static long processRowCount(ShardResponse shardResponse) {\n+        return processResponse(shardResponse, ShardResponse::successRowCount);\n+    }\n+\n+    private static long combineRowCounts(long a, long b) {\n+        return a + b;\n+    }\n+\n+    private static Iterable<Row> finishRowCount(Long rowCount) {\n+        return Collections.singletonList(new Row1(rowCount == null ? 0L : rowCount));\n+    }\n+\n+    private static List<Object[]> combineResultRows(List<Object[]> a, List<Object[]> b) {\n+        var result = new ArrayList<Object[]>();\n+        result.addAll(a);\n+        result.addAll(b);\n+        return result;\n+    }\n+\n+    private static Iterable<Row> finishResultRows(List<Object[]> result) {\n+        return Lists2.map(result, RowN::new);\n+    }\n+\n+    private static List<Object[]> processResulRows(ShardResponse shardResponse) {\n+        return processResponse(shardResponse, ShardResponse::getResultRows);\n+    }\n+\n+    private static <A> A processResponse(ShardResponse shardResponse, Function<ShardResponse, A> f) {\n         Exception failure = shardResponse.failure();\n         if (failure != null) {\n             Throwables.throwIfUnchecked(failure);\n             throw new RuntimeException(failure);\n         }\n-        return shardResponse.successRowCount();\n+        return f.apply(shardResponse);\n+    }\n+\n+    public static final ResultProcessing<Long> ROW_COUNT_PROCESSING = new ResultProcessing<>(\n+        ShardDMLExecutor.initialRowCount(),\n+        ShardDMLExecutor::processRowCount,\n+        ShardDMLExecutor::combineRowCounts,\n+        ShardDMLExecutor::finishRowCount\n+    );\n+\n+    public static final ResultProcessing<List<Object[]>> RESULT_ROW_PROCESSING = new ResultProcessing<>(\n+        ShardDMLExecutor.intialResultRows(),\n+        ShardDMLExecutor::processResulRows,\n+        ShardDMLExecutor::combineResultRows,\n+        ShardDMLExecutor::finishResultRows\n+    );\n+\n+    public static class ResultProcessing<Result> {", "originalCommit": "ada60739fb425e5470fc794c8f39f15aa3b017a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc5NzQ5MQ==", "url": "https://github.com/crate/crate/pull/9502#discussion_r365797491", "bodyText": "Great hint \ud83d\udc4d", "author": "mkleen", "createdAt": "2020-01-13T13:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc5MTg5Mw=="}], "type": "inlineReview"}, {"oid": "9cccb9dbfd1cf7a25b0fbc132a0d3a73af70ff42", "url": "https://github.com/crate/crate/commit/9cccb9dbfd1cf7a25b0fbc132a0d3a73af70ff42", "message": "Clean up types on ShardDMLExecutor", "committedDate": "2020-01-14T14:10:33Z", "type": "forcePushed"}, {"oid": "68046c09adb835a738898c4e5805093be7cbfd5d", "url": "https://github.com/crate/crate/commit/68046c09adb835a738898c4e5805093be7cbfd5d", "message": "Clean up types on ShardDMLExecutor", "committedDate": "2020-01-14T14:16:16Z", "type": "forcePushed"}, {"oid": "3c8ee76b047f9c938e26a1e5102834b411c02a92", "url": "https://github.com/crate/crate/commit/3c8ee76b047f9c938e26a1e5102834b411c02a92", "message": "Make outputs nullable", "committedDate": "2020-01-16T14:42:39Z", "type": "forcePushed"}, {"oid": "a1f9b82f0069a161f19ef3cf14bfe3fca4e81958", "url": "https://github.com/crate/crate/commit/a1f9b82f0069a161f19ef3cf14bfe3fca4e81958", "message": "Make outputs nullable", "committedDate": "2020-01-16T14:47:25Z", "type": "forcePushed"}, {"oid": "73fcc91d5caf75c2dd28ca446975859414957ad1", "url": "https://github.com/crate/crate/commit/73fcc91d5caf75c2dd28ca446975859414957ad1", "message": "Make outputs nullable", "committedDate": "2020-01-16T15:02:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NTAyMw==", "url": "https://github.com/crate/crate/pull/9502#discussion_r367845023", "bodyText": "I think it would be possible to use CollectionBucket here to avoid the copy operation.", "author": "mfussenegger", "createdAt": "2020-01-17T09:39:31Z", "path": "sql/src/main/java/io/crate/execution/engine/indexing/ShardDMLExecutor.java", "diffHunk": "@@ -155,12 +166,41 @@ private static String getLocalNodeId(ClusterService clusterService) {\n         return nodeId;\n     }\n \n-    private static long processShardResponse(ShardResponse shardResponse) {\n+    private static <A> A processResponse(ShardResponse shardResponse, Function<ShardResponse, A> f) {\n         Exception failure = shardResponse.failure();\n         if (failure != null) {\n             Throwables.throwIfUnchecked(failure);\n             throw new RuntimeException(failure);\n         }\n-        return shardResponse.successRowCount();\n+        return f.apply(shardResponse);\n+    }\n+\n+    private static Long toRowCount(ShardResponse shardResponse) {\n+        return Long.valueOf(processResponse(shardResponse, ShardResponse::successRowCount));\n+    }\n+\n+    private static List<Object[]> toResultRows(ShardResponse shardResponse) {\n+        List<Object[]> result = processResponse(shardResponse, ShardResponse::getResultRows);\n+        return result == null ? List.of() : result;\n     }\n+\n+    public static final Collector<ShardResponse, long[], Iterable<Row>> ROW_COUNT_COLLECTOR = Collector.of(\n+        () -> new long[]{0L},\n+        (a, b) -> a[0] += toRowCount(b),\n+        (a, b) -> {\n+            a[0] += b[0];\n+            return a;\n+        },\n+        a -> List.of(new Row1(a[0]))\n+    );\n+\n+    public static final Collector<ShardResponse, List<Object[]>, Iterable<Row>> RESULT_ROW_COLLECTOR = Collector.of(\n+        ArrayList::new,\n+        (a, b) -> a.addAll(toResultRows(b)),\n+        (a, b) -> {\n+            a.addAll(b);\n+            return a;\n+        },\n+        a -> Lists2.map(a, RowN::new)", "originalCommit": "4133de61bb48c67288ff4ea89ed995c79963fa64", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg0NTg2MA==", "url": "https://github.com/crate/crate/pull/9502#discussion_r367845860", "bodyText": "Maybe we could also add _seq_no or so to the RETURNING clause here. As that is one of the use cases we want to enable", "author": "mfussenegger", "createdAt": "2020-01-17T09:41:26Z", "path": "sql/src/test/java/io/crate/integrationtests/UpdateIntegrationTest.java", "diffHunk": "@@ -943,4 +944,52 @@ public void test_update_by_id_where_no_row_is_matching() throws Exception {\n         assertThat(response.cols()[0], is(\"id\"));\n         assertThat(response.rowCount(), is(0L));\n     }\n+\n+    @Test\n+    public void test_update_by_query_returning_single_field_with_outputputname() throws Exception {\n+        execute(\"create table test (id int primary key, message string) clustered into 2 shards\");\n+        execute(\"insert into test values(1, 'msg');\");\n+        assertEquals(1, response.rowCount());\n+        refresh();\n+\n+        execute(\"update test set message='updated' where message='msg' returning message as message_renamed\");\n+\n+        assertThat((response.rowCount()), is(1L));\n+        assertThat((response.cols()[0]), is(\"message_renamed\"));\n+        assertThat(response.rows()[0][0], is(\"updated\"));\n+    }\n+\n+\n+    @Test\n+    public void test_update_by_query_with_subquery_returning_multiple_fields() throws Exception {\n+        execute(\"create table test (id int primary key, message string) clustered into 2 shards\");\n+        execute(\"insert into test values(1, 'msg');\");\n+        assertEquals(1, response.rowCount());\n+        refresh();\n+\n+        execute(\"update test set message='updated' where message= (select 'msg') returning id, message\");\n+\n+        assertThat((response.rowCount()), is(1L));\n+        assertThat((response.cols()[0]), is(\"id\"));\n+        assertThat((response.cols()[1]), is(\"message\"));\n+        assertThat(response.rows()[0][0], is(1));\n+        assertThat(response.rows()[0][1], is(\"updated\"));\n+\n+    }\n+\n+    @Test\n+    public void test_update_by_query_returning_multiple_results() throws Exception {\n+        execute(\"create table test (id int primary key, x int, message string) clustered into 2 shards\");\n+        execute(\"insert into test values(1, 1, 'msg');\");\n+        execute(\"insert into test values(2, 1, 'msg');\");\n+        assertEquals(1, response.rowCount());\n+        refresh();\n+\n+        execute(\"update test set message='updated' where message='msg' and x > 0 returning message as message_renamed\");", "originalCommit": "4133de61bb48c67288ff4ea89ed995c79963fa64", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg5MTAwMw==", "url": "https://github.com/crate/crate/pull/9502#discussion_r367891003", "bodyText": "Shouldn't this be > 0, as _seq_no starts out at 0 initially?", "author": "mfussenegger", "createdAt": "2020-01-17T11:27:11Z", "path": "sql/src/test/java/io/crate/integrationtests/UpdateIntegrationTest.java", "diffHunk": "@@ -985,11 +985,20 @@ public void test_update_by_query_returning_multiple_results() throws Exception {\n         assertEquals(1, response.rowCount());\n         refresh();\n \n-        execute(\"update test set message='updated' where message='msg' and x > 0 returning message as message_renamed\");\n+        execute(\"update test set message='updated' where message='msg' and x > 0 \" +\n+                \"returning _docid, _seq_no as seq, message as message_renamed\");\n \n-        assertThat((response.rowCount()), is(2L ));\n-        assertThat((response.cols()[0]), is(\"message_renamed\"));\n-        assertThat(response.rows()[0][0], is(\"updated\"));\n-        assertThat(response.rows()[1][0], is(\"updated\"));\n+        assertThat((response.rowCount()), is(2L));\n+        assertThat((response.cols()[0]), is(\"_docid\"));\n+        assertThat((response.cols()[1]), is(\"seq\"));\n+        assertThat((response.cols()[2]), is(\"message_renamed\"));\n+\n+        assertThat(response.rows()[0][0], is(0));\n+        assertThat(response.rows()[0][1], is(0L));", "originalCommit": "0b39d14915c5259eac9875afbd6c6db0adcaa7e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg5MzkxMw==", "url": "https://github.com/crate/crate/pull/9502#discussion_r367893913", "bodyText": "Good point and nice catch. The return values are actually generated before, the seq_no is incremented which is wrong. This is needs to be fixed. Thank you!", "author": "mkleen", "createdAt": "2020-01-17T11:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg5MTAwMw=="}], "type": "inlineReview"}, {"oid": "76bf2c78066dac7635e0e8f6a2bf0f32bd17489f", "url": "https://github.com/crate/crate/commit/76bf2c78066dac7635e0e8f6a2bf0f32bd17489f", "message": "Fix seq_no/version processing for return values", "committedDate": "2020-01-17T14:47:01Z", "type": "forcePushed"}, {"oid": "e89e79501860d66f163102c2020795670eb90615", "url": "https://github.com/crate/crate/commit/e89e79501860d66f163102c2020795670eb90615", "message": "Add implementation for update-by-query usecase to storage engine", "committedDate": "2020-01-17T15:20:32Z", "type": "commit"}, {"oid": "e89e79501860d66f163102c2020795670eb90615", "url": "https://github.com/crate/crate/commit/e89e79501860d66f163102c2020795670eb90615", "message": "Add implementation for update-by-query usecase to storage engine", "committedDate": "2020-01-17T15:20:32Z", "type": "forcePushed"}]}