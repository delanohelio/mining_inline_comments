{"pr_number": 10147, "pr_title": "Make sure there is an entry in pg_proc for each pg_type typreceive", "pr_createdAt": "2020-06-29T12:37:03Z", "pr_url": "https://github.com/crate/crate/pull/10147", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NDU3Ng==", "url": "https://github.com/crate/crate/pull/10147#discussion_r446954576", "bodyText": "Are you sure about all the types? I've added this check coz some types, like any (maybe it is actually the only type) don't have typreceive,  typoutput, and typinput. See\ntemplate1=# select typreceive from pg_type where oid = 2276;\n typreceive\n------------\n -\n(1 row)", "author": "kovrus", "createdAt": "2020-06-29T13:04:38Z", "path": "server/src/main/java/io/crate/metadata/pgcatalog/PgTypeTable.java", "diffHunk": "@@ -64,31 +62,10 @@\n             .add(\"typtypmod\", INTEGER, c -> -1)\n             .add(\"typnamespace\", INTEGER, c -> TYPE_NAMESPACE_OID)\n             .add(\"typarray\", INTEGER, PGType::typArray)\n-            .add(\"typinput\", REGPROC, t -> {\n-                if (t.typArray() == 0) {\n-                    return Regproc.of(\"array_in\");\n-                } else {\n-                    return regprocForMetaFunction(t, \"_in\");\n-                }\n-            })\n-            .add(\"typoutput\", REGPROC, t -> {\n-                if (t.typArray() == 0) {\n-                    return Regproc.of(\"array_out\");\n-                } else {\n-                    return regprocForMetaFunction(t, \"_out\");\n-                }\n-            })\n-            .add(\"typreceive\", REGPROC, t -> regprocForMetaFunction(t, \"recv\"))\n+            .add(\"typinput\", REGPROC, PGType::typInput)\n+            .add(\"typoutput\", REGPROC, PGType::typOutput)\n+            .add(\"typreceive\", REGPROC, PGType::typReceive)\n             .add(\"typnotnull\", BOOLEAN, c -> false)\n             .build();\n     }\n-\n-    private static Regproc regprocForMetaFunction(PGType<?> type,\n-                                                  String suffix) {\n-        if (PGTypes.fromOID(type.oid()) != null) {", "originalCommit": "badccd716ca7dffd249e02fff2f5d684a291488c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk2MjQxNA==", "url": "https://github.com/crate/crate/pull/10147#discussion_r446962414", "bodyText": "Good point. I added a fixup.", "author": "mfussenegger", "createdAt": "2020-06-29T13:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njk1NjI2OQ==", "url": "https://github.com/crate/crate/pull/10147#discussion_r446956269", "bodyText": "\ud83d\udc4d\nlgtm", "author": "kovrus", "createdAt": "2020-06-29T13:07:15Z", "path": "server/src/main/java/io/crate/execution/engine/collect/sources/InformationSchemaIterables.java", "diffHunk": "@@ -160,21 +162,40 @@ public InformationSchemaIterables(final Schemas schemas,\n             .flatMap(List::stream)\n             .map(this::pgProc)\n             .iterator();\n-        pgTypeReceiveFunctions = () -> sequentialStream(PGTypes.pgTypes())\n-            .filter(pgType -> PGTypes.fromOID(pgType.oid()) != null)\n-            .map(\n-                type -> Signature.scalar(\n-                    type.typName() + \"recv\",\n-                    Objects.requireNonNullElse(\n-                        PGTypes.fromOID(type.oid()),\n-                        DataTypes.UNDEFINED\n-                    ).getTypeSignature()\n+\n+        pgTypeReceiveFunctions = () ->\n+            Stream.concat(\n+                sequentialStream(PGTypes.pgTypes())\n+                    .filter(t -> t.typArray() != 0)\n+                    .map(InformationSchemaIterables::typeToSignature)\n+                    .map(PgProcTable.Entry::of),\n+\n+                // Don't generate array_recv entry from pgTypes to avoid duplicate entries\n+                // (We want 1 array_recv entry, not one per array type)", "originalCommit": "8e2912c278436d1a974a822532615097b2452d80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "40af2f92b2032ae14f5ed1d7b9aa476f3a0a6c17", "url": "https://github.com/crate/crate/commit/40af2f92b2032ae14f5ed1d7b9aa476f3a0a6c17", "message": "fixup! fixup! Make sure there is an entry in pg_proc for each pg_type typreceive", "committedDate": "2020-06-29T13:16:53Z", "type": "forcePushed"}, {"oid": "1b21eaa7399bd85d68e29a53eb545172be4d4670", "url": "https://github.com/crate/crate/commit/1b21eaa7399bd85d68e29a53eb545172be4d4670", "message": "Make sure there is an entry in pg_proc for each pg_type typreceive\n\nEach pg_type entry must be able to join with an entry in pg_proc for\nclients like npgsql.\n\n(Except arrays, they've a generic `array_recv` value)", "committedDate": "2020-06-29T13:20:39Z", "type": "commit"}, {"oid": "1b21eaa7399bd85d68e29a53eb545172be4d4670", "url": "https://github.com/crate/crate/commit/1b21eaa7399bd85d68e29a53eb545172be4d4670", "message": "Make sure there is an entry in pg_proc for each pg_type typreceive\n\nEach pg_type entry must be able to join with an entry in pg_proc for\nclients like npgsql.\n\n(Except arrays, they've a generic `array_recv` value)", "committedDate": "2020-06-29T13:20:39Z", "type": "forcePushed"}]}