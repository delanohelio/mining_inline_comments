{"pr_number": 10268, "pr_title": "Fix performance regression; execute ORDER BY w/o LIMIT with QTF", "pr_createdAt": "2020-07-23T12:15:12Z", "pr_url": "https://github.com/crate/crate/pull/10268", "timeline": [{"oid": "0943cd5c3c683ab12a283cee1d884a329752a996", "url": "https://github.com/crate/crate/commit/0943cd5c3c683ab12a283cee1d884a329752a996", "message": "Fix performance regression; execute ORDER BY w/o LIMIT with QTF\n\nIn theory a normal `Order -> Collect` should be just as fast or faster\nthan a `Fetch -> Order -> Collect`, but it turns out that due to how\ncurrently the sorted merge, it is more expensive on a full row than a\nnarrow row with just the fetch id.\n\nPart of the reason is that the `*SortedMergeIterator` implementations\nuse a `peek`, which triggers multiple evaluations of a `Row`. For\nexample the `apply` of the `ScoreDocRowFunction` is called multiple\ntimes.\n\nFixing this in the execution layer may be a bit more involved, so this\napplies the fetch-rewrite also to some more patterns.\n\n    V1: 4.3.0-d162b7a8731762aacd4bdfcf6df20e6342ed6154\n    V2: 4.3.0-1ed3aa43bd5cd671fc332fbcc8c7432671a3b48b\n\n    Q: select * from uservisits where \"searchWord\" = 'hardnose' order by \"visitDate\" desc\n    C: 1\n    | Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n    |   V1    |      265.018 \u00b1   21.618 |    222.775 |    262.301 |    271.916 |    641.156 |\n    |   V2    |       55.767 \u00b1   23.288 |     45.291 |     52.272 |     58.345 |    552.883 |\n    \u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n    |               - 130.46%                           - 133.53%\n    There is a 100.00% probability that the observed difference is not random, and the best estimate of that difference is 130.46%\n    The test has statistical significance\n\n    System/JVM Metrics (durations in ms, byte-values in MB)\n        |    YOUNG GC            |       OLD GC           |      HEAP         |     ALLOC\n        |  cnt      avg      max |  cnt      avg      max |  initial     used |     rate      total\n     V1 |  504     4.28     3.93 |  490    43.76    45.05 |     2147      387 |   751.03     103980\n     V2 |   37     6.19     5.45 |   27    45.51    44.09 |     2147      800 |   823.33      27122\n\n(The ~55 mean here is about the same we had in 4.1)", "committedDate": "2020-07-23T12:14:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQwNDkyMg==", "url": "https://github.com/crate/crate/pull/10268#discussion_r459404922", "bodyText": "If the Eval operator dropped columns we still need it, otherwise a parent Rename may fail because it expects the same amount of outputs.", "author": "mfussenegger", "createdAt": "2020-07-23T12:16:48Z", "path": "server/src/main/java/io/crate/planner/operators/Eval.java", "diffHunk": "@@ -108,14 +112,20 @@ public FetchRewrite rewriteToFetch(TableStats tableStats, Collection<Symbol> use\n         if (fetchRewrite == null) {\n             return null;\n         }\n+        LogicalPlan newSource = fetchRewrite.newPlan();\n         Function<Symbol, Symbol> mapToFetchStubs = fetchRewrite.mapToFetchStubs();\n         LinkedHashMap<Symbol, Symbol> newReplacedOutputs = new LinkedHashMap<>();\n+        ArrayList<Symbol> newOutputs = new ArrayList<>();\n+        for (Symbol sourceOutput : newSource.outputs()) {\n+            if (sourceOutput instanceof FetchMarker) {\n+                newOutputs.add(sourceOutput);\n+            }\n+        }\n         for (Symbol output : outputs) {\n             newReplacedOutputs.put(output, mapToFetchStubs.apply(output));\n+            SymbolVisitors.intersection(output, newSource.outputs(), newOutputs::add);\n         }\n-        // Skip the Eval operator,\n-        // the evaluations that the `Eval` operator took care of are now part of the replacedOutputs.", "originalCommit": "0943cd5c3c683ab12a283cee1d884a329752a996", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}