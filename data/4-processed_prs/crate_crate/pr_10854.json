{"pr_number": 10854, "pr_title": "Add the numeric data type and numeric sum aggregation. ", "pr_createdAt": "2020-12-07T17:58:06Z", "pr_url": "https://github.com/crate/crate/pull/10854", "timeline": [{"oid": "d75f842a0489e90c744dd2efd07483da3b00de5f", "url": "https://github.com/crate/crate/commit/d75f842a0489e90c744dd2efd07483da3b00de5f", "message": "Add documentation for the numeric type and numeric sum aggreagtion.", "committedDate": "2020-12-08T11:16:48Z", "type": "forcePushed"}, {"oid": "aacd0285dc2245fe4e013997e631cdcf9c86d029", "url": "https://github.com/crate/crate/commit/aacd0285dc2245fe4e013997e631cdcf9c86d029", "message": "Add documentation for the numeric type and numeric sum aggreagtion.", "committedDate": "2020-12-08T14:20:10Z", "type": "forcePushed"}, {"oid": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0", "url": "https://github.com/crate/crate/commit/2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0", "message": "Add documentation for the numeric type and numeric sum aggreagtion.", "committedDate": "2020-12-08T14:54:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzMTMwOA==", "url": "https://github.com/crate/crate/pull/10854#discussion_r538531308", "bodyText": "doesn't this fail if input is a InputColumn symbol?\nI also don't completely get why the changes in this class are related/needed...", "author": "seut", "createdAt": "2020-12-08T15:56:53Z", "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesAggregates.java", "diffHunk": "@@ -134,20 +134,51 @@\n \n     @Nullable\n     private static MappedFieldType resolveInputToFieldType(FieldTypeLookup fieldTypeLookup,\n-                                                           List<Symbol> toCollect,\n                                                            Symbol input) {\n-        if (!(input instanceof InputColumn)) {\n+        MappedFieldType mappedFieldType = fieldTypeLookup.get(((Reference) input).column().fqn());", "originalCommit": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgwODEzNQ==", "url": "https://github.com/crate/crate/pull/10854#discussion_r538808135", "bodyText": "To make it possible to get a doc values aggregator for cases like sum(long_column::numeric).\nThe aggregation, in this case, will be a cast function symbol with the numeric value type,\nso it would not be possible to resolve DocValueAggregator later on because we would try to get it for the wrong type that is not in the list of to collect symbols. Therefore, if we face the cast function we have to visit its argument and apply the logic we had before, checking if it is a reference or input column symbol. See https://github.com/crate/crate/pull/10854/files#diff-f655e047f75c5f53c3c464715b73f94c02b3fa19f62209ea606a4f3d9cfec7d8R163-R169", "author": "kovrus", "createdAt": "2020-12-08T21:07:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzMTMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NDAxMw==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539074013", "bodyText": "Ah I see, function traversal is needed, but isn't this already required on the master when doing something like sum(long_column::int)? Looks like a bugfix, not?\nOther than that, I still think that the logic is a bit shaky as with the new ReferenceOrInputColumnSymbolExtractor theoretically a InputColumn is returned while this function resolveInputToFieldType is requiring a Reference.\nIf we expect the return type to be a Reference (which is afaik always the case) we should make that clear inside the code and fail on everything else.", "author": "seut", "createdAt": "2020-12-09T07:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzMTMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE0NTgwMA==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539145800", "bodyText": "Ah I see, function traversal is needed, but isn't this already required on the master when doing something like sum(long_column::int)? Looks like a bugfix, not?\n\nYou are right, it is the case on the master already. Maybe I'll extract this part and make a PR against master, but not sure whether it is a bug because the doc values optimization is not just applied in that case, nothing gets broken.\n\nOther than that, I still think that the logic is a bit shaky as with the new ReferenceOrInputColumnSymbolExtractor theoretically a InputColumn is returned while this function resolveInputToFieldType is requiring a Reference.\n\nAgree \ud83d\udc4d  will refine that", "author": "kovrus", "createdAt": "2020-12-09T09:29:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzMTMwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI5NDY1Mg==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539294652", "bodyText": "Ah I see, function traversal is needed, but isn't this already required on the master when doing something like sum(long_column::int)? Looks like a bugfix, not?\n\nit is not a bug on, master. this case is not implemented, I'll add just a support it for the numeric cast only. I'll try to follow up on it on this week.", "author": "kovrus", "createdAt": "2020-12-09T13:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzMTMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU0MDExNQ==", "url": "https://github.com/crate/crate/pull/10854#discussion_r538540115", "bodyText": "why not calling .setScale on the original value?", "author": "seut", "createdAt": "2020-12-08T16:04:39Z", "path": "server/src/main/java/io/crate/types/NumericType.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import io.crate.common.annotations.VisibleForTesting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class NumericType extends DataType<BigDecimal> implements Streamer<BigDecimal> {\n+\n+    public static final int ID = 22;\n+    public static final NumericType INSTANCE = new NumericType(null, null); // unscaled\n+\n+    public static NumericType of(int precision) {\n+        return new NumericType(precision, null);\n+    }\n+\n+    public static NumericType of(int precision, int scale) {\n+        return new NumericType(precision, scale);\n+    }\n+\n+    public static DataType<?> of(List<Integer> parameters) {\n+        if (parameters.isEmpty() || parameters.size() > 2) {\n+            throw new IllegalArgumentException(\n+                \"The numeric type support one or two parameter arguments, received: \" +\n+                parameters.size()\n+            );\n+        }\n+        if (parameters.size() == 1) {\n+            return of(parameters.get(0));\n+        } else {\n+            return of(parameters.get(0), parameters.get(1));\n+        }\n+    }\n+\n+    private final Integer scale;\n+    private final Integer precision;\n+\n+    private NumericType(Integer precision, Integer scale) {\n+        this.precision = precision;\n+        this.scale = scale;\n+    }\n+\n+    public NumericType(StreamInput in) throws IOException {\n+        this.precision = in.readOptionalVInt();\n+        this.scale = in.readOptionalVInt();\n+    }\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.NUMERIC;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"numeric\";\n+    }\n+\n+    @Override\n+    public Streamer<BigDecimal> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public BigDecimal implicitCast(Object value) throws IllegalArgumentException, ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        var mathContext = mathContextOrDefault();\n+        if (value instanceof BigDecimal) {\n+            return new BigDecimal(\n+                ((BigDecimal) value).toBigInteger(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());", "originalCommit": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgxMDgzOQ==", "url": "https://github.com/crate/crate/pull/10854#discussion_r538810839", "bodyText": "We also have to set the precision, it is done via the math context.\nIf we set the scale on the original value, smth like that might result in an incorrect result\n('some value'::numeric(16))::numeric(4, 2)", "author": "kovrus", "createdAt": "2020-12-08T21:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU0MDExNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NTc0OQ==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539075749", "bodyText": "Ah right, I missed the precision part via the math context. Thanks for the explanation.", "author": "seut", "createdAt": "2020-12-09T07:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU0MDExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU0MTYxNw==", "url": "https://github.com/crate/crate/pull/10854#discussion_r538541617", "bodyText": "why is the intermediate BigInteger used here instead of passing the string directly?", "author": "seut", "createdAt": "2020-12-08T16:06:01Z", "path": "server/src/main/java/io/crate/types/NumericType.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import io.crate.common.annotations.VisibleForTesting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class NumericType extends DataType<BigDecimal> implements Streamer<BigDecimal> {\n+\n+    public static final int ID = 22;\n+    public static final NumericType INSTANCE = new NumericType(null, null); // unscaled\n+\n+    public static NumericType of(int precision) {\n+        return new NumericType(precision, null);\n+    }\n+\n+    public static NumericType of(int precision, int scale) {\n+        return new NumericType(precision, scale);\n+    }\n+\n+    public static DataType<?> of(List<Integer> parameters) {\n+        if (parameters.isEmpty() || parameters.size() > 2) {\n+            throw new IllegalArgumentException(\n+                \"The numeric type support one or two parameter arguments, received: \" +\n+                parameters.size()\n+            );\n+        }\n+        if (parameters.size() == 1) {\n+            return of(parameters.get(0));\n+        } else {\n+            return of(parameters.get(0), parameters.get(1));\n+        }\n+    }\n+\n+    private final Integer scale;\n+    private final Integer precision;\n+\n+    private NumericType(Integer precision, Integer scale) {\n+        this.precision = precision;\n+        this.scale = scale;\n+    }\n+\n+    public NumericType(StreamInput in) throws IOException {\n+        this.precision = in.readOptionalVInt();\n+        this.scale = in.readOptionalVInt();\n+    }\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.NUMERIC;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"numeric\";\n+    }\n+\n+    @Override\n+    public Streamer<BigDecimal> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public BigDecimal implicitCast(Object value) throws IllegalArgumentException, ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        var mathContext = mathContextOrDefault();\n+        if (value instanceof BigDecimal) {\n+            return new BigDecimal(\n+                ((BigDecimal) value).toBigInteger(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof String) {\n+            return new BigDecimal(\n+                new BigInteger((String) value),", "originalCommit": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgxMjU0NQ==", "url": "https://github.com/crate/crate/pull/10854#discussion_r538812545", "bodyText": "I'll have to double-check that, but I think coz the string can already contain a scaled value.", "author": "kovrus", "createdAt": "2020-12-08T21:15:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU0MTYxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU1NjM5Mg==", "url": "https://github.com/crate/crate/pull/10854#discussion_r538556392", "bodyText": "couldn't this be folded into the String branch?", "author": "seut", "createdAt": "2020-12-08T16:18:46Z", "path": "server/src/main/java/io/crate/types/NumericType.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import io.crate.common.annotations.VisibleForTesting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class NumericType extends DataType<BigDecimal> implements Streamer<BigDecimal> {\n+\n+    public static final int ID = 22;\n+    public static final NumericType INSTANCE = new NumericType(null, null); // unscaled\n+\n+    public static NumericType of(int precision) {\n+        return new NumericType(precision, null);\n+    }\n+\n+    public static NumericType of(int precision, int scale) {\n+        return new NumericType(precision, scale);\n+    }\n+\n+    public static DataType<?> of(List<Integer> parameters) {\n+        if (parameters.isEmpty() || parameters.size() > 2) {\n+            throw new IllegalArgumentException(\n+                \"The numeric type support one or two parameter arguments, received: \" +\n+                parameters.size()\n+            );\n+        }\n+        if (parameters.size() == 1) {\n+            return of(parameters.get(0));\n+        } else {\n+            return of(parameters.get(0), parameters.get(1));\n+        }\n+    }\n+\n+    private final Integer scale;\n+    private final Integer precision;\n+\n+    private NumericType(Integer precision, Integer scale) {\n+        this.precision = precision;\n+        this.scale = scale;\n+    }\n+\n+    public NumericType(StreamInput in) throws IOException {\n+        this.precision = in.readOptionalVInt();\n+        this.scale = in.readOptionalVInt();\n+    }\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.NUMERIC;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"numeric\";\n+    }\n+\n+    @Override\n+    public Streamer<BigDecimal> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public BigDecimal implicitCast(Object value) throws IllegalArgumentException, ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        var mathContext = mathContextOrDefault();\n+        if (value instanceof BigDecimal) {\n+            return new BigDecimal(\n+                ((BigDecimal) value).toBigInteger(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof String) {\n+            return new BigDecimal(\n+                new BigInteger((String) value),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof Long\n+                   || value instanceof Byte\n+                   || value instanceof Integer\n+                   || value instanceof Short) {\n+            return new BigDecimal(\n+                BigInteger.valueOf(((Number) value).longValue()),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof Float || value instanceof Double) {", "originalCommit": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU1NzgzNA==", "url": "https://github.com/crate/crate/pull/10854#discussion_r538557834", "bodyText": "just adding 1L once should be enough and keeps this simpler", "author": "seut", "createdAt": "2020-12-08T16:20:06Z", "path": "server/src/test/java/io/crate/execution/engine/aggregation/impl/OverflowAwareMutableLongTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.junit.Assert.assertThat;\n+\n+public class OverflowAwareMutableLongTest {\n+\n+    @Test\n+    public void test_add_without_overflow_operates_on_primitive_long() {\n+        var value = new OverflowAwareMutableLong(5L);\n+        value.add(5L);\n+\n+        assertThat(value.hasValue(), is(true));\n+        assertThat(value.primitiveSum(), is(10L));\n+        assertThat(value.bigDecimalSum(), is(nullValue()));\n+        assertThat(value.value(), is(BigDecimal.TEN));\n+    }\n+\n+    @Test\n+    public void test_add_with_overflow_operates_on_big_decimal() {\n+        var value = new OverflowAwareMutableLong(Long.MAX_VALUE);\n+        value.add(5L);\n+        value.add(5L);", "originalCommit": "2fe6b8e8a09fb480b75cb5ba1165ffa4d94243c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NTE5MA==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539075190", "bodyText": "actually, calling the .add twice will test different parts of the code. so all fine, ignore my comment ;-)", "author": "seut", "createdAt": "2020-12-09T07:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU1NzgzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMDA5Mg==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539300092", "bodyText": "The length is internally calculated as\n        int byteLen = bitLength()/8 + 1;\n        byte[] byteArray = new byte[byteLen];\n\nCould we maybe use bitLength() / 8 + 1 directly? Creating the byteArray only to get the size seems overly expensive for the memory estimation.", "author": "mfussenegger", "createdAt": "2020-12-09T13:21:06Z", "path": "server/src/main/java/io/crate/breaker/NumericSizeEstimator.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.breaker;\n+\n+import javax.annotation.Nullable;\n+import java.math.BigDecimal;\n+\n+public final class NumericSizeEstimator extends SizeEstimator<BigDecimal> {\n+\n+    public static final NumericSizeEstimator INSTANCE = new NumericSizeEstimator();\n+\n+    private NumericSizeEstimator() {\n+    }\n+\n+    @Override\n+    public long estimateSize(@Nullable BigDecimal value) {\n+        if (value == null) {\n+            return 8;\n+        }\n+        return value.unscaledValue().toByteArray().length;", "originalCommit": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMTg1OA==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539301858", "bodyText": "Shouldn't the returnType default to numeric anyway because of the signature definition?\nNot sure I understand the reasoning here.\nIf we later on add supports for numeric type storage we shouldn't have to adjust aggregation functions.", "author": "mfussenegger", "createdAt": "2020-12-09T13:23:47Z", "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/NumericSumAggregation.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.execution.engine.aggregation.AggregationFunction;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.memory.MemoryManager;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.ByteType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.DoubleType;\n+import io.crate.types.FloatType;\n+import io.crate.types.IntegerType;\n+import io.crate.types.LongType;\n+import io.crate.types.ShortType;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.breaker.CircuitBreakingException;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+public class NumericSumAggregation extends AggregationFunction<BigDecimal, BigDecimal> {\n+\n+    public static final String NAME = \"sum\";\n+    public static final Signature SIGNATURE = Signature.aggregate(\n+        NAME,\n+        DataTypes.NUMERIC.getTypeSignature(),\n+        DataTypes.NUMERIC.getTypeSignature()\n+    );\n+\n+    public static void register(AggregationImplModule mod) {\n+        mod.register(SIGNATURE, NumericSumAggregation::new);\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType<BigDecimal> returnType;\n+\n+    @VisibleForTesting\n+    private NumericSumAggregation(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        // usually the sum numeric aggregation function is going to be\n+        // resolved after casting the sum parameter to the numeric type,\n+        // e.g. sum(count::numeric(16, 2)). Having that, it\n+        // is not possible to resolve the return type that will contain\n+        // the precision and/or scale. Therefore, we infer the return\n+        // type from the argument type.", "originalCommit": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMyMzc5Nw==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539323797", "bodyText": "Yes, the return type defaults to numeric, but with the default precision and 0 scale.  If we do smth like sum(count::numeric(16, 2)) we will lose the precision and scale information in the return type, so currently that is the only way I think, otherwise, we would need to have use type variables instead of numeric in the sum signature and somehow make it work also with other types.", "author": "kovrus", "createdAt": "2020-12-09T13:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMTg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMjYyNQ==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539302625", "bodyText": "See comment about avoiding toByteArray in the size estimator class", "author": "mfussenegger", "createdAt": "2020-12-09T13:24:47Z", "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/NumericSumAggregation.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.execution.engine.aggregation.AggregationFunction;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.memory.MemoryManager;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.ByteType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.DoubleType;\n+import io.crate.types.FloatType;\n+import io.crate.types.IntegerType;\n+import io.crate.types.LongType;\n+import io.crate.types.ShortType;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.breaker.CircuitBreakingException;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+public class NumericSumAggregation extends AggregationFunction<BigDecimal, BigDecimal> {\n+\n+    public static final String NAME = \"sum\";\n+    public static final Signature SIGNATURE = Signature.aggregate(\n+        NAME,\n+        DataTypes.NUMERIC.getTypeSignature(),\n+        DataTypes.NUMERIC.getTypeSignature()\n+    );\n+\n+    public static void register(AggregationImplModule mod) {\n+        mod.register(SIGNATURE, NumericSumAggregation::new);\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType<BigDecimal> returnType;\n+\n+    @VisibleForTesting\n+    private NumericSumAggregation(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        // usually the sum numeric aggregation function is going to be\n+        // resolved after casting the sum parameter to the numeric type,\n+        // e.g. sum(count::numeric(16, 2)). Having that, it\n+        // is not possible to resolve the return type that will contain\n+        // the precision and/or scale. Therefore, we infer the return\n+        // type from the argument type.\n+        var argumentType = boundSignature.getArgumentDataTypes().get(0);\n+        assert argumentType.id() == DataTypes.NUMERIC.id();\n+        //noinspection unchecked\n+        this.returnType = (DataType<BigDecimal>) argumentType;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BigDecimal newState(RamAccounting ramAccounting,\n+                               Version indexVersionCreated,\n+                               Version minNodeInCluster,\n+                               MemoryManager memoryManager) {\n+        return null;\n+    }\n+\n+    @Override\n+    public BigDecimal iterate(RamAccounting ramAccounting,\n+                              MemoryManager memoryManager,\n+                              BigDecimal state,\n+                              Input[] args) throws CircuitBreakingException {\n+        BigDecimal value = returnType.implicitCast(args[0].value());\n+        if (value != null) {\n+            if (state != null) {\n+                state = state.add(value);\n+            } else {\n+                state = value;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    @Override\n+    public BigDecimal reduce(RamAccounting ramAccounting,\n+                             BigDecimal state1,\n+                             BigDecimal state2) {\n+        if (state1 == null) {\n+            return state2;\n+        }\n+        if (state2 == null) {\n+            return state1;\n+        }\n+        return state1.add(state2);\n+    }\n+\n+    @Override\n+    public BigDecimal terminatePartial(RamAccounting ramAccounting, BigDecimal state) {\n+        if (state != null) {\n+            ramAccounting.addBytes(state.unscaledValue().toByteArray().length);", "originalCommit": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMzU0Nw==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539303547", "bodyText": "Same here.\nI'm also not sure if partialResult is the right place for the accounting. partialResult is called at the end of the aggregation, long after the allocations and resizes already happened.\nI think doing this in initialState or as needed would be safer", "author": "mfussenegger", "createdAt": "2020-12-09T13:26:05Z", "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/NumericSumAggregation.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.execution.engine.aggregation.AggregationFunction;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.memory.MemoryManager;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.ByteType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.DoubleType;\n+import io.crate.types.FloatType;\n+import io.crate.types.IntegerType;\n+import io.crate.types.LongType;\n+import io.crate.types.ShortType;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.breaker.CircuitBreakingException;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+public class NumericSumAggregation extends AggregationFunction<BigDecimal, BigDecimal> {\n+\n+    public static final String NAME = \"sum\";\n+    public static final Signature SIGNATURE = Signature.aggregate(\n+        NAME,\n+        DataTypes.NUMERIC.getTypeSignature(),\n+        DataTypes.NUMERIC.getTypeSignature()\n+    );\n+\n+    public static void register(AggregationImplModule mod) {\n+        mod.register(SIGNATURE, NumericSumAggregation::new);\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType<BigDecimal> returnType;\n+\n+    @VisibleForTesting\n+    private NumericSumAggregation(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        // usually the sum numeric aggregation function is going to be\n+        // resolved after casting the sum parameter to the numeric type,\n+        // e.g. sum(count::numeric(16, 2)). Having that, it\n+        // is not possible to resolve the return type that will contain\n+        // the precision and/or scale. Therefore, we infer the return\n+        // type from the argument type.\n+        var argumentType = boundSignature.getArgumentDataTypes().get(0);\n+        assert argumentType.id() == DataTypes.NUMERIC.id();\n+        //noinspection unchecked\n+        this.returnType = (DataType<BigDecimal>) argumentType;\n+    }\n+\n+    @Nullable\n+    @Override\n+    public BigDecimal newState(RamAccounting ramAccounting,\n+                               Version indexVersionCreated,\n+                               Version minNodeInCluster,\n+                               MemoryManager memoryManager) {\n+        return null;\n+    }\n+\n+    @Override\n+    public BigDecimal iterate(RamAccounting ramAccounting,\n+                              MemoryManager memoryManager,\n+                              BigDecimal state,\n+                              Input[] args) throws CircuitBreakingException {\n+        BigDecimal value = returnType.implicitCast(args[0].value());\n+        if (value != null) {\n+            if (state != null) {\n+                state = state.add(value);\n+            } else {\n+                state = value;\n+            }\n+        }\n+        return state;\n+    }\n+\n+    @Override\n+    public BigDecimal reduce(RamAccounting ramAccounting,\n+                             BigDecimal state1,\n+                             BigDecimal state2) {\n+        if (state1 == null) {\n+            return state2;\n+        }\n+        if (state2 == null) {\n+            return state1;\n+        }\n+        return state1.add(state2);\n+    }\n+\n+    @Override\n+    public BigDecimal terminatePartial(RamAccounting ramAccounting, BigDecimal state) {\n+        if (state != null) {\n+            ramAccounting.addBytes(state.unscaledValue().toByteArray().length);\n+        }\n+        return state;\n+    }\n+\n+    @Override\n+    public DataType<?> partialType() {\n+        return returnType;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public boolean isRemovableCumulative() {\n+        return true;\n+    }\n+\n+    @Override\n+    public BigDecimal removeFromAggregatedState(RamAccounting ramAccounting,\n+                                                BigDecimal previousAggState,\n+                                                Input[] stateToRemove) {\n+        BigDecimal value = returnType.implicitCast(stateToRemove[0].value());\n+        if (value != null) {\n+            if (previousAggState != null) {\n+                return previousAggState.subtract(value);\n+            }\n+        }\n+        return previousAggState;\n+    }\n+\n+    @Override\n+    public DocValueAggregator<?> getDocValueAggregator(List<DataType<?>> argumentTypes,\n+                                                       List<MappedFieldType> fieldTypes) {\n+        return switch (argumentTypes.get(0).id()) {\n+            case ByteType.ID, ShortType.ID, IntegerType.ID, LongType.ID ->\n+                new SumLong(returnType, fieldTypes.get(0).name());\n+            case FloatType.ID -> new SumFloat(returnType, fieldTypes.get(0).name());\n+            case DoubleType.ID -> new SumDouble(returnType, fieldTypes.get(0).name());\n+            default -> null;\n+        };\n+    }\n+\n+    static class SumLong implements DocValueAggregator<OverflowAwareMutableLong> {\n+\n+        private final DataType<BigDecimal> returnType;\n+        private final String columnName;\n+        private SortedNumericDocValues values;\n+\n+        SumLong(DataType<BigDecimal> returnType, String columnName) {\n+            this.returnType = returnType;\n+            this.columnName = columnName;\n+        }\n+\n+        @Override\n+        public OverflowAwareMutableLong initialState(RamAccounting ramAccounting) {\n+            return new OverflowAwareMutableLong(0L);\n+        }\n+\n+        @Override\n+        public void loadDocValues(LeafReader reader) throws IOException {\n+            values = DocValues.getSortedNumeric(reader, columnName);\n+        }\n+\n+        @Override\n+        public void apply(RamAccounting ramAccounting,\n+                          int doc,\n+                          OverflowAwareMutableLong state) throws IOException {\n+            if (values.advanceExact(doc) && values.docValueCount() == 1) {\n+                state.add(values.nextValue());\n+            }\n+        }\n+\n+        @Override\n+        public BigDecimal partialResult(RamAccounting ramAccounting,\n+                                        OverflowAwareMutableLong state) {\n+            if (state.hasValue()) {\n+                var partialResult = state.value();\n+                ramAccounting.addBytes(partialResult.unscaledValue().toByteArray().length);", "originalCommit": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMxNDc5NQ==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539314795", "bodyText": "I put into partialResult because we do not know how big the big decimal can be at the end. Would you suggest just to put some apprx. into initialState like for example 4 bytes?", "author": "kovrus", "createdAt": "2020-12-09T13:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMzU0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg1MDIxOA==", "url": "https://github.com/crate/crate/pull/10854#discussion_r540850218", "bodyText": "Yes I think its important to account that at earliest as possible, meaning accounting for the min size at initialState and adjusting it on iterate.", "author": "seut", "createdAt": "2020-12-11T10:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwMzU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwNjM3Ng==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539306376", "bodyText": "Should we maybe add a test in crate-qa with asyncpg or so, to verify that this can be read? Or is this covered already somewhere?", "author": "mfussenegger", "createdAt": "2020-12-09T13:29:54Z", "path": "server/src/main/java/io/crate/protocols/postgres/types/NumericType.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres.types;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import javax.annotation.Nonnull;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.nio.charset.StandardCharsets;\n+\n+class NumericType extends PGType<BigDecimal> {\n+\n+    static final int OID = 1700;\n+\n+    private static final int TYPE_LEN = -1;\n+    private static final int TYPE_MOD = -1;\n+\n+    public static final NumericType INSTANCE = new NumericType();\n+\n+    private NumericType() {\n+        super(OID, TYPE_LEN, TYPE_MOD, \"numeric\");\n+    }\n+\n+    @Override\n+    public int typArray() {\n+        return PGArray.NUMERIC_ARRAY.oid();\n+    }\n+\n+    @Override\n+    public String typeCategory() {\n+        return TypeCategory.NUMERIC.code();\n+    }\n+\n+    @Override\n+    public String type() {\n+        return Type.BASE.code();\n+    }\n+\n+    @Override\n+    public int writeAsBinary(ByteBuf buffer, @Nonnull BigDecimal value) {\n+        buffer.writeInt(TYPE_LEN);\n+\n+        buffer.writeInt(value.scale());\n+        buffer.writeInt(value.precision());\n+\n+        var unscaled = value.unscaledValue();\n+        byte[] bytes = unscaled.toByteArray();\n+        buffer.writeInt(bytes.length);\n+        buffer.writeBytes(bytes);\n+\n+        // unscaled (length) + unscaled (bytes) + precision and scale\n+        return INT32_BYTE_SIZE + bytes.length + INT32_BYTE_SIZE * 2;", "originalCommit": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMxNjAxMQ==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539316011", "bodyText": "not really, only in unit tests. would it be enough to go for an integration pg test in crate/crate?", "author": "kovrus", "createdAt": "2020-12-09T13:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwNjM3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMyMTc3Ng==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539321776", "bodyText": "If the jdbc client supports binary serialization for numeric types that's also possible, yes.", "author": "mfussenegger", "createdAt": "2020-12-09T13:51:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwNjM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMwOTc1Mg==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539309752", "bodyText": "There's  writeByteArray and readByteArray which could be used", "author": "mfussenegger", "createdAt": "2020-12-09T13:34:45Z", "path": "server/src/main/java/io/crate/types/NumericType.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import io.crate.common.annotations.VisibleForTesting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class NumericType extends DataType<BigDecimal> implements Streamer<BigDecimal> {\n+\n+    public static final int ID = 22;\n+    public static final NumericType INSTANCE = new NumericType(null, null); // unscaled\n+\n+    public static NumericType of(int precision) {\n+        return new NumericType(precision, null);\n+    }\n+\n+    public static NumericType of(int precision, int scale) {\n+        return new NumericType(precision, scale);\n+    }\n+\n+    public static DataType<?> of(List<Integer> parameters) {\n+        if (parameters.isEmpty() || parameters.size() > 2) {\n+            throw new IllegalArgumentException(\n+                \"The numeric type support one or two parameter arguments, received: \" +\n+                parameters.size()\n+            );\n+        }\n+        if (parameters.size() == 1) {\n+            return of(parameters.get(0));\n+        } else {\n+            return of(parameters.get(0), parameters.get(1));\n+        }\n+    }\n+\n+    private final Integer scale;\n+    private final Integer precision;\n+\n+    private NumericType(Integer precision, Integer scale) {\n+        this.precision = precision;\n+        this.scale = scale;\n+    }\n+\n+    public NumericType(StreamInput in) throws IOException {\n+        this.precision = in.readOptionalVInt();\n+        this.scale = in.readOptionalVInt();\n+    }\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.NUMERIC;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"numeric\";\n+    }\n+\n+    @Override\n+    public Streamer<BigDecimal> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public BigDecimal implicitCast(Object value) throws IllegalArgumentException, ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        var mathContext = mathContextOrDefault();\n+        if (value instanceof BigDecimal) {\n+            return new BigDecimal(\n+                ((BigDecimal) value).toBigInteger(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof Long\n+                   || value instanceof Byte\n+                   || value instanceof Integer\n+                   || value instanceof Short) {\n+            return new BigDecimal(\n+                BigInteger.valueOf(((Number) value).longValue()),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof String\n+                   || value instanceof Float\n+                   || value instanceof Double) {\n+            return new BigDecimal(\n+                value.toString(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else {\n+            throw new ClassCastException(\"Can't cast '\" + value + \"' to \" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal sanitizeValue(Object value) {\n+        if (value == null) {\n+            return null;\n+        } else {\n+            return (BigDecimal) value;\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal valueForInsert(Object value) {\n+        throw new UnsupportedOperationException(\n+            getName() + \" type cannot be used in insert statements\");\n+    }\n+\n+    @VisibleForTesting\n+    Integer scale() {\n+        return scale;\n+    }\n+\n+    @VisibleForTesting\n+    Integer precision() {\n+        return precision;\n+    }\n+\n+    private MathContext mathContextOrDefault() {\n+        if (precision == null) {\n+            return MathContext.UNLIMITED;\n+        } else {\n+            return new MathContext(precision);\n+        }\n+    }\n+\n+    private int scaleOrDefault() {\n+        return Objects.requireNonNullElse(scale, 0);\n+    }\n+\n+    private boolean unscaled() {\n+        return precision == null;\n+    }\n+\n+    @Override\n+    public TypeSignature getTypeSignature() {\n+        if (unscaled()) {\n+            return super.getTypeSignature();\n+        } else {\n+            ArrayList<TypeSignature> parameters = new ArrayList<>();\n+            parameters.add(TypeSignature.of(precision));\n+            if (scale != null) {\n+                parameters.add(TypeSignature.of(scale));\n+            }\n+            return new TypeSignature(getName(), parameters);\n+        }\n+    }\n+\n+    @Override\n+    public List<DataType<?>> getTypeParameters() {\n+        if (unscaled()) {\n+            return List.of();\n+        } else {\n+            if (scale != null) {\n+                return List.of(DataTypes.INTEGER);\n+            } else {\n+                return List.of(DataTypes.INTEGER, DataTypes.INTEGER);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int compare(BigDecimal o1, BigDecimal o2) {\n+        return o1.compareTo(o2);\n+    }\n+\n+    @Override\n+    public BigDecimal readValueFrom(StreamInput in) throws IOException {\n+        if (in.readBoolean()) {\n+            byte[] bytes = new byte[in.readVInt()];\n+            in.readBytes(bytes, 0, bytes.length);\n+            return new BigDecimal(\n+                new BigInteger(bytes),\n+                scaleOrDefault(),\n+                mathContextOrDefault()\n+            );\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public void writeValueTo(StreamOutput out, BigDecimal v) throws IOException {\n+        if (v != null) {\n+            out.writeBoolean(true);\n+            var bytes = v.unscaledValue().toByteArray();\n+            out.writeVInt(bytes.length);", "originalCommit": "fc447b25a8e00a5cfde5d5a2f27ab81c07282a04", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTMyNjIxMg==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539326212", "bodyText": "Ah okay, now I get it.\nHow about something like this instead:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // usually the sum numeric aggregation function is going to be\n          \n          \n            \n                    // resolved after casting the sum parameter to the numeric type,\n          \n          \n            \n                    // e.g. sum(count::numeric(16, 2)). Having that, it\n          \n          \n            \n                    // is not possible to resolve the return type that will contain\n          \n          \n            \n                    // the precision and/or scale. Therefore, we infer the return\n          \n          \n            \n                    // type from the argument type.\n          \n          \n            \n                    // We want to preserve the scale and precision from the numeric argument type for the return type.\n          \n          \n            \n                    // So we use the incoming numeric type as return type instead of the return type from the signature  \n          \n          \n            \n                    // `sum(count::numeric(16, 2))` should return the type `numeric(16, 2)` not `numeric`", "author": "mfussenegger", "createdAt": "2020-12-09T13:56:50Z", "path": "server/src/main/java/io/crate/execution/engine/aggregation/impl/NumericSumAggregation.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.execution.engine.aggregation.impl;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.execution.engine.aggregation.AggregationFunction;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.memory.MemoryManager;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.types.ByteType;\n+import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import io.crate.types.DoubleType;\n+import io.crate.types.FloatType;\n+import io.crate.types.IntegerType;\n+import io.crate.types.LongType;\n+import io.crate.types.ShortType;\n+import org.apache.lucene.index.DocValues;\n+import org.apache.lucene.index.LeafReader;\n+import org.apache.lucene.index.SortedNumericDocValues;\n+import org.apache.lucene.util.NumericUtils;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.common.breaker.CircuitBreakingException;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.util.List;\n+\n+public class NumericSumAggregation extends AggregationFunction<BigDecimal, BigDecimal> {\n+\n+    public static final String NAME = \"sum\";\n+    public static final Signature SIGNATURE = Signature.aggregate(\n+        NAME,\n+        DataTypes.NUMERIC.getTypeSignature(),\n+        DataTypes.NUMERIC.getTypeSignature()\n+    );\n+\n+    public static void register(AggregationImplModule mod) {\n+        mod.register(SIGNATURE, NumericSumAggregation::new);\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+    private final DataType<BigDecimal> returnType;\n+\n+    @VisibleForTesting\n+    private NumericSumAggregation(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+\n+        // usually the sum numeric aggregation function is going to be\n+        // resolved after casting the sum parameter to the numeric type,\n+        // e.g. sum(count::numeric(16, 2)). Having that, it\n+        // is not possible to resolve the return type that will contain\n+        // the precision and/or scale. Therefore, we infer the return\n+        // type from the argument type.", "originalCommit": "072c4a111d75fbe8137c751074c4e2aa3a164c8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MTUwNA==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539381504", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            the function argument to the :ref:` numeric type <numeric_type>` with an\n          \n          \n            \n            the function argument to the :ref:`numeric type <numeric_type>` with an", "author": "norosa", "createdAt": "2020-12-09T15:03:54Z", "path": "docs/general/builtins/aggregation.rst", "diffHunk": "@@ -307,6 +307,52 @@ exceeded an `ArithmeticException` will be raised.\n     cr> select sum(name), kind from locations group by kind order by sum(name) desc;\n     SQLParseException[Cannot cast value `North West Ripple` to type `char`]\n \n+If the ``sum`` aggregation on a numeric data type with the fixed length can\n+potentially exceed its range it is possible to handle the overflow by casting\n+the function argument to the :ref:` numeric type <numeric_type>` with an", "originalCommit": "072c4a111d75fbe8137c751074c4e2aa3a164c8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MjExMg==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539382112", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The ``sum`` aggregation on the ``bigint`` column will result in the overflow\n          \n          \n            \n            The ``sum`` aggregation on the ``bigint`` column will result in an overflow", "author": "norosa", "createdAt": "2020-12-09T15:04:37Z", "path": "docs/general/builtins/aggregation.rst", "diffHunk": "@@ -307,6 +307,52 @@ exceeded an `ArithmeticException` will be raised.\n     cr> select sum(name), kind from locations group by kind order by sum(name) desc;\n     SQLParseException[Cannot cast value `North West Ripple` to type `char`]\n \n+If the ``sum`` aggregation on a numeric data type with the fixed length can\n+potentially exceed its range it is possible to handle the overflow by casting\n+the function argument to the :ref:` numeric type <numeric_type>` with an\n+arbitrary precision.\n+\n+.. Hidden: create user visits table\n+\n+    cr> CREATE TABLE uservisits (id integer, count bigint)\n+    ... CLUSTERED INTO 1 SHARDS\n+    ... WITH (number_of_replicas = 0);\n+    CREATE OK, 1 row affected (... sec)\n+\n+.. Hidden: insert into uservisits table\n+\n+    cr> INSERT INTO uservisits VALUES (1, 9223372036854775807), (2, 10);\n+    INSERT OK, 2 rows affected  (... sec)\n+\n+.. Hidden: refresh uservisits table\n+\n+    cr> REFRESH TABLE uservisits;\n+    REFRESH OK, 1 row affected  (... sec)\n+\n+The ``sum`` aggregation on the ``bigint`` column will result in the overflow", "originalCommit": "072c4a111d75fbe8137c751074c4e2aa3a164c8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4MjkxMg==", "url": "https://github.com/crate/crate/pull/10854#discussion_r539382912", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            the aggregation column to the numeric data type::\n          \n          \n            \n            the aggregation column to the ``numeric`` data type::", "author": "norosa", "createdAt": "2020-12-09T15:05:32Z", "path": "docs/general/builtins/aggregation.rst", "diffHunk": "@@ -307,6 +307,52 @@ exceeded an `ArithmeticException` will be raised.\n     cr> select sum(name), kind from locations group by kind order by sum(name) desc;\n     SQLParseException[Cannot cast value `North West Ripple` to type `char`]\n \n+If the ``sum`` aggregation on a numeric data type with the fixed length can\n+potentially exceed its range it is possible to handle the overflow by casting\n+the function argument to the :ref:` numeric type <numeric_type>` with an\n+arbitrary precision.\n+\n+.. Hidden: create user visits table\n+\n+    cr> CREATE TABLE uservisits (id integer, count bigint)\n+    ... CLUSTERED INTO 1 SHARDS\n+    ... WITH (number_of_replicas = 0);\n+    CREATE OK, 1 row affected (... sec)\n+\n+.. Hidden: insert into uservisits table\n+\n+    cr> INSERT INTO uservisits VALUES (1, 9223372036854775807), (2, 10);\n+    INSERT OK, 2 rows affected  (... sec)\n+\n+.. Hidden: refresh uservisits table\n+\n+    cr> REFRESH TABLE uservisits;\n+    REFRESH OK, 1 row affected  (... sec)\n+\n+The ``sum`` aggregation on the ``bigint`` column will result in the overflow\n+in the following aggregation query::\n+\n+    cr> SELECT sum(count)\n+    ... FROM uservisits;\n+    ArithmeticException[long overflow]\n+\n+To address the overflow of the sum aggregation on the given field, we cast\n+the aggregation column to the numeric data type::", "originalCommit": "072c4a111d75fbe8137c751074c4e2aa3a164c8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c26c0b4d93e038e911989955161863f8acb1d52f", "url": "https://github.com/crate/crate/commit/c26c0b4d93e038e911989955161863f8acb1d52f", "message": "fixup! Add documentation for the numeric type and numeric sum aggreagtion.", "committedDate": "2020-12-10T15:14:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDg0NzMzNA==", "url": "https://github.com/crate/crate/pull/10854#discussion_r540847334", "bodyText": "This will just account for the internal bits needed for the integers of the BigInteger. I think we should account all other fields of BigDecimal + BigInteger as well (see https://www.javamex.com/tutorials/memory/object_memory_usage.shtml + https://stackoverflow.com/questions/2501176/java-bigdecimal-memory-usage).", "author": "seut", "createdAt": "2020-12-11T10:30:22Z", "path": "server/src/main/java/io/crate/types/NumericType.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.types;\n+\n+import io.crate.Streamer;\n+import io.crate.common.annotations.VisibleForTesting;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import javax.annotation.Nonnull;\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class NumericType extends DataType<BigDecimal> implements Streamer<BigDecimal> {\n+\n+    public static final int ID = 22;\n+    public static final NumericType INSTANCE = new NumericType(null, null); // unscaled\n+\n+    public static NumericType of(int precision) {\n+        return new NumericType(precision, null);\n+    }\n+\n+    public static NumericType of(int precision, int scale) {\n+        return new NumericType(precision, scale);\n+    }\n+\n+    public static DataType<?> of(List<Integer> parameters) {\n+        if (parameters.isEmpty() || parameters.size() > 2) {\n+            throw new IllegalArgumentException(\n+                \"The numeric type support one or two parameter arguments, received: \" +\n+                parameters.size()\n+            );\n+        }\n+        if (parameters.size() == 1) {\n+            return of(parameters.get(0));\n+        } else {\n+            return of(parameters.get(0), parameters.get(1));\n+        }\n+    }\n+\n+    private final Integer scale;\n+    private final Integer precision;\n+\n+    private NumericType(Integer precision, Integer scale) {\n+        this.precision = precision;\n+        this.scale = scale;\n+    }\n+\n+    public NumericType(StreamInput in) throws IOException {\n+        this.precision = in.readOptionalVInt();\n+        this.scale = in.readOptionalVInt();\n+    }\n+\n+    @Override\n+    public int id() {\n+        return ID;\n+    }\n+\n+    @Override\n+    public Precedence precedence() {\n+        return Precedence.NUMERIC;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"numeric\";\n+    }\n+\n+    @Override\n+    public Streamer<BigDecimal> streamer() {\n+        return this;\n+    }\n+\n+    @Override\n+    public BigDecimal implicitCast(Object value) throws IllegalArgumentException, ClassCastException {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        var mathContext = mathContextOrDefault();\n+        if (value instanceof Long\n+            || value instanceof Byte\n+            || value instanceof Integer\n+            || value instanceof Short) {\n+            return new BigDecimal(\n+                BigInteger.valueOf(((Number) value).longValue()),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else if (value instanceof String\n+                   || value instanceof Float\n+                   || value instanceof Double\n+                   || value instanceof BigDecimal) {\n+            return new BigDecimal(\n+                value.toString(),\n+                mathContext\n+            ).setScale(scaleOrDefault(), mathContext.getRoundingMode());\n+        } else {\n+            throw new ClassCastException(\"Can't cast '\" + value + \"' to \" + getName());\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal sanitizeValue(Object value) {\n+        if (value == null) {\n+            return null;\n+        } else {\n+            return (BigDecimal) value;\n+        }\n+    }\n+\n+    @Override\n+    public BigDecimal valueForInsert(Object value) {\n+        throw new UnsupportedOperationException(\n+            getName() + \" type cannot be used in insert statements\");\n+    }\n+\n+    public static long size(@Nonnull BigDecimal value) {\n+        return value.unscaledValue().bitLength() / 8 + 1;", "originalCommit": "c26c0b4d93e038e911989955161863f8acb1d52f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6e7b6e1e97dd8c10cad834764fbdc1f9f38e2fc6", "url": "https://github.com/crate/crate/commit/6e7b6e1e97dd8c10cad834764fbdc1f9f38e2fc6", "message": "fixup! fixup! Add support for the numeric data type in the sum aggregation.", "committedDate": "2020-12-11T12:27:29Z", "type": "forcePushed"}, {"oid": "eeb6dcb474e6f314a434b235e7a8ae484c54bee1", "url": "https://github.com/crate/crate/commit/eeb6dcb474e6f314a434b235e7a8ae484c54bee1", "message": "fixup! fixup! Add support for the numeric data type in the sum aggregation.", "committedDate": "2020-12-11T13:55:54Z", "type": "forcePushed"}, {"oid": "70dad6d72492480a5aa500009d602fdb302d0473", "url": "https://github.com/crate/crate/commit/70dad6d72492480a5aa500009d602fdb302d0473", "message": "Add documentation for the numeric type and numeric sum aggreagtion.", "committedDate": "2020-12-11T14:35:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjAwNzIxNQ==", "url": "https://github.com/crate/crate/pull/10854#discussion_r542007215", "bodyText": "@seut I couldn't finish this part on time, so such as I am not here, I am handling it over to you :(\nI've been trying to come up with some solution that would reflect the numeric_send method   https://github.com/postgres/postgres/blob/7538708394e7a70105a4e601e253adf80f47cca8/src/backend/utils/adt/numeric.c#L1030-L1049 but couldn't make it work (testing with asyncgpg). I've been writing num digits, weight, sign, scale and each digit as short (int16), but it seems that it is more complicated than that, see  https://github.com/cockroachdb/cockroach/blob/c2b4fff9ce4a0b80f74dd39a5e45eccd15c1b933/pkg/sql/pgwire/pgwirebase/encoding.go#L600-L637 and https://github.com/cockroachdb/cockroach/blob/c2b4fff9ce4a0b80f74dd39a5e45eccd15c1b933/pkg/sql/pgwire/pgwirebase/encoding.go#L550-L662", "author": "kovrus", "createdAt": "2020-12-13T21:15:41Z", "path": "server/src/main/java/io/crate/protocols/postgres/types/NumericType.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres.types;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import javax.annotation.Nonnull;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+import java.nio.charset.StandardCharsets;\n+\n+class NumericType extends PGType<BigDecimal> {\n+\n+    static final int OID = 1700;\n+\n+    private static final int TYPE_LEN = -1;\n+    private static final int TYPE_MOD = -1;\n+\n+    public static final NumericType INSTANCE = new NumericType();\n+\n+    private NumericType() {\n+        super(OID, TYPE_LEN, TYPE_MOD, \"numeric\");\n+    }\n+\n+    @Override\n+    public int typArray() {\n+        return PGArray.NUMERIC_ARRAY.oid();\n+    }\n+\n+    @Override\n+    public String typeCategory() {\n+        return TypeCategory.NUMERIC.code();\n+    }\n+\n+    @Override\n+    public String type() {\n+        return Type.BASE.code();\n+    }\n+\n+    @Override\n+    public int writeAsBinary(ByteBuf buffer, @Nonnull BigDecimal value) {\n+        buffer.writeInt(TYPE_LEN);", "originalCommit": "70dad6d72492480a5aa500009d602fdb302d0473", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "66fc34ef5193419148ec31e0667972a32b6cb558", "url": "https://github.com/crate/crate/commit/66fc34ef5193419148ec31e0667972a32b6cb558", "message": "Add arithmetic support for numeric type", "committedDate": "2020-12-17T12:36:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyODE5Ng==", "url": "https://github.com/crate/crate/pull/10854#discussion_r545128196", "bodyText": "Thanks for your efforts. Can we also add testing some negative values here?", "author": "amotl", "createdAt": "2020-12-17T14:23:58Z", "path": "server/src/test/java/io/crate/protocols/postgres/types/NumericTypeTest.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.protocols.postgres.types;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import org.junit.Test;\n+\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n+import java.util.ArrayList;\n+\n+import static org.hamcrest.Matchers.is;\n+\n+public class NumericTypeTest extends BasePGTypeTest<BigDecimal> {\n+\n+    public NumericTypeTest() {\n+        super(NumericType.INSTANCE);\n+    }\n+\n+    @Test\n+    public void test_read_and_write_numeric_text_value() {\n+        var expected = new BigDecimal(\"12.123\", MathContext.DECIMAL64)\n+            .setScale(2, MathContext.DECIMAL64.getRoundingMode());\n+        ByteBuf buffer = Unpooled.buffer();\n+        try {\n+            //noinspection unchecked\n+            pgType.writeAsText(buffer, expected);\n+            var actual = pgType.readTextValue(buffer, buffer.readInt());\n+            assertThat(actual, is(expected));\n+            assertThat(actual.toString(), is(expected.toString()));\n+        } finally {\n+            buffer.release();\n+        }\n+    }\n+\n+    @Test\n+    public void test_read_and_write_numeric_binary_value() {\n+        ArrayList<BigDecimal> testNumbers = new ArrayList<>();\n+        testNumbers.add(new BigDecimal(\"00123\"));\n+        testNumbers.add(new BigDecimal(\"12345.1\"));\n+        testNumbers.add(new BigDecimal(\"12.123\").setScale(2, MathContext.DECIMAL64.getRoundingMode()));\n+        testNumbers.add(new BigDecimal(\"1234.0\"));\n+        testNumbers.add(new BigDecimal(\"1234.0000\").setScale(1, MathContext.DECIMAL64.getRoundingMode()));", "originalCommit": "72a75b2c20601d253664c3c9362d5ef3fabb9e0f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "77b86e80465072ed48adbb486652a48c22c2783e", "url": "https://github.com/crate/crate/commit/77b86e80465072ed48adbb486652a48c22c2783e", "message": "Add arithmetic support for numeric type", "committedDate": "2020-12-17T20:24:33Z", "type": "forcePushed"}, {"oid": "cb5f412aa2051ae1f653aae52dbb713b6ea2529e", "url": "https://github.com/crate/crate/commit/cb5f412aa2051ae1f653aae52dbb713b6ea2529e", "message": "Add arithmetic support for numeric type", "committedDate": "2020-12-17T20:31:54Z", "type": "forcePushed"}, {"oid": "87f9ab0ecdc27903db3b1aca73cea9e566adc9d1", "url": "https://github.com/crate/crate/commit/87f9ab0ecdc27903db3b1aca73cea9e566adc9d1", "message": "fixup! Add precision and scale parameters to the numeric data type.", "committedDate": "2020-12-17T21:06:49Z", "type": "forcePushed"}, {"oid": "07bf20ac1aeb0f7c0b9bc6e1b860ebc9464f9a1f", "url": "https://github.com/crate/crate/commit/07bf20ac1aeb0f7c0b9bc6e1b860ebc9464f9a1f", "message": "Fix function matching based on numer of exact argument types\n\nThe function matching fallback logic to select the most specific\nfunction signature based on the numer of exact argument types wrongly\nused the bound signature instead of the declared one.\n\nThis also required some hardening on most subscript function signatures\nwhich were only working before by coincindence based on this mistake.", "committedDate": "2021-01-08T10:51:24Z", "type": "commit"}, {"oid": "634b3b3d8cd0d9cc8be54e7690b4fbd24d30e435", "url": "https://github.com/crate/crate/commit/634b3b3d8cd0d9cc8be54e7690b4fbd24d30e435", "message": "Add the numeric data type.", "committedDate": "2021-01-08T10:51:24Z", "type": "commit"}, {"oid": "66a24fdaf4905176933064339191cfd60b888d9a", "url": "https://github.com/crate/crate/commit/66a24fdaf4905176933064339191cfd60b888d9a", "message": "Add a size estimator for the numeric data type.", "committedDate": "2021-01-08T10:51:25Z", "type": "commit"}, {"oid": "31b6554c637475a8adf980dce1bd122f499152e1", "url": "https://github.com/crate/crate/commit/31b6554c637475a8adf980dce1bd122f499152e1", "message": "Add the numeric type cast support for primitive numeric types.", "committedDate": "2021-01-08T10:51:25Z", "type": "commit"}, {"oid": "ff6ac508bcb6477f05a551fdd68dfd05ba91ec6e", "url": "https://github.com/crate/crate/commit/ff6ac508bcb6477f05a551fdd68dfd05ba91ec6e", "message": "Fix numeric to integer/bigint casts\n\nIf the numeric is in a valid integer/bigint range, casting must\nsucceed even if it looses the fraction part.\nOnly if the integer part exceeds the valid range and exception must\nbe thrown.", "committedDate": "2021-01-08T10:51:26Z", "type": "forcePushed"}, {"oid": "1f678a287799f481cb35f27e86712570d5f85693", "url": "https://github.com/crate/crate/commit/1f678a287799f481cb35f27e86712570d5f85693", "message": "Fix numeric to integer/bigint casts\n\nIf the numeric is in a valid integer/bigint range, casting must\nsucceed even if it looses the fraction part.\nOnly if the integer part exceeds the valid range and exception must\nbe thrown.", "committedDate": "2021-01-08T12:33:42Z", "type": "forcePushed"}, {"oid": "6a5f765da9d415ffb601f9b4d7d6840272fe82e2", "url": "https://github.com/crate/crate/commit/6a5f765da9d415ffb601f9b4d7d6840272fe82e2", "message": "Add precision and scale parameters to the numeric data type.", "committedDate": "2021-01-11T11:25:24Z", "type": "commit"}, {"oid": "ae0a1bfd074ce7a429cff95bf2e03bf94bbb8d28", "url": "https://github.com/crate/crate/commit/ae0a1bfd074ce7a429cff95bf2e03bf94bbb8d28", "message": "Add the PG wire protocol support for the numeric data type.", "committedDate": "2021-01-11T11:25:28Z", "type": "commit"}, {"oid": "05f0b23136a9c84e4bc36954e918ae459e9acd1b", "url": "https://github.com/crate/crate/commit/05f0b23136a9c84e4bc36954e918ae459e9acd1b", "message": "Add support for the numeric data type in the sum aggregation.", "committedDate": "2021-01-11T11:26:55Z", "type": "commit"}, {"oid": "f25ea79196fed86a76426e03d84c84963c0dc02d", "url": "https://github.com/crate/crate/commit/f25ea79196fed86a76426e03d84c84963c0dc02d", "message": "Add documentation for the numeric type and numeric sum aggreagtion.", "committedDate": "2021-01-11T11:26:57Z", "type": "commit"}, {"oid": "8d0c37063b118913ef9e0c5ecec08816e2f61715", "url": "https://github.com/crate/crate/commit/8d0c37063b118913ef9e0c5ecec08816e2f61715", "message": "Fix pg numeric binary protocol support\n\nImplementation is validated locally by using a self-built version of\nPgJDBC master which includes binary support for numeric types.\nSee https://gist.github.com/seut/275e734c66b3f6b02d4e1cf9df5233ef,\nhttps://github.com/pgjdbc/pgjdbc/commit/c85b149d68c.", "committedDate": "2021-01-11T11:26:57Z", "type": "commit"}, {"oid": "bf7c13585f69eecdfe1d1c6c218fa5f0d780f6a3", "url": "https://github.com/crate/crate/commit/bf7c13585f69eecdfe1d1c6c218fa5f0d780f6a3", "message": "Add arithmetic support for numeric type", "committedDate": "2021-01-11T11:26:57Z", "type": "commit"}, {"oid": "0ce43410da0ea5f78d08347ddb8180e5a016eabf", "url": "https://github.com/crate/crate/commit/0ce43410da0ea5f78d08347ddb8180e5a016eabf", "message": "Fix numeric to integer/bigint casts\n\nIf the numeric is in a valid integer/bigint range, casting must\nsucceed even if it looses the fraction part.\nOnly if the integer part exceeds the valid range an exception must\nbe thrown.", "committedDate": "2021-01-11T11:26:57Z", "type": "commit"}, {"oid": "0ce43410da0ea5f78d08347ddb8180e5a016eabf", "url": "https://github.com/crate/crate/commit/0ce43410da0ea5f78d08347ddb8180e5a016eabf", "message": "Fix numeric to integer/bigint casts\n\nIf the numeric is in a valid integer/bigint range, casting must\nsucceed even if it looses the fraction part.\nOnly if the integer part exceeds the valid range an exception must\nbe thrown.", "committedDate": "2021-01-11T11:26:57Z", "type": "forcePushed"}]}