{"pr_number": 9540, "pr_title": "Add encode and decode string functions", "pr_createdAt": "2020-01-21T00:30:50Z", "pr_url": "https://github.com/crate/crate/pull/9540", "timeline": [{"oid": "0aa120fb32a65ba4605e9baaaefdcf57a117c3d9", "url": "https://github.com/crate/crate/commit/0aa120fb32a65ba4605e9baaaefdcf57a117c3d9", "message": "Add encode and decode string functions\n\nEncode takes a binary string in hex format and returns a textual\nrepresentation into the specified format.\nDecode does the opposit and returns the string into hex format.\n\nClose #9539", "committedDate": "2020-01-21T00:32:56Z", "type": "forcePushed"}, {"oid": "1b9d0fb86939648c355d5f2a293cad24d9206445", "url": "https://github.com/crate/crate/commit/1b9d0fb86939648c355d5f2a293cad24d9206445", "message": "Add encode and decode string functions\n\nEncode takes a binary string in hex format and returns a textual\nrepresentation into the specified format.\nDecode does the opposit and returns the string into hex format.\n\nClose #9539\n\nUpdate changes.txt file", "committedDate": "2020-01-21T08:58:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk2NjI3MQ==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368966271", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Returns a string with the leasing hexadecimal flag removed.\n          \n          \n            \n                 * Returns a string with the leading hexadecimal flag removed.", "author": "seut", "createdAt": "2020-01-21T12:14:10Z", "path": "blob/src/main/java/io/crate/common/Hex.java", "diffHunk": "@@ -33,6 +38,37 @@\n      */\n     private static final char[] DIGITS_UPPER = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n \n+    /**\n+     * Returns true if the argument is in the \"bytea\" hex format.\n+     */\n+    public static boolean isHexFormat(String data) {\n+        return data.startsWith(HEX_FLAG);\n+    }\n+\n+    /**\n+     * Returns a string with the leasing hexadecimal flag removed.", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk2ODA5MA==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368968090", "bodyText": "We should move this class and the existing Hex one into the shared subproject, this new class is not used inside blob at all and it contains generic logic anyway.", "author": "seut", "createdAt": "2020-01-21T12:18:41Z", "path": "blob/src/main/java/io/crate/common/Octal.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.common;\n+\n+import java.util.Arrays;\n+import java.util.Locale;\n+\n+/**\n+ * Encodes and decodes binary strings into the \"bytea\" escape format.\n+ * Unprintable bytes, outside of the 32..126 range are represented with an octal number \"\\nnn\", and backslashes\n+ * are doubled.\n+ */\n+public class Octal {", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3Mzk1OA==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368973958", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Add encode and decode string functions.\n          \n          \n            \n            - Added the :ref:`encode` and :ref:`decode` string functions.", "author": "seut", "createdAt": "2020-01-21T12:32:56Z", "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -52,7 +52,7 @@ None\n Changes\n =======\n \n-None\n+- Add encode and decode string functions.", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3NjI5Mg==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368976292", "bodyText": "All examples which uses the cr> prefix are executed and tested when running our itest  gradle task.\nI think this will fail as the output SELECT 1 row in set (... sec) is missing.\nAnother minor: all lines should be intended by 4 spaces.", "author": "seut", "createdAt": "2020-01-21T12:38:50Z", "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -508,6 +508,49 @@ Example::\n    In both cases, the scalar functions lpad and rpad, do now accept a len\n    greater than 50000.\n \n+.. _scalar-encode:\n+\n+``encode(bytea, format)``\n+-------------------------\n+\n+Encode takes a binary string in hex format and returns a textual representation\n+into the specified format. Supported formats are base64, hex, and escape. The\n+escape format represents unprintable characters with an octal sequence `\\nnn`.\n+\n+Synopsis::\n+\n+    encode(string1, format)\n+\n+Example::\n+\n+   cr> select encode(E'123\\b\\t56', 'base64');\n+   +----------------------------------------+\n+   | select encode(E'123\\b\\t56', 'base64'); |\n+   +----------------------------------------+\n+   | MTIzCAk1Ng==                           |\n+   +----------------------------------------+", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3NjQxMQ==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368976411", "bodyText": "Same issues here as well.", "author": "seut", "createdAt": "2020-01-21T12:39:09Z", "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -508,6 +508,49 @@ Example::\n    In both cases, the scalar functions lpad and rpad, do now accept a len\n    greater than 50000.\n \n+.. _scalar-encode:\n+\n+``encode(bytea, format)``\n+-------------------------\n+\n+Encode takes a binary string in hex format and returns a textual representation\n+into the specified format. Supported formats are base64, hex, and escape. The\n+escape format represents unprintable characters with an octal sequence `\\nnn`.\n+\n+Synopsis::\n+\n+    encode(string1, format)\n+\n+Example::\n+\n+   cr> select encode(E'123\\b\\t56', 'base64');\n+   +----------------------------------------+\n+   | select encode(E'123\\b\\t56', 'base64'); |\n+   +----------------------------------------+\n+   | MTIzCAk1Ng==                           |\n+   +----------------------------------------+\n+\n+.. _scalar-decode:\n+\n+``decode(text, format)``\n+-------------------------\n+\n+Decodes text encoded in the given format, which are listed in the `encode`\n+documentation. Returns a binary string in the hex format.\n+\n+Synopsis::\n+\n+    decode(text1, format)\n+\n+Example::\n+\n+   cr> select decode('T\\214', 'escape');\n+   +-----------------------------------+\n+   | select decode('T\\214', 'escape'); |\n+   +-----------------------------------+\n+   | \\x548c                            |\n+   +-----------------------------------+", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3NzYwNw==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368977607", "bodyText": "By defining a encode and decode function to the Format enum itself, this switch statement can be eliminated which improves performance.\nAlso the error handling should be improved, like e.g. catching the not-found enum.valueOf exception and turn it into a user friendly \"Format 'foo' not supported\" exception.", "author": "seut", "createdAt": "2020-01-21T12:41:52Z", "path": "sql/src/main/java/io/crate/expression/scalar/string/EncodeDecodeFunction.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.common.Hex;\n+import io.crate.common.Octal;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.arithmetic.BinaryScalar;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.types.DataTypes;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Locale;\n+import java.util.function.BinaryOperator;\n+\n+public class EncodeDecodeFunction {\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(new BinaryScalar<>(new Encode(), \"encode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+        module.register(new BinaryScalar<>(new Decode(), \"decode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+    }\n+\n+    /**\n+     * Takes a binary data of \"bytea\" type and encodes it into the given output format.\n+     */\n+    private static class Encode implements BinaryOperator<String> {\n+\n+        @Override\n+        public String apply(String bytea, String format) {\n+            switch (Format.valueOf(format.toUpperCase(Locale.ROOT))) {\n+                case BASE64:\n+                    final byte[] text;\n+                    if (Hex.isHexFormat(bytea)) {\n+                        text = Hex.decodeHex(Hex.stripHexFormatFlag(bytea));\n+                    } else {\n+                        text = Octal.decode(bytea);\n+                    }\n+                    return Base64.getEncoder().encodeToString(text);\n+                case HEX:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        // the input is already in hex format\n+                        return Hex.validateHex(Hex.stripHexFormatFlag(bytea));\n+                    }\n+                    return Hex.encodeHexString(Octal.decode(bytea));\n+                case ESCAPE:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        return Octal.encode(Hex.decodeHex(Hex.stripHexFormatFlag(bytea)));\n+                    }\n+                    return Octal.encode(bytea.getBytes(StandardCharsets.UTF_8));\n+                default:\n+                    // should not happen\n+                    throw new RuntimeException();", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3ODIyOQ==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368978229", "bodyText": "I think using string concatenation is faster and cheaper here than using the string format.", "author": "seut", "createdAt": "2020-01-21T12:43:24Z", "path": "sql/src/main/java/io/crate/expression/scalar/string/EncodeDecodeFunction.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.common.Hex;\n+import io.crate.common.Octal;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.arithmetic.BinaryScalar;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.types.DataTypes;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Locale;\n+import java.util.function.BinaryOperator;\n+\n+public class EncodeDecodeFunction {\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(new BinaryScalar<>(new Encode(), \"encode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+        module.register(new BinaryScalar<>(new Decode(), \"decode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+    }\n+\n+    /**\n+     * Takes a binary data of \"bytea\" type and encodes it into the given output format.\n+     */\n+    private static class Encode implements BinaryOperator<String> {\n+\n+        @Override\n+        public String apply(String bytea, String format) {\n+            switch (Format.valueOf(format.toUpperCase(Locale.ROOT))) {\n+                case BASE64:\n+                    final byte[] text;\n+                    if (Hex.isHexFormat(bytea)) {\n+                        text = Hex.decodeHex(Hex.stripHexFormatFlag(bytea));\n+                    } else {\n+                        text = Octal.decode(bytea);\n+                    }\n+                    return Base64.getEncoder().encodeToString(text);\n+                case HEX:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        // the input is already in hex format\n+                        return Hex.validateHex(Hex.stripHexFormatFlag(bytea));\n+                    }\n+                    return Hex.encodeHexString(Octal.decode(bytea));\n+                case ESCAPE:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        return Octal.encode(Hex.decodeHex(Hex.stripHexFormatFlag(bytea)));\n+                    }\n+                    return Octal.encode(bytea.getBytes(StandardCharsets.UTF_8));\n+                default:\n+                    // should not happen\n+                    throw new RuntimeException();\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Takes a string encoded into the given format and returns its hexadecimal representation.\n+     */\n+    private static class Decode implements BinaryOperator<String> {\n+\n+        @Override\n+        public String apply(String text, String format) {\n+            final byte[] value;\n+\n+            switch (Format.valueOf(format.toUpperCase(Locale.ROOT))) {\n+                case BASE64:\n+                    value = Base64.getDecoder().decode(text.getBytes(StandardCharsets.UTF_8));\n+                    break;\n+                case HEX:\n+                    // text is already in hex format\n+                    return String.format(Locale.ROOT, \"%s%s\", Hex.HEX_FLAG, Hex.validateHex(text));", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3ODQxMA==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368978410", "bodyText": "Also here, string concatenation should be faster and cheaper.", "author": "seut", "createdAt": "2020-01-21T12:43:50Z", "path": "sql/src/main/java/io/crate/expression/scalar/string/EncodeDecodeFunction.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.common.Hex;\n+import io.crate.common.Octal;\n+import io.crate.expression.scalar.ScalarFunctionModule;\n+import io.crate.expression.scalar.arithmetic.BinaryScalar;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.types.DataTypes;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.Locale;\n+import java.util.function.BinaryOperator;\n+\n+public class EncodeDecodeFunction {\n+\n+    public static void register(ScalarFunctionModule module) {\n+        module.register(new BinaryScalar<>(new Encode(), \"encode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+        module.register(new BinaryScalar<>(new Decode(), \"decode\", DataTypes.STRING, FunctionInfo.DETERMINISTIC_ONLY));\n+    }\n+\n+    /**\n+     * Takes a binary data of \"bytea\" type and encodes it into the given output format.\n+     */\n+    private static class Encode implements BinaryOperator<String> {\n+\n+        @Override\n+        public String apply(String bytea, String format) {\n+            switch (Format.valueOf(format.toUpperCase(Locale.ROOT))) {\n+                case BASE64:\n+                    final byte[] text;\n+                    if (Hex.isHexFormat(bytea)) {\n+                        text = Hex.decodeHex(Hex.stripHexFormatFlag(bytea));\n+                    } else {\n+                        text = Octal.decode(bytea);\n+                    }\n+                    return Base64.getEncoder().encodeToString(text);\n+                case HEX:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        // the input is already in hex format\n+                        return Hex.validateHex(Hex.stripHexFormatFlag(bytea));\n+                    }\n+                    return Hex.encodeHexString(Octal.decode(bytea));\n+                case ESCAPE:\n+                    if (Hex.isHexFormat(bytea)) {\n+                        return Octal.encode(Hex.decodeHex(Hex.stripHexFormatFlag(bytea)));\n+                    }\n+                    return Octal.encode(bytea.getBytes(StandardCharsets.UTF_8));\n+                default:\n+                    // should not happen\n+                    throw new RuntimeException();\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Takes a string encoded into the given format and returns its hexadecimal representation.\n+     */\n+    private static class Decode implements BinaryOperator<String> {\n+\n+        @Override\n+        public String apply(String text, String format) {\n+            final byte[] value;\n+\n+            switch (Format.valueOf(format.toUpperCase(Locale.ROOT))) {\n+                case BASE64:\n+                    value = Base64.getDecoder().decode(text.getBytes(StandardCharsets.UTF_8));\n+                    break;\n+                case HEX:\n+                    // text is already in hex format\n+                    return String.format(Locale.ROOT, \"%s%s\", Hex.HEX_FLAG, Hex.validateHex(text));\n+                case ESCAPE:\n+                    value = Octal.decode(text);\n+                    break;\n+                default:\n+                    // should not happen\n+                    throw new RuntimeException();\n+            }\n+            assert value != null;\n+            return String.format(Locale.ROOT, \"%s%s\", Hex.HEX_FLAG, Hex.encodeHexString(value));", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3ODY4OQ==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368978689", "bodyText": "I suggest to use the expectedException rule everywhere inside this suite to also test for a user-friendly error message.", "author": "seut", "createdAt": "2020-01-21T12:44:35Z", "path": "sql/src/test/java/io/crate/expression/scalar/string/EncodeDecodeFunctionTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+public class EncodeDecodeFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToBase64() {\n+        assertEvaluate(\"encode('\\\\xfh', 'base64')\", null);", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3OTQ1Mg==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368979452", "bodyText": "please use expectedException rule here instead (don't use System.out anyway, it will bypass any logging/output suppression inside the test runner)", "author": "seut", "createdAt": "2020-01-21T12:46:13Z", "path": "sql/src/test/java/io/crate/expression/scalar/string/EncodeDecodeFunctionTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+public class EncodeDecodeFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToBase64() {\n+        assertEvaluate(\"encode('\\\\xfh', 'base64')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToHex() {\n+        assertEvaluate(\"encode('\\\\xfh', 'hex')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToEscape() {\n+        assertEvaluate(\"encode('\\\\xfh', 'escape')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryDecodeFromHex1() {\n+        assertEvaluate(\"decode('\\\\xff', 'hex')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryDecodeFromHex2() {\n+        assertEvaluate(\"decode('ffa', 'hex')\", null);\n+    }\n+\n+    @Test\n+    public void testUnknownFormat() {\n+        try {\n+            assertEvaluate(\"encode('\\\\xff', 'bad')\", null);", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQyMjMxMw==", "url": "https://github.com/crate/crate/pull/9540#discussion_r369422313", "bodyText": "My bad, the sysout was not meant to be commited.", "author": "scampi", "createdAt": "2020-01-22T08:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3OTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3OTg0NA==", "url": "https://github.com/crate/crate/pull/9540#discussion_r368979844", "bodyText": "I think we should add a encode/decode test for NULL values", "author": "seut", "createdAt": "2020-01-21T12:47:05Z", "path": "sql/src/test/java/io/crate/expression/scalar/string/EncodeDecodeFunctionTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.scalar.string;\n+\n+import io.crate.expression.scalar.AbstractScalarFunctionsTest;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.types.DataTypes;\n+import org.junit.Test;\n+\n+public class EncodeDecodeFunctionTest extends AbstractScalarFunctionsTest {\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToBase64() {\n+        assertEvaluate(\"encode('\\\\xfh', 'base64')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToHex() {\n+        assertEvaluate(\"encode('\\\\xfh', 'hex')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryEncodeToEscape() {\n+        assertEvaluate(\"encode('\\\\xfh', 'escape')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryDecodeFromHex1() {\n+        assertEvaluate(\"decode('\\\\xff', 'hex')\", null);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testInvalidBinaryDecodeFromHex2() {\n+        assertEvaluate(\"decode('ffa', 'hex')\", null);\n+    }\n+\n+    @Test\n+    public void testUnknownFormat() {\n+        try {\n+            assertEvaluate(\"encode('\\\\xff', 'bad')\", null);\n+            fail(\"Should fail on unknown format\");\n+        } catch (IllegalArgumentException e) {\n+            System.out.println(\"e = \" + e);\n+        }\n+        try {\n+            assertEvaluate(\"decode('FA==', 'bad')\", null);\n+            fail(\"Should fail on unknown format\");\n+        } catch (IllegalArgumentException e) {\n+            System.out.println(\"e = \" + e);\n+        }\n+    }\n+\n+    @Test\n+    public void testEncodeFuncBase64() {\n+        // input in hex format\n+        final Literal<Object> name = Literal.of(DataTypes.STRING, \"\\\\x3132330001\");\n+        assertEvaluate(\"encode('\\\\x3132330001', 'base64')\", \"MTIzAAE=\");\n+        assertEvaluate(\"encode(name, 'Base64')\", \"MTIzAAE=\", name);\n+        // input in escape format\n+        assertEvaluate(\"encode('123\\\\000\\\\001', 'base64')\", \"MTIzAAE=\");\n+        assertEvaluate(\"encode('123', 'base64')\", \"MTIz\");\n+    }\n+\n+    @Test\n+    public void testDecodeFuncBase64() {\n+        final Literal<Object> name = Literal.of(DataTypes.STRING, \"MTIzAAE=\");\n+        assertEvaluate(\"decode('MTIzAAE=', 'base64')\", \"\\\\x3132330001\");\n+        assertEvaluate(\"decode('MTIzAAE=', 'BASE64')\", \"\\\\x3132330001\");\n+        assertEvaluate(\"decode(name, 'base64')\", \"\\\\x3132330001\", name);\n+    }\n+\n+    @Test\n+    public void testEncodeFuncHex() {\n+        assertEvaluate(\"encode('\\\\x3132330001', 'hex')\", \"3132330001\");\n+        assertEvaluate(\"encode('123\\\\000\\\\001', 'hex')\", \"3132330001\");\n+    }\n+\n+    @Test\n+    public void testDecodeFuncHex() {\n+        assertEvaluate(\"decode('3132330001', 'hex')\", \"\\\\x3132330001\");\n+    }\n+\n+    @Test\n+    public void testEncodeEmpties() {\n+        assertEvaluate(\"encode('', 'base64')\", \"\");\n+        assertEvaluate(\"encode('', 'hex')\", \"\");\n+        assertEvaluate(\"encode('', 'escape')\", \"\");\n+    }\n+\n+    @Test\n+    public void testEncodeFuncEscape() {\n+        assertEvaluate(\"encode('a\\bb\\\\c', 'escape')\", \"a\\\\010b\\\\\\\\c\");\n+        assertEvaluate(\"encode('\\\\x6108625c63', 'escape')\", \"a\\\\010b\\\\\\\\c\");\n+    }\n+\n+    @Test\n+    public void testDecodeFuncEscape() {\n+        assertEvaluate(\"decode('a\\\\010b\\\\\\\\c', 'escape')\", \"\\\\x6108625c63\");\n+    }\n+", "originalCommit": "1b9d0fb86939648c355d5f2a293cad24d9206445", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dfb374fcfa6d36f5d61a13fe1c7944fb3b5ba3ff", "url": "https://github.com/crate/crate/commit/dfb374fcfa6d36f5d61a13fe1c7944fb3b5ba3ff", "message": "Fix documentation examples of decode/encode", "committedDate": "2020-01-22T19:57:59Z", "type": "forcePushed"}, {"oid": "1c714181ea5605ddf52c98f36941f82e6cad79a1", "url": "https://github.com/crate/crate/commit/1c714181ea5605ddf52c98f36941f82e6cad79a1", "message": "Clarify the decoding of bytea strings in the hex escape format", "committedDate": "2020-01-23T20:28:18Z", "type": "forcePushed"}, {"oid": "5794deaf824534e8d9d38fda3254e7da90c1f787", "url": "https://github.com/crate/crate/commit/5794deaf824534e8d9d38fda3254e7da90c1f787", "message": "Fix handling of the Enum#valueOf exception which swallowed unrelated exceptions", "committedDate": "2020-01-24T13:11:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0MDEwNw==", "url": "https://github.com/crate/crate/pull/9540#discussion_r371240107", "bodyText": "minor nitpick: new changes should be put in top in the related sections. also we use a 80 char line limit in rst files.", "author": "seut", "createdAt": "2020-01-27T13:31:28Z", "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -58,6 +58,8 @@ Changes\n - Introduced new optional ``RETURNING`` clause for :ref:`Update <ref-update>` to\n   return specified values from each row updated.\n \n+- Added the :ref:`encode(bytea, format) <scalar-encode>` and :ref:`decode(text, format) <scalar-decode>` string functions.", "originalCommit": "5794deaf824534e8d9d38fda3254e7da90c1f787", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQzMTkxOA==", "url": "https://github.com/crate/crate/pull/9540#discussion_r371431918", "bodyText": "Fixed in the latest commit I squashed.", "author": "scampi", "createdAt": "2020-01-27T19:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI0MDEwNw=="}], "type": "inlineReview"}, {"oid": "4ec5ffdc3859bbec90f27469a0363fc338b8adcb", "url": "https://github.com/crate/crate/commit/4ec5ffdc3859bbec90f27469a0363fc338b8adcb", "message": "Add encode and decode string functions\n\nEncode takes a binary string in hex format and returns a textual\nrepresentation into the specified format.\nDecode does the opposit and returns the string into hex format.\n\nClose #9539\n\nUpdate changes.txt file\n\nUpdate blob/src/main/java/io/crate/common/Hex.java\n\nCo-Authored-By: Sebastian Utz <su@rtme.net>\n\nUpdate docs/appendices/release-notes/unreleased.rst\n\nCo-Authored-By: Sebastian Utz <su@rtme.net>\n\nImprove error messages\n\nUse string concatenation\n\nAdd encode/decode methods to the Format enum and improve error message on unknown format\n\nAdd tests for null inputs to the encode/decode functions\n\nMove Hex/Octal classes to the shared project\n\nFix documentation examples of decode/encode\n\nFix references to encode/decode in release notes\n\nClarify the decoding of bytea strings in the hex escape format\n\nFix handling of the Enum#valueOf exception which swallowed unrelated exceptions\n\nFormat the new change in the changelog", "committedDate": "2020-01-27T19:15:08Z", "type": "commit"}, {"oid": "4ec5ffdc3859bbec90f27469a0363fc338b8adcb", "url": "https://github.com/crate/crate/commit/4ec5ffdc3859bbec90f27469a0363fc338b8adcb", "message": "Add encode and decode string functions\n\nEncode takes a binary string in hex format and returns a textual\nrepresentation into the specified format.\nDecode does the opposit and returns the string into hex format.\n\nClose #9539\n\nUpdate changes.txt file\n\nUpdate blob/src/main/java/io/crate/common/Hex.java\n\nCo-Authored-By: Sebastian Utz <su@rtme.net>\n\nUpdate docs/appendices/release-notes/unreleased.rst\n\nCo-Authored-By: Sebastian Utz <su@rtme.net>\n\nImprove error messages\n\nUse string concatenation\n\nAdd encode/decode methods to the Format enum and improve error message on unknown format\n\nAdd tests for null inputs to the encode/decode functions\n\nMove Hex/Octal classes to the shared project\n\nFix documentation examples of decode/encode\n\nFix references to encode/decode in release notes\n\nClarify the decoding of bytea strings in the hex escape format\n\nFix handling of the Enum#valueOf exception which swallowed unrelated exceptions\n\nFormat the new change in the changelog", "committedDate": "2020-01-27T19:15:08Z", "type": "forcePushed"}]}