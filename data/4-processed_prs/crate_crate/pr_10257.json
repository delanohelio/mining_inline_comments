{"pr_number": 10257, "pr_title": "Add table function generate_subscripts", "pr_createdAt": "2020-07-22T08:15:47Z", "pr_url": "https://github.com/crate/crate/pull/10257", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzMjM1NA==", "url": "https://github.com/crate/crate/pull/10257#discussion_r458632354", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                cr> SELECT generate_subscripts([NULL,1,NULL,2], 1) AS s;\n          \n          \n            \n                cr> SELECT generate_subscripts([NULL, 1, NULL, 2], 1) AS s;", "author": "norosa", "createdAt": "2020-07-22T08:41:27Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -140,6 +140,54 @@ The return value always matches the ``start`` / ``stop`` types.\n     +---------------+-----------------------------------+\n     SELECT 3 rows in set (... sec)\n \n+.. _table-functions-generate-subscripts:\n+\n+``generate_subscripts(array, dim, [reverse])``\n+==============================================\n+\n+Generate the subscripts for the specified dimension ``dim`` of the given\n+``array``. Zero rows are returned for arrays that do not have the requested\n+dimension, or for NULL arrays (but valid subscripts are returned for NULL\n+array elements).\n+\n+If ``reverse`` is ``true`` the subscripts will be returned in reverse order.\n+\n+::\n+\n+    cr> SELECT generate_subscripts([NULL,1,NULL,2], 1) AS s;", "originalCommit": "1cdb3b7ed966f20291ade27ad2b400137aca1e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzMjQ2MA==", "url": "https://github.com/crate/crate/pull/10257#discussion_r458632460", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                cr> SELECT generate_subscripts([NULL,1,NULL,2], 1, true) AS s;\n          \n          \n            \n                cr> SELECT generate_subscripts([NULL, 1, NULL, 2], 1, true) AS s;", "author": "norosa", "createdAt": "2020-07-22T08:41:38Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -140,6 +140,54 @@ The return value always matches the ``start`` / ``stop`` types.\n     +---------------+-----------------------------------+\n     SELECT 3 rows in set (... sec)\n \n+.. _table-functions-generate-subscripts:\n+\n+``generate_subscripts(array, dim, [reverse])``\n+==============================================\n+\n+Generate the subscripts for the specified dimension ``dim`` of the given\n+``array``. Zero rows are returned for arrays that do not have the requested\n+dimension, or for NULL arrays (but valid subscripts are returned for NULL\n+array elements).\n+\n+If ``reverse`` is ``true`` the subscripts will be returned in reverse order.\n+\n+::\n+\n+    cr> SELECT generate_subscripts([NULL,1,NULL,2], 1) AS s;\n+    +---+\n+    | s |\n+    +---+\n+    | 1 |\n+    | 2 |\n+    | 3 |\n+    | 4 |\n+    +---+\n+    SELECT 4 rows in set (... sec)\n+\n+::\n+\n+    cr> SELECT generate_subscripts([NULL,1,NULL,2], 1, true) AS s;", "originalCommit": "1cdb3b7ed966f20291ade27ad2b400137aca1e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1NzM2MA==", "url": "https://github.com/crate/crate/pull/10257#discussion_r458657360", "bodyText": "I am not sure that stream usage is justified here. It generates the boxed sequence, sorts it if needed, allocates additional unnecessary objects, etc. As an idea, can't we just have two int fields, e.g. from and to that we set depending on the reverse flag, also probably we need the sign, so we know whether we inc or dec or smth similar? Something like that will be definitely more efficient than the current stream API usage.", "author": "kovrus", "createdAt": "2020-07-22T09:22:44Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.IntStream;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+    private static final Comparator<Integer> KEEP_ORDER = (o1, o2) -> 0;\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> nested = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (nested == null || nested.isEmpty()) {\n+                return null;\n+            }\n+            if (!nested.stream().allMatch(e -> e == null || e instanceof List)) {\n+                throw new IllegalArgumentException(\"expected a nested array at level \" + level);\n+            }\n+            List<?> head = (List<?>) nested.get(0);\n+            if (head == null || head.isEmpty()) {\n+                return null;\n+            }\n+            if (!nested.stream().allMatch(e -> e == null || ((List<?>) e).size() == head.size())) {\n+                throw new IllegalArgumentException(\"nested arrays should have the same dimension within a level\");\n+            }\n+            nested = head;\n+        }\n+        return nested;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input<T>... args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+\n+        List<?> array = (List<?>) args[0].value();\n+        if (array == null || array.isEmpty()) {\n+            return () -> NO_RESULTS_ITERATOR;\n+        }\n+        int dim = (Integer) args[1].value();\n+        if (dim <= 0) {\n+            throw new IllegalArgumentException(\"dimension must be greater than zero\");\n+        }\n+        List<?> nestedArray = extractNestedArray(array, dim);\n+        if (nestedArray == null || nestedArray.isEmpty()) {\n+            return () -> NO_RESULTS_ITERATOR;\n+        }\n+        boolean reversed = args.length == 3 && (Boolean) args[2].value();\n+        return () -> new Iterator<>() {\n+\n+            final Object [] columns = new Object[]{ null };\n+            final RowN row = new RowN(columns);\n+            final Iterator<Integer> subscripts = IntStream", "originalCommit": "1cdb3b7ed966f20291ade27ad2b400137aca1e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MDU5OA==", "url": "https://github.com/crate/crate/pull/10257#discussion_r458660598", "bodyText": "The same comment about the stream API usage. It is probably not that necessary to create a new stream object to iterate over a list and do some predicate checks. You can achieve that with the for-loop in a not less concise manner as well.", "author": "kovrus", "createdAt": "2020-07-22T09:28:15Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.IntStream;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+    private static final Comparator<Integer> KEEP_ORDER = (o1, o2) -> 0;\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> nested = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (nested == null || nested.isEmpty()) {\n+                return null;\n+            }\n+            if (!nested.stream().allMatch(e -> e == null || e instanceof List)) {\n+                throw new IllegalArgumentException(\"expected a nested array at level \" + level);\n+            }\n+            List<?> head = (List<?>) nested.get(0);\n+            if (head == null || head.isEmpty()) {\n+                return null;\n+            }\n+            if (!nested.stream().allMatch(e -> e == null || ((List<?>) e).size() == head.size())) {", "originalCommit": "1cdb3b7ed966f20291ade27ad2b400137aca1e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MDczNQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r458660735", "bodyText": "Same here, see the previous comments.", "author": "kovrus", "createdAt": "2020-07-22T09:28:29Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.IntStream;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+    private static final Comparator<Integer> KEEP_ORDER = (o1, o2) -> 0;\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> nested = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (nested == null || nested.isEmpty()) {\n+                return null;\n+            }\n+            if (!nested.stream().allMatch(e -> e == null || e instanceof List)) {", "originalCommit": "1cdb3b7ed966f20291ade27ad2b400137aca1e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MTg4Mg==", "url": "https://github.com/crate/crate/pull/10257#discussion_r458661882", "bodyText": "can we add tests that cover both scenarios?", "author": "kovrus", "createdAt": "2020-07-22T09:30:30Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.IntStream;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+    private static final Comparator<Integer> KEEP_ORDER = (o1, o2) -> 0;\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> nested = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (nested == null || nested.isEmpty()) {\n+                return null;\n+            }\n+            if (!nested.stream().allMatch(e -> e == null || e instanceof List)) {", "originalCommit": "1cdb3b7ed966f20291ade27ad2b400137aca1e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MzE0MA==", "url": "https://github.com/crate/crate/pull/10257#discussion_r458663140", "bodyText": "maybe align this variable. not sure why we need another static field for it.", "author": "kovrus", "createdAt": "2020-07-22T09:32:36Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.IntStream;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+    private static final Comparator<Integer> KEEP_ORDER = (o1, o2) -> 0;\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> nested = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (nested == null || nested.isEmpty()) {\n+                return null;\n+            }\n+            if (!nested.stream().allMatch(e -> e == null || e instanceof List)) {\n+                throw new IllegalArgumentException(\"expected a nested array at level \" + level);\n+            }\n+            List<?> head = (List<?>) nested.get(0);\n+            if (head == null || head.isEmpty()) {\n+                return null;\n+            }\n+            if (!nested.stream().allMatch(e -> e == null || ((List<?>) e).size() == head.size())) {\n+                throw new IllegalArgumentException(\"nested arrays should have the same dimension within a level\");\n+            }\n+            nested = head;\n+        }\n+        return nested;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input<T>... args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+\n+        List<?> array = (List<?>) args[0].value();\n+        if (array == null || array.isEmpty()) {\n+            return () -> NO_RESULTS_ITERATOR;", "originalCommit": "1cdb3b7ed966f20291ade27ad2b400137aca1e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2MzczMg==", "url": "https://github.com/crate/crate/pull/10257#discussion_r458663732", "bodyText": "it is a bit confusing, array becomes nested?", "author": "kovrus", "createdAt": "2020-07-22T09:33:37Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.IntStream;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+    private static final Comparator<Integer> KEEP_ORDER = (o1, o2) -> 0;\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> nested = array;", "originalCommit": "1cdb3b7ed966f20291ade27ad2b400137aca1e74", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2NTExOQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r458665119", "bodyText": "not really related, but i am wondering whether assertions like these still make sense. isn't it already guarded by the func resolving/registration logic?", "author": "kovrus", "createdAt": "2020-07-22T09:35:56Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.IntStream;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+    private static final Comparator<Integer> KEEP_ORDER = (o1, o2) -> 0;\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> nested = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (nested == null || nested.isEmpty()) {\n+                return null;\n+            }\n+            if (!nested.stream().allMatch(e -> e == null || e instanceof List)) {\n+                throw new IllegalArgumentException(\"expected a nested array at level \" + level);\n+            }\n+            List<?> head = (List<?>) nested.get(0);\n+            if (head == null || head.isEmpty()) {\n+                return null;\n+            }\n+            if (!nested.stream().allMatch(e -> e == null || ((List<?>) e).size() == head.size())) {\n+                throw new IllegalArgumentException(\"nested arrays should have the same dimension within a level\");\n+            }\n+            nested = head;\n+        }\n+        return nested;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input<T>... args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";", "originalCommit": "1cdb3b7ed966f20291ade27ad2b400137aca1e74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY3OTc2OA==", "url": "https://github.com/crate/crate/pull/10257#discussion_r458679768", "bodyText": "It is guarded by the function signature, but using assertions like this can be a useful defensive programming technique.\nIt makes explicit that there exists some contract. It can help debugging in case the other component no longer ensures this.\nBut the assertion message could be improved.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n          \n          \n            \n                    assert args.length == 2 || args.length == 3 : \"Signature must ensure that there are either two or three arguments\";", "author": "mfussenegger", "createdAt": "2020-07-22T10:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY2NTExOQ=="}], "type": "inlineReview"}, {"oid": "c495a7fda960fc3178c4312bc53fc118c8660428", "url": "https://github.com/crate/crate/commit/c495a7fda960fc3178c4312bc53fc118c8660428", "message": "Nomi's feedback", "committedDate": "2020-07-22T13:48:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3MzcxNQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459273715", "bodyText": "Maybe add some prose to each example to highlight what the example illustrates.\nOtherwise this looks like a random collection of examples and the reader has to decode the difference between them - which is difficult if you're just trying to learn about the function.", "author": "mfussenegger", "createdAt": "2020-07-23T07:54:33Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -140,6 +140,54 @@ The return value always matches the ``start`` / ``stop`` types.\n     +---------------+-----------------------------------+\n     SELECT 3 rows in set (... sec)\n \n+.. _table-functions-generate-subscripts:\n+\n+``generate_subscripts(array, dim, [reverse])``\n+==============================================\n+\n+Generate the subscripts for the specified dimension ``dim`` of the given\n+``array``. Zero rows are returned for arrays that do not have the requested\n+dimension, or for NULL arrays (but valid subscripts are returned for NULL\n+array elements).\n+\n+If ``reverse`` is ``true`` the subscripts will be returned in reverse order.\n+\n+::\n+\n+    cr> SELECT generate_subscripts([NULL, 1, NULL, 2], 1) AS s;", "originalCommit": "c495a7fda960fc3178c4312bc53fc118c8660428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3NDgyMg==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459274822", "bodyText": "Maybe we should point out that the table function is in the pg_catalog schema somewhere here in the docs", "author": "mfussenegger", "createdAt": "2020-07-23T07:56:46Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -140,6 +140,54 @@ The return value always matches the ``start`` / ``stop`` types.\n     +---------------+-----------------------------------+\n     SELECT 3 rows in set (... sec)\n \n+.. _table-functions-generate-subscripts:\n+\n+``generate_subscripts(array, dim, [reverse])``\n+==============================================\n+\n+Generate the subscripts for the specified dimension ``dim`` of the given", "originalCommit": "c495a7fda960fc3178c4312bc53fc118c8660428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3NTYwNQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459275605", "bodyText": "Could move this check above the previous check, then the oi != null check could be removed as it becomes redundant.", "author": "mfussenegger", "createdAt": "2020-07-23T07:58:21Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> targetArray = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (targetArray == null || targetArray.isEmpty()) {\n+                return null;\n+            }\n+            targetArray = checkAllElementsAreArraysOfConsistentDimension(targetArray, level);\n+        }\n+        return targetArray;\n+    }\n+\n+    private static List<?> checkAllElementsAreArraysOfConsistentDimension(List<?> array, int level) {\n+        int dim = -1;\n+        List<?> firstNonNullElement = null;\n+        for (int i = 0; i < array.size(); i++) {\n+            Object oi = array.get(i);\n+            if (oi != null && !(oi instanceof List)) {\n+                throw new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH,\n+                    \"expected a nested array, or null value at level %d, position %d\",\n+                    level, i + 1));\n+            }\n+            if (oi == null) {", "originalCommit": "c495a7fda960fc3178c4312bc53fc118c8660428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3NjU1OQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459276559", "bodyText": "I think the name doesn't really fit. It implies that it verifies some condition, but also has a return value without indicating what the value is about.", "author": "mfussenegger", "createdAt": "2020-07-23T08:00:12Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> targetArray = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (targetArray == null || targetArray.isEmpty()) {\n+                return null;\n+            }\n+            targetArray = checkAllElementsAreArraysOfConsistentDimension(targetArray, level);\n+        }\n+        return targetArray;\n+    }\n+\n+    private static List<?> checkAllElementsAreArraysOfConsistentDimension(List<?> array, int level) {", "originalCommit": "c495a7fda960fc3178c4312bc53fc118c8660428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3Njg3NQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459276875", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return () -> Collections.emptyIterator();\n          \n          \n            \n                        return List.of();\n          \n      \n    \n    \n  \n\nNo need to create a special supplier/Iterable.", "author": "mfussenegger", "createdAt": "2020-07-23T08:00:51Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> targetArray = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (targetArray == null || targetArray.isEmpty()) {\n+                return null;\n+            }\n+            targetArray = checkAllElementsAreArraysOfConsistentDimension(targetArray, level);\n+        }\n+        return targetArray;\n+    }\n+\n+    private static List<?> checkAllElementsAreArraysOfConsistentDimension(List<?> array, int level) {\n+        int dim = -1;\n+        List<?> firstNonNullElement = null;\n+        for (int i = 0; i < array.size(); i++) {\n+            Object oi = array.get(i);\n+            if (oi != null && !(oi instanceof List)) {\n+                throw new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH,\n+                    \"expected a nested array, or null value at level %d, position %d\",\n+                    level, i + 1));\n+            }\n+            if (oi == null) {\n+                // null is a valid value within an array\n+                continue;\n+            }\n+            List<?> element = (List<?>) oi;\n+            if (dim == -1) {\n+                dim = element.size();\n+            } else {\n+                if (dim != element.size()) {\n+                    throw new IllegalArgumentException(String.format(\n+                        Locale.ENGLISH,\n+                        \"nested arrays must have the same dimension within a level, offending level %d, position %d\",\n+                        level, i + 1));\n+                }\n+            }\n+            if (firstNonNullElement == null) {\n+                firstNonNullElement = element;\n+            }\n+        }\n+        return firstNonNullElement;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input<T>... args) {\n+        assert args.length == 2 || args.length == 3 :\n+            \"Signature must ensure that there are either two or three arguments\";\n+\n+        List<?> array = (List<?>) args[0].value();\n+        if (array == null || array.isEmpty()) {\n+            return () -> Collections.emptyIterator();", "originalCommit": "c495a7fda960fc3178c4312bc53fc118c8660428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3NzIwMQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459277201", "bodyText": "dim == null case needs to be handled as well. This causes a NullPointerException as it is.", "author": "mfussenegger", "createdAt": "2020-07-23T08:01:31Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> targetArray = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (targetArray == null || targetArray.isEmpty()) {\n+                return null;\n+            }\n+            targetArray = checkAllElementsAreArraysOfConsistentDimension(targetArray, level);\n+        }\n+        return targetArray;\n+    }\n+\n+    private static List<?> checkAllElementsAreArraysOfConsistentDimension(List<?> array, int level) {\n+        int dim = -1;\n+        List<?> firstNonNullElement = null;\n+        for (int i = 0; i < array.size(); i++) {\n+            Object oi = array.get(i);\n+            if (oi != null && !(oi instanceof List)) {\n+                throw new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH,\n+                    \"expected a nested array, or null value at level %d, position %d\",\n+                    level, i + 1));\n+            }\n+            if (oi == null) {\n+                // null is a valid value within an array\n+                continue;\n+            }\n+            List<?> element = (List<?>) oi;\n+            if (dim == -1) {\n+                dim = element.size();\n+            } else {\n+                if (dim != element.size()) {\n+                    throw new IllegalArgumentException(String.format(\n+                        Locale.ENGLISH,\n+                        \"nested arrays must have the same dimension within a level, offending level %d, position %d\",\n+                        level, i + 1));\n+                }\n+            }\n+            if (firstNonNullElement == null) {\n+                firstNonNullElement = element;\n+            }\n+        }\n+        return firstNonNullElement;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input<T>... args) {\n+        assert args.length == 2 || args.length == 3 :\n+            \"Signature must ensure that there are either two or three arguments\";\n+\n+        List<?> array = (List<?>) args[0].value();\n+        if (array == null || array.isEmpty()) {\n+            return () -> Collections.emptyIterator();\n+        }\n+        int dim = (Integer) args[1].value();\n+        if (dim <= 0) {", "originalCommit": "c495a7fda960fc3178c4312bc53fc118c8660428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3NzYwMQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459277601", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return () -> Collections.emptyIterator();\n          \n          \n            \n                        return List.of();", "author": "mfussenegger", "createdAt": "2020-07-23T08:02:14Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> targetArray = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (targetArray == null || targetArray.isEmpty()) {\n+                return null;\n+            }\n+            targetArray = checkAllElementsAreArraysOfConsistentDimension(targetArray, level);\n+        }\n+        return targetArray;\n+    }\n+\n+    private static List<?> checkAllElementsAreArraysOfConsistentDimension(List<?> array, int level) {\n+        int dim = -1;\n+        List<?> firstNonNullElement = null;\n+        for (int i = 0; i < array.size(); i++) {\n+            Object oi = array.get(i);\n+            if (oi != null && !(oi instanceof List)) {\n+                throw new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH,\n+                    \"expected a nested array, or null value at level %d, position %d\",\n+                    level, i + 1));\n+            }\n+            if (oi == null) {\n+                // null is a valid value within an array\n+                continue;\n+            }\n+            List<?> element = (List<?>) oi;\n+            if (dim == -1) {\n+                dim = element.size();\n+            } else {\n+                if (dim != element.size()) {\n+                    throw new IllegalArgumentException(String.format(\n+                        Locale.ENGLISH,\n+                        \"nested arrays must have the same dimension within a level, offending level %d, position %d\",\n+                        level, i + 1));\n+                }\n+            }\n+            if (firstNonNullElement == null) {\n+                firstNonNullElement = element;\n+            }\n+        }\n+        return firstNonNullElement;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input<T>... args) {\n+        assert args.length == 2 || args.length == 3 :\n+            \"Signature must ensure that there are either two or three arguments\";\n+\n+        List<?> array = (List<?>) args[0].value();\n+        if (array == null || array.isEmpty()) {\n+            return () -> Collections.emptyIterator();\n+        }\n+        int dim = (Integer) args[1].value();\n+        if (dim <= 0) {\n+            throw new IllegalArgumentException(\"dimension must be greater than zero\");\n+        }\n+        List<?> nestedArray = extractNestedArray(array, dim);\n+        if (nestedArray == null || nestedArray.isEmpty()) {\n+            return () -> Collections.emptyIterator();", "originalCommit": "c495a7fda960fc3178c4312bc53fc118c8660428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3ODAxMA==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459278010", "bodyText": "This raises a NullPointerException if the reversed flag argument is null", "author": "mfussenegger", "createdAt": "2020-07-23T08:03:11Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> targetArray = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (targetArray == null || targetArray.isEmpty()) {\n+                return null;\n+            }\n+            targetArray = checkAllElementsAreArraysOfConsistentDimension(targetArray, level);\n+        }\n+        return targetArray;\n+    }\n+\n+    private static List<?> checkAllElementsAreArraysOfConsistentDimension(List<?> array, int level) {\n+        int dim = -1;\n+        List<?> firstNonNullElement = null;\n+        for (int i = 0; i < array.size(); i++) {\n+            Object oi = array.get(i);\n+            if (oi != null && !(oi instanceof List)) {\n+                throw new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH,\n+                    \"expected a nested array, or null value at level %d, position %d\",\n+                    level, i + 1));\n+            }\n+            if (oi == null) {\n+                // null is a valid value within an array\n+                continue;\n+            }\n+            List<?> element = (List<?>) oi;\n+            if (dim == -1) {\n+                dim = element.size();\n+            } else {\n+                if (dim != element.size()) {\n+                    throw new IllegalArgumentException(String.format(\n+                        Locale.ENGLISH,\n+                        \"nested arrays must have the same dimension within a level, offending level %d, position %d\",\n+                        level, i + 1));\n+                }\n+            }\n+            if (firstNonNullElement == null) {\n+                firstNonNullElement = element;\n+            }\n+        }\n+        return firstNonNullElement;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input<T>... args) {\n+        assert args.length == 2 || args.length == 3 :\n+            \"Signature must ensure that there are either two or three arguments\";\n+\n+        List<?> array = (List<?>) args[0].value();\n+        if (array == null || array.isEmpty()) {\n+            return () -> Collections.emptyIterator();\n+        }\n+        int dim = (Integer) args[1].value();\n+        if (dim <= 0) {\n+            throw new IllegalArgumentException(\"dimension must be greater than zero\");\n+        }\n+        List<?> nestedArray = extractNestedArray(array, dim);\n+        if (nestedArray == null || nestedArray.isEmpty()) {\n+            return () -> Collections.emptyIterator();\n+        }\n+        boolean reversed = args.length == 3 && (Boolean) args[2].value();", "originalCommit": "c495a7fda960fc3178c4312bc53fc118c8660428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3ODk3NQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459278975", "bodyText": "What do you think about extracting parts of the evaluate of generate_series and re-using it here?", "author": "mfussenegger", "createdAt": "2020-07-23T08:05:09Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static List<?> extractNestedArray(List<?> array, int targetLevel) {\n+        List<?> targetArray = array;\n+        for (int level = 2; level <= targetLevel; level++) {\n+            if (targetArray == null || targetArray.isEmpty()) {\n+                return null;\n+            }\n+            targetArray = checkAllElementsAreArraysOfConsistentDimension(targetArray, level);\n+        }\n+        return targetArray;\n+    }\n+\n+    private static List<?> checkAllElementsAreArraysOfConsistentDimension(List<?> array, int level) {\n+        int dim = -1;\n+        List<?> firstNonNullElement = null;\n+        for (int i = 0; i < array.size(); i++) {\n+            Object oi = array.get(i);\n+            if (oi != null && !(oi instanceof List)) {\n+                throw new IllegalArgumentException(String.format(\n+                    Locale.ENGLISH,\n+                    \"expected a nested array, or null value at level %d, position %d\",\n+                    level, i + 1));\n+            }\n+            if (oi == null) {\n+                // null is a valid value within an array\n+                continue;\n+            }\n+            List<?> element = (List<?>) oi;\n+            if (dim == -1) {\n+                dim = element.size();\n+            } else {\n+                if (dim != element.size()) {\n+                    throw new IllegalArgumentException(String.format(\n+                        Locale.ENGLISH,\n+                        \"nested arrays must have the same dimension within a level, offending level %d, position %d\",\n+                        level, i + 1));\n+                }\n+            }\n+            if (firstNonNullElement == null) {\n+                firstNonNullElement = element;\n+            }\n+        }\n+        return firstNonNullElement;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input<T>... args) {\n+        assert args.length == 2 || args.length == 3 :\n+            \"Signature must ensure that there are either two or three arguments\";\n+\n+        List<?> array = (List<?>) args[0].value();\n+        if (array == null || array.isEmpty()) {\n+            return () -> Collections.emptyIterator();\n+        }\n+        int dim = (Integer) args[1].value();\n+        if (dim <= 0) {\n+            throw new IllegalArgumentException(\"dimension must be greater than zero\");\n+        }\n+        List<?> nestedArray = extractNestedArray(array, dim);\n+        if (nestedArray == null || nestedArray.isEmpty()) {\n+            return () -> Collections.emptyIterator();\n+        }\n+        boolean reversed = args.length == 3 && (Boolean) args[2].value();\n+        int lastSubscript = reversed ? 1 : nestedArray.size();\n+        int step = reversed ? -1 : 1;\n+        return () -> new Iterator<>() {\n+\n+            final Object [] columns = new Object[]{ null };\n+            final RowN row = new RowN(columns);\n+            int idx = reversed ? nestedArray.size() : 1;\n+\n+            @Override\n+            public boolean hasNext() {\n+                return reversed ? idx >= lastSubscript : idx <= lastSubscript;\n+            }\n+\n+            @Override\n+            public Row next() {\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException(\"no more rows\");\n+                }\n+                columns[0] = idx;\n+                idx += step;\n+                return row;\n+            }\n+        };\n+    }", "originalCommit": "c495a7fda960fc3178c4312bc53fc118c8660428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTI3OTEzOA==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459279138", "bodyText": "Is subscripts the right field-name?", "author": "mfussenegger", "createdAt": "2020-07-23T08:05:30Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.NoSuchElementException;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(\"subscripts\"));", "originalCommit": "c495a7fda960fc3178c4312bc53fc118c8660428", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e81cc28d1247078627465b401d451658a85895ed", "url": "https://github.com/crate/crate/commit/e81cc28d1247078627465b401d451658a85895ed", "message": "Change the name of the column, because see below:\n\npostgres=# select * from generate_subscripts('{1}'::int[], 1);\n generate_subscripts\n---------------------\n                   1\n(1 row)", "committedDate": "2020-07-23T10:53:18Z", "type": "forcePushed"}, {"oid": "f04cb92e88541c83da692fdfbdbb126b7bf6012b", "url": "https://github.com/crate/crate/commit/f04cb92e88541c83da692fdfbdbb126b7bf6012b", "message": "Two functions that belong to the pg_catalog", "committedDate": "2020-07-23T14:49:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5NDY5OQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459894699", "bodyText": "I wonder if we should actually be a bit more lenient about this and take the longest array at the given dimension?\nIn PostgreSQL this is a limitation of the array type itself:\n=# select array[ array[1, 2],  array[3, 4, 5] ];\nERROR:  2202E: multidimensional arrays must have array expressions with matching dimensions\n\n@kovrus what do you think?", "author": "mfussenegger", "createdAt": "2020-07-24T07:32:43Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -140,6 +140,94 @@ The return value always matches the ``start`` / ``stop`` types.\n     +---------------+-----------------------------------+\n     SELECT 3 rows in set (... sec)\n \n+.. _table-functions-generate-subscripts:\n+\n+``pg_catalog.generate_subscripts(array, dim, [reverse])``\n+=========================================================\n+\n+Generate the subscripts for the specified dimension ``dim`` of the given\n+``array``. Zero rows are returned for arrays that do not have the requested\n+dimension, or for NULL arrays (but valid subscripts are returned for NULL\n+array elements).\n+\n+If ``reverse`` is ``true`` the subscripts will be returned in reverse order.\n+\n+This example takes a one dimensional array of four elements, where elements\n+at positions 1 and 3 are NULL:\n+\n+::\n+\n+    cr> SELECT generate_subscripts([NULL, 1, NULL, 2], 1) AS s;\n+    +---+\n+    | s |\n+    +---+\n+    | 1 |\n+    | 2 |\n+    | 3 |\n+    | 4 |\n+    +---+\n+    SELECT 4 rows in set (... sec)\n+\n+This example returns the reversed list of subscripts for the same array:\n+\n+::\n+\n+    cr> SELECT generate_subscripts([NULL, 1, NULL, 2], 1, true) AS s;\n+    +---+\n+    | s |\n+    +---+\n+    | 4 |\n+    | 3 |\n+    | 2 |\n+    | 1 |\n+    +---+\n+    SELECT 4 rows in set (... sec)\n+\n+The following examples work on an array of three dimensions. Each of the elements\n+within a given level must be either NULL, or an array of the same size as the other\n+arrays within the same level.", "originalCommit": "7483dc4d8ab1c2b5f84815b5cdd3cba88b12ea08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkyNzgwOA==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459927808", "bodyText": "The longest array would result  in index out of bounds errors.\nThe shortest array would result in missing elements.", "author": "marregui", "createdAt": "2020-07-24T08:47:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5NDY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5NTA3MQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459895071", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                cr> select generate_subscripts([[[1],[2]], [[3],[4]], [[4],[5]]], 3) as s;\n          \n          \n            \n                +---+\n          \n          \n            \n                | s |\n          \n          \n            \n                +---+\n          \n          \n            \n                | 1 |\n          \n          \n            \n                +---+\n          \n          \n            \n                SELECT 1 row in set (... sec)\n          \n          \n            \n            \n          \n          \n            \n            ::\n          \n          \n            \n            \n          \n          \n            \n                cr> select generate_subscripts([ [[1], null], [[3], [null]], [null, null]], 3) as s;\n          \n          \n            \n                +---+\n          \n          \n            \n                | s |\n          \n          \n            \n                +---+\n          \n          \n            \n                | 1 |\n          \n          \n            \n                +---+\n          \n          \n            \n                SELECT 1 row in set (... sec)\n          \n          \n            \n            \n          \n          \n            \n            ::\n          \n          \n            \n            \n          \n          \n            \n                cr> select generate_subscripts([ [[1], null], [[3], [null]], [null, null]], 2) as s;\n          \n          \n            \n                +---+\n          \n          \n            \n                | s |\n          \n          \n            \n                +---+\n          \n          \n            \n                | 1 |\n          \n          \n            \n                | 2 |\n          \n          \n            \n                +---+\n          \n          \n            \n                SELECT 2 rows in set (... sec)\n          \n      \n    \n    \n  \n\nI think one example of the multi-dimensional case is enough. We don't need to cover all kind of edge cases or so for documentation purposes.", "author": "mfussenegger", "createdAt": "2020-07-24T07:33:46Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -140,6 +140,94 @@ The return value always matches the ``start`` / ``stop`` types.\n     +---------------+-----------------------------------+\n     SELECT 3 rows in set (... sec)\n \n+.. _table-functions-generate-subscripts:\n+\n+``pg_catalog.generate_subscripts(array, dim, [reverse])``\n+=========================================================\n+\n+Generate the subscripts for the specified dimension ``dim`` of the given\n+``array``. Zero rows are returned for arrays that do not have the requested\n+dimension, or for NULL arrays (but valid subscripts are returned for NULL\n+array elements).\n+\n+If ``reverse`` is ``true`` the subscripts will be returned in reverse order.\n+\n+This example takes a one dimensional array of four elements, where elements\n+at positions 1 and 3 are NULL:\n+\n+::\n+\n+    cr> SELECT generate_subscripts([NULL, 1, NULL, 2], 1) AS s;\n+    +---+\n+    | s |\n+    +---+\n+    | 1 |\n+    | 2 |\n+    | 3 |\n+    | 4 |\n+    +---+\n+    SELECT 4 rows in set (... sec)\n+\n+This example returns the reversed list of subscripts for the same array:\n+\n+::\n+\n+    cr> SELECT generate_subscripts([NULL, 1, NULL, 2], 1, true) AS s;\n+    +---+\n+    | s |\n+    +---+\n+    | 4 |\n+    | 3 |\n+    | 2 |\n+    | 1 |\n+    +---+\n+    SELECT 4 rows in set (... sec)\n+\n+The following examples work on an array of three dimensions. Each of the elements\n+within a given level must be either NULL, or an array of the same size as the other\n+arrays within the same level.\n+\n+::\n+\n+    cr> select generate_subscripts([[[1],[2]], [[3],[4]], [[4],[5]]], 2) as s;\n+    +---+\n+    | s |\n+    +---+\n+    | 1 |\n+    | 2 |\n+    +---+\n+    SELECT 2 rows in set (... sec)\n+\n+::\n+\n+    cr> select generate_subscripts([[[1],[2]], [[3],[4]], [[4],[5]]], 3) as s;\n+    +---+\n+    | s |\n+    +---+\n+    | 1 |\n+    +---+\n+    SELECT 1 row in set (... sec)\n+\n+::\n+\n+    cr> select generate_subscripts([ [[1], null], [[3], [null]], [null, null]], 3) as s;\n+    +---+\n+    | s |\n+    +---+\n+    | 1 |\n+    +---+\n+    SELECT 1 row in set (... sec)\n+\n+::\n+\n+    cr> select generate_subscripts([ [[1], null], [[3], [null]], [null, null]], 2) as s;\n+    +---+\n+    | s |\n+    +---+\n+    | 1 |\n+    | 2 |\n+    +---+\n+    SELECT 2 rows in set (... sec)", "originalCommit": "7483dc4d8ab1c2b5f84815b5cdd3cba88b12ea08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5NTk1OQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459895959", "bodyText": "Why the change to Bucket? This can still be an Iterable, the additional size info of Bucket is not required or used.", "author": "mfussenegger", "createdAt": "2020-07-24T07:36:01Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Bucket;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.function.Function;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(NAME.name()));\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static int getNumRows(List<?> array, int depthLevel) {\n+        if (depthLevel <= 0) {\n+            throw new IllegalArgumentException(\"target level must be greater than zero\");\n+        }\n+        List<?> targetArray = array;\n+        for (int level = 2; level <= depthLevel; level++) {\n+            if (targetArray == null || targetArray.isEmpty()) {\n+                return 0;\n+            }\n+            int size = -1;\n+            List<?> firstNonNullElement = null;\n+            for (int i = 0; i < targetArray.size(); i++) {\n+                Object oi = targetArray.get(i);\n+                if (oi == null) {\n+                    // null is a valid value within an array\n+                    continue;\n+                }\n+                if (!(oi instanceof List)) {\n+                    return 0;\n+                }\n+                List<?> element = (List<?>) oi;\n+                if (size == -1) {\n+                    size = element.size();\n+                } else {\n+                    if (size != element.size()) {\n+                        throw new IllegalArgumentException(String.format(\n+                            Locale.ENGLISH,\n+                            \"nested arrays must have the same dimension within a level, offending level %d, position %d\",\n+                            level, i + 1));\n+                    }\n+                }\n+                if (firstNonNullElement == null) {\n+                    firstNonNullElement = element;\n+                }\n+            }\n+            targetArray = firstNonNullElement;\n+        }\n+        return targetArray != null ? targetArray.size() : 0;\n+    }\n+\n+    @SafeVarargs\n+    @Override\n+    public final Bucket evaluate(TransactionContext txnCtx, Input<T>... args) {", "originalCommit": "7483dc4d8ab1c2b5f84815b5cdd3cba88b12ea08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5NzczOQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459897739", "bodyText": "I think the U extends Number constraint is unecessary, no?\nAlso not sure about the name. I think it emphases the SingleColumn part too much. How about just RangeIterator, SeriesGenerator, or GenerateSeriesIterator ?\nAlso, could this an Iterable? Would make it a bit more powerful", "author": "mfussenegger", "createdAt": "2020-07-24T07:40:16Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/SingleColumnRangeIterator.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+\n+public final class SingleColumnRangeIterator<T, U extends Number> implements Iterator<Row> {", "originalCommit": "7483dc4d8ab1c2b5f84815b5cdd3cba88b12ea08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5Nzk3Nw==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459897977", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                 Function<T, T> stepMutator,\n          \n          \n            \n                                                 Function<T, T> step,\n          \n      \n    \n    \n  \n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                 Function<T, T> stepMutator,\n          \n          \n            \n                                                 Function<T, T> nextValue,\n          \n      \n    \n    \n  \n\nIt's a pure function that shouldn't mutate any state.", "author": "mfussenegger", "createdAt": "2020-07-24T07:40:48Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/SingleColumnRangeIterator.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+\n+public final class SingleColumnRangeIterator<T, U extends Number> implements Iterator<Row> {\n+\n+    private final Object [] columns;\n+    private final RowN row;\n+    private final T endIncluded;\n+    private final Function<T, T> stepMutator;\n+    private final Comparator<T> comparator;\n+    private final Function<T, U> resultExtractor;\n+    private final boolean reversed;\n+    private T idx;\n+\n+    public SingleColumnRangeIterator(T start,\n+                                     T endIncluded,\n+                                     Function<T, T> stepMutator,", "originalCommit": "7483dc4d8ab1c2b5f84815b5cdd3cba88b12ea08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkxOTQyNw==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459919427", "bodyText": "Agreed, this is the fault of my background in clojure.", "author": "marregui", "createdAt": "2020-07-24T08:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5Nzk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTg5ODExNw==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459898117", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public SingleColumnRangeIterator(T start,\n          \n          \n            \n                public SingleColumnRangeIterator(T startInclusive,", "author": "mfussenegger", "createdAt": "2020-07-24T07:41:07Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/SingleColumnRangeIterator.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+\n+public final class SingleColumnRangeIterator<T, U extends Number> implements Iterator<Row> {\n+\n+    private final Object [] columns;\n+    private final RowN row;\n+    private final T endIncluded;\n+    private final Function<T, T> stepMutator;\n+    private final Comparator<T> comparator;\n+    private final Function<T, U> resultExtractor;\n+    private final boolean reversed;\n+    private T idx;\n+\n+    public SingleColumnRangeIterator(T start,", "originalCommit": "7483dc4d8ab1c2b5f84815b5cdd3cba88b12ea08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkwMTc1Mw==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459901753", "bodyText": "Not sure if idx is the right name here. It is not an index into a range, but the actual value.", "author": "mfussenegger", "createdAt": "2020-07-24T07:49:52Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/SingleColumnRangeIterator.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+\n+public final class SingleColumnRangeIterator<T, U extends Number> implements Iterator<Row> {\n+\n+    private final Object [] columns;\n+    private final RowN row;\n+    private final T endIncluded;\n+    private final Function<T, T> stepMutator;\n+    private final Comparator<T> comparator;\n+    private final Function<T, U> resultExtractor;\n+    private final boolean reversed;\n+    private T idx;", "originalCommit": "7483dc4d8ab1c2b5f84815b5cdd3cba88b12ea08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2NTI2MQ==", "url": "https://github.com/crate/crate/pull/10257#discussion_r459965261", "bodyText": "lgtm\nit is a bit hard to follow sometime some var names and messages with them, we have dim, level, target level, depth level, etc. but i am not sure how it can be improved.", "author": "kovrus", "createdAt": "2020-07-24T10:08:10Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/GenerateSubscripts.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.metadata.FunctionName;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.pgcatalog.PgCatalogSchemaInfo;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import static io.crate.metadata.functions.TypeVariableConstraint.typeVariable;\n+import static io.crate.types.DataTypes.INTEGER;\n+import static io.crate.types.TypeSignature.parseTypeSignature;\n+\n+public final class GenerateSubscripts<T> extends TableFunctionImplementation<T> {\n+\n+    public static final FunctionName NAME = new FunctionName(PgCatalogSchemaInfo.NAME, \"generate_subscripts\");\n+    private static final RowType RETURN_TYPE = new RowType(List.of(INTEGER), List.of(NAME.name()));\n+\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                parseTypeSignature(\"array(E)\"),\n+                DataTypes.INTEGER.getTypeSignature(),\n+                DataTypes.BOOLEAN.getTypeSignature(),\n+                DataTypes.INTEGER.getTypeSignature()\n+            ).withTypeVariableConstraints(typeVariable(\"E\")),\n+            GenerateSubscripts::new\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private GenerateSubscripts(Signature signature, Signature boundSignature) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+    }\n+\n+    private static int getNumRows(List<?> array, int depthLevel) {", "originalCommit": "3a806628d79660cc9d63c71597502d3efc1d37bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c8d70e6dcc2ee40828353bb201245960fedb5391", "url": "https://github.com/crate/crate/commit/c8d70e6dcc2ee40828353bb201245960fedb5391", "message": "Add table function generate_subscripts\n\nConvenience function that generates the set of valid subscripts for the\nspecified dimension of the given array. Zero rows are returned for arrays\nthat do not have the requested dimension, or for NULL arrays (but valid\nsubscripts are returned for NULL array elements).", "committedDate": "2020-07-24T10:10:14Z", "type": "commit"}, {"oid": "c8d70e6dcc2ee40828353bb201245960fedb5391", "url": "https://github.com/crate/crate/commit/c8d70e6dcc2ee40828353bb201245960fedb5391", "message": "Add table function generate_subscripts\n\nConvenience function that generates the set of valid subscripts for the\nspecified dimension of the given array. Zero rows are returned for arrays\nthat do not have the requested dimension, or for NULL arrays (but valid\nsubscripts are returned for NULL array elements).", "committedDate": "2020-07-24T10:10:14Z", "type": "forcePushed"}]}