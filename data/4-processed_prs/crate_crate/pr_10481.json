{"pr_number": 10481, "pr_title": "Use doc values aggregators in the group by iterator.", "pr_createdAt": "2020-09-02T14:25:31Z", "pr_url": "https://github.com/crate/crate/pull/10481", "timeline": [{"oid": "5a71405bd7c1088f013a8d336fadd48c2da3dde8", "url": "https://github.com/crate/crate/commit/5a71405bd7c1088f013a8d336fadd48c2da3dde8", "message": "WIP: Use doc values aggregators in group by.", "committedDate": "2020-09-02T15:05:53Z", "type": "forcePushed"}, {"oid": "81930a0e5d7725f854f74735b0268b309137bcbd", "url": "https://github.com/crate/crate/commit/81930a0e5d7725f854f74735b0268b309137bcbd", "message": "WIP: Use doc values aggregators in group by.", "committedDate": "2020-09-03T11:47:00Z", "type": "forcePushed"}, {"oid": "f5b34c4fea03ab27f65926e8ee0b3d86069b329f", "url": "https://github.com/crate/crate/commit/f5b34c4fea03ab27f65926e8ee0b3d86069b329f", "message": "WIP: Use doc values aggregators in group by.", "committedDate": "2020-09-03T14:31:33Z", "type": "forcePushed"}, {"oid": "50ebbee3473dda7c3994e1ffaa9989c71e43b91f", "url": "https://github.com/crate/crate/commit/50ebbee3473dda7c3994e1ffaa9989c71e43b91f", "message": "WIP: Use doc values aggregators in group by.", "committedDate": "2020-09-04T08:17:17Z", "type": "forcePushed"}, {"oid": "7a781f2ce9e0508a1fbbe8f8aca4316b497ee684", "url": "https://github.com/crate/crate/commit/7a781f2ce9e0508a1fbbe8f8aca4316b497ee684", "message": "WIP: Use doc values aggregators in group by.", "committedDate": "2020-09-07T09:43:37Z", "type": "forcePushed"}, {"oid": "36e01218d333bcb2651e43c62e05e00a84f61d0b", "url": "https://github.com/crate/crate/commit/36e01218d333bcb2651e43c62e05e00a84f61d0b", "message": "Use doc values aggregators in the group by iterator.\n\nDocValuesGroupByOptimizedIterator is kicked in when the group by keys and\naggregatefunctions fields utilize doc values. This optimization won't replace\nthe group by a single string key optimization. The optimization uses the\nDocValuesAggregator implementations, if any exists for the used aggregation\nfunctionis signatures, to perform the required aggregations.", "committedDate": "2020-09-07T12:51:11Z", "type": "forcePushed"}, {"oid": "51cdf90b27b898703066979b6ab2e4fb99b0e916", "url": "https://github.com/crate/crate/commit/51cdf90b27b898703066979b6ab2e4fb99b0e916", "message": "Use doc values aggregators in the group by iterator.\n\nDocValuesGroupByOptimizedIterator is kicked in when the group by keys and\naggregatefunctions fields utilize doc values. This optimization won't replace\nthe group by a single string key optimization. The optimization uses the\nDocValuesAggregator implementations, if any exists for the used aggregation\nfunctionis signatures, to perform the required aggregations.\n\nV1: 4.3.0-91eab4079418606c6800b03f9b438adabb1cb7f4\nV2: 4.3.0-7a781f2ce9e0508a1fbbe8f8aca4316b497ee684\n\nQ: select avg(\"adRevenue\"), sum(\"adRevenue\"), min(\"adRevenue\") from uservisits group by \"duration\"\nC: 10\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      638.100 \u00b1  325.566 |    211.815 |    482.160 |    932.585 |   3125.512 |\n|   V2    |      373.246 \u00b1  196.211 |    124.022 |    277.423 |    549.255 |   1615.749 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  52.38%                           -  53.91%\nThere is a 100.00% probability that the observed difference is not random, and the best estimate of that difference is 52.38%\nThe test has statistical significance\n\nQ: select avg(\"adRevenue\") from uservisits group by \"duration\"\nC: 10\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      452.103 \u00b1  218.103 |    151.666 |    345.346 |    667.845 |   1006.138 |\n|   V2    |      185.711 \u00b1   85.982 |     53.151 |    145.821 |    266.296 |    450.111 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  83.53%                           -  81.25%\nThere is a 100.00% probability that the observed difference is not random, and the best estimate of that difference is 83.53%\nThe test has statistical significance\n\nQ: select avg(\"adRevenue\") from uservisits group by \"cCode\", \"duration\"\nC: 10\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |     2103.870 \u00b1 1050.969 |    497.677 |   1709.958 |   3193.367 |   4763.876 |\n|   V2    |     1859.424 \u00b1  942.139 |    414.991 |   1486.976 |   2866.043 |   3878.281 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  12.34%                           -  13.95%\nThere is a 100.00% probability that the observed difference is not random, and the best estimate of that difference is 12.34%\nThe test has statistical significance\n\nQ: select \"cCode\", avg(\"adRevenue\") from uservisits group by \"cCode\"\nC: 15\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      381.050 \u00b1  208.475 |    104.771 |    396.171 |    480.988 |   1456.100 |\n|   V2    |      416.578 \u00b1  230.937 |    111.100 |    421.884 |    525.586 |   1559.578 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               +   8.91%                           +   6.29%\nThere is a 98.92% probability that the observed difference is not random, and the best estimate of that difference is 8.91%\nThe test has statistical significance\n\nQ: select \"cCode\", count(*) from uservisits group by \"cCode\"\nC: 15\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      436.798 \u00b1  612.384 |     54.301 |    187.792 |    264.789 |   2168.169 |\n|   V2    |      394.126 \u00b1  455.784 |     47.463 |    236.423 |    321.290 |   1533.854 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  10.27%                           +  22.93%\nThere is a 42.32% probability that the observed difference is not random, and the best estimate of that difference is 10.27%\nThe test has no statistical significance\n\nSystem/JVM Metrics (durations in ms, byte-values in MB)\n    |    YOUNG GC            |       OLD GC           |      HEAP         |     ALLOC\n    |  cnt      avg      max |  cnt      avg      max |  initial     used |     rate      total\n V1 |  218     2.60     1.91 |    0     0.00     0.00 |     2147      123 |  2092.40     278781\n V2 |  262     2.60     1.76 |    0     0.00     0.00 |     2147       52 |  2113.17     336127\n\nV1 top allocation frames\n  BytesRef.utf8ToString():89196875640\n  StringUTF16.compress(...):55279245409\n  GroupingCollector.evalKeyInputs(List):46236358862\n  Float.valueOf(float):43693361381\n  ArrayList.<init>(int):43296970152\nV2 top allocation frames\n  BytesRef.utf8ToString():121696878465\n  DocValuesGroupByOptimizedIterator$GroupByIterator.lambda$forManyKeys$2(List, List):60725497291\n  StringUTF16.compress(...):60709561912\n  ArrayList.<init>(int):60696946969\n  Float.valueOf(float):30925578229", "committedDate": "2020-09-07T13:39:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ0NzExMQ==", "url": "https://github.com/crate/crate/pull/10481#discussion_r484447111", "bodyText": "there are already pretty many group by integrations tests already.", "author": "kovrus", "createdAt": "2020-09-07T13:57:27Z", "path": "server/src/test/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIteratorTest.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.collect;\n+\n+import io.crate.breaker.RamAccounting;\n+import io.crate.data.BatchIterator;\n+import io.crate.data.Row;\n+import io.crate.execution.engine.aggregation.impl.SumAggregation;\n+import io.crate.expression.reference.doc.lucene.BytesRefColumnReference;\n+import io.crate.expression.reference.doc.lucene.CollectorContext;\n+import io.crate.expression.reference.doc.lucene.LongColumnReference;\n+import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.ReferenceIdent;\n+import io.crate.metadata.RelationName;\n+import io.crate.metadata.RowGranularity;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.test.integration.CrateDummyClusterServiceUnitTest;\n+import io.crate.testing.TestingRowConsumer;\n+import io.crate.types.DataTypes;\n+import org.apache.lucene.document.Document;\n+import org.apache.lucene.document.NumericDocValuesField;\n+import org.apache.lucene.document.SortedSetDocValuesField;\n+import org.apache.lucene.index.DirectoryReader;\n+import org.apache.lucene.index.IndexWriter;\n+import org.apache.lucene.index.IndexWriterConfig;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.store.ByteBuffersDirectory;\n+import org.elasticsearch.common.lucene.BytesRefs;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+\n+import static io.crate.testing.TestingHelpers.createNodeContext;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.instanceOf;\n+\n+public class DocValuesGroupByOptimizedIteratorTest extends CrateDummyClusterServiceUnitTest {", "originalCommit": "51cdf90b27b898703066979b6ab2e4fb99b0e916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ0NjM1NA==", "url": "https://github.com/crate/crate/pull/10481#discussion_r484446354", "bodyText": "I wonder if we have a potential double-close issue here. I think after the collectTask.addSearcher(sharedShardContext.readerId(), searcher); call the searcher will be closed as part of the collectTask.\nThis is probably also the case in the other places where we have the same setup pattern - so may not be exclusively to this PR now and we can also follow up on it later.", "author": "mfussenegger", "createdAt": "2020-09-07T13:56:03Z", "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.collect;\n+\n+import io.crate.breaker.MultiSizeEstimator;\n+import io.crate.breaker.RamAccounting;\n+import io.crate.breaker.SizeEstimatorFactory;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.common.collections.Lists2;\n+import io.crate.data.BatchIterator;\n+import io.crate.data.CollectingBatchIterator;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.exceptions.Exceptions;\n+import io.crate.execution.dsl.phases.RoutedCollectPhase;\n+import io.crate.execution.dsl.projection.GroupProjection;\n+import io.crate.execution.dsl.projection.Projection;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.execution.engine.aggregation.GroupByMaps;\n+import io.crate.execution.jobs.SharedShardContext;\n+import io.crate.expression.InputFactory;\n+import io.crate.expression.reference.doc.lucene.CollectorContext;\n+import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;\n+import io.crate.expression.symbol.AggregateMode;\n+import io.crate.expression.symbol.InputColumn;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.lucene.FieldTypeLookup;\n+import io.crate.lucene.LuceneQueryBuilder;\n+import io.crate.metadata.DocReferences;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.doc.DocSysColumns;\n+import io.crate.metadata.doc.DocTableInfo;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.Weight;\n+import org.apache.lucene.util.Bits;\n+import org.elasticsearch.index.engine.Engine;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+\n+import static io.crate.execution.dsl.projection.Projections.shardProjections;\n+import static io.crate.execution.engine.collect.LuceneShardCollectorProvider.formatSource;\n+\n+final class DocValuesGroupByOptimizedIterator {\n+\n+    @Nullable\n+    static BatchIterator<Row> tryOptimize(Functions functions,\n+                                          IndexShard indexShard,\n+                                          DocTableInfo table,\n+                                          LuceneQueryBuilder luceneQueryBuilder,\n+                                          FieldTypeLookup fieldTypeLookup,\n+                                          DocInputFactory docInputFactory,\n+                                          RoutedCollectPhase collectPhase,\n+                                          CollectTask collectTask) {\n+        Collection<? extends Projection> shardProjections = shardProjections(collectPhase.projections());\n+        GroupProjection groupProjection = getSinglePartialGroupProjection(shardProjections);\n+        if (groupProjection == null) {\n+            return null;\n+        }\n+\n+        ArrayList<Reference> docKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var key : groupProjection.keys()) {\n+            var keyRef = getKeyRef(collectPhase.toCollect(), key);\n+            if (keyRef == null) {\n+                return null; // group by on non-reference\n+            } else {\n+                docKeyRefs.add(keyRef);\n+            }\n+        }\n+\n+        ArrayList<Reference> columnKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var keyRef : docKeyRefs) {\n+            var keyColumnRef = (Reference) DocReferences.inverseSourceLookup(keyRef);\n+            MappedFieldType keyFieldType = fieldTypeLookup.get(keyRef.column().fqn());\n+            if (keyFieldType == null || !keyFieldType.hasDocValues()) {\n+                return null;\n+            } else {\n+                columnKeyRefs.add(keyColumnRef);\n+            }\n+        }\n+\n+        //noinspection rawtypes\n+        List<DocValueAggregator> aggregators = DocValuesAggregates.createAggregators(\n+            functions,\n+            groupProjection.values(),\n+            fieldTypeLookup,\n+            collectPhase.toCollect(),\n+            collectTask.txnCtx().sessionSettings().searchPath()\n+        );\n+        if (aggregators == null) {\n+            return null;\n+        }\n+\n+        if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)\n+            || Symbols.containsColumn(collectPhase.where(), DocSysColumns.SCORE)) {\n+            return null;\n+        }\n+\n+        ShardId shardId = indexShard.shardId();\n+        SharedShardContext sharedShardContext = collectTask.sharedShardContexts().getOrCreateContext(shardId);\n+        Engine.Searcher searcher = sharedShardContext.acquireSearcher(formatSource(collectPhase));\n+\n+        try {\n+            QueryShardContext queryShardContext = sharedShardContext.indexService().newQueryShardContext();\n+            collectTask.addSearcher(sharedShardContext.readerId(), searcher);\n+\n+            InputFactory.Context<? extends LuceneCollectorExpression<?>> docCtx\n+                = docInputFactory.getCtx(collectTask.txnCtx());\n+            docCtx.add(columnKeyRefs);\n+            List<? extends LuceneCollectorExpression<?>> keyExpressions = docCtx.expressions();\n+\n+            LuceneQueryBuilder.Context queryContext = luceneQueryBuilder.convert(\n+                collectPhase.where(),\n+                collectTask.txnCtx(),\n+                indexShard.mapperService(),\n+                indexShard.shardId().getIndexName(),\n+                queryShardContext,\n+                table,\n+                sharedShardContext.indexService().cache()\n+            );\n+\n+            var ramAccounting = collectTask.getRamAccounting();\n+            if (columnKeyRefs.size() == 1) {\n+                return GroupByIterator.forSingleKey(\n+                    aggregators,\n+                    searcher,\n+                    columnKeyRefs.get(0),\n+                    keyExpressions,\n+                    ramAccounting,\n+                    queryContext.query(),\n+                    new CollectorContext(sharedShardContext.readerId())\n+                );\n+            } else {\n+                return GroupByIterator.forManyKeys(\n+                    aggregators,\n+                    searcher,\n+                    columnKeyRefs,\n+                    keyExpressions,\n+                    ramAccounting,\n+                    queryContext.query(),\n+                    new CollectorContext(sharedShardContext.readerId())\n+                );\n+            }\n+        } catch (Throwable t) {\n+            searcher.close();", "originalCommit": "51cdf90b27b898703066979b6ab2e4fb99b0e916", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU2NjEwNA==", "url": "https://github.com/crate/crate/pull/10481#discussion_r484566104", "bodyText": "\ud83d\udc4d added it into the follow-up list. i'll check it later.", "author": "kovrus", "createdAt": "2020-09-07T21:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ0NjM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4NjM3OA==", "url": "https://github.com/crate/crate/pull/10481#discussion_r484486378", "bodyText": "this could be merged-into the loop below and thus would eliminate the docKeyRefs list and would avoid another loop.", "author": "seut", "createdAt": "2020-09-07T15:12:03Z", "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.collect;\n+\n+import io.crate.breaker.MultiSizeEstimator;\n+import io.crate.breaker.RamAccounting;\n+import io.crate.breaker.SizeEstimatorFactory;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.common.collections.Lists2;\n+import io.crate.data.BatchIterator;\n+import io.crate.data.CollectingBatchIterator;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.exceptions.Exceptions;\n+import io.crate.execution.dsl.phases.RoutedCollectPhase;\n+import io.crate.execution.dsl.projection.GroupProjection;\n+import io.crate.execution.dsl.projection.Projection;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.execution.engine.aggregation.GroupByMaps;\n+import io.crate.execution.jobs.SharedShardContext;\n+import io.crate.expression.InputFactory;\n+import io.crate.expression.reference.doc.lucene.CollectorContext;\n+import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;\n+import io.crate.expression.symbol.AggregateMode;\n+import io.crate.expression.symbol.InputColumn;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.lucene.FieldTypeLookup;\n+import io.crate.lucene.LuceneQueryBuilder;\n+import io.crate.metadata.DocReferences;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.doc.DocSysColumns;\n+import io.crate.metadata.doc.DocTableInfo;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.Weight;\n+import org.apache.lucene.util.Bits;\n+import org.elasticsearch.index.engine.Engine;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+\n+import static io.crate.execution.dsl.projection.Projections.shardProjections;\n+import static io.crate.execution.engine.collect.LuceneShardCollectorProvider.formatSource;\n+\n+final class DocValuesGroupByOptimizedIterator {\n+\n+    @Nullable\n+    static BatchIterator<Row> tryOptimize(Functions functions,\n+                                          IndexShard indexShard,\n+                                          DocTableInfo table,\n+                                          LuceneQueryBuilder luceneQueryBuilder,\n+                                          FieldTypeLookup fieldTypeLookup,\n+                                          DocInputFactory docInputFactory,\n+                                          RoutedCollectPhase collectPhase,\n+                                          CollectTask collectTask) {\n+        Collection<? extends Projection> shardProjections = shardProjections(collectPhase.projections());\n+        GroupProjection groupProjection = getSinglePartialGroupProjection(shardProjections);\n+        if (groupProjection == null) {\n+            return null;\n+        }\n+\n+        ArrayList<Reference> docKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var key : groupProjection.keys()) {\n+            var keyRef = getKeyRef(collectPhase.toCollect(), key);\n+            if (keyRef == null) {\n+                return null; // group by on non-reference\n+            } else {\n+                docKeyRefs.add(keyRef);\n+            }\n+        }\n+\n+        ArrayList<Reference> columnKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var keyRef : docKeyRefs) {", "originalCommit": "51cdf90b27b898703066979b6ab2e4fb99b0e916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDQ4NzEwMg==", "url": "https://github.com/crate/crate/pull/10481#discussion_r484487102", "bodyText": "I think this could be checked at the very first to avoid unnecessary logic", "author": "seut", "createdAt": "2020-09-07T15:13:41Z", "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.engine.collect;\n+\n+import io.crate.breaker.MultiSizeEstimator;\n+import io.crate.breaker.RamAccounting;\n+import io.crate.breaker.SizeEstimatorFactory;\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.common.collections.Lists2;\n+import io.crate.data.BatchIterator;\n+import io.crate.data.CollectingBatchIterator;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.exceptions.Exceptions;\n+import io.crate.execution.dsl.phases.RoutedCollectPhase;\n+import io.crate.execution.dsl.projection.GroupProjection;\n+import io.crate.execution.dsl.projection.Projection;\n+import io.crate.execution.engine.aggregation.DocValueAggregator;\n+import io.crate.execution.engine.aggregation.GroupByMaps;\n+import io.crate.execution.jobs.SharedShardContext;\n+import io.crate.expression.InputFactory;\n+import io.crate.expression.reference.doc.lucene.CollectorContext;\n+import io.crate.expression.reference.doc.lucene.LuceneCollectorExpression;\n+import io.crate.expression.symbol.AggregateMode;\n+import io.crate.expression.symbol.InputColumn;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.Symbols;\n+import io.crate.lucene.FieldTypeLookup;\n+import io.crate.lucene.LuceneQueryBuilder;\n+import io.crate.metadata.DocReferences;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.Reference;\n+import io.crate.metadata.doc.DocSysColumns;\n+import io.crate.metadata.doc.DocTableInfo;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.search.DocIdSetIterator;\n+import org.apache.lucene.search.IndexSearcher;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.ScoreMode;\n+import org.apache.lucene.search.Scorer;\n+import org.apache.lucene.search.Weight;\n+import org.apache.lucene.util.Bits;\n+import org.elasticsearch.index.engine.Engine;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.shard.IndexShard;\n+import org.elasticsearch.index.shard.ShardId;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+\n+import static io.crate.execution.dsl.projection.Projections.shardProjections;\n+import static io.crate.execution.engine.collect.LuceneShardCollectorProvider.formatSource;\n+\n+final class DocValuesGroupByOptimizedIterator {\n+\n+    @Nullable\n+    static BatchIterator<Row> tryOptimize(Functions functions,\n+                                          IndexShard indexShard,\n+                                          DocTableInfo table,\n+                                          LuceneQueryBuilder luceneQueryBuilder,\n+                                          FieldTypeLookup fieldTypeLookup,\n+                                          DocInputFactory docInputFactory,\n+                                          RoutedCollectPhase collectPhase,\n+                                          CollectTask collectTask) {\n+        Collection<? extends Projection> shardProjections = shardProjections(collectPhase.projections());\n+        GroupProjection groupProjection = getSinglePartialGroupProjection(shardProjections);\n+        if (groupProjection == null) {\n+            return null;\n+        }\n+\n+        ArrayList<Reference> docKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var key : groupProjection.keys()) {\n+            var keyRef = getKeyRef(collectPhase.toCollect(), key);\n+            if (keyRef == null) {\n+                return null; // group by on non-reference\n+            } else {\n+                docKeyRefs.add(keyRef);\n+            }\n+        }\n+\n+        ArrayList<Reference> columnKeyRefs = new ArrayList<>(groupProjection.keys().size());\n+        for (var keyRef : docKeyRefs) {\n+            var keyColumnRef = (Reference) DocReferences.inverseSourceLookup(keyRef);\n+            MappedFieldType keyFieldType = fieldTypeLookup.get(keyRef.column().fqn());\n+            if (keyFieldType == null || !keyFieldType.hasDocValues()) {\n+                return null;\n+            } else {\n+                columnKeyRefs.add(keyColumnRef);\n+            }\n+        }\n+\n+        //noinspection rawtypes\n+        List<DocValueAggregator> aggregators = DocValuesAggregates.createAggregators(\n+            functions,\n+            groupProjection.values(),\n+            fieldTypeLookup,\n+            collectPhase.toCollect(),\n+            collectTask.txnCtx().sessionSettings().searchPath()\n+        );\n+        if (aggregators == null) {\n+            return null;\n+        }\n+\n+        if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)\n+            || Symbols.containsColumn(collectPhase.where(), DocSysColumns.SCORE)) {", "originalCommit": "51cdf90b27b898703066979b6ab2e4fb99b0e916", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "76cf692f5cb2a8fbd82e5d2c4368f33e167a8f34", "url": "https://github.com/crate/crate/commit/76cf692f5cb2a8fbd82e5d2c4368f33e167a8f34", "message": "fixup! Use doc values aggregators in the group by iterator.", "committedDate": "2020-09-07T20:59:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NTQzMQ==", "url": "https://github.com/crate/crate/pull/10481#discussion_r484685431", "bodyText": "why not as the very first check even before checking for shard projections?", "author": "seut", "createdAt": "2020-09-08T06:44:17Z", "path": "server/src/main/java/io/crate/execution/engine/collect/DocValuesGroupByOptimizedIterator.java", "diffHunk": "@@ -98,24 +97,23 @@\n             return null;\n         }\n \n-        ArrayList<Reference> docKeyRefs = new ArrayList<>(groupProjection.keys().size());\n-        for (var key : groupProjection.keys()) {\n-            var keyRef = getKeyRef(collectPhase.toCollect(), key);\n-            if (keyRef == null) {\n-                return null; // group by on non-reference\n-            } else {\n-                docKeyRefs.add(keyRef);\n-            }\n+        if (Symbols.containsColumn(collectPhase.toCollect(), DocSysColumns.SCORE)", "originalCommit": "76cf692f5cb2a8fbd82e5d2c4368f33e167a8f34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcxMTUyMQ==", "url": "https://github.com/crate/crate/pull/10481#discussion_r484711521", "bodyText": "ah true, changed it and squashed the fixup", "author": "kovrus", "createdAt": "2020-09-08T07:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY4NTQzMQ=="}], "type": "inlineReview"}, {"oid": "daa89c5a4f0160159007745b5c90f6cc5fce582a", "url": "https://github.com/crate/crate/commit/daa89c5a4f0160159007745b5c90f6cc5fce582a", "message": "Use doc values aggregators in the group by iterator.\n\nDocValuesGroupByOptimizedIterator is kicked in when the group by keys and\naggregatefunctions fields utilize doc values. This optimization won't replace\nthe group by a single string key optimization. The optimization uses the\nDocValuesAggregator implementations, if any exists for the used aggregation\nfunctionis signatures, to perform the required aggregations.\n\nV1: 4.3.0-91eab4079418606c6800b03f9b438adabb1cb7f4\nV2: 4.3.0-7a781f2ce9e0508a1fbbe8f8aca4316b497ee684\n\nQ: select avg(\"adRevenue\"), sum(\"adRevenue\"), min(\"adRevenue\") from uservisits group by \"duration\"\nC: 10\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      638.100 \u00b1  325.566 |    211.815 |    482.160 |    932.585 |   3125.512 |\n|   V2    |      373.246 \u00b1  196.211 |    124.022 |    277.423 |    549.255 |   1615.749 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  52.38%                           -  53.91%\nThere is a 100.00% probability that the observed difference is not random, and the best estimate of that difference is 52.38%\nThe test has statistical significance\n\nQ: select avg(\"adRevenue\") from uservisits group by \"duration\"\nC: 10\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      452.103 \u00b1  218.103 |    151.666 |    345.346 |    667.845 |   1006.138 |\n|   V2    |      185.711 \u00b1   85.982 |     53.151 |    145.821 |    266.296 |    450.111 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  83.53%                           -  81.25%\nThere is a 100.00% probability that the observed difference is not random, and the best estimate of that difference is 83.53%\nThe test has statistical significance\n\nQ: select avg(\"adRevenue\") from uservisits group by \"cCode\", \"duration\"\nC: 10\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |     2103.870 \u00b1 1050.969 |    497.677 |   1709.958 |   3193.367 |   4763.876 |\n|   V2    |     1859.424 \u00b1  942.139 |    414.991 |   1486.976 |   2866.043 |   3878.281 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  12.34%                           -  13.95%\nThere is a 100.00% probability that the observed difference is not random, and the best estimate of that difference is 12.34%\nThe test has statistical significance\n\nQ: select \"cCode\", avg(\"adRevenue\") from uservisits group by \"cCode\"\nC: 15\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      381.050 \u00b1  208.475 |    104.771 |    396.171 |    480.988 |   1456.100 |\n|   V2    |      416.578 \u00b1  230.937 |    111.100 |    421.884 |    525.586 |   1559.578 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               +   8.91%                           +   6.29%\nThere is a 98.92% probability that the observed difference is not random, and the best estimate of that difference is 8.91%\nThe test has statistical significance\n\nQ: select \"cCode\", count(*) from uservisits group by \"cCode\"\nC: 15\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      436.798 \u00b1  612.384 |     54.301 |    187.792 |    264.789 |   2168.169 |\n|   V2    |      394.126 \u00b1  455.784 |     47.463 |    236.423 |    321.290 |   1533.854 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  10.27%                           +  22.93%\nThere is a 42.32% probability that the observed difference is not random, and the best estimate of that difference is 10.27%\nThe test has no statistical significance\n\nSystem/JVM Metrics (durations in ms, byte-values in MB)\n    |    YOUNG GC            |       OLD GC           |      HEAP         |     ALLOC\n    |  cnt      avg      max |  cnt      avg      max |  initial     used |     rate      total\n V1 |  218     2.60     1.91 |    0     0.00     0.00 |     2147      123 |  2092.40     278781\n V2 |  262     2.60     1.76 |    0     0.00     0.00 |     2147       52 |  2113.17     336127\n\nV1 top allocation frames\n  BytesRef.utf8ToString():89196875640\n  StringUTF16.compress(...):55279245409\n  GroupingCollector.evalKeyInputs(List):46236358862\n  Float.valueOf(float):43693361381\n  ArrayList.<init>(int):43296970152\nV2 top allocation frames\n  BytesRef.utf8ToString():121696878465\n  DocValuesGroupByOptimizedIterator$GroupByIterator.lambda$forManyKeys$2(List, List):60725497291\n  StringUTF16.compress(...):60709561912\n  ArrayList.<init>(int):60696946969\n  Float.valueOf(float):30925578229", "committedDate": "2020-09-08T07:34:19Z", "type": "commit"}, {"oid": "daa89c5a4f0160159007745b5c90f6cc5fce582a", "url": "https://github.com/crate/crate/commit/daa89c5a4f0160159007745b5c90f6cc5fce582a", "message": "Use doc values aggregators in the group by iterator.\n\nDocValuesGroupByOptimizedIterator is kicked in when the group by keys and\naggregatefunctions fields utilize doc values. This optimization won't replace\nthe group by a single string key optimization. The optimization uses the\nDocValuesAggregator implementations, if any exists for the used aggregation\nfunctionis signatures, to perform the required aggregations.\n\nV1: 4.3.0-91eab4079418606c6800b03f9b438adabb1cb7f4\nV2: 4.3.0-7a781f2ce9e0508a1fbbe8f8aca4316b497ee684\n\nQ: select avg(\"adRevenue\"), sum(\"adRevenue\"), min(\"adRevenue\") from uservisits group by \"duration\"\nC: 10\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      638.100 \u00b1  325.566 |    211.815 |    482.160 |    932.585 |   3125.512 |\n|   V2    |      373.246 \u00b1  196.211 |    124.022 |    277.423 |    549.255 |   1615.749 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  52.38%                           -  53.91%\nThere is a 100.00% probability that the observed difference is not random, and the best estimate of that difference is 52.38%\nThe test has statistical significance\n\nQ: select avg(\"adRevenue\") from uservisits group by \"duration\"\nC: 10\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      452.103 \u00b1  218.103 |    151.666 |    345.346 |    667.845 |   1006.138 |\n|   V2    |      185.711 \u00b1   85.982 |     53.151 |    145.821 |    266.296 |    450.111 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  83.53%                           -  81.25%\nThere is a 100.00% probability that the observed difference is not random, and the best estimate of that difference is 83.53%\nThe test has statistical significance\n\nQ: select avg(\"adRevenue\") from uservisits group by \"cCode\", \"duration\"\nC: 10\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |     2103.870 \u00b1 1050.969 |    497.677 |   1709.958 |   3193.367 |   4763.876 |\n|   V2    |     1859.424 \u00b1  942.139 |    414.991 |   1486.976 |   2866.043 |   3878.281 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  12.34%                           -  13.95%\nThere is a 100.00% probability that the observed difference is not random, and the best estimate of that difference is 12.34%\nThe test has statistical significance\n\nQ: select \"cCode\", avg(\"adRevenue\") from uservisits group by \"cCode\"\nC: 15\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      381.050 \u00b1  208.475 |    104.771 |    396.171 |    480.988 |   1456.100 |\n|   V2    |      416.578 \u00b1  230.937 |    111.100 |    421.884 |    525.586 |   1559.578 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               +   8.91%                           +   6.29%\nThere is a 98.92% probability that the observed difference is not random, and the best estimate of that difference is 8.91%\nThe test has statistical significance\n\nQ: select \"cCode\", count(*) from uservisits group by \"cCode\"\nC: 15\n| Version |         Mean \u00b1    Stdev |        Min |     Median |         Q3 |        Max |\n|   V1    |      436.798 \u00b1  612.384 |     54.301 |    187.792 |    264.789 |   2168.169 |\n|   V2    |      394.126 \u00b1  455.784 |     47.463 |    236.423 |    321.290 |   1533.854 |\n\u251c---------\u2534-------------------------\u2534------------\u2534------------\u2534------------\u2534------------\u2518\n|               -  10.27%                           +  22.93%\nThere is a 42.32% probability that the observed difference is not random, and the best estimate of that difference is 10.27%\nThe test has no statistical significance\n\nSystem/JVM Metrics (durations in ms, byte-values in MB)\n    |    YOUNG GC            |       OLD GC           |      HEAP         |     ALLOC\n    |  cnt      avg      max |  cnt      avg      max |  initial     used |     rate      total\n V1 |  218     2.60     1.91 |    0     0.00     0.00 |     2147      123 |  2092.40     278781\n V2 |  262     2.60     1.76 |    0     0.00     0.00 |     2147       52 |  2113.17     336127\n\nV1 top allocation frames\n  BytesRef.utf8ToString():89196875640\n  StringUTF16.compress(...):55279245409\n  GroupingCollector.evalKeyInputs(List):46236358862\n  Float.valueOf(float):43693361381\n  ArrayList.<init>(int):43296970152\nV2 top allocation frames\n  BytesRef.utf8ToString():121696878465\n  DocValuesGroupByOptimizedIterator$GroupByIterator.lambda$forManyKeys$2(List, List):60725497291\n  StringUTF16.compress(...):60709561912\n  ArrayList.<init>(int):60696946969\n  Float.valueOf(float):30925578229", "committedDate": "2020-09-08T07:34:19Z", "type": "forcePushed"}]}