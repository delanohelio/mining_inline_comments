{"pr_number": 9534, "pr_title": "Add returning clause for sys-update usecase to storage engine", "pr_createdAt": "2020-01-20T12:04:37Z", "pr_url": "https://github.com/crate/crate/pull/9534", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxODM3Mw==", "url": "https://github.com/crate/crate/pull/9534#discussion_r368818373", "bodyText": "Is it safe to mutate the expressions etc in a collector ? Does it have to be threadsafe here ?", "author": "mkleen", "createdAt": "2020-01-21T05:36:30Z", "path": "sql/src/main/java/io/crate/execution/dml/SysUpdateResultSetProjector.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.dml;\n+\n+import io.crate.data.BatchIterator;\n+import io.crate.data.CollectingBatchIterator;\n+import io.crate.data.CollectionBucket;\n+import io.crate.data.Input;\n+import io.crate.data.Projector;\n+import io.crate.data.Row;\n+import io.crate.execution.engine.collect.NestableCollectExpression;\n+import io.crate.expression.InputFactory;\n+import io.crate.expression.reference.StaticTableReferenceResolver;\n+import io.crate.expression.reference.sys.SysRowUpdater;\n+import io.crate.expression.reference.sys.check.node.SysNodeCheck;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.sys.SysNodeChecksTableInfo;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collector;\n+\n+public class SysUpdateResultSetProjector implements Projector {\n+\n+    private final Consumer<Object> rowWriter;\n+    private final List<NestableCollectExpression<SysNodeCheck, ?>> expressions;\n+    private final List<Input<?>> inputs;\n+    private final SysRowUpdater<?> sysRowUpdater;\n+\n+    public SysUpdateResultSetProjector(SysRowUpdater<?> sysRowUpdater,\n+                                       Consumer<Object> rowWriter,\n+                                       Symbol[] returnValues,\n+                                       Functions functions,\n+                                       TransactionContext txnCtx) {\n+        this.sysRowUpdater = sysRowUpdater;\n+        this.rowWriter = rowWriter;\n+        InputFactory.Context<NestableCollectExpression<SysNodeCheck, ?>> cntx = new InputFactory(\n+            functions).ctxForRefs(\n+            txnCtx, new StaticTableReferenceResolver<>(SysNodeChecksTableInfo.expressions()));\n+        cntx.add(List.of(returnValues));\n+        this.expressions = cntx.expressions();\n+        this.inputs = cntx.topLevelInputs();\n+    }\n+\n+    @Override\n+    public BatchIterator<Row> apply(BatchIterator<Row> batchIterator) {\n+        return CollectingBatchIterator\n+            .newInstance(batchIterator,\n+                         Collector.of(\n+                             () -> new State(rowWriter),\n+                             (state, row) -> {\n+                                 Object sysNodeCheckId = row.get(0);\n+                                 //Update sysNodeCheck to the new value\n+                                 state.rowWriter.accept(sysNodeCheckId);\n+                                 //Retrieve updated sysNodeCheck and evaluate return values\n+                                 SysNodeCheck sysNodeCheck = (SysNodeCheck) sysRowUpdater.getRow(sysNodeCheckId);\n+                                 expressions.forEach(x -> x.setNextRow(sysNodeCheck));", "originalCommit": "d18cc2d8efecd83c96a5acf2b1c57bc1351aa11a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MTYyNw==", "url": "https://github.com/crate/crate/pull/9534#discussion_r368861627", "bodyText": "With the current implementation / usage it is safe. But I'd extract the logic into a first class function. (To reduce the amount of indentation here)", "author": "mfussenegger", "createdAt": "2020-01-21T08:23:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxODM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxODcwNQ==", "url": "https://github.com/crate/crate/pull/9534#discussion_r368818705", "bodyText": "This could be merged with UpdateProjection and then dispatched using the ProjectionType to the designated Projector. What do you think ?", "author": "mkleen", "createdAt": "2020-01-21T05:38:13Z", "path": "sql/src/main/java/io/crate/execution/dsl/projection/SysUpdateProjection.java", "diffHunk": "@@ -23,42 +23,98 @@\n package io.crate.execution.dsl.projection;\n \n import io.crate.expression.symbol.InputColumn;\n+import io.crate.expression.symbol.SelectSymbol;\n import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolVisitors;\n import io.crate.expression.symbol.Symbols;\n import io.crate.metadata.Reference;\n import io.crate.metadata.RowGranularity;\n-import io.crate.types.DataType;\n+import io.crate.types.DataTypes;\n+import org.elasticsearch.Version;\n import org.elasticsearch.common.io.stream.StreamInput;\n import org.elasticsearch.common.io.stream.StreamOutput;\n \n+import javax.annotation.Nullable;\n import java.io.IOException;\n+import java.util.Arrays;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n \n-public class SysUpdateProjection extends DMLProjection {\n+public class SysUpdateProjection extends Projection {", "originalCommit": "d18cc2d8efecd83c96a5acf2b1c57bc1351aa11a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg2MDgxOA==", "url": "https://github.com/crate/crate/pull/9534#discussion_r368860818", "bodyText": "I'd keep it separate for now, so we've more flexibility with streaming changes in the future.", "author": "mfussenegger", "createdAt": "2020-01-21T08:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxODcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODgxODk0Nw==", "url": "https://github.com/crate/crate/pull/9534#discussion_r368818947", "bodyText": "I was wondering if it is a good idea to squeeze all the logic from SysUpdateResultSetProjector and SysUpdateProjector into 1 Projector using 2 different Collectors and States.", "author": "mkleen", "createdAt": "2020-01-21T05:39:43Z", "path": "sql/src/main/java/io/crate/execution/dml/SysUpdateResultSetProjector.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.dml;\n+\n+import io.crate.data.BatchIterator;\n+import io.crate.data.CollectingBatchIterator;\n+import io.crate.data.CollectionBucket;\n+import io.crate.data.Input;\n+import io.crate.data.Projector;\n+import io.crate.data.Row;\n+import io.crate.execution.engine.collect.NestableCollectExpression;\n+import io.crate.expression.InputFactory;\n+import io.crate.expression.reference.StaticTableReferenceResolver;\n+import io.crate.expression.reference.sys.SysRowUpdater;\n+import io.crate.expression.reference.sys.check.node.SysNodeCheck;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.sys.SysNodeChecksTableInfo;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collector;\n+\n+public class SysUpdateResultSetProjector implements Projector {", "originalCommit": "d18cc2d8efecd83c96a5acf2b1c57bc1351aa11a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg5NDA4Mw==", "url": "https://github.com/crate/crate/pull/9534#discussion_r368894083", "bodyText": "Btw, if the lambda captures a variable from the outer scope it causes an allocation.\nShouldn't be a problem for updates on system tables, but something to keep in mind for logic that runs in an inner loop.", "author": "mfussenegger", "createdAt": "2020-01-21T09:35:50Z", "path": "sql/src/main/java/io/crate/execution/dml/SysUpdateResultSetProjector.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.execution.dml;\n+\n+import io.crate.data.BatchIterator;\n+import io.crate.data.CollectingBatchIterator;\n+import io.crate.data.CollectionBucket;\n+import io.crate.data.Input;\n+import io.crate.data.Projector;\n+import io.crate.data.Row;\n+import io.crate.execution.engine.collect.NestableCollectExpression;\n+import io.crate.expression.InputFactory;\n+import io.crate.expression.reference.StaticTableReferenceResolver;\n+import io.crate.expression.reference.sys.SysRowUpdater;\n+import io.crate.expression.reference.sys.check.node.SysNodeCheck;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.Functions;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.sys.SysNodeChecksTableInfo;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collector;\n+\n+public class SysUpdateResultSetProjector implements Projector {\n+\n+    private final Consumer<Object> rowWriter;\n+    private final List<NestableCollectExpression<SysNodeCheck, ?>> expressions;\n+    private final List<Input<?>> inputs;\n+    private final SysRowUpdater<?> sysRowUpdater;\n+\n+    public SysUpdateResultSetProjector(SysRowUpdater<?> sysRowUpdater,\n+                                       Consumer<Object> rowWriter,\n+                                       Symbol[] returnValues,\n+                                       Functions functions,\n+                                       TransactionContext txnCtx) {\n+        this.sysRowUpdater = sysRowUpdater;\n+        this.rowWriter = rowWriter;\n+        InputFactory.Context<NestableCollectExpression<SysNodeCheck, ?>> cntx = new InputFactory(\n+            functions).ctxForRefs(\n+            txnCtx, new StaticTableReferenceResolver<>(SysNodeChecksTableInfo.expressions()));\n+        cntx.add(List.of(returnValues));\n+        this.expressions = cntx.expressions();\n+        this.inputs = cntx.topLevelInputs();\n+    }\n+\n+    @Override\n+    public BatchIterator<Row> apply(BatchIterator<Row> batchIterator) {\n+        return CollectingBatchIterator\n+            .newInstance(batchIterator,\n+                         Collector.of(\n+                             ArrayList<Object[]>::new,\n+                             (acc, row) -> {\n+                                 Object[] returnValues = evaluateReturnValues(row);\n+                                 acc.add(returnValues);\n+                             },\n+                             (state1, state2) -> {\n+                                 throw new UnsupportedOperationException(\n+                                     \"Combine not supported\");\n+                             },\n+                             CollectionBucket::new\n+                             ));\n+    }\n+\n+    private Object[] evaluateReturnValues(Row row) {\n+        Object sysNodeCheckId = row.get(0);\n+        //Update sysNodeCheck to the new value\n+        rowWriter.accept(sysNodeCheckId);\n+        //Retrieve updated sysNodeCheck and evaluate return values\n+        SysNodeCheck sysNodeCheck = (SysNodeCheck) sysRowUpdater.getRow(sysNodeCheckId);\n+        expressions.forEach(x -> x.setNextRow(sysNodeCheck));", "originalCommit": "6ecf1bf7f2e9fbc0b41a20010985ce45bfd0afcb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3MzQzMA==", "url": "https://github.com/crate/crate/pull/9534#discussion_r368973430", "bodyText": "Style nitpick and maybe something we should add a checkstyle rule for or change intellij defaults:\nCould put the arguments into a separate line to reduce the level of indentation, so that instead of\n#############################################################################\n                                                      #######################\n                                                      #######################\n                                                      #######################\n                                                      #######################\n                                                      #######################\n                                                      #######################\n                                                      #######################\n                                                      #######################\n\nWe've\n#####################################################\n    #####################\n    #####################\n    #####################\n    ...\n\nMost people tend to read from left to right. Having the arguments further to\nthe left helps with skimming.", "author": "mfussenegger", "createdAt": "2020-01-21T12:31:36Z", "path": "sql/src/main/java/io/crate/planner/consumer/UpdatePlanner.java", "diffHunk": "@@ -184,19 +200,48 @@ private static ExecutionPlan sysUpdate(PlannerContext plannerContext,\n                                            Map<Reference, Symbol> assignmentByTargetCol,\n                                            Symbol query,\n                                            Row params,\n-                                           SubQueryResults subQueryResults) {\n+                                           SubQueryResults subQueryResults,\n+                                           @Nullable List<Symbol> returnValues,\n+                                           @Nullable List<Field> outputFields) {\n         TableInfo tableInfo = table.tableInfo();\n         Reference idReference = requireNonNull(tableInfo.getReference(DocSysColumns.ID), \"Table must have a _id column\");\n-        SysUpdateProjection updateProjection = new SysUpdateProjection(idReference.valueType(), assignmentByTargetCol);\n+        Symbol[] outputSymbols;\n+        if (returnValues == null) {\n+            outputSymbols = new Symbol[]{new InputColumn(0, DataTypes.LONG)};\n+        } else {\n+            outputSymbols = new Symbol[outputFields.size()];\n+            for (int i = 0; i < outputFields.size(); i++) {\n+                outputSymbols[i] = new InputColumn(i, outputFields.get(i).valueType());\n+            }\n+        }\n+        SysUpdateProjection updateProjection = new SysUpdateProjection(new InputColumn(0, idReference.valueType()),", "originalCommit": "6db9148b3539f3e3adb19475091e4df704f6e864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3Nzg2Mw==", "url": "https://github.com/crate/crate/pull/9534#discussion_r368977863", "bodyText": "I fully agree on this.", "author": "mkleen", "createdAt": "2020-01-21T12:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3MzQzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3MzY0NQ==", "url": "https://github.com/crate/crate/pull/9534#discussion_r368973645", "bodyText": "Shouldn't a test like this already exist somewhere?", "author": "mfussenegger", "createdAt": "2020-01-21T12:32:10Z", "path": "sql/src/test/java/io/crate/integrationtests/UpdateIntegrationTest.java", "diffHunk": "@@ -1001,4 +1003,30 @@ public void test_update_by_query_returning_multiple_results() throws Exception {\n         assertThat(response.rows()[1][1], is(3L));\n         assertThat(response.rows()[1][2], is(\"updated\"));\n     }\n+\n+    @Test\n+    public void test_update_sys_tables_returning_count() throws Exception {\n+        execute(\"update sys.node_checks set acknowledged = true where id = 1\");", "originalCommit": "6db9148b3539f3e3adb19475091e4df704f6e864", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3ODQ1OA==", "url": "https://github.com/crate/crate/pull/9534#discussion_r368978458", "bodyText": "You are right, it is SysNodeCheckerIntegrationTest. Thanks for spotting this.", "author": "mkleen", "createdAt": "2020-01-21T12:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk3MzY0NQ=="}], "type": "inlineReview"}, {"oid": "42995ca521aa290e2ca304c647a27f5e05871c2c", "url": "https://github.com/crate/crate/commit/42995ca521aa290e2ca304c647a27f5e05871c2c", "message": "Add implementation for sys-table-update usecase to storage engine", "committedDate": "2020-01-21T13:16:41Z", "type": "forcePushed"}, {"oid": "1a688b8c029130f6feffe8677c7aa6d70368f1a3", "url": "https://github.com/crate/crate/commit/1a688b8c029130f6feffe8677c7aa6d70368f1a3", "message": "Add implementation for sys-table-update usecase to storage engine", "committedDate": "2020-01-21T13:20:09Z", "type": "commit"}, {"oid": "1a688b8c029130f6feffe8677c7aa6d70368f1a3", "url": "https://github.com/crate/crate/commit/1a688b8c029130f6feffe8677c7aa6d70368f1a3", "message": "Add implementation for sys-table-update usecase to storage engine", "committedDate": "2020-01-21T13:20:09Z", "type": "forcePushed"}]}