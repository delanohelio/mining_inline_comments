{"pr_number": 10866, "pr_title": "Improvement: Overhaul arrays and objects DQL docs", "pr_createdAt": "2020-12-14T20:59:26Z", "pr_url": "https://github.com/crate/crate/pull/10866", "timeline": [{"oid": "18142761b57818c7535763f3f29160d1a9a9ce67", "url": "https://github.com/crate/crate/commit/18142761b57818c7535763f3f29160d1a9a9ce67", "message": "Improvement: Overhaul arrays and objects DQL docs", "committedDate": "2020-12-14T22:11:48Z", "type": "forcePushed"}, {"oid": "ca543835467f3947aa9d8c486eda803fe61260cb", "url": "https://github.com/crate/crate/commit/ca543835467f3947aa9d8c486eda803fe61260cb", "message": "Improvement: Overhaul arrays and objects DQL docs", "committedDate": "2020-12-14T22:15:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA3MTEzOA==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545071138", "bodyText": "lint: should be \"table's\"", "author": "justien", "createdAt": "2020-12-17T12:59:22Z", "path": "docs/general/information-schema.rst", "diffHunk": "@@ -288,24 +288,25 @@ table::\n     +-------------------+--------------------------------+-----+--------------------------+\n     | locations         | date                           |   3 | timestamp with time zone |\n     | locations         | description                    |   6 | text                     |\n-    | locations         | id                             |   1 | text                     |\n+    | locations         | id                             |   1 | integer                  |\n     | locations         | information                    |  11 | object_array             |\n     | locations         | information['evolution_level'] |  12 | smallint                 |\n     | locations         | information['population']      |  13 | bigint                   |\n+    | locations         | inhabitants                    |   7 | object                   |\n+    | locations         | inhabitants['description']     |   8 | text                     |\n+    | locations         | inhabitants['interests']       |   9 | text_array               |\n+    | locations         | inhabitants['name']            |  10 | text                     |\n     | locations         | kind                           |   4 | text                     |\n+    | locations         | landmarks                      |  14 | text_array               |\n     | locations         | name                           |   2 | text                     |\n     | locations         | position                       |   5 | integer                  |\n-    | locations         | race                           |   7 | object                   |\n-    | locations         | race['description']            |   8 | text                     |\n-    | locations         | race['interests']              |   9 | text_array               |\n-    | locations         | race['name']                   |  10 | text                     |\n     | partitioned_table | date                           |   3 | timestamp with time zone |\n     | partitioned_table | id                             |   1 | bigint                   |\n     | partitioned_table | title                          |   2 | text                     |\n     | quotes            | id                             |   1 | integer                  |\n     | quotes            | quote                          |   2 | text                     |\n     +-------------------+--------------------------------+-----+--------------------------+\n-    SELECT 18 rows in set (... sec)\n+    SELECT 19 rows in set (... sec)\n \n You can even query this tables' own columns (attention: this might lead to", "originalCommit": "9183582de62081389adb864f48dfc3819ea7fb6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwMDU1Mw==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545800553", "bodyText": "fixed in 3551afc", "author": "norosa", "createdAt": "2020-12-18T12:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTA3MTEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyMTUwMw==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545221503", "bodyText": "Can we keep truncating the result table? I think without, readability gets worse.", "author": "seut", "createdAt": "2020-12-17T16:23:43Z", "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -5,40 +5,46 @@\n Selecting data\n ==============\n \n-Selecting (i.e. retrieving) data from CrateDB is done by using a SQL ``SELECT``\n-statement. The response to a ``SELECT`` query contains the column names of the\n-result, the actual result rows as a two-dimensional array of values, the row\n-count and the duration.\n+Selecting (i.e., retrieving) data from CrateDB can be done by using an SQL\n+``SELECT`` statement. The response to a ``SELECT`` query includes the column\n+names of the result, the result rows as a two-dimensional array of values, the\n+row count, and the execution time.\n+\n+.. SEEALSO::\n+\n+    :ref:`SELECT syntax <sql_reference_select>`\n \n .. rubric:: Table of contents\n \n .. contents::\n    :local:\n \n+\n Introduction\n ============\n \n A simple select::\n \n-    cr> select name, position from locations order by id limit 2;\n-    +-------------------+----------+\n-    | name              | position |\n-    +-------------------+----------+\n-    | North West Ripple | 1        |\n-    | Arkintoofle Minor | 3        |\n-    +-------------------+----------+\n+    cr> select id, name from locations order by id limit 2;\n+    +----+-------------------+\n+    | id | name              |\n+    +----+-------------------+\n+    |  1 | North West Ripple |\n+    |  2 | Outer Eastern Rim |\n+    +----+-------------------+\n     SELECT 2 rows in set (... sec)\n \n If the '*' operator is used, all columns defined in the schema are returned for\n each row::\n \n-    cr> select * from locations order by id limit 1 offset 1;\n-    +----+-------------------+--------------+--------+----------+---------...-+-------...-+-------------+\n-    | id | name              |         date | kind   | position | description | race      | information |\n-    +----+-------------------+--------------+--------+----------+---------...-+-------...-+-------------+\n-    | 10 | Arkintoofle Minor | 308534400000 | Planet |        3 | Motivate... | {\"desc... |        NULL |\n-    +----+-------------------+--------------+--------+----------+---------...-+-------...-+-------------+\n-    SELECT 1 row in set (... sec)\n+    cr> select * from locations order by id limit 2;\n+    +----+-------------------+--------------+--------+----------+--------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------+---------------------------------------------------------------------------------------+-----------+", "originalCommit": "9183582de62081389adb864f48dfc3819ea7fb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyMjI1Nw==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545222257", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            or another ``SELECT`` statement.\n          \n          \n            \n            or another ref:`SELECT <sql_reference_select>` statement.", "author": "seut", "createdAt": "2020-12-17T16:24:42Z", "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -59,8 +65,7 @@ Aliases can be used to change the output name of the columns::\n \n The ``FROM`` clause is used to reference the relation this select query is\n based upon. Can be a single table, many tables, a view, a :ref:`JOIN <sql_joins>`\n-or another ``SELECT`` statement. See :ref:`SELECT Reference\n-<sql_reference_select>`\n+or another ``SELECT`` statement.", "originalCommit": "9183582de62081389adb864f48dfc3819ea7fb6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwMDcwMA==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545800700", "bodyText": "fixed in 3be45f0, 6904221", "author": "norosa", "createdAt": "2020-12-18T12:29:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyMjI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyNDcxOQ==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545224719", "bodyText": "The sections before were about comparison operators, how does a general Arrays section fit here?", "author": "seut", "createdAt": "2020-12-17T16:27:55Z", "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays", "originalCommit": "9183582de62081389adb864f48dfc3819ea7fb6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTgwODYwNA==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545808604", "bodyText": "good point. I moved it because these sections concern operations on arrays, so I figured they should come after the general section on arrays. but you're right that this info should be a part of the general comparison operators\nto solve both issues, I moved the sections up (as suggested) and added a ref to the opening paras of both sections that links to the arrays section so people can jump there if they need to\nfix in 4ce0d3d", "author": "norosa", "createdAt": "2020-12-18T12:45:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyNDcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyNjgzNg==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545226836", "bodyText": "No, you can not nest arrays with in arrays. Defining a columns as array(array(text)) is not supported.", "author": "seut", "createdAt": "2020-12-17T16:30:43Z", "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value", "originalCommit": "9183582de62081389adb864f48dfc3819ea7fb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIyOTUxOA==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545229518", "bodyText": "See my comment above, arrays of arrays are not supported.", "author": "seut", "createdAt": "2020-12-17T16:34:24Z", "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value\n+   per expression. The following won't work:\n \n-The following query can be translated to *get all rows where race['interests']\n-has at least one element that equals 'netball'*::\n+   ``select my_column[1][2] from my_table;``\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 1 row in set (... sec)\n \n-The following query using the negated operator ``!=`` can be translated to *get\n-all rows where race['interests'] has at least one element that does not equal\n-'netball'*. As you see, the result is the same in this case::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' != ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Minories       | [\"baseball\", \"short stories\"]           |\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+.. _sql_dql_objects:\n \n-.. NOTE::\n+Objects\n+=======\n \n-    When using the negated operator ``!= ANY`` by default the maximum size of\n-    the array to operate on is ``8192``. To be able to use larger arrays the\n-    :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n-\n-Negating the ``=`` query from above is totally different. It can be translated\n-to *get all rows where race['interests'] has no value that equals 'netball'*::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where not 'netball' = ANY(race['interests']) order by race['name'];\n-    +--------------+-------------------------------+\n-    | race['name'] | race['interests']             |\n-    +--------------+-------------------------------+\n-    | Minories     | [\"baseball\", \"short stories\"] |\n-    +--------------+-------------------------------+\n+CrateDB supports an :ref:`object <object_data_type>` data type. It is possible\n+to select and query object properties.\n+\n+For example, you might insert an object like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (15, 'Betelgeuse', 2, 'Star System',\n+    ...     {name = 'Betelgeuseans',\n+    ...      description = 'Humanoids with two heads'}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n+\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-.. TIP::\n+The object properties can be selected from the ``inhabitants`` column with\n+``inhabitants['property']``, where ``property`` is the property name, like so::\n \n-    When using ``NOT <value> = ANY(<array_col>)`` the performance of the query\n-    could be quite bad, because special handling is required to implement the\n-    `3-valued logic`_. To achieve better performance, consider using the\n-    :ref:`ignore3vl function<ignore3vl>`.\n+    cr> select name, inhabitants['name'] from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+---------------------+\n+    | name       | inhabitants['name'] |\n+    +------------+---------------------+\n+    | Betelgeuse | Betelgeuseans       |\n+    +------------+---------------------+\n+    SELECT 1 row in set (... sec)\n \n-The same behaviour (though different comparison operations involved) holds true\n-for operators\n+Object property can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n- - ``LIKE`` and ``NOT LIKE``\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants['name'] = 'Betelgeuseans';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n- - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)\n \n-.. NOTE::\n+.. _sql_dql_array_objects:\n \n-    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the\n-    maximum size of the array to operate on is ``8192``. To be able to use\n-    larger arrays the :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n+Arrays within objects\n+=====================\n \n+Objects may contain arrays, and these arrays can be selected and queried.\n \n-.. _sql_dql_objects:\n+For example, you might insert an object containing an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (16, 'Folfanga', 4, 'Star System',\n+    ...     {name = 'A-Rth-Urp-Hil-Ipdenu',\n+    ...      description = 'A species of small slug',\n+    ...      interests = ['lettuce', 'slime']}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n \n-Inner objects and nested objects\n-================================\n+The result::\n \n-CrateDB supports an ``object`` data type, used for simple storing a whole\n-object into a column and it's even possible to select and query for properties\n-of such objects.\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Folfanga';\n+      +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Select a property of an inner object::\n+The child array can be selected as a property of the parent object in the\n+``inhabitants`` column using ``inhabitants['property']``, where ``property`` is\n+the parent object property name, like so::\n+\n+    cr> select name, inhabitants['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+--------------------------+\n+    | name     | inhabitants['interests'] |\n+    +----------+--------------------------+\n+    | Folfanga | [\"lettuce\", \"slime\"]     |\n+    +----------+--------------------------+\n+    SELECT 1 row in set (... sec)\n \n-    cr> select name, race['name'] from locations where name = 'Bartledan';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+The elements of the child array can be selected with\n+``inhabitants[n]['property']``, where ``n`` is the child array index and\n+``property`` is the parent object property name, like so::\n+\n+    cr> select name, inhabitants[1]['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+-----------------------------+\n+    | name     | inhabitants[1]['interests'] |\n+    +----------+-----------------------------+\n+    | Folfanga | lettuce                     |\n+    +----------+-----------------------------+\n     SELECT 1 row in set (... sec)\n \n-Query for a property of an inner object::\n+.. NOTE::\n \n-    cr> select name, race['name'] from locations\n-    ... where race['name'] = 'Bartledannians';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+    When accessing arrays within objects, the child array index comes before\n+    the parent object property name (i.e., ``my_column[n]['property']``), not\n+    the other way around. At the moment, the reverse syntax (i.e.,\n+    ``my_column['property'][n]``) is not supported.\n+\n+    Note also that ``my_column[n]['property']`` syntax can reference the\n+    ``property`` of a child object at index ``n`` of a parent array, if the\n+    column holds :ref:`arrays instead of objects <sql_dql_object_arrays>`. This\n+    makes the syntax `polymorphic`_ (i.e., behavior is inferred from the data\n+    type of the column).\n+\n+    As an alternative, child arrays can be :ref:`type cast\n+    <type_cast_from_string_literal>` to :ref:`text <data-type-text>` if you\n+    want the array index to appear last::\n+\n+        cr> select name, inhabitants['interests']::text[][1] from locations\n+        ... where name = 'Folfanga';\n+        +----------+-----------------------------+\n+        | name     | inhabitants[1]['interests'] |\n+        +----------+-----------------------------+\n+        | Folfanga | lettuce                     |\n+        +----------+-----------------------------+\n+        SELECT 1 row in set (... sec)\n+\n+.. _polymorphic: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\n+\n+The elements of the child array can also be addressed in the :ref:`where\n+clause <sql_dql_where_clause>`, like so::\n+\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants[1]['interests'] = 'lettuce'\n+    ... order by name;\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-Inserting objects::\n+.. NOTE::\n+\n+   You can nest arrays and objects however you like, but you can only have one", "originalCommit": "9183582de62081389adb864f48dfc3819ea7fb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzNDA0OA==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545234048", "bodyText": "Mentioning that this is still possible by my_column[1]['property']::text[][1] is maybe useful?", "author": "seut", "createdAt": "2020-12-17T16:40:23Z", "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value\n+   per expression. The following won't work:\n \n-The following query can be translated to *get all rows where race['interests']\n-has at least one element that equals 'netball'*::\n+   ``select my_column[1][2] from my_table;``\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 1 row in set (... sec)\n \n-The following query using the negated operator ``!=`` can be translated to *get\n-all rows where race['interests'] has at least one element that does not equal\n-'netball'*. As you see, the result is the same in this case::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' != ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Minories       | [\"baseball\", \"short stories\"]           |\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+.. _sql_dql_objects:\n \n-.. NOTE::\n+Objects\n+=======\n \n-    When using the negated operator ``!= ANY`` by default the maximum size of\n-    the array to operate on is ``8192``. To be able to use larger arrays the\n-    :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n-\n-Negating the ``=`` query from above is totally different. It can be translated\n-to *get all rows where race['interests'] has no value that equals 'netball'*::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where not 'netball' = ANY(race['interests']) order by race['name'];\n-    +--------------+-------------------------------+\n-    | race['name'] | race['interests']             |\n-    +--------------+-------------------------------+\n-    | Minories     | [\"baseball\", \"short stories\"] |\n-    +--------------+-------------------------------+\n+CrateDB supports an :ref:`object <object_data_type>` data type. It is possible\n+to select and query object properties.\n+\n+For example, you might insert an object like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (15, 'Betelgeuse', 2, 'Star System',\n+    ...     {name = 'Betelgeuseans',\n+    ...      description = 'Humanoids with two heads'}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n+\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-.. TIP::\n+The object properties can be selected from the ``inhabitants`` column with\n+``inhabitants['property']``, where ``property`` is the property name, like so::\n \n-    When using ``NOT <value> = ANY(<array_col>)`` the performance of the query\n-    could be quite bad, because special handling is required to implement the\n-    `3-valued logic`_. To achieve better performance, consider using the\n-    :ref:`ignore3vl function<ignore3vl>`.\n+    cr> select name, inhabitants['name'] from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+---------------------+\n+    | name       | inhabitants['name'] |\n+    +------------+---------------------+\n+    | Betelgeuse | Betelgeuseans       |\n+    +------------+---------------------+\n+    SELECT 1 row in set (... sec)\n \n-The same behaviour (though different comparison operations involved) holds true\n-for operators\n+Object property can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n- - ``LIKE`` and ``NOT LIKE``\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants['name'] = 'Betelgeuseans';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n- - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)\n \n-.. NOTE::\n+.. _sql_dql_array_objects:\n \n-    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the\n-    maximum size of the array to operate on is ``8192``. To be able to use\n-    larger arrays the :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n+Arrays within objects\n+=====================\n \n+Objects may contain arrays, and these arrays can be selected and queried.\n \n-.. _sql_dql_objects:\n+For example, you might insert an object containing an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (16, 'Folfanga', 4, 'Star System',\n+    ...     {name = 'A-Rth-Urp-Hil-Ipdenu',\n+    ...      description = 'A species of small slug',\n+    ...      interests = ['lettuce', 'slime']}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n \n-Inner objects and nested objects\n-================================\n+The result::\n \n-CrateDB supports an ``object`` data type, used for simple storing a whole\n-object into a column and it's even possible to select and query for properties\n-of such objects.\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Folfanga';\n+      +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Select a property of an inner object::\n+The child array can be selected as a property of the parent object in the\n+``inhabitants`` column using ``inhabitants['property']``, where ``property`` is\n+the parent object property name, like so::\n+\n+    cr> select name, inhabitants['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+--------------------------+\n+    | name     | inhabitants['interests'] |\n+    +----------+--------------------------+\n+    | Folfanga | [\"lettuce\", \"slime\"]     |\n+    +----------+--------------------------+\n+    SELECT 1 row in set (... sec)\n \n-    cr> select name, race['name'] from locations where name = 'Bartledan';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+The elements of the child array can be selected with\n+``inhabitants[n]['property']``, where ``n`` is the child array index and\n+``property`` is the parent object property name, like so::\n+\n+    cr> select name, inhabitants[1]['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+-----------------------------+\n+    | name     | inhabitants[1]['interests'] |\n+    +----------+-----------------------------+\n+    | Folfanga | lettuce                     |\n+    +----------+-----------------------------+\n     SELECT 1 row in set (... sec)\n \n-Query for a property of an inner object::\n+.. NOTE::\n \n-    cr> select name, race['name'] from locations\n-    ... where race['name'] = 'Bartledannians';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+    When accessing arrays within objects, the child array index comes before\n+    the parent object property name (i.e., ``my_column[n]['property']``), not\n+    the other way around. At the moment, the reverse syntax (i.e.,\n+    ``my_column['property'][n]``) is not supported.\n+\n+    Note also that ``my_column[n]['property']`` syntax can reference the\n+    ``property`` of a child object at index ``n`` of a parent array, if the\n+    column holds :ref:`arrays instead of objects <sql_dql_object_arrays>`. This\n+    makes the syntax `polymorphic`_ (i.e., behavior is inferred from the data\n+    type of the column).\n+\n+    As an alternative, child arrays can be :ref:`type cast\n+    <type_cast_from_string_literal>` to :ref:`text <data-type-text>` if you\n+    want the array index to appear last::\n+\n+        cr> select name, inhabitants['interests']::text[][1] from locations\n+        ... where name = 'Folfanga';\n+        +----------+-----------------------------+\n+        | name     | inhabitants[1]['interests'] |\n+        +----------+-----------------------------+\n+        | Folfanga | lettuce                     |\n+        +----------+-----------------------------+\n+        SELECT 1 row in set (... sec)\n+\n+.. _polymorphic: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\n+\n+The elements of the child array can also be addressed in the :ref:`where\n+clause <sql_dql_where_clause>`, like so::\n+\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants[1]['interests'] = 'lettuce'\n+    ... order by name;\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-Inserting objects::\n+.. NOTE::\n+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``", "originalCommit": "9183582de62081389adb864f48dfc3819ea7fb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzNTE0Ng==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545235146", "bodyText": "No, see comment above.", "author": "seut", "createdAt": "2020-12-17T16:41:44Z", "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value\n+   per expression. The following won't work:\n \n-The following query can be translated to *get all rows where race['interests']\n-has at least one element that equals 'netball'*::\n+   ``select my_column[1][2] from my_table;``\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 1 row in set (... sec)\n \n-The following query using the negated operator ``!=`` can be translated to *get\n-all rows where race['interests'] has at least one element that does not equal\n-'netball'*. As you see, the result is the same in this case::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' != ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Minories       | [\"baseball\", \"short stories\"]           |\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+.. _sql_dql_objects:\n \n-.. NOTE::\n+Objects\n+=======\n \n-    When using the negated operator ``!= ANY`` by default the maximum size of\n-    the array to operate on is ``8192``. To be able to use larger arrays the\n-    :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n-\n-Negating the ``=`` query from above is totally different. It can be translated\n-to *get all rows where race['interests'] has no value that equals 'netball'*::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where not 'netball' = ANY(race['interests']) order by race['name'];\n-    +--------------+-------------------------------+\n-    | race['name'] | race['interests']             |\n-    +--------------+-------------------------------+\n-    | Minories     | [\"baseball\", \"short stories\"] |\n-    +--------------+-------------------------------+\n+CrateDB supports an :ref:`object <object_data_type>` data type. It is possible\n+to select and query object properties.\n+\n+For example, you might insert an object like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (15, 'Betelgeuse', 2, 'Star System',\n+    ...     {name = 'Betelgeuseans',\n+    ...      description = 'Humanoids with two heads'}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n+\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-.. TIP::\n+The object properties can be selected from the ``inhabitants`` column with\n+``inhabitants['property']``, where ``property`` is the property name, like so::\n \n-    When using ``NOT <value> = ANY(<array_col>)`` the performance of the query\n-    could be quite bad, because special handling is required to implement the\n-    `3-valued logic`_. To achieve better performance, consider using the\n-    :ref:`ignore3vl function<ignore3vl>`.\n+    cr> select name, inhabitants['name'] from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+---------------------+\n+    | name       | inhabitants['name'] |\n+    +------------+---------------------+\n+    | Betelgeuse | Betelgeuseans       |\n+    +------------+---------------------+\n+    SELECT 1 row in set (... sec)\n \n-The same behaviour (though different comparison operations involved) holds true\n-for operators\n+Object property can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n- - ``LIKE`` and ``NOT LIKE``\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants['name'] = 'Betelgeuseans';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n- - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)\n \n-.. NOTE::\n+.. _sql_dql_array_objects:\n \n-    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the\n-    maximum size of the array to operate on is ``8192``. To be able to use\n-    larger arrays the :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n+Arrays within objects\n+=====================\n \n+Objects may contain arrays, and these arrays can be selected and queried.\n \n-.. _sql_dql_objects:\n+For example, you might insert an object containing an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (16, 'Folfanga', 4, 'Star System',\n+    ...     {name = 'A-Rth-Urp-Hil-Ipdenu',\n+    ...      description = 'A species of small slug',\n+    ...      interests = ['lettuce', 'slime']}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n \n-Inner objects and nested objects\n-================================\n+The result::\n \n-CrateDB supports an ``object`` data type, used for simple storing a whole\n-object into a column and it's even possible to select and query for properties\n-of such objects.\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Folfanga';\n+      +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Select a property of an inner object::\n+The child array can be selected as a property of the parent object in the\n+``inhabitants`` column using ``inhabitants['property']``, where ``property`` is\n+the parent object property name, like so::\n+\n+    cr> select name, inhabitants['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+--------------------------+\n+    | name     | inhabitants['interests'] |\n+    +----------+--------------------------+\n+    | Folfanga | [\"lettuce\", \"slime\"]     |\n+    +----------+--------------------------+\n+    SELECT 1 row in set (... sec)\n \n-    cr> select name, race['name'] from locations where name = 'Bartledan';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+The elements of the child array can be selected with\n+``inhabitants[n]['property']``, where ``n`` is the child array index and\n+``property`` is the parent object property name, like so::\n+\n+    cr> select name, inhabitants[1]['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+-----------------------------+\n+    | name     | inhabitants[1]['interests'] |\n+    +----------+-----------------------------+\n+    | Folfanga | lettuce                     |\n+    +----------+-----------------------------+\n     SELECT 1 row in set (... sec)\n \n-Query for a property of an inner object::\n+.. NOTE::\n \n-    cr> select name, race['name'] from locations\n-    ... where race['name'] = 'Bartledannians';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+    When accessing arrays within objects, the child array index comes before\n+    the parent object property name (i.e., ``my_column[n]['property']``), not\n+    the other way around. At the moment, the reverse syntax (i.e.,\n+    ``my_column['property'][n]``) is not supported.\n+\n+    Note also that ``my_column[n]['property']`` syntax can reference the\n+    ``property`` of a child object at index ``n`` of a parent array, if the\n+    column holds :ref:`arrays instead of objects <sql_dql_object_arrays>`. This\n+    makes the syntax `polymorphic`_ (i.e., behavior is inferred from the data\n+    type of the column).\n+\n+    As an alternative, child arrays can be :ref:`type cast\n+    <type_cast_from_string_literal>` to :ref:`text <data-type-text>` if you\n+    want the array index to appear last::\n+\n+        cr> select name, inhabitants['interests']::text[][1] from locations\n+        ... where name = 'Folfanga';\n+        +----------+-----------------------------+\n+        | name     | inhabitants[1]['interests'] |\n+        +----------+-----------------------------+\n+        | Folfanga | lettuce                     |\n+        +----------+-----------------------------+\n+        SELECT 1 row in set (... sec)\n+\n+.. _polymorphic: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\n+\n+The elements of the child array can also be addressed in the :ref:`where\n+clause <sql_dql_where_clause>`, like so::\n+\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants[1]['interests'] = 'lettuce'\n+    ... order by name;\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-Inserting objects::\n+.. NOTE::\n+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``\n+\n+\n+.. _sql_dql_object_arrays:\n+\n+Object within arrays\n+====================\n \n-    cr> insert into locations (id, name, position, kind, race)\n-    ... values ('DO', 'Dornbirn', 14, 'City', {name='Vorarlberger',\n-    ...     description = 'Very nice people with a strange accent',\n-    ...     interests = ['mountains', 'cheese', 'enzian']}\n+Arrays may contain objects, and these can be selected and queried.\n+\n+For example, you might insert an array of objects like so::\n+\n+    cr> insert into locations (id, name, position, kind, information)\n+    ... values (\n+    ...   17, 'Orion Beta', 3, 'Star System',\n+    ...   [{evolution_level=6, population=3600001},\n+    ...   {evolution_level=42, population=1}]\n     ... );\n     INSERT OK, 1 row affected (... sec)\n \n-.. _sql_dql_object_arrays:\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-Object arrays\n-=============\n+    cr> select name, information from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | name       | information                                                                               |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | Orion Beta | [{\"evolution_level\": 6, \"population\": 3600001}, {\"evolution_level\": 42, \"population\": 1}] |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+The individual child objects can be selected as an element of the parent array\n+in the ``information`` column using ``locations[1]``, where ``n`` is the parent\n+array index, like so::\n+\n+    cr> select name, information[1] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-----------------------------------------------+\n+    | name       | information[1]                                |\n+    +------------+-----------------------------------------------+\n+    | Orion Beta | {\"evolution_level\": 6, \"population\": 3600001} |\n+    +------------+-----------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Arrays in CrateDB can be queried for containment using the\n-:ref:`sql_dql_any_array` operator.\n+The properties of individual child objects can be selected with\n+``locations[n]['property']``, where ``n`` is the parent array index and\n+``property`` is the child property name, like so::\n+\n+    cr> select name, information[1]['population'] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+------------------------------+\n+    | name       | information[1]['population'] |\n+    +------------+------------------------------+\n+    | Orion Beta |                      3600001 |\n+    +------------+------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-It is possible to access fields of :ref:`sql_dql_objects` using subscript\n-expressions. If the parent is an object array, you'll get an array of the\n-selected field.\n+.. NOTE::\n \n+    The ``my_column[n]['property']`` syntax can reference the child array index\n+    ``n`` of a parent object ``property``, if the column holds :ref:`objects\n+    instead of arrays <sql_dql_array_objects>`. This makes the syntax\n+    `polymorphic`_ (i.e., behavior is inferred from the data type of the\n+    column).\n \n-Examples::\n+Additionally, you can query the same ``property`` of *every* object within the\n+array by omitting the array index, like so::\n \n     cr> select name, information['population'] from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n+    ... where information['population'] is not null;\n     +-------------------+---------------------------+\n     | name              | information['population'] |\n     +-------------------+---------------------------+\n     | North West Ripple | [12, 42]                  |\n     | Outer Eastern Rim | [5673745846]              |\n+    | Orion Beta        | [3600001, 1]              |\n     +-------------------+---------------------------+\n-    SELECT 2 rows in set (... sec)\n+    SELECT 3 rows in set (... sec)\n \n-::\n+.. NOTE::\n \n-    cr> select information from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n-    +----------------------------------------------------...-----------------------+\n-    | information                                                                  |\n-    +----------------------------------------------------...-----------------------+\n-    | [{\"evolution_level\": 4, \"population\": 12}, {\"evolu...\": 42, \"popul...\": 42}] |\n-    | [{\"evolution_level\": 2, \"population\": 5673745846}]                           |\n-    +---------------------------------------------------...------------------------+\n+   You can nest arrays and objects however you like, but you can only have one", "originalCommit": "9183582de62081389adb864f48dfc3819ea7fb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzNjU5NQ==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545236595", "bodyText": "Also see my comment above.\nThe whole Object inside arrays section looks like the repeated version of Arrays inside objects. Does this really makes sense like this? Couldn't we fold this together or just highlight important differences and otherwise link to the previous explanations?", "author": "seut", "createdAt": "2020-12-17T16:43:38Z", "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value\n+   per expression. The following won't work:\n \n-The following query can be translated to *get all rows where race['interests']\n-has at least one element that equals 'netball'*::\n+   ``select my_column[1][2] from my_table;``\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 1 row in set (... sec)\n \n-The following query using the negated operator ``!=`` can be translated to *get\n-all rows where race['interests'] has at least one element that does not equal\n-'netball'*. As you see, the result is the same in this case::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' != ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Minories       | [\"baseball\", \"short stories\"]           |\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+.. _sql_dql_objects:\n \n-.. NOTE::\n+Objects\n+=======\n \n-    When using the negated operator ``!= ANY`` by default the maximum size of\n-    the array to operate on is ``8192``. To be able to use larger arrays the\n-    :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n-\n-Negating the ``=`` query from above is totally different. It can be translated\n-to *get all rows where race['interests'] has no value that equals 'netball'*::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where not 'netball' = ANY(race['interests']) order by race['name'];\n-    +--------------+-------------------------------+\n-    | race['name'] | race['interests']             |\n-    +--------------+-------------------------------+\n-    | Minories     | [\"baseball\", \"short stories\"] |\n-    +--------------+-------------------------------+\n+CrateDB supports an :ref:`object <object_data_type>` data type. It is possible\n+to select and query object properties.\n+\n+For example, you might insert an object like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (15, 'Betelgeuse', 2, 'Star System',\n+    ...     {name = 'Betelgeuseans',\n+    ...      description = 'Humanoids with two heads'}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n+\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-.. TIP::\n+The object properties can be selected from the ``inhabitants`` column with\n+``inhabitants['property']``, where ``property`` is the property name, like so::\n \n-    When using ``NOT <value> = ANY(<array_col>)`` the performance of the query\n-    could be quite bad, because special handling is required to implement the\n-    `3-valued logic`_. To achieve better performance, consider using the\n-    :ref:`ignore3vl function<ignore3vl>`.\n+    cr> select name, inhabitants['name'] from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+---------------------+\n+    | name       | inhabitants['name'] |\n+    +------------+---------------------+\n+    | Betelgeuse | Betelgeuseans       |\n+    +------------+---------------------+\n+    SELECT 1 row in set (... sec)\n \n-The same behaviour (though different comparison operations involved) holds true\n-for operators\n+Object property can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n- - ``LIKE`` and ``NOT LIKE``\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants['name'] = 'Betelgeuseans';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n- - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)\n \n-.. NOTE::\n+.. _sql_dql_array_objects:\n \n-    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the\n-    maximum size of the array to operate on is ``8192``. To be able to use\n-    larger arrays the :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n+Arrays within objects\n+=====================\n \n+Objects may contain arrays, and these arrays can be selected and queried.\n \n-.. _sql_dql_objects:\n+For example, you might insert an object containing an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (16, 'Folfanga', 4, 'Star System',\n+    ...     {name = 'A-Rth-Urp-Hil-Ipdenu',\n+    ...      description = 'A species of small slug',\n+    ...      interests = ['lettuce', 'slime']}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n \n-Inner objects and nested objects\n-================================\n+The result::\n \n-CrateDB supports an ``object`` data type, used for simple storing a whole\n-object into a column and it's even possible to select and query for properties\n-of such objects.\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Folfanga';\n+      +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Select a property of an inner object::\n+The child array can be selected as a property of the parent object in the\n+``inhabitants`` column using ``inhabitants['property']``, where ``property`` is\n+the parent object property name, like so::\n+\n+    cr> select name, inhabitants['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+--------------------------+\n+    | name     | inhabitants['interests'] |\n+    +----------+--------------------------+\n+    | Folfanga | [\"lettuce\", \"slime\"]     |\n+    +----------+--------------------------+\n+    SELECT 1 row in set (... sec)\n \n-    cr> select name, race['name'] from locations where name = 'Bartledan';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+The elements of the child array can be selected with\n+``inhabitants[n]['property']``, where ``n`` is the child array index and\n+``property`` is the parent object property name, like so::\n+\n+    cr> select name, inhabitants[1]['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+-----------------------------+\n+    | name     | inhabitants[1]['interests'] |\n+    +----------+-----------------------------+\n+    | Folfanga | lettuce                     |\n+    +----------+-----------------------------+\n     SELECT 1 row in set (... sec)\n \n-Query for a property of an inner object::\n+.. NOTE::\n \n-    cr> select name, race['name'] from locations\n-    ... where race['name'] = 'Bartledannians';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+    When accessing arrays within objects, the child array index comes before\n+    the parent object property name (i.e., ``my_column[n]['property']``), not\n+    the other way around. At the moment, the reverse syntax (i.e.,\n+    ``my_column['property'][n]``) is not supported.\n+\n+    Note also that ``my_column[n]['property']`` syntax can reference the\n+    ``property`` of a child object at index ``n`` of a parent array, if the\n+    column holds :ref:`arrays instead of objects <sql_dql_object_arrays>`. This\n+    makes the syntax `polymorphic`_ (i.e., behavior is inferred from the data\n+    type of the column).\n+\n+    As an alternative, child arrays can be :ref:`type cast\n+    <type_cast_from_string_literal>` to :ref:`text <data-type-text>` if you\n+    want the array index to appear last::\n+\n+        cr> select name, inhabitants['interests']::text[][1] from locations\n+        ... where name = 'Folfanga';\n+        +----------+-----------------------------+\n+        | name     | inhabitants[1]['interests'] |\n+        +----------+-----------------------------+\n+        | Folfanga | lettuce                     |\n+        +----------+-----------------------------+\n+        SELECT 1 row in set (... sec)\n+\n+.. _polymorphic: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\n+\n+The elements of the child array can also be addressed in the :ref:`where\n+clause <sql_dql_where_clause>`, like so::\n+\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants[1]['interests'] = 'lettuce'\n+    ... order by name;\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-Inserting objects::\n+.. NOTE::\n+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``\n+\n+\n+.. _sql_dql_object_arrays:\n+\n+Object within arrays\n+====================\n \n-    cr> insert into locations (id, name, position, kind, race)\n-    ... values ('DO', 'Dornbirn', 14, 'City', {name='Vorarlberger',\n-    ...     description = 'Very nice people with a strange accent',\n-    ...     interests = ['mountains', 'cheese', 'enzian']}\n+Arrays may contain objects, and these can be selected and queried.\n+\n+For example, you might insert an array of objects like so::\n+\n+    cr> insert into locations (id, name, position, kind, information)\n+    ... values (\n+    ...   17, 'Orion Beta', 3, 'Star System',\n+    ...   [{evolution_level=6, population=3600001},\n+    ...   {evolution_level=42, population=1}]\n     ... );\n     INSERT OK, 1 row affected (... sec)\n \n-.. _sql_dql_object_arrays:\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-Object arrays\n-=============\n+    cr> select name, information from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | name       | information                                                                               |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | Orion Beta | [{\"evolution_level\": 6, \"population\": 3600001}, {\"evolution_level\": 42, \"population\": 1}] |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+The individual child objects can be selected as an element of the parent array\n+in the ``information`` column using ``locations[1]``, where ``n`` is the parent\n+array index, like so::\n+\n+    cr> select name, information[1] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-----------------------------------------------+\n+    | name       | information[1]                                |\n+    +------------+-----------------------------------------------+\n+    | Orion Beta | {\"evolution_level\": 6, \"population\": 3600001} |\n+    +------------+-----------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Arrays in CrateDB can be queried for containment using the\n-:ref:`sql_dql_any_array` operator.\n+The properties of individual child objects can be selected with\n+``locations[n]['property']``, where ``n`` is the parent array index and\n+``property`` is the child property name, like so::\n+\n+    cr> select name, information[1]['population'] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+------------------------------+\n+    | name       | information[1]['population'] |\n+    +------------+------------------------------+\n+    | Orion Beta |                      3600001 |\n+    +------------+------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-It is possible to access fields of :ref:`sql_dql_objects` using subscript\n-expressions. If the parent is an object array, you'll get an array of the\n-selected field.\n+.. NOTE::\n \n+    The ``my_column[n]['property']`` syntax can reference the child array index\n+    ``n`` of a parent object ``property``, if the column holds :ref:`objects\n+    instead of arrays <sql_dql_array_objects>`. This makes the syntax\n+    `polymorphic`_ (i.e., behavior is inferred from the data type of the\n+    column).\n \n-Examples::\n+Additionally, you can query the same ``property`` of *every* object within the\n+array by omitting the array index, like so::\n \n     cr> select name, information['population'] from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n+    ... where information['population'] is not null;\n     +-------------------+---------------------------+\n     | name              | information['population'] |\n     +-------------------+---------------------------+\n     | North West Ripple | [12, 42]                  |\n     | Outer Eastern Rim | [5673745846]              |\n+    | Orion Beta        | [3600001, 1]              |\n     +-------------------+---------------------------+\n-    SELECT 2 rows in set (... sec)\n+    SELECT 3 rows in set (... sec)\n \n-::\n+.. NOTE::\n \n-    cr> select information from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n-    +----------------------------------------------------...-----------------------+\n-    | information                                                                  |\n-    +----------------------------------------------------...-----------------------+\n-    | [{\"evolution_level\": 4, \"population\": 12}, {\"evolu...\": 42, \"popul...\": 42}] |\n-    | [{\"evolution_level\": 2, \"population\": 5673745846}]                           |\n-    +---------------------------------------------------...------------------------+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``", "originalCommit": "9183582de62081389adb864f48dfc3819ea7fb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTIzNzQ0OQ==", "url": "https://github.com/crate/crate/pull/10866#discussion_r545237449", "bodyText": "I'd suggest to move the general array/object handling description outside of the comparison operator list.\nOr we could change the header level and move array comparison operator beneath general array and object description.", "author": "seut", "createdAt": "2020-12-17T16:44:45Z", "path": "docs/general/dql/selects.rst", "diffHunk": "@@ -511,274 +502,461 @@ does always return ``NULL`` when comparing ``NULL``.\n     +----------+\n     SELECT 1 row in set (... sec)\n \n-.. _sql_dql_any_array:\n+.. _sql_dql_arrays:\n \n-``ANY (array)``\n-===============\n+Arrays\n+======\n+\n+CrateDB supports an :ref:`array <data-type-array>` data type. It is possible\n+to select and query array elements.\n+\n+For example, you might :ref:`insert <inserting_data>` an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, landmarks)\n+    ... values (14, 'Frogstar', 4, 'Star System',\n+    ...     ['Total Perspective Vortex', 'Milliways']\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n \n-The ANY (or SOME) operator allows to search for elements within arrays. This\n-allows to query for rows where an element of an array is, for example, equal to\n-or greater than some ``expression``.\n+.. Hidden: refresh locations\n \n-The following example returns any row where the array ``race['interests']``\n-contains an element 'netball'::\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks from locations\n+    ... where name = 'Frogstar';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-::\n+The individual array elements can be selected from the ``landmarks`` column\n+with ``landmarks[n]``, where ``n`` is the integer array index, like so::\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'books%' LIKE ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n+    cr> select name, landmarks[1] from locations\n+    ... where name = 'Frogstar';\n+    +----------+--------------------------+\n+    | name     | landmarks[1]             |\n+    +----------+--------------------------+\n+    | Frogstar | Total Perspective Vortex |\n+    +----------+--------------------------+\n     SELECT 1 row in set (... sec)\n \n-It can also be used on arrays::\n+.. NOTE::\n \n-    cr> select name, race['interests'] from locations\n-    ... where name = ANY(ARRAY['Bartledan', 'Algol'])\n-    ... order by name asc;\n-    +-----------+-----------------------------------------+\n-    | name      | race['interests']                       |\n-    +-----------+-----------------------------------------+\n-    | Algol     | NULL                                    |\n-    | Bartledan | [\"netball\", \"books with 100.000 words\"] |\n-    +-----------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+    The first index value is ``1``. The maximum array index is ``2147483648``.\n+    Using an index greater than the array size results in a NULL value.\n \n-This way it can be used as a shortcut for ``name = 'Bartledan' OR name =\n-'Algol'`` or any other ANY comparison.\n+Individual array elements can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n-The ``ANY`` construct can be used in :ref:`sql_subquery_expressions` or\n-:ref:`sql_array_comparisons`.\n+    cr> select name, landmarks from locations\n+    ... where landmarks[2] = 'Milliways';\n+    +----------+-------------------------------------------+\n+    | name     | landmarks                                 |\n+    +----------+-------------------------------------------+\n+    | Frogstar | [\"Total Perspective Vortex\", \"Milliways\"] |\n+    +----------+-------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n+When using the ``=`` operator, as above, the value of the array element at\n+index ``n`` is compared. To compare against *any* array element, see\n+:ref:`sql_dql_any_array`.\n \n-Negating ``ANY``\n-----------------\n+.. NOTE::\n \n-One important thing to notice when using ANY is that negating the ANY operator\n-does not behave as negating normal comparison operators.\n+   You can nest arrays within arrays, but you can only have one subscript value\n+   per expression. The following won't work:\n \n-The following query can be translated to *get all rows where race['interests']\n-has at least one element that equals 'netball'*::\n+   ``select my_column[1][2] from my_table;``\n \n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' = ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 1 row in set (... sec)\n \n-The following query using the negated operator ``!=`` can be translated to *get\n-all rows where race['interests'] has at least one element that does not equal\n-'netball'*. As you see, the result is the same in this case::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where 'netball' != ANY(race['interests']);\n-    +----------------+-----------------------------------------+\n-    | race['name']   | race['interests']                       |\n-    +----------------+-----------------------------------------+\n-    | Minories       | [\"baseball\", \"short stories\"]           |\n-    | Bartledannians | [\"netball\", \"books with 100.000 words\"] |\n-    +----------------+-----------------------------------------+\n-    SELECT 2 rows in set (... sec)\n+.. _sql_dql_objects:\n \n-.. NOTE::\n+Objects\n+=======\n \n-    When using the negated operator ``!= ANY`` by default the maximum size of\n-    the array to operate on is ``8192``. To be able to use larger arrays the\n-    :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n-\n-Negating the ``=`` query from above is totally different. It can be translated\n-to *get all rows where race['interests'] has no value that equals 'netball'*::\n-\n-    cr> select race['name'], race['interests'] from locations\n-    ... where not 'netball' = ANY(race['interests']) order by race['name'];\n-    +--------------+-------------------------------+\n-    | race['name'] | race['interests']             |\n-    +--------------+-------------------------------+\n-    | Minories     | [\"baseball\", \"short stories\"] |\n-    +--------------+-------------------------------+\n+CrateDB supports an :ref:`object <object_data_type>` data type. It is possible\n+to select and query object properties.\n+\n+For example, you might insert an object like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (15, 'Betelgeuse', 2, 'Star System',\n+    ...     {name = 'Betelgeuseans',\n+    ...      description = 'Humanoids with two heads'}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n+\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-.. TIP::\n+The object properties can be selected from the ``inhabitants`` column with\n+``inhabitants['property']``, where ``property`` is the property name, like so::\n \n-    When using ``NOT <value> = ANY(<array_col>)`` the performance of the query\n-    could be quite bad, because special handling is required to implement the\n-    `3-valued logic`_. To achieve better performance, consider using the\n-    :ref:`ignore3vl function<ignore3vl>`.\n+    cr> select name, inhabitants['name'] from locations\n+    ... where name = 'Betelgeuse';\n+    +------------+---------------------+\n+    | name       | inhabitants['name'] |\n+    +------------+---------------------+\n+    | Betelgeuse | Betelgeuseans       |\n+    +------------+---------------------+\n+    SELECT 1 row in set (... sec)\n \n-The same behaviour (though different comparison operations involved) holds true\n-for operators\n+Object property can also be addressed in the :ref:`where clause\n+<sql_dql_where_clause>`, like so::\n \n- - ``LIKE`` and ``NOT LIKE``\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants['name'] = 'Betelgeuseans';\n+    +------------+----------------------------------------------------------------------+\n+    | name       | inhabitants                                                          |\n+    +------------+----------------------------------------------------------------------+\n+    | Betelgeuse | {\"description\": \"Humanoids with two heads\", \"name\": \"Betelgeuseans\"} |\n+    +------------+----------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n- - all other comparison operators (excluding ``IS NULL`` and ``IS NOT NULL``)\n \n-.. NOTE::\n+.. _sql_dql_array_objects:\n \n-    When using the operators ``LIKE ANY`` and ``NOT LIKE ANY`` by default the\n-    maximum size of the array to operate on is ``8192``. To be able to use\n-    larger arrays the :ref:`indices.query.bool.max_clause_count\n-    <indices.query.bool.max_clause_count>` setting must be changed\n-    appropriately on each node.\n+Arrays within objects\n+=====================\n \n+Objects may contain arrays, and these arrays can be selected and queried.\n \n-.. _sql_dql_objects:\n+For example, you might insert an object containing an array like so::\n+\n+    cr> insert into locations (id, name, position, kind, inhabitants)\n+    ... values (16, 'Folfanga', 4, 'Star System',\n+    ...     {name = 'A-Rth-Urp-Hil-Ipdenu',\n+    ...      description = 'A species of small slug',\n+    ...      interests = ['lettuce', 'slime']}\n+    ... );\n+    INSERT OK, 1 row affected (... sec)\n+\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n \n-Inner objects and nested objects\n-================================\n+The result::\n \n-CrateDB supports an ``object`` data type, used for simple storing a whole\n-object into a column and it's even possible to select and query for properties\n-of such objects.\n+    cr> select name, inhabitants from locations\n+    ... where name = 'Folfanga';\n+      +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Select a property of an inner object::\n+The child array can be selected as a property of the parent object in the\n+``inhabitants`` column using ``inhabitants['property']``, where ``property`` is\n+the parent object property name, like so::\n+\n+    cr> select name, inhabitants['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+--------------------------+\n+    | name     | inhabitants['interests'] |\n+    +----------+--------------------------+\n+    | Folfanga | [\"lettuce\", \"slime\"]     |\n+    +----------+--------------------------+\n+    SELECT 1 row in set (... sec)\n \n-    cr> select name, race['name'] from locations where name = 'Bartledan';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+The elements of the child array can be selected with\n+``inhabitants[n]['property']``, where ``n`` is the child array index and\n+``property`` is the parent object property name, like so::\n+\n+    cr> select name, inhabitants[1]['interests'] from locations\n+    ... where name = 'Folfanga';\n+    +----------+-----------------------------+\n+    | name     | inhabitants[1]['interests'] |\n+    +----------+-----------------------------+\n+    | Folfanga | lettuce                     |\n+    +----------+-----------------------------+\n     SELECT 1 row in set (... sec)\n \n-Query for a property of an inner object::\n+.. NOTE::\n \n-    cr> select name, race['name'] from locations\n-    ... where race['name'] = 'Bartledannians';\n-    +-----------+----------------+\n-    | name      | race['name']   |\n-    +-----------+----------------+\n-    | Bartledan | Bartledannians |\n-    +-----------+----------------+\n+    When accessing arrays within objects, the child array index comes before\n+    the parent object property name (i.e., ``my_column[n]['property']``), not\n+    the other way around. At the moment, the reverse syntax (i.e.,\n+    ``my_column['property'][n]``) is not supported.\n+\n+    Note also that ``my_column[n]['property']`` syntax can reference the\n+    ``property`` of a child object at index ``n`` of a parent array, if the\n+    column holds :ref:`arrays instead of objects <sql_dql_object_arrays>`. This\n+    makes the syntax `polymorphic`_ (i.e., behavior is inferred from the data\n+    type of the column).\n+\n+    As an alternative, child arrays can be :ref:`type cast\n+    <type_cast_from_string_literal>` to :ref:`text <data-type-text>` if you\n+    want the array index to appear last::\n+\n+        cr> select name, inhabitants['interests']::text[][1] from locations\n+        ... where name = 'Folfanga';\n+        +----------+-----------------------------+\n+        | name     | inhabitants[1]['interests'] |\n+        +----------+-----------------------------+\n+        | Folfanga | lettuce                     |\n+        +----------+-----------------------------+\n+        SELECT 1 row in set (... sec)\n+\n+.. _polymorphic: https://en.wikipedia.org/wiki/Polymorphism_(computer_science)\n+\n+The elements of the child array can also be addressed in the :ref:`where\n+clause <sql_dql_where_clause>`, like so::\n+\n+    cr> select name, inhabitants from locations\n+    ... where inhabitants[1]['interests'] = 'lettuce'\n+    ... order by name;\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | name     | inhabitants                                                                                                   |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n+    | Folfanga | {\"description\": \"A species of small slug\", \"interests\": [\"lettuce\", \"slime\"], \"name\": \"A-Rth-Urp-Hil-Ipdenu\"} |\n+    +----------+---------------------------------------------------------------------------------------------------------------+\n     SELECT 1 row in set (... sec)\n \n-Inserting objects::\n+.. NOTE::\n+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``\n+\n+\n+.. _sql_dql_object_arrays:\n+\n+Object within arrays\n+====================\n \n-    cr> insert into locations (id, name, position, kind, race)\n-    ... values ('DO', 'Dornbirn', 14, 'City', {name='Vorarlberger',\n-    ...     description = 'Very nice people with a strange accent',\n-    ...     interests = ['mountains', 'cheese', 'enzian']}\n+Arrays may contain objects, and these can be selected and queried.\n+\n+For example, you might insert an array of objects like so::\n+\n+    cr> insert into locations (id, name, position, kind, information)\n+    ... values (\n+    ...   17, 'Orion Beta', 3, 'Star System',\n+    ...   [{evolution_level=6, population=3600001},\n+    ...   {evolution_level=42, population=1}]\n     ... );\n     INSERT OK, 1 row affected (... sec)\n \n-.. _sql_dql_object_arrays:\n+.. Hidden: refresh locations\n+\n+    cr> refresh table locations;\n+    REFRESH OK, 1 row affected (... sec)\n+\n+The result::\n \n-Object arrays\n-=============\n+    cr> select name, information from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | name       | information                                                                               |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    | Orion Beta | [{\"evolution_level\": 6, \"population\": 3600001}, {\"evolution_level\": 42, \"population\": 1}] |\n+    +------------+-------------------------------------------------------------------------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+The individual child objects can be selected as an element of the parent array\n+in the ``information`` column using ``locations[1]``, where ``n`` is the parent\n+array index, like so::\n+\n+    cr> select name, information[1] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+-----------------------------------------------+\n+    | name       | information[1]                                |\n+    +------------+-----------------------------------------------+\n+    | Orion Beta | {\"evolution_level\": 6, \"population\": 3600001} |\n+    +------------+-----------------------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-Arrays in CrateDB can be queried for containment using the\n-:ref:`sql_dql_any_array` operator.\n+The properties of individual child objects can be selected with\n+``locations[n]['property']``, where ``n`` is the parent array index and\n+``property`` is the child property name, like so::\n+\n+    cr> select name, information[1]['population'] from locations\n+    ... where name = 'Orion Beta';\n+    +------------+------------------------------+\n+    | name       | information[1]['population'] |\n+    +------------+------------------------------+\n+    | Orion Beta |                      3600001 |\n+    +------------+------------------------------+\n+    SELECT 1 row in set (... sec)\n \n-It is possible to access fields of :ref:`sql_dql_objects` using subscript\n-expressions. If the parent is an object array, you'll get an array of the\n-selected field.\n+.. NOTE::\n \n+    The ``my_column[n]['property']`` syntax can reference the child array index\n+    ``n`` of a parent object ``property``, if the column holds :ref:`objects\n+    instead of arrays <sql_dql_array_objects>`. This makes the syntax\n+    `polymorphic`_ (i.e., behavior is inferred from the data type of the\n+    column).\n \n-Examples::\n+Additionally, you can query the same ``property`` of *every* object within the\n+array by omitting the array index, like so::\n \n     cr> select name, information['population'] from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n+    ... where information['population'] is not null;\n     +-------------------+---------------------------+\n     | name              | information['population'] |\n     +-------------------+---------------------------+\n     | North West Ripple | [12, 42]                  |\n     | Outer Eastern Rim | [5673745846]              |\n+    | Orion Beta        | [3600001, 1]              |\n     +-------------------+---------------------------+\n-    SELECT 2 rows in set (... sec)\n+    SELECT 3 rows in set (... sec)\n \n-::\n+.. NOTE::\n \n-    cr> select information from locations\n-    ... where information['population'] is not null\n-    ... order by name;\n-    +----------------------------------------------------...-----------------------+\n-    | information                                                                  |\n-    +----------------------------------------------------...-----------------------+\n-    | [{\"evolution_level\": 4, \"population\": 12}, {\"evolu...\": 42, \"popul...\": 42}] |\n-    | [{\"evolution_level\": 2, \"population\": 5673745846}]                           |\n-    +---------------------------------------------------...------------------------+\n+   You can nest arrays and objects however you like, but you can only have one\n+   subscript value per expression. The following won't work:\n+\n+   ``select my_column[1]['property'][2] from my_table;``\n+\n+\n+.. _sql_dql_any_array:\n+\n+``ANY (array)``\n+===============", "originalCommit": "9183582de62081389adb864f48dfc3819ea7fb6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2f1a0df0089abea10e2cfea8fa5f29a15eacb0b2", "url": "https://github.com/crate/crate/commit/2f1a0df0089abea10e2cfea8fa5f29a15eacb0b2", "message": "Correction: Add clarification and cross-reference for object literals syntax (fixes crate/tech-writing-domain#201)", "committedDate": "2021-01-05T13:01:06Z", "type": "forcePushed"}, {"oid": "f725e09fc28e80c2701efa831a62e12b7879e9c4", "url": "https://github.com/crate/crate/commit/f725e09fc28e80c2701efa831a62e12b7879e9c4", "message": "restructuring", "committedDate": "2021-01-05T13:06:12Z", "type": "forcePushed"}, {"oid": "256dddd94bbc5289678e50690a6da2dd3be85e1f", "url": "https://github.com/crate/crate/commit/256dddd94bbc5289678e50690a6da2dd3be85e1f", "message": "fixup! make tests pass", "committedDate": "2021-01-11T23:26:38Z", "type": "forcePushed"}, {"oid": "a3231e769f01112a167d45dbe880b9b328bd0cd8", "url": "https://github.com/crate/crate/commit/a3231e769f01112a167d45dbe880b9b328bd0cd8", "message": "Improvement: Overhaul arrays and objects DQL docs", "committedDate": "2021-01-11T23:30:37Z", "type": "forcePushed"}, {"oid": "0561b2e647543adfff52400ec076ddb5375812f2", "url": "https://github.com/crate/crate/commit/0561b2e647543adfff52400ec076ddb5375812f2", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nChanges to \"Selecting data\" docs:\n\n- A complete rework of the documentation on arrays, objects, and nested\n  structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n\n  - Syntax explanations have been expanded, clarified, and so on\n\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n\n- Updates to some example outputs to reflect changes made to the test data\n\n- Minor additional edits for clarity, style, and consistency\n\nOther changes:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information.", "committedDate": "2021-01-11T23:31:49Z", "type": "forcePushed"}, {"oid": "dea919a2fe351407d5e6f9f13d3e2773772bbbf6", "url": "https://github.com/crate/crate/commit/dea919a2fe351407d5e6f9f13d3e2773772bbbf6", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nChanges to \"Selecting data\" docs:\n\n- A complete rework of the documentation on arrays, objects, and nested\n  structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n\n  - Syntax explanations have been expanded, clarified, and so on\n\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n\n- Updates to some example outputs to reflect changes made to the test data\n\n- Minor additional edits for clarity, style, and consistency\n\nOther changes:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information.", "committedDate": "2021-01-12T00:14:01Z", "type": "forcePushed"}, {"oid": "ff30fb05a93113a7d1ea83ddacbc9ad8a5b93ead", "url": "https://github.com/crate/crate/commit/ff30fb05a93113a7d1ea83ddacbc9ad8a5b93ead", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information.", "committedDate": "2021-01-12T00:15:00Z", "type": "forcePushed"}, {"oid": "237b86bc2107b8e722a84e09bb80af28df20e7e6", "url": "https://github.com/crate/crate/commit/237b86bc2107b8e722a84e09bb80af28df20e7e6", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html``\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information.", "committedDate": "2021-01-12T00:22:58Z", "type": "forcePushed"}, {"oid": "6265084f9db95e54d8390a1e114976c80e7802a4", "url": "https://github.com/crate/crate/commit/6265084f9db95e54d8390a1e114976c80e7802a4", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html`\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information.", "committedDate": "2021-01-12T00:59:03Z", "type": "forcePushed"}, {"oid": "9b7c9d16f5b5762b7b7777e61687ed049345322e", "url": "https://github.com/crate/crate/commit/9b7c9d16f5b5762b7b7777e61687ed049345322e", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html`\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information.", "committedDate": "2021-01-13T18:51:47Z", "type": "commit"}, {"oid": "9b7c9d16f5b5762b7b7777e61687ed049345322e", "url": "https://github.com/crate/crate/commit/9b7c9d16f5b5762b7b7777e61687ed049345322e", "message": "Improvement: Overhaul `SELECT` docs for arrays and objects\n\nThis commit is a complete rework of the documentation on arrays, objects, and\nnested structures:\n\n  - Narrative flow has been improved so that each section leads into\n    and builds up to the next\n  - Example data has been changed so that the The Hitchhiker's Guide to the\n    Galaxy theme (established elsewhere) is maintained throughout\n  - Example queries and and example data have been improved to better show what\n    is being demonstrated\n  - Syntax explanations have been expanded, clarified, and so on\n  - A tip has been added to address the fact that array syntax doesn't follow\n    the usual left-to-right convention for addressing the contents of a nested\n    structure\n  - A new subsection, \"Limitations\", has been added to better communicate some\n    important specifics of array access\n  - A tip has been added about nonstandard syntax for addressing the elements\n    of a second array\n\nOther changes to the \"Selecting data\" docs:\n\n- Adds the \"Comparison operators\" and \"Nonscalar data types\" headings to better\n  indicate the relationship between subsections\n- Updates to some example outputs to reflect changes made to the test data\n- Minor additional edits for clarity, style, and consistency\n\nChanges to other files:\n\n- Fixes a `test_docs.py` deprication warning\n- Fixes test data ID values (removes the double quotes)\n- Alters the test data to better suit the examples in `selects.html`\n- Renames `race` to `inhabitants`\n- Minor updates for files impacted by the changes above (test data changes, RST\n  editing, and so on)\n\nSee <https://github.com/crate/crate/pull/10866> for more information.", "committedDate": "2021-01-13T18:51:47Z", "type": "forcePushed"}]}