{"pr_number": 10104, "pr_title": "Add support for global flag 'g' to now tabular function regexp_matches", "pr_createdAt": "2020-06-18T20:50:27Z", "pr_url": "https://github.com/crate/crate/pull/10104", "timeline": [{"oid": "f5878fd6b29912b94f6aef0d362cc94d004e5c92", "url": "https://github.com/crate/crate/commit/f5878fd6b29912b94f6aef0d362cc94d004e5c92", "message": "Add support of global flag 'g' to scalar function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match.", "committedDate": "2020-06-18T21:25:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcwMTAyMw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r442701023", "bodyText": "To match the language of the rest of the table, I might rephrase it as:\n\"do not stop at first match and keep going until end of source. \"", "author": "infoverload", "createdAt": "2020-06-19T08:16:38Z", "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -1780,6 +1780,16 @@ not matter.\n | ``d`` | only ``\\n`` is considered a line-terminator when using ``^``, ``$`` |\n |       | and ``.``                                                           |\n +-------+---------------------------------------------------------------------+\n+| ``g`` | do not stop at the first match, but rather keep going until the end |\n+|       | of ``source``.                                                      |\n++-------+---------------------------------------------------------------------+", "originalCommit": "f5878fd6b29912b94f6aef0d362cc94d004e5c92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dc2da01950be6f90cb8963926b4bcacf75a7d329", "url": "https://github.com/crate/crate/commit/dc2da01950be6f90cb8963926b4bcacf75a7d329", "message": "Rework function 'regexp_matches' as a table function", "committedDate": "2020-06-22T18:51:16Z", "type": "forcePushed"}, {"oid": "c805f023c3ff4ce5a5307f5375cc572aed08e30e", "url": "https://github.com/crate/crate/commit/c805f023c3ff4ce5a5307f5375cc572aed08e30e", "message": "Rework function 'regexp_matches' as a table function", "committedDate": "2020-06-22T18:56:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MzExOA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r444773118", "bodyText": "cells is a varargs argument, this will cause you to have a Row with multiple cells.\n List.of(\"foo\", \"bar\").toArray()\n$2 ==> Object[2] { \"foo\", \"bar\" }\n\n\nvar row = new RowN(List.of(\"foo\", \"bar\").toArray())\nrow.numColumns(); -> this will be 2, instead of 1\n\nWhat you want is something like this:\nvar row = new RowN(new Object[] { List.of(\"foo\", \"bar\").toArray() });\nrow.numColumns(); -> this will be 1", "author": "mfussenegger", "createdAt": "2020-06-24T09:42:00Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/FoobarFunction.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.metadata.FunctionIdent;\n+import io.crate.metadata.FunctionInfo;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+public class FoobarFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"foobar\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"planetzs\")); // single column, array(text)\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(NAME, ROW_TYPE.getTypeSignature()),\n+            (signature, args) -> new FoobarFunction(\n+                signature,\n+                new FunctionInfo(\n+                    new FunctionIdent(NAME, args),\n+                    ROW_TYPE,\n+                    FunctionInfo.Type.TABLE))\n+        );\n+    }\n+\n+    private final Signature signature;\n+    private final FunctionInfo info;\n+\n+    private FoobarFunction(Signature signature, FunctionInfo info) {\n+        this.signature = signature;\n+        this.info = info;\n+    }\n+\n+    @Override\n+    public FunctionInfo info() {\n+        return info;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        return iterableOf(List.of(\n+            \"Mercury\", \"Venus\", \"Earth\", \"Jupiter\", \"Saturn\", \"Your-anus\", \"Ne pais fume\"));\n+    }\n+    private static Iterable<Row> iterableOf(List<String> data) {\n+        if (data == null || data.size() == 0) {\n+            return null;\n+        }\n+        return () -> new Iterator<>() {\n+            final RowN row = new RowN(1);\n+            int idx = 0;\n+\n+            @Override\n+            public boolean hasNext() {\n+                return idx < 1;\n+            }\n+\n+            @Override\n+            public Row next() {\n+                if (!hasNext()) {\n+                    throw new NoSuchElementException(\"no more rows\");\n+                }\n+                row.cells(data.toArray());", "originalCommit": "f2bb0da87f153e5310018548ea711648daac07e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3NTYwNw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r444775607", "bodyText": "and then the problem is:\nSQLActionException[ClassCastException: class [Ljava.lang.Object; cannot be cast to class java.util.List ([Ljava.lang.Object; and java.util.List are in module java.base of loader 'bootstrap')]", "author": "marregui", "createdAt": "2020-06-24T09:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MzExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3NTc0NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r444775744", "bodyText": "cool", "author": "marregui", "createdAt": "2020-06-24T09:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MzExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3NjgxMA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r444776810", "bodyText": "YES!!!!!!! thank you very much!!!! I could not see the freaking varargs issue!!! and went mental, hitting my antlers against the wall, xxx", "author": "marregui", "createdAt": "2020-06-24T09:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MzExOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3ODEwNA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r444778104", "bodyText": "and then the problem is:\n\nRight, the toArray() call is bogus.  STRING_ARRAY value must be a List<String>, not an array.", "author": "mfussenegger", "createdAt": "2020-06-24T09:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc3MzExOA=="}], "type": "inlineReview"}, {"oid": "3f005ebc303de2d839b194db664bb7167d9a6fcc", "url": "https://github.com/crate/crate/commit/3f005ebc303de2d839b194db664bb7167d9a6fcc", "message": "Rework function 'regexp_matches' as a table function", "committedDate": "2020-06-25T13:47:01Z", "type": "forcePushed"}, {"oid": "79d57ca0ac4354298172c0ea1cc4cc77a5979b97", "url": "https://github.com/crate/crate/commit/79d57ca0ac4354298172c0ea1cc4cc77a5979b97", "message": "No need for checking pgtype and act accordingly (mistake)", "committedDate": "2020-06-26T14:00:20Z", "type": "forcePushed"}, {"oid": "3213e0dc57621fb9020ca7b75b1b523cc7f9d6ee", "url": "https://github.com/crate/crate/commit/3213e0dc57621fb9020ca7b75b1b523cc7f9d6ee", "message": "Adapt to new signature only function definition", "committedDate": "2020-06-29T11:42:13Z", "type": "forcePushed"}, {"oid": "749835d8833d00fe5c1bc61197846c65586d362f", "url": "https://github.com/crate/crate/commit/749835d8833d00fe5c1bc61197846c65586d362f", "message": "Refactor documentation, still needs work", "committedDate": "2020-06-29T13:22:34Z", "type": "forcePushed"}, {"oid": "0816fe05a0f722ceeeaa7e46ecd38c70a6a5a87d", "url": "https://github.com/crate/crate/commit/0816fe05a0f722ceeeaa7e46ecd38c70a6a5a87d", "message": "Add support of global flag 'g' to scalar function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match.", "committedDate": "2020-06-30T14:21:42Z", "type": "forcePushed"}, {"oid": "7b2834e21ed2896260ffc27ccb73b38517770a0a", "url": "https://github.com/crate/crate/commit/7b2834e21ed2896260ffc27ccb73b38517770a0a", "message": "Add support of global flag 'g' to scalar function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match.", "committedDate": "2020-07-01T10:25:20Z", "type": "forcePushed"}, {"oid": "b1b8839a154af89ee56272430965fa12c140c612", "url": "https://github.com/crate/crate/commit/b1b8839a154af89ee56272430965fa12c140c612", "message": "Add support of global flag 'g' to scalar function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match.", "committedDate": "2020-07-01T17:19:30Z", "type": "forcePushed"}, {"oid": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "url": "https://github.com/crate/crate/commit/972b05d2661ecf1c330442f18c99cd31ee58dba2", "message": "Add support for global flag 'g' to now tabular function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match. The postgres specification defines this\nfunction as a table function.", "committedDate": "2020-07-01T19:07:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNzgwNg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454617806", "bodyText": "This is not a fix, but a change - maybe even a breaking change.", "author": "mfussenegger", "createdAt": "2020-07-14T20:16:18Z", "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -268,6 +268,11 @@ Performance improvements\n Fixes\n =====\n \n+- Added support for flag ``g`` to function", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxODIzMA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454618230", "bodyText": "I don't this this should be changed here. Rather the functions shouldn't return null elements.", "author": "mfussenegger", "createdAt": "2020-07-14T20:17:11Z", "path": "server/src/main/java/io/crate/execution/engine/pipeline/TableFunctionApplier.java", "diffHunk": "@@ -57,7 +58,11 @@ public TableFunctionApplier(List<Input<Iterable<Row>>> tableFunctions,\n             expressions.get(i).setNextRow(row);\n         }\n         mapIncomingValuesToOutgoingCells();\n-        List<Iterator<Row>> iterators = Lists2.map(tableFunctions, x -> x.value().iterator());\n+        List<Iterator<Row>> iterators = tableFunctions.stream()\n+            .map(Input::value)\n+            .filter(Objects::nonNull)\n+            .map(Iterable::iterator)\n+            .collect(Collectors.toList());", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyMTY5Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454621696", "bodyText": "Part of this function is now used by the regexp_replace function, the other by the regexp_matches functions. Would it make sense to separate this into two classes, or inline the relevant code as inner static class to the relevant functions?\nOr another option would be to have two implementations and the implementation would be retrieved via a static constructor that takes the flag as argument, to avoid the if (global cases", "author": "mfussenegger", "createdAt": "2020-07-14T20:23:45Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexMatcher.java", "diffHunk": "@@ -22,37 +22,54 @@\n package io.crate.expression.scalar.regex;\n \n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n import java.util.List;\n+import java.util.Objects;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n \n public class RegexMatcher {", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNDU3Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454624576", "bodyText": "Does the type signature definition still fit? Shouldn't that be a row-type now?", "author": "mfussenegger", "createdAt": "2020-07-14T20:28:35Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -19,29 +19,37 @@\n  * software solely pursuant to the terms of the relevant commercial agreement.\n  */\n \n-package io.crate.expression.scalar.regex;\n+package io.crate.expression.tablefunctions;\n \n+import io.crate.common.annotations.VisibleForTesting;\n import io.crate.data.Input;\n-import io.crate.expression.scalar.ScalarFunctionModule;\n-import io.crate.expression.symbol.Function;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n import io.crate.expression.symbol.Literal;\n import io.crate.expression.symbol.Symbol;\n import io.crate.expression.symbol.SymbolType;\n import io.crate.metadata.Scalar;\n import io.crate.metadata.TransactionContext;\n import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n \n import javax.annotation.Nullable;\n+import java.util.Iterator;\n import java.util.List;\n+import java.util.NoSuchElementException;\n \n-public class MatchesFunction extends Scalar<List<String>, Object> {\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n \n     public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n \n-    public static void register(ScalarFunctionModule module) {\n+    public static void register(TableFunctionModule module) {\n         module.register(\n-            Signature.scalar(\n+            Signature.table(", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5ODQwMg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r456398402", "bodyText": "It is a row_type, new RowType(List.of(DataTypes.STRING_ARRAY), List.of(\"groups\")), I followed a similar approach to GenerateSeries.", "author": "marregui", "createdAt": "2020-07-17T12:02:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNjMxOA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454626318", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testCompile() throws Exception {\n          \n          \n            \n                public void test_compile_creates_regex_matcher_instance_on_table_function() throws Exception {", "author": "mfussenegger", "createdAt": "2020-07-14T20:31:39Z", "path": "server/src/test/java/io/crate/expression/tablefunctions/MatchesFunctionTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.metadata.Scalar;\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.junit.Test;\n+\n+import java.util.Locale;\n+\n+public class MatchesFunctionTest extends AbstractTableFunctionsTest {\n+\n+    @Test\n+    public void testCompile() throws Exception {", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNjcxNQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454626715", "bodyText": "why not pass the argument into the function directly?", "author": "mfussenegger", "createdAt": "2020-07-14T20:32:23Z", "path": "server/src/test/java/io/crate/expression/tablefunctions/MatchesFunctionTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.metadata.Scalar;\n+import org.hamcrest.BaseMatcher;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.junit.Test;\n+\n+import java.util.Locale;\n+\n+public class MatchesFunctionTest extends AbstractTableFunctionsTest {\n+\n+    @Test\n+    public void testCompile() throws Exception {\n+        Matcher<Scalar> matcher = new BaseMatcher<>() {\n+            @Override\n+            public boolean matches(Object item) {\n+                MatchesFunction regexpImpl = (MatchesFunction) item;\n+                // ensure that the RegexMatcher was created due to compilation\n+                return regexpImpl.regexMatcher() != null;\n+            }\n+\n+            @Override\n+            public void describeTo(Description description) {\n+            }\n+        };\n+        assertCompile(\"regexp_matches(name, '.*(ba).*')\", (s) -> matcher);\n+    }\n+\n+    private static String regexp_matches(String value, String pattern, String flags) {\n+        return String.format(Locale.ENGLISH, \"regexp_matches('%s', '%s', '%s')\", value, pattern, flags);\n+    }\n+\n+    private static String regexp_matches(String value, String pattern) {", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNjk5NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454626994", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Seed(\"C328C6C2B806C0E9\")", "author": "mfussenegger", "createdAt": "2020-07-14T20:32:55Z", "path": "server/src/test/java/io/crate/integrationtests/RegexpMatchesTableFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.integrationtests;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Seed;\n+import io.crate.testing.TestingHelpers;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import static io.crate.testing.TestingHelpers.printedTable;\n+import static org.hamcrest.core.Is.is;\n+\n+public class RegexpMatchesTableFunctionIntegrationTest extends SQLTransportIntegrationTest {\n+\n+    @Before\n+    public void setup() {\n+        execute(\"create table tregex (i integer, s string) with (number_of_replicas=0)\");\n+        execute(\"insert into tregex(i, s) values (?, ?)\", new Object[][]{\n+            new Object[]{1, \"foo is first\"},\n+            new Object[]{2, \"bar is second\"},\n+            new Object[]{3, \"foobar is great\"},\n+            new Object[]{4, \"boobar is greater\"},\n+            new Object[]{5, \"awam bam baluma\"},\n+            new Object[]{6, null}\n+        });\n+        refresh();\n+    }\n+\n+    @After\n+    public void teardown() {\n+        execute(\"drop table tregex\");\n+    }\n+\n+    @Seed(\"C328C6C2B806C0E9\")", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyNzMwMQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r454627301", "bodyText": "I don't really see how these are testing anything that is not covered by the unit tests?", "author": "mfussenegger", "createdAt": "2020-07-14T20:33:30Z", "path": "server/src/test/java/io/crate/integrationtests/RegexpMatchesTableFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.integrationtests;\n+\n+import com.carrotsearch.randomizedtesting.annotations.Seed;\n+import io.crate.testing.TestingHelpers;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import static io.crate.testing.TestingHelpers.printedTable;\n+import static org.hamcrest.core.Is.is;\n+\n+public class RegexpMatchesTableFunctionIntegrationTest extends SQLTransportIntegrationTest {\n+\n+    @Before\n+    public void setup() {\n+        execute(\"create table tregex (i integer, s string) with (number_of_replicas=0)\");\n+        execute(\"insert into tregex(i, s) values (?, ?)\", new Object[][]{\n+            new Object[]{1, \"foo is first\"},\n+            new Object[]{2, \"bar is second\"},\n+            new Object[]{3, \"foobar is great\"},\n+            new Object[]{4, \"boobar is greater\"},\n+            new Object[]{5, \"awam bam baluma\"},\n+            new Object[]{6, null}\n+        });\n+        refresh();\n+    }\n+\n+    @After\n+    public void teardown() {\n+        execute(\"drop table tregex\");\n+    }\n+\n+    @Seed(\"C328C6C2B806C0E9\")\n+    @Test\n+    public void test_regexp_matches_is_used_in_select_filtering_from_a_table() {\n+        execute(\"select regexp_matches(s, '(\\\\w+) is (great).*', 'g') from tregex\");\n+        Arrays.sort(response.rows(), Comparator.comparing(o -> ((List<String>) o[0]).get(0)));\n+        assertThat(TestingHelpers.printedTable(response.rows()), is(\"[boobar, great]\\n\" +\n+                                                                    \"[foobar, great]\\n\"));\n+    }\n+\n+    @Test\n+    public void test_regexp_matches_is_used_in_from_generating_a_table() {\n+        execute(\"select * from regexp_matches('foobar is greater', '(\\\\w+) is (great|greater)', 'g')\");\n+        assertThat(TestingHelpers.printedTable(response.rows()), is(\"[foobar, great]\\n\"));\n+    }\n+\n+    @Test\n+    public void test_regexp_matches_g() {\n+        execute(\"select regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g')\");\n+        assertThat(printedTable(response.rows()), is(\"[bar, beque]\\n\" +\n+                                                     \"[bazil, barf]\\n\"));\n+\n+        execute(\"select groups from regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g')\");\n+        assertThat(printedTable(response.rows()), is(\"[bar, beque]\\n\" +\n+                                                     \"[bazil, barf]\\n\"));\n+    }\n+\n+    @Test\n+    public void test_regexp_matches() {\n+        execute(\"select regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)')\");\n+        assertThat(printedTable(response.rows()), is(\"[bar, beque]\\n\"));\n+\n+        execute(\"select groups from regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)')\");\n+        assertThat(printedTable(response.rows()), is(\"[bar, beque]\\n\"));\n+    }", "originalCommit": "972b05d2661ecf1c330442f18c99cd31ee58dba2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1362e7fcd3d0e84abf5cb01bd25bd765fa8fdc0", "url": "https://github.com/crate/crate/commit/b1362e7fcd3d0e84abf5cb01bd25bd765fa8fdc0", "message": "Remove integration tests as their logic is covered in unit tests already", "committedDate": "2020-07-17T14:32:09Z", "type": "forcePushed"}, {"oid": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "url": "https://github.com/crate/crate/commit/4d98613ddd524d8fccd4b634bd3513cce8b578a6", "message": "Refactor RegexMatcher to split functionality match/replace", "committedDate": "2020-07-18T17:36:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0MjU2Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457942566", "bodyText": "I think this could be final, right ?", "author": "mkleen", "createdAt": "2020-07-21T08:55:21Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexpReplaceFunction.java", "diffHunk": "@@ -33,6 +33,7 @@\n \n import javax.annotation.Nullable;\n import java.util.List;\n+import java.util.regex.Matcher;\n \n public class RegexpReplaceFunction extends Scalar<String, Object> {", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0MzA5OQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457943099", "bodyText": "This could be final as well i think.", "author": "mkleen", "createdAt": "2020-07-21T08:56:13Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1NjU0Nw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457956547", "bodyText": "Minor: I think you could just return List.of() and () -> new Iterator<>() {.. and avoid the allocation here, but this is more like a personal preference.", "author": "mkleen", "createdAt": "2020-07-21T09:18:57Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3NTI5MQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457975291", "bodyText": "emptyIterator in any case returns a singleton and can be used directly. Assigning it to a different constant field wastes some memory for no reason.", "author": "mfussenegger", "createdAt": "2020-07-21T09:50:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1NjU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk2NjA4OQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457966089", "bodyText": "Minor: RegexpMatcher would be more consistent with the rest of the crate naming.", "author": "mkleen", "createdAt": "2020-07-21T09:34:45Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexMatcher.java", "diffHunk": "@@ -22,70 +22,37 @@\n package io.crate.expression.scalar.regex;\n \n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-public class RegexMatcher {\n+public abstract class RegexMatcher {", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk0ODY1Mg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457948652", "bodyText": "is this variable really necessary patternVal, you can probably just use pattern.", "author": "kovrus", "createdAt": "2020-07-21T09:05:25Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private final RegexMatcher regexMatcher;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable RegexMatcher regexMatcher) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.regexMatcher = regexMatcher;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    RegexMatcher regexMatcher() {\n+        return regexMatcher;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            String patternVal = literal.value();", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1ODUyNQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457958525", "bodyText": "i am wondering why this exception is swallowed and the null is returned, shouldn't we propagate this failure?", "author": "kovrus", "createdAt": "2020-07-21T09:22:09Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private final RegexMatcher regexMatcher;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable RegexMatcher regexMatcher) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.regexMatcher = regexMatcher;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    RegexMatcher regexMatcher() {\n+        return regexMatcher;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            String patternVal = literal.value();\n+            if (patternVal == null) {\n+                return this;\n+            }\n+            pattern = patternVal;\n+        }\n+        String flags = null;\n+        if (arguments.size() == 3) {\n+            assert arguments.get(2).symbolType() == SymbolType.LITERAL :\n+                \"3rd argument must be a \" + SymbolType.LITERAL;\n+            flags = ((Literal<String>) arguments.get(2)).value();\n+        }\n+        if (pattern != null) {\n+            return new MatchesFunction(\n+                signature, boundSignature, createMatcher(pattern, flags));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+        String value = (String) args[0].value();\n+        String pattern = (String) args[1].value();\n+        if (value == null || pattern == null) {\n+            return () -> NO_RESULTS_ITERATOR;\n+        }\n+\n+        RegexMatcher matcher;\n+        if (regexMatcher == null) {\n+            String flags = null;\n+            if (args.length == 3) {\n+                flags = (String) args[2].value();\n+            }\n+            matcher = createMatcher(pattern, flags);\n+        } else {\n+            matcher = regexMatcher;\n+        }\n+\n+        Iterator<Row> rowIterator;\n+        List<List<String>> rowGroups = matcher.match(value);\n+        if (rowGroups == null) {\n+            rowIterator = NO_RESULTS_ITERATOR;\n+        } else {\n+            rowIterator = new Iterator<>() {\n+\n+                final Object [] columns = new Object[]{ null };\n+                final RowN row = new RowN(columns);\n+                int idx = 0;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return idx < rowGroups.size();\n+                }\n+\n+                @Override\n+                public Row next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException(\"no more rows\");\n+                    }\n+                    columns[0] = rowGroups.get(idx++);\n+                    return row;\n+                }\n+            };\n+        }\n+        return () -> rowIterator;\n+    }\n+\n+    private static RegexMatcher createMatcher(String regex, @Nullable String flags) {\n+\n+        Function<Supplier<List<String>>, List<List<String>>> collector =\n+            RegexMatcher.isGlobal(flags) ?\n+                (supplier) -> {\n+                    List<List<String>> result = Stream\n+                        .generate(supplier)\n+                        .takeWhile(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+                    return result.isEmpty() ? null : result;\n+                }\n+                :\n+                (supplier) -> {\n+                    List<String> groups = supplier.get();\n+                    return groups != null ? List.of(groups) : null;\n+                };\n+        return new RegexMatcher(regex, flags) {\n+\n+            @Override\n+            public List<List<String>> match(String term) {\n+                Matcher matcher = initMatcher(term);\n+                return collector.apply(() -> {\n+                    if (!matcher.find()) {\n+                        return null;\n+                    }\n+                    int groupCount = matcher.groupCount();\n+                    if (groupCount == 0) {\n+                        try {\n+                            return List.of(matcher.group());\n+                        } catch (IllegalStateException e) {\n+                            return null;", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzMDQ0Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r458630446", "bodyText": "matcher.group() throws IllegalStateException:\n     *  If no match has yet been attempted,\n     *  or if the previous match operation failed\n\nRemoving try/catch block to propagate the exception :)", "author": "marregui", "createdAt": "2020-07-22T08:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1ODUyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk1OTg0MQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457959841", "bodyText": "maybe we can make this function nonnullable, then we probably won't have to handle special null cases here https://github.com/crate/crate/pull/10104/files#diff-4f4a1a2d0baa1a4764044bf3363dcba8R168 and use the same logic to handle both empty and non-empty cases?", "author": "kovrus", "createdAt": "2020-07-21T09:24:27Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private final RegexMatcher regexMatcher;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable RegexMatcher regexMatcher) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.regexMatcher = regexMatcher;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    RegexMatcher regexMatcher() {\n+        return regexMatcher;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            String patternVal = literal.value();\n+            if (patternVal == null) {\n+                return this;\n+            }\n+            pattern = patternVal;\n+        }\n+        String flags = null;\n+        if (arguments.size() == 3) {\n+            assert arguments.get(2).symbolType() == SymbolType.LITERAL :\n+                \"3rd argument must be a \" + SymbolType.LITERAL;\n+            flags = ((Literal<String>) arguments.get(2)).value();\n+        }\n+        if (pattern != null) {\n+            return new MatchesFunction(\n+                signature, boundSignature, createMatcher(pattern, flags));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+        String value = (String) args[0].value();\n+        String pattern = (String) args[1].value();\n+        if (value == null || pattern == null) {\n+            return () -> NO_RESULTS_ITERATOR;\n+        }\n+\n+        RegexMatcher matcher;\n+        if (regexMatcher == null) {\n+            String flags = null;\n+            if (args.length == 3) {\n+                flags = (String) args[2].value();\n+            }\n+            matcher = createMatcher(pattern, flags);\n+        } else {\n+            matcher = regexMatcher;\n+        }\n+\n+        Iterator<Row> rowIterator;\n+        List<List<String>> rowGroups = matcher.match(value);\n+        if (rowGroups == null) {\n+            rowIterator = NO_RESULTS_ITERATOR;\n+        } else {\n+            rowIterator = new Iterator<>() {\n+\n+                final Object [] columns = new Object[]{ null };\n+                final RowN row = new RowN(columns);\n+                int idx = 0;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return idx < rowGroups.size();\n+                }\n+\n+                @Override\n+                public Row next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException(\"no more rows\");\n+                    }\n+                    columns[0] = rowGroups.get(idx++);\n+                    return row;\n+                }\n+            };\n+        }\n+        return () -> rowIterator;\n+    }\n+\n+    private static RegexMatcher createMatcher(String regex, @Nullable String flags) {\n+\n+        Function<Supplier<List<String>>, List<List<String>>> collector =\n+            RegexMatcher.isGlobal(flags) ?\n+                (supplier) -> {\n+                    List<List<String>> result = Stream\n+                        .generate(supplier)\n+                        .takeWhile(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+                    return result.isEmpty() ? null : result;\n+                }\n+                :\n+                (supplier) -> {\n+                    List<String> groups = supplier.get();\n+                    return groups != null ? List.of(groups) : null;\n+                };\n+        return new RegexMatcher(regex, flags) {\n+\n+            @Override\n+            public List<List<String>> match(String term) {", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk2ODk3OA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457968978", "bodyText": "imho a simple for-loop would be more readable and it would avoid to/from object operations (not sure whether it is the case though)", "author": "kovrus", "createdAt": "2020-07-21T09:39:52Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private final RegexMatcher regexMatcher;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable RegexMatcher regexMatcher) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.regexMatcher = regexMatcher;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    RegexMatcher regexMatcher() {\n+        return regexMatcher;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            String patternVal = literal.value();\n+            if (patternVal == null) {\n+                return this;\n+            }\n+            pattern = patternVal;\n+        }\n+        String flags = null;\n+        if (arguments.size() == 3) {\n+            assert arguments.get(2).symbolType() == SymbolType.LITERAL :\n+                \"3rd argument must be a \" + SymbolType.LITERAL;\n+            flags = ((Literal<String>) arguments.get(2)).value();\n+        }\n+        if (pattern != null) {\n+            return new MatchesFunction(\n+                signature, boundSignature, createMatcher(pattern, flags));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+        String value = (String) args[0].value();\n+        String pattern = (String) args[1].value();\n+        if (value == null || pattern == null) {\n+            return () -> NO_RESULTS_ITERATOR;\n+        }\n+\n+        RegexMatcher matcher;\n+        if (regexMatcher == null) {\n+            String flags = null;\n+            if (args.length == 3) {\n+                flags = (String) args[2].value();\n+            }\n+            matcher = createMatcher(pattern, flags);\n+        } else {\n+            matcher = regexMatcher;\n+        }\n+\n+        Iterator<Row> rowIterator;\n+        List<List<String>> rowGroups = matcher.match(value);\n+        if (rowGroups == null) {\n+            rowIterator = NO_RESULTS_ITERATOR;\n+        } else {\n+            rowIterator = new Iterator<>() {\n+\n+                final Object [] columns = new Object[]{ null };\n+                final RowN row = new RowN(columns);\n+                int idx = 0;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return idx < rowGroups.size();\n+                }\n+\n+                @Override\n+                public Row next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException(\"no more rows\");\n+                    }\n+                    columns[0] = rowGroups.get(idx++);\n+                    return row;\n+                }\n+            };\n+        }\n+        return () -> rowIterator;\n+    }\n+\n+    private static RegexMatcher createMatcher(String regex, @Nullable String flags) {\n+\n+        Function<Supplier<List<String>>, List<List<String>>> collector =\n+            RegexMatcher.isGlobal(flags) ?\n+                (supplier) -> {\n+                    List<List<String>> result = Stream\n+                        .generate(supplier)\n+                        .takeWhile(Objects::nonNull)\n+                        .collect(Collectors.toList());\n+                    return result.isEmpty() ? null : result;\n+                }\n+                :\n+                (supplier) -> {\n+                    List<String> groups = supplier.get();\n+                    return groups != null ? List.of(groups) : null;\n+                };\n+        return new RegexMatcher(regex, flags) {\n+\n+            @Override\n+            public List<List<String>> match(String term) {\n+                Matcher matcher = initMatcher(term);\n+                return collector.apply(() -> {\n+                    if (!matcher.find()) {\n+                        return null;\n+                    }\n+                    int groupCount = matcher.groupCount();\n+                    if (groupCount == 0) {\n+                        try {\n+                            return List.of(matcher.group());\n+                        } catch (IllegalStateException e) {\n+                            return null;\n+                        }\n+                    }\n+                    return IntStream", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk2OTk5Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457969996", "bodyText": "stuff?", "author": "kovrus", "createdAt": "2020-07-21T09:41:36Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -140,6 +140,152 @@ The return value always matches the ``start`` / ``stop`` types.\n     +---------------+-----------------------------------+\n     SELECT 3 rows in set (... sec)\n \n+.. _table-functions-regexp-matches:\n+\n+``regexp_matches(source, pattern [, flags])``\n+=============================================\n+\n+Uses the regular expression ``pattern`` to match against the ``source`` string.\n+\n+The result rows have one column:\n+\n+.. list-table::\n+    :header-rows: 1\n+\n+    * - Column name\n+      - Description\n+    * - groups\n+      - ``array(text)``\n+\n+If ``pattern`` matches ``source``, an array of the matched regular expression\n+groups is returned.\n+\n+If no regular expression group was used, the whole pattern is used as a group.\n+\n+A regular expression group is formed by a subexpression that is surrounded by\n+parentheses. The position of a group is determined by the position of its\n+opening parenthesis.\n+\n+For example when matching the pattern ``\\b([A-Z])`` a match for the\n+subexpression ``([A-Z])`` would create group No. 1. If you want to group stuff", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3MjIyMQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457972221", "bodyText": "kind of similar what jordi commented already. The abstract RegexMatcher class is implemented partially by match and replace functions, which raises the question about using this abstraction. I'd better move related to functions logic closer to the implementation and maybe add some static factory methods that would hide things like https://github.com/crate/crate/pull/10104/files#diff-bffb730cd7513f358bd585218cd15286R172 and https://github.com/crate/crate/pull/10104/files#diff-4f4a1a2d0baa1a4764044bf3363dcba8R198", "author": "kovrus", "createdAt": "2020-07-21T09:45:22Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexMatcher.java", "diffHunk": "@@ -22,70 +22,37 @@\n package io.crate.expression.scalar.regex;\n \n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-public class RegexMatcher {\n+public abstract class RegexMatcher {", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3Mjg4OA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457972888", "bodyText": "is there a reason why Supplier is used here?", "author": "kovrus", "createdAt": "2020-07-21T09:46:36Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,236 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.scalar.regex.RegexMatcher;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.regex.Matcher;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+    private static final Iterator<Row> NO_RESULTS_ITERATOR = Collections.emptyIterator();\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private final RegexMatcher regexMatcher;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable RegexMatcher regexMatcher) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.regexMatcher = regexMatcher;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    RegexMatcher regexMatcher() {\n+        return regexMatcher;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            String patternVal = literal.value();\n+            if (patternVal == null) {\n+                return this;\n+            }\n+            pattern = patternVal;\n+        }\n+        String flags = null;\n+        if (arguments.size() == 3) {\n+            assert arguments.get(2).symbolType() == SymbolType.LITERAL :\n+                \"3rd argument must be a \" + SymbolType.LITERAL;\n+            flags = ((Literal<String>) arguments.get(2)).value();\n+        }\n+        if (pattern != null) {\n+            return new MatchesFunction(\n+                signature, boundSignature, createMatcher(pattern, flags));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+        String value = (String) args[0].value();\n+        String pattern = (String) args[1].value();\n+        if (value == null || pattern == null) {\n+            return () -> NO_RESULTS_ITERATOR;\n+        }\n+\n+        RegexMatcher matcher;\n+        if (regexMatcher == null) {\n+            String flags = null;\n+            if (args.length == 3) {\n+                flags = (String) args[2].value();\n+            }\n+            matcher = createMatcher(pattern, flags);\n+        } else {\n+            matcher = regexMatcher;\n+        }\n+\n+        Iterator<Row> rowIterator;\n+        List<List<String>> rowGroups = matcher.match(value);\n+        if (rowGroups == null) {\n+            rowIterator = NO_RESULTS_ITERATOR;\n+        } else {\n+            rowIterator = new Iterator<>() {\n+\n+                final Object [] columns = new Object[]{ null };\n+                final RowN row = new RowN(columns);\n+                int idx = 0;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return idx < rowGroups.size();\n+                }\n+\n+                @Override\n+                public Row next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException(\"no more rows\");\n+                    }\n+                    columns[0] = rowGroups.get(idx++);\n+                    return row;\n+                }\n+            };\n+        }\n+        return () -> rowIterator;\n+    }\n+\n+    private static RegexMatcher createMatcher(String regex, @Nullable String flags) {\n+\n+        Function<Supplier<List<String>>, List<List<String>>> collector =", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3NDc5Mw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457974793", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              row contains a single column ``groups`` of type ``text_array``.\n          \n          \n            \n              row contains a single column ``groups`` of type ``array(text)``.\n          \n      \n    \n    \n  \n\nor smth similar, the text_array smth more like an internal representation.", "author": "kovrus", "createdAt": "2020-07-21T09:50:01Z", "path": "docs/appendices/release-notes/unreleased.rst", "diffHunk": "@@ -42,7 +42,10 @@ Unreleased Changes\n Breaking Changes\n ================\n \n-None\n+- Added support for flag ``g`` to function\n+  :ref:`regexp_matches <table-functions-regexp-matches>` and changed\n+  its type from ``scalar`` to ``table`` type. It now returns a table where each\n+  row contains a single column ``groups`` of type ``text_array``.", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3NjMxMw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r457976313", "bodyText": "I'm not sure I like the design of the new abstraction here.\nIs the availability of these two methods depending on the g flag? Or why we do need to have these two methods in a base class when they can be unavailable?", "author": "mfussenegger", "createdAt": "2020-07-21T09:52:43Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexMatcher.java", "diffHunk": "@@ -22,70 +22,37 @@\n package io.crate.expression.scalar.regex;\n \n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-public class RegexMatcher {\n+public abstract class RegexMatcher {\n \n-    private final boolean globalFlag;\n     private final Pattern pattern;\n     private Matcher matcher;\n \n-    public RegexMatcher(String regex, int flags, boolean globalFlag) {\n-        pattern = Pattern.compile(regex, flags);\n-        this.globalFlag = globalFlag;\n-    }\n-\n     public RegexMatcher(String regex, @Nullable String flags) {\n-        this(regex, parseFlags(flags), isGlobal(flags));\n-    }\n-\n-    public RegexMatcher(String regex) {\n-        this(regex, 0, false);\n-    }\n-\n-    public boolean match(String term) {\n-        initMatcher(term);\n-        return matcher.find();\n-    }\n-\n-    @Nullable\n-    public List<String> groups() {\n-        int groupCount = matcher.groupCount();\n-        if (groupCount == 0) {\n-            try {\n-                return List.of(matcher.group());\n-            } catch (IllegalStateException e) {\n-                return null;\n-            }\n-        }\n-        ArrayList<String> groups = new ArrayList<>(groupCount);\n-        for (int i = 0; i < groupCount; i++) {\n-            groups.add(matcher.group(i + 1));\n-        }\n-        return groups;\n+        pattern = Pattern.compile(regex, parseFlags(flags));\n     }\n \n-    public String replace(String term, String replacement) {\n-        initMatcher(term);\n-        if (globalFlag) {\n-            return matcher.replaceAll(replacement);\n-        } else {\n-            return matcher.replaceFirst(replacement);\n-        }\n-    }\n-\n-    private void initMatcher(String term) {\n+    protected Matcher initMatcher(String term) {\n         if (matcher == null) {\n             matcher = pattern.matcher(term);\n         } else {\n             matcher.reset(term);\n         }\n+        return matcher;\n     }\n \n-    public static int parseFlags(@Nullable String flagsString) {\n+    public List<List<String>> match(String term) {\n+        throw new UnsupportedOperationException(\"method not available\");\n+    }\n+\n+    public String replace(String term, String replacement) {\n+        throw new UnsupportedOperationException(\"method not available\");\n+    }\n+", "originalCommit": "4d98613ddd524d8fccd4b634bd3513cce8b578a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODYzODk0NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r458638944", "bodyText": "Well, Pattern/Matcher provide functionality to replace and match, each exposed by a different function (regexp_replace and regexp_matches). Before both functions shared the same package, but now the later function is a table function, so it has been refactored to a different package.\nBoth functions accept flags, including g, however this flag results in a behaviour not included by Matcher and thus needs to be provided by a subclass. I modelled it in this way because I evolved the code from what existed and because the g spot is common to both functions.\nI will give it another round, to see if I can impress this time.", "author": "marregui", "createdAt": "2020-07-22T08:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzk3NjMxMw=="}], "type": "inlineReview"}, {"oid": "5511c6f95824a3fdfe1159f71fcd989f2c4a42c1", "url": "https://github.com/crate/crate/commit/5511c6f95824a3fdfe1159f71fcd989f2c4a42c1", "message": "Cosmetic changes pass 1, the least meaty changes", "committedDate": "2020-07-22T08:43:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1MTE0NQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r458651145", "bodyText": "occurence = occurrence", "author": "infoverload", "createdAt": "2020-07-22T09:12:24Z", "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -1711,78 +1711,33 @@ See the api documentation for more details.\n \n .. _Lucene Regular Expressions: http://lucene.apache.org/core/4_9_0/core/org/apache/lucene/util/automaton/RegExp.html\n \n-.. _scalar-regexp-matches:\n-\n-``regexp_matches(source, pattern [, flags])``\n----------------------------------------------\n-\n-This function uses the regular expression pattern in ``pattern`` to match\n-against the ``source`` string.\n-\n-Returns: ``text_array``\n-\n-If ``source`` matches, an array of the matched regular expression groups is\n-returned.\n-\n-If no regular expression group was used, the whole pattern is used as a group.\n-\n-If ``source`` does not match, this function returns ``NULL``.\n-\n-A regular expression group is formed by a subexpression that is surrounded by\n-parentheses.The position of a group is determined by the position of its\n-opening parenthesis.\n-\n-For example when matching the pattern ``\\b([A-Z])`` a match for the\n-subexpression ``([A-Z])`` would create group No. 1. If you want to group stuff\n-with parentheses, but without grouping, use ``(?...)``.\n-\n-For example matching the regular expression ``([Aa](.+)z)`` against\n-``alcatraz``, results in these groups:\n-\n- * group 1: ``alcatraz`` (from first to last parenthesis or whole pattern)\n- * group 2: ``lcatra`` (beginning at second parenthesis)\n-\n-The ``regexp_matches`` function will return all groups as a ``text`` array::\n-\n-    cr> select regexp_matches('alcatraz', '(a(.+)z)') as matched;\n-    +------------------------+\n-    | matched                |\n-    +------------------------+\n-    | [\"alcatraz\", \"lcatra\"] |\n-    +------------------------+\n-    SELECT 1 row in set (... sec)\n-\n-::\n+``regexp_replace(source, pattern, replacement [, flags])``\n+----------------------------------------------------------\n \n-    cr> select regexp_matches('alcatraz', 'traz') as matched;\n-    +----------+\n-    | matched  |\n-    +----------+\n-    | [\"traz\"] |\n-    +----------+\n-    SELECT 1 row in set (... sec)\n+``regexp_replace`` can be used to replace every (or only the first) occurence", "originalCommit": "5511c6f95824a3fdfe1159f71fcd989f2c4a42c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1Mjg1NQ==", "url": "https://github.com/crate/crate/pull/10104#discussion_r458652855", "bodyText": "java = Java", "author": "infoverload", "createdAt": "2020-07-22T09:15:25Z", "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -1711,78 +1711,33 @@ See the api documentation for more details.\n \n .. _Lucene Regular Expressions: http://lucene.apache.org/core/4_9_0/core/org/apache/lucene/util/automaton/RegExp.html\n \n-.. _scalar-regexp-matches:\n-\n-``regexp_matches(source, pattern [, flags])``\n----------------------------------------------\n-\n-This function uses the regular expression pattern in ``pattern`` to match\n-against the ``source`` string.\n-\n-Returns: ``text_array``\n-\n-If ``source`` matches, an array of the matched regular expression groups is\n-returned.\n-\n-If no regular expression group was used, the whole pattern is used as a group.\n-\n-If ``source`` does not match, this function returns ``NULL``.\n-\n-A regular expression group is formed by a subexpression that is surrounded by\n-parentheses.The position of a group is determined by the position of its\n-opening parenthesis.\n-\n-For example when matching the pattern ``\\b([A-Z])`` a match for the\n-subexpression ``([A-Z])`` would create group No. 1. If you want to group stuff\n-with parentheses, but without grouping, use ``(?...)``.\n-\n-For example matching the regular expression ``([Aa](.+)z)`` against\n-``alcatraz``, results in these groups:\n-\n- * group 1: ``alcatraz`` (from first to last parenthesis or whole pattern)\n- * group 2: ``lcatra`` (beginning at second parenthesis)\n-\n-The ``regexp_matches`` function will return all groups as a ``text`` array::\n-\n-    cr> select regexp_matches('alcatraz', '(a(.+)z)') as matched;\n-    +------------------------+\n-    | matched                |\n-    +------------------------+\n-    | [\"alcatraz\", \"lcatra\"] |\n-    +------------------------+\n-    SELECT 1 row in set (... sec)\n-\n-::\n+``regexp_replace(source, pattern, replacement [, flags])``\n+----------------------------------------------------------\n \n-    cr> select regexp_matches('alcatraz', 'traz') as matched;\n-    +----------+\n-    | matched  |\n-    +----------+\n-    | [\"traz\"] |\n-    +----------+\n-    SELECT 1 row in set (... sec)\n+``regexp_replace`` can be used to replace every (or only the first) occurence\n+of a subsequence matching ``pattern`` in the ``source`` string with the\n+``replacement`` string. If no subsequence in ``source`` matches the regular\n+expression ``pattern``, ``source`` is returned unchanged.\n \n-Through array element access functionality, a group can be selected directly.\n-See :ref:`sql_dql_object_arrays_select` for details.\n+Returns: ``text``\n \n-::\n+``pattern`` is a java regular expression. For details on the regexp syntax, see", "originalCommit": "5511c6f95824a3fdfe1159f71fcd989f2c4a42c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1MzE0NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r458653144", "bodyText": "Per default = By default", "author": "infoverload", "createdAt": "2020-07-22T09:15:56Z", "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -1711,78 +1711,33 @@ See the api documentation for more details.\n \n .. _Lucene Regular Expressions: http://lucene.apache.org/core/4_9_0/core/org/apache/lucene/util/automaton/RegExp.html\n \n-.. _scalar-regexp-matches:\n-\n-``regexp_matches(source, pattern [, flags])``\n----------------------------------------------\n-\n-This function uses the regular expression pattern in ``pattern`` to match\n-against the ``source`` string.\n-\n-Returns: ``text_array``\n-\n-If ``source`` matches, an array of the matched regular expression groups is\n-returned.\n-\n-If no regular expression group was used, the whole pattern is used as a group.\n-\n-If ``source`` does not match, this function returns ``NULL``.\n-\n-A regular expression group is formed by a subexpression that is surrounded by\n-parentheses.The position of a group is determined by the position of its\n-opening parenthesis.\n-\n-For example when matching the pattern ``\\b([A-Z])`` a match for the\n-subexpression ``([A-Z])`` would create group No. 1. If you want to group stuff\n-with parentheses, but without grouping, use ``(?...)``.\n-\n-For example matching the regular expression ``([Aa](.+)z)`` against\n-``alcatraz``, results in these groups:\n-\n- * group 1: ``alcatraz`` (from first to last parenthesis or whole pattern)\n- * group 2: ``lcatra`` (beginning at second parenthesis)\n-\n-The ``regexp_matches`` function will return all groups as a ``text`` array::\n-\n-    cr> select regexp_matches('alcatraz', '(a(.+)z)') as matched;\n-    +------------------------+\n-    | matched                |\n-    +------------------------+\n-    | [\"alcatraz\", \"lcatra\"] |\n-    +------------------------+\n-    SELECT 1 row in set (... sec)\n-\n-::\n+``regexp_replace(source, pattern, replacement [, flags])``\n+----------------------------------------------------------\n \n-    cr> select regexp_matches('alcatraz', 'traz') as matched;\n-    +----------+\n-    | matched  |\n-    +----------+\n-    | [\"traz\"] |\n-    +----------+\n-    SELECT 1 row in set (... sec)\n+``regexp_replace`` can be used to replace every (or only the first) occurence\n+of a subsequence matching ``pattern`` in the ``source`` string with the\n+``replacement`` string. If no subsequence in ``source`` matches the regular\n+expression ``pattern``, ``source`` is returned unchanged.\n \n-Through array element access functionality, a group can be selected directly.\n-See :ref:`sql_dql_object_arrays_select` for details.\n+Returns: ``text``\n \n-::\n+``pattern`` is a java regular expression. For details on the regexp syntax, see\n+`Java Regular Expressions`_.\n \n-    cr> select regexp_matches('alcatraz', '(a(.+)z)')[2] as second_group;\n-    +--------------+\n-    | second_group |\n-    +--------------+\n-    | lcatra       |\n-    +--------------+\n-    SELECT 1 row in set (... sec)\n+The ``replacement`` string may contain expressions like ``$N`` where ``N`` is a\n+digit between 0 and 9. It references the *N*\\ th matched group of ``pattern``\n+and the matching subsequence of that group will be inserted in the returned\n+string. The expression ``$0`` will insert the whole matching ``source``.\n \n-.. _scalar-regexp-matches-flags:\n+Per default, only the first occurrence of a subsequence matching ``pattern``", "originalCommit": "5511c6f95824a3fdfe1159f71fcd989f2c4a42c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1NjY5NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r458656694", "bodyText": "as optional third parameter = as optional parameters", "author": "infoverload", "createdAt": "2020-07-22T09:21:45Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -140,6 +140,152 @@ The return value always matches the ``start`` / ``stop`` types.\n     +---------------+-----------------------------------+\n     SELECT 3 rows in set (... sec)\n \n+.. _table-functions-regexp-matches:\n+\n+``regexp_matches(source, pattern [, flags])``\n+=============================================\n+\n+Uses the regular expression ``pattern`` to match against the ``source`` string.\n+\n+The result rows have one column:\n+\n+.. list-table::\n+    :header-rows: 1\n+\n+    * - Column name\n+      - Description\n+    * - groups\n+      - ``array(text)``\n+\n+If ``pattern`` matches ``source``, an array of the matched regular expression\n+groups is returned.\n+\n+If no regular expression group was used, the whole pattern is used as a group.\n+\n+A regular expression group is formed by a subexpression that is surrounded by\n+parentheses. The position of a group is determined by the position of its\n+opening parenthesis.\n+\n+For example when matching the pattern ``\\b([A-Z])`` a match for the\n+subexpression ``([A-Z])`` would create group No. 1. If you want to group items\n+with parentheses, but without grouping, use ``(?...)``.\n+\n+For example matching the regular expression ``([Aa](.+)z)`` against\n+``alcatraz``, results in these groups:\n+\n+ * group 1: ``alcatraz`` (from first to last parenthesis or whole pattern)\n+ * group 2: ``lcatra`` (beginning at second parenthesis)\n+\n+The ``regexp_matches`` function will return all groups as a ``text`` array::\n+\n+    cr> select regexp_matches('alcatraz', '(a(.+)z)') as matched;\n+    +------------------------+\n+    | matched                |\n+    +------------------------+\n+    | [\"alcatraz\", \"lcatra\"] |\n+    +------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+::\n+\n+    cr> select regexp_matches('alcatraz', 'traz') as matched;\n+    +----------+\n+    | matched  |\n+    +----------+\n+    | [\"traz\"] |\n+    +----------+\n+    SELECT 1 row in set (... sec)\n+\n+Through array element access functionality, a group can be selected directly.\n+See :ref:`sql_dql_object_arrays_select` for details.\n+\n+::\n+\n+    cr> select regexp_matches('alcatraz', '(a(.+)z)')[2] as second_group;\n+    +--------------+\n+    | second_group |\n+    +--------------+\n+    | lcatra       |\n+    +--------------+\n+    SELECT 1 row in set (... sec)\n+\n+.. _table-functions-regexp-matches-flags:\n+\n+Flags\n+.....\n+\n+This function takes a number of flags as optional third parameter. These flags", "originalCommit": "5511c6f95824a3fdfe1159f71fcd989f2c4a42c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY1NzA2MA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r458657060", "bodyText": "as optional third parameter = as an optional parameter", "author": "infoverload", "createdAt": "2020-07-22T09:22:19Z", "path": "docs/general/builtins/scalar.rst", "diffHunk": "@@ -1711,78 +1711,33 @@ See the api documentation for more details.\n \n .. _Lucene Regular Expressions: http://lucene.apache.org/core/4_9_0/core/org/apache/lucene/util/automaton/RegExp.html\n \n-.. _scalar-regexp-matches:\n-\n-``regexp_matches(source, pattern [, flags])``\n----------------------------------------------\n-\n-This function uses the regular expression pattern in ``pattern`` to match\n-against the ``source`` string.\n-\n-Returns: ``text_array``\n-\n-If ``source`` matches, an array of the matched regular expression groups is\n-returned.\n-\n-If no regular expression group was used, the whole pattern is used as a group.\n-\n-If ``source`` does not match, this function returns ``NULL``.\n-\n-A regular expression group is formed by a subexpression that is surrounded by\n-parentheses.The position of a group is determined by the position of its\n-opening parenthesis.\n-\n-For example when matching the pattern ``\\b([A-Z])`` a match for the\n-subexpression ``([A-Z])`` would create group No. 1. If you want to group stuff\n-with parentheses, but without grouping, use ``(?...)``.\n-\n-For example matching the regular expression ``([Aa](.+)z)`` against\n-``alcatraz``, results in these groups:\n-\n- * group 1: ``alcatraz`` (from first to last parenthesis or whole pattern)\n- * group 2: ``lcatra`` (beginning at second parenthesis)\n-\n-The ``regexp_matches`` function will return all groups as a ``text`` array::\n-\n-    cr> select regexp_matches('alcatraz', '(a(.+)z)') as matched;\n-    +------------------------+\n-    | matched                |\n-    +------------------------+\n-    | [\"alcatraz\", \"lcatra\"] |\n-    +------------------------+\n-    SELECT 1 row in set (... sec)\n-\n-::\n+``regexp_replace(source, pattern, replacement [, flags])``\n+----------------------------------------------------------\n \n-    cr> select regexp_matches('alcatraz', 'traz') as matched;\n-    +----------+\n-    | matched  |\n-    +----------+\n-    | [\"traz\"] |\n-    +----------+\n-    SELECT 1 row in set (... sec)\n+``regexp_replace`` can be used to replace every (or only the first) occurence\n+of a subsequence matching ``pattern`` in the ``source`` string with the\n+``replacement`` string. If no subsequence in ``source`` matches the regular\n+expression ``pattern``, ``source`` is returned unchanged.\n \n-Through array element access functionality, a group can be selected directly.\n-See :ref:`sql_dql_object_arrays_select` for details.\n+Returns: ``text``\n \n-::\n+``pattern`` is a java regular expression. For details on the regexp syntax, see\n+`Java Regular Expressions`_.\n \n-    cr> select regexp_matches('alcatraz', '(a(.+)z)')[2] as second_group;\n-    +--------------+\n-    | second_group |\n-    +--------------+\n-    | lcatra       |\n-    +--------------+\n-    SELECT 1 row in set (... sec)\n+The ``replacement`` string may contain expressions like ``$N`` where ``N`` is a\n+digit between 0 and 9. It references the *N*\\ th matched group of ``pattern``\n+and the matching subsequence of that group will be inserted in the returned\n+string. The expression ``$0`` will insert the whole matching ``source``.\n \n-.. _scalar-regexp-matches-flags:\n+Per default, only the first occurrence of a subsequence matching ``pattern``\n+will be replaced. If all occurrences shall be replaced use the ``g`` flag.\n \n Flags\n .....\n \n-This function takes a number of flags as optional third parameter. These flags\n-are given as a string containing any of the characters listed below. Order does\n-not matter.\n+``regexp_replace`` supports a number of flags as optional third parameter. These", "originalCommit": "5511c6f95824a3fdfe1159f71fcd989f2c4a42c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "92cf07cb1e112d519fa44dfc2ab7b2ed4f17f5d3", "url": "https://github.com/crate/crate/commit/92cf07cb1e112d519fa44dfc2ab7b2ed4f17f5d3", "message": "Daisy's feedback, thank you!", "committedDate": "2020-07-22T11:47:44Z", "type": "forcePushed"}, {"oid": "56d325f2ead2b3b9a4da5df6abcd5dcdf8bd10ce", "url": "https://github.com/crate/crate/commit/56d325f2ead2b3b9a4da5df6abcd5dcdf8bd10ce", "message": "Catch null pointer exception", "committedDate": "2020-07-24T11:15:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MDE3NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460790174", "bodyText": "is it possible to replace this stream with something like:\nvar group = groups(matcher);\nwhile (group != null) {\n    rowGroups.add(...)\n    group = groups(matcher)\n}", "author": "kovrus", "createdAt": "2020-07-27T10:17:14Z", "path": "server/src/main/java/io/crate/expression/tablefunctions/MatchesFunction.java", "diffHunk": "@@ -0,0 +1,208 @@\n+/*\n+ * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n+ * license agreements.  See the NOTICE file distributed with this work for\n+ * additional information regarding copyright ownership.  Crate licenses\n+ * this file to you under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.  You may\n+ * obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *\n+ * However, if you have executed another commercial license agreement\n+ * with Crate these terms will supersede the license and you may use the\n+ * software solely pursuant to the terms of the relevant commercial agreement.\n+ */\n+\n+package io.crate.expression.tablefunctions;\n+\n+import io.crate.common.annotations.VisibleForTesting;\n+import io.crate.data.Input;\n+import io.crate.data.Row;\n+import io.crate.data.RowN;\n+import io.crate.expression.symbol.Literal;\n+import io.crate.expression.symbol.Symbol;\n+import io.crate.expression.symbol.SymbolType;\n+import io.crate.metadata.Scalar;\n+import io.crate.metadata.TransactionContext;\n+import io.crate.metadata.functions.Signature;\n+import io.crate.metadata.tablefunctions.TableFunctionImplementation;\n+import io.crate.types.DataTypes;\n+import io.crate.types.RowType;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static io.crate.expression.RegexpFlagsHelper.parseFlags;\n+import static io.crate.expression.RegexpFlagsHelper.isGlobal;\n+\n+public final class MatchesFunction extends TableFunctionImplementation<List<Object>> {\n+\n+    public static final String NAME = \"regexp_matches\";\n+    private static final RowType ROW_TYPE = new RowType(\n+        List.of(DataTypes.STRING_ARRAY), List.of(\"groups\"));\n+\n+    public static void register(TableFunctionModule module) {\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+        module.register(\n+            Signature.table(\n+                NAME,\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING.getTypeSignature(),\n+                DataTypes.STRING_ARRAY.getTypeSignature()\n+            ),\n+            MatchesFunction::new\n+        );\n+    }\n+\n+    @Nullable\n+    private Pattern pattern;\n+    private final Signature signature;\n+    private final Signature boundSignature;\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature) {\n+        this(signature, boundSignature, null);\n+    }\n+\n+    private MatchesFunction(Signature signature, Signature boundSignature, @Nullable Pattern pattern) {\n+        this.signature = signature;\n+        this.boundSignature = boundSignature;\n+        this.pattern = pattern;\n+    }\n+\n+    @Override\n+    public Signature signature() {\n+        return signature;\n+    }\n+\n+    @Override\n+    public Signature boundSignature() {\n+        return boundSignature;\n+    }\n+\n+    @Override\n+    public RowType returnType() {\n+        return ROW_TYPE;\n+    }\n+\n+    @Override\n+    public boolean hasLazyResultSet() {\n+        return false;\n+    }\n+\n+    @VisibleForTesting\n+    Pattern pattern() {\n+        return pattern;\n+    }\n+\n+    @Override\n+    public Scalar<Iterable<Row>, List<Object>> compile(List<Symbol> arguments) {\n+        assert arguments.size() > 1 : \"number of arguments must be > 1\";\n+        String pattern = null;\n+        if (arguments.get(1).symbolType() == SymbolType.LITERAL) {\n+            Literal<String> literal = (Literal<String>) arguments.get(1);\n+            pattern = literal.value();\n+            if (pattern == null) {\n+                return this;\n+            }\n+        }\n+        String flags = null;\n+        if (arguments.size() == 3) {\n+            assert arguments.get(2).symbolType() == SymbolType.LITERAL :\n+                \"3rd argument must be a \" + SymbolType.LITERAL;\n+            flags = ((Literal<String>) arguments.get(2)).value();\n+        }\n+        if (pattern != null) {\n+            return new MatchesFunction(\n+                signature, boundSignature, Pattern.compile(pattern, parseFlags(flags)));\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public Iterable<Row> evaluate(TransactionContext txnCtx, Input[] args) {\n+        assert args.length == 2 || args.length == 3 : \"number of args must be 2 or 3\";\n+\n+        String value = (String) args[0].value();\n+        String pattern = (String) args[1].value();\n+        if (value == null || pattern == null) {\n+            return () -> Collections.emptyIterator();\n+        }\n+        String flags = null;\n+        if (args.length == 3) {\n+            flags = (String) args[2].value();\n+        }\n+\n+        if (this.pattern == null) {\n+            this.pattern = Pattern.compile(pattern, parseFlags(flags));\n+        }\n+        Matcher matcher = this.pattern.matcher(value);\n+        List<List<String>> rowGroups;\n+        if (isGlobal(flags)) {\n+            rowGroups = Stream", "originalCommit": "56d325f2ead2b3b9a4da5df6abcd5dcdf8bd10ce", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5NzQwMw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460797403", "bodyText": "yes, I was proud of that snippet!", "author": "marregui", "createdAt": "2020-07-27T10:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDc5MDE3NA=="}], "type": "inlineReview"}, {"oid": "06af923fd9bedbea8473e02499b70ca337bfef5f", "url": "https://github.com/crate/crate/commit/06af923fd9bedbea8473e02499b70ca337bfef5f", "message": "Remove streams, I prefer them though", "committedDate": "2020-07-27T10:29:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyNDg0Ng==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460824846", "bodyText": "maybe final or do we really have to mutate it in the evaluate?", "author": "kovrus", "createdAt": "2020-07-27T11:29:10Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexpReplaceFunction.java", "diffHunk": "@@ -65,16 +70,16 @@ public static void register(ScalarFunctionModule module) {\n     private final Signature signature;\n     private final Signature boundSignature;\n     @Nullable\n-    private final RegexMatcher regexMatcher;\n+    private Pattern pattern;", "originalCommit": "06af923fd9bedbea8473e02499b70ca337bfef5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg1NjI5Mg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460856292", "bodyText": "compile creates the Pattern.", "author": "marregui", "createdAt": "2020-07-27T12:33:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyNDg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg1NzAyNg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460857026", "bodyText": "i was talking about the mutation here https://github.com/crate/crate/pull/10104/files#diff-bffb730cd7513f358bd585218cd15286R155", "author": "kovrus", "createdAt": "2020-07-27T12:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyNDg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg3NTA1NA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460875054", "bodyText": "evaluate does not mutate pattern, it checks whether it was initialised (compile would do this), and if not, then it initialises it. I kind of preserved this logic from the previous scalar implementation.", "author": "marregui", "createdAt": "2020-07-27T13:05:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgyNDg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNDU4Mg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460834582", "bodyText": "Same here as in the generate_subscripts PR. I think for users it would be helpful to have a sentence or two for each example, explaining what is shown.\nI'm also not sure what the difference between the last two examples is? Feels a bit like proofing that it works instead of illustrating the user how it can be used.", "author": "mfussenegger", "createdAt": "2020-07-27T11:49:50Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -198,6 +198,152 @@ arrays within the same level.\n     +---+\n     SELECT 2 rows in set (... sec)\n \n+.. _table-functions-regexp-matches:\n+\n+``regexp_matches(source, pattern [, flags])``\n+=============================================\n+\n+Uses the regular expression ``pattern`` to match against the ``source`` string.\n+\n+The result rows have one column:\n+\n+.. list-table::\n+    :header-rows: 1\n+\n+    * - Column name\n+      - Description\n+    * - groups\n+      - ``array(text)``\n+\n+If ``pattern`` matches ``source``, an array of the matched regular expression\n+groups is returned.\n+\n+If no regular expression group was used, the whole pattern is used as a group.\n+\n+A regular expression group is formed by a subexpression that is surrounded by\n+parentheses. The position of a group is determined by the position of its\n+opening parenthesis.\n+\n+For example when matching the pattern ``\\b([A-Z])`` a match for the\n+subexpression ``([A-Z])`` would create group No. 1. If you want to group items\n+with parentheses, but without grouping, use ``(?...)``.\n+\n+For example matching the regular expression ``([Aa](.+)z)`` against\n+``alcatraz``, results in these groups:\n+\n+ * group 1: ``alcatraz`` (from first to last parenthesis or whole pattern)\n+ * group 2: ``lcatra`` (beginning at second parenthesis)\n+\n+The ``regexp_matches`` function will return all groups as a ``text`` array::\n+\n+    cr> select regexp_matches('alcatraz', '(a(.+)z)') as matched;\n+    +------------------------+\n+    | matched                |\n+    +------------------------+\n+    | [\"alcatraz\", \"lcatra\"] |\n+    +------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+::\n+\n+    cr> select regexp_matches('alcatraz', 'traz') as matched;\n+    +----------+\n+    | matched  |\n+    +----------+\n+    | [\"traz\"] |\n+    +----------+\n+    SELECT 1 row in set (... sec)\n+\n+Through array element access functionality, a group can be selected directly.\n+See :ref:`sql_dql_object_arrays_select` for details.\n+\n+::\n+\n+    cr> select regexp_matches('alcatraz', '(a(.+)z)')[2] as second_group;\n+    +--------------+\n+    | second_group |\n+    +--------------+\n+    | lcatra       |\n+    +--------------+\n+    SELECT 1 row in set (... sec)\n+\n+.. _table-functions-regexp-matches-flags:\n+\n+Flags\n+.....\n+\n+This function takes a number of flags as optional third parameter. These flags\n+are given as a string containing any of the characters listed below. Order does\n+not matter.\n+\n++-------+---------------------------------------------------------------------+\n+| Flag  | Description                                                         |\n++=======+=====================================================================+\n+| ``i`` | enable case insensitive matching                                    |\n++-------+---------------------------------------------------------------------+\n+| ``u`` | enable unicode case folding when used together with ``i``           |\n++-------+---------------------------------------------------------------------+\n+| ``U`` | enable unicode support for character classes like ``\\W``            |\n++-------+---------------------------------------------------------------------+\n+| ``s`` | make ``.`` match line terminators, too                              |\n++-------+---------------------------------------------------------------------+\n+| ``m`` | make ``^`` and ``$`` match on the beginning or end of a line        |\n+|       | too.                                                                |\n++-------+---------------------------------------------------------------------+\n+| ``x`` | permit whitespace and line comments starting with ``#``             |\n++-------+---------------------------------------------------------------------+\n+| ``d`` | only ``\\n`` is considered a line-terminator when using ``^``, ``$`` |\n+|       | and ``.``                                                           |\n++-------+---------------------------------------------------------------------+\n+| ``g`` | keep matching until the end of ``source``, instead of stopping at   |\n+|       | the first match.                                                    |\n++-------+---------------------------------------------------------------------+\n+\n+\n+Examples\n+........\n+\n+::\n+\n+    cr> select regexp_matches('foobar', '^(a(.+)z)$') as matched;\n+    +---------+\n+    | matched |\n+    +---------+\n+    +---------+\n+    SELECT 0 rows in set (... sec)\n+\n+::\n+\n+    cr> select regexp_matches('99 bottles of beer on the wall', '\\d{2}\\s(\\w+).*', 'ixU')\n+    ... as matched;\n+    +-------------+\n+    | matched     |\n+    +-------------+\n+    | [\"bottles\"] |\n+    +-------------+\n+    SELECT 1 row in set (... sec)\n+\n+::\n+\n+    cr>  select regexp_matches('#abc #def #ghi #jkl', '(#[^\\s]*) (#[^\\s]*)', 'g') as matched;\n+    +------------------+\n+    | matched          |\n+    +------------------+\n+    | [\"#abc\", \"#def\"] |\n+    | [\"#ghi\", \"#jkl\"] |\n+    +------------------+\n+    SELECT 2 rows in set (... sec)\n+\n+::\n+\n+    cr> select regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g') as matched;\n+    +-------------------+\n+    | matched           |\n+    +-------------------+\n+    | [\"bar\", \"beque\"]  |\n+    | [\"bazil\", \"barf\"] |\n+    +-------------------+\n+    SELECT 2 rows in set (... sec)", "originalCommit": "06af923fd9bedbea8473e02499b70ca337bfef5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNDgzOA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460834838", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public final class RegexpFlagsHelper {\n          \n          \n            \n            public final class RegexpFlags {\n          \n      \n    \n    \n  \n\nNot sure if Helper adds anything useful to readers.", "author": "mfussenegger", "createdAt": "2020-07-27T11:50:18Z", "path": "server/src/main/java/io/crate/expression/RegexpFlagsHelper.java", "diffHunk": "@@ -1,89 +1,31 @@\n /*\n- * Licensed to CRATE Technology GmbH (\"Crate\") under one or more contributor\n- * license agreements.  See the NOTICE file distributed with this work for\n- * additional information regarding copyright ownership.  Crate licenses\n- * this file to you under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.  You may\n+ * Licensed to Crate under one or more contributor license agreements.\n+ * See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.  Crate licenses this file\n+ * to you under the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.  You may\n  * obtain a copy of the License at\n  *\n  *     http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+ * implied.  See the License for the specific language governing\n+ * permissions and limitations under the License.\n  *\n  * However, if you have executed another commercial license agreement\n  * with Crate these terms will supersede the license and you may use the\n- * software solely pursuant to the terms of the relevant commercial agreement.\n+ * software solely pursuant to the terms of the relevant commercial\n+ * agreement.\n  */\n \n-package io.crate.expression.scalar.regex;\n+package io.crate.expression;\n \n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n-public class RegexMatcher {\n-\n-    private final boolean globalFlag;\n-    private final Pattern pattern;\n-    private Matcher matcher;\n-\n-    public RegexMatcher(String regex, int flags, boolean globalFlag) {\n-        pattern = Pattern.compile(regex, flags);\n-        this.globalFlag = globalFlag;\n-    }\n-\n-    public RegexMatcher(String regex, @Nullable String flags) {\n-        this(regex, parseFlags(flags), isGlobal(flags));\n-    }\n-\n-    public RegexMatcher(String regex) {\n-        this(regex, 0, false);\n-    }\n-\n-    public boolean match(String term) {\n-        initMatcher(term);\n-        return matcher.find();\n-    }\n-\n-    @Nullable\n-    public List<String> groups() {\n-        int groupCount = matcher.groupCount();\n-        if (groupCount == 0) {\n-            try {\n-                return List.of(matcher.group());\n-            } catch (IllegalStateException e) {\n-                return null;\n-            }\n-        }\n-        ArrayList<String> groups = new ArrayList<>(groupCount);\n-        for (int i = 0; i < groupCount; i++) {\n-            groups.add(matcher.group(i + 1));\n-        }\n-        return groups;\n-    }\n-\n-    public String replace(String term, String replacement) {\n-        initMatcher(term);\n-        if (globalFlag) {\n-            return matcher.replaceAll(replacement);\n-        } else {\n-            return matcher.replaceFirst(replacement);\n-        }\n-    }\n-\n-    private void initMatcher(String term) {\n-        if (matcher == null) {\n-            matcher = pattern.matcher(term);\n-        } else {\n-            matcher.reset(term);\n-        }\n-    }\n+public final class RegexpFlagsHelper {", "originalCommit": "06af923fd9bedbea8473e02499b70ca337bfef5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDgzNTUxNg==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460835516", "bodyText": "Are all arguments String? If so the generic definition could be changed, eliminating the casts here.", "author": "mfussenegger", "createdAt": "2020-07-27T11:51:48Z", "path": "server/src/main/java/io/crate/expression/scalar/regex/RegexpReplaceFunction.java", "diffHunk": "@@ -89,35 +94,32 @@ public Signature boundSignature() {\n \n     @Override\n     public Symbol normalizeSymbol(Function function, TransactionContext txnCtx) {\n-        List<Symbol> arguments = function.arguments();\n-        final int size = arguments.size();\n+        List<Symbol> args = function.arguments();\n+        final int size = args.size();\n         assert size == 3 || size == 4 : \"function's number of arguments must be 3 or 4\";\n-\n-        if (anyNonLiterals(arguments)) {\n+        if (anyNonLiterals(args)) {\n             return function;\n         }\n-\n-        final Input input = (Input) arguments.get(0);\n-        final Input pattern = (Input) arguments.get(1);\n-        final Input replacement = (Input) arguments.get(2);\n-        final String inputValue = (String) input.value();\n-        final String patternValue = (String) pattern.value();\n-        final String replacementValue = (String) replacement.value();\n-        if (inputValue == null || patternValue == null || replacementValue == null) {\n+        final String value = ((Input<String>) args.get(0)).value();\n+        final String pattern = ((Input<String>) args.get(1)).value();\n+        final String replacement = ((Input<String>) args.get(2)).value();", "originalCommit": "06af923fd9bedbea8473e02499b70ca337bfef5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1256fb015e12ee9c1d36990b558450bfd04ee723", "url": "https://github.com/crate/crate/commit/1256fb015e12ee9c1d36990b558450bfd04ee723", "message": "Make pattern final as requested by Ruslan", "committedDate": "2020-07-27T13:59:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkzNDgyMA==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460934820", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In this example the ``pattern``does not match anything in the ``source`` and the result\n          \n          \n            \n            In this example the ``pattern`` does not match anything in the ``source`` and the result", "author": "kovrus", "createdAt": "2020-07-27T14:32:39Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -198,6 +198,149 @@ arrays within the same level.\n     +---+\n     SELECT 2 rows in set (... sec)\n \n+.. _table-functions-regexp-matches:\n+\n+``regexp_matches(source, pattern [, flags])``\n+=============================================\n+\n+Uses the regular expression ``pattern`` to match against the ``source`` string.\n+\n+The result rows have one column:\n+\n+.. list-table::\n+    :header-rows: 1\n+\n+    * - Column name\n+      - Description\n+    * - groups\n+      - ``array(text)``\n+\n+If ``pattern`` matches ``source``, an array of the matched regular expression\n+groups is returned.\n+\n+If no regular expression group was used, the whole pattern is used as a group.\n+\n+A regular expression group is formed by a subexpression that is surrounded by\n+parentheses. The position of a group is determined by the position of its\n+opening parenthesis.\n+\n+For example when matching the pattern ``\\b([A-Z])`` a match for the\n+subexpression ``([A-Z])`` would create group No. 1. If you want to group items\n+with parentheses, but without grouping, use ``(?...)``.\n+\n+For example matching the regular expression ``([Aa](.+)z)`` against\n+``alcatraz``, results in these groups:\n+\n+ * group 1: ``alcatraz`` (from first to last parenthesis or whole pattern)\n+ * group 2: ``lcatra`` (beginning at second parenthesis)\n+\n+The ``regexp_matches`` function will return all groups as a ``text`` array::\n+\n+    cr> select regexp_matches('alcatraz', '(a(.+)z)') as matched;\n+    +------------------------+\n+    | matched                |\n+    +------------------------+\n+    | [\"alcatraz\", \"lcatra\"] |\n+    +------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+::\n+\n+    cr> select regexp_matches('alcatraz', 'traz') as matched;\n+    +----------+\n+    | matched  |\n+    +----------+\n+    | [\"traz\"] |\n+    +----------+\n+    SELECT 1 row in set (... sec)\n+\n+Through array element access functionality, a group can be selected directly.\n+See :ref:`sql_dql_object_arrays_select` for details.\n+\n+::\n+\n+    cr> select regexp_matches('alcatraz', '(a(.+)z)')[2] as second_group;\n+    +--------------+\n+    | second_group |\n+    +--------------+\n+    | lcatra       |\n+    +--------------+\n+    SELECT 1 row in set (... sec)\n+\n+.. _table-functions-regexp-matches-flags:\n+\n+Flags\n+.....\n+\n+This function takes a number of flags as optional third parameter. These flags\n+are given as a string containing any of the characters listed below. Order does\n+not matter.\n+\n++-------+---------------------------------------------------------------------+\n+| Flag  | Description                                                         |\n++=======+=====================================================================+\n+| ``i`` | enable case insensitive matching                                    |\n++-------+---------------------------------------------------------------------+\n+| ``u`` | enable unicode case folding when used together with ``i``           |\n++-------+---------------------------------------------------------------------+\n+| ``U`` | enable unicode support for character classes like ``\\W``            |\n++-------+---------------------------------------------------------------------+\n+| ``s`` | make ``.`` match line terminators, too                              |\n++-------+---------------------------------------------------------------------+\n+| ``m`` | make ``^`` and ``$`` match on the beginning or end of a line        |\n+|       | too.                                                                |\n++-------+---------------------------------------------------------------------+\n+| ``x`` | permit whitespace and line comments starting with ``#``             |\n++-------+---------------------------------------------------------------------+\n+| ``d`` | only ``\\n`` is considered a line-terminator when using ``^``, ``$`` |\n+|       | and ``.``                                                           |\n++-------+---------------------------------------------------------------------+\n+| ``g`` | keep matching until the end of ``source``, instead of stopping at   |\n+|       | the first match.                                                    |\n++-------+---------------------------------------------------------------------+\n+\n+\n+Examples\n+........\n+\n+In this example the ``pattern``does not match anything in the ``source`` and the result", "originalCommit": "1256fb015e12ee9c1d36990b558450bfd04ee723", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkzNTYyNw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460935627", "bodyText": "isn't this example about using the flags or their combination?", "author": "kovrus", "createdAt": "2020-07-27T14:33:44Z", "path": "docs/general/builtins/table-functions.rst", "diffHunk": "@@ -198,6 +198,149 @@ arrays within the same level.\n     +---+\n     SELECT 2 rows in set (... sec)\n \n+.. _table-functions-regexp-matches:\n+\n+``regexp_matches(source, pattern [, flags])``\n+=============================================\n+\n+Uses the regular expression ``pattern`` to match against the ``source`` string.\n+\n+The result rows have one column:\n+\n+.. list-table::\n+    :header-rows: 1\n+\n+    * - Column name\n+      - Description\n+    * - groups\n+      - ``array(text)``\n+\n+If ``pattern`` matches ``source``, an array of the matched regular expression\n+groups is returned.\n+\n+If no regular expression group was used, the whole pattern is used as a group.\n+\n+A regular expression group is formed by a subexpression that is surrounded by\n+parentheses. The position of a group is determined by the position of its\n+opening parenthesis.\n+\n+For example when matching the pattern ``\\b([A-Z])`` a match for the\n+subexpression ``([A-Z])`` would create group No. 1. If you want to group items\n+with parentheses, but without grouping, use ``(?...)``.\n+\n+For example matching the regular expression ``([Aa](.+)z)`` against\n+``alcatraz``, results in these groups:\n+\n+ * group 1: ``alcatraz`` (from first to last parenthesis or whole pattern)\n+ * group 2: ``lcatra`` (beginning at second parenthesis)\n+\n+The ``regexp_matches`` function will return all groups as a ``text`` array::\n+\n+    cr> select regexp_matches('alcatraz', '(a(.+)z)') as matched;\n+    +------------------------+\n+    | matched                |\n+    +------------------------+\n+    | [\"alcatraz\", \"lcatra\"] |\n+    +------------------------+\n+    SELECT 1 row in set (... sec)\n+\n+::\n+\n+    cr> select regexp_matches('alcatraz', 'traz') as matched;\n+    +----------+\n+    | matched  |\n+    +----------+\n+    | [\"traz\"] |\n+    +----------+\n+    SELECT 1 row in set (... sec)\n+\n+Through array element access functionality, a group can be selected directly.\n+See :ref:`sql_dql_object_arrays_select` for details.\n+\n+::\n+\n+    cr> select regexp_matches('alcatraz', '(a(.+)z)')[2] as second_group;\n+    +--------------+\n+    | second_group |\n+    +--------------+\n+    | lcatra       |\n+    +--------------+\n+    SELECT 1 row in set (... sec)\n+\n+.. _table-functions-regexp-matches-flags:\n+\n+Flags\n+.....\n+\n+This function takes a number of flags as optional third parameter. These flags\n+are given as a string containing any of the characters listed below. Order does\n+not matter.\n+\n++-------+---------------------------------------------------------------------+\n+| Flag  | Description                                                         |\n++=======+=====================================================================+\n+| ``i`` | enable case insensitive matching                                    |\n++-------+---------------------------------------------------------------------+\n+| ``u`` | enable unicode case folding when used together with ``i``           |\n++-------+---------------------------------------------------------------------+\n+| ``U`` | enable unicode support for character classes like ``\\W``            |\n++-------+---------------------------------------------------------------------+\n+| ``s`` | make ``.`` match line terminators, too                              |\n++-------+---------------------------------------------------------------------+\n+| ``m`` | make ``^`` and ``$`` match on the beginning or end of a line        |\n+|       | too.                                                                |\n++-------+---------------------------------------------------------------------+\n+| ``x`` | permit whitespace and line comments starting with ``#``             |\n++-------+---------------------------------------------------------------------+\n+| ``d`` | only ``\\n`` is considered a line-terminator when using ``^``, ``$`` |\n+|       | and ``.``                                                           |\n++-------+---------------------------------------------------------------------+\n+| ``g`` | keep matching until the end of ``source``, instead of stopping at   |\n+|       | the first match.                                                    |\n++-------+---------------------------------------------------------------------+\n+\n+\n+Examples\n+........\n+\n+In this example the ``pattern``does not match anything in the ``source`` and the result\n+is an empty table:\n+\n+::\n+\n+    cr> select regexp_matches('foobar', '^(a(.+)z)$') as matched;\n+    +---------+\n+    | matched |\n+    +---------+\n+    +---------+\n+    SELECT 0 rows in set (... sec)\n+\n+In this example we find the term that follows two digits:", "originalCommit": "1256fb015e12ee9c1d36990b558450bfd04ee723", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk0MjUyMw==", "url": "https://github.com/crate/crate/pull/10104#discussion_r460942523", "bodyText": "a few examples to show users valid uses of the function. It happens to follow the flags section, but it is not part of the flags section", "author": "marregui", "createdAt": "2020-07-27T14:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDkzNTYyNw=="}], "type": "inlineReview"}, {"oid": "c25c7441730c9b85f221644f487189ef303106cd", "url": "https://github.com/crate/crate/commit/c25c7441730c9b85f221644f487189ef303106cd", "message": "Add support for global flag 'g' to now tabular function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match. The postgres specification defines this\nfunction as a table function.", "committedDate": "2020-07-27T14:44:40Z", "type": "commit"}, {"oid": "c25c7441730c9b85f221644f487189ef303106cd", "url": "https://github.com/crate/crate/commit/c25c7441730c9b85f221644f487189ef303106cd", "message": "Add support for global flag 'g' to now tabular function regexp_matches\n\nTo find all matches in a source of the given pattern instead of\nstopping at the first match. The postgres specification defines this\nfunction as a table function.", "committedDate": "2020-07-27T14:44:40Z", "type": "forcePushed"}]}