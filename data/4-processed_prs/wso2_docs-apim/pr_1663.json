{"pr_number": 1663, "pr_title": "Updated access-control doc.", "pr_createdAt": "2020-08-11T08:55:08Z", "pr_url": "https://github.com/wso2/docs-apim/pull/1663", "timeline": [{"oid": "0cae403822bc25f33347251e0bb546a3868b8bc9", "url": "https://github.com/wso2/docs-apim/commit/0cae403822bc25f33347251e0bb546a3868b8bc9", "message": "Updated access-control doc.", "committedDate": "2020-08-11T08:53:16Z", "type": "commit"}, {"oid": "5b96a57be68cb6498fbbabf3ac016e291980d0b7", "url": "https://github.com/wso2/docs-apim/commit/5b96a57be68cb6498fbbabf3ac016e291980d0b7", "message": "Updated throttling use cases doc.", "committedDate": "2020-08-12T07:07:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg3MzQ2Ng==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469873466", "bodyText": "Please change description to something similar to -\nIf the 'Invert Condition' is checked, then the condition applies only to the IPs not mentioned in the 'IP Address'.", "author": "ruthryi", "createdAt": "2020-08-13T11:07:17Z", "path": "en/docs/learn/rate-limiting/access-control.md", "diffHunk": "@@ -18,35 +18,36 @@ When requests to an API are to be permitted from a set of known/trusted IPs only\n 2.  Under the **Rate Limiting Policies** tab and navigate to **Advanced Policies.**\n 3.  Click Add New Policy to add a new Rate Limit tier.\n \n-    ![](../../assets/img/learn/allowed-ip-add-policy.png)\n+    ![Advanced Rate Limit policy]({{base_path}}/assets/img/learn/allowed-ip-add-policy.png)\n \n-4.  Fill the details as below and click **Add Conditional Group** .\n+4.  Fill the details as below and click **Add Conditional Group**.\n \n-    ![](../../assets/img/learn/allowed-ip-add-conditional-group.png)\n+    ![Advanced Rate Limit policy]({{base_path}}/assets/img/learn/allowed-ip-add-conditional-group.png)\n \n 5.  Open the Conditional Group added and fill the details.\n \n     | Property            | Value                                                                                                          |\n     |---------------------|----------------------------------------------------------------------------------------------------------------|\n-    | IP Condition Policy | Checked                                                                                                        |\n     | IP Condition Type   | Specific IP                                                                                                    |\n     | IP Address          | <IP_Address_to_be_allowed> E.g. 193.100.3.106                                                              |\n     | Invert Condition    | Checked (If Invert Condition check then condition only apply to the IPs which not mention in IP Address above) |", "originalCommit": "5b96a57be68cb6498fbbabf3ac016e291980d0b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1NjQ5Mw==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469956493", "bodyText": "Fixed with 8ac6250", "author": "Meruja", "createdAt": "2020-08-13T13:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg3MzQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4MjAxOA==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469882018", "bodyText": "Break this into 2 paragraphs with \"To prevent your backend system from getting overloaded\"", "author": "ruthryi", "createdAt": "2020-08-13T11:25:43Z", "path": "en/docs/learn/rate-limiting/introducing-throttling-use-cases.md", "diffHunk": "@@ -27,19 +27,19 @@ The following sections describe the type of throttling policy applicable to each\n \n #### Maximum backend throughput ( **Applies per API** ): API Publisher\n \n-According to the API Gateway architecture, an API in the Gateway is actually a proxy to an actual service hosted within your organization, cloud, etc. This usually means that there is a physical capacity that your backend services can handle. Although you expose your API on defined limits (subscription tiers), as the number of applications that consume your API grows, the number of requests being served by your API rise, which in turn means that the number of requests served by your backend system rise as well. Therefore, although none of the applications may exceed their own allocated quotas, their combined load might hit the maximum capacity that can be handled by your backend system. To prevent your backend system from getting overloaded, the limits enforced by the **Maximum Backend Throughput** in the API act as a hard stop on the number of requests that your backend system can serve within a given time period. The counters maintained when evaluating the maximum backend throughput are shared across all nodes of the Gateway cluster and apply across all users using any application that accesses that particular API. For information on how to specify maximum backend throughput limits, see [Setting Maximum Backend Throughput Limits](../setting-maximum-backend-throughput-limits) .\n+According to the API Gateway architecture, an API in the Gateway is actually a proxy to an actual service hosted within your organization, cloud, etc. This usually means that there is a physical capacity that your backend services can handle. Although you expose your API on defined limits (subscription tiers), as the number of applications that consume your API grows, the number of requests being served by your API rise, which in turn means that the number of requests served by your backend system rise as well. Therefore, although none of the applications may exceed their own allocated quotas, their combined load might hit the maximum capacity that can be handled by your backend system. To prevent your backend system from getting overloaded, the limits enforced by the **Maximum Backend Throughput** in the API act as a hard stop on the number of requests that your backend system can serve within a given time period. The counters maintained when evaluating the maximum backend throughput are shared across all nodes of the Gateway cluster and apply across all users using any application that accesses that particular API. For information on how to specify maximum backend throughput limits, see [Setting Maximum Backend Throughput Limits]({{base_path}}/learn/rate-limiting/setting-maximum-backend-throughput-limits).", "originalCommit": "5b96a57be68cb6498fbbabf3ac016e291980d0b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1NjU0OQ==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469956549", "bodyText": "Fixed with 8ac6250", "author": "Meruja", "createdAt": "2020-08-13T13:36:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4MjAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4MjY2Ng==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469882666", "bodyText": "Instead of s/he, please use 'they'.", "author": "ruthryi", "createdAt": "2020-08-13T11:27:03Z", "path": "en/docs/learn/rate-limiting/introducing-throttling-use-cases.md", "diffHunk": "@@ -27,19 +27,19 @@ The following sections describe the type of throttling policy applicable to each\n \n #### Maximum backend throughput ( **Applies per API** ): API Publisher\n \n-According to the API Gateway architecture, an API in the Gateway is actually a proxy to an actual service hosted within your organization, cloud, etc. This usually means that there is a physical capacity that your backend services can handle. Although you expose your API on defined limits (subscription tiers), as the number of applications that consume your API grows, the number of requests being served by your API rise, which in turn means that the number of requests served by your backend system rise as well. Therefore, although none of the applications may exceed their own allocated quotas, their combined load might hit the maximum capacity that can be handled by your backend system. To prevent your backend system from getting overloaded, the limits enforced by the **Maximum Backend Throughput** in the API act as a hard stop on the number of requests that your backend system can serve within a given time period. The counters maintained when evaluating the maximum backend throughput are shared across all nodes of the Gateway cluster and apply across all users using any application that accesses that particular API. For information on how to specify maximum backend throughput limits, see [Setting Maximum Backend Throughput Limits](../setting-maximum-backend-throughput-limits) .\n+According to the API Gateway architecture, an API in the Gateway is actually a proxy to an actual service hosted within your organization, cloud, etc. This usually means that there is a physical capacity that your backend services can handle. Although you expose your API on defined limits (subscription tiers), as the number of applications that consume your API grows, the number of requests being served by your API rise, which in turn means that the number of requests served by your backend system rise as well. Therefore, although none of the applications may exceed their own allocated quotas, their combined load might hit the maximum capacity that can be handled by your backend system. To prevent your backend system from getting overloaded, the limits enforced by the **Maximum Backend Throughput** in the API act as a hard stop on the number of requests that your backend system can serve within a given time period. The counters maintained when evaluating the maximum backend throughput are shared across all nodes of the Gateway cluster and apply across all users using any application that accesses that particular API. For information on how to specify maximum backend throughput limits, see [Setting Maximum Backend Throughput Limits]({{base_path}}/learn/rate-limiting/setting-maximum-backend-throughput-limits).\n \n ### Implications on the APIs in the Gateway\n \n #### Subscription tiers: API Publisher\n \n-When an API Publisher publishes an API to be consumed by applications, s/he\u00a0can choose to make the API available over different limits. For example, the **Gold** tier allows an application to access the API at 5000 requests per minute while a **Silver** tier allows an application to access the API at 2000 requests per minute. For information on how to define a throttling tier to an API, see [API-level throttling (API publisher)](../setting-throttling-limits/#subscription-level-throttling-api-publisher) .\n+When an API Publisher publishes an API to be consumed by applications, s/he\u00a0can choose to make the API available over different limits. For example, the **Gold** tier allows an application to access the API at 5000 requests per minute while a **Silver** tier allows an application to access the API at 2000 requests per minute. For information on how to define a throttling tier to an API, see [API-level throttling (API publisher)]({{base_path}}/learn/rate-limiting/setting-throttling-limits/#subscription-level-throttling-api-publisher).", "originalCommit": "5b96a57be68cb6498fbbabf3ac016e291980d0b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1NjYzMQ==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469956631", "bodyText": "Fixed with 8ac6250", "author": "Meruja", "createdAt": "2020-08-13T13:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4MjY2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4NDg0MA==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469884840", "bodyText": "Does this look better;\n\nThe following image shows an example for configuring.....\n\nWDYT?", "author": "ruthryi", "createdAt": "2020-08-13T11:31:43Z", "path": "en/docs/learn/rate-limiting/introducing-throttling-use-cases.md", "diffHunk": "@@ -56,42 +56,42 @@ Let\u2019s look at how each of these can be important for serving requests through\n \n You can control/restrict access to your API or its selected resources for a given IP address or address range. For example, if you need to grant permission for internal applications to consume a larger quota of your API resource than your external consumers, you can define an advanced policy with higher limits for your internal IP address range and lower limits for the rest. \n \n-Here is a sample for configuring an IP condition by limitting the number of requests for a specific IP address.\n+Here is a sample for configuring an IP condition by limiting the number of requests for a specific IP address.\n \n-![](../../assets/img/learn/advanced-throttling-ip-condition.png)\n+![Advanced Rate Limit policy]({{base_path}}/assets/img/learn/new-allow-specific-ip.png)\n \n ##### HTTP request headers\n \n Advanced policies allow you to apply limits to APIs by filtering requests based on HTTP headers. For example, assume you need to apply a special limit for JSON requests. To do that, you can filter JSON messages by using a policy that inspects the HTTP request headers and checks if the `Content-Type` header is `application/json` and apply a special limit for those requests while allowing a default value for the rest.\n \n Here is a sample for configuring a header condition by considering the \"Content-Type\" header.\n \n-![](../../assets/img/learn/advanced-throttling-header-condition.png)\n+![]({{base_path}}/assets/img/learn/new-header-condition-regex.png)\n ##### JWT claims\n \n A JWT claim contains meta information of an API request. It can include application details, API details, user claims, etc. Advanced throttling policies based on JWT claims allow you to filter requests by JWT claim values and apply limits for requests. For example, if you need to allow special limits for users in a specific user role, you can create an advanced policy that checks for a particular regular expression on the role claim of the user and apply special limits for the ones that match.\n \n-Here is a sample for configuring JWT claim condition by considering the version of the API (http://wso2.org/claims/version).\n+Here is a sample for configuring JWT claim condition by considering the version of the API (http://wso2.org/claims/subscribe).", "originalCommit": "5b96a57be68cb6498fbbabf3ac016e291980d0b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1NjY4Mw==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469956683", "bodyText": "Fixed with 8ac6250", "author": "Meruja", "createdAt": "2020-08-13T13:37:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4NDg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4NTEwMQ==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469885101", "bodyText": "Should be i.e.", "author": "ruthryi", "createdAt": "2020-08-13T11:32:12Z", "path": "en/docs/learn/rate-limiting/introducing-throttling-use-cases.md", "diffHunk": "@@ -56,42 +56,42 @@ Let\u2019s look at how each of these can be important for serving requests through\n \n You can control/restrict access to your API or its selected resources for a given IP address or address range. For example, if you need to grant permission for internal applications to consume a larger quota of your API resource than your external consumers, you can define an advanced policy with higher limits for your internal IP address range and lower limits for the rest. \n \n-Here is a sample for configuring an IP condition by limitting the number of requests for a specific IP address.\n+Here is a sample for configuring an IP condition by limiting the number of requests for a specific IP address.\n \n-![](../../assets/img/learn/advanced-throttling-ip-condition.png)\n+![Advanced Rate Limit policy]({{base_path}}/assets/img/learn/new-allow-specific-ip.png)\n \n ##### HTTP request headers\n \n Advanced policies allow you to apply limits to APIs by filtering requests based on HTTP headers. For example, assume you need to apply a special limit for JSON requests. To do that, you can filter JSON messages by using a policy that inspects the HTTP request headers and checks if the `Content-Type` header is `application/json` and apply a special limit for those requests while allowing a default value for the rest.\n \n Here is a sample for configuring a header condition by considering the \"Content-Type\" header.\n \n-![](../../assets/img/learn/advanced-throttling-header-condition.png)\n+![]({{base_path}}/assets/img/learn/new-header-condition-regex.png)\n ##### JWT claims\n \n A JWT claim contains meta information of an API request. It can include application details, API details, user claims, etc. Advanced throttling policies based on JWT claims allow you to filter requests by JWT claim values and apply limits for requests. For example, if you need to allow special limits for users in a specific user role, you can create an advanced policy that checks for a particular regular expression on the role claim of the user and apply special limits for the ones that match.\n \n-Here is a sample for configuring JWT claim condition by considering the version of the API (http://wso2.org/claims/version).\n+Here is a sample for configuring JWT claim condition by considering the version of the API (http://wso2.org/claims/subscribe).\n \n-![](../../assets/img/learn/advanced-throttling-jwt-condition.png)\n+![]({{base_path}}/assets/img/learn/new-jwt-condition-regex.png)\n ##### Query parameters\n \n Filtering based on query parameters almost always apply to HTTP GET requests when doing search type of operations. For example, if you have a search API with `category` as a query parameter, you can have different limits for searching different categories.\n \n-![](../../assets/img/learn/advanced-throttling-query-conidtion.png)\n+![]({{base_path}}/assets/img/learn/new-advanced-throttling-query-conidtion.png)\n Eg : 'sales' category can be allocated with more requests than 'hr' category\n \n ### Implications on applications that consume APIs\n \n #### Per token quota: Application Developer\n \n-When an application developer subscribes their application to an API, they select a tier (limit) for their application to invoke the API. This limit applies across all users of the application when accessing the particular API. To ensure that a fair distribution of the quota is available among all the users, it is important to consider setting a per user quota for the application, since a user is identified by a token (in OAuth2.0, this limit is known as the per token quota). It is important to note that the limit enforced by this setting applies to a single user (token) accessing all APIs of the application. The counters maintained when evaluating a per token quota are shared across all nodes in the Gateway cluster. For information on how to define a throttling tier to an application, see [Application-level throttling (application developer)](../setting-throttling-limits/#application-level-throttling-application-developer)) .\n+When an application developer subscribes their application to an API, they select a tier (limit) for their application to invoke the API. This limit applies across all users of the application when accessing the particular API. To ensure that a fair distribution of the quota is available among all the users, it is important to consider setting a per user quota for the application, since a user is identified by a token (in OAuth2.0, this limit is known as the per token quota). It is important to note that the limit enforced by this setting applies to a single user (token) accessing all APIs of the application. The counters maintained when evaluating a per token quota are shared across all nodes in the Gateway cluster. For information on how to define a throttling tier to an application, see [Application-level throttling (application developer)]({{base_path}}/learn/rate-limiting/setting-throttling-limits/#application-level-throttling-application-developer)).\n \n \n The below diagram shows how throttle policies are applied at different levels.\n \n \n-![](../../assets/img/learn/throttling-levels.png)\n+![]({{base_path}}/assets/img/learn/throttling-levels.png)\n \n If [advanced throttling](#advanced-throttling-policies-api-publisher) policies are added and engaged to a specific API or API resource, it will also be applied here. i.e Requests will be allowed/rejected based on the conditions specified in advanced throttling policies as well.", "originalCommit": "5b96a57be68cb6498fbbabf3ac016e291980d0b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1NjczMg==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469956732", "bodyText": "Fixed with 8ac6250", "author": "Meruja", "createdAt": "2020-08-13T13:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4NTEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4NTQ1NA==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469885454", "bodyText": "Can we change this to \"The following diagram\" please", "author": "ruthryi", "createdAt": "2020-08-13T11:32:55Z", "path": "en/docs/learn/rate-limiting/introducing-throttling-use-cases.md", "diffHunk": "@@ -56,42 +56,42 @@ Let\u2019s look at how each of these can be important for serving requests through\n \n You can control/restrict access to your API or its selected resources for a given IP address or address range. For example, if you need to grant permission for internal applications to consume a larger quota of your API resource than your external consumers, you can define an advanced policy with higher limits for your internal IP address range and lower limits for the rest. \n \n-Here is a sample for configuring an IP condition by limitting the number of requests for a specific IP address.\n+Here is a sample for configuring an IP condition by limiting the number of requests for a specific IP address.\n \n-![](../../assets/img/learn/advanced-throttling-ip-condition.png)\n+![Advanced Rate Limit policy]({{base_path}}/assets/img/learn/new-allow-specific-ip.png)\n \n ##### HTTP request headers\n \n Advanced policies allow you to apply limits to APIs by filtering requests based on HTTP headers. For example, assume you need to apply a special limit for JSON requests. To do that, you can filter JSON messages by using a policy that inspects the HTTP request headers and checks if the `Content-Type` header is `application/json` and apply a special limit for those requests while allowing a default value for the rest.\n \n Here is a sample for configuring a header condition by considering the \"Content-Type\" header.\n \n-![](../../assets/img/learn/advanced-throttling-header-condition.png)\n+![]({{base_path}}/assets/img/learn/new-header-condition-regex.png)\n ##### JWT claims\n \n A JWT claim contains meta information of an API request. It can include application details, API details, user claims, etc. Advanced throttling policies based on JWT claims allow you to filter requests by JWT claim values and apply limits for requests. For example, if you need to allow special limits for users in a specific user role, you can create an advanced policy that checks for a particular regular expression on the role claim of the user and apply special limits for the ones that match.\n \n-Here is a sample for configuring JWT claim condition by considering the version of the API (http://wso2.org/claims/version).\n+Here is a sample for configuring JWT claim condition by considering the version of the API (http://wso2.org/claims/subscribe).\n \n-![](../../assets/img/learn/advanced-throttling-jwt-condition.png)\n+![]({{base_path}}/assets/img/learn/new-jwt-condition-regex.png)\n ##### Query parameters\n \n Filtering based on query parameters almost always apply to HTTP GET requests when doing search type of operations. For example, if you have a search API with `category` as a query parameter, you can have different limits for searching different categories.\n \n-![](../../assets/img/learn/advanced-throttling-query-conidtion.png)\n+![]({{base_path}}/assets/img/learn/new-advanced-throttling-query-conidtion.png)\n Eg : 'sales' category can be allocated with more requests than 'hr' category\n \n ### Implications on applications that consume APIs\n \n #### Per token quota: Application Developer\n \n-When an application developer subscribes their application to an API, they select a tier (limit) for their application to invoke the API. This limit applies across all users of the application when accessing the particular API. To ensure that a fair distribution of the quota is available among all the users, it is important to consider setting a per user quota for the application, since a user is identified by a token (in OAuth2.0, this limit is known as the per token quota). It is important to note that the limit enforced by this setting applies to a single user (token) accessing all APIs of the application. The counters maintained when evaluating a per token quota are shared across all nodes in the Gateway cluster. For information on how to define a throttling tier to an application, see [Application-level throttling (application developer)](../setting-throttling-limits/#application-level-throttling-application-developer)) .\n+When an application developer subscribes their application to an API, they select a tier (limit) for their application to invoke the API. This limit applies across all users of the application when accessing the particular API. To ensure that a fair distribution of the quota is available among all the users, it is important to consider setting a per user quota for the application, since a user is identified by a token (in OAuth2.0, this limit is known as the per token quota). It is important to note that the limit enforced by this setting applies to a single user (token) accessing all APIs of the application. The counters maintained when evaluating a per token quota are shared across all nodes in the Gateway cluster. For information on how to define a throttling tier to an application, see [Application-level throttling (application developer)]({{base_path}}/learn/rate-limiting/setting-throttling-limits/#application-level-throttling-application-developer)).\n \n \n The below diagram shows how throttle policies are applied at different levels.", "originalCommit": "5b96a57be68cb6498fbbabf3ac016e291980d0b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTk1Njc4NA==", "url": "https://github.com/wso2/docs-apim/pull/1663#discussion_r469956784", "bodyText": "Fixed with 8ac6250", "author": "Meruja", "createdAt": "2020-08-13T13:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg4NTQ1NA=="}], "type": "inlineReview"}, {"oid": "8ac6250ac777743b79f3357d1907debffb99bc0c", "url": "https://github.com/wso2/docs-apim/commit/8ac6250ac777743b79f3357d1907debffb99bc0c", "message": "Fixed review comments.", "committedDate": "2020-08-13T13:35:41Z", "type": "commit"}]}