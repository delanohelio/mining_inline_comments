{"pr_number": 1581, "pr_title": "Easy MLT binary format writer perf fixes", "pr_createdAt": "2020-06-12T14:57:39Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1581", "timeline": [{"oid": "3f962385a58bac16b0f60425729abf4b19f1a091", "url": "https://github.com/DataDog/dd-trace-java/commit/3f962385a58bac16b0f60425729abf4b19f1a091", "message": "Do not recompute FrameSequence.length recursively", "committedDate": "2020-06-12T14:52:25Z", "type": "commit"}, {"oid": "8ad8e34e5575184cf49b84bed02d109329320ebc", "url": "https://github.com/DataDog/dd-trace-java/commit/8ad8e34e5575184cf49b84bed02d109329320ebc", "message": "Provide a ByteBuffer backed implementation of LEB128Writer", "committedDate": "2020-06-12T14:52:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NDI5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439474294", "bodyText": "I can't really figure out how length can become -1", "author": "bantonsson", "createdAt": "2020-06-12T15:02:59Z", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/FrameSequence.java", "diffHunk": "@@ -58,14 +61,16 @@ public FrameSequence(\n   }\n \n   public int length() {\n-    if (isEmpty()) {\n-      return 0;\n-    }\n-    if (isLeaf()) {\n-      return frameCpIndexes.length;\n+    if (length == -1) {", "originalCommit": "8ad8e34e5575184cf49b84bed02d109329320ebc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NTE0MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439475141", "bodyText": "Right. Messed up rebase ...\nlength is supposed to be initialized to -1", "author": "jbachorik", "createdAt": "2020-06-12T15:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3NDI5NA=="}], "type": "inlineReview"}, {"oid": "1f30019655279f3c5e37498ede5d7a68fa7be6c0", "url": "https://github.com/DataDog/dd-trace-java/commit/1f30019655279f3c5e37498ede5d7a68fa7be6c0", "message": "Initialize FrameSequence.length to -1", "committedDate": "2020-06-12T15:04:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMTM1NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439501355", "bodyText": "We've been caching these in various ways (constants in a poor man's constant pool, variables in an LRU cache) could you take something like a Function<String, byte[]> which intercepts this?\nI was a bit surprised that C2 isn't smart enough to eliminate these, even with compact strings.", "author": "richardstartin", "createdAt": "2020-06-12T15:51:59Z", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/AbstractLEB128Writer.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+abstract class AbstractLEB128Writer implements LEB128Writer {\n+  @Override\n+  public final LEB128Writer writeChar(char data) {\n+    writeChar(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeChar(long offset, char data) {\n+    return writeLong(offset, data & 0x000000000000ffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeShort(short data) {\n+    writeShort(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeShort(long offset, short data) {\n+    return writeLong(offset, data & 0x000000000000ffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeInt(int data) {\n+    writeInt(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeInt(long offset, int data) {\n+    return writeLong(offset, data & 0x00000000ffffffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeLong(long data) {\n+    writeLong(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeLong(long offset, long data) {\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) (data & 0xff));\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    return writeByte(offset, (byte) (data >> 7));\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeFloat(float data) {\n+    writeFloat(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeDouble(double data) {\n+    writeDouble(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeBoolean(boolean data) {\n+    writeBoolean(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeBoolean(long offset, boolean data) {\n+    return writeByte(offset, data ? (byte) 1 : (byte) 0);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeByte(byte data) {\n+    writeByte(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeBytes(byte... data) {\n+    writeBytes(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeUTF(String data) {\n+    writeUTF(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeUTF(long offset, String data) {", "originalCommit": "1f30019655279f3c5e37498ede5d7a68fa7be6c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0MjE1OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440042159", "bodyText": "You mean we are having LRU cache of UTF8 byte array representation of string instances?\nIs it a global cache? Would it be able to handle the extra amount of strings coming from sampled stack traces?\nMaybe having an overloaded writeUTF(long offset, byte[] stringData) could work? And if the caller can get the byte array eg. from the cache it would call this method instead?", "author": "jbachorik", "createdAt": "2020-06-15T09:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMTM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA1NTcxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440055712", "bodyText": "So the cache instance is local to the MsgpackFormatWriter since it's mostly for short tags, and I'm not sure of the overlap with what you are writing, but the class is here datadog.trace.core.util.LRUCache.", "author": "bantonsson", "createdAt": "2020-06-15T09:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMTM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIyNTEzNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440225134", "bodyText": "Well, I have added support for accepting a byte array of an UTF8 encoded string. It will be up to the user to decide when it is appropriate to get the data from the LRU cache.", "author": "jbachorik", "createdAt": "2020-06-15T14:40:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMTM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMTUwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439501508", "bodyText": "ditto", "author": "richardstartin", "createdAt": "2020-06-12T15:52:17Z", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/AbstractLEB128Writer.java", "diffHunk": "@@ -0,0 +1,223 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+abstract class AbstractLEB128Writer implements LEB128Writer {\n+  @Override\n+  public final LEB128Writer writeChar(char data) {\n+    writeChar(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeChar(long offset, char data) {\n+    return writeLong(offset, data & 0x000000000000ffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeShort(short data) {\n+    writeShort(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeShort(long offset, short data) {\n+    return writeLong(offset, data & 0x000000000000ffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeInt(int data) {\n+    writeInt(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeInt(long offset, int data) {\n+    return writeLong(offset, data & 0x00000000ffffffffL);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeLong(long data) {\n+    writeLong(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeLong(long offset, long data) {\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) (data & 0xff));\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    data >>= 7;\n+    if ((data & LEB128Writer.COMPRESSED_INT_MASK) == 0) {\n+      return writeByte(offset, (byte) data);\n+    }\n+    offset = writeByte(offset, (byte) (data | LEB128Writer.EXT_BIT));\n+    return writeByte(offset, (byte) (data >> 7));\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeFloat(float data) {\n+    writeFloat(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeDouble(double data) {\n+    writeDouble(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeBoolean(boolean data) {\n+    writeBoolean(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeBoolean(long offset, boolean data) {\n+    return writeByte(offset, data ? (byte) 1 : (byte) 0);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeByte(byte data) {\n+    writeByte(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeBytes(byte... data) {\n+    writeBytes(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeUTF(String data) {\n+    writeUTF(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeUTF(long offset, String data) {\n+    byte[] bytes = data.getBytes(StandardCharsets.UTF_8);\n+    long pos = writeInt(offset, bytes.length);\n+    return writeBytes(pos, bytes);\n+  }\n+\n+  @Override\n+  public final LEB128Writer writeCompactUTF(String data) {\n+    writeCompactUTF(position(), data);\n+    return this;\n+  }\n+\n+  @Override\n+  public final long writeCompactUTF(long offset, String data) {\n+    if (data == null) {\n+      return writeByte(offset, (byte) 0); // special NULL encoding\n+    }\n+    if (data.isEmpty()) {\n+      return writeByte(offset, (byte) 1); // special empty string encoding\n+    }\n+    long pos = writeByte(offset, (byte) 3); // UTF-8 string\n+    byte[] out = data.getBytes(StandardCharsets.UTF_8);", "originalCommit": "1f30019655279f3c5e37498ede5d7a68fa7be6c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMjM0MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439502341", "bodyText": "I really think that using a byte[] instead of a ByteBuffer on JDK11 will leave a lot on the table when writing wide integer types (there's no difference if you benchmark on JDK8).", "author": "richardstartin", "createdAt": "2020-06-12T15:53:51Z", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128ByteArrayWriter.java", "diffHunk": "@@ -1,167 +1,34 @@\n package com.datadog.mlt.io;\n \n-import java.nio.charset.StandardCharsets;\n import java.util.Arrays;\n \n /** Byte-array writer with default support for LEB128 encoded integer types */\n-final class LEB128ByteArrayWriter {\n-  private static final int EXT_BIT = 0x80;\n-  private static final long COMPRESSED_INT_MASK = -EXT_BIT;\n+final class LEB128ByteArrayWriter extends AbstractLEB128Writer {\n   private byte[] array;", "originalCommit": "1f30019655279f3c5e37498ede5d7a68fa7be6c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMjIxNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440022216", "bodyText": "This is just a fall-back implementation and I expect it to get removed once we are happy with the ByteBuffer based one.", "author": "jbachorik", "createdAt": "2020-06-15T08:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMjM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMzE1Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439503156", "bodyText": "\ud83d\udc4d", "author": "richardstartin", "createdAt": "2020-06-12T15:55:20Z", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128ByteBufferWriter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.ByteBuffer;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+final class LEB128ByteBufferWriter extends AbstractLEB128Writer {", "originalCommit": "1f30019655279f3c5e37498ede5d7a68fa7be6c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDA0MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439504040", "bodyText": "Have you tried using on heap buffers? This is slow, so should probably be pooled if you need direct memory, and makes the copy slower too.", "author": "richardstartin", "createdAt": "2020-06-12T15:56:53Z", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128ByteBufferWriter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.datadog.mlt.io;\n+\n+import java.nio.ByteBuffer;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+final class LEB128ByteBufferWriter extends AbstractLEB128Writer {\n+  private ByteBuffer buffer;\n+\n+  LEB128ByteBufferWriter(int initialCapacity) {\n+    this.buffer = ByteBuffer.allocateDirect(initialCapacity);\n+  }\n+\n+  @Override\n+  public void reset() {\n+    buffer.clear();\n+  }\n+\n+  @Override\n+  public long writeFloat(long offset, float data) {\n+    ensureCapacity((int) offset, 4);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.putFloat(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeDouble(long offset, double data) {\n+    ensureCapacity((int) offset, 8);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.putDouble(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeByte(long offset, byte data) {\n+    ensureCapacity((int) offset, 1);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.put(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeBytes(long offset, byte... data) {\n+    ensureCapacity((int) offset, data.length);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.put(data, 0, data.length);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeShortRaw(long offset, short data) {\n+    ensureCapacity((int) offset, 2);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.putShort(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeIntRaw(long offset, int data) {\n+    ensureCapacity((int) offset, 4);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.putInt(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public long writeLongRaw(long offset, long data) {\n+    ensureCapacity((int) offset, 8);\n+    int originalPosition = buffer.position();\n+    buffer.position((int) offset);\n+    buffer.putLong(data);\n+    if (originalPosition > buffer.position()) {\n+      buffer.position(originalPosition);\n+    }\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public byte[] toByteArray() {\n+    buffer.flip();\n+    byte[] data = new byte[buffer.remaining()];\n+    buffer.get(data, 0, data.length);\n+    return data;\n+  }\n+\n+  @Override\n+  public int position() {\n+    return buffer.position();\n+  }\n+\n+  @Override\n+  public int capacity() {\n+    return buffer.capacity();\n+  }\n+\n+  private void ensureCapacity(int offset, int dataLength) {\n+    if (offset + dataLength > buffer.capacity()) {\n+      int newCapacity = buffer.capacity() * 2;\n+      log.warn(\n+          \"{} capacity ({} bytes) exceeded. Reallocating internal buffer with new capacity {} bytes\",\n+          this.getClass().getName(),\n+          buffer.capacity(),\n+          newCapacity);\n+      ByteBuffer newBuffer = ByteBuffer.allocateDirect(newCapacity);", "originalCommit": "1f30019655279f3c5e37498ede5d7a68fa7be6c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzODQ4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440038485", "bodyText": "The ByteBuffer instance is cached at the writer instance level - eg. it can be reused many times.\nMaybe on-heap buffers would be good enough? Since the data is never shared with native code it should not make any difference (except of increasing the heap reqs)", "author": "jbachorik", "createdAt": "2020-06-15T09:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIxOTc1NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440219755", "bodyText": "I have factored out the code allocating the buffer so we can play with both modes.\nIn my naive local 'benchmarks' the only effect I can reliably see is more allocations happening for the on-heap buffers (of course). The allocations/deallocations are infrequent enough not to have any visible effect ...", "author": "jbachorik", "createdAt": "2020-06-15T14:32:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4MzM3Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440283373", "bodyText": "looks good", "author": "richardstartin", "createdAt": "2020-06-15T16:02:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDcwNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r439504706", "bodyText": "Have you considered not releasing a new byte[] and taking a Consumer<byte[] which must synchronously consume the data?", "author": "richardstartin", "createdAt": "2020-06-12T15:58:14Z", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/MLTWriter.java", "diffHunk": "@@ -4,38 +4,29 @@\n import it.unimi.dsi.fastutil.ints.IntSet;\n import java.nio.charset.StandardCharsets;\n import java.util.function.IntConsumer;\n-import java.util.stream.Stream;\n-import lombok.Generated;\n \n /** The MLT binary format writer */\n public final class MLTWriter {\n+  private static final int CHUNK_WRITER_CAPACITY = 512 * 1024; // initial 512kB for chunk writer\n+  private static final int FRAME_STACK_WRITER_CAPACITY =\n+      256 * 1024; // initial 256kB for frame stack writer\n+  private final LEB128Writer chunkWriter = LEB128Writer.getInstance(CHUNK_WRITER_CAPACITY);\n+  private final LEB128Writer frameStackDataWriter =\n+      LEB128Writer.getInstance(FRAME_STACK_WRITER_CAPACITY);\n   /**\n    * Write a single chunk to its binary format\n    *\n    * @param chunk the chunk\n    * @return chunk in its MLT binary format\n    */\n   public byte[] writeChunk(IMLTChunk chunk) {\n-    LEB128ByteArrayWriter writer =\n-        new LEB128ByteArrayWriter(16384); // conservatively pre-allocate 16k byte array\n-    writeChunk(chunk, writer);\n-    return writer.toByteArray();\n+    writeChunk(chunk, chunkWriter);", "originalCommit": "1f30019655279f3c5e37498ede5d7a68fa7be6c0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyNDEwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440024100", "bodyText": "Would this help? The byte[] instance would still be escaping the writeChunk(chunk) method, right?", "author": "jbachorik", "createdAt": "2020-06-15T08:50:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzNTE5NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440035194", "bodyText": "I think the idea was to change the signature to be public void writeChunk(IMLTChunk chunk, Consumer consumer) and just hand out the underlying byte[], and the length of the written bytes instead of a copy of the byte[].", "author": "bantonsson", "createdAt": "2020-06-15T09:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA0MzIxOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440043219", "bodyText": "IC. Yes, that's a good idea.", "author": "jbachorik", "createdAt": "2020-06-15T09:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExNjIwMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440116203", "bodyText": "Well ... this assumes an on-heap buffer since direct buffers have no underlying array.\nSo I will change also the buffer allocation from direct to on-heap.", "author": "jbachorik", "createdAt": "2020-06-15T11:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIxNzY3MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440217670", "bodyText": "Ok, I have added support for exporting the writer data via a callback which will get passed in a ByteBuffer instance. Not sure if this will help anything at the end since we will need to materialize the byte array at the end before base64 encoding it anyway - unless we can not use Java 8 Base64 class which can accept directly ByteBuffer.", "author": "jbachorik", "createdAt": "2020-06-15T14:29:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4NTI0OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440285248", "bodyText": "Yes that's why I said it must be synchronous. I.e. the contract is: the consumer gets access to your data until they return, which can avoid a copy. If they need the data after returning and don't copy it, that's their problem. If the consumer were outside the scope of this codebase, it would be unacceptable, but we can police it with review, and it should avoid allocating lots of arrays. I am inclined to lean away from direct memory.", "author": "richardstartin", "createdAt": "2020-06-15T16:05:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MzAwMQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440353001", "bodyText": "\ud83d\udc4d\nSupport is there - now we only have to make sure the clients will do the right thing.", "author": "jbachorik", "createdAt": "2020-06-15T18:04:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNDcwNg=="}], "type": "inlineReview"}, {"oid": "757fba3fbe334187a55626a71a3ea7d7aa3abe51", "url": "https://github.com/DataDog/dd-trace-java/commit/757fba3fbe334187a55626a71a3ea7d7aa3abe51", "message": "Add methods accepting UTF8 byte array to LEB128Writer", "committedDate": "2020-06-15T14:26:49Z", "type": "commit"}, {"oid": "9228eca3bdffe76c7e967c3888fa721dc02239a9", "url": "https://github.com/DataDog/dd-trace-java/commit/9228eca3bdffe76c7e967c3888fa721dc02239a9", "message": "Allow exporting LEB128Writer contents via a ByteBuffer callback", "committedDate": "2020-06-15T14:27:19Z", "type": "commit"}, {"oid": "2d6e2263fc04aa43fa3e8c28c787b3701efa688c", "url": "https://github.com/DataDog/dd-trace-java/commit/2d6e2263fc04aa43fa3e8c28c787b3701efa688c", "message": "Fix LEB128Writer to byte[] export", "committedDate": "2020-06-15T15:43:43Z", "type": "commit"}, {"oid": "ec71430405d322ec410918b21ed1217c7347c94a", "url": "https://github.com/DataDog/dd-trace-java/commit/ec71430405d322ec410918b21ed1217c7347c94a", "message": "Make formatter happy", "committedDate": "2020-06-15T16:02:21Z", "type": "commit"}, {"oid": "0b7aad513231cf8cab0b8ad34e398500e0d8253f", "url": "https://github.com/DataDog/dd-trace-java/commit/0b7aad513231cf8cab0b8ad34e398500e0d8253f", "message": "Exclude transient implementation classes", "committedDate": "2020-06-15T17:52:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2NDIxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440664212", "bodyText": "So this is the way to work around the final requirement for the lambda. It makes everything so much more readable \ud83d\ude09", "author": "bantonsson", "createdAt": "2020-06-16T08:07:42Z", "path": "utils/mlt-support/src/main/java/com/datadog/mlt/io/LEB128Writer.java", "diffHunk": "@@ -269,7 +314,34 @@ static LEB128Writer getInstance(int initialCapacity) {\n    *\n    * @return byte array containing the written data\n    */\n-  byte[] toByteArray();\n+  default byte[] export() {\n+    final byte[][] dataRef = new byte[1][];", "originalCommit": "0b7aad513231cf8cab0b8ad34e398500e0d8253f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2NzUxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1581#discussion_r440667510", "bodyText": "Yeah. You can choose your poison - either unnecessary AtomicReference or this abomination :(", "author": "jbachorik", "createdAt": "2020-06-16T08:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY2NDIxMg=="}], "type": "inlineReview"}]}