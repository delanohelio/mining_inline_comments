{"pr_number": 1257, "pr_title": "Return TypePool.Resolution that caches TypeDescription calls.", "pr_createdAt": "2020-02-26T01:17:32Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1257", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNTkwOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384225909", "bodyText": "Do these need to be volatile?", "author": "tylerbenson", "createdAt": "2020-02-26T01:19:07Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;\n+    }\n+  }\n+\n+  /**\n+   * TypeDescription implementation that delegates and caches the results for the expensive calls\n+   * commonly used by our instrumentation.\n+   */\n+  private static class CachingTypeDescription\n+      extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {\n+    private final TypeDescription delegate;\n+\n+    // TODO fix thread safetyness:\n+    private Generic superClass;\n+    private TypeList.Generic interfaces;\n+    private AnnotationList annotations;\n+    private MethodList<MethodDescription.InDefinedShape> methods;", "originalCommit": "8a8bdefcdf6407d163a029625c85482450f3f3b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzNDk2Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384334963", "bodyText": "no need", "author": "jpbempel", "createdAt": "2020-02-26T08:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNjAzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384226037", "bodyText": "And this?", "author": "tylerbenson", "createdAt": "2020-02-26T01:19:36Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?", "originalCommit": "8a8bdefcdf6407d163a029625c85482450f3f3b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyODMwMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384328303", "bodyText": "No need, worst case you have created 2 CachingTypeDescriptions on concurrent calls", "author": "jpbempel", "createdAt": "2020-02-26T08:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNjAzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNTg0MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384505840", "bodyText": "Yes, each thread will null -> non-null transition, so this is safe.\nString.hashCode does exactly this some strategy.\nIt may create additional objects, but that's usually better than the coordination overhead.", "author": "dougqh", "createdAt": "2020-02-26T13:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIyNjAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyOTU0Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384329547", "bodyText": "to help you reason about concurrency here, you can use local vars:\nTypeDescription localResolution = cachedResolution; // read field\nif (localResolution == null) {\n    localResolution = new CachingTypeDescription(delegate.resolve());\n}\ncachedResolution = localResolution; // write field\nreturn localResolution;\n\nIn any case you won't return null, that's the most important.", "author": "jpbempel", "createdAt": "2020-02-26T08:14:43Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;", "originalCommit": "8a8bdefcdf6407d163a029625c85482450f3f3b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNDkyOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384504929", "bodyText": "Yes, local variables are especially helpful in these situations.  I'd also like using an explicit this, since I think it makes the shared read/writes more obvious -- but I know, I'm in the minority on that one.", "author": "dougqh", "createdAt": "2020-02-26T13:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyOTU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4ODY5Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384488692", "bodyText": "Looks like this either needs to be addressed, or removed - or maybe expanded with more explanation for posterity", "author": "mar-kolya", "createdAt": "2020-02-26T13:24:58Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;\n+    }\n+  }\n+\n+  /**\n+   * TypeDescription implementation that delegates and caches the results for the expensive calls\n+   * commonly used by our instrumentation.\n+   */\n+  private static class CachingTypeDescription\n+      extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {\n+    private final TypeDescription delegate;\n+\n+    // TODO fix thread safetyness:", "originalCommit": "8a8bdefcdf6407d163a029625c85482450f3f3b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4OTMwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384489300", "bodyText": "SuperClass can be null for things that do not have it... but I guess it's ok to call getSuperClass again in this case - however you may want to add a comment.", "author": "mar-kolya", "createdAt": "2020-02-26T13:26:07Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/DDCachingPoolStrategy.java", "diffHunk": "@@ -232,4 +247,88 @@ public void clear() {\n       // Allowing the high-level eviction policy make the clearing decisions\n     }\n   }\n+\n+  private static class CachingResolution implements TypePool.Resolution {\n+    private final TypePool.Resolution delegate;\n+    private TypeDescription cachedResolution; // FIXME: should this be volatile?\n+\n+    public CachingResolution(final TypePool.Resolution delegate) {\n+\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    public boolean isResolved() {\n+      return delegate.isResolved();\n+    }\n+\n+    @Override\n+    public TypeDescription resolve() {\n+      if (cachedResolution == null) {\n+        cachedResolution = new CachingTypeDescription(delegate.resolve());\n+      }\n+      return cachedResolution;\n+    }\n+  }\n+\n+  /**\n+   * TypeDescription implementation that delegates and caches the results for the expensive calls\n+   * commonly used by our instrumentation.\n+   */\n+  private static class CachingTypeDescription\n+      extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {\n+    private final TypeDescription delegate;\n+\n+    // TODO fix thread safetyness:\n+    private Generic superClass;\n+    private TypeList.Generic interfaces;\n+    private AnnotationList annotations;\n+    private MethodList<MethodDescription.InDefinedShape> methods;\n+\n+    public CachingTypeDescription(final TypeDescription delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    protected TypeDescription delegate() {\n+      return delegate;\n+    }\n+\n+    @Override\n+    public Generic getSuperClass() {\n+      if (superClass == null) {\n+        superClass = delegate.getSuperClass();", "originalCommit": "8a8bdefcdf6407d163a029625c85482450f3f3b1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNzc2NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1257#discussion_r384507765", "bodyText": "I think for us to get much value from the wrapping.  We need to extend our wrapper to have additional capabilities that we need.\nFor instance -- adding getSafeSuperClass, getSafeInterfaces, etc.  That would save heavier repeat work.\nWe can also make our extended TypeDescription store Matcher results, etc. as well.", "author": "dougqh", "createdAt": "2020-02-26T13:58:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQ4OTMwMA=="}], "type": "inlineReview"}, {"oid": "f431d5285af9c629dcf5b18544955959dff8b42d", "url": "https://github.com/DataDog/dd-trace-java/commit/f431d5285af9c629dcf5b18544955959dff8b42d", "message": "Return TypePool.Resolution that caches\n\nCaching focused on the expensive calls primarily used by our instrumentation.", "committedDate": "2020-02-26T20:47:48Z", "type": "commit"}, {"oid": "f431d5285af9c629dcf5b18544955959dff8b42d", "url": "https://github.com/DataDog/dd-trace-java/commit/f431d5285af9c629dcf5b18544955959dff8b42d", "message": "Return TypePool.Resolution that caches\n\nCaching focused on the expensive calls primarily used by our instrumentation.", "committedDate": "2020-02-26T20:47:48Z", "type": "forcePushed"}]}