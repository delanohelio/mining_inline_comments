{"pr_number": 1578, "pr_title": "Iterate type interfaces without materialising a list during super type matching", "pr_createdAt": "2020-06-12T07:56:27Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1578", "timeline": [{"oid": "a550113bc25280eab7c48a1f10fe7e8b755d0676", "url": "https://github.com/DataDog/dd-trace-java/commit/a550113bc25280eab7c48a1f10fe7e8b755d0676", "message": "reduce allocation during type matching", "committedDate": "2020-06-12T08:13:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3NjM2OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439276369", "bodyText": "\ud83d\udc4d", "author": "jbachorik", "createdAt": "2020-06-12T08:18:02Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/matcher/HasSuperMethodMatcher.java", "diffHunk": "@@ -48,8 +49,7 @@ private boolean matchesInterface(\n       final Junction<MethodDescription> signatureMatcher,\n       final Set<TypeDefinition> checkedInterfaces) {\n     for (final TypeDefinition type : interfaces) {\n-      if (!checkedInterfaces.contains(type)) {\n-        checkedInterfaces.add(type);\n+      if (checkedInterfaces.add(type)) {", "originalCommit": "a550113bc25280eab7c48a1f10fe7e8b755d0676", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3ODEzMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439278133", "bodyText": "This looks suspicious - IINM it is valid to call it.next(); it.next(); it.next(); and expect to get the next value on each invocation (or get an exception). But here calling next() without hasNext() being called first will return still the same element.", "author": "jbachorik", "createdAt": "2020-06-12T08:21:40Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/matcher/SafeHasSuperTypeMatcher.java", "diffHunk": "@@ -152,4 +129,55 @@ public boolean equals(final Object other) {\n   public int hashCode() {\n     return 17 * 31 + matcher.hashCode();\n   }\n+\n+  /**\n+   * TypeDefinition#getInterfaces() produces an iterator which may throw an exception during\n+   * iteration if an interface is absent from the classpath.\n+   *\n+   * <p>This wrapper exists to allow getting interfaces even if the lookup on one fails.\n+   */\n+  private static class SafeInterfaceIterator\n+      implements Iterator<TypeDefinition>, Iterable<TypeDefinition> {\n+    private final TypeDefinition typeDefinition;\n+    private final Iterator<TypeDescription.Generic> it;\n+    private TypeDefinition next;\n+\n+    private SafeInterfaceIterator(TypeDefinition typeDefinition) {\n+      this.typeDefinition = typeDefinition;\n+      this.it = typeDefinition.getInterfaces().iterator();\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+      if (it.hasNext()) {\n+        try {\n+          this.next = it.next();\n+          return true;", "originalCommit": "a550113bc25280eab7c48a1f10fe7e8b755d0676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI4MjgxNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439282816", "bodyText": "It's a private static class intended for local usage only, I would prefer to add a comment than change this", "author": "richardstartin", "createdAt": "2020-06-12T08:30:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3ODEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI4NDI5Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439284293", "bodyText": "Ok. Out of curiosity - why is it important that you cache the next value? To avoid the interfaces set check?\nSorry for bikesheding - does it need to be an actual Iterator implementation?", "author": "jbachorik", "createdAt": "2020-06-12T08:33:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3ODEzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5MjQ1OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439292458", "bodyText": "I want to halt the iteration as soon as an exception is thrown. I don't want to check if there is another element, catch an exception in the call to next() and then handle it elsewhere. In fact, this peculiarity is the reason for returning Iterable - to force orderly iteration.", "author": "richardstartin", "createdAt": "2020-06-12T08:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3ODEzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3ODQ4Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439278483", "bodyText": "What about throwing UnsupportedOperationException to make it totally clear that this method is not supposed to be called at all.", "author": "jbachorik", "createdAt": "2020-06-12T08:22:22Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/matcher/SafeHasSuperTypeMatcher.java", "diffHunk": "@@ -152,4 +129,55 @@ public boolean equals(final Object other) {\n   public int hashCode() {\n     return 17 * 31 + matcher.hashCode();\n   }\n+\n+  /**\n+   * TypeDefinition#getInterfaces() produces an iterator which may throw an exception during\n+   * iteration if an interface is absent from the classpath.\n+   *\n+   * <p>This wrapper exists to allow getting interfaces even if the lookup on one fails.\n+   */\n+  private static class SafeInterfaceIterator\n+      implements Iterator<TypeDefinition>, Iterable<TypeDefinition> {\n+    private final TypeDefinition typeDefinition;\n+    private final Iterator<TypeDescription.Generic> it;\n+    private TypeDefinition next;\n+\n+    private SafeInterfaceIterator(TypeDefinition typeDefinition) {\n+      this.typeDefinition = typeDefinition;\n+      this.it = typeDefinition.getInterfaces().iterator();\n+    }\n+\n+    @Override\n+    public boolean hasNext() {\n+      if (it.hasNext()) {\n+        try {\n+          this.next = it.next();\n+          return true;\n+        } catch (Exception e) {\n+          if (log.isDebugEnabled()) {\n+            log.debug(\n+                \"{} trying to get interfaces for target {}: {}\",\n+                e.getClass().getSimpleName(),\n+                safeTypeDefinitionName(typeDefinition),\n+                e.getMessage());\n+          }\n+          return false;\n+        }\n+      }\n+      return false;\n+    }\n+\n+    @Override\n+    public TypeDefinition next() {\n+      return next;\n+    }\n+\n+    @Override\n+    public void remove() {}", "originalCommit": "a550113bc25280eab7c48a1f10fe7e8b755d0676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzNzg4Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439337886", "bodyText": "\ud83d\udc4d", "author": "bantonsson", "createdAt": "2020-06-12T10:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3ODQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3ODk2Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439278963", "bodyText": "Nit: maybe final to discourage brave souls extending this class?", "author": "jbachorik", "createdAt": "2020-06-12T08:23:18Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/matcher/TypeComparators.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package datadog.trace.agent.tooling.bytebuddy.matcher;\n+\n+import java.util.Comparator;\n+import net.bytebuddy.description.type.TypeDefinition;\n+import net.bytebuddy.description.type.TypeDescription;\n+\n+public class TypeComparators {", "originalCommit": "a550113bc25280eab7c48a1f10fe7e8b755d0676", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3OTMzNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439279337", "bodyText": "Is it ok not to do null check?", "author": "jbachorik", "createdAt": "2020-06-12T08:24:00Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/matcher/TypeComparators.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package datadog.trace.agent.tooling.bytebuddy.matcher;\n+\n+import java.util.Comparator;\n+import net.bytebuddy.description.type.TypeDefinition;\n+import net.bytebuddy.description.type.TypeDescription;\n+\n+public class TypeComparators {\n+\n+  public static final Comparator<TypeDescription> TYPE_DESCRIPTION =\n+      new TypeDescriptionComparator();\n+  public static final Comparator<TypeDefinition> TYPE_DEFINITION = new TypeDefinitionComparator();\n+\n+  private static class TypeDescriptionComparator implements Comparator<TypeDescription> {\n+\n+    @Override\n+    public int compare(TypeDescription o1, TypeDescription o2) {\n+      return o1.getSimpleName().compareTo(o2.getSimpleName());", "originalCommit": "a550113bc25280eab7c48a1f10fe7e8b755d0676", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI5ODM5OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439298398", "bodyText": "These are bytebuddy types. As far as I'm aware, the library will throw exceptions rather than produce null values.", "author": "richardstartin", "createdAt": "2020-06-12T09:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3OTMzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQwMDUyNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439400526", "bodyText": "So I'm wondering if this has something to do with the Netty failure. From digging into ByteBuddy a bit it seems like the default equals for those types work on getName and not getSimpleName", "author": "bantonsson", "createdAt": "2020-06-12T12:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3OTMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI3OTgyNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439279826", "bodyText": "Nit: Can this be extracted to a custom iterator type?", "author": "jbachorik", "createdAt": "2020-06-12T08:25:03Z", "path": "dd-java-agent/agent-tooling/src/test/groovy/datadog/trace/agent/tooling/bytebuddy/matcher/HasInterfaceMatcherTest.groovy", "diffHunk": "@@ -46,6 +47,20 @@ class HasInterfaceMatcherTest extends DDSpecification {\n     def type = Mock(TypeDescription)\n     def typeGeneric = Mock(TypeDescription.Generic)\n     def matcher = implementsInterface(named(Object.name))\n+    def interfaces = Mock(TypeList.Generic)\n+    def it = new Iterator() {\n+      int i = 0\n+\n+      @Override\n+      boolean hasNext() {\n+        return i++ < 1\n+      }\n+\n+      @Override\n+      Object next() {\n+        throw new Exception(\"iteration exception\")\n+      }\n+    }", "originalCommit": "a550113bc25280eab7c48a1f10fe7e8b755d0676", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6801e71d1c2d2abb24e9396ef1be754831b5db5a", "url": "https://github.com/DataDog/dd-trace-java/commit/6801e71d1c2d2abb24e9396ef1be754831b5db5a", "message": "reduce allocation during type matching", "committedDate": "2020-06-12T08:53:59Z", "type": "forcePushed"}, {"oid": "b2bd5e1639603e5ee01a1fd5974d3f61206b31f2", "url": "https://github.com/DataDog/dd-trace-java/commit/b2bd5e1639603e5ee01a1fd5974d3f61206b31f2", "message": "reduce allocation during type matching", "committedDate": "2020-06-12T09:08:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTMzODYxNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439338615", "bodyText": "I know that this comment and behavior is the same as the old one, but maybe clarify that it stops at the first exception.", "author": "bantonsson", "createdAt": "2020-06-12T10:29:27Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/matcher/SafeHasSuperTypeMatcher.java", "diffHunk": "@@ -152,4 +129,67 @@ public boolean equals(final Object other) {\n   public int hashCode() {\n     return 17 * 31 + matcher.hashCode();\n   }\n+\n+  /**\n+   * TypeDefinition#getInterfaces() produces an iterator which may throw an exception during\n+   * iteration if an interface is absent from the classpath.\n+   *\n+   * <p>The caller MUST call hasNext() before calling next().\n+   *\n+   * <p>This wrapper exists to allow getting interfaces even if the lookup on one fails.", "originalCommit": "b2bd5e1639603e5ee01a1fd5974d3f61206b31f2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b5ca36bab7628a4a126fd5439f1741d762cb8d35", "url": "https://github.com/DataDog/dd-trace-java/commit/b5ca36bab7628a4a126fd5439f1741d762cb8d35", "message": "reduce allocation during type matching", "committedDate": "2020-06-12T11:59:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2MjM2NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439462364", "bodyText": "I switched to getName and the :dd-java-agent:instrumentation:netty-4.1:testJava11Generated succeeded locally, while getSimpleName fails.\n    public int compare(TypeDescription o1, TypeDescription o2) {\n      if (o1 == o2) {\n        return 0;\n      }\n\n      return o1.getName().compareTo(o2.getName());\n    }", "author": "bantonsson", "createdAt": "2020-06-12T14:43:52Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/matcher/TypeComparators.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package datadog.trace.agent.tooling.bytebuddy.matcher;\n+\n+import java.util.Comparator;\n+import net.bytebuddy.description.type.TypeDefinition;\n+import net.bytebuddy.description.type.TypeDescription;\n+\n+public final class TypeComparators {\n+\n+  public static final Comparator<TypeDescription> TYPE_DESCRIPTION =\n+      new TypeDescriptionComparator();\n+  public static final Comparator<TypeDefinition> TYPE_DEFINITION = new TypeDefinitionComparator();\n+\n+  private static class TypeDescriptionComparator implements Comparator<TypeDescription> {\n+\n+    @Override\n+    public int compare(TypeDescription o1, TypeDescription o2) {\n+      return o1.getSimpleName().compareTo(o2.getSimpleName());", "originalCommit": "b5ca36bab7628a4a126fd5439f1741d762cb8d35", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3MDQ2Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439470462", "bodyText": "Is name sufficient here?  We have to be a bit carefully about duplicates being loaded across different ClassLoaders, but in a limited context, name should work.", "author": "dougqh", "createdAt": "2020-06-12T14:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2MjM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODY5Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1578#discussion_r439478697", "bodyText": "I think I'll just change this back to HashSet to avoid edge cases.", "author": "richardstartin", "createdAt": "2020-06-12T15:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ2MjM2NA=="}], "type": "inlineReview"}, {"oid": "e8302efc759dc1d811ca22309e4de8d01c7b2418", "url": "https://github.com/DataDog/dd-trace-java/commit/e8302efc759dc1d811ca22309e4de8d01c7b2418", "message": "reduce allocation during type matching", "committedDate": "2020-06-12T15:13:23Z", "type": "forcePushed"}, {"oid": "9527c7742ef1c46bf0e8bf1ede9786f51b0408f9", "url": "https://github.com/DataDog/dd-trace-java/commit/9527c7742ef1c46bf0e8bf1ede9786f51b0408f9", "message": "reduce allocation during type matching", "committedDate": "2020-06-12T15:36:01Z", "type": "commit"}, {"oid": "9527c7742ef1c46bf0e8bf1ede9786f51b0408f9", "url": "https://github.com/DataDog/dd-trace-java/commit/9527c7742ef1c46bf0e8bf1ede9786f51b0408f9", "message": "reduce allocation during type matching", "committedDate": "2020-06-12T15:36:01Z", "type": "forcePushed"}]}