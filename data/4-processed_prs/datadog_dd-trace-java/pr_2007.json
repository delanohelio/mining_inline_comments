{"pr_number": 2007, "pr_title": "inject fields once at the root of the type hierarchy", "pr_createdAt": "2020-10-19T19:40:14Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2007", "timeline": [{"oid": "32bb658d71cc3c68ea15878c24a313ce2bbd5336", "url": "https://github.com/DataDog/dd-trace-java/commit/32bb658d71cc3c68ea15878c24a313ce2bbd5336", "message": "inject fields once at the root of the type hierarchy", "committedDate": "2020-10-19T19:45:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODAxOTUyOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508019528", "bodyText": "Are the fields accessed directly or are there generated accessor methods added?", "author": "tylerbenson", "createdAt": "2020-10-19T19:46:53Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/FieldInjectionVisitor.java", "diffHunk": "@@ -123,7 +123,7 @@ public void visitEnd() {\n         if (!foundField) {\n           cv.visitField(\n               // Field should be transient to avoid being serialized with the object.\n-              Opcodes.ACC_PRIVATE | Opcodes.ACC_TRANSIENT,\n+              Opcodes.ACC_PROTECTED | Opcodes.ACC_TRANSIENT,", "originalCommit": "32bb658d71cc3c68ea15878c24a313ce2bbd5336", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODAyMTI0Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508021243", "bodyText": "public accessors are generated so this shouldn't be necessary", "author": "richardstartin", "createdAt": "2020-10-19T19:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODAxOTUyOA=="}], "type": "inlineReview"}, {"oid": "bb543541ee3feeffcb8e6d4c2f1116e34533dd8e", "url": "https://github.com/DataDog/dd-trace-java/commit/bb543541ee3feeffcb8e6d4c2f1116e34533dd8e", "message": "inject fields once at the root of the type hierarchy", "committedDate": "2020-10-19T19:49:06Z", "type": "forcePushed"}, {"oid": "fa292ce15a0495cdcea562299f5933637cdb4a6a", "url": "https://github.com/DataDog/dd-trace-java/commit/fa292ce15a0495cdcea562299f5933637cdb4a6a", "message": "inject fields once at the root of the type hierarchy", "committedDate": "2020-10-19T19:51:41Z", "type": "forcePushed"}, {"oid": "e4b8620a6259004736932275106155f553bf4853", "url": "https://github.com/DataDog/dd-trace-java/commit/e4b8620a6259004736932275106155f553bf4853", "message": "inject fields once at the root of the type hierarchy", "committedDate": "2020-10-19T20:01:45Z", "type": "forcePushed"}, {"oid": "30f0783f63ae169a1cd089d9a26cfeb12cd25bbe", "url": "https://github.com/DataDog/dd-trace-java/commit/30f0783f63ae169a1cd089d9a26cfeb12cd25bbe", "message": "inject fields once at the root of the type hierarchy", "committedDate": "2020-10-19T20:59:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5ODQ4NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508098485", "bodyText": "It's a bit difficult for me to understand how this method is able to identify the correct classes to instrument. Perhaps a comment would help?", "author": "tylerbenson", "createdAt": "2020-10-19T22:26:37Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -76,6 +103,32 @@ public boolean matches(\n             valueType);\n       }\n     }\n-    return result;\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {", "originalCommit": "30f0783f63ae169a1cd089d9a26cfeb12cd25bbe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI0OTgwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508249807", "bodyText": "I don't think the logic is particularly complicated", "author": "richardstartin", "createdAt": "2020-10-20T06:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODA5ODQ4NQ=="}], "type": "inlineReview"}, {"oid": "57ef21e3b6c0d17c45f5883cd61dee6d9e725e2d", "url": "https://github.com/DataDog/dd-trace-java/commit/57ef21e3b6c0d17c45f5883cd61dee6d9e725e2d", "message": "inject fields once at the root of the type hierarchy", "committedDate": "2020-10-20T06:50:20Z", "type": "forcePushed"}, {"oid": "72e27cda53b9cd015d6960f21d7654becc22dbea", "url": "https://github.com/DataDog/dd-trace-java/commit/72e27cda53b9cd015d6960f21d7654becc22dbea", "message": "inject fields once at the root of the type hierarchy", "committedDate": "2020-10-20T07:48:17Z", "type": "commit"}, {"oid": "72e27cda53b9cd015d6960f21d7654becc22dbea", "url": "https://github.com/DataDog/dd-trace-java/commit/72e27cda53b9cd015d6960f21d7654becc22dbea", "message": "inject fields once at the root of the type hierarchy", "committedDate": "2020-10-20T07:48:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0Nzc1Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508347756", "bodyText": "I'm not sure we can short-circuit the search here if you want to get the closest class to Object that implements the key interface. If ByteBuddy's getInterfaces method behaves like reflection then it will only tell you what the class declared as its interfaces at that level, and not all the interfaces it implements.\nFor example:\nclass A implements Runnable {\n  public void run() {}\n}\n\nclass B extends A {}\n\nclass C extends B {}\n\nclass D extends C {}\n\nWith the above code we'd field-inject D, C, and A.\nThere are also cases where sub-classes re-declare the interfaces they implement:\nclass A implements Runnable {\n  public void run() {}\n}\n\nclass B extends A {}\n\nclass C extends B {}\n\nclass D extends C implements Runnable {}\n\nNot to mention cases where an interface extends another interface:\ninterface R extends Runnable {}\n\nclass A implements R {\n  public void run() {}\n}\n\nclass B extends A {}\n\nclass C extends B {}\n\nclass D extends C implements Runnable {}\n\nSince this is an optimization then we don't need to do an exhaustive search - but I think it's worth checking against a few frameworks to see if we miss any chances to skip field injection.", "author": "mcculls", "createdAt": "2020-10-20T09:25:54Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,153 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.\n+     */\n+    boolean shouldInject =\n+        classBeingRedefined == null\n+            || Arrays.asList(classBeingRedefined.getInterfaces())\n+                .contains(FieldBackedContextStoreAppliedMarker.class);\n+    String injectionTarget = null;\n+    if (shouldInject) {\n+      // will always inject the key type if it's a class,\n+      // if this isn't the key class, we need to find the\n+      // last super class that implements the key type,\n+      // if it is an interface. This could be streamlined\n+      // slightly if we knew whether the key type were an\n+      // interface or a class, but can be figured out as\n+      // we go along\n+      if (!keyType.equals(typeDescription.getName())) {\n+        injectionTarget = getInjectionTarget(typeDescription);\n+        shouldInject &= typeDescription.getName().equals(injectionTarget);\n+      }\n+    }\n+    if (log.isDebugEnabled()) {\n+      if (shouldInject) {\n+        // Only log success the first time we add it to the class\n+        if (classBeingRedefined == null) {\n+          log.debug(\n+              \"Added context-store field to {}: {} -> {}\",\n+              typeDescription.getName(),\n+              keyType,\n+              valueType);\n+        }\n+      } else if (null != injectionTarget) {\n+        log.debug(\n+            \"Will not add context-store field to {}: {} -> {}, because it will be added to {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType,\n+            injectionTarget);\n+      } else {\n+        // This will log for every failed redefine\n+        log.debug(\n+            \"Failed to add context-store field to {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+    }\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {\n+    // The flag takes 3 values:\n+    // true: the key type is a class, so should be the injection target\n+    // false: the key type is an interface, so we need to find the class\n+    // closes to java.lang.Object which implements the key type\n+    // null: we don't know yet because we haven't seen the key type before\n+    Boolean keyTypeIsClass = KEY_TYPE_IS_CLASS.get(keyType);\n+    if (null != keyTypeIsClass && keyTypeIsClass) {\n+      // if we already know the key type is a class,\n+      // we must inject into that class.\n+      return keyType;\n+    }\n+    // then we don't know it's a class so need to\n+    // follow the type's ancestry to find out\n+    TypeDescription.Generic superClass = typeDescription.getSuperClass();\n+    String implementingClass = typeDescription.getName();\n+    while (null != superClass) {\n+      String superClassName = superClass.asRawType().getTypeName();\n+      if (null == keyTypeIsClass && keyType.equals(superClassName)) {\n+        // short circuit the search with this key type next time\n+        KEY_TYPE_IS_CLASS.put(keyType, true);\n+        return keyType;\n+      }\n+      boolean implementsInterface = false;\n+      for (TypeDescription.Generic iface : superClass.getInterfaces()) {\n+        String interfaceName = iface.asRawType().getTypeName();\n+        if (keyType.equals(interfaceName)) {\n+          // then the key type must be an interface\n+          if (null == keyTypeIsClass) {\n+            KEY_TYPE_IS_CLASS.put(keyType, false);\n+            keyTypeIsClass = false;\n+          }\n+          implementingClass = superClassName;\n+          implementsInterface = true;\n+          break;\n+        }\n+      }\n+      if (!implementsInterface) {\n+        break;", "originalCommit": "72e27cda53b9cd015d6960f21d7654becc22dbea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM1MzIzNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508353236", "bodyText": "Yes, you're right (the first paragraph was clear enough but thanks for the example) - I added a test for this and removed the short circuit.", "author": "richardstartin", "createdAt": "2020-10-20T09:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM0Nzc1Ng=="}], "type": "inlineReview"}, {"oid": "99dac885e302dd53dc8fdc14db3a396656ead9a2", "url": "https://github.com/DataDog/dd-trace-java/commit/99dac885e302dd53dc8fdc14db3a396656ead9a2", "message": "add tests for ShouldInjectFieldsMatcher and remove short circuit optimisation", "committedDate": "2020-10-20T09:34:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3NDc5Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508374797", "bodyText": "We'll still miss a chance to optimize if the class hierarchy implements an interface that extends the key type and doesn't implement the key type directly (since this only checks directly declared interfaces, and not the interfaces they extend) but I think that's OK as widening the search to include transitive interfaces could be expensive.", "author": "mcculls", "createdAt": "2020-10-20T10:06:51Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.\n+     */\n+    boolean shouldInject =\n+        classBeingRedefined == null\n+            || Arrays.asList(classBeingRedefined.getInterfaces())\n+                .contains(FieldBackedContextStoreAppliedMarker.class);\n+    String injectionTarget = null;\n+    if (shouldInject) {\n+      // will always inject the key type if it's a class,\n+      // if this isn't the key class, we need to find the\n+      // last super class that implements the key type,\n+      // if it is an interface. This could be streamlined\n+      // slightly if we knew whether the key type were an\n+      // interface or a class, but can be figured out as\n+      // we go along\n+      if (!keyType.equals(typeDescription.getName())) {\n+        injectionTarget = getInjectionTarget(typeDescription);\n+        shouldInject &= typeDescription.getName().equals(injectionTarget);\n+      }\n+    }\n+    if (log.isDebugEnabled()) {\n+      if (shouldInject) {\n+        // Only log success the first time we add it to the class\n+        if (classBeingRedefined == null) {\n+          log.debug(\n+              \"Added context-store field to {}: {} -> {}\",\n+              typeDescription.getName(),\n+              keyType,\n+              valueType);\n+        }\n+      } else if (null != injectionTarget) {\n+        log.debug(\n+            \"Will not add context-store field to {}: {} -> {}, because it will be added to {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType,\n+            injectionTarget);\n+      } else {\n+        // This will log for every failed redefine\n+        log.debug(\n+            \"Failed to add context-store field to {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+    }\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {\n+    // precondition: typeDescription must be a sub type of the key class\n+    // verifying this isn't free so the caller (in the same package) is trusted\n+\n+    // The flag takes 3 values:\n+    // true: the key type is a class, so should be the injection target\n+    // false: the key type is an interface, so we need to find the class\n+    // closes to java.lang.Object which implements the key type\n+    // null: we don't know yet because we haven't seen the key type before\n+    Boolean keyTypeIsClass = KEY_TYPE_IS_CLASS.get(keyType);\n+    if (null != keyTypeIsClass && keyTypeIsClass) {\n+      // if we already know the key type is a class,\n+      // we must inject into that class.\n+      return keyType;\n+    }\n+    // then we don't know it's a class so need to\n+    // follow the type's ancestry to find out\n+    TypeDescription.Generic superClass = typeDescription.getSuperClass();\n+    String implementingClass = typeDescription.getName();\n+    while (null != superClass) {\n+      String superClassName = superClass.asRawType().getTypeName();\n+      if (null == keyTypeIsClass && keyType.equals(superClassName)) {\n+        // short circuit the search with this key type next time\n+        KEY_TYPE_IS_CLASS.put(keyType, true);\n+        return keyType;\n+      }\n+      for (TypeDescription.Generic iface : superClass.getInterfaces()) {", "originalCommit": "99dac885e302dd53dc8fdc14db3a396656ead9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3ODg3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508378879", "bodyText": "You're right, but this should work for all the types we're interested in injecting (we need to stop doing this for Runnable for other reasons). This kind of matching is done repetitively, and I think the structure of the types we care about, at least for the purpose of field injection, could be memoized cheaply so we don't need to do so many traversals. The result is also correct no matter what, it's just a missed optimisation opportunity (both in space and transformation time).", "author": "richardstartin", "createdAt": "2020-10-20T10:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3NDc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM5ODYxNA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508398614", "bodyText": "Having said that, I would be amazed if traversing the hierarchy when we already know there's a subtype relationship outweighs the cost of unnecessary transformation, or the long term cost of carrying extra fields around.", "author": "richardstartin", "createdAt": "2020-10-20T10:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3NDc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwMDg4MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508400880", "bodyText": "true - if you do extend the search to cover transitive interfaces then you might want to consider a local cache to track which interfaces you've seen", "author": "mcculls", "createdAt": "2020-10-20T10:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3NDc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ5MDAxMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508490010", "bodyText": "For more context to anyone else reviewing, the single case that I considered making this for is ForkJoinTask. Whether you're using the streams API or RecursiveAction etc.  the API depends on being able fork lots of tiny objects but there are often at least two levels of class inheritance. This won't make much difference to wide interface inheritance hierarchies.", "author": "richardstartin", "createdAt": "2020-10-20T13:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM3NDc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMzMzOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508413338", "bodyText": "I think that the javadoc is very clear:\n\nReturns the interfaces directly implemented by the class or interface represented by this object.", "author": "bantonsson", "createdAt": "2020-10-20T11:11:00Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.", "originalCommit": "99dac885e302dd53dc8fdc14db3a396656ead9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODQyMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508438420", "bodyText": "This is an existing comment", "author": "richardstartin", "createdAt": "2020-10-20T11:55:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMzMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NDMzOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508444338", "bodyText": "It's still broken...", "author": "bantonsson", "createdAt": "2020-10-20T12:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMzMzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0ODUxOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508448518", "bodyText": "Yes, I agree. There are also a few missing articles which certainly justifies a cleanup.", "author": "richardstartin", "createdAt": "2020-10-20T12:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQxMzMzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQyMTIzNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508421236", "bodyText": "Do we think that it's common to have a sub-class that is re-implementing and interface? This looks like it will try super-classes even though it found a direct implementation of an interface in the current class.", "author": "bantonsson", "createdAt": "2020-10-20T11:25:01Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.\n+     */\n+    boolean shouldInject =\n+        classBeingRedefined == null\n+            || Arrays.asList(classBeingRedefined.getInterfaces())\n+                .contains(FieldBackedContextStoreAppliedMarker.class);\n+    String injectionTarget = null;\n+    if (shouldInject) {\n+      // will always inject the key type if it's a class,\n+      // if this isn't the key class, we need to find the\n+      // last super class that implements the key type,\n+      // if it is an interface. This could be streamlined\n+      // slightly if we knew whether the key type were an\n+      // interface or a class, but can be figured out as\n+      // we go along\n+      if (!keyType.equals(typeDescription.getName())) {\n+        injectionTarget = getInjectionTarget(typeDescription);\n+        shouldInject &= typeDescription.getName().equals(injectionTarget);\n+      }\n+    }\n+    if (log.isDebugEnabled()) {\n+      if (shouldInject) {\n+        // Only log success the first time we add it to the class\n+        if (classBeingRedefined == null) {\n+          log.debug(\n+              \"Added context-store field to {}: {} -> {}\",\n+              typeDescription.getName(),\n+              keyType,\n+              valueType);\n+        }\n+      } else if (null != injectionTarget) {\n+        log.debug(\n+            \"Will not add context-store field to {}: {} -> {}, because it will be added to {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType,\n+            injectionTarget);\n+      } else {\n+        // This will log for every failed redefine\n+        log.debug(\n+            \"Failed to add context-store field to {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+    }\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {\n+    // precondition: typeDescription must be a sub type of the key class\n+    // verifying this isn't free so the caller (in the same package) is trusted\n+\n+    // The flag takes 3 values:\n+    // true: the key type is a class, so should be the injection target\n+    // false: the key type is an interface, so we need to find the class\n+    // closes to java.lang.Object which implements the key type\n+    // null: we don't know yet because we haven't seen the key type before\n+    Boolean keyTypeIsClass = KEY_TYPE_IS_CLASS.get(keyType);\n+    if (null != keyTypeIsClass && keyTypeIsClass) {\n+      // if we already know the key type is a class,\n+      // we must inject into that class.\n+      return keyType;\n+    }\n+    // then we don't know it's a class so need to\n+    // follow the type's ancestry to find out\n+    TypeDescription.Generic superClass = typeDescription.getSuperClass();\n+    String implementingClass = typeDescription.getName();\n+    while (null != superClass) {\n+      String superClassName = superClass.asRawType().getTypeName();\n+      if (null == keyTypeIsClass && keyType.equals(superClassName)) {\n+        // short circuit the search with this key type next time\n+        KEY_TYPE_IS_CLASS.put(keyType, true);\n+        return keyType;\n+      }\n+      for (TypeDescription.Generic iface : superClass.getInterfaces()) {\n+        String interfaceName = iface.asRawType().getTypeName();\n+        if (keyType.equals(interfaceName)) {\n+          // then the key type must be an interface\n+          if (null == keyTypeIsClass) {\n+            KEY_TYPE_IS_CLASS.put(keyType, false);\n+            keyTypeIsClass = false;\n+          }\n+          implementingClass = superClassName;\n+          break;", "originalCommit": "99dac885e302dd53dc8fdc14db3a396656ead9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzOTUzOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508439539", "bodyText": "It's looking for the class closest to java.lang.Object to inject the field in to, so it will go up the hierarchy, but remember that this class implements the interface.", "author": "richardstartin", "createdAt": "2020-10-20T11:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQyMTIzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NDU4Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508444582", "bodyText": "Yes, I can see now that you discussed this with @mcculls and it's fine if we assume that it's common enough.", "author": "bantonsson", "createdAt": "2020-10-20T12:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQyMTIzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQyMjgxNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508422817", "bodyText": "It feels like we are missing to check the typeDescription for interface implementations. This code jumps straight to the superClass.", "author": "bantonsson", "createdAt": "2020-10-20T11:27:47Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.\n+     */\n+    boolean shouldInject =\n+        classBeingRedefined == null\n+            || Arrays.asList(classBeingRedefined.getInterfaces())\n+                .contains(FieldBackedContextStoreAppliedMarker.class);\n+    String injectionTarget = null;\n+    if (shouldInject) {\n+      // will always inject the key type if it's a class,\n+      // if this isn't the key class, we need to find the\n+      // last super class that implements the key type,\n+      // if it is an interface. This could be streamlined\n+      // slightly if we knew whether the key type were an\n+      // interface or a class, but can be figured out as\n+      // we go along\n+      if (!keyType.equals(typeDescription.getName())) {\n+        injectionTarget = getInjectionTarget(typeDescription);\n+        shouldInject &= typeDescription.getName().equals(injectionTarget);\n+      }\n+    }\n+    if (log.isDebugEnabled()) {\n+      if (shouldInject) {\n+        // Only log success the first time we add it to the class\n+        if (classBeingRedefined == null) {\n+          log.debug(\n+              \"Added context-store field to {}: {} -> {}\",\n+              typeDescription.getName(),\n+              keyType,\n+              valueType);\n+        }\n+      } else if (null != injectionTarget) {\n+        log.debug(\n+            \"Will not add context-store field to {}: {} -> {}, because it will be added to {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType,\n+            injectionTarget);\n+      } else {\n+        // This will log for every failed redefine\n+        log.debug(\n+            \"Failed to add context-store field to {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+    }\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {\n+    // precondition: typeDescription must be a sub type of the key class\n+    // verifying this isn't free so the caller (in the same package) is trusted\n+\n+    // The flag takes 3 values:\n+    // true: the key type is a class, so should be the injection target\n+    // false: the key type is an interface, so we need to find the class\n+    // closes to java.lang.Object which implements the key type\n+    // null: we don't know yet because we haven't seen the key type before\n+    Boolean keyTypeIsClass = KEY_TYPE_IS_CLASS.get(keyType);\n+    if (null != keyTypeIsClass && keyTypeIsClass) {\n+      // if we already know the key type is a class,\n+      // we must inject into that class.\n+      return keyType;\n+    }\n+    // then we don't know it's a class so need to\n+    // follow the type's ancestry to find out\n+    TypeDescription.Generic superClass = typeDescription.getSuperClass();\n+    String implementingClass = typeDescription.getName();\n+    while (null != superClass) {\n+      String superClassName = superClass.asRawType().getTypeName();", "originalCommit": "99dac885e302dd53dc8fdc14db3a396656ead9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODc1OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508438758", "bodyText": "This is discussed above.\nWe already know there is a sub type relationship, so if there is no super class or no super class is found to inject the field in to, we end up injecting into this class (we return implementingClass which was initialised to the type description's name, without overwriting it.)", "author": "richardstartin", "createdAt": "2020-10-20T11:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQyMjgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ0NDkwNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508444905", "bodyText": "Ah yes, the other matcher before this one.", "author": "bantonsson", "createdAt": "2020-10-20T12:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQyMjgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1Nzg5NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508557895", "bodyText": "Very slim edge case that is probably not worth considering:  It is possible for this result to be different on different classloaders within a single jvm.", "author": "tylerbenson", "createdAt": "2020-10-20T14:29:02Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/context/ShouldInjectFieldsMatcher.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package datadog.trace.agent.tooling.context;\n+\n+import datadog.trace.bootstrap.FieldBackedContextStoreAppliedMarker;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter;\n+import java.security.ProtectionDomain;\n+import java.util.Arrays;\n+import java.util.concurrent.ConcurrentHashMap;\n+import lombok.extern.slf4j.Slf4j;\n+import net.bytebuddy.agent.builder.AgentBuilder;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.utility.JavaModule;\n+\n+@Slf4j\n+final class ShouldInjectFieldsMatcher implements AgentBuilder.RawMatcher {\n+\n+  // this map will contain as many entries as there are unique\n+  // context store keys, so can't get very big\n+  private static final ConcurrentHashMap<String, Boolean> KEY_TYPE_IS_CLASS =\n+      new ConcurrentHashMap<>();\n+\n+  public static AgentBuilder.RawMatcher of(String keyType, String valueType) {\n+    return new ShouldInjectFieldsMatcher(keyType, valueType);\n+  }\n+\n+  private final String keyType;\n+  private final String valueType;\n+  private final ExcludeFilter.ExcludeType skipType;\n+\n+  private ShouldInjectFieldsMatcher(String keyType, String valueType) {\n+    this.keyType = keyType;\n+    this.valueType = valueType;\n+    this.skipType = ExcludeFilter.ExcludeType.fromFieldType(keyType);\n+  }\n+\n+  @Override\n+  public boolean matches(\n+      final TypeDescription typeDescription,\n+      final ClassLoader classLoader,\n+      final JavaModule module,\n+      final Class<?> classBeingRedefined,\n+      final ProtectionDomain protectionDomain) {\n+\n+    // First check if we should skip injecting the field based on the key type\n+    if (skipType != null && ExcludeFilter.exclude(skipType, typeDescription.getName())) {\n+      if (log.isDebugEnabled()) {\n+        log.debug(\n+            \"Skipping context-store field for {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+      return false;\n+    }\n+    /*\n+     * The idea here is that we can add fields if class is just being loaded\n+     * (classBeingRedefined == null) and we have to add same fields again if class we added\n+     * fields before is being transformed again. Note: here we assume that Class#getInterfaces()\n+     * returns list of interfaces defined immediately on a given class, not inherited from its\n+     * parents. It looks like current JVM implementation does exactly this but javadoc is not\n+     * explicit about that.\n+     */\n+    boolean shouldInject =\n+        classBeingRedefined == null\n+            || Arrays.asList(classBeingRedefined.getInterfaces())\n+                .contains(FieldBackedContextStoreAppliedMarker.class);\n+    String injectionTarget = null;\n+    if (shouldInject) {\n+      // will always inject the key type if it's a class,\n+      // if this isn't the key class, we need to find the\n+      // last super class that implements the key type,\n+      // if it is an interface. This could be streamlined\n+      // slightly if we knew whether the key type were an\n+      // interface or a class, but can be figured out as\n+      // we go along\n+      if (!keyType.equals(typeDescription.getName())) {\n+        injectionTarget = getInjectionTarget(typeDescription);\n+        shouldInject &= typeDescription.getName().equals(injectionTarget);\n+      }\n+    }\n+    if (log.isDebugEnabled()) {\n+      if (shouldInject) {\n+        // Only log success the first time we add it to the class\n+        if (classBeingRedefined == null) {\n+          log.debug(\n+              \"Added context-store field to {}: {} -> {}\",\n+              typeDescription.getName(),\n+              keyType,\n+              valueType);\n+        }\n+      } else if (null != injectionTarget) {\n+        log.debug(\n+            \"Will not add context-store field to {}: {} -> {}, because it will be added to {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType,\n+            injectionTarget);\n+      } else {\n+        // This will log for every failed redefine\n+        log.debug(\n+            \"Failed to add context-store field to {}: {} -> {}\",\n+            typeDescription.getName(),\n+            keyType,\n+            valueType);\n+      }\n+    }\n+    return shouldInject;\n+  }\n+\n+  private String getInjectionTarget(TypeDescription typeDescription) {\n+    // precondition: typeDescription must be a sub type of the key class\n+    // verifying this isn't free so the caller (in the same package) is trusted\n+\n+    // The flag takes 3 values:\n+    // true: the key type is a class, so should be the injection target\n+    // false: the key type is an interface, so we need to find the class\n+    // closes to java.lang.Object which implements the key type\n+    // null: we don't know yet because we haven't seen the key type before\n+    Boolean keyTypeIsClass = KEY_TYPE_IS_CLASS.get(keyType);", "originalCommit": "99dac885e302dd53dc8fdc14db3a396656ead9a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU2OTk2Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2007#discussion_r508569967", "bodyText": "I'm fairly sure there would be a ClassCastException in any instrumentation using a context store if your edge case existed in practice.", "author": "richardstartin", "createdAt": "2020-10-20T14:43:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODU1Nzg5NQ=="}], "type": "inlineReview"}]}