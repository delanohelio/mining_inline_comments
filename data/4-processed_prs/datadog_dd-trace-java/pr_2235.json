{"pr_number": 2235, "pr_title": "AgentTestRunner refactor and cleanup", "pr_createdAt": "2020-12-22T22:52:42Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2235", "timeline": [{"oid": "1b8b3992dc39ab80590b2ba55287897531ffeb62", "url": "https://github.com/DataDog/dd-trace-java/commit/1b8b3992dc39ab80590b2ba55287897531ffeb62", "message": "Big refactor", "committedDate": "2020-12-22T23:07:27Z", "type": "forcePushed"}, {"oid": "b21dfa1c69be637d7c1749028ccaf5375153a9d9", "url": "https://github.com/DataDog/dd-trace-java/commit/b21dfa1c69be637d7c1749028ccaf5375153a9d9", "message": "Allow WithGlobalCallback to work across multiple tracer installations", "committedDate": "2020-12-23T22:46:26Z", "type": "forcePushed"}, {"oid": "0430aecd576a4a117c25216afd27ebfe2801eac9", "url": "https://github.com/DataDog/dd-trace-java/commit/0430aecd576a4a117c25216afd27ebfe2801eac9", "message": "ignore class load errors from the http server being shutdown", "committedDate": "2020-12-24T17:58:10Z", "type": "forcePushed"}, {"oid": "5f6d7daab357e8cef30b57732cf2040027073f99", "url": "https://github.com/DataDog/dd-trace-java/commit/5f6d7daab357e8cef30b57732cf2040027073f99", "message": "Add ability to override tracer registration", "committedDate": "2020-12-24T19:29:25Z", "type": "commit"}, {"oid": "c6bf31d407f3f9e01e2d11bb3531f244b6cad555", "url": "https://github.com/DataDog/dd-trace-java/commit/c6bf31d407f3f9e01e2d11bb3531f244b6cad555", "message": "Use TEST_TRACER directly instead of method", "committedDate": "2020-12-24T19:29:25Z", "type": "commit"}, {"oid": "b56a89a3e0d4334b9c8d18de20d215ba0b7e955d", "url": "https://github.com/DataDog/dd-trace-java/commit/b56a89a3e0d4334b9c8d18de20d215ba0b7e955d", "message": "ignore class load errors from the http server being shutdown", "committedDate": "2020-12-24T19:29:25Z", "type": "forcePushed"}, {"oid": "3745cfabd2d19f30a2a0ef82f9fd4d2244bc66b5", "url": "https://github.com/DataDog/dd-trace-java/commit/3745cfabd2d19f30a2a0ef82f9fd4d2244bc66b5", "message": "Big refactor", "committedDate": "2020-12-24T21:13:28Z", "type": "commit"}, {"oid": "22900bc5c822b56830ff1e542af5001a67731707", "url": "https://github.com/DataDog/dd-trace-java/commit/22900bc5c822b56830ff1e542af5001a67731707", "message": "Fix scala tests", "committedDate": "2020-12-24T21:13:28Z", "type": "commit"}, {"oid": "be57e16ea2bf8abdc8e3a5e4f5542c0cb2611356", "url": "https://github.com/DataDog/dd-trace-java/commit/be57e16ea2bf8abdc8e3a5e4f5542c0cb2611356", "message": "Fix codenarc", "committedDate": "2020-12-24T21:13:28Z", "type": "commit"}, {"oid": "7972a67c23a438ad2babd539096d469ecfae61f7", "url": "https://github.com/DataDog/dd-trace-java/commit/7972a67c23a438ad2babd539096d469ecfae61f7", "message": "Allow WithGlobalCallback to work across multiple tracer installations", "committedDate": "2020-12-24T21:13:28Z", "type": "commit"}, {"oid": "fb383c1a19b09ab4826f3342199422d8cacd68b3", "url": "https://github.com/DataDog/dd-trace-java/commit/fb383c1a19b09ab4826f3342199422d8cacd68b3", "message": "ignore class load errors from the http server being shutdown", "committedDate": "2020-12-24T21:13:28Z", "type": "commit"}, {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "url": "https://github.com/DataDog/dd-trace-java/commit/28a4be28deac23da5b3dfc32ddb85e83934e2e86", "message": "Ignore coverage because of Groovy bug", "committedDate": "2020-12-24T21:13:28Z", "type": "commit"}, {"oid": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "url": "https://github.com/DataDog/dd-trace-java/commit/28a4be28deac23da5b3dfc32ddb85e83934e2e86", "message": "Ignore coverage because of Groovy bug", "committedDate": "2020-12-24T21:13:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwNDEzNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549404135", "bodyText": "Consider adding a warning level log message when this is used so it can be identified if somehow invoked in non-test env's.  (This could also be done in the forceRegister methods instead.)", "author": "tylerbenson", "createdAt": "2020-12-28T16:19:15Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/TracerInstaller.java", "diffHunk": "@@ -25,9 +25,21 @@ public static void installGlobalTracer(final CoreTracer tracer) {\n     try {\n       GlobalTracer.registerIfAbsent(tracer);\n       AgentTracer.registerIfAbsent(tracer);\n+\n+      log.debug(\"Global tracer installed\");\n+    } catch (final RuntimeException re) {\n+      log.warn(\"Failed to register tracer: {}\", tracer, re);\n+    }\n+  }\n+\n+  public static void forceInstallGlobalTracer(CoreTracer tracer) {", "originalCommit": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwNzgxNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549407815", "bodyText": "Do we need a way for tests to remove callbacks after test completion?", "author": "tylerbenson", "createdAt": "2020-12-28T16:31:21Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "diffHunk": "@@ -31,50 +32,52 @@ public boolean addTraceInterceptor(TraceInterceptor traceInterceptor) {\n         @Override\n         public void addScopeListener(ScopeListener listener) {}\n       };\n-  private static final AtomicReference<Tracer> provider = new AtomicReference<>(NO_OP);\n+\n+  private static final Collection<Callback> installationCallbacks = new ArrayList<>();", "originalCommit": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1MTM2MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549451361", "bodyText": "No, and removing them would break tests.\nThe callbacks are added with the initialization of the logging framework specific MDC class (with LogContextScopeListener.add()).  This only happens once per module.  Everything worked fine previously because CoreTracer was static and only created once per module.\nWith the changes in this PR, CoreTracer is created once per test class but the MDC initialization still only happens once per module.  Those callbacks need to be called on every CoreTracer instance.\nIn the future, if we have classloader isolation between test classes in the same module, the MDC class would be initialized multiple times, but the static installationCallbacks field would also be initialized multiple times.\ntl;dr: the lifecycle of installationCallbacks needs to match the lifecycle of the MDC subclass which is static for now.", "author": "randomanderson", "createdAt": "2020-12-28T18:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwNzgxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwODgzOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549408839", "bodyText": "I'm not sure I understand this change... please elaborate.", "author": "tylerbenson", "createdAt": "2020-12-28T16:34:45Z", "path": "dd-java-agent/testing/src/test/groovy/context/FieldBackedProviderTest.groovy", "diffHunk": "@@ -32,21 +33,14 @@ import static datadog.trace.bootstrap.config.provider.SystemPropertiesConfigSour\n import static org.junit.Assume.assumeTrue\n \n class FieldBackedProviderTest extends AgentTestRunner {\n-\n   @Override\n-  boolean onInstrumentationError(\n-    final String typeName,\n-    final ClassLoader classLoader,\n-    final JavaModule module,\n-    final boolean loaded,\n-    final Throwable throwable) {\n-    // Incorrect* classes assert on incorrect api usage. Error expected.\n-    return !(typeName.startsWith(ContextTestInstrumentation.getName() + '$Incorrect') && throwable.getMessage().startsWith(\"Incorrect Context Api Usage detected.\"))\n-  }\n+  void onDiscovery(String typeName, ClassLoader classLoader, JavaModule module, boolean loaded) {\n+    if (typeName?.endsWith(\"UntransformableKeyClass\")) {\n+      throw new AbortTransformationException(\n+        \"Aborting transform for class name = \" + typeName + \", loader = \" + classLoader)\n+    }\n \n-  @Override\n-  protected boolean shouldTransformClass(final String className, final ClassLoader classLoader) {\n-    return className == null || (!className.endsWith(\"UntransformableKeyClass\"))\n+    super.onDiscovery(typeName, classLoader, module, loaded)", "originalCommit": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNzQ4MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549437481", "bodyText": "The previous code had a static instance named TEST_LISTENER that implemented AgentBuilder.Listener and called onInstrumentationError and shouldTransformClass on subclasses of AgentTestRunner.\nWith this PR, AgentTestRunner implements AgentBuilder.Listener directly:\nshouldTransformClass() -> onDiscovery()\nonInstrumentationError() -> onError()\nTEST_LISTENER previously threw  AbortTransfomationException when shouldTransformClass returned false.\nThe test for ContextTestInstrumentation.getName() + '$Incorrect' was moved to AgentTestRunner.  The incorrect api usage instrumentation errors were being picked up by more that just this particular test because of the change in the ordering of the test lifecycle.  If that wasn't the case, onInstrumentationError would have just been changed to onError.", "author": "randomanderson", "createdAt": "2020-12-28T18:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwODgzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwOTQ1OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549409458", "bodyText": "Why is it necessary? I would expect the .class to be implicit now that this is groovy.", "author": "tylerbenson", "createdAt": "2020-12-28T16:36:35Z", "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.groovy", "diffHunk": "@@ -0,0 +1,263 @@\n+package datadog.trace.agent.test\n+\n+import ch.qos.logback.classic.Level\n+import ch.qos.logback.classic.Logger\n+import ch.qos.logback.classic.util.ContextInitializer\n+import com.google.common.collect.Sets\n+import com.timgroup.statsd.StatsDClient\n+import datadog.trace.agent.test.asserts.ListWriterAssert\n+import datadog.trace.agent.tooling.AgentInstaller\n+import datadog.trace.agent.tooling.Instrumenter\n+import datadog.trace.agent.tooling.TracerInstaller\n+import datadog.trace.api.Config\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer.TracerAPI\n+import datadog.trace.common.writer.ListWriter\n+import datadog.trace.core.CoreTracer\n+import datadog.trace.core.DDSpan\n+import datadog.trace.core.PendingTrace\n+import datadog.trace.test.util.DDSpecification\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import net.bytebuddy.agent.builder.AgentBuilder\n+import net.bytebuddy.description.type.TypeDescription\n+import net.bytebuddy.dynamic.DynamicType\n+import net.bytebuddy.utility.JavaModule\n+import org.junit.runner.RunWith\n+import org.slf4j.LoggerFactory\n+import org.spockframework.mock.MockUtil\n+import spock.lang.Shared\n+\n+import java.lang.instrument.ClassFileTransformer\n+import java.lang.instrument.Instrumentation\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.TimeoutException\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.AdditionalLibraryIgnoresMatcher.additionalLibraryIgnoresMatcher\n+import static datadog.trace.api.IdGenerationStrategy.THREAD_PREFIX\n+\n+/**\n+ * A spock test runner which automatically applies instrumentation and exposes a global trace\n+ * writer.\n+ *\n+ * <p>To use, write a regular spock test, but extend this class instead of {@link\n+ * spock.lang.Specification}. <br>\n+ * This will cause the following to occur before test startup:\n+ *\n+ * <ul>\n+ *   <li>All {@link Instrumenter}s on the test classpath will be applied. Matching preloaded classes\n+ *       will be retransformed.\n+ *   <li>{@link AgentTestRunner#TEST_WRITER} will be registered with the global tracer and available\n+ *       in an initialized state.\n+ * </ul>\n+ */\n+// CodeNarc incorrectly thinks \".class\" is unnecessary in @RunWith\n+@SuppressWarnings('UnnecessaryDotClass')\n+@RunWith(SpockRunner.class)", "originalCommit": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ0NTM1Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549445357", "bodyText": "I'm not sure but compilation fails without it.\n/dd-java-agent/testing/build/tmp/compileGroovy/groovy-java-stubs/datadog/trace/agent/test/AgentTestRunner.java:12: error: cannot find symbol\n@java.lang.SuppressWarnings(value=\"UnnecessaryDotClass\") @org.junit.runner.RunWith(value=SpockRunner) public abstract class AgentTestRunner\n                                                                                         ^\n  symbol: variable SpockRunner\n1 error\nstartup failed:\nCompilation failed; see the compiler error output for details.\n\n1 error\n\n\nFAILURE: Build failed with an exception.", "author": "randomanderson", "createdAt": "2020-12-28T18:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQwOTQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxMDY0OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549410649", "bodyText": "Seems odd to call this again in setup() after the agent is initialized.", "author": "tylerbenson", "createdAt": "2020-12-28T16:40:24Z", "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.groovy", "diffHunk": "@@ -0,0 +1,263 @@\n+package datadog.trace.agent.test\n+\n+import ch.qos.logback.classic.Level\n+import ch.qos.logback.classic.Logger\n+import ch.qos.logback.classic.util.ContextInitializer\n+import com.google.common.collect.Sets\n+import com.timgroup.statsd.StatsDClient\n+import datadog.trace.agent.test.asserts.ListWriterAssert\n+import datadog.trace.agent.tooling.AgentInstaller\n+import datadog.trace.agent.tooling.Instrumenter\n+import datadog.trace.agent.tooling.TracerInstaller\n+import datadog.trace.api.Config\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer.TracerAPI\n+import datadog.trace.common.writer.ListWriter\n+import datadog.trace.core.CoreTracer\n+import datadog.trace.core.DDSpan\n+import datadog.trace.core.PendingTrace\n+import datadog.trace.test.util.DDSpecification\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import net.bytebuddy.agent.builder.AgentBuilder\n+import net.bytebuddy.description.type.TypeDescription\n+import net.bytebuddy.dynamic.DynamicType\n+import net.bytebuddy.utility.JavaModule\n+import org.junit.runner.RunWith\n+import org.slf4j.LoggerFactory\n+import org.spockframework.mock.MockUtil\n+import spock.lang.Shared\n+\n+import java.lang.instrument.ClassFileTransformer\n+import java.lang.instrument.Instrumentation\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.TimeoutException\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.AdditionalLibraryIgnoresMatcher.additionalLibraryIgnoresMatcher\n+import static datadog.trace.api.IdGenerationStrategy.THREAD_PREFIX\n+\n+/**\n+ * A spock test runner which automatically applies instrumentation and exposes a global trace\n+ * writer.\n+ *\n+ * <p>To use, write a regular spock test, but extend this class instead of {@link\n+ * spock.lang.Specification}. <br>\n+ * This will cause the following to occur before test startup:\n+ *\n+ * <ul>\n+ *   <li>All {@link Instrumenter}s on the test classpath will be applied. Matching preloaded classes\n+ *       will be retransformed.\n+ *   <li>{@link AgentTestRunner#TEST_WRITER} will be registered with the global tracer and available\n+ *       in an initialized state.\n+ * </ul>\n+ */\n+// CodeNarc incorrectly thinks \".class\" is unnecessary in @RunWith\n+@SuppressWarnings('UnnecessaryDotClass')\n+@RunWith(SpockRunner.class)\n+abstract class AgentTestRunner extends DDSpecification implements AgentBuilder.Listener {\n+  private static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10)\n+\n+  protected static final Instrumentation INSTRUMENTATION = ByteBuddyAgent.getInstrumentation()\n+\n+  static {\n+    configureLoggingLevels()\n+  }\n+\n+  /**\n+   * For test runs, agent's global tracer will report to this list writer.\n+   *\n+   * <p>Before the start of each test the reported traces will be reset.\n+   */\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  ListWriter TEST_WRITER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  TracerAPI TEST_TRACER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  StatsDClient STATS_D_CLIENT = Mock(StatsDClient)\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<String> TRANSFORMED_CLASSES_NAMES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<TypeDescription> TRANSFORMED_CLASSES_TYPES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  AtomicInteger INSTRUMENTATION_ERROR_COUNT = new AtomicInteger(0)\n+\n+  @Shared\n+  ClassFileTransformer activeTransformer\n+\n+  private static void configureLoggingLevels() {\n+    final Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)\n+    if (!rootLogger.iteratorForAppenders().hasNext()) {\n+      try {\n+        // previous test wiped out the logging config bring it back for the next test\n+        new ContextInitializer(rootLogger.getLoggerContext()).autoConfig()\n+      } catch (final Exception e) {\n+        e.printStackTrace()\n+      }\n+    }\n+\n+    rootLogger.setLevel(Level.WARN)\n+    ((Logger) LoggerFactory.getLogger(\"datadog\")).setLevel(Level.DEBUG)\n+  }\n+\n+  def setupSpec() {\n+    // If this fails, it's likely the result of another test loading Config before it can be\n+    // injected into the bootstrap classpath. If one test extends AgentTestRunner in a module, all tests must extend\n+    assert Config.getClassLoader() == null: \"Config must load on the bootstrap classpath.\"\n+\n+    configurePreAgent()\n+\n+    TEST_WRITER = new ListWriter()\n+    TEST_TRACER =\n+      CoreTracer.builder()\n+        .writer(TEST_WRITER)\n+        .idGenerationStrategy(THREAD_PREFIX)\n+        .statsDClient(STATS_D_CLIENT)\n+        .build()\n+    TracerInstaller.forceInstallGlobalTracer(TEST_TRACER)\n+\n+    assert ServiceLoader.load(Instrumenter, AgentTestRunner.getClassLoader())\n+      .iterator()\n+      .hasNext(): \"No instrumentation found\"\n+    activeTransformer = AgentInstaller.installBytebuddyAgent(INSTRUMENTATION, true, this)\n+  }\n+\n+  /** Override to set config before the agent is installed */\n+  protected void configurePreAgent() {}\n+\n+  def setup() {\n+    configureLoggingLevels()\n+\n+    assert TEST_TRACER.activeSpan() == null: \"Span is active before test has started: \" + TEST_TRACER.activeSpan()\n+\n+    configurePreAgent()", "originalCommit": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzODM3Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549438373", "bodyText": "Config is reset before each test.  If a property was set in configurePreAgent(), it would be gone by the second test.  The old code did this as well it was just less clear because the @Befores were scattered about the class.\nI'll add a comment", "author": "randomanderson", "createdAt": "2020-12-28T18:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxMDY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxMDk2MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549410960", "bodyText": "Why call this again here?", "author": "tylerbenson", "createdAt": "2020-12-28T16:41:27Z", "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.groovy", "diffHunk": "@@ -0,0 +1,263 @@\n+package datadog.trace.agent.test\n+\n+import ch.qos.logback.classic.Level\n+import ch.qos.logback.classic.Logger\n+import ch.qos.logback.classic.util.ContextInitializer\n+import com.google.common.collect.Sets\n+import com.timgroup.statsd.StatsDClient\n+import datadog.trace.agent.test.asserts.ListWriterAssert\n+import datadog.trace.agent.tooling.AgentInstaller\n+import datadog.trace.agent.tooling.Instrumenter\n+import datadog.trace.agent.tooling.TracerInstaller\n+import datadog.trace.api.Config\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer.TracerAPI\n+import datadog.trace.common.writer.ListWriter\n+import datadog.trace.core.CoreTracer\n+import datadog.trace.core.DDSpan\n+import datadog.trace.core.PendingTrace\n+import datadog.trace.test.util.DDSpecification\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import net.bytebuddy.agent.builder.AgentBuilder\n+import net.bytebuddy.description.type.TypeDescription\n+import net.bytebuddy.dynamic.DynamicType\n+import net.bytebuddy.utility.JavaModule\n+import org.junit.runner.RunWith\n+import org.slf4j.LoggerFactory\n+import org.spockframework.mock.MockUtil\n+import spock.lang.Shared\n+\n+import java.lang.instrument.ClassFileTransformer\n+import java.lang.instrument.Instrumentation\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.TimeoutException\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.AdditionalLibraryIgnoresMatcher.additionalLibraryIgnoresMatcher\n+import static datadog.trace.api.IdGenerationStrategy.THREAD_PREFIX\n+\n+/**\n+ * A spock test runner which automatically applies instrumentation and exposes a global trace\n+ * writer.\n+ *\n+ * <p>To use, write a regular spock test, but extend this class instead of {@link\n+ * spock.lang.Specification}. <br>\n+ * This will cause the following to occur before test startup:\n+ *\n+ * <ul>\n+ *   <li>All {@link Instrumenter}s on the test classpath will be applied. Matching preloaded classes\n+ *       will be retransformed.\n+ *   <li>{@link AgentTestRunner#TEST_WRITER} will be registered with the global tracer and available\n+ *       in an initialized state.\n+ * </ul>\n+ */\n+// CodeNarc incorrectly thinks \".class\" is unnecessary in @RunWith\n+@SuppressWarnings('UnnecessaryDotClass')\n+@RunWith(SpockRunner.class)\n+abstract class AgentTestRunner extends DDSpecification implements AgentBuilder.Listener {\n+  private static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10)\n+\n+  protected static final Instrumentation INSTRUMENTATION = ByteBuddyAgent.getInstrumentation()\n+\n+  static {\n+    configureLoggingLevels()\n+  }\n+\n+  /**\n+   * For test runs, agent's global tracer will report to this list writer.\n+   *\n+   * <p>Before the start of each test the reported traces will be reset.\n+   */\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  ListWriter TEST_WRITER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  TracerAPI TEST_TRACER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  StatsDClient STATS_D_CLIENT = Mock(StatsDClient)\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<String> TRANSFORMED_CLASSES_NAMES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<TypeDescription> TRANSFORMED_CLASSES_TYPES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  AtomicInteger INSTRUMENTATION_ERROR_COUNT = new AtomicInteger(0)\n+\n+  @Shared\n+  ClassFileTransformer activeTransformer\n+\n+  private static void configureLoggingLevels() {\n+    final Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)\n+    if (!rootLogger.iteratorForAppenders().hasNext()) {\n+      try {\n+        // previous test wiped out the logging config bring it back for the next test\n+        new ContextInitializer(rootLogger.getLoggerContext()).autoConfig()\n+      } catch (final Exception e) {\n+        e.printStackTrace()\n+      }\n+    }\n+\n+    rootLogger.setLevel(Level.WARN)\n+    ((Logger) LoggerFactory.getLogger(\"datadog\")).setLevel(Level.DEBUG)\n+  }\n+\n+  def setupSpec() {\n+    // If this fails, it's likely the result of another test loading Config before it can be\n+    // injected into the bootstrap classpath. If one test extends AgentTestRunner in a module, all tests must extend\n+    assert Config.getClassLoader() == null: \"Config must load on the bootstrap classpath.\"\n+\n+    configurePreAgent()\n+\n+    TEST_WRITER = new ListWriter()\n+    TEST_TRACER =\n+      CoreTracer.builder()\n+        .writer(TEST_WRITER)\n+        .idGenerationStrategy(THREAD_PREFIX)\n+        .statsDClient(STATS_D_CLIENT)\n+        .build()\n+    TracerInstaller.forceInstallGlobalTracer(TEST_TRACER)\n+\n+    assert ServiceLoader.load(Instrumenter, AgentTestRunner.getClassLoader())\n+      .iterator()\n+      .hasNext(): \"No instrumentation found\"\n+    activeTransformer = AgentInstaller.installBytebuddyAgent(INSTRUMENTATION, true, this)\n+  }\n+\n+  /** Override to set config before the agent is installed */\n+  protected void configurePreAgent() {}\n+\n+  def setup() {\n+    configureLoggingLevels()\n+\n+    assert TEST_TRACER.activeSpan() == null: \"Span is active before test has started: \" + TEST_TRACER.activeSpan()\n+\n+    configurePreAgent()\n+\n+    println \"Starting test: ${getSpecificationContext().getCurrentIteration().getName()}\"\n+\n+    TEST_TRACER.flush()\n+    TEST_WRITER.start()\n+\n+    new MockUtil().attachMock(STATS_D_CLIENT, this)\n+  }\n+\n+  void cleanup() {\n+    TEST_TRACER.flush()\n+    new MockUtil().attachMock(STATS_D_CLIENT, this)", "originalCommit": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ1MTQ5Ng==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549451496", "bodyText": "this is a bug, should be detach", "author": "randomanderson", "createdAt": "2020-12-28T18:51:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxMDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQxMTM5NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549411395", "bodyText": "Should the GlobalTracer be reset with a no-op instance before/after this is closed?", "author": "tylerbenson", "createdAt": "2020-12-28T16:42:58Z", "path": "dd-java-agent/testing/src/main/groovy/datadog/trace/agent/test/AgentTestRunner.groovy", "diffHunk": "@@ -0,0 +1,263 @@\n+package datadog.trace.agent.test\n+\n+import ch.qos.logback.classic.Level\n+import ch.qos.logback.classic.Logger\n+import ch.qos.logback.classic.util.ContextInitializer\n+import com.google.common.collect.Sets\n+import com.timgroup.statsd.StatsDClient\n+import datadog.trace.agent.test.asserts.ListWriterAssert\n+import datadog.trace.agent.tooling.AgentInstaller\n+import datadog.trace.agent.tooling.Instrumenter\n+import datadog.trace.agent.tooling.TracerInstaller\n+import datadog.trace.api.Config\n+import datadog.trace.bootstrap.instrumentation.api.AgentSpan\n+import datadog.trace.bootstrap.instrumentation.api.AgentTracer.TracerAPI\n+import datadog.trace.common.writer.ListWriter\n+import datadog.trace.core.CoreTracer\n+import datadog.trace.core.DDSpan\n+import datadog.trace.core.PendingTrace\n+import datadog.trace.test.util.DDSpecification\n+import groovy.transform.stc.ClosureParams\n+import groovy.transform.stc.SimpleType\n+import net.bytebuddy.agent.ByteBuddyAgent\n+import net.bytebuddy.agent.builder.AgentBuilder\n+import net.bytebuddy.description.type.TypeDescription\n+import net.bytebuddy.dynamic.DynamicType\n+import net.bytebuddy.utility.JavaModule\n+import org.junit.runner.RunWith\n+import org.slf4j.LoggerFactory\n+import org.spockframework.mock.MockUtil\n+import spock.lang.Shared\n+\n+import java.lang.instrument.ClassFileTransformer\n+import java.lang.instrument.Instrumentation\n+import java.util.concurrent.TimeUnit\n+import java.util.concurrent.TimeoutException\n+import java.util.concurrent.atomic.AtomicInteger\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.AdditionalLibraryIgnoresMatcher.additionalLibraryIgnoresMatcher\n+import static datadog.trace.api.IdGenerationStrategy.THREAD_PREFIX\n+\n+/**\n+ * A spock test runner which automatically applies instrumentation and exposes a global trace\n+ * writer.\n+ *\n+ * <p>To use, write a regular spock test, but extend this class instead of {@link\n+ * spock.lang.Specification}. <br>\n+ * This will cause the following to occur before test startup:\n+ *\n+ * <ul>\n+ *   <li>All {@link Instrumenter}s on the test classpath will be applied. Matching preloaded classes\n+ *       will be retransformed.\n+ *   <li>{@link AgentTestRunner#TEST_WRITER} will be registered with the global tracer and available\n+ *       in an initialized state.\n+ * </ul>\n+ */\n+// CodeNarc incorrectly thinks \".class\" is unnecessary in @RunWith\n+@SuppressWarnings('UnnecessaryDotClass')\n+@RunWith(SpockRunner.class)\n+abstract class AgentTestRunner extends DDSpecification implements AgentBuilder.Listener {\n+  private static final long TIMEOUT_MILLIS = TimeUnit.SECONDS.toMillis(10)\n+\n+  protected static final Instrumentation INSTRUMENTATION = ByteBuddyAgent.getInstrumentation()\n+\n+  static {\n+    configureLoggingLevels()\n+  }\n+\n+  /**\n+   * For test runs, agent's global tracer will report to this list writer.\n+   *\n+   * <p>Before the start of each test the reported traces will be reset.\n+   */\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  ListWriter TEST_WRITER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  TracerAPI TEST_TRACER\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  StatsDClient STATS_D_CLIENT = Mock(StatsDClient)\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<String> TRANSFORMED_CLASSES_NAMES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  Set<TypeDescription> TRANSFORMED_CLASSES_TYPES = Sets.newConcurrentHashSet()\n+\n+  @SuppressWarnings('PropertyName')\n+  @Shared\n+  AtomicInteger INSTRUMENTATION_ERROR_COUNT = new AtomicInteger(0)\n+\n+  @Shared\n+  ClassFileTransformer activeTransformer\n+\n+  private static void configureLoggingLevels() {\n+    final Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)\n+    if (!rootLogger.iteratorForAppenders().hasNext()) {\n+      try {\n+        // previous test wiped out the logging config bring it back for the next test\n+        new ContextInitializer(rootLogger.getLoggerContext()).autoConfig()\n+      } catch (final Exception e) {\n+        e.printStackTrace()\n+      }\n+    }\n+\n+    rootLogger.setLevel(Level.WARN)\n+    ((Logger) LoggerFactory.getLogger(\"datadog\")).setLevel(Level.DEBUG)\n+  }\n+\n+  def setupSpec() {\n+    // If this fails, it's likely the result of another test loading Config before it can be\n+    // injected into the bootstrap classpath. If one test extends AgentTestRunner in a module, all tests must extend\n+    assert Config.getClassLoader() == null: \"Config must load on the bootstrap classpath.\"\n+\n+    configurePreAgent()\n+\n+    TEST_WRITER = new ListWriter()\n+    TEST_TRACER =\n+      CoreTracer.builder()\n+        .writer(TEST_WRITER)\n+        .idGenerationStrategy(THREAD_PREFIX)\n+        .statsDClient(STATS_D_CLIENT)\n+        .build()\n+    TracerInstaller.forceInstallGlobalTracer(TEST_TRACER)\n+\n+    assert ServiceLoader.load(Instrumenter, AgentTestRunner.getClassLoader())\n+      .iterator()\n+      .hasNext(): \"No instrumentation found\"\n+    activeTransformer = AgentInstaller.installBytebuddyAgent(INSTRUMENTATION, true, this)\n+  }\n+\n+  /** Override to set config before the agent is installed */\n+  protected void configurePreAgent() {}\n+\n+  def setup() {\n+    configureLoggingLevels()\n+\n+    assert TEST_TRACER.activeSpan() == null: \"Span is active before test has started: \" + TEST_TRACER.activeSpan()\n+\n+    configurePreAgent()\n+\n+    println \"Starting test: ${getSpecificationContext().getCurrentIteration().getName()}\"\n+\n+    TEST_TRACER.flush()\n+    TEST_WRITER.start()\n+\n+    new MockUtil().attachMock(STATS_D_CLIENT, this)\n+  }\n+\n+  void cleanup() {\n+    TEST_TRACER.flush()\n+    new MockUtil().attachMock(STATS_D_CLIENT, this)\n+  }\n+\n+  /** Override to clean up things after the agent is removed */\n+  protected void cleanupAfterAgent() {}\n+\n+  def cleanupSpec() {\n+    TEST_TRACER?.close()", "originalCommit": "28a4be28deac23da5b3dfc32ddb85e83934e2e86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0607b0a76b7d5008643b6bd9c7af8f503b40031b", "url": "https://github.com/DataDog/dd-trace-java/commit/0607b0a76b7d5008643b6bd9c7af8f503b40031b", "message": "PR feedback", "committedDate": "2020-12-28T18:52:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2Mjg3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2235#discussion_r549762879", "bodyText": "This is not suppose to be public api, right? Maybe comment", "author": "lpriima", "createdAt": "2020-12-29T16:15:31Z", "path": "dd-trace-api/src/main/java/datadog/trace/api/GlobalTracer.java", "diffHunk": "@@ -31,50 +32,52 @@ public boolean addTraceInterceptor(TraceInterceptor traceInterceptor) {\n         @Override\n         public void addScopeListener(ScopeListener listener) {}\n       };\n-  private static final AtomicReference<Tracer> provider = new AtomicReference<>(NO_OP);\n+\n+  private static final Collection<Callback> installationCallbacks = new ArrayList<>();\n+  private static Tracer provider = NO_OP;\n \n   public static void registerIfAbsent(Tracer p) {\n-    if (p != null && p != NO_OP) {\n-      boolean installed = provider.compareAndSet(NO_OP, p);\n-      if (installed) {\n-        Callback callback = installationCallback.getAndSet(null);\n-        if (callback != null) {\n+    if (p == null || p == NO_OP) {\n+      throw new IllegalArgumentException();\n+    }\n+\n+    synchronized (installationCallbacks) {\n+      if (provider == NO_OP) {\n+        provider = p;\n+        for (Callback callback : installationCallbacks) {\n           callback.installed(p);\n         }\n       }\n     }\n   }\n \n+  public static void forceRegister(Tracer tracer) {", "originalCommit": "0607b0a76b7d5008643b6bd9c7af8f503b40031b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}