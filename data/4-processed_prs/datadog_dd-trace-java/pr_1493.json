{"pr_number": 1493, "pr_title": "Allow traces to be reported if continuations are GC'd before activation.", "pr_createdAt": "2020-05-22T19:39:03Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/1493", "timeline": [{"oid": "7a5e58ea4e40b7ea6b5f6774ca09efeae8d67b30", "url": "https://github.com/DataDog/dd-trace-java/commit/7a5e58ea4e40b7ea6b5f6774ca09efeae8d67b30", "message": "Allow traces to be reported if continuations are GC'd before activation.\n\nSplit up tracking between spans and continuations for better logging.\nRestructure the logs for better consistency.", "committedDate": "2020-05-22T19:38:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNTQ3OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1493#discussion_r429425479", "bodyText": "This is the main change.", "author": "tylerbenson", "createdAt": "2020-05-22T19:41:51Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -249,8 +260,18 @@ private synchronized void write() {\n   public synchronized boolean clean() {\n     Reference ref;\n     int count = 0;\n-    while ((ref = referenceQueue.poll()) != null) {\n-      weakReferences.remove(ref);\n+    while ((ref = continuationReferenceQueue.poll()) != null) {\n+      weakContinuations.remove(ref);\n+      count++;\n+      expireReference();\n+    }\n+    if (count > 0) {\n+      log.debug(\"t_id={} -> {} unfinished continuations garbage collected.\", traceId, count);\n+    }\n+\n+    count = 0;\n+    while ((ref = spanReferenceQueue.poll()) != null) {\n+      weakSpans.remove(ref);", "originalCommit": "7a5e58ea4e40b7ea6b5f6774ca09efeae8d67b30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNTY1Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/1493#discussion_r429425652", "bodyText": "I did confirm this test failed without my change.", "author": "tylerbenson", "createdAt": "2020-05-22T19:42:20Z", "path": "dd-trace-core/src/test/groovy/datadog/trace/core/PendingTraceTest.groovy", "diffHunk": "@@ -119,20 +121,51 @@ class PendingTraceTest extends DDSpecification {\n \n     then:\n     trace.pendingReferenceCount.get() == 0\n-    trace.weakReferences.size() == 0\n+    trace.weakSpans.size() == 0\n     trace.asList() == [rootSpan]\n     writer == []\n     writer.traceCount.get() == 1\n     !PendingTrace.SPAN_CLEANER.get().pendingTraces.contains(trace)\n   }\n \n+  @Timeout(value = 60, unit = TimeUnit.SECONDS)\n+  def \"trace is still reported when unfinished continuation discarded\"() {", "originalCommit": "7a5e58ea4e40b7ea6b5f6774ca09efeae8d67b30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "85a3bd61cc0fb446404edf67e79eff4919c53c08", "url": "https://github.com/DataDog/dd-trace-java/commit/85a3bd61cc0fb446404edf67e79eff4919c53c08", "message": "More logging improvements", "committedDate": "2020-05-22T20:02:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzNzQ1NA==", "url": "https://github.com/DataDog/dd-trace-java/pull/1493#discussion_r429437454", "bodyText": "Instead of using a second reference queue, could we write the trace when all spans are finished?", "author": "devinsba", "createdAt": "2020-05-22T20:20:52Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/PendingTrace.java", "diffHunk": "@@ -44,9 +44,13 @@ static PendingTrace create(final CoreTracer tracer, final BigInteger traceId) {\n   /** Nano second ticks value at trace start */\n   private final long startNanoTicks;\n \n-  private final ReferenceQueue referenceQueue = new ReferenceQueue();\n-  private final Set<WeakReference<?>> weakReferences =\n-      Collections.newSetFromMap(new ConcurrentHashMap<WeakReference<?>, Boolean>());\n+  private final ReferenceQueue spanReferenceQueue = new ReferenceQueue();", "originalCommit": "85a3bd61cc0fb446404edf67e79eff4919c53c08", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MTkwNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1493#discussion_r429451905", "bodyText": "Yes, that would be simpler.  That's effectively our current semantic guarantee anyway.", "author": "dougqh", "createdAt": "2020-05-22T21:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzNzQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NTQ3NQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/1493#discussion_r429455475", "bodyText": "The problem is, we may have spans added to an existing trace even after all other spans are complete.", "author": "tylerbenson", "createdAt": "2020-05-22T21:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzNzQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ5NDExMw==", "url": "https://github.com/DataDog/dd-trace-java/pull/1493#discussion_r430494113", "bodyText": "I know this is already merged but I don't think that any spans that start after the root span tree has finished should semantically block reporting of the trace. Its possible there are cases that this isn't true, queue consumption maybe, but I think in the case of http/rpc once the root span tree is finished we should be ok to report", "author": "devinsba", "createdAt": "2020-05-26T15:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzNzQ1NA=="}], "type": "inlineReview"}]}