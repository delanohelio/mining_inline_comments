{"pr_number": 2021, "pr_title": "pass executed Runnables through AbstractExecutorService.newTaskFor to get free context propagation", "pr_createdAt": "2020-10-22T10:50:25Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2021", "timeline": [{"oid": "e4d1a8feaa70c20967ac9dc69d59e8d242cc4928", "url": "https://github.com/DataDog/dd-trace-java/commit/e4d1a8feaa70c20967ac9dc69d59e8d242cc4928", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T11:26:59Z", "type": "forcePushed"}, {"oid": "bfd7f28677733623a72e7dc3403d15259b44d970", "url": "https://github.com/DataDog/dd-trace-java/commit/bfd7f28677733623a72e7dc3403d15259b44d970", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T11:41:20Z", "type": "forcePushed"}, {"oid": "e182673e9a4c23a60eccd15a8370a7b1c44b6748", "url": "https://github.com/DataDog/dd-trace-java/commit/e182673e9a4c23a60eccd15a8370a7b1c44b6748", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T12:27:10Z", "type": "forcePushed"}, {"oid": "577040a459fca81bc29073c210e62fbec2d5b95d", "url": "https://github.com/DataDog/dd-trace-java/commit/577040a459fca81bc29073c210e62fbec2d5b95d", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T13:56:36Z", "type": "forcePushed"}, {"oid": "e9889de877b2e1895830079e7901421e6bbcc3fe", "url": "https://github.com/DataDog/dd-trace-java/commit/e9889de877b2e1895830079e7901421e6bbcc3fe", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T14:59:44Z", "type": "forcePushed"}, {"oid": "8db05f62bd6e11536febcf5d6c912abaa480a8c3", "url": "https://github.com/DataDog/dd-trace-java/commit/8db05f62bd6e11536febcf5d6c912abaa480a8c3", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T15:29:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3MzQxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510273412", "bodyText": "Excellent!", "author": "bantonsson", "createdAt": "2020-10-22T15:52:58Z", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.NameMatchers.namedOneOf;\n+import static datadog.trace.instrumentation.java.concurrent.NewTaskFor.newTaskFor;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public final class WrapRunnableAsNewTaskInstrumentation extends Instrumenter.Default {\n+  public WrapRunnableAsNewTaskInstrumentation() {\n+    super(\"java_concurrent\", \"new-task-for\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return namedOneOf(\n+        \"io.netty.channel.epoll.EpollEventLoop\",\n+        \"io.netty.channel.epoll.EpollEventLoopGroup\",\n+        \"io.netty.channel.MultithreadEventLoopGroup\",\n+        \"io.netty.channel.nio.NioEventLoop\",\n+        \"io.netty.channel.nio.NioEventLoopGroup\",\n+        \"io.netty.channel.SingleThreadEventLoop\",\n+        \"io.netty.util.concurrent.AbstractEventExecutor\",\n+        \"io.netty.util.concurrent.AbstractEventExecutorGroup\",\n+        \"io.netty.util.concurrent.AbstractScheduledEventExecutor\",\n+        \"io.netty.util.concurrent.DefaultEventExecutor\",\n+        \"io.netty.util.concurrent.DefaultEventExecutorGroup\",\n+        \"io.netty.util.concurrent.GlobalEventExecutor\",\n+        \"io.netty.util.concurrent.MultithreadEventExecutorGroup\",\n+        \"io.netty.util.concurrent.SingleThreadEventExecutor\",\n+        \"java.util.concurrent.AbstractExecutorService\",\n+        \"java.util.concurrent.CompletableFuture$ThreadPerTaskExecutor\",\n+        \"java.util.concurrent.SubmissionPublisher$ThreadPerTaskExecutor\",\n+        \"java.util.concurrent.ThreadPoolExecutor\",\n+        \"org.glassfish.grizzly.threadpool.GrizzlyExecutorService\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {packageName + \".NewTaskFor\"};\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(\n+                named(\"execute\")\n+                    .and(ElementMatchers.takesArgument(0, named(Runnable.class.getName())))),\n+        getClass().getName() + \"$Wrap\");\n+  }\n+\n+  public static final class Wrap {\n+    @Advice.OnMethodEnter\n+    public static void execute(\n+        @Advice.This Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      task = newTaskFor(executor, task);", "originalCommit": "8db05f62bd6e11536febcf5d6c912abaa480a8c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3NzQ4OQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510277489", "bodyText": "Returning the favor, this looks like the same pattern that you suggested ClassValue for", "author": "devinsba", "createdAt": "2020-10-22T15:58:25Z", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType.RUNNABLE;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.exclude;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.AbstractExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class NewTaskFor {\n+\n+  private static final Method NEW_TASK_FOR_RUNNABLE = lookupNewTaskForRunnable();\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Runnable newTaskFor(Executor executor, Runnable runnable) {\n+    // TODO write a slick instrumentation and instrument these types directly\n+    if (runnable instanceof RunnableFuture\n+        || exclude(RUNNABLE, runnable)\n+        || runnable.getClass().getName().startsWith(\"slick.\")) {", "originalCommit": "8db05f62bd6e11536febcf5d6c912abaa480a8c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI4MDIzOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510280238", "bodyText": "It's a bit different because we don't know how many distinct types of Runnable an executor will see - in clojure this could be every loaded class - whereas the other case was a library type with (I believe) relatively few implementations. In any case, this is temporary, because I will start work on a slick-specific instrumentation soon.", "author": "richardstartin", "createdAt": "2020-10-22T16:02:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3NzQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDI3OTUxMg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510279512", "bodyText": "getDeclaredMethod and setAccessible can also throw SecurityException so I'd include that in the catch", "author": "mcculls", "createdAt": "2020-10-22T16:01:04Z", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType.RUNNABLE;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.exclude;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.AbstractExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class NewTaskFor {\n+\n+  private static final Method NEW_TASK_FOR_RUNNABLE = lookupNewTaskForRunnable();\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public static Runnable newTaskFor(Executor executor, Runnable runnable) {\n+    // TODO write a slick instrumentation and instrument these types directly\n+    if (runnable instanceof RunnableFuture\n+        || exclude(RUNNABLE, runnable)\n+        || runnable.getClass().getName().startsWith(\"slick.\")) {\n+      return runnable;\n+    }\n+    if (null != NEW_TASK_FOR_RUNNABLE && executor instanceof AbstractExecutorService) {\n+      try {\n+        return (RunnableFuture<Void>) NEW_TASK_FOR_RUNNABLE.invoke(executor, runnable, null);\n+      } catch (Throwable t) {\n+        log.debug(\"failed to invoke newTaskFor on {}\", executor, t);\n+      }\n+    }\n+    return new FutureTask<>(runnable, null);\n+  }\n+\n+  private static Method lookupNewTaskForRunnable() {\n+    try {\n+      Method newTaskFor =\n+          AbstractExecutorService.class.getDeclaredMethod(\n+              \"newTaskFor\", Runnable.class, Object.class);\n+      newTaskFor.setAccessible(true);\n+      return newTaskFor;\n+    } catch (NoSuchMethodException e) {", "originalCommit": "8db05f62bd6e11536febcf5d6c912abaa480a8c3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "20d65da5cb280c34ef31627561160883c6a32cc1", "url": "https://github.com/DataDog/dd-trace-java/commit/20d65da5cb280c34ef31627561160883c6a32cc1", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T16:09:15Z", "type": "forcePushed"}, {"oid": "fb45dc21105146a489f7fe23dd6f7ccd543c73e7", "url": "https://github.com/DataDog/dd-trace-java/commit/fb45dc21105146a489f7fe23dd6f7ccd543c73e7", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T16:43:46Z", "type": "forcePushed"}, {"oid": "de02353661ea32ca4d0e7298ca17c6977958fd88", "url": "https://github.com/DataDog/dd-trace-java/commit/de02353661ea32ca4d0e7298ca17c6977958fd88", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T17:34:05Z", "type": "forcePushed"}, {"oid": "ca78561ec061a839207cb37b8f01a91ac58809c6", "url": "https://github.com/DataDog/dd-trace-java/commit/ca78561ec061a839207cb37b8f01a91ac58809c6", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T18:23:23Z", "type": "commit"}, {"oid": "ca78561ec061a839207cb37b8f01a91ac58809c6", "url": "https://github.com/DataDog/dd-trace-java/commit/ca78561ec061a839207cb37b8f01a91ac58809c6", "message": "wrap executed Runnables in FutureTask to get free context-propagation", "committedDate": "2020-10-22T18:23:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyODI5Nw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510428297", "bodyText": "I'm having a hard time understanding when to use Method and when to use Method Handles.  Why use one over the other?", "author": "tylerbenson", "createdAt": "2020-10-22T20:11:42Z", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/NewTaskFor.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.ExcludeType.RUNNABLE;\n+import static datadog.trace.bootstrap.instrumentation.java.concurrent.ExcludeFilter.exclude;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.AbstractExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.RunnableFuture;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public final class NewTaskFor {\n+\n+  private static final boolean SAFE_TO_PROPAGATE;\n+  private static final Method NEW_TASK_FOR_RUNNABLE;", "originalCommit": "ca78561ec061a839207cb37b8f01a91ac58809c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyOTY0MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510429641", "bodyText": "Ah, I think I get it... Here you must use reflection because newTaskFor is not accessible, so you can't use Method Handles or call it directly.", "author": "tylerbenson", "createdAt": "2020-10-22T20:14:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyODI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3MjY4OA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510672688", "bodyText": "Yes, exactly. We could unreflect the method to get a MethodHandle, but then we need to use invokeWithArguments and would have no benefit over just using reflection.", "author": "richardstartin", "createdAt": "2020-10-23T06:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQyODI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MzcwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510443700", "bodyText": "I think a class comment describing the benefits of this approach would be useful for posterity.", "author": "tylerbenson", "createdAt": "2020-10-22T20:41:15Z", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.NameMatchers.namedOneOf;\n+import static datadog.trace.instrumentation.java.concurrent.NewTaskFor.newTaskFor;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public final class WrapRunnableAsNewTaskInstrumentation extends Instrumenter.Default {", "originalCommit": "ca78561ec061a839207cb37b8f01a91ac58809c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MzIwNQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510453205", "bodyText": "In the future, it might be possible to replace this with a direct method call:\nraphw/byte-buddy#484\nMeanwhile, you may be able to avoid the reflection with MemberSubstitution raphw/byte-buddy#483", "author": "tylerbenson", "createdAt": "2020-10-22T20:58:52Z", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package datadog.trace.instrumentation.java.concurrent;\n+\n+import static datadog.trace.agent.tooling.bytebuddy.matcher.NameMatchers.namedOneOf;\n+import static datadog.trace.instrumentation.java.concurrent.NewTaskFor.newTaskFor;\n+import static java.util.Collections.singletonMap;\n+import static net.bytebuddy.matcher.ElementMatchers.isMethod;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+import com.google.auto.service.AutoService;\n+import datadog.trace.agent.tooling.Instrumenter;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+@AutoService(Instrumenter.class)\n+public final class WrapRunnableAsNewTaskInstrumentation extends Instrumenter.Default {\n+  public WrapRunnableAsNewTaskInstrumentation() {\n+    super(\"java_concurrent\", \"new-task-for\");\n+  }\n+\n+  @Override\n+  public ElementMatcher<? super TypeDescription> typeMatcher() {\n+    return namedOneOf(\n+        \"io.netty.channel.epoll.EpollEventLoop\",\n+        \"io.netty.channel.epoll.EpollEventLoopGroup\",\n+        \"io.netty.channel.MultithreadEventLoopGroup\",\n+        \"io.netty.channel.nio.NioEventLoop\",\n+        \"io.netty.channel.nio.NioEventLoopGroup\",\n+        \"io.netty.channel.SingleThreadEventLoop\",\n+        \"io.netty.util.concurrent.AbstractEventExecutor\",\n+        \"io.netty.util.concurrent.AbstractEventExecutorGroup\",\n+        \"io.netty.util.concurrent.AbstractScheduledEventExecutor\",\n+        \"io.netty.util.concurrent.DefaultEventExecutor\",\n+        \"io.netty.util.concurrent.DefaultEventExecutorGroup\",\n+        \"io.netty.util.concurrent.GlobalEventExecutor\",\n+        \"io.netty.util.concurrent.MultithreadEventExecutorGroup\",\n+        \"io.netty.util.concurrent.SingleThreadEventExecutor\",\n+        \"java.util.concurrent.AbstractExecutorService\",\n+        \"java.util.concurrent.CompletableFuture$ThreadPerTaskExecutor\",\n+        \"java.util.concurrent.SubmissionPublisher$ThreadPerTaskExecutor\",\n+        \"java.util.concurrent.ThreadPoolExecutor\",\n+        \"org.glassfish.grizzly.threadpool.GrizzlyExecutorService\");\n+  }\n+\n+  @Override\n+  public String[] helperClassNames() {\n+    return new String[] {packageName + \".NewTaskFor\"};\n+  }\n+\n+  @Override\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    return singletonMap(\n+        isMethod()\n+            .and(\n+                named(\"execute\")\n+                    .and(ElementMatchers.takesArgument(0, named(Runnable.class.getName())))),\n+        getClass().getName() + \"$Wrap\");\n+  }\n+\n+  public static final class Wrap {\n+    @Advice.OnMethodEnter\n+    public static void execute(\n+        @Advice.This Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      task = newTaskFor(executor, task);", "originalCommit": "ca78561ec061a839207cb37b8f01a91ac58809c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3MzM3MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2021#discussion_r510673370", "bodyText": "I will look into using MemberSubstitution here, but we'd need reorganise things a bit to be able to do it without action-at-a-distance dependencies, so I'll do it as part of a PR to make that possible in a sensible way.", "author": "richardstartin", "createdAt": "2020-10-23T06:57:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ1MzIwNQ=="}], "type": "inlineReview"}]}