{"pr_number": 2199, "pr_title": "Avoid WARNING: Illegal reflective access by datadog.trace.instrumentation.java.concurrent.NewTaskFor", "pr_createdAt": "2020-12-14T12:05:40Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2199", "timeline": [{"oid": "d1fcc83c166fe9bd49fc5fa49a7e7d73b99e6c6b", "url": "https://github.com/DataDog/dd-trace-java/commit/d1fcc83c166fe9bd49fc5fa49a7e7d73b99e6c6b", "message": "Merge NewTaskFor with WrapRunnableAsNewTaskInstrumentation by using a placeholder 'newTaskFor' call.\nThe placeholder call in the advice will be rewritten to call the real 'newTaskFor' at build time.\n\nNote: once the 'NewTaskFor' advice has been rewritten it can only be applied to executors that extend\nAbstractExecutorService otherwise we get class verification errors at load time. For other executors\nwe apply a simpler wrapper that avoids 'newTaskFor'. This results in a bit of duplication but that's\ntolerated as it means we can avoid having to inject helpers onto the bootclasspath.", "committedDate": "2020-12-14T11:52:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzOTk4Mg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2199#discussion_r542339982", "bodyText": "You probably don't need this at all if you get rid of the netty executors which don't extend AbstractExecutorService i.e. the executor groups. They always delegate anyway, so everything should work fine.", "author": "richardstartin", "createdAt": "2020-12-14T12:17:57Z", "path": "dd-java-agent/instrumentation/java-concurrent/src/main/java/datadog/trace/instrumentation/java/concurrent/WrapRunnableAsNewTaskInstrumentation.java", "diffHunk": "@@ -48,29 +57,82 @@ public WrapRunnableAsNewTaskInstrumentation() {\n   }\n \n   @Override\n-  public String[] helperClassNames() {\n-    return new String[] {packageName + \".NewTaskFor\"};\n+  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n+    Map<ElementMatcher<MethodDescription>, String> transformers = new HashMap<>();\n+\n+    Junction<MethodDescription> hasExecute =\n+        isMethod().and(named(\"execute\").and(takesArgument(0, named(Runnable.class.getName()))));\n+\n+    Junction<MethodDescription> hasNewTaskFor =\n+        isDeclaredBy(extendsClass(named(\"java.util.concurrent.AbstractExecutorService\")));\n+\n+    // executors that extend AbstractExecutorService should use 'newTaskFor' wrapper\n+    transformers.put(hasExecute.and(hasNewTaskFor), getClass().getName() + \"$NewTaskFor\");\n+\n+    // use simple wrapper for executors that don't extend AbstractExecutorService\n+    transformers.put(hasExecute.and(not(hasNewTaskFor)), getClass().getName() + \"$Wrap\");\n+\n+    return transformers;\n   }\n \n-  @Override\n-  public Map<? extends ElementMatcher<? super MethodDescription>, String> transformers() {\n-    return singletonMap(\n-        isMethod()\n-            .and(\n-                named(\"execute\")\n-                    .and(ElementMatchers.takesArgument(0, named(Runnable.class.getName())))),\n-        getClass().getName() + \"$Wrap\");\n+  // We tolerate a bit of duplication between these advice classes because\n+  // it avoids having to inject other helper classes onto the bootclasspath\n+\n+  /**\n+   * Wrapper that uses {@link AbstractExecutorService#newTaskFor}.\n+   *\n+   * <p>The placeholder 'newTaskFor' is rewritten at build time to call the real method (which has\n+   * protected access so javac won't let us call it here directly). Once rewritten this advice can\n+   * only be applied to types that extend {@link AbstractExecutorService} otherwise we'll get class\n+   * verification errors about this call in the transformed executor.\n+   */\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+  public static final class NewTaskFor {\n+    @Advice.OnMethodEnter\n+    public static void execute(\n+        @Advice.This Executor executor,\n+        @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n+      // TODO write a slick instrumentation and instrument these types directly\n+      if (task instanceof RunnableFuture\n+          || null == task\n+          || exclude(RUNNABLE, task)\n+          || task.getClass().getName().startsWith(\"slick.\")) {\n+        // no wrapping required\n+      } else if (task instanceof Comparable) {\n+        task = new ComparableRunnable(task);\n+      } else {\n+        task = NewTaskForPlaceholder.newTaskFor(executor, task, null);\n+      }\n+    }\n+\n+    @Advice.OnMethodExit(onThrowable = Throwable.class)\n+    public static void cancel(@Advice.Argument(0) Runnable task, @Advice.Thrown Throwable error) {\n+      if (null != error && task instanceof RunnableFuture) {\n+        ((RunnableFuture) task).cancel(true);\n+      }\n+    }\n   }\n \n+  /** More general wrapper that uses {@link FutureTask} instead of calling 'newTaskFor'. */\n+  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n   public static final class Wrap {\n     @Advice.OnMethodEnter\n     public static void execute(\n         @Advice.This Executor executor,\n         @Advice.Argument(value = 0, readOnly = false) Runnable task) {\n-      task = newTaskFor(executor, task);\n+      // TODO write a slick instrumentation and instrument these types directly", "originalCommit": "d1fcc83c166fe9bd49fc5fa49a7e7d73b99e6c6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0MzUwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2199#discussion_r542443500", "bodyText": "I assume it's also safe to remove:\njava.util.concurrent.CompletableFuture$ThreadPerTaskExecutor\njava.util.concurrent.SubmissionPublisher$ThreadPerTaskExecutor\n\nsince they don't extend AbstractExecutorService, they just call new Thread(task)", "author": "mcculls", "createdAt": "2020-12-14T14:50:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzOTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0NTAzMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2199#discussion_r542445030", "bodyText": "actually I guess those will need to stay, because they don't end up delegating to AbstractExecutorService", "author": "mcculls", "createdAt": "2020-12-14T14:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzOTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQ0NzUyNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2199#discussion_r542447527", "bodyText": "We only need java.util.concurrent.CompletableFuture$ThreadPerTaskExecutor because we have an isolated test for it - we should rely on the CompletableFuture instrumentation instead. I'm not that familiar with java.util.concurrent.SubmissionPublisher$ThreadPerTaskExecutor - so it may be the justification for this extra instrumentation.", "author": "richardstartin", "createdAt": "2020-12-14T14:56:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzOTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjUyMTQwMA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2199#discussion_r542521400", "bodyText": "For future reference after this PR is merged: We should not be instrumenting either of these executors.\n\njava.util.concurrent.CompletableFuture$ThreadPerTaskExecutor should defer to the CompletableFuture instrumentation\njava.util.concurrent.SubmissionPublisher$ThreadPerTaskExecutor should defer to a new java.util.concurrent.SubmissionPublisher$ConsumerTask instrumentation which would track the ConsumerTasks lifecycle.", "author": "richardstartin", "createdAt": "2020-12-14T16:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjMzOTk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0NDE1MA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2199#discussion_r542344150", "bodyText": "I think we should aim to do more at build time \ud83d\udc4d\ud83c\udffb", "author": "richardstartin", "createdAt": "2020-12-14T12:25:30Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/NewTaskForGradlePlugin.java", "diffHunk": "@@ -0,0 +1,30 @@\n+package datadog.trace.agent.tooling.bytebuddy;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.nameEndsWith;\n+\n+import java.io.IOException;\n+import net.bytebuddy.build.Plugin;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.dynamic.ClassFileLocator;\n+import net.bytebuddy.dynamic.DynamicType;\n+\n+/**\n+ * Bytebuddy gradle plugin which rewrites placeholder calls in 'NewTaskFor' advice at build time.\n+ */\n+public class NewTaskForGradlePlugin extends Plugin.ForElementMatcher {", "originalCommit": "d1fcc83c166fe9bd49fc5fa49a7e7d73b99e6c6b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjQzMzI1Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2199#discussion_r542433253", "bodyText": "Agreed", "author": "dougqh", "createdAt": "2020-12-14T14:37:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0NDE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjM0NDkwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2199#discussion_r542344908", "bodyText": "This is neat (now I've found the logic amongst all those final keywords)", "author": "richardstartin", "createdAt": "2020-12-14T12:26:49Z", "path": "dd-java-agent/agent-tooling/src/main/java/datadog/trace/agent/tooling/bytebuddy/NewTaskForRewritingVisitor.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package datadog.trace.agent.tooling.bytebuddy;\n+\n+import datadog.trace.agent.tooling.Utils;\n+import datadog.trace.bootstrap.instrumentation.java.concurrent.NewTaskForPlaceholder;\n+import java.util.concurrent.RunnableFuture;\n+import net.bytebuddy.asm.AsmVisitorWrapper;\n+import net.bytebuddy.description.field.FieldDescription;\n+import net.bytebuddy.description.field.FieldList;\n+import net.bytebuddy.description.method.MethodList;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.Implementation;\n+import net.bytebuddy.jar.asm.ClassVisitor;\n+import net.bytebuddy.jar.asm.ClassWriter;\n+import net.bytebuddy.jar.asm.MethodVisitor;\n+import net.bytebuddy.jar.asm.Opcodes;\n+import net.bytebuddy.jar.asm.Type;\n+import net.bytebuddy.pool.TypePool;\n+\n+/**\n+ * ASM visitor which rewrites placeholder 'newTaskFor' calls at build time to use the real method.\n+ */\n+public final class NewTaskForRewritingVisitor implements AsmVisitorWrapper {\n+  static final NewTaskForRewritingVisitor INSTANCE = new NewTaskForRewritingVisitor();\n+\n+  static final String NEW_TASK_FOR_PLACEHOLDER_CLASS =\n+      Utils.getInternalName(NewTaskForPlaceholder.class.getName());\n+\n+  static final String ABSTRACT_EXECUTOR_SERVICE_CLASS =\n+      \"java/util/concurrent/AbstractExecutorService\";\n+\n+  static final String NEW_TASK_FOR_METHOD = \"newTaskFor\";\n+\n+  static final String NEW_TASK_FOR_METHOD_DESCRIPTOR =\n+      Type.getMethodDescriptor(\n+          Type.getType(RunnableFuture.class),\n+          Type.getType(Runnable.class),\n+          Type.getType(Object.class));\n+\n+  @Override\n+  public int mergeWriter(final int flags) {\n+    return flags | ClassWriter.COMPUTE_MAXS;\n+  }\n+\n+  @Override\n+  public int mergeReader(final int flags) {\n+    return flags;\n+  }\n+\n+  @Override\n+  public ClassVisitor wrap(\n+      final TypeDescription instrumentedType,\n+      final ClassVisitor classVisitor,\n+      final Implementation.Context implementationContext,\n+      final TypePool typePool,\n+      final FieldList<FieldDescription.InDefinedShape> fields,\n+      final MethodList<?> methods,\n+      final int writerFlags,\n+      final int readerFlags) {\n+    return new ClassVisitor(Opcodes.ASM7, classVisitor) {\n+      @Override\n+      public MethodVisitor visitMethod(\n+          final int access,\n+          final String name,\n+          final String descriptor,\n+          final String signature,\n+          final String[] exceptions) {\n+        final MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);\n+        return new MethodVisitor(Opcodes.ASM7, mv) {\n+          @Override\n+          public void visitMethodInsn(\n+              final int opcode,\n+              final String owner,\n+              final String name,\n+              final String descriptor,\n+              final boolean isInterface) {\n+            // NewTaskForPlaceholder.newTaskFor(e,task,value) -> e.newTaskFor(task,value)\n+            if (Opcodes.INVOKESTATIC == opcode", "originalCommit": "d1fcc83c166fe9bd49fc5fa49a7e7d73b99e6c6b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3c56d6aeaf5f64efca2cbbbf59cd4ea12b516da5", "url": "https://github.com/DataDog/dd-trace-java/commit/3c56d6aeaf5f64efca2cbbbf59cd4ea12b516da5", "message": "Remove Netty executor groups from instrumentation because they eventually delegate to an executor that does extend AbstractExecutorService", "committedDate": "2020-12-14T14:56:38Z", "type": "commit"}]}