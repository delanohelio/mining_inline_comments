{"pr_number": 2049, "pr_title": "implement protobuf writer, refactor msgpack serialisation to reuse code", "pr_createdAt": "2020-11-04T12:24:27Z", "pr_url": "https://github.com/DataDog/dd-trace-java/pull/2049", "timeline": [{"oid": "a4b50828a43dcc9d548c55c99e2cb6a82371e3ff", "url": "https://github.com/DataDog/dd-trace-java/commit/a4b50828a43dcc9d548c55c99e2cb6a82371e3ff", "message": "implement protobuf writer, refactor msgpack serialisation to reuse code", "committedDate": "2020-11-04T13:43:55Z", "type": "forcePushed"}, {"oid": "3a2f05064e7a5b69d25abf9ffed22bc0e3fc52b5", "url": "https://github.com/DataDog/dd-trace-java/commit/3a2f05064e7a5b69d25abf9ffed22bc0e3fc52b5", "message": "implement protobuf writer, refactor msgpack serialisation to reuse code", "committedDate": "2020-11-04T13:54:31Z", "type": "forcePushed"}, {"oid": "fc0d450e25781d2e6f7b06c362429de1195d1718", "url": "https://github.com/DataDog/dd-trace-java/commit/fc0d450e25781d2e6f7b06c362429de1195d1718", "message": "implement protobuf writer, refactor msgpack serialisation to reuse code", "committedDate": "2020-11-04T16:49:58Z", "type": "forcePushed"}, {"oid": "42def7a99d5f22dcfe6746f8a5ad0c2039955d77", "url": "https://github.com/DataDog/dd-trace-java/commit/42def7a99d5f22dcfe6746f8a5ad0c2039955d77", "message": "implement protobuf writer, refactor msgpack serialisation to reuse code", "committedDate": "2020-11-04T18:05:08Z", "type": "forcePushed"}, {"oid": "d13d4957bc94fa892a643a243f6c8ea6448fa59f", "url": "https://github.com/DataDog/dd-trace-java/commit/d13d4957bc94fa892a643a243f6c8ea6448fa59f", "message": "implement protobuf writer, refactor msgpack serialisation to reuse code", "committedDate": "2020-11-05T11:09:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk3NTM3MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2049#discussion_r517975371", "bodyText": "This is flawed at the moment because the root buffer will not be written in to until the end for messages like\nmessage Foo {\n     repeated Any x = 1;\n}\n\nAnd the first context pushed to the stack would need to grow indefinitely.", "author": "richardstartin", "createdAt": "2020-11-05T11:19:10Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/protobuf/ProtobufWriter.java", "diffHunk": "@@ -0,0 +1,416 @@\n+package datadog.trace.core.serialization.protobuf;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.serialization.ByteBufferConsumer;\n+import datadog.trace.core.serialization.Codec;\n+import datadog.trace.core.serialization.EncodingCache;\n+import datadog.trace.core.serialization.Writable;\n+import datadog.trace.core.serialization.WritableFormatter;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.Map;\n+\n+/**\n+ * Gives low level access to the protobuf format. Requires writers to write fields in the correct\n+ * order (which is also beneficial for readers hoping to skip fields, allowing the reader to pass\n+ * over the buffer once).\n+ */\n+public class ProtobufWriter extends WritableFormatter {\n+\n+  private static final int VARINT = 0;\n+  private static final int FIXED_64 = 1;\n+  private static final int LENGTH_DELIMITED = 2;\n+  private static final int FIXED_32 = 5;\n+\n+  private class Context implements Writable {\n+    private final ByteBuffer buffer;\n+    private int elementCount = Integer.MAX_VALUE;\n+    private int fieldNumber = 1;\n+    private int position = 0;\n+    private boolean inArray = false;\n+\n+    private Context(ByteBuffer buffer) {\n+      this.buffer = buffer;\n+    }\n+\n+    private Context() {\n+      // 512 KB\n+      this(ByteBuffer.allocate(1 << 19));\n+    }\n+\n+    void reset() {\n+      buffer.position(0);\n+      buffer.limit(buffer.capacity());\n+      this.fieldNumber = 1;\n+      this.position = 0;\n+      this.elementCount = Integer.MAX_VALUE;\n+    }\n+\n+    void transferTo(Context target) {\n+      buffer.flip();\n+      target.writeBinary(buffer);\n+    }\n+\n+    @Override\n+    public void writeNull() {\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeBoolean(boolean value) {\n+      if (value) {\n+        if (!inArray) {\n+          writeTag(VARINT);\n+        }\n+        writeVarInt(1);\n+      }\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeObject(Object value, EncodingCache encodingCache) {\n+      ProtobufWriter.this.writeObject(value, encodingCache);\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeMap(Map<? extends CharSequence, ?> map, EncodingCache encodingCache) {\n+      if (!map.isEmpty()) {\n+        ProtobufWriter.this.writeMap(map, encodingCache);\n+      }\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeString(CharSequence s, EncodingCache encodingCache) {\n+      if (s instanceof UTF8BytesString) {\n+        writeUTF8((UTF8BytesString) s);\n+      } else {\n+        // TODO consider avoiding allocations here\n+        writeUTF8(String.valueOf(s).getBytes(UTF_8));\n+      }\n+    }\n+\n+    @Override\n+    public void writeUTF8(byte[] string, int offset, int length) {\n+      if (length != 0) {\n+        writeLengthPrefix(length);\n+        buffer.put(string, offset, length);\n+      }\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeUTF8(byte[] string) {\n+      if (string.length != 0) {\n+        writeLengthPrefix(string.length);\n+        buffer.put(string);\n+      }\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeUTF8(UTF8BytesString string) {\n+      if (string.encodedLength() != 0) {\n+        writeLengthPrefix(string.encodedLength());\n+        string.transferTo(buffer);\n+      }\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeBinary(byte[] binary, int offset, int length) {\n+      if (length != 0) {\n+        writeLengthPrefix(length);\n+        buffer.put(binary, offset, length);\n+      }\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeBinary(ByteBuffer buffer) {\n+      if (buffer.hasRemaining()) {\n+        writeLengthPrefix(buffer.remaining());\n+        this.buffer.put(buffer);\n+      }\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void startMap(int elementCount) {\n+      if (elementCount != 0) {\n+        ProtobufWriter.this.startMap(elementCount);\n+      }\n+    }\n+\n+    @Override\n+    public void startStruct(int elementCount) {\n+      if (elementCount != 0) {\n+        ProtobufWriter.this.startStruct(elementCount);\n+      }\n+    }\n+\n+    @Override\n+    public void startArray(int elementCount) {\n+      if (elementCount != 0) {\n+        ProtobufWriter.this.startArray(elementCount);\n+      }\n+    }\n+\n+    @Override\n+    public void writeInt(int value) {\n+      // TODO to support sint32 need a separate zigzag encoded method\n+      if (value != 0) {\n+        if (!inArray) {\n+          writeTag(VARINT);\n+        }\n+        writeVarInt(value);\n+      }\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeLong(long value) {\n+      // TODO to support sint64 need a separate zigzag encoded method\n+      if (value != 0) {\n+        if (!inArray) {\n+          writeTag(VARINT);\n+        }\n+        writeVarInt(value);\n+      }\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeFloat(float value) {\n+      if (value != 0f) {\n+        if (!inArray) {\n+          writeTag(FIXED_32);\n+        }\n+        buffer.putFloat(value);\n+      }\n+      nextElement();\n+    }\n+\n+    @Override\n+    public void writeDouble(double value) {\n+      if (value != 0d) {\n+        if (!inArray) {\n+          writeTag(FIXED_64);\n+        }\n+        buffer.putDouble(value);\n+      }\n+      nextElement();\n+    }\n+\n+    private void writeLengthPrefix(int length) {\n+      writeTag(LENGTH_DELIMITED);\n+      writeVarInt(length);\n+    }\n+\n+    private void nextElement() {\n+      if (!inArray) {\n+        ++fieldNumber;\n+      }\n+      ++position;\n+      checkElementCountInvariant();\n+    }\n+\n+    private void checkElementCountInvariant() {\n+      if (position == elementCount) {\n+        ProtobufWriter.this.leaveContext();\n+      }\n+    }\n+\n+    void writeTag(int wireType) {\n+      writeVarInt((fieldNumber << 3) | wireType);\n+    }\n+\n+    private void writeVarInt(int value) {\n+      int length = varIntLength(value);\n+      for (int i = 0; i < length; ++i) {\n+        buffer.put((byte) ((value & 0x7F) | 0x80));\n+        value >>>= 7;\n+      }\n+      buffer.put((byte) value);\n+    }\n+\n+    private void writeVarInt(long value) {\n+      int length = varIntLength(value);\n+      for (int i = 0; i < length; ++i) {\n+        buffer.put((byte) ((value & 0x7F) | 0x80));\n+        value >>>= 7;\n+      }\n+      buffer.put((byte) value);\n+    }\n+\n+    private int varIntLength(int value) {\n+      return (31 - Integer.numberOfLeadingZeros(value)) / 7;\n+    }\n+\n+    private int varIntLength(long value) {\n+      return (63 - Long.numberOfLeadingZeros(value)) / 7;\n+    }\n+  }\n+\n+  private final Deque<Context> pool = new ArrayDeque<>();\n+  private final Deque<Context> stack = new ArrayDeque<>();\n+  private final Context root;\n+  private Context active;\n+\n+  public ProtobufWriter(\n+      Codec codec, ByteBufferConsumer sink, ByteBuffer buffer, boolean manualReset) {\n+    super(codec, sink, buffer, manualReset, 0);\n+    this.root = new Context(buffer);", "originalCommit": "d13d4957bc94fa892a643a243f6c8ea6448fa59f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzNTUyOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2049#discussion_r518035528", "bodyText": "This is just a name change, not new code.", "author": "richardstartin", "createdAt": "2020-11-05T13:06:06Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/msgpack/MsgPackWriter.java", "diffHunk": "@@ -1,8 +1,606 @@\n package datadog.trace.core.serialization.msgpack;\n \n+import static java.nio.charset.StandardCharsets.UTF_8;", "originalCommit": "d13d4957bc94fa892a643a243f6c8ea6448fa59f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE0MjIxOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2049#discussion_r518142219", "bodyText": "Any idea why git didn't pick up on the rename?", "author": "tylerbenson", "createdAt": "2020-11-05T15:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzNTUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE2NzMwNw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2049#discussion_r518167307", "bodyText": "It's because there was an interface called MsgPackWriter before, in the same package, which was renamed and moved to Writer in the package above.", "author": "richardstartin", "createdAt": "2020-11-05T16:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzNTUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODEzOTc5Mw==", "url": "https://github.com/DataDog/dd-trace-java/pull/2049#discussion_r518139793", "bodyText": "Tis a shame that these annotations can't be added when targeting Java 7.", "author": "tylerbenson", "createdAt": "2020-11-05T15:31:01Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/ValueWriter.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package datadog.trace.core.serialization;\n+\n+// TODO @FunctionalInterface", "originalCommit": "d13d4957bc94fa892a643a243f6c8ea6448fa59f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE0NzIzOQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2049#discussion_r518147239", "bodyText": "This doesn't seem as easy to follow as parameterized spock.", "author": "tylerbenson", "createdAt": "2020-11-05T15:38:12Z", "path": "dd-trace-core/src/test/java/datadog/trace/core/serialization/protobuf/IntPackingTest.java", "diffHunk": "@@ -0,0 +1,140 @@\n+package datadog.trace.core.serialization.protobuf;\n+\n+import static datadog.trace.core.serialization.protobuf.CompactRepeatedFieldHelper.verifyCompactVarints;\n+\n+import datadog.trace.core.serialization.ByteBufferConsumer;\n+import datadog.trace.core.serialization.EncodingCachingStrategies;\n+import datadog.trace.core.serialization.Mapper;\n+import datadog.trace.core.serialization.MessageFormatter;\n+import datadog.trace.core.serialization.Writable;\n+import java.nio.ByteBuffer;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+@RunWith(Parameterized.class)", "originalCommit": "d13d4957bc94fa892a643a243f6c8ea6448fa59f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "84b6b3eb3715bd6f943087f72240826dc1cf40f2", "url": "https://github.com/DataDog/dd-trace-java/commit/84b6b3eb3715bd6f943087f72240826dc1cf40f2", "message": "implement protobuf writer, refactor msgpack serialisation to reuse code", "committedDate": "2020-11-06T12:58:10Z", "type": "forcePushed"}, {"oid": "0f239fc21c7f9f475cfc321f46da94636deed5c1", "url": "https://github.com/DataDog/dd-trace-java/commit/0f239fc21c7f9f475cfc321f46da94636deed5c1", "message": "implement protobuf writer, refactor msgpack serialisation to reuse code", "committedDate": "2020-11-06T15:59:58Z", "type": "commit"}, {"oid": "0f239fc21c7f9f475cfc321f46da94636deed5c1", "url": "https://github.com/DataDog/dd-trace-java/commit/0f239fc21c7f9f475cfc321f46da94636deed5c1", "message": "implement protobuf writer, refactor msgpack serialisation to reuse code", "committedDate": "2020-11-06T15:59:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3MTQwNg==", "url": "https://github.com/DataDog/dd-trace-java/pull/2049#discussion_r519671406", "bodyText": "If I understand the code correctly, the Context is used to serialize out the current struct or array so that it's possible to write the length in bytes in the varint encoding in the parent buffer before copying over the serialized bytes from the context. It would be great with some comment about the machinery so it would be easier to follow without digging through the call chain.", "author": "bantonsson", "createdAt": "2020-11-09T09:39:39Z", "path": "dd-trace-core/src/main/java/datadog/trace/core/serialization/protobuf/ProtobufWriter.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package datadog.trace.core.serialization.protobuf;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+import datadog.trace.bootstrap.instrumentation.api.UTF8BytesString;\n+import datadog.trace.core.serialization.ByteBufferConsumer;\n+import datadog.trace.core.serialization.Codec;\n+import datadog.trace.core.serialization.EncodingCache;\n+import datadog.trace.core.serialization.Writable;\n+import datadog.trace.core.serialization.WritableFormatter;\n+import java.nio.ByteBuffer;\n+import java.util.ArrayDeque;\n+import java.util.Deque;\n+import java.util.Map;\n+\n+/**\n+ * Gives low level access to the protobuf format. Requires writers to write fields in the correct\n+ * order (which is also beneficial for readers hoping to skip fields, allowing the reader to pass\n+ * over the buffer once).\n+ */\n+public class ProtobufWriter extends WritableFormatter {\n+\n+  private static final int VARINT = 0;\n+  private static final int FIXED_64 = 1;\n+  private static final int LENGTH_DELIMITED = 2;\n+  private static final int FIXED_32 = 5;\n+\n+  private class Context implements Writable {", "originalCommit": "0f239fc21c7f9f475cfc321f46da94636deed5c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcxMDc4MQ==", "url": "https://github.com/DataDog/dd-trace-java/pull/2049#discussion_r519710781", "bodyText": "Yes, that's right. As you can see, it's quite awkward to write protobuf. I will try to explain the mechanics better in comments.", "author": "richardstartin", "createdAt": "2020-11-09T10:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3MTQwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTczMjcwOA==", "url": "https://github.com/DataDog/dd-trace-java/pull/2049#discussion_r519732708", "bodyText": "Thanks", "author": "bantonsson", "createdAt": "2020-11-09T11:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY3MTQwNg=="}], "type": "inlineReview"}, {"oid": "2af593c5333ebf0560a5b76fa8457a020f5871a2", "url": "https://github.com/DataDog/dd-trace-java/commit/2af593c5333ebf0560a5b76fa8457a020f5871a2", "message": "javadoc to clarify the protobuf context stack", "committedDate": "2020-11-09T10:52:56Z", "type": "commit"}]}