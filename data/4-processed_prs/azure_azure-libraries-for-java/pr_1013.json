{"pr_number": 1013, "pr_title": "Migrate ProviderRegistrationPolicy and ResourceManagerThrottlingPolicy", "pr_createdAt": "2020-02-09T10:26:53Z", "pr_url": "https://github.com/Azure/azure-libraries-for-java/pull/1013", "timeline": [{"oid": "a9fa2e542c6bd08adb04b919d91b0e29507bbc33", "url": "https://github.com/Azure/azure-libraries-for-java/commit/a9fa2e542c6bd08adb04b919d91b0e29507bbc33", "message": "feat: add ProviderRegistrationPolicy", "committedDate": "2020-02-06T06:37:01Z", "type": "commit"}, {"oid": "642d9dd32f90a929ff74b3eb2d2afed559ca5f79", "url": "https://github.com/Azure/azure-libraries-for-java/commit/642d9dd32f90a929ff74b3eb2d2afed559ca5f79", "message": "feat: add ResourceManagerThrottlingPolicy", "committedDate": "2020-02-09T10:24:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njc4ODI3OQ==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r376788279", "bodyText": "For boolean feauntion, should naming with is", "author": "yaohaizh", "createdAt": "2020-02-09T14:29:03Z", "path": "azure-mgmt-resources/src/main/java/com/azure/management/resources/fluentcore/utils/ProviderRegistrationPolicy.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License. See License.txt in the project root for\n+ * license information.\n+ */\n+\n+package com.azure.management.resources.fluentcore.utils;\n+\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.management.CloudError;\n+import com.azure.core.management.serializer.AzureJacksonAdapter;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.serializer.SerializerEncoding;\n+import com.azure.management.AzureTokenCredential;\n+import com.azure.management.RestClient;\n+import com.azure.management.RestClientBuilder;\n+import com.azure.management.resources.Provider;\n+import com.azure.management.resources.fluentcore.arm.ResourceUtils;\n+import com.azure.management.resources.implementation.ResourceManager;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A Http Pipeline Policy for automatic provider registration in Azure.\n+ */\n+public class ProviderRegistrationPolicy implements HttpPipelinePolicy {\n+    private final static String MISSING_SUBSCRIPTION_REGISTRATION = \"MissingSubscriptionRegistration\";\n+    private final AzureTokenCredential credential;\n+\n+    /**\n+     * Initialize a provider registration policy with a credential that's authorized\n+     * to register the provider.\n+     * @param credential the credential for provider registration\n+     */\n+    public ProviderRegistrationPolicy(AzureTokenCredential credential) {\n+        this.credential = credential;\n+    }\n+\n+    private boolean responseSuccessful(HttpResponse response) {", "originalCommit": "642d9dd32f90a929ff74b3eb2d2afed559ca5f79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgzNjM3NQ==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r376836375", "bodyText": "Please double check the code. I think v1 code is incorrect. Commonly no one calls wait on an ReentrantLock.", "author": "weidongxu-microsoft", "createdAt": "2020-02-10T01:16:28Z", "path": "azure-mgmt-resources/src/main/java/com/azure/management/resources/fluentcore/utils/ResourceManagerThrottlingPolicy.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License. See License.txt in the project root for\n+ * license information.\n+ */\n+\n+package com.azure.management.resources.fluentcore.utils;\n+\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.util.DateTimeRfc1123;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.logging.ClientLogger;\n+import com.azure.management.resources.fluentcore.arm.ResourceUtils;\n+import reactor.core.publisher.Mono;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.OffsetDateTime;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A Http Pipeline Policy for automatic retry when Azure Resource Manager is throttling because of too many read/write requests.\n+ * <p>\n+ * For each subscription and tenant, Azure Resource Manager limits read requests to 15,000 per hour and\n+ *   write requests to 1,200 per hour. These limits apply to each Azure Resource Manager instance.\n+ */\n+public class ResourceManagerThrottlingPolicy implements HttpPipelinePolicy {\n+    private static final ConcurrentMap<String, ReentrantLock> REENTRANT_LOCK_MAP = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        final HttpRequest request = context.getHttpRequest();\n+        String extractSubscriptionId = ResourceUtils.extractFromResourceId(request.getUrl().getPath(), \"subscriptions\");\n+        if (extractSubscriptionId == null) {\n+            extractSubscriptionId = \"global\";\n+        }\n+        final String subscriptionId = extractSubscriptionId;\n+        REENTRANT_LOCK_MAP.putIfAbsent(subscriptionId, new ReentrantLock());\n+        try {\n+            synchronized (REENTRANT_LOCK_MAP.get(subscriptionId)) {\n+                if (REENTRANT_LOCK_MAP.get(subscriptionId).isLocked()) {\n+                    REENTRANT_LOCK_MAP.get(subscriptionId).wait();", "originalCommit": "642d9dd32f90a929ff74b3eb2d2afed559ca5f79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg0NTY0OQ==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r376845649", "bodyText": "wait makes thread waiting until notifyAll, it is not the method for ReentrantLock. Maybe change  it into Object.wait()?", "author": "ChenTanyi", "createdAt": "2020-02-10T02:23:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgzNjM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg0OTEyNA==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r376849124", "bodyText": "If one is using high level sync like ReentrantLock, one should never call low level sync method in Object (as well as synchronized block).\nPlease review what this class actually want to do. Normally one of lock or tryLock and then unlock should be enough to do the job.", "author": "weidongxu-microsoft", "createdAt": "2020-02-10T02:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgzNjM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg1MDI4NQ==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r376850285", "bodyText": "Since it is just wait the lock to be released (after sleep for retry), but don't need to lock again, do you mean it should be better to use lock then unlock immediately?", "author": "ChenTanyi", "createdAt": "2020-02-10T02:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgzNjM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg1NTYxNg==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r376855616", "bodyText": "If there is no better way you can do the wait on the object.\nWhat I mean is that you need to think what is the proper way to implement the feature. And what it the proper way to test to make sure it is done correctly.\nHaving lock inside async method is already weird enough (and the unlock is in finally block of the method, does it happen before or after the request is complete?).\n1st, is there another way to throttle it in async?\n2nd, if you had to do the lock, is there a better way?\n@yaohaizh", "author": "weidongxu-microsoft", "createdAt": "2020-02-10T03:28:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgzNjM3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NDg2OQ==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r378094869", "bodyText": "I'd removed the lock, and deal with every 429 separately, since every subscription has several limitation (read, write, delete and so on)", "author": "ChenTanyi", "createdAt": "2020-02-12T08:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgzNjM3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg0MDg5Nw==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r376840897", "bodyText": "Not sure about proxy, or any other configure with origin restClient.\nIf you are also not sure, add a TODO?", "author": "weidongxu-microsoft", "createdAt": "2020-02-10T01:52:06Z", "path": "azure-mgmt-resources/src/main/java/com/azure/management/resources/fluentcore/utils/ProviderRegistrationPolicy.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License. See License.txt in the project root for\n+ * license information.\n+ */\n+\n+package com.azure.management.resources.fluentcore.utils;\n+\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.management.CloudError;\n+import com.azure.core.management.serializer.AzureJacksonAdapter;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.serializer.SerializerEncoding;\n+import com.azure.management.AzureTokenCredential;\n+import com.azure.management.RestClient;\n+import com.azure.management.RestClientBuilder;\n+import com.azure.management.resources.Provider;\n+import com.azure.management.resources.fluentcore.arm.ResourceUtils;\n+import com.azure.management.resources.implementation.ResourceManager;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A Http Pipeline Policy for automatic provider registration in Azure.\n+ */\n+public class ProviderRegistrationPolicy implements HttpPipelinePolicy {\n+    private final static String MISSING_SUBSCRIPTION_REGISTRATION = \"MissingSubscriptionRegistration\";\n+    private final AzureTokenCredential credential;\n+\n+    /**\n+     * Initialize a provider registration policy with a credential that's authorized\n+     * to register the provider.\n+     * @param credential the credential for provider registration\n+     */\n+    public ProviderRegistrationPolicy(AzureTokenCredential credential) {\n+        this.credential = credential;\n+    }\n+\n+    private boolean responseSuccessful(HttpResponse response) {\n+        return response.getStatusCode() >= 200 && response.getStatusCode() < 300;\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        final HttpRequest request = context.getHttpRequest();\n+        return next.process().flatMap(\n+            response -> {\n+                if (!responseSuccessful(response)) {\n+                    HttpResponse bufferedResponse = response.buffer();\n+                    return FluxUtil.collectBytesInByteBufferStream(bufferedResponse.getBody()).flatMap(\n+                        body -> {\n+                            String bodyStr = new String(body, StandardCharsets.UTF_8);\n+\n+                            AzureJacksonAdapter jacksonAdapter = new AzureJacksonAdapter();\n+                            CloudError cloudError;\n+                            try {\n+                                cloudError = jacksonAdapter.deserialize(bodyStr, CloudError.class, SerializerEncoding.JSON);\n+                            } catch (IOException e) {\n+                                return Mono.just(bufferedResponse);\n+                            }\n+\n+                            if (cloudError != null && MISSING_SUBSCRIPTION_REGISTRATION.equals(cloudError.getCode())) {\n+                                String subscriptionId = ResourceUtils.extractFromResourceId(request.getUrl().getPath(), \"subscriptions\");\n+                                RestClient restClient = new RestClientBuilder()", "originalCommit": "642d9dd32f90a929ff74b3eb2d2afed559ca5f79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NDkwMg==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r378094902", "bodyText": "Done", "author": "ChenTanyi", "createdAt": "2020-02-12T08:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg0MDg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg0MTQ0Mw==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r376841443", "bodyText": "You seems calling a sync version? Should use the async?", "author": "weidongxu-microsoft", "createdAt": "2020-02-10T01:55:14Z", "path": "azure-mgmt-resources/src/main/java/com/azure/management/resources/fluentcore/utils/ProviderRegistrationPolicy.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/**\n+ * Copyright (c) Microsoft Corporation. All rights reserved.\n+ * Licensed under the MIT License. See License.txt in the project root for\n+ * license information.\n+ */\n+\n+package com.azure.management.resources.fluentcore.utils;\n+\n+import com.azure.core.http.HttpPipelineCallContext;\n+import com.azure.core.http.HttpPipelineNextPolicy;\n+import com.azure.core.http.HttpRequest;\n+import com.azure.core.http.HttpResponse;\n+import com.azure.core.http.policy.HttpPipelinePolicy;\n+import com.azure.core.management.CloudError;\n+import com.azure.core.management.serializer.AzureJacksonAdapter;\n+import com.azure.core.util.FluxUtil;\n+import com.azure.core.util.serializer.SerializerEncoding;\n+import com.azure.management.AzureTokenCredential;\n+import com.azure.management.RestClient;\n+import com.azure.management.RestClientBuilder;\n+import com.azure.management.resources.Provider;\n+import com.azure.management.resources.fluentcore.arm.ResourceUtils;\n+import com.azure.management.resources.implementation.ResourceManager;\n+import reactor.core.publisher.Mono;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * A Http Pipeline Policy for automatic provider registration in Azure.\n+ */\n+public class ProviderRegistrationPolicy implements HttpPipelinePolicy {\n+    private final static String MISSING_SUBSCRIPTION_REGISTRATION = \"MissingSubscriptionRegistration\";\n+    private final AzureTokenCredential credential;\n+\n+    /**\n+     * Initialize a provider registration policy with a credential that's authorized\n+     * to register the provider.\n+     * @param credential the credential for provider registration\n+     */\n+    public ProviderRegistrationPolicy(AzureTokenCredential credential) {\n+        this.credential = credential;\n+    }\n+\n+    private boolean responseSuccessful(HttpResponse response) {\n+        return response.getStatusCode() >= 200 && response.getStatusCode() < 300;\n+    }\n+\n+    @Override\n+    public Mono<HttpResponse> process(HttpPipelineCallContext context, HttpPipelineNextPolicy next) {\n+        final HttpRequest request = context.getHttpRequest();\n+        return next.process().flatMap(\n+            response -> {\n+                if (!responseSuccessful(response)) {\n+                    HttpResponse bufferedResponse = response.buffer();\n+                    return FluxUtil.collectBytesInByteBufferStream(bufferedResponse.getBody()).flatMap(\n+                        body -> {\n+                            String bodyStr = new String(body, StandardCharsets.UTF_8);\n+\n+                            AzureJacksonAdapter jacksonAdapter = new AzureJacksonAdapter();\n+                            CloudError cloudError;\n+                            try {\n+                                cloudError = jacksonAdapter.deserialize(bodyStr, CloudError.class, SerializerEncoding.JSON);\n+                            } catch (IOException e) {\n+                                return Mono.just(bufferedResponse);\n+                            }\n+\n+                            if (cloudError != null && MISSING_SUBSCRIPTION_REGISTRATION.equals(cloudError.getCode())) {\n+                                String subscriptionId = ResourceUtils.extractFromResourceId(request.getUrl().getPath(), \"subscriptions\");\n+                                RestClient restClient = new RestClientBuilder()\n+                                        .withBaseUrl(String.format(\"%s://%s\", request.getUrl().getProtocol(), request.getUrl().getHost()))\n+                                        .withCredential(credential)\n+                                        .withSerializerAdapter(jacksonAdapter).buildClient();\n+                                ResourceManager resourceManager = ResourceManager.authenticate(restClient)\n+                                        .withSubscription(subscriptionId);\n+                                Pattern providerPattern = Pattern.compile(\".*'(.*)'\");\n+                                Matcher providerMatcher = providerPattern.matcher(cloudError.getMessage());\n+                                providerMatcher.find();\n+                                Provider provider = registerProvider(providerMatcher.group(1), resourceManager);\n+                                while (provider.registrationState().equalsIgnoreCase(\"Unregistered\")\n+                                    || provider.registrationState().equalsIgnoreCase(\"Registering\")) {\n+                                    SdkContext.sleep(5 * 1000);\n+                                    provider = resourceManager.providers().getByName(provider.namespace());\n+                                }\n+\n+                                // Retry after registration\n+                                return next.process();\n+                            }\n+                            return Mono.just(bufferedResponse);\n+                        }\n+                    );\n+                }\n+                return Mono.just(response);\n+            }\n+        );\n+    }\n+\n+    private Provider registerProvider(String namespace, ResourceManager resourceManager) {\n+        return resourceManager.providers().register(namespace);", "originalCommit": "642d9dd32f90a929ff74b3eb2d2afed559ca5f79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA5NDk4MA==", "url": "https://github.com/Azure/azure-libraries-for-java/pull/1013#discussion_r378094980", "bodyText": "Done", "author": "ChenTanyi", "createdAt": "2020-02-12T08:17:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njg0MTQ0Mw=="}], "type": "inlineReview"}, {"oid": "5e7e2b560c19d4348c915d0ba51e9a28ef4128a2", "url": "https://github.com/Azure/azure-libraries-for-java/commit/5e7e2b560c19d4348c915d0ba51e9a28ef4128a2", "message": "fix: make provider register become async", "committedDate": "2020-02-11T10:30:04Z", "type": "commit"}, {"oid": "2e0b18a1886edf025b6af6423cc99622efcbf8f2", "url": "https://github.com/Azure/azure-libraries-for-java/commit/2e0b18a1886edf025b6af6423cc99622efcbf8f2", "message": "fix: remove synchronized, deal with every 429, since every subscription has several limitation", "committedDate": "2020-02-12T08:08:40Z", "type": "commit"}]}