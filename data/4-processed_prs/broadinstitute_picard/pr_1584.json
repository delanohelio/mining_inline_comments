{"pr_number": 1584, "pr_title": "Safely run DownsampleSam multiple times", "pr_createdAt": "2020-09-29T21:23:43Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1584", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0NzUwNA==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497647504", "bodyText": "you might come across a PG that will not have the rs tag...should protect against that.", "author": "yfarjoun", "createdAt": "2020-09-30T16:33:43Z", "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +218,28 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final int previousSeed = Integer.parseInt(pg.getAttribute(RANDOM_SEED_TAG));", "originalCommit": "d52442bcf3175dc19588cc2fe724514be89e1396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxOTUzNw==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498319537", "bodyText": "done", "author": "kachulis", "createdAt": "2020-10-01T15:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0NzUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0ODQ2Mw==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497648463", "bodyText": "This is too small a space to traverse. I would pull out random seed from a RNG that itself is initialized with the provided seed.", "author": "yfarjoun", "createdAt": "2020-09-30T16:35:15Z", "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +218,28 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final int previousSeed = Integer.parseInt(pg.getAttribute(RANDOM_SEED_TAG));\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                RANDOM_SEED *= 2;", "originalCommit": "d52442bcf3175dc19588cc2fe724514be89e1396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0OTE5NQ==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497649195", "bodyText": "also, if you modified the seed, put out a warning that the provided random seed had already been used and that you are using a different seed (and state what it is)", "author": "yfarjoun", "createdAt": "2020-09-30T16:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0ODQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxOTg4NA==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498319884", "bodyText": "done", "author": "kachulis", "createdAt": "2020-10-01T15:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY0ODQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MTUzMw==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497651533", "bodyText": "use 0 and MAX_INT as two options.", "author": "yfarjoun", "createdAt": "2020-09-30T16:40:04Z", "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +151,52 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});", "originalCommit": "d52442bcf3175dc19588cc2fe724514be89e1396", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1MzU4MQ==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497653581", "bodyText": "update the doc for the seed argument to reflect some of the logic here.", "author": "yfarjoun", "createdAt": "2020-09-30T16:43:18Z", "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -183,6 +187,8 @@\n \n     private final Log log = Log.getInstance(DownsampleSam.class);\n \n+    public static final String RANDOM_SEED_TAG = \"rs\";", "originalCommit": "d52442bcf3175dc19588cc2fe724514be89e1396", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NDE1OQ==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r497654159", "bodyText": "please add a test that shows that downsampling twice with 50% actually yields 25%.", "author": "yfarjoun", "createdAt": "2020-09-30T16:44:16Z", "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +151,52 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,3)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, HighAccuracy), Arrays.asList(1,1)});\n+\n+        //randomly generate some sequences to test out\n+        final Strategy[] availableStratagies = Strategy.values();\n+        final Random random = new Random(12345);\n+        for (int i =0; i<20; i++) {\n+            final List<Strategy> strategies = new ArrayList<>();\n+            final List<Integer> seeds = new ArrayList<>();\n+\n+            while (strategies.size() < 5) {\n+                final int seed = random.nextInt(3);\n+                final Strategy strategy = availableStratagies[random.nextInt(availableStratagies.length)];\n+\n+                seeds.add(seed);\n+                strategies.add(strategy);\n+            }\n+            rets.add(new Object[]{strategies, seeds});\n+        }\n+\n+        return rets.toArray(new Object[0][]);\n+    }\n+\n+    @Test(dataProvider = \"RepeatedDownsamplingProvider\")", "originalCommit": "d52442bcf3175dc19588cc2fe724514be89e1396", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMzNTIwMw==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498335203", "bodyText": "testDownsampleWorker does this in some sense, in that it tests that each downsampling step actually downsamples the data as intended.  I have also added code to test the the cumulative downsampling is as expected.", "author": "kachulis", "createdAt": "2020-10-01T15:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NDE1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDYxOQ==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694619", "bodyText": "\ud83d\udc4d", "author": "yfarjoun", "createdAt": "2020-10-07T02:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1NDE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498402012", "bodyText": "this break will still cause the code to hit the while loop below after having collected a subset of seeds, I'm not sure that's what you intended.", "author": "yfarjoun", "createdAt": "2020-10-01T17:21:25Z", "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,42 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random().nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The current seed has been set to \" + RANDOM_SEED + \" to avoid using the \" +\n+                                \"same seed as previously.\");\n+                        break;", "originalCommit": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjg5Mw==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498402893", "bodyText": "Also, the log message might be incorrect in that case.", "author": "yfarjoun", "createdAt": "2020-10-01T17:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwNjEwNw==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498406107", "bodyText": "Since we want DownsampleSam to be deterministic, we need a better solution here. Perhaps an override argument?", "author": "yfarjoun", "createdAt": "2020-10-01T17:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzNjEyMQ==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501936121", "bodyText": "sorry, I missed that.", "author": "yfarjoun", "createdAt": "2020-10-08T18:41:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwMjAxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQwNzAyNA==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r498407024", "bodyText": "expand imports", "author": "yfarjoun", "createdAt": "2020-10-01T17:30:17Z", "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -18,9 +18,12 @@\n import java.io.FileNotFoundException;\n import java.io.IOException;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.List;\n import java.util.Random;\n \n+import static htsjdk.samtools.DownsamplingIteratorFactory.Strategy.*;", "originalCommit": "f9eefe2e0d82d2dccf13ba1c0841bd987c58786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDAwMQ==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694001", "bodyText": "RANDOM_SEED may be null.", "author": "yfarjoun", "createdAt": "2020-10-07T02:02:17Z", "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final int USER_SEED = RANDOM_SEED;", "originalCommit": "370a63ce143be5581bc318c375888a0d80a0197f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDQzNA==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694434", "bodyText": "also, no reason to ALL_CAPS the userSeed variable. We usually reserve that for input arguments and statics", "author": "yfarjoun", "createdAt": "2020-10-07T02:03:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NTQxMw==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501675413", "bodyText": "null RANDOM_SEED is checked for earlier, and at this point in the code it can't be null.", "author": "kachulis", "createdAt": "2020-10-08T12:20:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkzNjU5OA==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501936598", "bodyText": "thanks for pointing that out.", "author": "yfarjoun", "createdAt": "2020-10-08T18:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDE4NQ==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694185", "bodyText": "extra space before period...were you going to put a more informative error message here?", "author": "yfarjoun", "createdAt": "2020-10-07T02:03:06Z", "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final int USER_SEED = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            final Random rnd = new Random(RANDOM_SEED);\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                final int previousSeed = RANDOM_SEED;\n+                RANDOM_SEED = rnd.nextInt();\n+                log.warn(\"DownsampleSam has been run before on this data with the seed .  The random seed will be changed to avoid using the \" +", "originalCommit": "370a63ce143be5581bc318c375888a0d80a0197f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDY4Nw==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694687", "bodyText": "spaces", "author": "yfarjoun", "createdAt": "2020-10-07T02:04:47Z", "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +153,63 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+\n+\n+\n+    @DataProvider(name = \"RepeatedDownsamplingProvider\")\n+    public Object[][] repeatedDownsamplingProvider() {\n+        final List<Object[]> rets = new ArrayList<>();\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(2,1)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(0,0)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MAX_VALUE,Integer.MAX_VALUE)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MIN_VALUE,Integer.MIN_VALUE)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MIN_VALUE,Integer.MAX_VALUE)});\n+        rets.add(new Object[]{Arrays.asList(DownsamplingIteratorFactory.Strategy.ConstantMemory, ConstantMemory), Arrays.asList(Integer.MAX_VALUE,0)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, ConstantMemory), Arrays.asList(1,3)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, ConstantMemory), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(ConstantMemory, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, Chained), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(HighAccuracy, HighAccuracy), Arrays.asList(1,1)});\n+        rets.add(new Object[]{Arrays.asList(Chained, HighAccuracy), Arrays.asList(1,1)});\n+\n+        //randomly generate some sequences to test out\n+        final Strategy[] availableStratagies = Strategy.values();\n+        final Random random = new Random(12345);\n+        for (int i =0; i<20; i++) {", "originalCommit": "370a63ce143be5581bc318c375888a0d80a0197f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDczNQ==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r500694735", "bodyText": "too many spaces", "author": "yfarjoun", "createdAt": "2020-10-07T02:04:54Z", "path": "src/test/java/picard/sam/DownsampleSamTest.java", "diffHunk": "@@ -148,5 +153,63 @@ private void testDownsampleWorker(final File samFile, final double fraction, fin\n             TestNGUtil.assertGreaterThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * .8 * SamTestUtil.countSamTotalRecord(samFile));\n             TestNGUtil.assertLessThan(SamTestUtil.countSamTotalRecord(downsampled), fraction * 1.2 * SamTestUtil.countSamTotalRecord(samFile));\n         }\n+        return downsampled;\n+    }\n+", "originalCommit": "370a63ce143be5581bc318c375888a0d80a0197f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTUxNA==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501825514", "bodyText": "This hash is effectively random since it's the Object.hashCode(), right? but it gives the illusion of being deterministic.\nI think it should be as deterministic as possible, but am not sure what here can be used as a seed. perhaps the collection of PU fields from the RG tags? not sure how you'd like to resolve this,\nbut I don't like hidden randomness.", "author": "yfarjoun", "createdAt": "2020-10-08T15:46:36Z", "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();", "originalCommit": "1fecb519b860215d647fb28464414b458f50283f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkyMTc0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501921742", "bodyText": "SAMProgramRecord has a hashCode method that avoids dropping into Object.hashCode(), so I believe this should be deterministic.", "author": "kachulis", "createdAt": "2020-10-08T18:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTc5Nw==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501825797", "bodyText": "no need to split this into two lines.", "author": "yfarjoun", "createdAt": "2020-10-08T15:46:58Z", "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);", "originalCommit": "1fecb519b860215d647fb28464414b458f50283f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNDUxMw==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501914513", "bodyText": "I meant the extra variable previousSeed", "author": "yfarjoun", "createdAt": "2020-10-08T18:06:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNjkyMg==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501916922", "bodyText": "that makes more sense", "author": "kachulis", "createdAt": "2020-10-08T18:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNTc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyNzM0OQ==", "url": "https://github.com/broadinstitute/picard/pull/1584#discussion_r501827349", "bodyText": "final", "author": "yfarjoun", "createdAt": "2020-10-08T15:49:09Z", "path": "src/main/java/picard/sam/DownsampleSam.java", "diffHunk": "@@ -212,7 +220,45 @@ protected int doWork() {\n         }\n \n         final SamReader in = SamReaderFactory.makeDefault().referenceSequence(REFERENCE_SEQUENCE).open(SamInputResource.of(INPUT));\n-        final SAMFileWriter out = new SAMFileWriterFactory().makeSAMOrBAMWriter(in.getFileHeader(), true, OUTPUT);\n+        final SAMFileHeader header = in.getFileHeader().clone();\n+\n+        if (STRATEGY == Strategy.ConstantMemory || STRATEGY == Strategy.Chained) {\n+            //if running using ConstantMemory or Chained strategy, need to check if we have previously run with the same random seed\n+            //collect previously used seeds\n+            final Integer userSeed = RANDOM_SEED;\n+            final Set<Integer> previousSeeds = new HashSet<>();\n+            for (final SAMProgramRecord pg : header.getProgramRecords()) {\n+                if (pg.getProgramName() != null && pg.getProgramName().equals(PG_PROGRAM_NAME)) {\n+                    final String previousSeedString = pg.getAttribute(RANDOM_SEED_TAG);\n+                    if (previousSeedString == null) {\n+                        /* The previous seed was not recorded.  In this case, the current seed may be the same as the previous seed,\n+                        so we will change it to a randomly selected seed, which is very likely to be unique\n+                         */\n+                        RANDOM_SEED = new Random(pg.hashCode()).nextInt();\n+                        log.warn(\"DownsampleSam has been run before on this data, but the previous seed was not recorded.  The used seed will be changed to minimize the chance of using the\" +\n+                                \" same seed as in a previous run.\");\n+                    }\n+                    final int previousSeed = Integer.parseInt(previousSeedString);\n+                    previousSeeds.add(previousSeed);\n+                }\n+            }\n+\n+            final Random rnd = new Random(RANDOM_SEED);\n+            while (previousSeeds.contains(RANDOM_SEED)) {\n+                final int previousSeed = RANDOM_SEED;\n+                RANDOM_SEED = rnd.nextInt();\n+                log.warn(\"DownsampleSam has been run before on this data with the seed \" + RANDOM_SEED + \".  The random seed will be changed to avoid using the \" +\n+                        \"same seed as previously.\");\n+            }\n+            if (!userSeed.equals(RANDOM_SEED)) {\n+                log.warn(\"RANDOM_SEED has been changed to \" + RANDOM_SEED + \".\");\n+            }\n+        }\n+\n+        SAMProgramRecord pgRecord = getPGRecord(header);", "originalCommit": "1fecb519b860215d647fb28464414b458f50283f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f6f8b5facb51f914ab73cfc131dc9bf56914e2e7", "url": "https://github.com/broadinstitute/picard/commit/f6f8b5facb51f914ab73cfc131dc9bf56914e2e7", "message": "safety check when Downsampling", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "8739d7a5f23b41c4fc0cf339a4bdf2a449d62f8d", "url": "https://github.com/broadinstitute/picard/commit/8739d7a5f23b41c4fc0cf339a4bdf2a449d62f8d", "message": "refactor addition of pg line", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "cf348d0024f05fe1a6fdd5cd083f0a572d8bce6e", "url": "https://github.com/broadinstitute/picard/commit/cf348d0024f05fe1a6fdd5cd083f0a572d8bce6e", "message": "better tests", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "46cb0760acb823a71ec364a3a9804b30732cec47", "url": "https://github.com/broadinstitute/picard/commit/46cb0760acb823a71ec364a3a9804b30732cec47", "message": "internally adjust probability", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "fac2638a700d311e2186085aa8327e2cc23d16e2", "url": "https://github.com/broadinstitute/picard/commit/fac2638a700d311e2186085aa8327e2cc23d16e2", "message": "adjust seed instead of probability, add tag to pg record instead of parsing command line", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "20a72a75fb71810f2ceed2c88093296a9d819a17", "url": "https://github.com/broadinstitute/picard/commit/20a72a75fb71810f2ceed2c88093296a9d819a17", "message": "cleanup and fix random seed adjustment", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "7acdedee3c2ccdfbb5b4719bb450ab2eef2a26da", "url": "https://github.com/broadinstitute/picard/commit/7acdedee3c2ccdfbb5b4719bb450ab2eef2a26da", "message": "actually add pg record to header", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "55da2a0cf7b48f0af383f639395cb3520243f5f7", "url": "https://github.com/broadinstitute/picard/commit/55da2a0cf7b48f0af383f639395cb3520243f5f7", "message": "review comments", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "4c38cc9faab258a2bdd470187f03117cbd81ea81", "url": "https://github.com/broadinstitute/picard/commit/4c38cc9faab258a2bdd470187f03117cbd81ea81", "message": "don't need PicardException", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "4dd9edcff2e9443990d927b315cbfe12c0c4e733", "url": "https://github.com/broadinstitute/picard/commit/4dd9edcff2e9443990d927b315cbfe12c0c4e733", "message": "review comments", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "f20f43c1963629ce9507981170de5ea7aa8c4998", "url": "https://github.com/broadinstitute/picard/commit/f20f43c1963629ce9507981170de5ea7aa8c4998", "message": "small cleanup", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "ec7c80b4235ecf34ed837297717af1f13cc44ecf", "url": "https://github.com/broadinstitute/picard/commit/ec7c80b4235ecf34ed837297717af1f13cc44ecf", "message": "review", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "b8d984816fe56e70b41fffe6333e79277cc10d37", "url": "https://github.com/broadinstitute/picard/commit/b8d984816fe56e70b41fffe6333e79277cc10d37", "message": "remove extra blank line", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "80b4042c227f452680de1b8a3d1267d4f1313ac5", "url": "https://github.com/broadinstitute/picard/commit/80b4042c227f452680de1b8a3d1267d4f1313ac5", "message": "try again", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "846572b2b274b48d9c0df6442393366cd489911e", "url": "https://github.com/broadinstitute/picard/commit/846572b2b274b48d9c0df6442393366cd489911e", "message": "avoid npe", "committedDate": "2020-10-08T18:48:31Z", "type": "commit"}, {"oid": "846572b2b274b48d9c0df6442393366cd489911e", "url": "https://github.com/broadinstitute/picard/commit/846572b2b274b48d9c0df6442393366cd489911e", "message": "avoid npe", "committedDate": "2020-10-08T18:48:31Z", "type": "forcePushed"}]}