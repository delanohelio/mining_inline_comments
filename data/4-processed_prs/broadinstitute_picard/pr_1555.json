{"pr_number": 1555, "pr_title": "Several changes to metrics collections (AlignmentSummaryMetrics and WgsMetrics) + some fluff", "pr_createdAt": "2020-07-31T21:04:26Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1555", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MzA1Ng==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464463056", "bodyText": "Is there any reason to not use RuntimeException() here?", "author": "pshapiro4broad", "createdAt": "2020-08-03T14:49:00Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -15,6 +20,24 @@\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.\n+    final protected File TEMP_OUTPUT_DIR;\n+    {\n+        try {\n+            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());\n+            TEMP_OUTPUT_DIR.delete();\n+            TEMP_OUTPUT_DIR.mkdir();\n+        } catch (IOException e) {\n+            throw new PicardException(\"Couldn't create temp directory\") ;", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzMjAwOQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465132009", "bodyText": "Well...PicardException is a RuntimeException...but this was it's more clear that it comes from Picard...I don't mind either way....what's the argument for RuntimeException?", "author": "yfarjoun", "createdAt": "2020-08-04T15:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2MzA1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ2NDQyNw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464464427", "bodyText": "This is OK, an improvement would be to make this lazy, as not every test needs to create temp output. E.g.,\nprotected File getTempDir() {\n    if (TEMP_OUTPUT_DIR == null) {\n    ...\n}", "author": "pshapiro4broad", "createdAt": "2020-08-03T14:51:08Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -15,6 +20,24 @@\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NDQ1Nw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464474457", "bodyText": "Why not\nTEMP_OUTPUT_DIR = Files.createTempDirectory(getClass().getName()).toFile();", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:06:23Z", "path": "src/test/java/picard/cmdline/CommandLineProgramTest.java", "diffHunk": "@@ -15,6 +20,24 @@\n     public static final File CHR_M_REFERENCE = new File(REFERENCE_TEST_DIR,\"chrM.reference.fasta\");\n     public static final File CHR_M_DICT = new File(REFERENCE_TEST_DIR,\"chrM.reference.dict\");\n \n+\n+    // A per-test-class directory that will be deleted after the tests are complete.\n+    final protected File TEMP_OUTPUT_DIR;\n+    {\n+        try {\n+            TEMP_OUTPUT_DIR = File.createTempFile(FileUtils.getTempDirectory().getAbsolutePath(),this.getClass().getSimpleName());", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNjkyOA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465136928", "bodyText": "\ud83d\udc4d", "author": "yfarjoun", "createdAt": "2020-08-04T15:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3NDQ1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3OTUwNA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464479504", "bodyText": "It looks like this is a common case. You could add createTempFile to CommandLineProgramTest to avoid some typing.", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:14:45Z", "path": "src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java", "diffHunk": "@@ -51,8 +55,7 @@ public String getCommandLineProgramName() {\n     public void test() throws IOException {\n         final File input = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n         final File reference = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.fasta\");\n-        final File outfile = File.createTempFile(\"alignmentMetrics\", \".txt\");\n-        outfile.deleteOnExit();\n+        final File outfile = File.createTempFile(\"test\", \".txt\", TEMP_OUTPUT_DIR);", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDk4Ng==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465144986", "bodyText": "not much less typing...but OK.", "author": "yfarjoun", "createdAt": "2020-08-04T15:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3OTUwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4MjMyNg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464482326", "bodyText": "unnecessary array new: {{true}, {false}} should work here", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:19:26Z", "path": "src/test/java/picard/analysis/CollectAlignmentSummaryMetricsTest.java", "diffHunk": "@@ -642,4 +645,79 @@ public void testAdapterReads() throws IOException {\n             }\n         }\n     }\n+\n+    @DataProvider()\n+    Object[][] TrueFalse() {\n+        return new Object[][]{\n+                new Object[]{true},", "originalCommit": "c61879a92713afb1c79cd0b4a0e22aff38946d33", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NjMwMw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464486303", "bodyText": "unnecessary array creation\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String[] args = new String[] {\n          \n          \n            \n                    final String[] args = {", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:25:33Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -239,10 +300,49 @@ public void testLargeIntervals(final String useFastAlgorithm) throws IOException\n         }\n     }\n \n+    @Test(dataProvider = \"wgsDataProvider\")\n+    public void testSmallIntervals(final File input, final String reference_name,\n+                                   final String useFastAlgorithm) throws IOException {\n+        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n+        final File ref = new File(reference_name);\n+        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n+        final int sampleSize = 1000;\n+        final String[] args = new String[] {", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjEwNg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465146106", "bodyText": "\ud83e\udd2f", "author": "yfarjoun", "createdAt": "2020-08-04T15:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NjMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NjcwNg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464486706", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);\n          \n          \n            \n                    final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\", TEMP_OUTPUT_DIR);", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:26:08Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -239,10 +300,49 @@ public void testLargeIntervals(final String useFastAlgorithm) throws IOException\n         }\n     }\n \n+    @Test(dataProvider = \"wgsDataProvider\")\n+    public void testSmallIntervals(final File input, final String reference_name,\n+                                   final String useFastAlgorithm) throws IOException {\n+        final File outfile = File.createTempFile(\"testSmallIntervals\", \".wgs_metrics\",TEMP_OUTPUT_DIR);", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4NzcxMw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464487713", "bodyText": "whitespace\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n          \n          \n            \n                    setBuilder.addPair(\"all_in\", 0, 200, 200, false, false, \"100M\", \"100M\", true, false, 30);", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:27:37Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -208,11 +214,66 @@ void setupBuilder() throws IOException {\n         };\n     }\n \n+    @Test(dataProvider = \"wgsAlgorithm\")\n+    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n+\n+        final File ref = CHR_M_REFERENCE;\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n+\n+        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n+\n+        setBuilder.setReadLength(100);\n+\n+        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ4ODY5MA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464488690", "bodyText": "unnecessary new\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final String[] args = new String[]{\n          \n          \n            \n                    final String[] args = {", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:29:07Z", "path": "src/test/java/picard/analysis/CollectWgsMetricsTest.java", "diffHunk": "@@ -208,11 +214,66 @@ void setupBuilder() throws IOException {\n         };\n     }\n \n+    @Test(dataProvider = \"wgsAlgorithm\")\n+    public void testIntervalOneRead(final String useFastAlgorithm) throws IOException {\n+\n+        final File ref = CHR_M_REFERENCE;\n+        final File tempSamFile = VcfTestUtils.createTemporaryIndexedFile(\"testIntervalOneRead\", \".bam\", TEMP_OUTPUT_DIR);\n+\n+        final SAMRecordSetBuilder setBuilder = CollectWgsMetricsTestUtils.createTestSAMBuilder(ref, READ_GROUP_ID, SAMPLE, PLATFORM, LIBRARY);\n+\n+        setBuilder.setReadLength(100);\n+\n+        setBuilder.addPair(\"all_in\",0,200,200,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"half_in\",0,950,950,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"just_out\",0,1001,1001,false,false,\"100M\",\"100M\",true,false,30);\n+        setBuilder.addPair(\"one_base_in\",0,1000,1000,false,false,\"100M\",\"100M\",true,false,30);\n+\n+        final SamReader samReader = setBuilder.getSamReader();\n+\n+        // Write SAM file\n+        try (SAMFileWriter writer = new SAMFileWriterFactory()\n+                .setCreateIndex(true)\n+                .makeBAMWriter(samReader.getFileHeader(), false, tempSamFile)) {\n+            for (final SAMRecord record : samReader) {\n+                writer.addAlignment(record);\n+            }\n+        }\n+\n+        final File outfile = File.createTempFile(\"testIntervalOneRead\", \".wgs_metrics\", TEMP_OUTPUT_DIR);\n+        final File intervals = new File(TEST_DIR, \"smallIntervals.interval_list\");\n+        final int sampleSize = 1000;\n+        final String[] args = new String[]{", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5MTQwNw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464491407", "bodyText": "This seems like it could lead to problems, if someone changed the file while editing the other test but didn't realize the file was used here as well. If you made a separate constant for each file shared like this (e.g., build the path to the file in CollectAlignmentSummaryMetricsTest as a constant), that would at least make it easier to find other tests that depended on that file.", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:33:19Z", "path": "src/test/java/picard/analysis/CollectOxoGMetricsTest.java", "diffHunk": "@@ -12,7 +12,7 @@\n \n public class CollectOxoGMetricsTest {\n     private static final File TEST_DATA_DIR = new File(\"testdata/picard/sam/\");\n-    private static final File SAM_FILE = new File(TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");\n+    private static final File SAM_FILE = new File(CollectAlignmentSummaryMetricsTest.TEST_DATA_DIR, \"summary_alignment_stats_test.sam\");", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0ODY3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465148673", "bodyText": "This is no different than what it was (regarding someone changing the file) but at least now there's a variable that is traced to where it's being used...I fail to see how building the path from scratch helps...I moved the files into a subdirectory and suddenly other tests started failing....with this construction it will not happen...", "author": "yfarjoun", "createdAt": "2020-08-04T15:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5MTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5Mjc3NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464492774", "bodyText": "Why remove this null check? If this is null, it will cause TheoreticalSensitivity.normalizeHistogram to throw a PicardException.", "author": "pshapiro4broad", "createdAt": "2020-08-03T15:35:39Z", "path": "src/main/java/picard/analysis/WgsMetrics.java", "diffHunk": "@@ -290,23 +302,35 @@ public void calculateDerivedFields() {\n         MEDIAN_COVERAGE  = highQualityDepthHistogram.getMedian();\n         MAD_COVERAGE     = highQualityDepthHistogram.getMedianAbsoluteDeviation();\n \n-        PCT_1X    = MathUtil.sum(depthHistogramArray, 1, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n-        PCT_5X    = MathUtil.sum(depthHistogramArray, 5, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n-        PCT_10X   = MathUtil.sum(depthHistogramArray, 10, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_15X   = MathUtil.sum(depthHistogramArray, 15, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_20X   = MathUtil.sum(depthHistogramArray, 20, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_25X   = MathUtil.sum(depthHistogramArray, 25, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_30X   = MathUtil.sum(depthHistogramArray, 30, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_40X   = MathUtil.sum(depthHistogramArray, 40, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_50X   = MathUtil.sum(depthHistogramArray, 50, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_60X   = MathUtil.sum(depthHistogramArray, 60, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_70X   = MathUtil.sum(depthHistogramArray, 70, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_80X   = MathUtil.sum(depthHistogramArray, 80, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_90X   = MathUtil.sum(depthHistogramArray, 90, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n-        PCT_100X  = MathUtil.sum(depthHistogramArray, 100, depthHistogramArray.length) / (double) GENOME_TERRITORY;\n+        PCT_1X   = MathUtil.sum(depthHistogramArray, 1, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n+        PCT_5X   = MathUtil.sum(depthHistogramArray, 5, depthHistogramArray.length)   / (double) GENOME_TERRITORY;\n+        PCT_10X  = MathUtil.sum(depthHistogramArray, 10, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_15X  = MathUtil.sum(depthHistogramArray, 15, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_20X  = MathUtil.sum(depthHistogramArray, 20, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_25X  = MathUtil.sum(depthHistogramArray, 25, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_30X  = MathUtil.sum(depthHistogramArray, 30, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_40X  = MathUtil.sum(depthHistogramArray, 40, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_50X  = MathUtil.sum(depthHistogramArray, 50, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_60X  = MathUtil.sum(depthHistogramArray, 60, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_70X  = MathUtil.sum(depthHistogramArray, 70, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_80X  = MathUtil.sum(depthHistogramArray, 80, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_90X  = MathUtil.sum(depthHistogramArray, 90, depthHistogramArray.length)  / (double) GENOME_TERRITORY;\n+        PCT_100X = MathUtil.sum(depthHistogramArray, 100, depthHistogramArray.length) / (double) GENOME_TERRITORY;\n+\n+\n+        // This roughly measures by how much we must over-sequence so that xx% of bases have coverage at least as deep as the current mean coverage:\n+        if (highQualityDepthHistogram.getCount() > 0) {\n+            FOLD_80_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.2);\n+            FOLD_90_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.1);\n+            FOLD_95_BASE_PENALTY = MEAN_COVERAGE / highQualityDepthHistogram.getPercentile(0.05);\n+        } else {\n+            FOLD_80_BASE_PENALTY = 0;\n+            FOLD_90_BASE_PENALTY = 0;\n+            FOLD_95_BASE_PENALTY = 0;\n+        }\n \n         // Get Theoretical Het SNP Sensitivity\n-        if (unfilteredBaseQHistogram != null && unfilteredDepthHistogram != null) {\n+        if (unfilteredBaseQHistogram != null) {", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0OTUyMQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465149521", "bodyText": "", "author": "yfarjoun", "createdAt": "2020-08-04T15:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5Mjc3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0OTk1Ng==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465149956", "bodyText": "already checked in the first line of test", "author": "yfarjoun", "createdAt": "2020-08-04T15:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ5Mjc3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MTcxMQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464581711", "bodyText": "= 0 initializers unnecessary", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:13:57Z", "path": "src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java", "diffHunk": "@@ -103,148 +104,206 @@ public GroupAlignmentSummaryMetricsPerUnitMetricCollector(final String sample, f\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MTc5MQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464581791", "bodyText": "can be final, I think", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:14:08Z", "path": "src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java", "diffHunk": "@@ -103,148 +104,206 @@ public GroupAlignmentSummaryMetricsPerUnitMetricCollector(final String sample, f\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;\n+        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n+        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n+\n+        private AlignmentSummaryMetrics metrics;", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MzU5Mw==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464583593", "bodyText": "I wouldn't normally comment on this. but the code is inconsistent in its use. Why do these use this. but no other fields do? I think it would be better to omit them completely unless necessary for disambiguation purposes.", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:17:41Z", "path": "src/main/java/picard/analysis/AlignmentSummaryMetricsCollector.java", "diffHunk": "@@ -103,148 +104,206 @@ public GroupAlignmentSummaryMetricsPerUnitMetricCollector(final String sample, f\n             this.sample = sample;\n             this.library = library;\n             this.readGroup = readGroup;\n-            unpairedCollector     = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n-            firstOfPairCollector  = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n+            unpairedCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.UNPAIRED, sample, library, readGroup);\n+            firstOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.FIRST_OF_PAIR, sample, library, readGroup);\n             secondOfPairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.SECOND_OF_PAIR, sample, library, readGroup);\n-            pairCollector         = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n+            pairCollector = new IndividualAlignmentSummaryMetricsCollector(AlignmentSummaryMetrics.Category.PAIR, sample, library, readGroup);\n         }\n \n         public void acceptRecord(final SAMRecordAndReference args) {\n-            final SAMRecord rec         = args.getSamRecord();\n-            final ReferenceSequence ref = args.getReferenceSequence();\n \n-            if (rec.getReadPairedFlag()) {\n-                if (rec.getFirstOfPairFlag()) {\n-                    firstOfPairCollector.addRecord(rec, ref);\n+            if (args.getSamRecord().getReadPairedFlag()) {\n+                if (args.getSamRecord().getFirstOfPairFlag()) {\n+                    firstOfPairCollector.acceptRecord(args);\n                 } else {\n-                    secondOfPairCollector.addRecord(rec, ref);\n+                    secondOfPairCollector.acceptRecord(args);\n                 }\n \n-                pairCollector.addRecord(rec, ref);\n+                pairCollector.acceptRecord(args);\n             } else {\n-                unpairedCollector.addRecord(rec, ref);\n+                unpairedCollector.acceptRecord(args);\n             }\n         }\n \n         @Override\n         public void finish() {\n             // Let the collectors do any summary computations etc.\n-            unpairedCollector.onComplete();\n-            firstOfPairCollector.onComplete();\n-            secondOfPairCollector.onComplete();\n-            pairCollector.onComplete();\n+            unpairedCollector.finish();\n+            firstOfPairCollector.finish();\n+            secondOfPairCollector.finish();\n+            pairCollector.finish();\n         }\n \n         @Override\n-        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Comparable<?>> file) {\n+        public void addMetricsToFile(final MetricsFile<AlignmentSummaryMetrics, Integer> file) {\n             if (firstOfPairCollector.getMetrics().TOTAL_READS > 0) {\n                 // override how bad cycle is determined for paired reads, it should be\n                 // the sum of first and second reads\n                 pairCollector.getMetrics().BAD_CYCLES = firstOfPairCollector.getMetrics().BAD_CYCLES +\n                         secondOfPairCollector.getMetrics().BAD_CYCLES;\n \n-                file.addMetric(firstOfPairCollector.getMetrics());\n-                file.addMetric(secondOfPairCollector.getMetrics());\n-                file.addMetric(pairCollector.getMetrics());\n+                firstOfPairCollector.addMetricsToFile(file);\n+                secondOfPairCollector.addMetricsToFile(file);\n+                pairCollector.addMetricsToFile(file);\n             }\n \n-            //if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n+            // if there are no reads in any category then we will returned an unpaired alignment summary metric with all zero values\n             if (unpairedCollector.getMetrics().TOTAL_READS > 0 || firstOfPairCollector.getMetrics().TOTAL_READS == 0) {\n-                file.addMetric(unpairedCollector.getMetrics());\n+                unpairedCollector.addMetricsToFile(file);\n             }\n         }\n+    }\n \n-        /**\n-         * Class that counts reads that match various conditions\n-         */\n-        private class IndividualAlignmentSummaryMetricsCollector {\n-            private long numPositiveStrand = 0;\n-            private final Histogram<Integer> readLengthHistogram = new Histogram<>();\n-            private AlignmentSummaryMetrics metrics;\n-            private long chimeras;\n-            private long chimerasDenominator;\n-            private long adapterReads;\n-            private long indels;\n-\n-            private long nonBisulfiteAlignedBases = 0;\n-            private long hqNonBisulfiteAlignedBases = 0;\n-            private final Histogram<Long> mismatchHistogram = new Histogram<>();\n-            private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n-            private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n-\n-            public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n-                                                              final String sample,\n-                                                              final String library,\n-                                                              final String readGroup) {\n-                metrics = new AlignmentSummaryMetrics();\n-                metrics.CATEGORY = pairingCategory;\n-                metrics.SAMPLE = sample;\n-                metrics.LIBRARY = library;\n-                metrics.READ_GROUP = readGroup;\n-            }\n+    /**\n+     * Class that counts reads that match various conditions\n+     */\n+    public class IndividualAlignmentSummaryMetricsCollector implements PerUnitMetricCollector<AlignmentSummaryMetrics, Integer, SAMRecordAndReference> {\n+        private long numPositiveStrand = 0;\n+        private final Histogram<Integer> readLengthHistogram = new Histogram<>(\"count\", \"readLength\");\n+        private final Histogram<Integer> alignedReadLengthHistogram = new Histogram<>(\"count\", \"alignedReadLength\");\n+\n+        private AlignmentSummaryMetrics metrics;\n+        private long chimeras;\n+        private long chimerasDenominator;\n+        private long adapterReads;\n+        private long indels;\n+\n+        private long numSoftClipped;\n+        private long numHardClipped;\n+\n+        private long nonBisulfiteAlignedBases = 0;\n+        private long hqNonBisulfiteAlignedBases = 0;\n+        private final Histogram<Long> mismatchHistogram = new Histogram<>();\n+        private final Histogram<Long> hqMismatchHistogram = new Histogram<>();\n+        private final Histogram<Integer> badCycleHistogram = new Histogram<>();\n+\n+        public IndividualAlignmentSummaryMetricsCollector(final AlignmentSummaryMetrics.Category pairingCategory,\n+                                                          final String sample,\n+                                                          final String library,\n+                                                          final String readGroup) {\n+            metrics = new AlignmentSummaryMetrics();\n+            metrics.CATEGORY = pairingCategory;\n+            metrics.SAMPLE = sample;\n+            metrics.LIBRARY = library;\n+            metrics.READ_GROUP = readGroup;\n+        }\n \n-            public void addRecord(final SAMRecord record, final ReferenceSequence ref) {\n-                if (record.getNotPrimaryAlignmentFlag()) {\n-                    // only want 1 count per read so skip non primary alignments\n-                    return;\n-                }\n+        public void acceptRecord(final SAMRecordAndReference samRecordAndReference) {\n+            final SAMRecord record = samRecordAndReference.getSamRecord();\n+            final ReferenceSequence ref = samRecordAndReference.getReferenceSequence();\n \n-                collectReadData(record);\n-                collectQualityData(record, ref);\n+            if (record.isSecondaryAlignment()) {\n+                // only want 1 count per read so skip non-primary alignments\n+                return;\n             }\n \n-            public void onComplete() {\n-                //summarize read data\n-                if (metrics.TOTAL_READS > 0)\n-                {\n-                    metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n-                    metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n-                    metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n-\n-                    //Calculate BAD_CYCLES\n-                    metrics.BAD_CYCLES = 0;\n-                    for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n-                        final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n-                        if (badCyclePercentage >= 0.8) {\n-                            metrics.BAD_CYCLES++;\n-                        }\n-                    }\n+            collectReadData(record);\n+            collectQualityData(record, ref);\n+        }\n \n-                    if(doRefMetrics) {\n-                        metrics.PCT_PF_READS_ALIGNED =  MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n-                        metrics.PCT_READS_ALIGNED_IN_PAIRS =  MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_PF_READS_IMPROPER_PAIRS =  MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.STRAND_BALANCE =  MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n-                        metrics.PCT_CHIMERAS =  MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);\n-                        metrics.PF_INDEL_RATE =  MathUtil.divide(this.indels, (double) metrics.PF_ALIGNED_BASES);\n-                        metrics.PF_MISMATCH_RATE =  MathUtil.divide(mismatchHistogram.getSum(), (double) nonBisulfiteAlignedBases);\n-                        metrics.PF_HQ_ERROR_RATE =  MathUtil.divide(hqMismatchHistogram.getSum(), (double) hqNonBisulfiteAlignedBases);\n-\n-                        metrics.PF_HQ_MEDIAN_MISMATCHES = hqMismatchHistogram.getMedian();\n+        @Override\n+        public void finish() {\n+            //summarize read data\n+            if (metrics.TOTAL_READS > 0) {\n+                metrics.PCT_PF_READS = (double) metrics.PF_READS / (double) metrics.TOTAL_READS;\n+                metrics.PCT_ADAPTER = this.adapterReads / (double) metrics.PF_READS;\n+                metrics.MEAN_READ_LENGTH = readLengthHistogram.getMean();\n+\n+                //Calculate BAD_CYCLES\n+                metrics.BAD_CYCLES = 0;\n+                for (final Histogram.Bin<Integer> cycleBin : badCycleHistogram.values()) {\n+                    final double badCyclePercentage = cycleBin.getValue() / metrics.TOTAL_READS;\n+                    if (badCyclePercentage >= 0.8) {\n+                        metrics.BAD_CYCLES++;\n                     }\n                 }\n+\n+                if (doRefMetrics) {\n+                    metrics.PCT_PF_READS_ALIGNED = MathUtil.divide((double) metrics.PF_READS_ALIGNED, (double) metrics.PF_READS);\n+                    metrics.PCT_READS_ALIGNED_IN_PAIRS = MathUtil.divide((double) metrics.READS_ALIGNED_IN_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_PF_READS_IMPROPER_PAIRS = MathUtil.divide((double) metrics.PF_READS_IMPROPER_PAIRS, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.STRAND_BALANCE = MathUtil.divide(numPositiveStrand, (double) metrics.PF_READS_ALIGNED);\n+                    metrics.PCT_CHIMERAS = MathUtil.divide(this.chimeras, (double) this.chimerasDenominator);", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4NjY0NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464586644", "bodyText": "unnecessary ;\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    };\n          \n          \n            \n                    }", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:23:52Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -432,17 +555,19 @@ public SinglePassSamProgram makeInstance(final String outbase,\n                                                      final File refflat,\n                                                      final Set<String> ignoreSequence) {\n                 final CollectQualityYieldMetrics program = new CollectQualityYieldMetrics();\n-                program.output = new RequiredOutputArgumentCollection(new File(outbase + \".quality_yield_metrics\" + outext));\n+                program.output = new RequiredOutputArgumentCollection(new File(outbase + METRIC_EXTENSION + outext));\n                 // Generally programs should not be accessing these directly but it might make things smoother\n                 // to just set them anyway. These are set here to make sure that in case of a the derived class\n                 // overrides\n                 program.INPUT = input;\n \n                 return program;\n             }\n-        }\n+        };", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwNjg2NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465306864", "bodyText": "", "author": "yfarjoun", "createdAt": "2020-08-04T20:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4NjY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4OTI2OA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464589268", "bodyText": "why makeList instead of Arrays.asList?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n          \n          \n            \n                        final List<String> OUTPUT_EXTENSIONS = Arrays.asList(", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:29:06Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -194,6 +209,19 @@ public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".insert_size_metrics\";\n+            final String PDF_EXTENSION = \".insert_size_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MDg0Mg==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464590842", "bodyText": "It looks like this is the same for most (all?) subclasses. If you make USAGE_SUMMARY and OUTPUT_EXTENSIONS either constructor arguments or abstract methods then the duplicate code can be removed.", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:32:20Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -157,13 +156,28 @@ default boolean supportsMetricAccumulationLevel() {\n         }\n     }\n \n-    public enum Program implements ProgramInterface {\n+    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n+\n         CollectAlignmentSummaryMetrics {\n+\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n+            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n+                    METRICS_EXTENSION,\n+                    PDF_EXTENSION);\n+\n+            @Override\n+            public String getHelpDoc() {", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTAyNQ==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r464591025", "bodyText": "I think this should be CollectAlignmentSummaryMetrics.USAGE_SUMMARY", "author": "pshapiro4broad", "createdAt": "2020-08-03T18:32:47Z", "path": "src/main/java/picard/analysis/CollectMultipleMetrics.java", "diffHunk": "@@ -157,13 +156,28 @@ default boolean supportsMetricAccumulationLevel() {\n         }\n     }\n \n-    public enum Program implements ProgramInterface {\n+    public enum Program implements ProgramInterface, CommandLineParser.ClpEnum {\n+\n         CollectAlignmentSummaryMetrics {\n+\n             @Override\n             public boolean supportsMetricAccumulationLevel() {\n                 return true;\n             }\n \n+            final String METRICS_EXTENSION = \".alignment_summary_metrics\";\n+            final String PDF_EXTENSION = \".read_length_histogram.pdf\";\n+\n+            final List<String> OUTPUT_EXTENSIONS = CollectionUtil.makeList(\n+                    METRICS_EXTENSION,\n+                    PDF_EXTENSION);\n+\n+            @Override\n+            public String getHelpDoc() {\n+                return picard.analysis.CollectInsertSizeMetrics.USAGE_SUMMARY +", "originalCommit": "3ac7222a52d17630ff5c8a2eda6977a6fd1c776f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2NTg5NA==", "url": "https://github.com/broadinstitute/picard/pull/1555#discussion_r465165894", "bodyText": "oops. good catch.", "author": "yfarjoun", "createdAt": "2020-08-04T16:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5MTAyNQ=="}], "type": "inlineReview"}, {"oid": "b92438175bcb131ae681e3e3f362714c0f9d0cd1", "url": "https://github.com/broadinstitute/picard/commit/b92438175bcb131ae681e3e3f362714c0f9d0cd1", "message": "WIP", "committedDate": "2020-08-04T20:30:36Z", "type": "commit"}, {"oid": "690fdc6532393877c3a6b04dffad0eee688223d6", "url": "https://github.com/broadinstitute/picard/commit/690fdc6532393877c3a6b04dffad0eee688223d6", "message": "WIP", "committedDate": "2020-08-04T20:30:36Z", "type": "commit"}, {"oid": "6cc4f7e319f7b89abdfafe494e17930ceefcb659", "url": "https://github.com/broadinstitute/picard/commit/6cc4f7e319f7b89abdfafe494e17930ceefcb659", "message": "WIP", "committedDate": "2020-08-04T20:30:36Z", "type": "commit"}, {"oid": "70768b2f7a2e6ac0d05bf84805ef1159ff428372", "url": "https://github.com/broadinstitute/picard/commit/70768b2f7a2e6ac0d05bf84805ef1159ff428372", "message": "Several changes to metrics collections:\n\n- Added Clips (Soft and Hard) to AlignmentSummaryMetrics\n- Added read-length histogram and pdf output to AlignmentSummaryMetrics\n- Added Tests\n- Added a TEMP_OUTPUT_DIR to CommandLineProgramTest.java which is delete once the derived class is done testing\n- Modified Two test classes to use TEMP_OUTPUT_DIR\n- Modified enum in CollectMultipleMetrics so that it will display what the options are and what each program does in the help.", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "c515e9b634464d0ef8943e2f95bf8097b849c7db", "url": "https://github.com/broadinstitute/picard/commit/c515e9b634464d0ef8943e2f95bf8097b849c7db", "message": "- fixed failing tests (moved files)\n- fixed fialing test (protect against empty histogram)", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "215e12c2b44dc6741692d7f9b79c631b62bc3c80", "url": "https://github.com/broadinstitute/picard/commit/215e12c2b44dc6741692d7f9b79c631b62bc3c80", "message": "- testing failures (ggplot2?)\n- fixing other tests failures", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "64f74350f783534af23e030e0a0a4dfdb4edb7d0", "url": "https://github.com/broadinstitute/picard/commit/64f74350f783534af23e030e0a0a4dfdb4edb7d0", "message": "- test that one can load the reshape library in R in the test env", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "8891b58d1f994cd189997156ca43c82be0c0368b", "url": "https://github.com/broadinstitute/picard/commit/8891b58d1f994cd189997156ca43c82be0c0368b", "message": "- add test with library in R", "committedDate": "2020-08-04T20:30:37Z", "type": "commit"}, {"oid": "05d03a38f6f8ff2280532846e2417c8fbdd744d7", "url": "https://github.com/broadinstitute/picard/commit/05d03a38f6f8ff2280532846e2417c8fbdd744d7", "message": "- now plotting like a champ...no ggplot, no reshape2....", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "d3c121a38e71b082868514291b0baffd91544644", "url": "https://github.com/broadinstitute/picard/commit/d3c121a38e71b082868514291b0baffd91544644", "message": "- responding to review comments", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "8e5b875089475c999ffec862886d9fb2868049bf", "url": "https://github.com/broadinstitute/picard/commit/8e5b875089475c999ffec862886d9fb2868049bf", "message": "remove r_packages test since we do not have these packages in the r distribution we use.", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "d1d17547088339055368553a9411cee98dd9fcae", "url": "https://github.com/broadinstitute/picard/commit/d1d17547088339055368553a9411cee98dd9fcae", "message": "- updated the javaDoc", "committedDate": "2020-08-04T20:30:38Z", "type": "commit"}, {"oid": "d1d17547088339055368553a9411cee98dd9fcae", "url": "https://github.com/broadinstitute/picard/commit/d1d17547088339055368553a9411cee98dd9fcae", "message": "- updated the javaDoc", "committedDate": "2020-08-04T20:30:38Z", "type": "forcePushed"}]}