{"pr_number": 1465, "pr_title": "Removed plain `assert`s and replaced them with ValidationUtil function", "pr_createdAt": "2020-02-09T12:18:37Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1465", "timeline": [{"oid": "daead95bf4086294061167556e98fae28588e890", "url": "https://github.com/broadinstitute/picard/commit/daead95bf4086294061167556e98fae28588e890", "message": "- removed plain `assert`s and replaced them with ValidationUtil functions.\n- some asserts remain, but they have been fixed in a different PR.", "committedDate": "2020-02-10T20:05:01Z", "type": "commit"}, {"oid": "daead95bf4086294061167556e98fae28588e890", "url": "https://github.com/broadinstitute/picard/commit/daead95bf4086294061167556e98fae28588e890", "message": "- removed plain `assert`s and replaced them with ValidationUtil functions.\n- some asserts remain, but they have been fixed in a different PR.", "committedDate": "2020-02-10T20:05:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY3NjMwNg==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r377676306", "bodyText": "In this case, why not throw new PicardException(\"Invalid allele index: \" + alleleIdx);? This doesn't seem like a proper use of validateArg().", "author": "pshapiro4broad", "createdAt": "2020-02-11T14:42:15Z", "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -45,7 +47,7 @@\n         public static TruthState getHom(final int alleleIdx) {\n             if (alleleIdx == 0) return HOM_REF;\n             if (alleleIdx == 1) return HOM_VAR1;\n-            assert false;\n+            ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "originalCommit": "daead95bf4086294061167556e98fae28588e890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NDk3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378984973", "bodyText": "@yfarjoun Wait, I lied, you didn't respond to Phil here.", "author": "lbergelson", "createdAt": "2020-02-13T16:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY3NjMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY3NzA2MQ==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r377677061", "bodyText": "Please reformat the changed lines in the IDE. In this case I would expect to see spaces around the -> operator, and the line length seems long to me.", "author": "pshapiro4broad", "createdAt": "2020-02-11T14:43:21Z", "path": "src/main/java/picard/analysis/CollectWgsMetricsWithNonZeroCoverage.java", "diffHunk": "@@ -186,7 +187,7 @@ protected WgsMetrics generateWgsMetrics(final IntervalList intervals,\n \n     @Override\n     protected WgsMetricsCollector getCollector(final int coverageCap, final IntervalList intervals) {\n-        assert(coverageCap == this.collector.coverageCap);\n+        ValidationUtils.validateArg(coverageCap == this.collector.coverageCap,()->\"coverageCap has to be the same as the internal coverageCap, found \" + coverageCap + \" and \" + this.collector.coverageCap);", "originalCommit": "daead95bf4086294061167556e98fae28588e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY3ODEzMQ==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r377678131", "bodyText": "Did you mean to delete this class? This seems unrelated to your other changes, and maybe deserves its own PR.", "author": "pshapiro4broad", "createdAt": "2020-02-11T14:45:03Z", "path": "src/main/java/picard/fastq/BamToBfqWriter.java", "diffHunk": "@@ -1,444 +1,446 @@\n-/*\r\n- * The MIT License\r\n- *\r\n- * Copyright (c) 2009 The Broad Institute\r\n- *\r\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n- * of this software and associated documentation files (the \"Software\"), to deal\r\n- * in the Software without restriction, including without limitation the rights\r\n- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n- * copies of the Software, and to permit persons to whom the Software is\r\n- * furnished to do so, subject to the following conditions:\r\n- *\r\n- * The above copyright notice and this permission notice shall be included in\r\n- * all copies or substantial portions of the Software.\r\n- *\r\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n- * THE SOFTWARE.\r\n- */\r\n-package picard.fastq;\r\n-\r\n-import htsjdk.samtools.ReservedTagConstants;\r\n-import htsjdk.samtools.SAMFileHeader;\r\n-import htsjdk.samtools.SAMRecord;\r\n-import htsjdk.samtools.SamReader;\r\n-import htsjdk.samtools.SamReaderFactory;\r\n-import htsjdk.samtools.filter.AggregateFilter;\r\n-import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\r\n-import htsjdk.samtools.filter.FilteringSamIterator;\r\n-import htsjdk.samtools.filter.SamRecordFilter;\r\n-import htsjdk.samtools.filter.TagFilter;\r\n-import htsjdk.samtools.filter.WholeReadClippedFilter;\r\n-import htsjdk.samtools.util.BinaryCodec;\r\n-import htsjdk.samtools.util.CloserUtil;\r\n-import htsjdk.samtools.util.IOUtil;\r\n-import htsjdk.samtools.util.Log;\r\n-import htsjdk.samtools.util.PeekableIterator;\r\n-import picard.PicardException;\r\n-\r\n-import java.io.File;\r\n-import java.util.ArrayList;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-\r\n-/**\r\n- * Class to take unmapped reads in BAM file format and create Maq binary fastq format file(s) --\r\n- * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\r\n- * BAM file having all paired reads together in order.\r\n- */\r\n-public class BamToBfqWriter {\r", "originalCommit": "daead95bf4086294061167556e98fae28588e890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgwMzQ5Mw==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378803493", "bodyText": "this seemed to have been due to the rebase...I didn't do it...", "author": "yfarjoun", "createdAt": "2020-02-13T11:26:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY3ODEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTM1Mg==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r377875352", "bodyText": "just throw here", "author": "lbergelson", "createdAt": "2020-02-11T20:19:30Z", "path": "src/test/java/picard/fingerprint/CrosscheckFingerprintsTest.java", "diffHunk": "@@ -948,7 +949,7 @@ private void doTest(final String[] args, final File metrics, final int expectedR\n \n             } catch (NoSuchFieldException e) {\n                 e.printStackTrace();\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "originalCommit": "daead95bf4086294061167556e98fae28588e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTY1OA==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r377875658", "bodyText": "Just throw if we shouldn't be here.", "author": "lbergelson", "createdAt": "2020-02-11T20:20:07Z", "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -56,7 +58,7 @@ public static TruthState getVar(final int allele0idx, final int allele1idx) {\n             if (allele0idx == 1 && allele1idx == 2) return HET_VAR1_VAR2;\n             if (allele0idx == 2 && allele1idx == 1) return HET_VAR1_VAR2;\n \n-            assert false;\n+            ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "originalCommit": "daead95bf4086294061167556e98fae28588e890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NTA1MQ==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378985051", "bodyText": "Same", "author": "lbergelson", "createdAt": "2020-02-13T16:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg3NTY1OA=="}], "type": "inlineReview"}, {"oid": "433e35081818cac6103490113f3cb48fae50a491", "url": "https://github.com/broadinstitute/picard/commit/433e35081818cac6103490113f3cb48fae50a491", "message": "- responding to review comments", "committedDate": "2020-02-13T11:32:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgwNzM5Mw==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378807393", "bodyText": "this is the actual change in the file...everything else is due to newline differences.....", "author": "yfarjoun", "createdAt": "2020-02-13T11:36:06Z", "path": "src/main/java/picard/fastq/BamToBfqWriter.java", "diffHunk": "@@ -1,444 +1,446 @@\n-/*\r\n- * The MIT License\r\n- *\r\n- * Copyright (c) 2009 The Broad Institute\r\n- *\r\n- * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n- * of this software and associated documentation files (the \"Software\"), to deal\r\n- * in the Software without restriction, including without limitation the rights\r\n- * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n- * copies of the Software, and to permit persons to whom the Software is\r\n- * furnished to do so, subject to the following conditions:\r\n- *\r\n- * The above copyright notice and this permission notice shall be included in\r\n- * all copies or substantial portions of the Software.\r\n- *\r\n- * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n- * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n- * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n- * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n- * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n- * THE SOFTWARE.\r\n- */\r\n-package picard.fastq;\r\n-\r\n-import htsjdk.samtools.ReservedTagConstants;\r\n-import htsjdk.samtools.SAMFileHeader;\r\n-import htsjdk.samtools.SAMRecord;\r\n-import htsjdk.samtools.SamReader;\r\n-import htsjdk.samtools.SamReaderFactory;\r\n-import htsjdk.samtools.filter.AggregateFilter;\r\n-import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\r\n-import htsjdk.samtools.filter.FilteringSamIterator;\r\n-import htsjdk.samtools.filter.SamRecordFilter;\r\n-import htsjdk.samtools.filter.TagFilter;\r\n-import htsjdk.samtools.filter.WholeReadClippedFilter;\r\n-import htsjdk.samtools.util.BinaryCodec;\r\n-import htsjdk.samtools.util.CloserUtil;\r\n-import htsjdk.samtools.util.IOUtil;\r\n-import htsjdk.samtools.util.Log;\r\n-import htsjdk.samtools.util.PeekableIterator;\r\n-import picard.PicardException;\r\n-\r\n-import java.io.File;\r\n-import java.util.ArrayList;\r\n-import java.util.Iterator;\r\n-import java.util.List;\r\n-\r\n-/**\r\n- * Class to take unmapped reads in BAM file format and create Maq binary fastq format file(s) --\r\n- * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\r\n- * BAM file having all paired reads together in order.\r\n- */\r\n-public class BamToBfqWriter {\r\n-\r\n-    private static final int SEED_REGION_LENGTH = 28;\r\n-    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\r\n-\r\n-    private final File bamFile;\r\n-    private final String outputPrefix;\r\n-    private final String namePrefix;\r\n-    private final int nameTrim;\r\n-    private boolean pairedReads = false;\r\n-    private int wrote = 0;\r\n-    private int increment = 1;\r\n-    private int chunk = 0;\r\n-    private BinaryCodec codec1;\r\n-    private BinaryCodec codec2;\r\n-    private final Log log = Log.getInstance(BamToBfqWriter.class);\r\n-    private final boolean includeNonPfReads;\r\n-    private final boolean clipAdapters;\r\n-    private final Integer basesToWrite;\r\n-\r\n-    /**\r\n-     * Constructor\r\n-     *\r\n-     * @param bamFile        the BAM file to read from\r\n-     * @param outputPrefix   the directory and file prefix for the binary fastq files\r\n-     * @param total          the total number of records that should be written, drawn evenly\r\n-     *                       from throughout the file (null for all).\r\n-     * @param chunk          the maximum number of records that should be written to any one file\r\n-     * @param pairedReads    whether these reads are from  a paired-end run\r\n-     * @param namePrefix     The string to be stripped off the read name\r\n-     *                       before writing to the bfq file. May be null, in which case\r\n-     *                       the name will not be trimmed.\r\n-     * @param includeNonPfReads whether to include non pf-reads\r\n-     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\r\n-     */\r\n-    public BamToBfqWriter(final File bamFile, final String outputPrefix, final Integer total,\r\n-                          final Integer chunk, final boolean pairedReads, String namePrefix,\r\n-                          boolean includeNonPfReads, boolean clipAdapters, Integer basesToWrite) {\r\n-\r\n-        IOUtil.assertFileIsReadable(bamFile);\r\n-        this.bamFile = bamFile;\r\n-        this.outputPrefix = outputPrefix;\r\n-        this.pairedReads = pairedReads;\r\n-        if (total != null) {\r\n-            final double writeable = (double)countWritableRecords();\r\n-            this.increment = (int)Math.floor(writeable/total.doubleValue());\r\n-            if (this.increment == 0) {\r\n-                this.increment = 1;\r\n-            }\r\n-        }\r\n-        if (chunk != null) {\r\n-            this.chunk = chunk;\r\n-        }\r\n-        this.namePrefix = namePrefix;\r\n-        this.nameTrim = namePrefix != null ? namePrefix.length() : 0;\r\n-        this.includeNonPfReads = includeNonPfReads;\r\n-        this.clipAdapters = clipAdapters;\r\n-        this.basesToWrite = basesToWrite;\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructor\r\n-     *\r\n-     * @param bamFile   the BAM file to read from\r\n-     * @param outputPrefix   the directory and file prefix for the binary fastq files\r\n-     * @param pairedReads    whether these reads are from  a paired-end run\r\n-     * @param namePrefix     the barcode of the run (to be stripped off the read name\r\n-     *                       before writing to the bfq file)\r\n-     * @param includeNonPfReads whether to include non pf-reads\r\n-     */\r\n-    public BamToBfqWriter(final File bamFile, final String outputPrefix, final boolean pairedReads,\r\n-                          String namePrefix, boolean includeNonPfReads) {\r\n-        this(bamFile, outputPrefix, null, null, pairedReads, namePrefix, includeNonPfReads, true, null);\r\n-    }\r\n- \r\n-    /**\r\n-     * Writes the binary fastq file(s) to the output directory\r\n-     */\r\n-    public void writeBfqFiles() {\r\n-\r\n-        final SamReader reader = SamReaderFactory.makeDefault().open(bamFile);\r\n-        final Iterator<SAMRecord> iterator = reader.iterator();\r\n-\r\n-        // Filter out noise reads and reads that fail the quality filter\r\n-        final TagFilter tagFilter = new TagFilter(ReservedTagConstants.XN, 1);\r\n-        final FailsVendorReadQualityFilter qualityFilter = new FailsVendorReadQualityFilter();\r\n-        final WholeReadClippedFilter clippedFilter = new WholeReadClippedFilter();\r\n-\r\n-\r\n-        if (!pairedReads) {\r\n-            List<SamRecordFilter> filters = new ArrayList<SamRecordFilter>();\r\n-            filters.add(tagFilter);\r\n-            filters.add(clippedFilter);\r\n-            if (!this.includeNonPfReads) {\r\n-                filters.add(qualityFilter);\r\n-            }\r\n-            writeSingleEndBfqs(iterator, filters);\r\n-            codec1.close();\r\n-        }\r\n-        else {\r\n-            writePairedEndBfqs(iterator, tagFilter, qualityFilter, clippedFilter);\r\n-            codec1.close();\r\n-            codec2.close();\r\n-        }\r\n-        log.info(\"Wrote \" + wrote + \" bfq records.\");\r\n-        CloserUtil.close(reader);\r\n-    }\r\n-\r\n-    /**\r\n-     * Path for writing bfqs for paired-end reads\r\n-     *\r\n-     * @param iterator      the iterator witht he SAM Records to write\r\n-     * @param tagFilter     the filter for noise reads\r\n-     * @param qualityFilter the filter for PF reads\r\n-     */\r\n-    private void writePairedEndBfqs(final Iterator<SAMRecord> iterator, final TagFilter tagFilter,\r\n-                                    final FailsVendorReadQualityFilter qualityFilter,\r\n-                                    SamRecordFilter ... otherFilters) {\r\n-        // Open the codecs for writing\r\n-        int fileIndex = 0;\r\n-        initializeNextBfqFiles(fileIndex++);\r\n-\r\n-        int records = 0;\r\n-\r\n-        RECORD_LOOP: while (iterator.hasNext()) {\r\n-            final SAMRecord first = iterator.next();\r\n-            if (!iterator.hasNext()) {\r\n-                throw new PicardException(\"Mismatched number of records in \" + this.bamFile.getAbsolutePath());\r\n-            }\r\n-            final SAMRecord second = iterator.next();\r\n-            if (!second.getReadName().equals(first.getReadName()) ||\r\n-                first.getFirstOfPairFlag() == second.getFirstOfPairFlag()) {\r\n-                throw new PicardException(\"Unmatched read pairs in \" + this.bamFile.getAbsolutePath() +\r\n-                    \": \" + first.getReadName() + \", \" + second.getReadName() + \".\");\r\n-            }\r\n-\r\n-            // If *both* are noise reads, filter them out\r\n-            if (tagFilter.filterOut(first) && tagFilter.filterOut(second))  {\r\n-                continue;\r\n-            }\r\n-\r\n-            // If either fails to pass filter, then exclude them as well\r\n-            if (!includeNonPfReads && (qualityFilter.filterOut(first) || qualityFilter.filterOut(second))) {\r\n-                continue;\r\n-            }\r\n-\r\n-            // If either fails any of the other filters, exclude them both\r\n-            for (SamRecordFilter filter : otherFilters) {\r\n-                if (filter.filterOut(first) || filter.filterOut(second)) {\r\n-                    continue RECORD_LOOP;\r\n-                }\r\n-            }\r\n-\r\n-            // Otherwise, write them out\r\n-            records++;\r\n-            if (records % increment == 0) {\r\n-                first.setReadName(first.getReadName() + \"/1\");\r\n-                writeFastqRecord(first.getFirstOfPairFlag() ? codec1 : codec2, first);\r\n-                second.setReadName(second.getReadName() + \"/2\");\r\n-                writeFastqRecord(second.getFirstOfPairFlag() ? codec1 : codec2, second);\r\n-                wrote++;\r\n-                if (wrote % 1000000 == 0) {\r\n-                    log.info(wrote + \" records written.\");\r\n-                }\r\n-                if (chunk > 0 && wrote % chunk == 0) {\r\n-                    initializeNextBfqFiles(fileIndex++);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Path for writing bfqs for single-end reads\r\n-     *\r\n-     * @param iterator  the iterator with he SAM Records to write\r\n-     * @param filters   the list of filters to be applied\r\n-     */\r\n-    private void writeSingleEndBfqs(final Iterator<SAMRecord> iterator, final List<SamRecordFilter> filters) {\r\n-\r\n-        // Open the codecs for writing\r\n-        int fileIndex = 0;\r\n-        initializeNextBfqFiles(fileIndex++);\r\n-\r\n-        int records = 0;\r\n-\r\n-        final FilteringSamIterator it = new FilteringSamIterator(iterator, new AggregateFilter(filters));\r\n-        while (it.hasNext()) {\r\n-            final SAMRecord record = it.next();\r\n-            records++;\r\n-            if (records % increment == 0) {\r\n-\r\n-                record.setReadName(record.getReadName() + \"/1\");\r\n-                writeFastqRecord(codec1, record);\r\n-                wrote++;\r\n-                if (wrote % 1000000 == 0) {\r\n-                    log.info(wrote + \" records processed.\");\r\n-                }\r\n-                if (chunk > 0 && wrote % chunk == 0) {\r\n-                    initializeNextBfqFiles(fileIndex++);\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Closes any the open bfq file(s), if any, and opens the new one(s)\r\n-     *\r\n-     * @param fileIndex the index (counter) of the files to write\r\n-     */\r\n-    private void initializeNextBfqFiles(final int fileIndex) {\r\n-        // Close the codecs if they were writing before\r\n-        if (codec1 != null) {\r\n-            codec1.close();\r\n-            if (pairedReads) {\r\n-                codec2.close();\r\n-            }\r\n-        }\r\n-\r\n-        // Open new file, using the fileIndex.\r\n-        final File bfq1 = getOutputFile(this.outputPrefix , 1, fileIndex);\r\n-        codec1 = new BinaryCodec(IOUtil.openFileForWriting(bfq1));\r\n-        log.info(\"Now writing to file \" + bfq1.getAbsolutePath());\r\n-        if (pairedReads) {\r\n-            final File bfq2 = getOutputFile(this.outputPrefix , 2, fileIndex);\r\n-            codec2 = new BinaryCodec(IOUtil.openFileForWriting(bfq2));\r\n-            log.info(\"Now writing to file \" + bfq2.getAbsolutePath());\r\n-        }\r\n-    }\r\n-\r\n-    /**\r\n-     * Writes out a SAMRecord in Maq fastq format\r\n-     *\r\n-     * @param codec the code to write to\r\n-     * @param rec   the SAMRecord to write\r\n-     */\r\n-    private void writeFastqRecord(final BinaryCodec codec, final SAMRecord rec) {\r\n-\r\n-        // Trim the run barcode off the read name\r\n-        String readName = rec.getReadName();\r\n-        if (namePrefix != null && readName.startsWith(namePrefix)) {\r\n-            readName = readName.substring(nameTrim);\r\n-        }\r\n-        // Writes the length of the read name and then the name (null-terminated)\r\n-        codec.writeString(readName, true, true);\r\n-\r\n-        final char[] seqs = rec.getReadString().toCharArray();\r\n-        final char[] quals = rec.getBaseQualityString().toCharArray();\r\n-\r\n-        int retainedLength = seqs.length;\r\n-        if (clipAdapters){\r\n-            // adjust to a shorter length iff clipping tag exists\r\n-            Integer trimPoint = rec.getIntegerAttribute(ReservedTagConstants.XT);\r\n-            if (trimPoint != null) {\r\n-                assert (rec.getReadLength() == seqs.length);\r\n-                retainedLength = Math.min(seqs.length, Math.max(SEED_REGION_LENGTH, trimPoint -1));\r\n-            }\r\n-        }\r\n-\r\n-        // Write the length of the sequence\r\n-        codec.writeInt(basesToWrite != null ? basesToWrite : seqs.length);\r\n-\r\n-        // Calculate and write the sequence and qualities\r\n-        final byte[] seqsAndQuals = encodeSeqsAndQuals(seqs, quals, retainedLength);\r\n-        codec.writeBytes(seqsAndQuals);\r\n-    }\r\n-\r\n-    private byte[] encodeSeqsAndQuals(char[] seqs, char[] quals, int retainedLength) {\r\n-        final byte[] seqsAndQuals = new byte[basesToWrite == null ? seqs.length : basesToWrite];\r\n-\r\n-        int seedRegionNoCallFixes = 0;\r\n-        for (int i = 0; i < retainedLength && i < seqsAndQuals.length; i++) {\r\n-            int quality = Math.min(quals[i]-33, 63);\r\n-            final int base;\r\n-            switch(seqs[i]) {\r\n-                case 'A':\r\n-                case 'a':\r\n-                    base = 0;\r\n-                    break;\r\n-                case 'C':\r\n-                case 'c':\r\n-                    base = 1;\r\n-                    break;\r\n-                case 'G':\r\n-                case 'g':\r\n-                    base = 2;\r\n-                    break;\r\n-                case 'T':\r\n-                case 't':\r\n-                    base = 3;\r\n-                    break;\r\n-                case 'N':\r\n-                case 'n':\r\n-                case '.':\r\n-                    base = 0;\r\n-                    if (i < SEED_REGION_LENGTH ) {\r\n-                        if (seedRegionNoCallFixes < MAX_SEED_REGION_NOCALL_FIXES) {\r\n-                            quality = 1;\r\n-                            seedRegionNoCallFixes++;\r\n-                        }\r\n-                        else {\r\n-                            quality = 0;\r\n-                        }\r\n-                    }\r\n-                    else {\r\n-                        quality = 1;\r\n-                    }\r\n-                    break;\r\n-                default:\r\n-                    throw new PicardException(\"Unknown base when writing bfq file: \" + seqs[i]);\r\n-            }\r\n-            seqsAndQuals[i] = encodeBaseAndQuality(base, quality);\r\n-        }\r\n-        // rewrite clipped adapter with all A's of quality 1\r\n-        for (int i = retainedLength; i < seqsAndQuals.length; i++) {\r\n-            seqsAndQuals[i] = encodeBaseAndQuality(0, 1);\r\n-        }\r\n-\r\n-        return seqsAndQuals;\r\n-    }\r\n-\r\n-    private byte encodeBaseAndQuality(int base, int quality) {\r\n-        return (byte) ((base << 6) | quality);\r\n-    }\r\n-\r\n-    /**\r\n-     * Count the number of records in the bamFile that could potentially be written\r\n-     *\r\n-     * @return  the number of records in the Bam file\r\n-     */\r\n-    private int countWritableRecords() {\r\n-        int count = 0;\r\n-\r\n-        final SamReader reader = SamReaderFactory.makeDefault().open(this.bamFile);\r\n-        if(!reader.getFileHeader().getSortOrder().equals(SAMFileHeader.SortOrder.queryname)) {\r\n-        \t//this is a fix for issue PIC-274: It looks like BamToBfqWriter requires that the input BAM is queryname sorted, \r\n-        \t//but it doesn't check this early, nor produce an understandable error message.\"\r\n-        \tthrow new PicardException(\"Input file (\" + this.bamFile.getAbsolutePath() +\") needs to be sorted by queryname.\");\r\n-        }\r\n-        final PeekableIterator<SAMRecord> it = new PeekableIterator<SAMRecord>(reader.iterator());\r\n-        if (!this.pairedReads) {\r\n-            // Filter out noise reads and reads that fail the quality filter\r\n-            final List<SamRecordFilter> filters = new ArrayList<SamRecordFilter>();\r\n-            filters.add(new TagFilter(ReservedTagConstants.XN, 1));\r\n-            if (!this.includeNonPfReads) {\r\n-                filters.add(new FailsVendorReadQualityFilter());\r\n-            }\r\n-            final FilteringSamIterator itr = new FilteringSamIterator(it, new AggregateFilter(filters));\r\n-            while (itr.hasNext()) {\r\n-                itr.next();\r\n-                count++;\r\n-            }\r\n-        }\r\n-        else {\r\n-            while (it.hasNext()) {\r\n-                final SAMRecord first = it.next();\r\n-                final SAMRecord second = it.next();\r\n-                // If both are noise reads, filter them out\r\n-                if (first.getAttribute(ReservedTagConstants.XN) != null &&\r\n-                    second.getAttribute(ReservedTagConstants.XN) != null)  {\r\n-                    // skip it\r\n-                }\r\n-                // If either fails to pass filter, then exclude them as well\r\n-                else if (!this.includeNonPfReads && (first.getReadFailsVendorQualityCheckFlag() || second.getReadFailsVendorQualityCheckFlag()) ) {\r\n-                    // skip it\r\n-                }\r\n-                // Otherwise, write them out\r\n-                else {\r\n-                    count++;\r\n-                }\r\n-            }\r\n-        }\r\n-        it.close();\r\n-        CloserUtil.close(reader);\r\n-        return count;\r\n-    }\r\n-\r\n-    /**\r\n-     * Constructs the name for the output file and returns the file\r\n-     *\r\n-     * @param outputPrefix        the directory and file prefix for the output bfq file\r\n-     * @param read                whether this is the file for the first or second read\r\n-     * @param index               used in file name\r\n-     * @return                    a new File object for the bfq file.\r\n-     */\r\n-    private File getOutputFile(final String outputPrefix, final int read, final int index) {\r\n-        final File result = new File(outputPrefix + index + \".\" + read + \".bfq\");\r\n-        IOUtil.assertFileIsWritable(result);\r\n-        return result;\r\n-    }\r\n-\r\n-}\r\n+/*\n+ * The MIT License\n+ *\n+ * Copyright (c) 2009 The Broad Institute\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in\n+ * all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+ * THE SOFTWARE.\n+ */\n+package picard.fastq;\n+\n+import htsjdk.samtools.ReservedTagConstants;\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMRecord;\n+import htsjdk.samtools.SamReader;\n+import htsjdk.samtools.SamReaderFactory;\n+import htsjdk.samtools.filter.AggregateFilter;\n+import htsjdk.samtools.filter.FailsVendorReadQualityFilter;\n+import htsjdk.samtools.filter.FilteringSamIterator;\n+import htsjdk.samtools.filter.SamRecordFilter;\n+import htsjdk.samtools.filter.TagFilter;\n+import htsjdk.samtools.filter.WholeReadClippedFilter;\n+import htsjdk.samtools.util.BinaryCodec;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.Log;\n+import htsjdk.samtools.util.PeekableIterator;\n+import htsjdk.utils.ValidationUtils;\n+import picard.PicardException;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Class to take unmapped reads in BAM file format and create Maq binary fastq format file(s) --\n+ * one or two of them, depending on whether it's a paired-end read.  This relies on the unmapped\n+ * BAM file having all paired reads together in order.\n+ */\n+public class BamToBfqWriter {\n+\n+    private static final int SEED_REGION_LENGTH = 28;\n+    private static final int MAX_SEED_REGION_NOCALL_FIXES = 2;\n+\n+    private final File bamFile;\n+    private final String outputPrefix;\n+    private final String namePrefix;\n+    private final int nameTrim;\n+    private boolean pairedReads = false;\n+    private int wrote = 0;\n+    private int increment = 1;\n+    private int chunk = 0;\n+    private BinaryCodec codec1;\n+    private BinaryCodec codec2;\n+    private final Log log = Log.getInstance(BamToBfqWriter.class);\n+    private final boolean includeNonPfReads;\n+    private final boolean clipAdapters;\n+    private final Integer basesToWrite;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile        the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param total          the total number of records that should be written, drawn evenly\n+     *                       from throughout the file (null for all).\n+     * @param chunk          the maximum number of records that should be written to any one file\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     The string to be stripped off the read name\n+     *                       before writing to the bfq file. May be null, in which case\n+     *                       the name will not be trimmed.\n+     * @param includeNonPfReads whether to include non pf-reads\n+     * @param clipAdapters    whether to replace adapters as marked with XT:i clipping position attribute\n+     */\n+    public BamToBfqWriter(final File bamFile, final String outputPrefix, final Integer total,\n+                          final Integer chunk, final boolean pairedReads, String namePrefix,\n+                          boolean includeNonPfReads, boolean clipAdapters, Integer basesToWrite) {\n+\n+        IOUtil.assertFileIsReadable(bamFile);\n+        this.bamFile = bamFile;\n+        this.outputPrefix = outputPrefix;\n+        this.pairedReads = pairedReads;\n+        if (total != null) {\n+            final double writeable = (double)countWritableRecords();\n+            this.increment = (int)Math.floor(writeable/total.doubleValue());\n+            if (this.increment == 0) {\n+                this.increment = 1;\n+            }\n+        }\n+        if (chunk != null) {\n+            this.chunk = chunk;\n+        }\n+        this.namePrefix = namePrefix;\n+        this.nameTrim = namePrefix != null ? namePrefix.length() : 0;\n+        this.includeNonPfReads = includeNonPfReads;\n+        this.clipAdapters = clipAdapters;\n+        this.basesToWrite = basesToWrite;\n+    }\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bamFile   the BAM file to read from\n+     * @param outputPrefix   the directory and file prefix for the binary fastq files\n+     * @param pairedReads    whether these reads are from  a paired-end run\n+     * @param namePrefix     the barcode of the run (to be stripped off the read name\n+     *                       before writing to the bfq file)\n+     * @param includeNonPfReads whether to include non pf-reads\n+     */\n+    public BamToBfqWriter(final File bamFile, final String outputPrefix, final boolean pairedReads,\n+                          String namePrefix, boolean includeNonPfReads) {\n+        this(bamFile, outputPrefix, null, null, pairedReads, namePrefix, includeNonPfReads, true, null);\n+    }\n+ \n+    /**\n+     * Writes the binary fastq file(s) to the output directory\n+     */\n+    public void writeBfqFiles() {\n+\n+        final SamReader reader = SamReaderFactory.makeDefault().open(bamFile);\n+        final Iterator<SAMRecord> iterator = reader.iterator();\n+\n+        // Filter out noise reads and reads that fail the quality filter\n+        final TagFilter tagFilter = new TagFilter(ReservedTagConstants.XN, 1);\n+        final FailsVendorReadQualityFilter qualityFilter = new FailsVendorReadQualityFilter();\n+        final WholeReadClippedFilter clippedFilter = new WholeReadClippedFilter();\n+\n+\n+        if (!pairedReads) {\n+            List<SamRecordFilter> filters = new ArrayList<SamRecordFilter>();\n+            filters.add(tagFilter);\n+            filters.add(clippedFilter);\n+            if (!this.includeNonPfReads) {\n+                filters.add(qualityFilter);\n+            }\n+            writeSingleEndBfqs(iterator, filters);\n+            codec1.close();\n+        }\n+        else {\n+            writePairedEndBfqs(iterator, tagFilter, qualityFilter, clippedFilter);\n+            codec1.close();\n+            codec2.close();\n+        }\n+        log.info(\"Wrote \" + wrote + \" bfq records.\");\n+        CloserUtil.close(reader);\n+    }\n+\n+    /**\n+     * Path for writing bfqs for paired-end reads\n+     *\n+     * @param iterator      the iterator witht he SAM Records to write\n+     * @param tagFilter     the filter for noise reads\n+     * @param qualityFilter the filter for PF reads\n+     */\n+    private void writePairedEndBfqs(final Iterator<SAMRecord> iterator, final TagFilter tagFilter,\n+                                    final FailsVendorReadQualityFilter qualityFilter,\n+                                    SamRecordFilter ... otherFilters) {\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        RECORD_LOOP: while (iterator.hasNext()) {\n+            final SAMRecord first = iterator.next();\n+            if (!iterator.hasNext()) {\n+                throw new PicardException(\"Mismatched number of records in \" + this.bamFile.getAbsolutePath());\n+            }\n+            final SAMRecord second = iterator.next();\n+            if (!second.getReadName().equals(first.getReadName()) ||\n+                first.getFirstOfPairFlag() == second.getFirstOfPairFlag()) {\n+                throw new PicardException(\"Unmatched read pairs in \" + this.bamFile.getAbsolutePath() +\n+                    \": \" + first.getReadName() + \", \" + second.getReadName() + \".\");\n+            }\n+\n+            // If *both* are noise reads, filter them out\n+            if (tagFilter.filterOut(first) && tagFilter.filterOut(second))  {\n+                continue;\n+            }\n+\n+            // If either fails to pass filter, then exclude them as well\n+            if (!includeNonPfReads && (qualityFilter.filterOut(first) || qualityFilter.filterOut(second))) {\n+                continue;\n+            }\n+\n+            // If either fails any of the other filters, exclude them both\n+            for (SamRecordFilter filter : otherFilters) {\n+                if (filter.filterOut(first) || filter.filterOut(second)) {\n+                    continue RECORD_LOOP;\n+                }\n+            }\n+\n+            // Otherwise, write them out\n+            records++;\n+            if (records % increment == 0) {\n+                first.setReadName(first.getReadName() + \"/1\");\n+                writeFastqRecord(first.getFirstOfPairFlag() ? codec1 : codec2, first);\n+                second.setReadName(second.getReadName() + \"/2\");\n+                writeFastqRecord(second.getFirstOfPairFlag() ? codec1 : codec2, second);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records written.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Path for writing bfqs for single-end reads\n+     *\n+     * @param iterator  the iterator with he SAM Records to write\n+     * @param filters   the list of filters to be applied\n+     */\n+    private void writeSingleEndBfqs(final Iterator<SAMRecord> iterator, final List<SamRecordFilter> filters) {\n+\n+        // Open the codecs for writing\n+        int fileIndex = 0;\n+        initializeNextBfqFiles(fileIndex++);\n+\n+        int records = 0;\n+\n+        final FilteringSamIterator it = new FilteringSamIterator(iterator, new AggregateFilter(filters));\n+        while (it.hasNext()) {\n+            final SAMRecord record = it.next();\n+            records++;\n+            if (records % increment == 0) {\n+\n+                record.setReadName(record.getReadName() + \"/1\");\n+                writeFastqRecord(codec1, record);\n+                wrote++;\n+                if (wrote % 1000000 == 0) {\n+                    log.info(wrote + \" records processed.\");\n+                }\n+                if (chunk > 0 && wrote % chunk == 0) {\n+                    initializeNextBfqFiles(fileIndex++);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Closes any the open bfq file(s), if any, and opens the new one(s)\n+     *\n+     * @param fileIndex the index (counter) of the files to write\n+     */\n+    private void initializeNextBfqFiles(final int fileIndex) {\n+        // Close the codecs if they were writing before\n+        if (codec1 != null) {\n+            codec1.close();\n+            if (pairedReads) {\n+                codec2.close();\n+            }\n+        }\n+\n+        // Open new file, using the fileIndex.\n+        final File bfq1 = getOutputFile(this.outputPrefix , 1, fileIndex);\n+        codec1 = new BinaryCodec(IOUtil.openFileForWriting(bfq1));\n+        log.info(\"Now writing to file \" + bfq1.getAbsolutePath());\n+        if (pairedReads) {\n+            final File bfq2 = getOutputFile(this.outputPrefix , 2, fileIndex);\n+            codec2 = new BinaryCodec(IOUtil.openFileForWriting(bfq2));\n+            log.info(\"Now writing to file \" + bfq2.getAbsolutePath());\n+        }\n+    }\n+\n+    /**\n+     * Writes out a SAMRecord in Maq fastq format\n+     *\n+     * @param codec the code to write to\n+     * @param rec   the SAMRecord to write\n+     */\n+    private void writeFastqRecord(final BinaryCodec codec, final SAMRecord rec) {\n+\n+        // Trim the run barcode off the read name\n+        String readName = rec.getReadName();\n+        if (namePrefix != null && readName.startsWith(namePrefix)) {\n+            readName = readName.substring(nameTrim);\n+        }\n+        // Writes the length of the read name and then the name (null-terminated)\n+        codec.writeString(readName, true, true);\n+\n+        final char[] seqs = rec.getReadString().toCharArray();\n+        final char[] quals = rec.getBaseQualityString().toCharArray();\n+\n+        int retainedLength = seqs.length;\n+        if (clipAdapters){\n+            // adjust to a shorter length iff clipping tag exists\n+            Integer trimPoint = rec.getIntegerAttribute(ReservedTagConstants.XT);\n+            if (trimPoint != null) {\n+                ValidationUtils.validateArg(rec.getReadLength() == seqs.length, () -> \"length of read and seqs differ. Found \" + rec.getReadLength() + \" and '\" + seqs.length + \".\");", "originalCommit": "433e35081818cac6103490113f3cb48fae50a491", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NTIzNg==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378985236", "bodyText": "here", "author": "lbergelson", "createdAt": "2020-02-13T16:48:22Z", "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -109,8 +111,7 @@ public static CallState getHom(final int alleleIdx) {\n             if (alleleIdx == 2) return HOM_VAR2;\n             if (alleleIdx == 3) return HOM_VAR3;\n \n-            assert false;\n-            return null;\n+            throw new IllegalStateException(\"Shouldn't be here.\");", "originalCommit": "433e35081818cac6103490113f3cb48fae50a491", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NTI3NQ==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378985275", "bodyText": "to", "author": "lbergelson", "createdAt": "2020-02-13T16:48:26Z", "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -124,22 +125,22 @@ public static CallState getHet(int allele0idx, int allele1idx) {\n                 if (allele1idx == 1) return HET_REF_VAR1;\n                 if (allele1idx == 2) return HET_REF_VAR2;\n                 if (allele1idx == 3) return HET_REF_VAR3;\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "originalCommit": "433e35081818cac6103490113f3cb48fae50a491", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NTMwNw==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378985307", "bodyText": "and", "author": "lbergelson", "createdAt": "2020-02-13T16:48:30Z", "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -124,22 +125,22 @@ public static CallState getHet(int allele0idx, int allele1idx) {\n                 if (allele1idx == 1) return HET_REF_VAR1;\n                 if (allele1idx == 2) return HET_REF_VAR2;\n                 if (allele1idx == 3) return HET_REF_VAR3;\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");\n                 return null;\n             }\n \n             //HET CASES\n             if(allele0idx == 1) {\n                 if (allele1idx == 2) return HET_VAR1_VAR2;\n                 if (allele1idx == 3) return HET_VAR1_VAR3;\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "originalCommit": "433e35081818cac6103490113f3cb48fae50a491", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk4NTMyNQ==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r378985325", "bodyText": "here", "author": "lbergelson", "createdAt": "2020-02-13T16:48:32Z", "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -124,22 +125,22 @@ public static CallState getHet(int allele0idx, int allele1idx) {\n                 if (allele1idx == 1) return HET_REF_VAR1;\n                 if (allele1idx == 2) return HET_REF_VAR2;\n                 if (allele1idx == 3) return HET_REF_VAR3;\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");\n                 return null;\n             }\n \n             //HET CASES\n             if(allele0idx == 1) {\n                 if (allele1idx == 2) return HET_VAR1_VAR2;\n                 if (allele1idx == 3) return HET_VAR1_VAR3;\n-                assert false;\n+                ValidationUtils.validateArg(false,\"Shouldn't be here.\");\n                 return null;\n             }\n \n             if(allele0idx == 2 && allele1idx == 3) return HET_VAR3_VAR4; //special case not a mistake.\n             if(allele0idx == 3 && allele1idx == 4) return HET_VAR3_VAR4;\n \n-            assert false;\n+            ValidationUtils.validateArg(false,\"Shouldn't be here.\");", "originalCommit": "433e35081818cac6103490113f3cb48fae50a491", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e42c92c7f118b8c541f5b815f77473b4f395a9d3", "url": "https://github.com/broadinstitute/picard/commit/e42c92c7f118b8c541f5b815f77473b4f395a9d3", "message": "- missed a few changes", "committedDate": "2020-02-13T18:16:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzNjM5MQ==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r382136391", "bodyText": "import is now unused?", "author": "pshapiro4broad", "createdAt": "2020-02-20T17:07:23Z", "path": "src/main/java/picard/vcf/GenotypeConcordanceStates.java", "diffHunk": "@@ -1,5 +1,7 @@\n package picard.vcf;\n \n+import htsjdk.utils.ValidationUtils;", "originalCommit": "e42c92c7f118b8c541f5b815f77473b4f395a9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEzNjYyNA==", "url": "https://github.com/broadinstitute/picard/pull/1465#discussion_r382136624", "bodyText": "Also unused import", "author": "pshapiro4broad", "createdAt": "2020-02-20T17:07:49Z", "path": "src/test/java/picard/fingerprint/CrosscheckFingerprintsTest.java", "diffHunk": "@@ -3,6 +3,7 @@\n import htsjdk.samtools.SamReader;\n import htsjdk.samtools.metrics.MetricsFile;\n import htsjdk.samtools.util.IOUtil;\n+import htsjdk.utils.ValidationUtils;", "originalCommit": "e42c92c7f118b8c541f5b815f77473b4f395a9d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e9057552c3ef3514db56ba66a8963b739c103523", "url": "https://github.com/broadinstitute/picard/commit/e9057552c3ef3514db56ba66a8963b739c103523", "message": "Merge branch 'master' into yf_remove_asserts", "committedDate": "2020-02-20T20:11:57Z", "type": "commit"}, {"oid": "8a98a61f8346321ff465b255ea467ba334b9de89", "url": "https://github.com/broadinstitute/picard/commit/8a98a61f8346321ff465b255ea467ba334b9de89", "message": "- remove unused imports", "committedDate": "2020-02-20T20:23:54Z", "type": "commit"}]}