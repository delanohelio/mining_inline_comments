{"pr_number": 1589, "pr_title": "MBA deletion edge case alternate solution", "pr_createdAt": "2020-10-01T20:56:47Z", "pr_url": "https://github.com/broadinstitute/picard/pull/1589", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTI3Mw==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498531273", "bodyText": "You dropped the \"innies\" requirement it seems...I'm not sure if that is on purpose, or just not needed...but could you add tests to show that they do not get clipped?", "author": "yfarjoun", "createdAt": "2020-10-01T21:51:37Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {", "originalCommit": "8d09e6c0da0417494574bc73373fdf930a64b881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTc1Mw==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498531753", "bodyText": "also how do we know if reads are innes? what do we do with the clipped bases?\n   <-----------------------SSSSSSSSS\n                                SSSSSSS------------------------->\n\n(S being a soft-clipped base....)", "author": "yfarjoun", "createdAt": "2020-10-01T21:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgxMzY2MQ==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498813661", "bodyText": "The explicit \"innie\" requirement is dropped, but this still will not clip outies, because I believe by definition outies cannot be overlapping with reads on opposite strands.  I don't think innie and outie really have meaning for overlapping reads, though I may be confused about this.  There is a test commented as Non overlapping \"outies\" which tests outies.\nPreviously, the \"innie\" requirement was enforced with the logic pos.getAlignmentStart() < neg.getAlignmentEnd(). Combining this with posClipFrom > 0/ negClipFrom > 0 is almost equivalent to the overlapping requirement, except for when the two reads overlap by only a single base.  In this case, the new check of read1.overlaps(read2) will pass, while the old check of pos.getAlignmentStart() < neg.getAlignmentEnd() will not, because instead pos.getAlignmentStart() == neg.getAlignmentEnd().  This is not a behavior change I was intending, as I wasn't aware of this edge case difference until just now.  But I believe the old behavior was actually a bug, since the new behavior is more consistent with my understanding of what is intended.  It doesn't make sense to me that we would clip when two or more bases overlap, but not when only one base overlaps, so I'm guessing that was not intentional.  I have added a test demonstrating this edge case (commented as \"overlap by one base only\"), and have also added the same test on the branch ck_mba_single_overlap_test_example to demonstrate the previous behavior.\nFor your softclipped example, these reads will not go through any additional clipping since they are not overlapping.\nThis is consistent with past behavior, since they would not pass the pos.getAlignmentStart() < neg.getAlignmentEnd() check.", "author": "kachulis", "createdAt": "2020-10-02T13:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNjk2Nw==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499036967", "bodyText": "\ud83d\udc4d thanks for the explanation", "author": "yfarjoun", "createdAt": "2020-10-02T20:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMTI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDU2OQ==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498534569", "bodyText": "did you mix up 3' and 5' here? or am I confused?", "author": "yfarjoun", "createdAt": "2020-10-01T22:01:16Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.", "originalCommit": "8d09e6c0da0417494574bc73373fdf930a64b881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDc4Nw==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498534787", "bodyText": "5'------------------------------------->3'\n3' <-----------------------------5'", "author": "yfarjoun", "createdAt": "2020-10-01T22:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAxMjAzOA==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499012038", "bodyText": "I think this is correct.  On a forward read, the first base clipped is the 5' most base to clip, and the last base not clipped is the 3' most base not to be clipped.\n3'<SSSSSSSSMMMMMMMMMMMM5'\n         5'MMMMMMMMMMMMSSSSSSSS>3'\n                      ||\n                      ||---> 5' most base to clip\n                      |\n                      |---> 3' most base not to clip\n\nI agree this is pretty confusing to parse, so I will add this ascii art to the comment in the code to help clarify the language", "author": "kachulis", "createdAt": "2020-10-02T19:30:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNDI2MA==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499024260", "bodyText": "\ud83d\udc4d yeah, thanks.", "author": "yfarjoun", "createdAt": "2020-10-02T20:00:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzNDU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDI0MA==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498574240", "bodyText": "perhaps these variables need to be renamed, where the first assignment is negFirstBaseToClip (unchanged) and the second is negFirstBaseFrom3PrimeEndToClip?", "author": "yfarjoun", "createdAt": "2020-10-02T00:34:53Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);", "originalCommit": "8d09e6c0da0417494574bc73373fdf930a64b881", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyMzUzMw==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499023533", "bodyText": "Agreed these variables could be names more clearly (though I think this should be negFirstBaseFrom5PrimeEndToClip).  I've tried to improve the naming, and added some comments to clarify what all these variables are.", "author": "kachulis", "createdAt": "2020-10-02T19:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDI0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNDU1Mw==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499024553", "bodyText": "I think that part of the problem is that pos is overloaded (both POSition and POSitive).... \ud83e\udd37", "author": "yfarjoun", "createdAt": "2020-10-02T20:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU3NDgyMw==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498574823", "bodyText": "could this be moved up so it's next to the other stuff that deals with pos?", "author": "yfarjoun", "createdAt": "2020-10-02T00:37:39Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n+        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+\n+        if(posLastUnclipped > 0 && posLastUnclipped < pos.getReadLength()) {", "originalCommit": "8d09e6c0da0417494574bc73373fdf930a64b881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwNTQwMw==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r498605403", "bodyText": "1-based position,\n0 if reference position doesn't overlap with read even with softclips converted to matches.", "author": "yfarjoun", "createdAt": "2020-10-02T03:31:11Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,57 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+         */\n+\n+        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n \n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read\n+         */\n+\n+        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n+        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+\n+        if(posLastUnclipped > 0 && posLastUnclipped < pos.getReadLength()) {\n+            clip3PrimeEndOfRead(pos, posLastUnclipped + 1, hardClipReads);\n         }\n-        if(negClipFrom > 0) {\n-            clip3PrimeEndOfRead(neg, negClipFrom, hardClipReads);\n+        if(negFirstBaseToClip > 0) {\n+            clip3PrimeEndOfRead(neg, negFirstBaseToClip, hardClipReads);\n         }\n     }\n \n+    /**\n+     * Gets the read position that corresponds to a particular position on the reference.  If the position on the reference\n+     * falls in a deletion in the alignment of the read, the position before the deletion will be returned.", "originalCommit": "8d09e6c0da0417494574bc73373fdf930a64b881", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNjQxOQ==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499036419", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(negFirstBaseFrom5PrimeEndToClip > 0) {\n          \n          \n            \n                    if (negFirstBaseFrom5PrimeEndToClip > 0) {", "author": "yfarjoun", "createdAt": "2020-10-02T20:30:32Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -796,41 +796,69 @@ private void transferAlignmentInfoToPairedRead(final SAMRecord firstUnaligned, f\n      * starts and ends of each read are the same.\n      */\n     protected static void clipForOverlappingReads(final SAMRecord read1, final SAMRecord read2, final boolean useHardClipping) {\n-        // If both reads are mapped, see if we need to clip the ends due to small insert size\n-        if (!(read1.getReadUnmappedFlag() || read2.getReadUnmappedFlag())) {\n-            if (read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag()) {\n-                final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n-                final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n-\n-                // Innies only -- do we need to do anything else about jumping libraries?\n-                if (pos.getAlignmentStart() < neg.getAlignmentEnd()) {\n-                    // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n-                    clip3primeEndsTo5primeEnds(pos, neg, false, false);\n-\n-                    if (useHardClipping) {\n-                        // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n-                        clip3primeEndsTo5primeEnds(pos, neg, true, true);\n-                    }\n-                }\n+        // Only clip if both reads are mapped, on opposite strands, overlapping\n+        if (!read1.getReadUnmappedFlag() && !read2.getReadUnmappedFlag() &&\n+                read1.getReadNegativeStrandFlag() != read2.getReadNegativeStrandFlag() &&\n+                read1.overlaps(read2)) {\n+            final SAMRecord pos = (read1.getReadNegativeStrandFlag()) ? read2 : read1;\n+            final SAMRecord neg = (read1.getReadNegativeStrandFlag()) ? read1 : read2;\n+\n+            // first we softclip the 3' end of each read so that its 3' aligned end does not extends past the 5' aligned start of it's mate\n+            clip3primeEndsTo5primeEnds(pos, neg, false, false);\n+\n+            if (useHardClipping) {\n+                // if we want to hardclip, we additionally hardclip the 3' end of each read so that its 3' unclipped end does not extend past the 5' unclipped start of its mate\n+                clip3primeEndsTo5primeEnds(pos, neg, true, true);\n             }\n         }\n     }\n \n     private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRecord neg, final boolean hardClipReads, final boolean useUnclippedEnds) {\n         final int negEnd = useUnclippedEnds? neg.getUnclippedEnd() : neg.getEnd();\n         final int posStart = useUnclippedEnds? pos.getUnclippedStart() : pos.getStart();\n-        final int posClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd + 1);\n-        int negClipFrom = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negClipFrom = negClipFrom > 0 ? (neg.getReadLength() + 1) - negClipFrom : 0;\n-\n-        if(posClipFrom > 0) {\n-            clip3PrimeEndOfRead(pos, posClipFrom, hardClipReads);\n+        /*\n+          For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n+          We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n+          the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n+         */\n+\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n+            final int pos5PrimeMostClipped = pos3PrimeMostUnclipped + 1;\n+            clip3PrimeEndOfRead(pos, pos5PrimeMostClipped, hardClipReads);\n         }\n-        if(negClipFrom > 0) {\n-            clip3PrimeEndOfRead(neg, negClipFrom, hardClipReads);\n+\n+        /*\n+        For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n+         the queried base when the queried base is in a deletion on a negative strand read.\n+         */\n+\n+        //this is the position counting from the aligned start of the read\n+        final int neg5PrimeMostBaseToClipPositionFromStart = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n+\n+        //this is the position counting from the 5' end of the read\n+        final int negFirstBaseFrom5PrimeEndToClip = neg5PrimeMostBaseToClipPositionFromStart > 0 ? (neg.getReadLength() + 1) - neg5PrimeMostBaseToClipPositionFromStart : 0;\n+\n+        if(negFirstBaseFrom5PrimeEndToClip > 0) {", "originalCommit": "73ea523f7b61f9d74c885409c0313835f7cddeb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNzQ5Mg==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499037492", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    //this is the position counting from the aligned start of the read\n          \n          \n            \n                    // this is the position counting from the aligned start of the read", "author": "yfarjoun", "createdAt": "2020-10-02T20:33:16Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n          */\n \n-        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n+            final int pos5PrimeMostClipped = pos3PrimeMostUnclipped + 1;\n+            clip3PrimeEndOfRead(pos, pos5PrimeMostClipped, hardClipReads);\n+        }\n \n         /*\n         For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n-         the queried base when the queried base is in a deletion on a negative strand read\n+         the queried base when the queried base is in a deletion on a negative strand read.\n          */\n \n-        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+        //this is the position counting from the aligned start of the read", "originalCommit": "73ea523f7b61f9d74c885409c0313835f7cddeb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNzU2MA==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499037560", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    //this is the position counting from the 5' end of the read\n          \n          \n            \n                    // this is the position counting from the 5' end of the read", "author": "yfarjoun", "createdAt": "2020-10-02T20:33:26Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n          */\n \n-        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n+            final int pos5PrimeMostClipped = pos3PrimeMostUnclipped + 1;\n+            clip3PrimeEndOfRead(pos, pos5PrimeMostClipped, hardClipReads);\n+        }\n \n         /*\n         For the negative strand, we ask for the position of the 5' most base to clip.  getReadPositionAtReferencePositionIgnoreSoftClips will return the 5' most base before\n-         the queried base when the queried base is in a deletion on a negative strand read\n+         the queried base when the queried base is in a deletion on a negative strand read.\n          */\n \n-        int negFirstBaseToClip = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n-        negFirstBaseToClip = negFirstBaseToClip > 0 ? (neg.getReadLength() + 1) - negFirstBaseToClip : 0;\n+        //this is the position counting from the aligned start of the read\n+        final int neg5PrimeMostBaseToClipPositionFromStart = getReadPositionAtReferencePositionIgnoreSoftClips(neg, posStart - 1);\n \n-        if(posLastUnclipped > 0 && posLastUnclipped < pos.getReadLength()) {\n-            clip3PrimeEndOfRead(pos, posLastUnclipped + 1, hardClipReads);\n-        }\n-        if(negFirstBaseToClip > 0) {\n-            clip3PrimeEndOfRead(neg, negFirstBaseToClip, hardClipReads);\n+        //this is the position counting from the 5' end of the read", "originalCommit": "73ea523f7b61f9d74c885409c0313835f7cddeb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTUxOQ==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499039519", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {\n          \n          \n            \n                    if (pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {", "author": "yfarjoun", "createdAt": "2020-10-02T20:38:25Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'\n+                                  ||\n+                                  ||---> 5' most base to clip\n+                                  |\n+                                  |---> 3' most base not to clip\n          */\n \n-        final int posLastUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        final int pos3PrimeMostUnclipped = getReadPositionAtReferencePositionIgnoreSoftClips(pos, negEnd);\n+        if(pos3PrimeMostUnclipped > 0 && pos3PrimeMostUnclipped < pos.getReadLength()) {", "originalCommit": "73ea523f7b61f9d74c885409c0313835f7cddeb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTc3MQ==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499039771", "bodyText": "the 5 looks like an S...\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        3'<SSSSSSSSMMMMMMMMMMMM5'\n          \n          \n            \n                       3' <SSSSSSSSMMMMMMMMMMMM 5'", "author": "yfarjoun", "createdAt": "2020-10-02T20:39:03Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'", "originalCommit": "73ea523f7b61f9d74c885409c0313835f7cddeb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzOTgzNw==", "url": "https://github.com/broadinstitute/picard/pull/1589#discussion_r499039837", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                 5'MMMMMMMMMMMMSSSSSSSS>3'\n          \n          \n            \n                                5' MMMMMMMMMMMMSSSSSSSS> 3'", "author": "yfarjoun", "createdAt": "2020-10-02T20:39:13Z", "path": "src/main/java/picard/sam/AbstractAlignmentMerger.java", "diffHunk": "@@ -820,29 +820,41 @@ private static void clip3primeEndsTo5primeEnds(final SAMRecord pos, final SAMRec\n           For the positive strand, we ask for the position of the 3' most base which will not be clipped, and then increment to find the 5' most base to clip.\n           We do this because getReadPositionAtReferencePositionIgnoreSoftClips will return the base before a deletion, so will return the 3' most base before\n           the queried base when the queried base is in a deletion on a positive strand read\n+\n+            3'<SSSSSSSSMMMMMMMMMMMM5'\n+                     5'MMMMMMMMMMMMSSSSSSSS>3'", "originalCommit": "73ea523f7b61f9d74c885409c0313835f7cddeb8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f4392e3bdc4b167ab526ac672cf1952088aac07d", "url": "https://github.com/broadinstitute/picard/commit/f4392e3bdc4b167ab526ac672cf1952088aac07d", "message": "beginning change", "committedDate": "2020-10-02T20:48:34Z", "type": "commit"}, {"oid": "e40601a422e4ddecc9c78752d2cf72ac724cb5be", "url": "https://github.com/broadinstitute/picard/commit/e40601a422e4ddecc9c78752d2cf72ac724cb5be", "message": "get working, tests", "committedDate": "2020-10-02T20:48:34Z", "type": "commit"}, {"oid": "2d05515aa91d7971442be838d1e0eb39fd51b37d", "url": "https://github.com/broadinstitute/picard/commit/2d05515aa91d7971442be838d1e0eb39fd51b37d", "message": "some cleanup", "committedDate": "2020-10-02T20:48:34Z", "type": "commit"}, {"oid": "7b3a592c26ac484f2a3cf23f7a8311701bbfd686", "url": "https://github.com/broadinstitute/picard/commit/7b3a592c26ac484f2a3cf23f7a8311701bbfd686", "message": "more comments", "committedDate": "2020-10-02T20:48:34Z", "type": "commit"}, {"oid": "d728a5a96592147799456a6d64403459be601d64", "url": "https://github.com/broadinstitute/picard/commit/d728a5a96592147799456a6d64403459be601d64", "message": "another test", "committedDate": "2020-10-02T20:48:35Z", "type": "commit"}, {"oid": "d2a0aa7bf23538a6bc59ccc745b52486e09de80e", "url": "https://github.com/broadinstitute/picard/commit/d2a0aa7bf23538a6bc59ccc745b52486e09de80e", "message": "variable name change for clarity", "committedDate": "2020-10-02T20:48:35Z", "type": "commit"}, {"oid": "9722b0a3fe204074e6afa818c211b4a911e686f9", "url": "https://github.com/broadinstitute/picard/commit/9722b0a3fe204074e6afa818c211b4a911e686f9", "message": "test to demonstrate edge case change", "committedDate": "2020-10-02T20:48:35Z", "type": "commit"}, {"oid": "20b20e9f0e515ce6bfc17aae956c3c2f7319aae9", "url": "https://github.com/broadinstitute/picard/commit/20b20e9f0e515ce6bfc17aae956c3c2f7319aae9", "message": "ascii art", "committedDate": "2020-10-02T20:48:35Z", "type": "commit"}, {"oid": "c6cce2bdb473a959774fe686420aed15fe91351f", "url": "https://github.com/broadinstitute/picard/commit/c6cce2bdb473a959774fe686420aed15fe91351f", "message": "review comments", "committedDate": "2020-10-02T20:48:35Z", "type": "commit"}, {"oid": "3d001dbef722d595afef93e717bbabe18d4257b6", "url": "https://github.com/broadinstitute/picard/commit/3d001dbef722d595afef93e717bbabe18d4257b6", "message": "spaces", "committedDate": "2020-10-02T20:48:35Z", "type": "commit"}, {"oid": "3d001dbef722d595afef93e717bbabe18d4257b6", "url": "https://github.com/broadinstitute/picard/commit/3d001dbef722d595afef93e717bbabe18d4257b6", "message": "spaces", "committedDate": "2020-10-02T20:48:35Z", "type": "forcePushed"}]}