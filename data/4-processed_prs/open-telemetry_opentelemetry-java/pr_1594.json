{"pr_number": 1594, "pr_title": "SpanContext hides the TraceId/SpanId implementations", "pr_createdAt": "2020-08-26T21:33:26Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594", "timeline": [{"oid": "90dc14a77da20ebf659b654ce059fe6c40593af4", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/90dc14a77da20ebf659b654ce059fe6c40593af4", "message": "cleanup some CharSequence usages to String", "committedDate": "2020-08-26T21:36:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1MDE1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477950153", "bodyText": "It might affect other places as well, but while we're here, let's use a non-unicode check for isDigit", "author": "anuraaga", "createdAt": "2020-08-27T02:26:14Z", "path": "api/src/main/java/io/opentelemetry/trace/BigendianEncoding.java", "diffHunk": "@@ -165,5 +174,24 @@ private static void byteToBase16(byte value, char[] dest, int destOffset) {\n     dest[destOffset + 1] = ENCODING[b | 0x100];\n   }\n \n+  public static boolean isValidBase16String(CharSequence value) {\n+    for (int i = 0; i < value.length(); i++) {\n+      char b = value.charAt(i);\n+      // 48..57 && 97..102 are valid\n+      if (!Character.isDigit(b) && (b < 97 || b > 102)) {", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAyODk5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478028998", "bodyText": "happy to fix it. Are there non-ascii digits out there?", "author": "jkwatson", "createdAt": "2020-08-27T03:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1MDE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA3MDkyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478070920", "bodyText": "done", "author": "jkwatson", "createdAt": "2020-08-27T03:59:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1MDE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1MTE0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477951141", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static byte[] bytesFromBase16(CharSequence value, int srcOffset, int charactersToRead) {\n          \n          \n            \n              static byte[] bytesFromBase16(CharSequence value, int offset, int length) {\n          \n      \n    \n    \n  \n\nI think this pattern is very prevelant in the JDK so good to follow the idiom", "author": "anuraaga", "createdAt": "2020-08-27T02:26:55Z", "path": "api/src/main/java/io/opentelemetry/trace/BigendianEncoding.java", "diffHunk": "@@ -138,6 +138,15 @@ static void byteToBase16String(byte value, char[] dest, int destOffset) {\n     byteToBase16(value, dest, destOffset);\n   }\n \n+  static byte[] bytesFromBase16(CharSequence value, int srcOffset, int charactersToRead) {", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1MTkzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477951939", "bodyText": "Think the loop is still very easy even without the subsequence", "author": "anuraaga", "createdAt": "2020-08-27T02:27:30Z", "path": "api/src/main/java/io/opentelemetry/trace/BigendianEncoding.java", "diffHunk": "@@ -138,6 +138,15 @@ static void byteToBase16String(byte value, char[] dest, int destOffset) {\n     byteToBase16(value, dest, destOffset);\n   }\n \n+  static byte[] bytesFromBase16(CharSequence value, int srcOffset, int charactersToRead) {\n+    CharSequence part = value.subSequence(srcOffset, srcOffset + charactersToRead);", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAyODA2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478028062", "bodyText": "definitely. I thought I had caught all these, but I missed this one. will fix.", "author": "jkwatson", "createdAt": "2020-08-27T03:22:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1MTkzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA3MDgyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478070822", "bodyText": "done", "author": "jkwatson", "createdAt": "2020-08-27T03:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1MTkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1NDQ0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477954445", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /* remote$=*/ remote);\n          \n          \n            \n                    /* remote=*/ remote);\n          \n      \n    \n    \n  \n\nIsn't it?", "author": "anuraaga", "createdAt": "2020-08-27T02:29:23Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanContext.java", "diffHunk": "@@ -75,25 +76,88 @@ public static SpanContext create(\n    * @since 0.1.0\n    */\n   public static SpanContext createFromRemoteParent(\n-      TraceId traceId, SpanId spanId, TraceFlags traceFlags, TraceState traceState) {\n-    return new AutoValue_SpanContext(traceId, spanId, traceFlags, traceState, /* remote=*/ true);\n+      CharSequence traceId, CharSequence spanId, TraceFlags traceFlags, TraceState traceState) {\n+    return create(traceId, 0, spanId, 0, traceFlags, traceState, /* remote=*/ true);\n   }\n \n+  /**\n+   * Creates a new {@code SpanContext} with the given identifiers and options.\n+   *\n+   * @param traceId a CharSequence containing the trace identifier of the span context.\n+   * @param traceIdOffset the offset at which the traceId starts.\n+   * @param spanId the CharSequence containing the the span identifier of the span context.\n+   * @param spanIdOffset the offset at which the spanId starts.\n+   * @param traceFlags the trace options for the span context.\n+   * @param traceState the trace state for the span context.\n+   * @return a new {@code SpanContext} with the given identifiers and options.\n+   * @since 0.1.0\n+   */\n+  @SuppressWarnings({\n+    \"InconsistentOverloads\",\n+    \"UngroupedOverloads\",\n+    \"OverloadMethodsDeclarationOrder\"\n+  })\n+  public static SpanContext create(\n+      CharSequence traceId,\n+      int traceIdOffset,\n+      CharSequence spanId,\n+      int spanIdOffset,\n+      TraceFlags traceFlags,\n+      TraceState traceState,\n+      boolean remote) {\n+    return new AutoValue_SpanContext(\n+        traceId.subSequence(traceIdOffset, traceIdOffset + 32).toString(),\n+        spanId.subSequence(spanIdOffset, spanIdOffset + 16).toString(),\n+        traceFlags,\n+        traceState,\n+        /* remote$=*/ remote);", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAxNjYwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478016602", "bodyText": "you would think that, but it seems to shift back and forth in ways I can't predict. If you get it wrong, checkstyle/errorprone complains.", "author": "jkwatson", "createdAt": "2020-08-27T03:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1NDQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxMzcyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478613726", "bodyText": "I think occurs when you use the @Memoized annotation, due to the way that generates the underlying implementations.", "author": "jkwatson", "createdAt": "2020-08-27T18:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk1NDQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2MjkxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477962914", "bodyText": "We can replace some of the methods in this class for checking validity I think", "author": "anuraaga", "createdAt": "2020-08-27T02:35:21Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/Common.java", "diffHunk": "@@ -52,8 +52,8 @@ static SpanContext buildSpanContext(String traceId, String spanId, String sample\n               : NOT_SAMPLED_FLAGS;\n \n       return SpanContext.createFromRemoteParent(\n-          TraceId.fromLowerBase16(StringUtils.padLeft(traceId, MAX_TRACE_ID_LENGTH), 0),\n-          SpanId.fromLowerBase16(spanId, 0),\n+          StringUtils.padLeft(traceId, MAX_TRACE_ID_LENGTH),\n+          spanId,", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAzNjc1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478036755", "bodyText": "You mean use the ones on TraceId/SpanId?", "author": "jkwatson", "createdAt": "2020-08-27T03:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2MjkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA0MzA5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478043095", "bodyText": "Yeah", "author": "anuraaga", "createdAt": "2020-08-27T03:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2MjkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA3MDY4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478070687", "bodyText": "done", "author": "jkwatson", "createdAt": "2020-08-27T03:59:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2MjkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2NTgyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477965821", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public String getTraceIdAsBase16() {\n          \n          \n            \n              public String getTraceIdAsHexString() {\n          \n      \n    \n    \n  \n\nOur spec now uses hex too and I think it's more familiar to people than base 16\nhttps://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/api.md#retrieving-the-traceid-and-spanid", "author": "anuraaga", "createdAt": "2020-08-27T02:37:28Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanContext.java", "diffHunk": "@@ -75,25 +76,88 @@ public static SpanContext create(\n    * @since 0.1.0\n    */\n   public static SpanContext createFromRemoteParent(\n-      TraceId traceId, SpanId spanId, TraceFlags traceFlags, TraceState traceState) {\n-    return new AutoValue_SpanContext(traceId, spanId, traceFlags, traceState, /* remote=*/ true);\n+      CharSequence traceId, CharSequence spanId, TraceFlags traceFlags, TraceState traceState) {\n+    return create(traceId, 0, spanId, 0, traceFlags, traceState, /* remote=*/ true);\n   }\n \n+  /**\n+   * Creates a new {@code SpanContext} with the given identifiers and options.\n+   *\n+   * @param traceId a CharSequence containing the trace identifier of the span context.\n+   * @param traceIdOffset the offset at which the traceId starts.\n+   * @param spanId the CharSequence containing the the span identifier of the span context.\n+   * @param spanIdOffset the offset at which the spanId starts.\n+   * @param traceFlags the trace options for the span context.\n+   * @param traceState the trace state for the span context.\n+   * @return a new {@code SpanContext} with the given identifiers and options.\n+   * @since 0.1.0\n+   */\n+  @SuppressWarnings({\n+    \"InconsistentOverloads\",\n+    \"UngroupedOverloads\",\n+    \"OverloadMethodsDeclarationOrder\"\n+  })\n+  public static SpanContext create(\n+      CharSequence traceId,\n+      int traceIdOffset,\n+      CharSequence spanId,\n+      int spanIdOffset,\n+      TraceFlags traceFlags,\n+      TraceState traceState,\n+      boolean remote) {\n+    return new AutoValue_SpanContext(\n+        traceId.subSequence(traceIdOffset, traceIdOffset + 32).toString(),\n+        spanId.subSequence(spanIdOffset, spanIdOffset + 16).toString(),\n+        traceFlags,\n+        traceState,\n+        /* remote$=*/ remote);\n+  }\n+\n+  abstract String getTraceId();\n+\n+  abstract String getSpanId();\n+\n   /**\n    * Returns the trace identifier associated with this {@code SpanContext}.\n    *\n    * @return the trace identifier associated with this {@code SpanContext}.\n    * @since 0.1.0\n    */\n-  public abstract TraceId getTraceId();\n+  public String getTraceIdAsBase16() {", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAzMTkyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478031925", "bodyText": "I'll go through and change it.", "author": "jkwatson", "createdAt": "2020-08-27T03:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2NTgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2NjUzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477966534", "bodyText": "Since our accessors (e.g. getTraceId() use String, I don't think there's an advantage to using CharSequence in the factories. Can we use String everywhere?", "author": "anuraaga", "createdAt": "2020-08-27T02:38:01Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanContext.java", "diffHunk": "@@ -75,25 +76,88 @@ public static SpanContext create(\n    * @since 0.1.0\n    */\n   public static SpanContext createFromRemoteParent(\n-      TraceId traceId, SpanId spanId, TraceFlags traceFlags, TraceState traceState) {\n-    return new AutoValue_SpanContext(traceId, spanId, traceFlags, traceState, /* remote=*/ true);\n+      CharSequence traceId, CharSequence spanId, TraceFlags traceFlags, TraceState traceState) {\n+    return create(traceId, 0, spanId, 0, traceFlags, traceState, /* remote=*/ true);\n   }\n \n+  /**\n+   * Creates a new {@code SpanContext} with the given identifiers and options.\n+   *\n+   * @param traceId a CharSequence containing the trace identifier of the span context.\n+   * @param traceIdOffset the offset at which the traceId starts.\n+   * @param spanId the CharSequence containing the the span identifier of the span context.\n+   * @param spanIdOffset the offset at which the spanId starts.\n+   * @param traceFlags the trace options for the span context.\n+   * @param traceState the trace state for the span context.\n+   * @return a new {@code SpanContext} with the given identifiers and options.\n+   * @since 0.1.0\n+   */\n+  @SuppressWarnings({\n+    \"InconsistentOverloads\",\n+    \"UngroupedOverloads\",\n+    \"OverloadMethodsDeclarationOrder\"\n+  })\n+  public static SpanContext create(\n+      CharSequence traceId,", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAzMDUyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478030527", "bodyText": "My thinking (and it wasn't very strong thinking) was that to be more accepting of inputs, and more restrictive on outputs. But, I definitely don't feel too strongly about that.", "author": "jkwatson", "createdAt": "2020-08-27T03:24:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2NjUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA3MTU0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478071544", "bodyText": "Got it - I'm ok with either, but have a small feeling that String feels more familiar to developers", "author": "anuraaga", "createdAt": "2020-08-27T04:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2NjUzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE2NDg1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r482164859", "bodyText": "switched all to String now. :)", "author": "jkwatson", "createdAt": "2020-09-02T15:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2NjUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk2ODQ1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477968457", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String INVALID = \"0000000000000000\";\n          \n          \n            \n              private static final String INVALID = \"0000000000000000\";", "author": "anuraaga", "createdAt": "2020-08-27T02:39:17Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanId.java", "diffHunk": "@@ -16,43 +16,25 @@\n \n package io.opentelemetry.trace;\n \n-import io.opentelemetry.internal.Utils;\n-import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n \n /**\n- * A class that represents a span identifier. A valid span identifier is an 8-byte array with at\n- * least one non-zero byte.\n+ * Helper methods for dealing with a span identifier. A valid span identifier is an 8-byte array\n+ * with at least one non-zero byte. In base-16 representation, a 16 character hex String, where at\n+ * least one of the characters is not a '0'.\n  *\n  * @since 0.1.0\n  */\n @Immutable\n-public final class SpanId implements Comparable<SpanId> {\n+public final class SpanId {\n \n+  private static final ThreadLocal<char[]> charBuffer = new ThreadLocal<>();\n   private static final int SIZE = 8;\n   private static final int BASE16_SIZE = 2 * SIZE;\n-  private static final long INVALID_ID = 0;\n-  private static final SpanId INVALID = new SpanId(INVALID_ID);\n \n-  // The internal representation of the SpanId.\n-  private final long id;\n+  public static final String INVALID = \"0000000000000000\";", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3MDUyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477970524", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String INVALID = \"00000000000000000000000000000000\";\n          \n          \n            \n              private static final String INVALID = \"00000000000000000000000000000000\";", "author": "anuraaga", "createdAt": "2020-08-27T02:40:42Z", "path": "api/src/main/java/io/opentelemetry/trace/TraceId.java", "diffHunk": "@@ -17,55 +17,42 @@\n package io.opentelemetry.trace;\n \n import io.opentelemetry.internal.Utils;\n-import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n \n /**\n- * A class that represents a trace identifier. A valid trace identifier is a 16-byte array with at\n- * least one non-zero byte.\n+ * Helper methods for dealing with a trace identifier. A valid trace identifier is a 16-byte array\n+ * with at least one non-zero byte. In base-16 representation, a 32 character hex String, where at\n+ * least one of the characters is not a '0'.\n  *\n  * @since 0.1.0\n  */\n @Immutable\n-public final class TraceId implements Comparable<TraceId> {\n+public final class TraceId {\n+  private static final ThreadLocal<char[]> charBuffer = new ThreadLocal<>();\n \n-  private static final int SIZE = 16;\n+  private static final int SIZE_IN_BYTES = 16;\n   private static final int BASE16_SIZE = 2 * BigendianEncoding.LONG_BASE16;\n-  private static final long INVALID_ID = 0;\n-  private static final TraceId INVALID = new TraceId(INVALID_ID, INVALID_ID);\n+  public static final String INVALID = \"00000000000000000000000000000000\";", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3NjU3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477976572", "bodyText": "I don't know if the offset versions provide enough user benefit to have (not much harder to call subsequence than grok this long method signature). There doesn't seem to be a performance benefit since we always need to take the substring anyways.\nIf we only had two factories, than I think we could also provide two symmetric factories that accept byte[] and we don't need public APIs like TraceId.toLowerBase16(byte[])", "author": "anuraaga", "createdAt": "2020-08-27T02:45:07Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanContext.java", "diffHunk": "@@ -75,25 +76,88 @@ public static SpanContext create(\n    * @since 0.1.0\n    */\n   public static SpanContext createFromRemoteParent(\n-      TraceId traceId, SpanId spanId, TraceFlags traceFlags, TraceState traceState) {\n-    return new AutoValue_SpanContext(traceId, spanId, traceFlags, traceState, /* remote=*/ true);\n+      CharSequence traceId, CharSequence spanId, TraceFlags traceFlags, TraceState traceState) {\n+    return create(traceId, 0, spanId, 0, traceFlags, traceState, /* remote=*/ true);\n   }\n \n+  /**\n+   * Creates a new {@code SpanContext} with the given identifiers and options.\n+   *\n+   * @param traceId a CharSequence containing the trace identifier of the span context.\n+   * @param traceIdOffset the offset at which the traceId starts.\n+   * @param spanId the CharSequence containing the the span identifier of the span context.\n+   * @param spanIdOffset the offset at which the spanId starts.\n+   * @param traceFlags the trace options for the span context.\n+   * @param traceState the trace state for the span context.\n+   * @return a new {@code SpanContext} with the given identifiers and options.\n+   * @since 0.1.0\n+   */\n+  @SuppressWarnings({\n+    \"InconsistentOverloads\",\n+    \"UngroupedOverloads\",\n+    \"OverloadMethodsDeclarationOrder\"\n+  })\n+  public static SpanContext create(\n+      CharSequence traceId,\n+      int traceIdOffset,\n+      CharSequence spanId,\n+      int spanIdOffset,\n+      TraceFlags traceFlags,\n+      TraceState traceState,\n+      boolean remote) {\n+    return new AutoValue_SpanContext(\n+        traceId.subSequence(traceIdOffset, traceIdOffset + 32).toString(),", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3NzMwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477977304", "bodyText": "Though realized a byte[] version of this factory would have benefit from an offset version :)", "author": "anuraaga", "createdAt": "2020-08-27T02:45:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3NjU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAzOTc3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478039770", "bodyText": "This was a method signature that @bogdandrutu had requested. I don't know that it's necessary at the moment, though.", "author": "jkwatson", "createdAt": "2020-08-27T03:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3NjU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxMjk5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478612997", "bodyText": "I think we should get rid of the offsets for now; we can always add another option later; we can't take it back if we leave it in.", "author": "jkwatson", "createdAt": "2020-08-27T18:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3NjU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxMzkyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478613924", "bodyText": "I got rid of them. Smaller API is better for now.", "author": "jkwatson", "createdAt": "2020-08-27T18:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3NjU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3OTQ4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477979483", "bodyText": "Any thoughts on moving these to reflect they're only used for ID generation, maybe IdGeneratorUtil, or we could make IdGenerator an abstract class with protected helper methods for generating IDs from longs?", "author": "anuraaga", "createdAt": "2020-08-27T02:47:17Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanId.java", "diffHunk": "@@ -65,46 +47,38 @@ public static int getSize() {\n   }\n \n   /**\n-   * Returns the invalid {@code SpanId}. All bytes are 0.\n+   * Returns the length of the base16 (hex) representation of the {@code SpanId}.\n    *\n-   * @return the invalid {@code SpanId}.\n-   * @since 0.1.0\n+   * @since 0.8.0\n    */\n-  public static SpanId getInvalid() {\n-    return INVALID;\n+  public static int getBase16Length() {\n+    return BASE16_SIZE;\n   }\n \n   /**\n-   * Returns a {@code SpanId} whose representation is copied from the {@code src} beginning at the\n-   * {@code srcOffset} offset.\n+   * Returns the invalid {@code SpanId}. All bytes are 0.\n    *\n-   * @param src the buffer where the representation of the {@code SpanId} is copied.\n-   * @param srcOffset the offset in the buffer where the representation of the {@code SpanId}\n-   *     begins.\n-   * @return a {@code SpanId} whose representation is copied from the buffer.\n-   * @throws NullPointerException if {@code src} is null.\n-   * @throws IndexOutOfBoundsException if {@code srcOffset+SpanId.getSize()} is greater than {@code\n-   *     src.length}.\n+   * @return the invalid {@code SpanId}.\n    * @since 0.1.0\n    */\n-  public static SpanId fromBytes(byte[] src, int srcOffset) {\n-    Utils.checkNotNull(src, \"src\");\n-    return new SpanId(BigendianEncoding.longFromByteArray(src, srcOffset));\n+  public static String getInvalid() {\n+    return INVALID;\n   }\n \n-  /**\n-   * Copies the byte array representations of the {@code SpanId} into the {@code dest} beginning at\n-   * the {@code destOffset} offset.\n-   *\n-   * @param dest the destination buffer.\n-   * @param destOffset the starting offset in the destination buffer.\n-   * @throws NullPointerException if {@code dest} is null.\n-   * @throws IndexOutOfBoundsException if {@code destOffset+SpanId.getSize()} is greater than {@code\n-   *     dest.length}.\n-   * @since 0.1.0\n-   */\n-  public void copyBytesTo(byte[] dest, int destOffset) {\n-    BigendianEncoding.longToByteArray(id, dest, destOffset);\n+  /** Generate a valid {@link SpanId} from the given long value. */\n+  public static String fromLong(long id) {", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAzMzk1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478033958", "bodyText": "I liked having all the transformations \"close to home\" in the relevant helpers, but it wouldn't be hard to convince me to move them. Let's do that as a follow-up, if that's ok.", "author": "jkwatson", "createdAt": "2020-08-27T03:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3OTQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODA0MDQwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478040407", "bodyText": "Also, there are quite a few usages in test code at the moment, so I think I'd want to hold off for a follow-up PR, for sure.", "author": "jkwatson", "createdAt": "2020-08-27T03:31:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3OTQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4MTUyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477981522", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static long getTraceIdRandomPart(CharSequence traceId) {\n          \n          \n            \n              public static long getRandomPart(CharSequence traceId) {\n          \n      \n    \n    \n  \n\nWe don't repeat the classname in the others, don't think we need to here either.", "author": "anuraaga", "createdAt": "2020-08-27T02:48:44Z", "path": "api/src/main/java/io/opentelemetry/trace/TraceId.java", "diffHunk": "@@ -193,32 +163,7 @@ public boolean equals(@Nullable Object obj) {\n    *\n    * @return the rightmost 8 bytes of the trace-id as a long value.\n    */\n-  public long getTraceRandomPart() {\n-    return idLo;\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    // Copied from Arrays.hashCode(long[])\n-    int result = 1;\n-    result = 31 * result + ((int) (idHi ^ (idHi >>> 32)));\n-    result = 31 * result + ((int) (idLo ^ (idLo >>> 32)));\n-    return result;\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"TraceId{traceId=\" + toLowerBase16() + \"}\";\n-  }\n-\n-  @Override\n-  public int compareTo(TraceId that) {\n-    if (idHi == that.idHi) {\n-      if (idLo == that.idLo) {\n-        return 0;\n-      }\n-      return idLo < that.idLo ? -1 : 1;\n-    }\n-    return idHi < that.idHi ? -1 : 1;\n+  public static long getTraceIdRandomPart(CharSequence traceId) {", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4MjE0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477982142", "bodyText": "Though this seems like it doesn't need to be public API, it even documents itself as being used in one specific sampler?", "author": "anuraaga", "createdAt": "2020-08-27T02:49:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4MTUyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAxODcyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478018720", "bodyText": "This was the method name before, so I kept it as-is.  And, it's public so any Sampler could get access to it, I believe.", "author": "jkwatson", "createdAt": "2020-08-27T03:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4MTUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4NjA5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477986097", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                System.arraycopy(traceId.toCharArray(), 0, chars, 0, TRACE_ID_HEX_SIZE);\n          \n          \n            \n                traceId.getChars(0, traceId.length(), chars, 0);\n          \n      \n    \n    \n  \n\nSimilar throughout", "author": "anuraaga", "createdAt": "2020-08-27T02:52:02Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/B3PropagatorInjectorSingleHeader.java", "diffHunk": "@@ -50,9 +50,13 @@\n     SpanContext spanContext = span.getContext();\n \n     char[] chars = new char[COMBINED_HEADER_SIZE];\n-    spanContext.getTraceId().copyLowerBase16To(chars, 0);\n+    String traceId = spanContext.getTraceIdAsBase16();\n+    System.arraycopy(traceId.toCharArray(), 0, chars, 0, TRACE_ID_HEX_SIZE);", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4NzE3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r477987179", "bodyText": "Looks like a lot can be updated to use String / getChars instead of CharSequence", "author": "anuraaga", "createdAt": "2020-08-27T02:52:47Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/HttpTraceContext.java", "diffHunk": "@@ -94,9 +94,19 @@\n     chars[0] = VERSION.charAt(0);\n     chars[1] = VERSION.charAt(1);\n     chars[2] = TRACEPARENT_DELIMITER;\n-    spanContext.getTraceId().copyLowerBase16To(chars, TRACE_ID_OFFSET);\n+\n+    CharSequence traceId = spanContext.getTraceIdAsBase16();", "originalCommit": "90dc14a77da20ebf659b654ce059fe6c40593af4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODAyMDE4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478020182", "bodyText": "yeah, it's true. I hadn't tracked them all down. I don't think it's actually harmful to declare these as CharSequence, so I wasn't aggressive at finding them all.", "author": "jkwatson", "createdAt": "2020-08-27T03:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4NzE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU5MDAwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478590007", "bodyText": "I'm going to go through and get rid of the CharSequence usage and go to strictly String based API. We can always loosen it up later, if we just support String for now.", "author": "jkwatson", "createdAt": "2020-08-27T17:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4NzE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODYxMzk3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478613972", "bodyText": "done", "author": "jkwatson", "createdAt": "2020-08-27T18:27:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk4NzE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc5MTAyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478791029", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static boolean isValidBase16String(CharSequence value) {\n          \n          \n            \n              static boolean isValidBase16String(CharSequence value) {\n          \n      \n    \n    \n  \n\nClass isn't public", "author": "anuraaga", "createdAt": "2020-08-28T02:07:49Z", "path": "api/src/main/java/io/opentelemetry/trace/BigendianEncoding.java", "diffHunk": "@@ -165,5 +173,24 @@ private static void byteToBase16(byte value, char[] dest, int destOffset) {\n     dest[destOffset + 1] = ENCODING[b | 0x100];\n   }\n \n+  public static boolean isValidBase16String(CharSequence value) {", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc5MTA3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478791072", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static String toLowerBase16(byte[] bytes) {\n          \n          \n            \n              static String toLowerBase16(byte[] bytes) {", "author": "anuraaga", "createdAt": "2020-08-28T02:08:00Z", "path": "api/src/main/java/io/opentelemetry/trace/BigendianEncoding.java", "diffHunk": "@@ -165,5 +173,24 @@ private static void byteToBase16(byte value, char[] dest, int destOffset) {\n     dest[destOffset + 1] = ENCODING[b | 0x100];\n   }\n \n+  public static boolean isValidBase16String(CharSequence value) {\n+    for (int i = 0; i < value.length(); i++) {\n+      char b = value.charAt(i);\n+      // 48..57 && 97..102 are valid\n+      if ((b < 48 || b > 57) && (b < 97 || b > 102)) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n   private BigendianEncoding() {}\n+\n+  public static String toLowerBase16(byte[] bytes) {", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc5MTQ0MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478791440", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    && !INVALID.contentEquals(spanId)\n          \n          \n            \n                    && !INVALID.equals(spanId)", "author": "anuraaga", "createdAt": "2020-08-28T02:09:42Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanId.java", "diffHunk": "@@ -145,50 +104,14 @@ public void copyLowerBase16To(char[] dest, int destOffset) {\n    * @return {@code true} if the span identifier is valid.\n    * @since 0.1.0\n    */\n-  public boolean isValid() {\n-    return id != INVALID_ID;\n-  }\n-\n-  /**\n-   * Returns the lowercase base16 encoding of this {@code SpanId}.\n-   *\n-   * @return the lowercase base16 encoding of this {@code SpanId}.\n-   * @since 0.1.0\n-   */\n-  public String toLowerBase16() {\n-    char[] chars = new char[BASE16_SIZE];\n-    copyLowerBase16To(chars, 0);\n-    return new String(chars);\n-  }\n-\n-  @Override\n-  public boolean equals(@Nullable Object obj) {\n-    if (obj == this) {\n-      return true;\n-    }\n-\n-    if (!(obj instanceof SpanId)) {\n-      return false;\n-    }\n-\n-    SpanId that = (SpanId) obj;\n-    return id == that.id;\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    // Copied from Long.hashCode in java8.\n-    return (int) (id ^ (id >>> 32));\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"SpanId{spanId=\" + toLowerBase16() + \"}\";\n+  public static boolean isValid(String spanId) {\n+    return (spanId.length() == BASE16_SIZE)\n+        && !INVALID.contentEquals(spanId)", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg1ODg1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478858854", "bodyText": "I'm pretty sure they're the same, and maybe it's just me but I find writing the same code as the comment would be more readable\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if ((b < 48 || b > 57) && (b < 97 || b > 102)) {\n          \n          \n            \n                  if (!(b >= 48 && b <= 57) || !(b >= 97 && b <= 102)) {", "author": "anuraaga", "createdAt": "2020-08-28T06:31:33Z", "path": "api/src/main/java/io/opentelemetry/trace/BigendianEncoding.java", "diffHunk": "@@ -165,5 +173,24 @@ private static void byteToBase16(byte value, char[] dest, int destOffset) {\n     dest[destOffset + 1] = ENCODING[b | 0x100];\n   }\n \n+  public static boolean isValidBase16String(CharSequence value) {\n+    for (int i = 0; i < value.length(); i++) {\n+      char b = value.charAt(i);\n+      // 48..57 && 97..102 are valid\n+      if ((b < 48 || b > 57) && (b < 97 || b > 102)) {", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1Nzg5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r479457899", "bodyText": "heh. I agree with you. However, what you pasted isn't correct (IDEA says it's always true!). I'll figure out how to make it what you intended. :)", "author": "jkwatson", "createdAt": "2020-08-28T18:03:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg1ODg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjE5Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r479472196", "bodyText": "check out the update. I think it's now much easier to understand.", "author": "jkwatson", "createdAt": "2020-08-28T18:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg1ODg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MDA4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478860082", "bodyText": "Think we can remove .toString() in this file", "author": "anuraaga", "createdAt": "2020-08-28T06:35:02Z", "path": "api/src/test/java/io/opentelemetry/trace/TraceIdTest.java", "diffHunk": "@@ -75,56 +76,42 @@ void testGetRandomTracePart_NegativeLongRepresentation() {\n       0x0F,\n       0x00\n     };\n-    TraceId traceid = TraceId.fromBytes(id, 0);\n-    assertThat(traceid.getTraceRandomPart()).isEqualTo(0xFF0A0B0C0D0E0F00L);\n+    CharSequence traceid = TraceId.toLowerBase16(id);\n+    assertThat(TraceId.getTraceIdRandomPart(traceid)).isEqualTo(0xFF0A0B0C0D0E0F00L);\n   }\n \n   @Test\n   void fromLowerBase16() {\n-    assertThat(TraceId.fromLowerBase16(\"00000000000000000000000000000000\", 0))\n-        .isEqualTo(TraceId.getInvalid());\n-    assertThat(TraceId.fromLowerBase16(\"00000000000000000000000000000061\", 0)).isEqualTo(first);\n-    assertThat(TraceId.fromLowerBase16(\"ff000000000000000000000000000041\", 0)).isEqualTo(second);\n+    assertThat(", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MDYzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478860636", "bodyText": "A note for potentially following up with moving fromLongs to ID generation, there isn't a great reason for unit tests to use the long version vs string version, presumably assertion messages matching the input is an improvement.", "author": "anuraaga", "createdAt": "2020-08-28T06:36:36Z", "path": "exporters/logging/src/test/java/io/opentelemetry/exporters/logging/LoggingSpanExporterTest.java", "diffHunk": "@@ -60,8 +60,8 @@ void returnCode() {\n     SpanData spanData =\n         TestSpanData.newBuilder()\n             .setHasEnded(true)\n-            .setTraceId(new TraceId(1234L, 6789L))\n-            .setSpanId(new SpanId(9876L))\n+            .setTraceId(TraceId.fromLongs(1234L, 6789L))", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MDc2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478860766", "bodyText": "Can remove toString", "author": "anuraaga", "createdAt": "2020-08-28T06:36:55Z", "path": "exporters/zipkin/src/main/java/io/opentelemetry/exporters/zipkin/ZipkinSpanExporter.java", "diffHunk": "@@ -132,16 +133,16 @@ static Span generateSpan(SpanData spanData, Endpoint localEndpoint) {\n \n     final Span.Builder spanBuilder =\n         Span.newBuilder()\n-            .traceId(spanData.getTraceId().toLowerBase16())\n-            .id(spanData.getSpanId().toLowerBase16())\n+            .traceId(spanData.getTraceId().toString())", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MTEyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478861126", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                setter.set(carrier, B3Propagator.SPAN_ID_HEADER, spanContext.getSpanIdAsHexString().toString());\n          \n          \n            \n                setter.set(carrier, B3Propagator.SPAN_ID_HEADER, spanContext.getSpanIdAsHexString());", "author": "anuraaga", "createdAt": "2020-08-28T06:37:50Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/B3PropagatorInjectorMultipleHeaders.java", "diffHunk": "@@ -39,8 +39,8 @@\n     SpanContext spanContext = span.getContext();\n     String sampled = spanContext.getTraceFlags().isSampled() ? Common.TRUE_INT : Common.FALSE_INT;\n \n-    setter.set(carrier, B3Propagator.TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n-    setter.set(carrier, B3Propagator.SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+    setter.set(carrier, B3Propagator.TRACE_ID_HEADER, spanContext.getTraceIdAsHexString());\n+    setter.set(carrier, B3Propagator.SPAN_ID_HEADER, spanContext.getSpanIdAsHexString().toString());", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MTgzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478861838", "bodyText": "For another PR, we might consider moving the validity checks into createFromRemoteParent so propagators don't have to worry about it.", "author": "anuraaga", "createdAt": "2020-08-28T06:39:51Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -189,11 +198,13 @@ private static SpanContext buildSpanContext(String traceId, String spanId, Strin\n       int flagsInt = Integer.parseInt(flags);\n       TraceFlags traceFlags = ((flagsInt & 1) == 1) ? SAMPLED_FLAGS : NOT_SAMPLED_FLAGS;\n \n+      String otelTraceId = StringUtils.padLeft(traceId, MAX_TRACE_ID_LENGTH);\n+      String otelSpanId = StringUtils.padLeft(spanId, MAX_SPAN_ID_LENGTH);\n+      if (!TraceId.isValid(otelTraceId) || !SpanId.isValid(otelSpanId)) {\n+        return SpanContext.getInvalid();\n+      }\n       return SpanContext.createFromRemoteParent(", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ2MDk0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r479460947", "bodyText": "That seems reasonable!", "author": "jkwatson", "createdAt": "2020-08-28T18:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MTgzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MTkyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478861927", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceIdAsHexString().toString());\n          \n          \n            \n                setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceIdAsHexString());", "author": "anuraaga", "createdAt": "2020-08-28T06:40:07Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -71,8 +74,8 @@ public static OtTracerPropagator getInstance() {\n     if (!spanContext.isValid()) {\n       return;\n     }\n-    setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n-    setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+    setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceIdAsHexString().toString());", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MTk3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478861970", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanIdAsHexString().toString());\n          \n          \n            \n                setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanIdAsHexString());", "author": "anuraaga", "createdAt": "2020-08-28T06:40:14Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/OtTracerPropagator.java", "diffHunk": "@@ -71,8 +74,8 @@ public static OtTracerPropagator getInstance() {\n     if (!spanContext.isValid()) {\n       return;\n     }\n-    setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceId().toLowerBase16());\n-    setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanId().toLowerBase16());\n+    setter.set(carrier, TRACE_ID_HEADER, spanContext.getTraceIdAsHexString().toString());\n+    setter.set(carrier, SPAN_ID_HEADER, spanContext.getSpanIdAsHexString().toString());", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2MjMwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r478862300", "bodyText": "Don't need toString() (presumably it's a better assertion without it too). Next few files have it", "author": "anuraaga", "createdAt": "2020-08-28T06:41:04Z", "path": "opentracing_shim/src/test/java/io/opentelemetry/opentracingshim/testbed/TestUtils.java", "diffHunk": "@@ -179,8 +179,12 @@ public static void assertSameTrace(List<SpanData> spans) {\n     for (int i = 0; i < spans.size() - 1; i++) {\n       // TODO - Include nanos in this comparison.\n       assertTrue(spans.get(spans.size() - 1).getEndEpochNanos() >= spans.get(i).getEndEpochNanos());\n-      assertEquals(spans.get(spans.size() - 1).getTraceId(), spans.get(i).getTraceId());\n-      assertEquals(spans.get(spans.size() - 1).getSpanId(), spans.get(i).getParentSpanId());\n+      assertEquals(\n+          spans.get(spans.size() - 1).getTraceId().toString(),", "originalCommit": "38fd490c3628c47c026e3380a360b92e5b7e3bd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQyOTYwOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481429608", "bodyText": "return CharSequence instead?", "author": "tylerbenson", "createdAt": "2020-09-01T21:02:53Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanContext.java", "diffHunk": "@@ -75,25 +81,55 @@ public static SpanContext create(\n    * @since 0.1.0\n    */\n   public static SpanContext createFromRemoteParent(\n-      TraceId traceId, SpanId spanId, TraceFlags traceFlags, TraceState traceState) {\n-    return new AutoValue_SpanContext(traceId, spanId, traceFlags, traceState, /* remote=*/ true);\n+      String traceId, String spanId, TraceFlags traceFlags, TraceState traceState) {\n+    return create(traceId, spanId, traceFlags, traceState, /* remote=*/ true);\n   }\n \n+  abstract String getTraceId();\n+\n+  abstract String getSpanId();", "originalCommit": "a51046e6700f8657dd5c18a2321d67310947061a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzODkyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481438922", "bodyText": "I think we discussed this, and decided to keep it as String for now. We can always open it up to CharSequence later, since it's a broader interface, I think.", "author": "jkwatson", "createdAt": "2020-09-01T21:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQyOTYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg5MDM1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481890358", "bodyText": "You can change return types that easily. If clients expect String they will break on CharSequence. You can widen input, not output", "author": "iNikem", "createdAt": "2020-09-02T08:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQyOTYwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjE2NTI1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r482165254", "bodyText": "true, but this isn't a public method!", "author": "jkwatson", "createdAt": "2020-09-02T15:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQyOTYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzMzAzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481433036", "bodyText": "Hex? If you used hex in SpanContext method names.", "author": "bogdandrutu", "createdAt": "2020-09-01T21:09:40Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanId.java", "diffHunk": "@@ -65,46 +47,38 @@ public static int getSize() {\n   }\n \n   /**\n-   * Returns the invalid {@code SpanId}. All bytes are 0.\n+   * Returns the length of the base16 (hex) representation of the {@code SpanId}.\n    *\n-   * @return the invalid {@code SpanId}.\n-   * @since 0.1.0\n+   * @since 0.8.0\n    */\n-  public static SpanId getInvalid() {\n-    return INVALID;\n+  public static int getBase16Length() {", "originalCommit": "a51046e6700f8657dd5c18a2321d67310947061a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzODAyMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481438023", "bodyText": "yes! should fix this. good catch.", "author": "jkwatson", "createdAt": "2020-09-01T21:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzMzAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0ODk1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481448950", "bodyText": "done", "author": "jkwatson", "createdAt": "2020-09-01T21:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzMzAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzNDA0MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481434040", "bodyText": "s/getBuffer/getTemporaryBuffer?", "author": "bogdandrutu", "createdAt": "2020-09-01T21:11:36Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanId.java", "diffHunk": "@@ -65,46 +47,38 @@ public static int getSize() {\n   }\n \n   /**\n-   * Returns the invalid {@code SpanId}. All bytes are 0.\n+   * Returns the length of the base16 (hex) representation of the {@code SpanId}.\n    *\n-   * @return the invalid {@code SpanId}.\n-   * @since 0.1.0\n+   * @since 0.8.0\n    */\n-  public static SpanId getInvalid() {\n-    return INVALID;\n+  public static int getBase16Length() {\n+    return BASE16_SIZE;\n   }\n \n   /**\n-   * Returns a {@code SpanId} whose representation is copied from the {@code src} beginning at the\n-   * {@code srcOffset} offset.\n+   * Returns the invalid {@code SpanId}. All bytes are 0.\n    *\n-   * @param src the buffer where the representation of the {@code SpanId} is copied.\n-   * @param srcOffset the offset in the buffer where the representation of the {@code SpanId}\n-   *     begins.\n-   * @return a {@code SpanId} whose representation is copied from the buffer.\n-   * @throws NullPointerException if {@code src} is null.\n-   * @throws IndexOutOfBoundsException if {@code srcOffset+SpanId.getSize()} is greater than {@code\n-   *     src.length}.\n+   * @return the invalid {@code SpanId}.\n    * @since 0.1.0\n    */\n-  public static SpanId fromBytes(byte[] src, int srcOffset) {\n-    Utils.checkNotNull(src, \"src\");\n-    return new SpanId(BigendianEncoding.longFromByteArray(src, srcOffset));\n+  public static String getInvalid() {\n+    return INVALID;\n   }\n \n-  /**\n-   * Copies the byte array representations of the {@code SpanId} into the {@code dest} beginning at\n-   * the {@code destOffset} offset.\n-   *\n-   * @param dest the destination buffer.\n-   * @param destOffset the starting offset in the destination buffer.\n-   * @throws NullPointerException if {@code dest} is null.\n-   * @throws IndexOutOfBoundsException if {@code destOffset+SpanId.getSize()} is greater than {@code\n-   *     dest.length}.\n-   * @since 0.1.0\n-   */\n-  public void copyBytesTo(byte[] dest, int destOffset) {\n-    BigendianEncoding.longToByteArray(id, dest, destOffset);\n+  /** Generate a valid {@link SpanId} from the given long value. */\n+  public static String fromLong(long id) {\n+    char[] result = getBuffer();\n+    BigendianEncoding.longToBase16String(id, result, 0);\n+    return new String(result);\n+  }\n+\n+  private static char[] getBuffer() {", "originalCommit": "a51046e6700f8657dd5c18a2321d67310947061a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0OTA1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481449053", "bodyText": "done", "author": "jkwatson", "createdAt": "2020-09-01T21:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzNDA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzNDIzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481434232", "bodyText": "Same, use Hex if you decided to use that in the SC", "author": "bogdandrutu", "createdAt": "2020-09-01T21:11:57Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanId.java", "diffHunk": "@@ -119,23 +93,8 @@ public void copyBytesTo(byte[] dest, int destOffset) {\n    *     srcOffset}.\n    * @since 0.1.0\n    */\n-  public static SpanId fromLowerBase16(CharSequence src, int srcOffset) {\n-    Utils.checkNotNull(src, \"src\");\n-    return new SpanId(BigendianEncoding.longFromBase16String(src, srcOffset));\n-  }\n-\n-  /**\n-   * Copies the lowercase base16 representations of the {@code SpanId} into the {@code dest}\n-   * beginning at the {@code destOffset} offset.\n-   *\n-   * @param dest the destination buffer.\n-   * @param destOffset the starting offset in the destination buffer.\n-   * @throws IndexOutOfBoundsException if {@code destOffset + 2 * SpanId.getSize()} is greater than\n-   *     {@code dest.length}.\n-   * @since 0.1.0\n-   */\n-  public void copyLowerBase16To(char[] dest, int destOffset) {\n-    BigendianEncoding.longToBase16String(id, dest, destOffset);\n+  public static byte[] bytesFromLowerBase16(String src, int srcOffset) {", "originalCommit": "a51046e6700f8657dd5c18a2321d67310947061a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzODE2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481438160", "bodyText": "agreed. \ud83d\udc4d", "author": "jkwatson", "createdAt": "2020-09-01T21:19:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzNDIzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0OTA5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481449093", "bodyText": "done", "author": "jkwatson", "createdAt": "2020-09-01T21:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzNDIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzNDgyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481434828", "bodyText": "name the params traceIdHex, spanIdHex", "author": "bogdandrutu", "createdAt": "2020-09-01T21:13:04Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanContext.java", "diffHunk": "@@ -59,8 +60,13 @@ public static SpanContext getInvalid() {\n    * @since 0.1.0\n    */\n   public static SpanContext create(\n-      TraceId traceId, SpanId spanId, TraceFlags traceFlags, TraceState traceState) {\n-    return new AutoValue_SpanContext(traceId, spanId, traceFlags, traceState, /* remote=*/ false);\n+      String traceId, String spanId, TraceFlags traceFlags, TraceState traceState) {", "originalCommit": "a51046e6700f8657dd5c18a2321d67310947061a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQ0OTEzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1594#discussion_r481449136", "bodyText": "done", "author": "jkwatson", "createdAt": "2020-09-01T21:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTQzNDgyOA=="}], "type": "inlineReview"}, {"oid": "8a9760c631f64dfe1240df8519c940a1bae35d96", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8a9760c631f64dfe1240df8519c940a1bae35d96", "message": "\u0001 This is a combination of 2 commits.\n\u0001 This is the 1st commit message:\n\nWIP on converting to String-based SpanContext\n\ndon't hand out the byte arrays publicly, but require making copies\n\nmake sure to hand out fresh invalid byte arrays.\n\nUse strings for span and trace ids.\n\nSwitch over to CharSequence instead of String for the ids\n\nFix a couple of places that were casting to String\n\nAdd some simple wrappers for the generated longs to save converting until the last moment to the character-based representation.\n\nintroduce a reusable threadlocal char buffer for generating random ids.\n\nupdate for changes from upstream\n\nChange the SpanContext to store the ids as Strings internally\nChange the id access methods on SpanContext to be clearly labeled as the base16 representations\nAdd a new create method that allows specifying offsets for traceId and spanId CharSequences\n\nProvide an option for creating a SpanContext from longs or Strings, optionally.\n\nfix a typo\n\nupdate from upstream\n\n\u0001 The commit message #2 will be skipped:\n\n\u0001 don't hand out the byte arrays publicly, but require making copies", "committedDate": "2020-09-01T21:23:11Z", "type": "commit"}, {"oid": "2053731753b9ed6816fb32c1e205b9ebc55f4d6f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2053731753b9ed6816fb32c1e205b9ebc55f4d6f", "message": "WIP on converting to String-based SpanContext", "committedDate": "2020-09-01T21:23:11Z", "type": "commit"}, {"oid": "45347b69d32335efe6f8cd70bf23ea720e376468", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/45347b69d32335efe6f8cd70bf23ea720e376468", "message": "Update the SpanContext to only store Strings internally for Trace and Span ids.", "committedDate": "2020-09-01T21:23:12Z", "type": "commit"}, {"oid": "7b279ddfcf7dfb2bcbfdbfd8c672fb499672fece", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7b279ddfcf7dfb2bcbfdbfd8c672fb499672fece", "message": "remove dead files", "committedDate": "2020-09-01T21:23:12Z", "type": "commit"}, {"oid": "ad892498dc26e570e32919789e3f02c5881c0b02", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ad892498dc26e570e32919789e3f02c5881c0b02", "message": "cleanup some CharSequence usages to String", "committedDate": "2020-09-01T21:23:12Z", "type": "commit"}, {"oid": "8135b1010361bc57c43473a634c5f735a1c5f153", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8135b1010361bc57c43473a634c5f735a1c5f153", "message": "Update api/src/main/java/io/opentelemetry/trace/BigendianEncoding.java\n\nCo-authored-by: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-09-01T21:23:12Z", "type": "commit"}, {"oid": "f1000faa9a16950b2149663ea4d6e58990aa1c75", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f1000faa9a16950b2149663ea4d6e58990aa1c75", "message": "Update extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/B3PropagatorInjectorSingleHeader.java\n\nCo-authored-by: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-09-01T21:23:12Z", "type": "commit"}, {"oid": "72783e296e7a6f0dcaeff6dd26bf4fcb728e838c", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/72783e296e7a6f0dcaeff6dd26bf4fcb728e838c", "message": "Update api/src/main/java/io/opentelemetry/trace/SpanId.java\n\nCo-authored-by: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-09-01T21:23:12Z", "type": "commit"}, {"oid": "6522ed3410beec9b516f3d3c5ceb5d2b685fe9df", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6522ed3410beec9b516f3d3c5ceb5d2b685fe9df", "message": "Update api/src/main/java/io/opentelemetry/trace/TraceId.java\n\nCo-authored-by: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-09-01T21:23:12Z", "type": "commit"}, {"oid": "d0f0b120ba099ce1b4d9d614dabcc21fe994999e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d0f0b120ba099ce1b4d9d614dabcc21fe994999e", "message": "updates from PR suggestion fubars", "committedDate": "2020-09-01T21:23:12Z", "type": "commit"}, {"oid": "410ce78d424665304a86fe27ec5986c4dc32e9b7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/410ce78d424665304a86fe27ec5986c4dc32e9b7", "message": "some cleanup from PR feedback", "committedDate": "2020-09-01T21:23:12Z", "type": "commit"}, {"oid": "362cba901d70ac1ab76481920d7baf30ca05fc33", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/362cba901d70ac1ab76481920d7baf30ca05fc33", "message": "Switch back to String from CharSequence", "committedDate": "2020-09-01T21:23:12Z", "type": "commit"}, {"oid": "07a9eec347172a342c5e2803c9137bbf3d54239b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/07a9eec347172a342c5e2803c9137bbf3d54239b", "message": "Get rid of the overload with the offsets", "committedDate": "2020-09-01T21:23:13Z", "type": "commit"}, {"oid": "4bf20569a322abb0989d1c109fcfd2f048e7c586", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4bf20569a322abb0989d1c109fcfd2f048e7c586", "message": "Lots of bits of cleanup from PR feedback.", "committedDate": "2020-09-01T21:23:13Z", "type": "commit"}, {"oid": "85aafd2c6235e86e1d3f099cfdd025277920c3f8", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/85aafd2c6235e86e1d3f099cfdd025277920c3f8", "message": "more renaming of base16 to hex", "committedDate": "2020-09-01T21:42:44Z", "type": "commit"}, {"oid": "85aafd2c6235e86e1d3f099cfdd025277920c3f8", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/85aafd2c6235e86e1d3f099cfdd025277920c3f8", "message": "more renaming of base16 to hex", "committedDate": "2020-09-01T21:42:44Z", "type": "forcePushed"}]}