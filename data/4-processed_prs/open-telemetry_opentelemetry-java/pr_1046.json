{"pr_number": 1046, "pr_title": "added jaeger propagator and tests", "pr_createdAt": "2020-03-27T08:24:21Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046", "timeline": [{"oid": "a43ca37adb4d4ca8f8107804512bf282f6f0f958", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a43ca37adb4d4ca8f8107804512bf282f6f0f958", "message": "added jaeger propogator and test", "committedDate": "2020-03-26T23:59:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTEzNzQxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399137416", "bodyText": "TRUE_INT and FALSE_INT kinda misleading names because type is String and they are using to mark that span is sampled, if u are wanna use static variable consider to use smth like IS_SAMPLED", "author": "DotSpy", "createdAt": "2020-03-27T09:33:19Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";", "originalCommit": "a43ca37adb4d4ca8f8107804512bf282f6f0f958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0MjQ3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399142471", "bodyText": "same for this name explain that we are setting it to 0 because this field is deprecated.", "author": "DotSpy", "createdAt": "2020-03-27T09:42:07Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";", "originalCommit": "a43ca37adb4d4ca8f8107804512bf282f6f0f958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0MzI4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399143289", "bodyText": "if u are using UTF-8 one time i don't think it worse it to do a static variable for it", "author": "DotSpy", "createdAt": "2020-03-27T09:43:38Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";", "originalCommit": "a43ca37adb4d4ca8f8107804512bf282f6f0f958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0NTgyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399245829", "bodyText": "There might be a built in constant StandardCharsets.UTF_8.name();", "author": "pavolloffay", "createdAt": "2020-03-27T12:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0MzI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0NTk5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399145997", "bodyText": "consider to log here value that we couldn't decode", "author": "DotSpy", "createdAt": "2020-03-27T09:48:14Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty header: '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, UTF_8);\n+    } catch (UnsupportedEncodingException e) {\n+      logger.info(\"Error decoding '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");", "originalCommit": "a43ca37adb4d4ca8f8107804512bf282f6f0f958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTE0NjkzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399146939", "bodyText": "consider to log here trace id that invalid", "author": "DotSpy", "createdAt": "2020-03-27T09:49:52Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty header: '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, UTF_8);\n+    } catch (UnsupportedEncodingException e) {\n+      logger.info(\"Error decoding '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String[] parts = value.split(SEPARATOR);\n+    if (parts.length != 4) {\n+      logger.info(\"Invalid header '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String traceId = parts[0];\n+    if (!isTraceIdValid(traceId)) {\n+      logger.info(\n+          \"Invalid TraceId in Jaeger header: '\"", "originalCommit": "a43ca37adb4d4ca8f8107804512bf282f6f0f958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0ODMyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399248321", "bodyText": "This log is not necessary. It can happen quite often.", "author": "pavolloffay", "createdAt": "2020-03-27T13:04:11Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(", "originalCommit": "a43ca37adb4d4ca8f8107804512bf282f6f0f958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI0OTY0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399249645", "bodyText": "nit: log the value", "author": "pavolloffay", "createdAt": "2020-03-27T13:06:33Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  static final String PARENT_SPAN = \"0\";\n+  static final String TRUE_INT = \"1\";\n+  static final String FALSE_INT = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String UTF_8 = \"UTF-8\";\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? TRUE_INT : FALSE_INT;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      logger.info(\n+          \"Missing or empty header: '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, UTF_8);\n+    } catch (UnsupportedEncodingException e) {\n+      logger.info(\"Error decoding '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String[] parts = value.split(SEPARATOR);\n+    if (parts.length != 4) {\n+      logger.info(\"Invalid header '\" + TRACE_ID_HEADER + \"'. Returning INVALID span context.\");", "originalCommit": "a43ca37adb4d4ca8f8107804512bf282f6f0f958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI1MjcyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399252722", "bodyText": "Tests could use Jaeger client and compare results on in the carrier with this implementation.", "author": "pavolloffay", "createdAt": "2020-03-27T13:11:49Z", "path": "api/src/test/java/io/opentelemetry/trace/propagation/JaegerPropagatorTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static com.google.common.truth.Truth.assertThat;\n+import static io.opentelemetry.trace.propagation.JaegerPropagator.PARENT_SPAN;\n+import static io.opentelemetry.trace.propagation.JaegerPropagator.SEPARATOR;\n+import static io.opentelemetry.trace.propagation.JaegerPropagator.TRACE_ID_HEADER;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Unit tests for {@link io.opentelemetry.trace.propagation.JaegerPropagator}. */\n+@RunWith(JUnit4.class)\n+public class JaegerPropagatorTest {", "originalCommit": "a43ca37adb4d4ca8f8107804512bf282f6f0f958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2MjkxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r399862918", "bodyText": "Thanks - I've added the Jaeger client and used the  TextMapCodec to generate the value to compare against.", "author": "jarebudev", "createdAt": "2020-03-29T22:26:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTI1MjcyMg=="}], "type": "inlineReview"}, {"oid": "0861da2d10ad548d2a4d443771634c0b8c640ed9", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0861da2d10ad548d2a4d443771634c0b8c640ed9", "message": "address PR comments about logging and static var names", "committedDate": "2020-03-28T21:38:59Z", "type": "commit"}, {"oid": "139050b0709f678ea961fa39985b35d724d7398b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/139050b0709f678ea961fa39985b35d724d7398b", "message": "added jaeger client for testing jaeger propagator", "committedDate": "2020-03-29T22:20:48Z", "type": "commit"}, {"oid": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c", "message": "resolved conflict in build.gradle", "committedDate": "2020-03-30T20:44:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MzQyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r400543428", "bodyText": "The standard says that it is base16 encoded, I am not sure why do you need to call URLDecoder(base16) is base16 if I am not missing something.", "author": "bogdandrutu", "createdAt": "2020-03-30T22:55:43Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  // Parent span has been deprecated but Jaeger propagation protocol requires it\n+  static final String DEPRECATED_PARENT_SPAN = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String IS_SAMPLED = \"1\";\n+  private static final String NOT_SAMPLED = \"0\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + DEPRECATED_PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, \"UTF-8\");", "originalCommit": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NzY4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r400547680", "bodyText": "I think I got it the separator \":\" may be encoded, please comment.", "author": "bogdandrutu", "createdAt": "2020-03-30T23:07:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MzQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE5ODUzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r401198530", "bodyText": "Yes that's correct - the separator can be encoded, so we decode it before trying to split", "author": "jarebudev", "createdAt": "2020-03-31T20:35:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MzQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY4NDk4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r401684985", "bodyText": "worth adding a comment into the code about it?", "author": "jkwatson", "createdAt": "2020-04-01T15:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MzQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA5MDE4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r402090186", "bodyText": "yeh i'll add in a comment", "author": "jarebudev", "createdAt": "2020-04-02T06:56:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MzQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NjY3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r400546672", "bodyText": "consider to benchmark this to see if allocated a char[] with the right size and calling copyLowerBase16To gives better performance. maybe just a TODO.", "author": "bogdandrutu", "createdAt": "2020-03-30T23:04:43Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  // Parent span has been deprecated but Jaeger propagation protocol requires it\n+  static final String DEPRECATED_PARENT_SPAN = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String IS_SAMPLED = \"1\";\n+  private static final String NOT_SAMPLED = \"0\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + DEPRECATED_PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);", "originalCommit": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjA5OTc4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r402099784", "bodyText": "I had a look into creating jmh benchmarks for the import and export of the context using JaegerPropagator - I think they will look similar to the ones already written for HttpTraceContext.\nWorth raising a seperate issue to add these?", "author": "jarebudev", "createdAt": "2020-04-02T07:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NjY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjEyNzA1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r402127052", "bodyText": "@jpkrohling Yeap, it will be clearer if u add it as separate issue, so it will be easier to track", "author": "DotSpy", "createdAt": "2020-04-02T08:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NjY3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NzcwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r400547700", "bodyText": "You can avoid using split. The first separator is the only one which can be on different position then all the others are at known positions relative to the first one.", "author": "bogdandrutu", "createdAt": "2020-03-30T23:07:53Z", "path": "api/src/main/java/io/opentelemetry/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.trace.propagation;\n+\n+import static io.opentelemetry.internal.Utils.checkNotNull;\n+\n+import io.grpc.Context;\n+import io.opentelemetry.context.propagation.HttpTextFormat;\n+import io.opentelemetry.internal.StringUtils;\n+import io.opentelemetry.trace.DefaultSpan;\n+import io.opentelemetry.trace.Span;\n+import io.opentelemetry.trace.SpanContext;\n+import io.opentelemetry.trace.SpanId;\n+import io.opentelemetry.trace.TraceFlags;\n+import io.opentelemetry.trace.TraceId;\n+import io.opentelemetry.trace.TraceState;\n+import io.opentelemetry.trace.TracingContextUtils;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * Implementation of the Jaeger propagation protocol. See <a\n+ * href=https://www.jaegertracing.io/docs/client-libraries/#propagation-format>Jaeger Propogation\n+ * Format</a>.\n+ */\n+@Immutable\n+public class JaegerPropagator implements HttpTextFormat {\n+\n+  private static final Logger logger = Logger.getLogger(HttpTraceContext.class.getName());\n+\n+  static final String TRACE_ID_HEADER = \"uber-trace-id\";\n+  // Parent span has been deprecated but Jaeger propagation protocol requires it\n+  static final String DEPRECATED_PARENT_SPAN = \"0\";\n+  static final String SEPARATOR = \":\";\n+\n+  private static final String IS_SAMPLED = \"1\";\n+  private static final String NOT_SAMPLED = \"0\";\n+\n+  private static final int MAX_TRACE_ID_LENGTH = 2 * TraceId.getSize();\n+  private static final int MAX_SPAN_ID_LENGTH = 2 * SpanId.getSize();\n+  private static final int MAX_FLAGS_LENGTH = 2;\n+  private static final TraceFlags SAMPLED_FLAGS = TraceFlags.builder().setIsSampled(true).build();\n+  private static final TraceFlags NOT_SAMPLED_FLAGS =\n+      TraceFlags.builder().setIsSampled(false).build();\n+\n+  private static final List<String> FIELDS = Collections.singletonList(TRACE_ID_HEADER);\n+\n+  @Override\n+  public List<String> fields() {\n+    return FIELDS;\n+  }\n+\n+  @Override\n+  public <C> void inject(Context context, C carrier, Setter<C> setter) {\n+    checkNotNull(context, \"context\");\n+    checkNotNull(setter, \"setter\");\n+    checkNotNull(carrier, \"carrier\");\n+\n+    Span span = TracingContextUtils.getSpanWithoutDefault(context);\n+    if (span == null) {\n+      return;\n+    }\n+\n+    SpanContext spanContext = span.getContext();\n+    String sampled = spanContext.getTraceFlags().isSampled() ? IS_SAMPLED : NOT_SAMPLED;\n+\n+    setter.set(\n+        carrier,\n+        TRACE_ID_HEADER,\n+        spanContext.getTraceId().toLowerBase16()\n+            + SEPARATOR\n+            + spanContext.getSpanId().toLowerBase16()\n+            + SEPARATOR\n+            + DEPRECATED_PARENT_SPAN\n+            + SEPARATOR\n+            + sampled);\n+  }\n+\n+  @Override\n+  public <C> Context extract(Context context, C carrier, Getter<C> getter) {\n+    checkNotNull(carrier, \"carrier\");\n+    checkNotNull(getter, \"getter\");\n+\n+    SpanContext spanContext = getSpanContextFromHeader(carrier, getter);\n+\n+    return TracingContextUtils.withSpan(DefaultSpan.create(spanContext), context);\n+  }\n+\n+  @SuppressWarnings(\"StringSplitter\")\n+  private static <C> SpanContext getSpanContextFromHeader(C carrier, Getter<C> getter) {\n+    String value = getter.get(carrier, TRACE_ID_HEADER);\n+    if (StringUtils.isNullOrEmpty(value)) {\n+      return SpanContext.getInvalid();\n+    }\n+\n+    try {\n+      value = URLDecoder.decode(value, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      logger.info(\n+          \"Error decoding '\"\n+              + TRACE_ID_HEADER\n+              + \"' with value \"\n+              + value\n+              + \". Returning INVALID span context.\");\n+      return SpanContext.getInvalid();\n+    }\n+\n+    String[] parts = value.split(SEPARATOR);", "originalCommit": "ca9ac4b1ef7a862059a7c97e5e2ec9752329ab5c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0ODMxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r400548319", "bodyText": "Or the base16 encoding in the spec actually is hex encoded which means is variable size?", "author": "bogdandrutu", "createdAt": "2020-03-30T23:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NzcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMTIxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r401211217", "bodyText": "If I understood the propagation spec correctly, the 3rd part (parent span id) may be set, or could be 0.  I guess it depends on which Jaeger client is being used to generate the propagation value which we wont know.\nI could look at using alternatives to String.split if we want to optimise.  Possibly StringTokenizer?", "author": "jarebudev", "createdAt": "2020-03-31T20:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NzcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTIxMzc3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1046#discussion_r401213773", "bodyText": "scratch the bit about StringTokenizer - just looked at it and its use in new code is discouraged.", "author": "jarebudev", "createdAt": "2020-03-31T21:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NzcwMA=="}], "type": "inlineReview"}, {"oid": "7526af496f0bc2022cc25e0e110a95faf367cecb", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7526af496f0bc2022cc25e0e110a95faf367cecb", "message": "added comment to explain why UTF-8 decoding is needed", "committedDate": "2020-04-02T07:05:59Z", "type": "commit"}]}