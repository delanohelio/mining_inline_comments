{"pr_number": 990, "pr_title": "Add benchmarks for metrics API", "pr_createdAt": "2020-03-10T19:20:27Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/990", "timeline": [{"oid": "5cd56c190e0b6f567eaba8a0b033802503d47f0d", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5cd56c190e0b6f567eaba8a0b033802503d47f0d", "message": "Add benchmarks for metrics API", "committedDate": "2020-03-10T19:19:23Z", "type": "commit"}, {"oid": "94df20d7b736cac02840c4e9f5bc972c6d317fc6", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/94df20d7b736cac02840c4e9f5bc972c6d317fc6", "message": "update to meet Google Java style guidelines", "committedDate": "2020-03-10T19:39:22Z", "type": "commit"}, {"oid": "491864ded74d22cfcaa189ec0f8abb1609b9ee4e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/491864ded74d22cfcaa189ec0f8abb1609b9ee4e", "message": "reduce code duplication in measurements\n\nSplit measurements and SDKs into two enums that can\nbe pulled together into a matrix, which has an\nadditional benefit that comparable metrics are\npulled onto the same scale in the JMH visualizer", "committedDate": "2020-03-16T23:55:39Z", "type": "commit"}, {"oid": "6c8b1097db18b49c7ed4aaef5754acadeb79ac52", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6c8b1097db18b49c7ed4aaef5754acadeb79ac52", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into metrics_api_benchmarks", "committedDate": "2020-03-17T00:57:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4Nzg4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/990#discussion_r396187885", "bodyText": "API_ONLY? I don't know maybe you can think of a better name :), kind of don't like NO_SDK.", "author": "bogdandrutu", "createdAt": "2020-03-23T02:39:31Z", "path": "sdk/src/jmh/java/io/opentelemetry/sdk/metrics/TestSdk.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import com.google.errorprone.annotations.Immutable;\n+import io.opentelemetry.metrics.DefaultMeter;\n+import io.opentelemetry.metrics.Meter;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.internal.MillisClock;\n+import io.opentelemetry.sdk.resources.Resource;\n+\n+public enum TestSdk {\n+  NO_SDK(", "originalCommit": "6c8b1097db18b49c7ed4aaef5754acadeb79ac52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU3NTE3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/990#discussion_r396575179", "bodyText": "I actually really like API_ONLY- I think that's both clearer and more positive.", "author": "zenmoto", "createdAt": "2020-03-23T16:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4Nzg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODYzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/990#discussion_r396188630", "bodyText": "Don't see a clear advantage to use generics here. Can we get rid of them?", "author": "bogdandrutu", "createdAt": "2020-03-23T02:43:32Z", "path": "sdk/src/jmh/java/io/opentelemetry/sdk/metrics/MetricsTestOperationBuilder.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import com.google.errorprone.annotations.Immutable;\n+import io.opentelemetry.metrics.DoubleCounter;\n+import io.opentelemetry.metrics.DoubleMeasure;\n+import io.opentelemetry.metrics.LongCounter;\n+import io.opentelemetry.metrics.LongMeasure;\n+import io.opentelemetry.metrics.Meter;\n+\n+/**\n+ * This enum allows for iteration over all of the operations that we want to benchmark. To ensure\n+ * that the enum cannot change state, each enum holds a builder function- passing a meter in will\n+ * return a wrapper for both bound and unbound versions of that operation which can then be used in\n+ * a benchmark.\n+ */\n+public enum MetricsTestOperationBuilder {\n+  LongCounterAdd(\n+      new OperationBuilder<LongCounter, LongCounter.BoundLongCounter>() {\n+        @Override\n+        public Operation<LongCounter, LongCounter.BoundLongCounter> build(Meter meter) {\n+          Operation<LongCounter, LongCounter.BoundLongCounter> op =\n+              new Operation<LongCounter, LongCounter.BoundLongCounter>() {\n+                @Override\n+                void perform(String... args) {\n+                  metric.add(5L, args);\n+                }\n+\n+                @Override\n+                void performBound() {\n+                  boundMetric.add(5L);\n+                }\n+\n+                @Override\n+                protected void initialize(Meter meter) {\n+                  metric = meter.longCounterBuilder(\"long_counter\").build();\n+                  boundMetric =\n+                      meter.longCounterBuilder(\"bound_long_counter\").build().bind(\"KEY\", \"VALUE\");\n+                }\n+              };\n+          op.initialize(meter);\n+          return op;\n+        }\n+      }),\n+  DoubleCounterAdd(\n+      new OperationBuilder<DoubleCounter, DoubleCounter.BoundDoubleCounter>() {\n+        @Override\n+        public Operation<DoubleCounter, DoubleCounter.BoundDoubleCounter> build(Meter meter) {\n+          Operation<DoubleCounter, DoubleCounter.BoundDoubleCounter> op =\n+              new Operation<DoubleCounter, DoubleCounter.BoundDoubleCounter>() {\n+                @Override\n+                void perform(String... args) {\n+                  metric.add(5.0d, args);\n+                }\n+\n+                @Override\n+                void performBound() {\n+                  boundMetric.add(5.0d);\n+                }\n+\n+                @Override\n+                protected void initialize(Meter meter) {\n+                  metric = meter.doubleCounterBuilder(\"double_counter\").build();\n+                  boundMetric =\n+                      meter\n+                          .doubleCounterBuilder(\"bound_double_counter\")\n+                          .build()\n+                          .bind(\"KEY\", \"VALUE\");\n+                }\n+              };\n+          op.initialize(meter);\n+          return op;\n+        }\n+      }),\n+  DoubleMeasureRecord(\n+      new OperationBuilder<DoubleMeasure, DoubleMeasure.BoundDoubleMeasure>() {\n+        @Override\n+        public Operation<DoubleMeasure, DoubleMeasure.BoundDoubleMeasure> build(Meter meter) {\n+          Operation<DoubleMeasure, DoubleMeasure.BoundDoubleMeasure> op =\n+              new Operation<DoubleMeasure, DoubleMeasure.BoundDoubleMeasure>() {\n+                @Override\n+                void perform(String... args) {\n+                  metric.record(5.0d, args);\n+                }\n+\n+                @Override\n+                void performBound() {\n+                  boundMetric.record(5.0d);\n+                }\n+\n+                @Override\n+                protected void initialize(Meter meter) {\n+                  metric = meter.doubleMeasureBuilder(\"double_measure\").build();\n+                  boundMetric =\n+                      meter\n+                          .doubleMeasureBuilder(\"bound_double_measure\")\n+                          .build()\n+                          .bind(\"KEY\", \"VALUE\");\n+                }\n+              };\n+          op.initialize(meter);\n+          return op;\n+        }\n+      }),\n+  LongMeasureRecord(\n+      new OperationBuilder<LongMeasure, LongMeasure.BoundLongMeasure>() {\n+        @Override\n+        public Operation<LongMeasure, LongMeasure.BoundLongMeasure> build(Meter meter) {\n+          Operation<LongMeasure, LongMeasure.BoundLongMeasure> op =\n+              new Operation<LongMeasure, LongMeasure.BoundLongMeasure>() {\n+                @Override\n+                void perform(String... args) {\n+                  metric.record(5L, args);\n+                }\n+\n+                @Override\n+                void performBound() {\n+                  boundMetric.record(5L);\n+                }\n+\n+                @Override\n+                protected void initialize(Meter meter) {\n+                  metric = meter.longMeasureBuilder(\"long_measure\").build();\n+                  boundMetric =\n+                      meter.longMeasureBuilder(\"bound_long_measure\").build().bind(\"KEY\", \"VALUE\");\n+                }\n+              };\n+          op.initialize(meter);\n+          return op;\n+        }\n+      });\n+\n+  private final OperationBuilder<?, ?> builder;\n+\n+  MetricsTestOperationBuilder(final OperationBuilder<?, ?> builder) {\n+    this.builder = builder;\n+  }\n+\n+  public Operation<?, ?> build(Meter meter) {\n+    return this.builder.build(meter);\n+  }\n+\n+  @Immutable\n+  private interface OperationBuilder<T, U> {\n+    Operation<T, U> build(Meter meter);\n+  }\n+\n+  abstract static class Operation<T, U> {\n+    T metric;\n+    U boundMetric;", "originalCommit": "6c8b1097db18b49c7ed4aaef5754acadeb79ac52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU5MjgxNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/990#discussion_r396592814", "bodyText": "This is what's allowing us to use the metrics without an explicit cast in the Operation instances like metric.add(5L, args). Otherwise both metric and boundMetric are going to need to be bare objects with casts everywhere we refer to them (which is not often. I think I prefer the generic way, but if you prefer the raw Object because the generics are distracting, I'm sympathetic to that argument.", "author": "zenmoto", "createdAt": "2020-03-23T16:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODYzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYzOTM5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/990#discussion_r396639391", "bodyText": "metric and metricBound can be members in the sub-class you don't need them here because you don't need access to them when calling perform and performBound.", "author": "bogdandrutu", "createdAt": "2020-03-23T17:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODYzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njc0MTI5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/990#discussion_r396741297", "bodyText": "Of course, thank you. Tried this too many ways before and was overlooking the obvious here.", "author": "zenmoto", "createdAt": "2020-03-23T20:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4ODYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4OTAwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/990#discussion_r396189006", "bodyText": "It seems that this is a common pattern to call initialize as the fist thing after the ctor is called. Do we really need an initialize method or we can just move the code and get rid of that method?", "author": "bogdandrutu", "createdAt": "2020-03-23T02:45:34Z", "path": "sdk/src/jmh/java/io/opentelemetry/sdk/metrics/MetricsTestOperationBuilder.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.metrics;\n+\n+import com.google.errorprone.annotations.Immutable;\n+import io.opentelemetry.metrics.DoubleCounter;\n+import io.opentelemetry.metrics.DoubleMeasure;\n+import io.opentelemetry.metrics.LongCounter;\n+import io.opentelemetry.metrics.LongMeasure;\n+import io.opentelemetry.metrics.Meter;\n+\n+/**\n+ * This enum allows for iteration over all of the operations that we want to benchmark. To ensure\n+ * that the enum cannot change state, each enum holds a builder function- passing a meter in will\n+ * return a wrapper for both bound and unbound versions of that operation which can then be used in\n+ * a benchmark.\n+ */\n+public enum MetricsTestOperationBuilder {\n+  LongCounterAdd(\n+      new OperationBuilder<LongCounter, LongCounter.BoundLongCounter>() {\n+        @Override\n+        public Operation<LongCounter, LongCounter.BoundLongCounter> build(Meter meter) {\n+          Operation<LongCounter, LongCounter.BoundLongCounter> op =\n+              new Operation<LongCounter, LongCounter.BoundLongCounter>() {\n+                @Override\n+                void perform(String... args) {\n+                  metric.add(5L, args);\n+                }\n+\n+                @Override\n+                void performBound() {\n+                  boundMetric.add(5L);\n+                }\n+\n+                @Override\n+                protected void initialize(Meter meter) {\n+                  metric = meter.longCounterBuilder(\"long_counter\").build();\n+                  boundMetric =\n+                      meter.longCounterBuilder(\"bound_long_counter\").build().bind(\"KEY\", \"VALUE\");\n+                }\n+              };\n+          op.initialize(meter);\n+          return op;\n+        }\n+      }),\n+  DoubleCounterAdd(\n+      new OperationBuilder<DoubleCounter, DoubleCounter.BoundDoubleCounter>() {\n+        @Override\n+        public Operation<DoubleCounter, DoubleCounter.BoundDoubleCounter> build(Meter meter) {\n+          Operation<DoubleCounter, DoubleCounter.BoundDoubleCounter> op =\n+              new Operation<DoubleCounter, DoubleCounter.BoundDoubleCounter>() {\n+                @Override\n+                void perform(String... args) {\n+                  metric.add(5.0d, args);\n+                }\n+\n+                @Override\n+                void performBound() {\n+                  boundMetric.add(5.0d);\n+                }\n+\n+                @Override\n+                protected void initialize(Meter meter) {\n+                  metric = meter.doubleCounterBuilder(\"double_counter\").build();\n+                  boundMetric =\n+                      meter\n+                          .doubleCounterBuilder(\"bound_double_counter\")\n+                          .build()\n+                          .bind(\"KEY\", \"VALUE\");\n+                }\n+              };\n+          op.initialize(meter);", "originalCommit": "6c8b1097db18b49c7ed4aaef5754acadeb79ac52", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxMjg3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/990#discussion_r396612878", "bodyText": "We need initialize(meter), because we can't have a constructor in an abstract class, and we need somewhere to build the correct metric/boundMetric set for the test. Code standards don't allow for calling an overridden method from a superclass constructor, but I can move this into a superclass build(Meter meter) that will clean this up a bit. The other alternative is to move all of these Operations into a named class and use constructors, but I think that will be less clear.", "author": "zenmoto", "createdAt": "2020-03-23T17:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4OTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYyNDUyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/990#discussion_r396624527", "bodyText": "Or I missed an obvious way to restructure this by passing the meter and bound meter into the constructor.  Oops.", "author": "zenmoto", "createdAt": "2020-03-23T17:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE4OTAwNg=="}], "type": "inlineReview"}, {"oid": "3c3f5deb90f59f596edcd3b1fedc9859ccc3bb7a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3c3f5deb90f59f596edcd3b1fedc9859ccc3bb7a", "message": "remove generics from tested operation, clean up construction", "committedDate": "2020-03-23T20:02:50Z", "type": "commit"}, {"oid": "4962258870f7b12fcd118da4e0077e0859cc8fb7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4962258870f7b12fcd118da4e0077e0859cc8fb7", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into metrics_api_benchmarks", "committedDate": "2020-03-23T20:03:26Z", "type": "commit"}]}