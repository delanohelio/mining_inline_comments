{"pr_number": 1325, "pr_title": "Convert Link and Event types to use the new immutable Attributes", "pr_createdAt": "2020-06-09T19:55:20Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325", "timeline": [{"oid": "542dddc4630141aefc14bcba6c07f044272868ef", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/542dddc4630141aefc14bcba6c07f044272868ef", "message": "Convert Link and Event types to use the new immutable Attributes\n\nupdate from the upstream branch\n\nupdate from parent branch changes", "committedDate": "2020-06-09T16:21:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MjQ2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r437772464", "bodyText": "why atomic? I think I know why because you need to change it in the lambda. You can have a size() on the builder maybe? Maybe create an issue because this smells a bit :)", "author": "bogdandrutu", "createdAt": "2020-06-09T23:13:23Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/RecordEventsReadableSpan.java", "diffHunk": "@@ -362,24 +363,23 @@ public void addEvent(io.opentelemetry.trace.Event event, long timestamp) {\n     addTimedEvent(TimedEvent.create(timestamp, event));\n   }\n \n-  static Map<String, AttributeValue> copyAndLimitAttributes(\n-      Map<String, AttributeValue> attributes, int limit) {\n-    if (attributes.isEmpty()) {\n-      return Collections.emptyMap();\n-    }\n-\n-    if (attributes.size() <= limit) {\n-      return Collections.unmodifiableMap(new HashMap<>(attributes));\n-    }\n-\n-    Map<String, AttributeValue> temp = new HashMap<>();\n-    for (Map.Entry<String, AttributeValue> entry : attributes.entrySet()) {\n-      if (temp.size() < limit) {\n-        temp.put(entry.getKey(), entry.getValue());\n-      }\n+  static Attributes copyAndLimitAttributes(final Attributes attributes, final int limit) {\n+    if (attributes.isEmpty() || attributes.size() <= limit) {\n+      return attributes;\n     }\n \n-    return Collections.unmodifiableMap(temp);\n+    final Attributes.Builder temp = Attributes.newBuilder();\n+    final AtomicInteger added = new AtomicInteger();", "originalCommit": "542dddc4630141aefc14bcba6c07f044272868ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4MTc1MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r437781751", "bodyText": "yes, entirely because it needed to be updated in the inner class. size() on the builder isn't a bad idea at all, though.\nI will note that we're going to need a more sophisticated builder-like class to handle the attributes on the active span itself, so maybe we can roll the cleanup into that change?", "author": "jkwatson", "createdAt": "2020-06-09T23:43:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NzEwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r437857101", "bodyText": "Does this work to avoid the atomic?\nattributes.forEach(\n        new KeyValueConsumer<AttributeValue>() {\n          private int added = 0;\n        \n          @Override\n          public void consume(String key, AttributeValue value) {\n            if (added <= limit) {\n              temp.setAttribute(key, value);\n              added++;\n            }\n          }\n        });\nI don't know if I've seen many builders with a size method. Doesn't mean it's a bad idea, but I think here the actual problem isn't about knowing size but about the fact that inner classes / lambdas can't mutate an outside local variable. Adding builder.size might help this specific situation but I don't think it's a real solution.", "author": "anuraaga", "createdAt": "2020-06-10T04:45:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODE5NzA4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r438197086", "bodyText": "Also another possibility that is probably the fastest is to add a public Attributes truncate(size int) method that both lables and attributes can have. That is the fastest because it does not need to create builders, call lambdas etc.\n@anuraaga I think for the moment your proposal is very good, also I would declare the builder in that class and probably make it a static final class not anonymous.", "author": "bogdandrutu", "createdAt": "2020-06-10T15:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIxMzY1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r438213653", "bodyText": "Just FYI, making a private static inner class also final doesn't do anything but add visual clutter, as it has no actual impact on anything.", "author": "jkwatson", "createdAt": "2020-06-10T15:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyMjIwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r438222205", "bodyText": "At least it show the clear intention that we don't want to extend, also it can be done extended from another static inner class.", "author": "bogdandrutu", "createdAt": "2020-06-10T15:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MjQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODIyNDE2Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r438224163", "bodyText": "ok, I did this. please take a look!", "author": "jkwatson", "createdAt": "2020-06-10T15:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3MjQ2NA=="}], "type": "inlineReview"}, {"oid": "ced433149574ec1fe883452e6a1ad7bf015061da", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ced433149574ec1fe883452e6a1ad7bf015061da", "message": "move the limiting of attributes to a custom consumer class", "committedDate": "2020-06-10T15:42:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNTcxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r438535713", "bodyText": "Would usually use something like result, not used to temp being as important as this one :)", "author": "anuraaga", "createdAt": "2020-06-11T04:27:16Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/RecordEventsReadableSpan.java", "diffHunk": "@@ -362,24 +362,14 @@ public void addEvent(io.opentelemetry.trace.Event event, long timestamp) {\n     addTimedEvent(TimedEvent.create(timestamp, event));\n   }\n \n-  static Map<String, AttributeValue> copyAndLimitAttributes(\n-      Map<String, AttributeValue> attributes, int limit) {\n-    if (attributes.isEmpty()) {\n-      return Collections.emptyMap();\n-    }\n-\n-    if (attributes.size() <= limit) {\n-      return Collections.unmodifiableMap(new HashMap<>(attributes));\n-    }\n-\n-    Map<String, AttributeValue> temp = new HashMap<>();\n-    for (Map.Entry<String, AttributeValue> entry : attributes.entrySet()) {\n-      if (temp.size() < limit) {\n-        temp.put(entry.getKey(), entry.getValue());\n-      }\n+  static Attributes copyAndLimitAttributes(final Attributes attributes, final int limit) {\n+    if (attributes.isEmpty() || attributes.size() <= limit) {\n+      return attributes;\n     }\n \n-    return Collections.unmodifiableMap(temp);\n+    Attributes.Builder temp = Attributes.newBuilder();", "originalCommit": "ced433149574ec1fe883452e6a1ad7bf015061da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3NzkwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r438877909", "bodyText": "agreed. will pick this up in the next round of changes.", "author": "jkwatson", "createdAt": "2020-06-11T15:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNTcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNjMyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r438536320", "bodyText": "This works because we don't expect any attributes to have more than Integer.MAX_VALUE size (where added will become negative and elements start being appended again), but even so it's probably clearer keep the logic precise instead of the increment shortcut. That said, this might go away soon anyways so no big deal just FYI.\nif (added < limit) {\n  buileder.set(...)\n  added++;\n}", "author": "anuraaga", "createdAt": "2020-06-11T04:30:00Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/RecordEventsReadableSpan.java", "diffHunk": "@@ -534,4 +524,22 @@ int getTotalRecordedLinks() {\n         ? Collections.unmodifiableMap(attributes)\n         : Collections.unmodifiableMap(new HashMap<>(attributes));\n   }\n+\n+  private static class LimitingAttributeConsumer implements KeyValueConsumer<AttributeValue> {\n+    private final int limit;\n+    private final Attributes.Builder builder;\n+    private int added;\n+\n+    public LimitingAttributeConsumer(int limit, Attributes.Builder builder) {\n+      this.limit = limit;\n+      this.builder = builder;\n+    }\n+\n+    @Override\n+    public void consume(String key, AttributeValue value) {\n+      if (added++ < limit) {", "originalCommit": "ced433149574ec1fe883452e6a1ad7bf015061da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg3MjAwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r438872004", "bodyText": "Are you suggesting the change for a functional reason, or just for clarity? what you suggest is identical functionally.\nI don't understand the Integer.MAX_VALUE comment here. Attributes limits should never come anywhere close to that, so I have zero concern around overflowing the int. Do you have a use-case that I'm not thinking of?", "author": "jkwatson", "createdAt": "2020-06-11T15:29:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNjMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0NjA3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r439146072", "bodyText": "Mostly just for clarity - the fact that attribute limits should never come close is true but also some hidden knowledge needed to know the code works. It's nice to reduce hidden knowledge if it's not a burden, I guess one extra line of code isn't so bad. Also allows the added variable to actually be true since the value stops being how many were added, but how many were consumed, after the limit.\nVery small nits, just added them for future reference.", "author": "anuraaga", "createdAt": "2020-06-12T00:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNjMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE2OTk0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1325#discussion_r439169942", "bodyText": "ah, yes, I do agree with all of this. I'll be sure to include the cleanup in a future PR", "author": "jkwatson", "createdAt": "2020-06-12T02:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUzNjMyMA=="}], "type": "inlineReview"}]}