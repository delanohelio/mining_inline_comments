{"pr_number": 1524, "pr_title": "initial commit of logging support extension", "pr_createdAt": "2020-08-10T20:27:56Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524", "timeline": [{"oid": "0209c779a13deae1cba177b236ad5c9f01c32858", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0209c779a13deae1cba177b236ad5c9f01c32858", "message": "initial commit of logging support extension", "committedDate": "2020-08-10T20:18:45Z", "type": "commit"}, {"oid": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "message": "complete move from extensions to sdk_extensions", "committedDate": "2020-08-10T20:36:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNDMxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468224319", "bodyText": "I think these should all be 0.8.0 now, since we've already released 0.7.0", "author": "jkwatson", "createdAt": "2020-08-10T22:38:31Z", "path": "sdk_extensions/logging_support/src/main/java/io/opentelemetry/common/AnyValue.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * A class that represents all the possible values for a data body. An {@code AnyValue} can have 6\n+ * types of values: {@code String}, {@code boolean}, {@code int}, {@code double}, {@code array}, or\n+ * {@code kvlist}. represented through {@code AnyValue.Type}. A {@code array} or a {@code kvlist}\n+ * can in turn hold other {@code AnyValue} instances, allowing for mapping to JSON-like structures.\n+ *\n+ * @since 0.7.0", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1NTcxNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468255717", "bodyText": "Also I think we can add it only to the class, not all the methods in the class, for new classes. I think it's how the JDK manages it.", "author": "anuraaga", "createdAt": "2020-08-11T00:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNDMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNjc4Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468226786", "bodyText": "Any reason not to use AutoValue for this?", "author": "jkwatson", "createdAt": "2020-08-10T22:45:36Z", "path": "sdk_extensions/logging_support/src/main/java/io/opentelemetry/logging/DefaultLogRecord.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.common.AnyValue;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.util.Map;\n+\n+public class DefaultLogRecord implements LogRecord {", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0NDczNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468244734", "bodyText": "The intent is to allow for flexibility in implementing these records- for example I would prefer to make an adapter for a Log4j record rather than copying each of the fields.", "author": "zenmoto", "createdAt": "2020-08-10T23:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNjc4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1NjE5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468256193", "bodyText": "We can make that change if we need to later, it's sort of an implementation detail. Since this seems to be a simple POJO for now, we may as well get sane equality / tostring for free while we're here", "author": "anuraaga", "createdAt": "2020-08-11T00:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNjc4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyOTY1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468229659", "bodyText": "Prefer using a single-threaded ExecutorService, rather than using a Timer.", "author": "jkwatson", "createdAt": "2020-08-10T22:54:36Z", "path": "sdk_extensions/logging_support/src/main/java/io/opentelemetry/logging/SizeOrLatencyBatchStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Batching strategy that allows specifying both a maximum size and a maximum amount of time before\n+ * sending a batch of records. Batch will be flushed whenever the list of records queued exceeds the\n+ * maximum threshold (default 50), or a set timeout expires (default 5 seconds).\n+ */\n+public class SizeOrLatencyBatchStrategy implements LoggingBatchStrategy {\n+  private static final int DEFAULT_BATCH_SIZE = 50;\n+  private static final int DEFAULT_MAX_DELAY = 5;\n+  private static final TimeUnit DEFAULT_MAX_DELAY_UNITS = TimeUnit.SECONDS;\n+  private static final Timer timer = new Timer();", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMTExNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468231116", "bodyText": "why not just have a fixed rate of export, and have the exporter no-op if there's nothing to export? This extra bit of complication, and extra synchronization on every log record(!) seems like more than is needed.", "author": "jkwatson", "createdAt": "2020-08-10T22:58:43Z", "path": "sdk_extensions/logging_support/src/main/java/io/opentelemetry/logging/SizeOrLatencyBatchStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Batching strategy that allows specifying both a maximum size and a maximum amount of time before\n+ * sending a batch of records. Batch will be flushed whenever the list of records queued exceeds the\n+ * maximum threshold (default 50), or a set timeout expires (default 5 seconds).\n+ */\n+public class SizeOrLatencyBatchStrategy implements LoggingBatchStrategy {\n+  private static final int DEFAULT_BATCH_SIZE = 50;\n+  private static final int DEFAULT_MAX_DELAY = 5;\n+  private static final TimeUnit DEFAULT_MAX_DELAY_UNITS = TimeUnit.SECONDS;\n+  private static final Timer timer = new Timer();\n+\n+  private final int maxBatch;\n+  private final int maxDelay;\n+  private final TimeUnit maxDelayUnits;\n+\n+  private WeakReference<LoggingBatchExporter> batchHandler;\n+  private List<LogRecord> batch = new ArrayList<>();\n+  private boolean timerPending = false;\n+\n+  private SizeOrLatencyBatchStrategy(int maxBatch, int maxDelay, TimeUnit units) {\n+    this.maxBatch = maxBatch > 0 ? maxBatch : DEFAULT_BATCH_SIZE;\n+    this.maxDelay = maxDelay > 0 ? maxDelay : DEFAULT_MAX_DELAY;\n+    this.maxDelayUnits = units != null ? units : DEFAULT_MAX_DELAY_UNITS;\n+  }\n+\n+  @Override\n+  public void add(LogRecord record) {\n+    synchronized (this) {\n+      if (!timerPending) {", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0NDY3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468244679", "bodyText": "I got over-fixated on having the \"right\" interval between batches. Of course it's better to do this more simply, avoid the synchronization, and occasionally have an extra batch.", "author": "zenmoto", "createdAt": "2020-08-10T23:41:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMTExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjAwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468232003", "bodyText": "Can this be implemented with a Queue, rather than a bare List? The synchronization needed to manage this seems like a recipe for bad contention issues.", "author": "jkwatson", "createdAt": "2020-08-10T23:01:29Z", "path": "sdk_extensions/logging_support/src/main/java/io/opentelemetry/logging/SizeOrLatencyBatchStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Batching strategy that allows specifying both a maximum size and a maximum amount of time before\n+ * sending a batch of records. Batch will be flushed whenever the list of records queued exceeds the\n+ * maximum threshold (default 50), or a set timeout expires (default 5 seconds).\n+ */\n+public class SizeOrLatencyBatchStrategy implements LoggingBatchStrategy {\n+  private static final int DEFAULT_BATCH_SIZE = 50;\n+  private static final int DEFAULT_MAX_DELAY = 5;\n+  private static final TimeUnit DEFAULT_MAX_DELAY_UNITS = TimeUnit.SECONDS;\n+  private static final Timer timer = new Timer();\n+\n+  private final int maxBatch;\n+  private final int maxDelay;\n+  private final TimeUnit maxDelayUnits;\n+\n+  private WeakReference<LoggingBatchExporter> batchHandler;\n+  private List<LogRecord> batch = new ArrayList<>();", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjM4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468232382", "bodyText": "If we do end up needing to synchronize on every record addition, we should definitely synchronize on a private final member variable, rather than this, which could allow another user to deadlock this process by synchronizing on the Strategy instance by accident (or on purpose).", "author": "jkwatson", "createdAt": "2020-08-10T23:02:43Z", "path": "sdk_extensions/logging_support/src/main/java/io/opentelemetry/logging/SizeOrLatencyBatchStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Batching strategy that allows specifying both a maximum size and a maximum amount of time before\n+ * sending a batch of records. Batch will be flushed whenever the list of records queued exceeds the\n+ * maximum threshold (default 50), or a set timeout expires (default 5 seconds).\n+ */\n+public class SizeOrLatencyBatchStrategy implements LoggingBatchStrategy {\n+  private static final int DEFAULT_BATCH_SIZE = 50;\n+  private static final int DEFAULT_MAX_DELAY = 5;\n+  private static final TimeUnit DEFAULT_MAX_DELAY_UNITS = TimeUnit.SECONDS;\n+  private static final Timer timer = new Timer();\n+\n+  private final int maxBatch;\n+  private final int maxDelay;\n+  private final TimeUnit maxDelayUnits;\n+\n+  private WeakReference<LoggingBatchExporter> batchHandler;\n+  private List<LogRecord> batch = new ArrayList<>();\n+  private boolean timerPending = false;\n+\n+  private SizeOrLatencyBatchStrategy(int maxBatch, int maxDelay, TimeUnit units) {\n+    this.maxBatch = maxBatch > 0 ? maxBatch : DEFAULT_BATCH_SIZE;\n+    this.maxDelay = maxDelay > 0 ? maxDelay : DEFAULT_MAX_DELAY;\n+    this.maxDelayUnits = units != null ? units : DEFAULT_MAX_DELAY_UNITS;\n+  }\n+\n+  @Override\n+  public void add(LogRecord record) {\n+    synchronized (this) {", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0NDQyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468244429", "bodyText": "Thanks. I think I'll take the approach of reducing the synchronization, but I'll remember this for next time.", "author": "zenmoto", "createdAt": "2020-08-10T23:41:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjc3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468232779", "bodyText": "Why the WeakReference here? Is it really needed? Having this would make it easy for someone to assign an exporter, and not keep a reference to it, ending exports altogether without them knowing why it had happened.", "author": "jkwatson", "createdAt": "2020-08-10T23:04:02Z", "path": "sdk_extensions/logging_support/src/main/java/io/opentelemetry/logging/SizeOrLatencyBatchStrategy.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Batching strategy that allows specifying both a maximum size and a maximum amount of time before\n+ * sending a batch of records. Batch will be flushed whenever the list of records queued exceeds the\n+ * maximum threshold (default 50), or a set timeout expires (default 5 seconds).\n+ */\n+public class SizeOrLatencyBatchStrategy implements LoggingBatchStrategy {\n+  private static final int DEFAULT_BATCH_SIZE = 50;\n+  private static final int DEFAULT_MAX_DELAY = 5;\n+  private static final TimeUnit DEFAULT_MAX_DELAY_UNITS = TimeUnit.SECONDS;\n+  private static final Timer timer = new Timer();\n+\n+  private final int maxBatch;\n+  private final int maxDelay;\n+  private final TimeUnit maxDelayUnits;\n+\n+  private WeakReference<LoggingBatchExporter> batchHandler;", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0NjUwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468246501", "bodyText": "I added this because the LogSink holds a reference to the strategy, and then passes itself in as a delegate, so I was trying to avoid a reference cycle. It would be much cleaner to not have the weak reference and just pass an anonymous inner class instead. I'll change that.", "author": "zenmoto", "createdAt": "2020-08-10T23:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1Njg3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468256878", "bodyText": "Reference cycles are common in Java, especially because of inner classes, as long as we're careful not to have those for static fields I'd avoid the complexity of WeakReference", "author": "anuraaga", "createdAt": "2020-08-11T00:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI4NTg5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468285898", "bodyText": "Right. The GC is very, very good about handling these cases, as long (as you say), it's not static cycles in the classes themselves.", "author": "jkwatson", "createdAt": "2020-08-11T02:12:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMjc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMzQ2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468233466", "bodyText": "I think having this tight a tolerence for testing code is going to probably cause sporadic test failures. Can we use something like awaitility for this instead?", "author": "jkwatson", "createdAt": "2020-08-10T23:06:08Z", "path": "sdk_extensions/logging_support/src/test/java/io/opentelemetry/logging/SdkLogSinkProviderTest.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import io.opentelemetry.logging.api.LogRecord.Severity;\n+import io.opentelemetry.logging.api.LogSink;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class SdkLogSinkProviderTest {\n+  @Test\n+  public void testProviderAggregation() throws InterruptedException {\n+    List<LogRecord> records1 = new ArrayList<>();\n+    List<LogRecord> records2 = new ArrayList<>();\n+    SdkLogSinkProvider provider =\n+        new SdkLogSinkProvider.Builder()\n+            .withBatchManager(\n+                new SizeOrLatencyBatchStrategy.Builder()\n+                    .withMaxBatchSize(5)\n+                    .withMaxDelay(50, TimeUnit.MILLISECONDS)\n+                    .build())\n+            .withExporter(records1::addAll)\n+            .withExporter(records2::addAll)\n+            .build();\n+    LogSink sink = provider.get(\"test\", \"0.8.0\");\n+    for (int i = 0; i < 11; i++) {\n+      sink.offer(\n+          sink.buildRecord()\n+              .withUnixTimeMillis(System.currentTimeMillis())\n+              .withSeverity(Severity.DEBUG)\n+              .withBody(\"test\")\n+              .build());\n+    }\n+    assertThat(records1.size()).isEqualTo(10);\n+    assertThat(records2.size()).isEqualTo(10);\n+    Thread.sleep(55);", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzMzk2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468233962", "bodyText": "same comment on test timing. let's see if we can use awaitility for this kind of test that has timing requirements.", "author": "jkwatson", "createdAt": "2020-08-10T23:07:54Z", "path": "sdk_extensions/logging_support/src/test/java/io/opentelemetry/logging/SizeOrLatencyBatchStrategyTest.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+@RunWith(JUnit4.class)\n+public class SizeOrLatencyBatchStrategyTest {\n+\n+  @Test\n+  public void testSizeStrategy() {\n+    SizeOrLatencyBatchStrategy strategy =\n+        new SizeOrLatencyBatchStrategy.Builder().withMaxBatchSize(5).build();\n+    final List<LogRecord> transmittedBatch = new ArrayList<>();\n+\n+    strategy.setBatchHandler(transmittedBatch::addAll);\n+\n+    for (int i = 0; i < 7; i++) {\n+      strategy.add(null);\n+    }\n+\n+    assertThat(transmittedBatch.size()).isEqualTo(5);\n+\n+    for (int i = 0; i < 3; i++) {\n+      strategy.add(null);\n+    }\n+\n+    assertThat(transmittedBatch.size()).isEqualTo(10);\n+  }\n+\n+  @Test\n+  public void testLatencyStrategy() throws InterruptedException {\n+    SizeOrLatencyBatchStrategy strategy =\n+        new SizeOrLatencyBatchStrategy.Builder().withMaxDelay(50, TimeUnit.MILLISECONDS).build();\n+\n+    final List<LogRecord> transmittedBatch = new ArrayList<>();\n+\n+    strategy.setBatchHandler(transmittedBatch::addAll);\n+\n+    for (int i = 0; i < 7; i++) {\n+      strategy.add(null);\n+      Thread.sleep(10);\n+    }\n+\n+    assertThat(transmittedBatch.size()).isEqualTo(5);\n+    Thread.sleep(55);", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNDM1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468234352", "bodyText": "field name should match the class/interface name a little more closely.", "author": "jkwatson", "createdAt": "2020-08-10T23:09:11Z", "path": "sdk_extensions/logging_support/src/main/java/io/opentelemetry/logging/SdkLogSinkProvider.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.Exporter;\n+import io.opentelemetry.logging.api.LogRecord;\n+import io.opentelemetry.logging.api.LogSink;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+\n+public class SdkLogSinkProvider implements LoggingBatchExporter {\n+  private final LoggingBatchStrategy batchManager;", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI1NjAzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r468256033", "bodyText": "Looks like these can all be final", "author": "anuraaga", "createdAt": "2020-08-11T00:20:50Z", "path": "sdk_extensions/logging_support/src/main/java/io/opentelemetry/logging/DefaultLogRecord.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.common.AnyValue;\n+import io.opentelemetry.common.AttributeValue;\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.util.Map;\n+\n+public class DefaultLogRecord implements LogRecord {\n+  private long timestamp;", "originalCommit": "5d12042a2d829ef52f6afa6f0a75b5893c9b46e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4e3495b93ad08abd56ff5fd1e9a006e73ae7b7ff", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4e3495b93ad08abd56ff5fd1e9a006e73ae7b7ff", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into logging_extension", "committedDate": "2020-08-17T21:16:04Z", "type": "commit"}, {"oid": "3200d1735c67c759a6ef68cfac45ebae3271086e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3200d1735c67c759a6ef68cfac45ebae3271086e", "message": "address code review comments", "committedDate": "2020-08-24T21:35:36Z", "type": "commit"}, {"oid": "e4365dfb9701cdae6acca79ff036524354ad07d5", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e4365dfb9701cdae6acca79ff036524354ad07d5", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into logging_extension", "committedDate": "2020-08-24T21:46:20Z", "type": "commit"}, {"oid": "52433b06eb1f6be0c33cf8b281f4107943a280b7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/52433b06eb1f6be0c33cf8b281f4107943a280b7", "message": "move logging_support to logging/support", "committedDate": "2020-08-24T22:01:06Z", "type": "commit"}, {"oid": "3e6be4d085d3b251f22b5d834de49b3b4d027c45", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3e6be4d085d3b251f22b5d834de49b3b4d027c45", "message": "missed test update in last commit", "committedDate": "2020-08-24T22:57:48Z", "type": "commit"}, {"oid": "aa545852220f9476fe652febbfd765ff3ebd3f55", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/aa545852220f9476fe652febbfd765ff3ebd3f55", "message": "code format", "committedDate": "2020-08-24T23:02:11Z", "type": "commit"}, {"oid": "8573b4f795b4d729fbefbc6810219cd371dda8f2", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8573b4f795b4d729fbefbc6810219cd371dda8f2", "message": "change list to queue in implementation, collection in api", "committedDate": "2020-08-25T18:37:35Z", "type": "commit"}, {"oid": "44a238d60443d96a000c77337fb37aabf96233df", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/44a238d60443d96a000c77337fb37aabf96233df", "message": "missed making a utility method static", "committedDate": "2020-08-26T16:25:39Z", "type": "commit"}, {"oid": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "message": "fix a broken test", "committedDate": "2020-08-26T16:48:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MTgyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r477461821", "bodyText": "This may need to be replaced by AttributeValue, I think the missing part is the KVList, maybe a comment for the moment explaining the difference.", "author": "bogdandrutu", "createdAt": "2020-08-26T17:17:40Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/common/AnyValue.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * A class that represents all the possible values for a data body. An {@code AnyValue} can have 6\n+ * types of values: {@code String}, {@code boolean}, {@code int}, {@code double}, {@code array}, or\n+ * {@code kvlist}. represented through {@code AnyValue.Type}. A {@code array} or a {@code kvlist}\n+ * can in turn hold other {@code AnyValue} instances, allowing for mapping to JSON-like structures.\n+ *\n+ * @since 0.8.0\n+ */\n+@Immutable\n+public abstract class AnyValue {", "originalCommit": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNTE3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486605177", "bodyText": "This is a good point. In Collector codebase for example we use the same AttributeValue data type for Spans, Resources and LogRecords. This mirrors what we have in the OTLP Proto definitions.\nIs there any reason we cannot extend AttributeValue to fully handle all possible types that AnyValue can represent?", "author": "tigrannajaryan", "createdAt": "2020-09-10T20:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MTgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNjYyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486626620", "bodyText": "If the recent PR #1631 gets merged, then AttributeValue won't exist any more. Also, I don't think we want to accept map-values into our tracing attributes, which that would impact.", "author": "jkwatson", "createdAt": "2020-09-10T20:52:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MTgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MzUxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r477463513", "bodyText": "s/LoggingBatchExporter/LogsExporter to be in sync with others exporters. Also move it to a directory called export", "author": "bogdandrutu", "createdAt": "2020-08-26T17:20:31Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/LoggingBatchExporter.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.util.Collection;\n+\n+/**\n+ * A LoggingBatchExporter accepts a batch of records and handles the transmission of those records\n+ * to a remote system.\n+ */\n+public interface LoggingBatchExporter {", "originalCommit": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2NDQ0MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r477464440", "bodyText": "In trace we call this a \"SpanProcessor\", probably same name here LogRecordProcessor, which has one implementation as BatchingLogRecordProcessor.\nhttps://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/trace/sdk.md#span-processor", "author": "bogdandrutu", "createdAt": "2020-08-26T17:22:02Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/LoggingBatchStrategy.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+\n+/**\n+ * A LoggingBatchStrategy encodes the logic for how to batch and aggregate records for transmission.\n+ * {@link SizeOrLatencyBatchStrategy}\n+ */\n+public interface LoggingBatchStrategy {", "originalCommit": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2NTA0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r477465043", "bodyText": "This should be probably part of the ctor, we should not allow to set/remove exporters during runtime.", "author": "bogdandrutu", "createdAt": "2020-08-26T17:23:01Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/LoggingBatchStrategy.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+\n+/**\n+ * A LoggingBatchStrategy encodes the logic for how to batch and aggregate records for transmission.\n+ * {@link SizeOrLatencyBatchStrategy}\n+ */\n+public interface LoggingBatchStrategy {\n+  void stop();\n+\n+  /**\n+   * Add a LogRecord to the existing batch.\n+   *\n+   * @param record record to enqueue\n+   */\n+  void add(LogRecord record);\n+\n+  /** Explicitly flush the batch. */\n+  void flush();\n+\n+  /**\n+   * This sets the handler for the batch. {@link\n+   * LoggingBatchExporter#handleLogRecordBatch(Collection)} will be called whenever this strategy's\n+   * constraints are fulfilled.\n+   *\n+   * @param handler Exporter to invoke when the batch is full\n+   */\n+  void setBatchHandler(LoggingBatchExporter handler);", "originalCommit": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkzNTQ1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r477935457", "bodyText": "I assume AnyValue here mirrors AnyValue from OTLP Protobufs. If that's the case then we likely need to use long instead of int since OTLP Protobufs use int64.", "author": "tigrannajaryan", "createdAt": "2020-08-27T02:16:15Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/common/AnyValue.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * A class that represents all the possible values for a data body. An {@code AnyValue} can have 6\n+ * types of values: {@code String}, {@code boolean}, {@code int}, {@code double}, {@code array}, or\n+ * {@code kvlist}. represented through {@code AnyValue.Type}. A {@code array} or a {@code kvlist}\n+ * can in turn hold other {@code AnyValue} instances, allowing for mapping to JSON-like structures.\n+ *\n+ * @since 0.8.0\n+ */\n+@Immutable\n+public abstract class AnyValue {\n+\n+  /** An enum that represents all the possible value types for an {@code AnyValue}. */\n+  public enum Type {\n+    STRING,\n+    BOOL,\n+    INT,\n+    DOUBLE,\n+    ARRAY,\n+    KVLIST\n+  }\n+\n+  /**\n+   * Returns an {@code AnyValue} with a string value.\n+   *\n+   * @param stringValue The new value.\n+   * @return an {@code AnyValue} with a string value.\n+   */\n+  public static AnyValue stringAnyValue(String stringValue) {\n+    return AnyValueString.create(stringValue);\n+  }\n+\n+  /**\n+   * Returns the string value of this {@code AnyValue}. An UnsupportedOperationException will be\n+   * thrown if getType() is not {@link AnyValue.Type#STRING}.\n+   *\n+   * @return the string value of this {@code AttributeValue}.\n+   */\n+  public String getStringValue() {\n+    throw new UnsupportedOperationException(\n+        String.format(\"This type can only return %s data\", getType().name()));\n+  }\n+\n+  /**\n+   * Returns an {@code AnyValue} with an int value.\n+   *\n+   * @param intValue The new value.\n+   * @return an {@code AnyValue} with a int value.\n+   */\n+  public static AnyValue intAnyValue(int intValue) {", "originalCommit": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzkzODY4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r477938689", "bodyText": "May be worth doing this to make the size of the int clear:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                INT,\n          \n          \n            \n                INT64,", "author": "tigrannajaryan", "createdAt": "2020-08-27T02:17:52Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/common/AnyValue.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.List;\n+import java.util.Map;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.Immutable;\n+\n+/**\n+ * A class that represents all the possible values for a data body. An {@code AnyValue} can have 6\n+ * types of values: {@code String}, {@code boolean}, {@code int}, {@code double}, {@code array}, or\n+ * {@code kvlist}. represented through {@code AnyValue.Type}. A {@code array} or a {@code kvlist}\n+ * can in turn hold other {@code AnyValue} instances, allowing for mapping to JSON-like structures.\n+ *\n+ * @since 0.8.0\n+ */\n+@Immutable\n+public abstract class AnyValue {\n+\n+  /** An enum that represents all the possible value types for an {@code AnyValue}. */\n+  public enum Type {\n+    STRING,\n+    BOOL,\n+    INT,", "originalCommit": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk0NDU4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r477944580", "bodyText": "I am not sure what defaults we use for trace and metrics but I think a lower default would be nicer. Latencies at every node are additive and keeping it low is beneficial otherwise the data may take a lot of time to arrive. We use 200ms in the Collector.", "author": "tigrannajaryan", "createdAt": "2020-08-27T02:22:11Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/SizeOrLatencyBatchStrategy.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.util.Collection;\n+import java.util.Queue;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Batching strategy that allows specifying both a maximum size and a maximum amount of time before\n+ * sending a batch of records. Batch will be flushed whenever the list of records queued exceeds the\n+ * maximum threshold (default 50), or a set timeout expires (default 5 seconds).\n+ */\n+public class SizeOrLatencyBatchStrategy implements LoggingBatchStrategy {\n+  private static final int DEFAULT_BATCH_SIZE = 50;\n+  private static final int DEFAULT_MAX_DELAY = 5;", "originalCommit": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk0OTk2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r477949965", "bodyText": "Minor: will this run periodically regardless of whether flush() is also called from add()? Ideally flush() called from add() should reset the periodic timer so that flush() is not called too soon.", "author": "tigrannajaryan", "createdAt": "2020-08-27T02:26:06Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/SizeOrLatencyBatchStrategy.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.util.Collection;\n+import java.util.Queue;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Batching strategy that allows specifying both a maximum size and a maximum amount of time before\n+ * sending a batch of records. Batch will be flushed whenever the list of records queued exceeds the\n+ * maximum threshold (default 50), or a set timeout expires (default 5 seconds).\n+ */\n+public class SizeOrLatencyBatchStrategy implements LoggingBatchStrategy {\n+  private static final int DEFAULT_BATCH_SIZE = 50;\n+  private static final int DEFAULT_MAX_DELAY = 5;\n+  private static final TimeUnit DEFAULT_MAX_DELAY_UNITS = TimeUnit.SECONDS;\n+  private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\n+  private final int maxBatch;\n+  private final int maxDelay;\n+  private final TimeUnit maxDelayUnits;\n+  private final ScheduledFuture<?> schedule;\n+\n+  private LoggingBatchExporter batchHandler;\n+  private Queue<LogRecord> batch = buildNewQueue();\n+\n+  private static Queue<LogRecord> buildNewQueue() {\n+    return new LinkedBlockingQueue<>();\n+  }\n+\n+  private SizeOrLatencyBatchStrategy(int maxBatch, int maxDelay, TimeUnit units) {\n+    this.maxBatch = maxBatch > 0 ? maxBatch : DEFAULT_BATCH_SIZE;\n+    this.maxDelay = maxDelay > 0 ? maxDelay : DEFAULT_MAX_DELAY;\n+    this.maxDelayUnits = units != null ? units : DEFAULT_MAX_DELAY_UNITS;\n+    this.schedule =\n+        executor.scheduleWithFixedDelay(\n+            new Runnable() {\n+              @Override\n+              public void run() {\n+                flush();", "originalCommit": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3MTMyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r477971320", "bodyText": "Shouldn't this also be synchronized to avoid the race on this.batch in flash()?", "author": "tigrannajaryan", "createdAt": "2020-08-27T02:41:15Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/SizeOrLatencyBatchStrategy.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.logging.api.LogRecord;\n+import java.util.Collection;\n+import java.util.Queue;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Batching strategy that allows specifying both a maximum size and a maximum amount of time before\n+ * sending a batch of records. Batch will be flushed whenever the list of records queued exceeds the\n+ * maximum threshold (default 50), or a set timeout expires (default 5 seconds).\n+ */\n+public class SizeOrLatencyBatchStrategy implements LoggingBatchStrategy {\n+  private static final int DEFAULT_BATCH_SIZE = 50;\n+  private static final int DEFAULT_MAX_DELAY = 5;\n+  private static final TimeUnit DEFAULT_MAX_DELAY_UNITS = TimeUnit.SECONDS;\n+  private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\n+  private final int maxBatch;\n+  private final int maxDelay;\n+  private final TimeUnit maxDelayUnits;\n+  private final ScheduledFuture<?> schedule;\n+\n+  private LoggingBatchExporter batchHandler;\n+  private Queue<LogRecord> batch = buildNewQueue();\n+\n+  private static Queue<LogRecord> buildNewQueue() {\n+    return new LinkedBlockingQueue<>();\n+  }\n+\n+  private SizeOrLatencyBatchStrategy(int maxBatch, int maxDelay, TimeUnit units) {\n+    this.maxBatch = maxBatch > 0 ? maxBatch : DEFAULT_BATCH_SIZE;\n+    this.maxDelay = maxDelay > 0 ? maxDelay : DEFAULT_MAX_DELAY;\n+    this.maxDelayUnits = units != null ? units : DEFAULT_MAX_DELAY_UNITS;\n+    this.schedule =\n+        executor.scheduleWithFixedDelay(\n+            new Runnable() {\n+              @Override\n+              public void run() {\n+                flush();\n+              }\n+            },\n+            this.maxDelay,\n+            this.maxDelay,\n+            this.maxDelayUnits);\n+  }\n+\n+  @Override\n+  public void stop() {\n+    schedule.cancel(false);\n+  }\n+\n+  @Override\n+  public void add(LogRecord record) {", "originalCommit": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzk3NDMxOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r477974319", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * href=\"https://github.com/open-telemetry/oteps/blob/master/text/logs/0097-log-data-model.md\">\n          \n          \n            \n             * href=\"https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/logs/data-model.md\">", "author": "tigrannajaryan", "createdAt": "2020-08-27T02:43:26Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/api/LogRecord.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging.api;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.common.AnyValue;\n+import io.opentelemetry.common.AttributeValue;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A LogRecord is an implementation of the <a\n+ * href=\"https://github.com/open-telemetry/oteps/blob/master/text/logs/0097-log-data-model.md\">", "originalCommit": "9f2ed0a99841bcab6e1b7db9ae0bf550de84e14a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fa90ba0ce29efdcaa3eeb00e086c79b58275481e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/fa90ba0ce29efdcaa3eeb00e086c79b58275481e", "message": "Update sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/api/LogRecord.java\n\nCo-authored-by: Tigran Najaryan <4194920+tigrannajaryan@users.noreply.github.com>", "committedDate": "2020-08-27T22:10:07Z", "type": "commit"}, {"oid": "b9b14aed8c62d2360f14d91064c658d2f0ea4f2a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b9b14aed8c62d2360f14d91064c658d2f0ea4f2a", "message": "reworked to align with how we batch process spans", "committedDate": "2020-09-10T16:11:44Z", "type": "commit"}, {"oid": "2d7ff2f3ace84d4b189219b6fe1d670b48dc33d9", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2d7ff2f3ace84d4b189219b6fe1d670b48dc33d9", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into logging_extension_rework", "committedDate": "2020-09-10T16:11:59Z", "type": "commit"}, {"oid": "cb607c5ff7fd669987494588d56743588f2b1572", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/cb607c5ff7fd669987494588d56743588f2b1572", "message": "move of CompletableResultCode and formatting", "committedDate": "2020-09-10T16:58:54Z", "type": "commit"}, {"oid": "76a73bc497ba8c44a75d485080d9b056fbadc6a0", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/76a73bc497ba8c44a75d485080d9b056fbadc6a0", "message": "update AnyValue to use long instead of int", "committedDate": "2020-09-10T18:16:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNzAyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486607029", "bodyText": "We need to be careful to avoid self-reinforcing loops if metric operations decide to log on metering failures like we decide to meter on logging failures here. Do we know that none of the metric API calls we make here is log-free or that metric API implementation will not use our logging methods?", "author": "tigrannajaryan", "createdAt": "2020-09-10T20:14:31Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/BatchLogProcessor.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.logging.api.Exporter;\n+import io.opentelemetry.logging.api.LogProcessor;\n+import io.opentelemetry.logging.api.LogRecord;\n+import io.opentelemetry.metrics.LongCounter;\n+import io.opentelemetry.metrics.LongCounter.BoundLongCounter;\n+import io.opentelemetry.metrics.Meter;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.DaemonThreadFactory;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionHandler;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.logging.Logger;\n+\n+public class BatchLogProcessor implements LogProcessor {\n+  private static final String WORKER_THREAD_NAME =\n+      BatchLogProcessor.class.getSimpleName() + \"_WorkerThread\";\n+  private static final String TIMER_THREAD_NAME =\n+      BatchLogProcessor.class.getSimpleName() + \"_TimerThread\";\n+\n+  private final Worker worker;\n+  private final Thread workerThread;\n+\n+  private BatchLogProcessor(\n+      int maxQueueSize,\n+      long scheduleDelayMillis,\n+      int maxExportBatchSize,\n+      long exporterTimeout,\n+      Exporter exporter) {\n+    this.worker =\n+        new Worker(\n+            maxQueueSize, scheduleDelayMillis, maxExportBatchSize, exporterTimeout, exporter);\n+    this.workerThread = new DaemonThreadFactory(WORKER_THREAD_NAME).newThread(worker);\n+    this.workerThread.start();\n+  }\n+\n+  public static Builder builder(Exporter exporter) {\n+    return new Builder(exporter);\n+  }\n+\n+  @Override\n+  public void addLogRecord(LogRecord record) {\n+    worker.addLogRecord(record);\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    workerThread.interrupt();\n+    worker.shutdown();\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    worker.forceFlush();\n+  }\n+\n+  private static class Worker implements Runnable {\n+    static {\n+      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.logging\");", "originalCommit": "76a73bc497ba8c44a75d485080d9b056fbadc6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMDM3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486630371", "bodyText": "This is a good point. I'm also trying to get the message out if logs are not getting out- do we have patterns for how we manage this type of situation?", "author": "zenmoto", "createdAt": "2020-09-10T21:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNzAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMjI4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486632282", "bodyText": "The only recommendation I can think of is to be careful and don't make calls that looks mutually recursive. Unfortunately that means you have to do flow control analysis manually. It results in fragile code, I know. Someone touches anything there (adds an innocent looking debug statement) and it can become a disaster :-(\nMore complicated technical means are possible, like detecting the recursion and aborting it, not sure if we want to go that route.", "author": "tigrannajaryan", "createdAt": "2020-09-10T21:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwNzAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwODE4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486608187", "bodyText": "Can we have a smaller default, please? I don't want to increase logging end-to-end latency this much.", "author": "tigrannajaryan", "createdAt": "2020-09-10T20:16:46Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/BatchLogProcessor.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.logging.api.Exporter;\n+import io.opentelemetry.logging.api.LogProcessor;\n+import io.opentelemetry.logging.api.LogRecord;\n+import io.opentelemetry.metrics.LongCounter;\n+import io.opentelemetry.metrics.LongCounter.BoundLongCounter;\n+import io.opentelemetry.metrics.Meter;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.DaemonThreadFactory;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionHandler;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.logging.Logger;\n+\n+public class BatchLogProcessor implements LogProcessor {\n+  private static final String WORKER_THREAD_NAME =\n+      BatchLogProcessor.class.getSimpleName() + \"_WorkerThread\";\n+  private static final String TIMER_THREAD_NAME =\n+      BatchLogProcessor.class.getSimpleName() + \"_TimerThread\";\n+\n+  private final Worker worker;\n+  private final Thread workerThread;\n+\n+  private BatchLogProcessor(\n+      int maxQueueSize,\n+      long scheduleDelayMillis,\n+      int maxExportBatchSize,\n+      long exporterTimeout,\n+      Exporter exporter) {\n+    this.worker =\n+        new Worker(\n+            maxQueueSize, scheduleDelayMillis, maxExportBatchSize, exporterTimeout, exporter);\n+    this.workerThread = new DaemonThreadFactory(WORKER_THREAD_NAME).newThread(worker);\n+    this.workerThread.start();\n+  }\n+\n+  public static Builder builder(Exporter exporter) {\n+    return new Builder(exporter);\n+  }\n+\n+  @Override\n+  public void addLogRecord(LogRecord record) {\n+    worker.addLogRecord(record);\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    workerThread.interrupt();\n+    worker.shutdown();\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    worker.forceFlush();\n+  }\n+\n+  private static class Worker implements Runnable {\n+    static {\n+      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.logging\");\n+      LongCounter logProcessorErrors =\n+          meter\n+              .longCounterBuilder(\"logProcessorErrors\")\n+              .setUnit(\"1\")\n+              .setDescription(\"Number of errors encountered while processing logs\")\n+              .build();\n+      Labels.Builder builder =\n+          Labels.of(\"logProcessorType\", BatchLogProcessor.class.getName()).toBuilder();\n+      exporterFailureCounter =\n+          logProcessorErrors.bind(builder.setLabel(\"errorType\", \"exporter failure\").build());\n+      exporterBusyCounter =\n+          logProcessorErrors.bind(builder.setLabel(\"errorType\", \"exporter busy\").build());\n+      droppedRecordCounter =\n+          logProcessorErrors.bind(\n+              builder.setLabel(\"errorType\", \"dropped record - queue full\").build());\n+    }\n+\n+    private static final BoundLongCounter exporterFailureCounter;\n+    private static final BoundLongCounter exporterBusyCounter;\n+    private static final BoundLongCounter droppedRecordCounter;\n+    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n+\n+    private final Object monitor = new Object();\n+    private final int maxQueueSize;\n+    private final long scheduleDelayMillis;\n+    private final ArrayList<LogRecord> logRecords;\n+    private final int maxExportBatchSize;\n+    private final ExecutorService executor;\n+    private final Exporter exporter;\n+    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n+    private final long exporterTimeout;\n+\n+    private Worker(\n+        int maxQueueSize,\n+        long scheduleDelayMillis,\n+        int maxExportBatchSize,\n+        long exporterTimeout,\n+        Exporter exporter) {\n+      this.maxQueueSize = maxQueueSize;\n+      this.maxExportBatchSize = maxExportBatchSize;\n+\n+      this.exporterTimeout = exporterTimeout;\n+      this.scheduleDelayMillis = scheduleDelayMillis;\n+      this.exporter = exporter;\n+      this.logRecords = new ArrayList<>(maxQueueSize);\n+      // We should be able to drain a full queue without dropping a batch\n+      int exportQueueSize = maxQueueSize / maxExportBatchSize;\n+      RejectedExecutionHandler h =\n+          new RejectedExecutionHandler() {\n+            @Override\n+            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n+              exporterBusyCounter.add(1);\n+            }\n+          };\n+      this.executor =\n+          new ThreadPoolExecutor(\n+              1,\n+              1,\n+              0L,\n+              TimeUnit.MILLISECONDS,\n+              new LinkedBlockingQueue<Runnable>(exportQueueSize),\n+              h);\n+    }\n+\n+    @Override\n+    public void run() {\n+      ArrayList<LogRecord> logsCopy;\n+      while (!Thread.currentThread().isInterrupted()) {\n+        synchronized (monitor) {\n+          if (this.logRecords.size() < maxExportBatchSize) {\n+            do {\n+              try {\n+                monitor.wait(scheduleDelayMillis);\n+              } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                return;\n+              }\n+            } while (this.logRecords.isEmpty());\n+          }\n+          logsCopy = new ArrayList<>(this.logRecords);\n+          logRecords.clear();\n+        }\n+        exportBatches(logsCopy);\n+      }\n+    }\n+\n+    private void exportBatches(ArrayList<LogRecord> recordsToShip) {\n+      for (int i = 0; i < recordsToShip.size(); ) {\n+        int lastIndexToTake = Math.min(i + maxExportBatchSize, recordsToShip.size());\n+        onBatchExport(createLogDataForExport(recordsToShip, i, lastIndexToTake));\n+        i = lastIndexToTake;\n+      }\n+    }\n+\n+    private void onBatchExport(final List<LogRecord> logDataForExport) {\n+      final Future<CompletableResultCode> f =\n+          executor.submit(\n+              new Callable<CompletableResultCode>() {\n+                @Override\n+                public CompletableResultCode call() {\n+                  return exporter.accept(logDataForExport);\n+                }\n+              });\n+\n+      timer.schedule(\n+          new TimerTask() {\n+            @Override\n+            public void run() {\n+              if (f.isDone()) {\n+                try {\n+                  final CompletableResultCode result = f.get(0, TimeUnit.MILLISECONDS);\n+                  if (!result.isSuccess()) {\n+                    // This may mean that the export process has failed, or that it's still running\n+                    // but it's at the end of it's timeout.\n+                    logger.warning(\"log exporter has failed or timed out\");\n+                    exporterFailureCounter.add(1);\n+                  }\n+                } catch (InterruptedException | ExecutionException e) {\n+                  logger.warning(\"log exporter failure:\" + e.getLocalizedMessage());\n+                  exporterFailureCounter.add(1);\n+                } catch (TimeoutException e) {\n+                  logger.warning(\"log exporter has failed to return async result\");\n+                  exporterFailureCounter.add(1);\n+                }\n+              }\n+            }\n+          },\n+          exporterTimeout);\n+    }\n+\n+    private static List<LogRecord> createLogDataForExport(\n+        ArrayList<LogRecord> recordsToShip, int startIndex, int endIndex) {\n+      List<LogRecord> logDataBuffer = new ArrayList<>(endIndex - startIndex);\n+      for (int i = startIndex; i < endIndex; i++) {\n+        logDataBuffer.add(recordsToShip.get(i));\n+        recordsToShip.set(i, null);\n+      }\n+      return Collections.unmodifiableList(logDataBuffer);\n+    }\n+\n+    public void addLogRecord(LogRecord record) {\n+      synchronized (monitor) {\n+        if (logRecords.size() >= maxQueueSize) {\n+          droppedRecordCounter.add(1);\n+          // FIXME: call callback\n+        }\n+        logRecords.add(record);\n+        if (logRecords.size() >= maxExportBatchSize) {\n+          monitor.notifyAll();\n+        }\n+      }\n+    }\n+\n+    private void shutdown() {\n+      forceFlush();\n+      timer.cancel();\n+      exporter.shutdown();\n+    }\n+\n+    private void forceFlush() {\n+      ArrayList<LogRecord> logsCopy;\n+      synchronized (monitor) {\n+        logsCopy = new ArrayList<>(this.logRecords);\n+        logRecords.clear();\n+      }\n+      exportBatches(logsCopy);\n+    }\n+  }\n+\n+  static class Builder extends ConfigBuilder<Builder> {\n+    /* @VisibleForTesting */ static final long DEFAULT_SCHEDULE_DELAY_MILLIS = 5000;\n+    static final int DEFAULT_MAX_QUEUE_SIZE = 2048;\n+    static final int DEFAULT_MAX_EXPORT_BATCH_SIZE = 512;\n+    static final long DEFAULT_EXPORT_TIMEOUT_MILLIS = 30_000;\n+\n+    private final Exporter exporter;\n+    private long scheduleDelayMillis = DEFAULT_SCHEDULE_DELAY_MILLIS;\n+    private int maxQueueSize = DEFAULT_MAX_QUEUE_SIZE;\n+    private int maxExportBatchSize = DEFAULT_MAX_EXPORT_BATCH_SIZE;\n+    private long exporterTimeoutMillis = DEFAULT_EXPORT_TIMEOUT_MILLIS;\n+\n+    private Builder(Exporter exporter) {\n+      this.exporter = Utils.checkNotNull(exporter, \"Exporter argument can not be null\");\n+    }\n+\n+    public Builder newBuilder(Exporter exporter) {\n+      return new Builder(exporter);\n+    }\n+\n+    public BatchLogProcessor build() {\n+      return new BatchLogProcessor(\n+          maxQueueSize, scheduleDelayMillis, maxExportBatchSize, exporterTimeoutMillis, exporter);\n+    }\n+\n+    /**\n+     * Sets the delay interval between two consecutive exports. The actual interval may be shorter\n+     * if the batch size is getting larger than {@code maxQueuedSpans / 2}.\n+     *\n+     * <p>Default value is {@code 5000}ms.", "originalCommit": "76a73bc497ba8c44a75d485080d9b056fbadc6a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMTc4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486611783", "bodyText": "For consistency we probably to name this export, same as we do for traces: \n  \n    \n      opentelemetry-java/sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/export/SpanExporter.java\n    \n    \n         Line 41\n      in\n      d138908\n    \n    \n    \n    \n\n        \n          \n           CompletableResultCode export(Collection<SpanData> spans); \n        \n    \n  \n\n\nSimilarly, probably name the class LogExporter.", "author": "tigrannajaryan", "createdAt": "2020-09-10T20:23:41Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/api/Exporter.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging.api;\n+\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import java.util.Collection;\n+\n+/**\n+ * An exporter is responsible for taking a list of {@link LogRecord}s and transmitting them to their\n+ * ultimate destination.\n+ */\n+public interface Exporter {\n+  CompletableResultCode accept(Collection<LogRecord> records);", "originalCommit": "76a73bc497ba8c44a75d485080d9b056fbadc6a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMjY2Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486612667", "bodyText": "SpanExporter.shutdown returns CompletableResultCode. Should we too for consistency? Generally I think it is worth trying to be consistent with our tracing peers such as SpanExporter.", "author": "tigrannajaryan", "createdAt": "2020-09-10T20:25:18Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/api/Exporter.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging.api;\n+\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import java.util.Collection;\n+\n+/**\n+ * An exporter is responsible for taking a list of {@link LogRecord}s and transmitting them to their\n+ * ultimate destination.\n+ */\n+public interface Exporter {\n+  CompletableResultCode accept(Collection<LogRecord> records);\n+\n+  void shutdown();", "originalCommit": "76a73bc497ba8c44a75d485080d9b056fbadc6a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMzMxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486613318", "bodyText": "SpanData uses string instead of byte[]: \n  \n    \n      opentelemetry-java/sdk/tracing/src/main/java/io/opentelemetry/sdk/trace/data/SpanData.java\n    \n    \n         Line 46\n      in\n      d138908\n    \n    \n    \n    \n\n        \n          \n           String getTraceId(); \n        \n    \n  \n\n\nI don't know what is better in Java but let's be consistent.", "author": "tigrannajaryan", "createdAt": "2020-09-10T20:26:33Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/api/LogRecord.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging.api;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.common.AnyValue;\n+import io.opentelemetry.common.AttributeValue;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A LogRecord is an implementation of the <a\n+ * href=\"https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/logs/data-model.md\">\n+ * OpenTelemetry logging model</a>.\n+ */\n+@AutoValue\n+public abstract class LogRecord {\n+  abstract long getTimeUnixNano();\n+\n+  @SuppressWarnings(\"mutable\")\n+  abstract byte[] getTraceId();", "originalCommit": "76a73bc497ba8c44a75d485080d9b056fbadc6a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYyNTIzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486625230", "bodyText": "we avoided using byte[] specifically because it's a mutable type, where as String is immutable.", "author": "jkwatson", "createdAt": "2020-09-10T20:49:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMzMxOA=="}], "type": "inlineReview"}, {"oid": "d8696e95c094a80f70b2833d87420c8b9cee1fa4", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d8696e95c094a80f70b2833d87420c8b9cee1fa4", "message": "address code review comments\n\nrename Exporter to LogExporter, move to 'export' package\nrename LogExporter.accept(data) to LogExporter.export(data)\ndecrease flush interval from 5000 to 200ms\nreturn CompletableResultCode from LogExporter.shutdown()\nchange traceId and spanId types to String from byte[]", "committedDate": "2020-09-10T21:59:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2Mjg0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r486662841", "bodyText": "This was a bit that gave me fits. In the span export, there's a monitor that dumps a batch if a batch is already in process. Unfortunately exportBatches is set up to export several batches at the same time, meaning that the first will lock subsequent batches, so if the incoming queue fills, the first batch goes to the exporter and the rest are silently discarded. The intent here is to use an execution queue to allow enough exports to occur to drain a full input queue, but still retain the behavior of shedding batches if the exporter can't keep up.", "author": "zenmoto", "createdAt": "2020-09-10T22:14:03Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/BatchLogProcessor.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.logging.api.Exporter;\n+import io.opentelemetry.logging.api.LogProcessor;\n+import io.opentelemetry.logging.api.LogRecord;\n+import io.opentelemetry.metrics.LongCounter;\n+import io.opentelemetry.metrics.LongCounter.BoundLongCounter;\n+import io.opentelemetry.metrics.Meter;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.DaemonThreadFactory;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionHandler;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.logging.Logger;\n+\n+public class BatchLogProcessor implements LogProcessor {\n+  private static final String WORKER_THREAD_NAME =\n+      BatchLogProcessor.class.getSimpleName() + \"_WorkerThread\";\n+  private static final String TIMER_THREAD_NAME =\n+      BatchLogProcessor.class.getSimpleName() + \"_TimerThread\";\n+\n+  private final Worker worker;\n+  private final Thread workerThread;\n+\n+  private BatchLogProcessor(\n+      int maxQueueSize,\n+      long scheduleDelayMillis,\n+      int maxExportBatchSize,\n+      long exporterTimeout,\n+      Exporter exporter) {\n+    this.worker =\n+        new Worker(\n+            maxQueueSize, scheduleDelayMillis, maxExportBatchSize, exporterTimeout, exporter);\n+    this.workerThread = new DaemonThreadFactory(WORKER_THREAD_NAME).newThread(worker);\n+    this.workerThread.start();\n+  }\n+\n+  public static Builder builder(Exporter exporter) {\n+    return new Builder(exporter);\n+  }\n+\n+  @Override\n+  public void addLogRecord(LogRecord record) {\n+    worker.addLogRecord(record);\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    workerThread.interrupt();\n+    worker.shutdown();\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    worker.forceFlush();\n+  }\n+\n+  private static class Worker implements Runnable {\n+    static {\n+      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.logging\");\n+      LongCounter logProcessorErrors =\n+          meter\n+              .longCounterBuilder(\"logProcessorErrors\")\n+              .setUnit(\"1\")\n+              .setDescription(\"Number of errors encountered while processing logs\")\n+              .build();\n+      Labels.Builder builder =\n+          Labels.of(\"logProcessorType\", BatchLogProcessor.class.getName()).toBuilder();\n+      exporterFailureCounter =\n+          logProcessorErrors.bind(builder.setLabel(\"errorType\", \"exporter failure\").build());\n+      exporterBusyCounter =\n+          logProcessorErrors.bind(builder.setLabel(\"errorType\", \"exporter busy\").build());\n+      droppedRecordCounter =\n+          logProcessorErrors.bind(\n+              builder.setLabel(\"errorType\", \"dropped record - queue full\").build());\n+    }\n+\n+    private static final BoundLongCounter exporterFailureCounter;\n+    private static final BoundLongCounter exporterBusyCounter;\n+    private static final BoundLongCounter droppedRecordCounter;\n+    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n+\n+    private final Object monitor = new Object();\n+    private final int maxQueueSize;\n+    private final long scheduleDelayMillis;\n+    private final ArrayList<LogRecord> logRecords;\n+    private final int maxExportBatchSize;\n+    private final ExecutorService executor;\n+    private final Exporter exporter;\n+    private final Timer timer = new Timer(TIMER_THREAD_NAME, /* isDaemon= */ true);\n+    private final long exporterTimeout;\n+\n+    private Worker(\n+        int maxQueueSize,\n+        long scheduleDelayMillis,\n+        int maxExportBatchSize,\n+        long exporterTimeout,\n+        Exporter exporter) {\n+      this.maxQueueSize = maxQueueSize;\n+      this.maxExportBatchSize = maxExportBatchSize;\n+\n+      this.exporterTimeout = exporterTimeout;\n+      this.scheduleDelayMillis = scheduleDelayMillis;\n+      this.exporter = exporter;\n+      this.logRecords = new ArrayList<>(maxQueueSize);\n+      // We should be able to drain a full queue without dropping a batch\n+      int exportQueueSize = maxQueueSize / maxExportBatchSize;\n+      RejectedExecutionHandler h =\n+          new RejectedExecutionHandler() {\n+            @Override\n+            public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {\n+              exporterBusyCounter.add(1);\n+            }\n+          };\n+      this.executor =\n+          new ThreadPoolExecutor(\n+              1,\n+              1,\n+              0L,\n+              TimeUnit.MILLISECONDS,\n+              new LinkedBlockingQueue<Runnable>(exportQueueSize),\n+              h);\n+    }\n+\n+    @Override\n+    public void run() {\n+      ArrayList<LogRecord> logsCopy;\n+      while (!Thread.currentThread().isInterrupted()) {\n+        synchronized (monitor) {\n+          if (this.logRecords.size() < maxExportBatchSize) {\n+            do {\n+              try {\n+                monitor.wait(scheduleDelayMillis);\n+              } catch (InterruptedException e) {\n+                Thread.currentThread().interrupt();\n+                return;\n+              }\n+            } while (this.logRecords.isEmpty());\n+          }\n+          logsCopy = new ArrayList<>(this.logRecords);\n+          logRecords.clear();\n+        }\n+        exportBatches(logsCopy);\n+      }\n+    }\n+\n+    private void exportBatches(ArrayList<LogRecord> recordsToShip) {\n+      for (int i = 0; i < recordsToShip.size(); ) {\n+        int lastIndexToTake = Math.min(i + maxExportBatchSize, recordsToShip.size());\n+        onBatchExport(createLogDataForExport(recordsToShip, i, lastIndexToTake));\n+        i = lastIndexToTake;\n+      }\n+    }\n+\n+    private void onBatchExport(final List<LogRecord> logDataForExport) {\n+      final Future<CompletableResultCode> f =", "originalCommit": "76a73bc497ba8c44a75d485080d9b056fbadc6a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "64b30efe0a9b3ea11effb4f29f0d95e82401a380", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/64b30efe0a9b3ea11effb4f29f0d95e82401a380", "message": "implement BatchLogProcessor.fromConfigMap", "committedDate": "2020-09-11T17:11:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4Njg4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r487186885", "bodyText": "To match trace and metrics this should be in data package.", "author": "bogdandrutu", "createdAt": "2020-09-11T17:27:26Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/api/LogRecord.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging.api;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.common.AnyValue;\n+import io.opentelemetry.common.AttributeValue;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A LogRecord is an implementation of the <a\n+ * href=\"https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/logs/data-model.md\">\n+ * OpenTelemetry logging model</a>.\n+ */\n+@AutoValue\n+public abstract class LogRecord {", "originalCommit": "64b30efe0a9b3ea11effb4f29f0d95e82401a380", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NzEwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r487187109", "bodyText": "put this for the moment in the same data package as LogRecord", "author": "bogdandrutu", "createdAt": "2020-09-11T17:27:53Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/common/AnyValue.java", "diffHunk": "@@ -0,0 +1,276 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.common;", "originalCommit": "64b30efe0a9b3ea11effb4f29f0d95e82401a380", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4NzY2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r487187661", "bodyText": "Move this class to io.opentelemetry.logging.export", "author": "bogdandrutu", "createdAt": "2020-09-11T17:29:02Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/BatchLogProcessor.java", "diffHunk": "@@ -0,0 +1,397 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;", "originalCommit": "64b30efe0a9b3ea11effb4f29f0d95e82401a380", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4ODQ3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r487188479", "bodyText": "This package should be io.opentelemetry.sdk.logging (and everywhere else)", "author": "bogdandrutu", "createdAt": "2020-09-11T17:30:34Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/logging/LogSinkSdkProvider.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.logging;", "originalCommit": "64b30efe0a9b3ea11effb4f29f0d95e82401a380", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE4OTY3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r487189671", "bodyText": "This should be \"io.opentelemetry.sdk.extensions.logging\" and all the classes should be in this package or subpackages of this package", "author": "bogdandrutu", "createdAt": "2020-09-11T17:32:50Z", "path": "sdk_extensions/logging/support/build.gradle", "diffHunk": "@@ -0,0 +1,20 @@\n+plugins {\n+    id \"java\"\n+    id \"maven-publish\"\n+\n+    id \"ru.vyarus.animalsniffer\"\n+}\n+\n+description = 'OpenTelemetry Contrib Logging Support'\n+ext.moduleName = \"io.opentelemetry.extensions.logging.support\"", "originalCommit": "64b30efe0a9b3ea11effb4f29f0d95e82401a380", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c44c10c872a83551ba6a401dad9e4a10170cca13", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c44c10c872a83551ba6a401dad9e4a10170cca13", "message": "rearrange packages", "committedDate": "2020-09-11T20:06:40Z", "type": "commit"}, {"oid": "e77b91aac6b028820fc1a6f6c400dc41ed9ade0e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e77b91aac6b028820fc1a6f6c400dc41ed9ade0e", "message": "add readme", "committedDate": "2020-09-16T13:34:29Z", "type": "commit"}, {"oid": "3d652fcb2846cbc7c885fc92482d049e520aa397", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3d652fcb2846cbc7c885fc92482d049e520aa397", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into logging_extension", "committedDate": "2020-09-16T13:34:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1OTUyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r490159528", "bodyText": "We're returning CompletableResultCode for shutdown / forceFlush now, can we update these?", "author": "anuraaga", "createdAt": "2020-09-17T11:09:58Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/sdk/logging/LogProcessor.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.logging;\n+\n+import io.opentelemetry.sdk.logging.data.LogRecord;\n+import io.opentelemetry.sdk.trace.TracerSdkProvider;\n+\n+public interface LogProcessor {\n+\n+  void addLogRecord(LogRecord record);\n+\n+  /**\n+   * Called when {@link TracerSdkProvider#shutdown()} is called.\n+   *\n+   * <p>Implementations must ensure that all span events are processed before returning.\n+   */\n+  void shutdown();", "originalCommit": "3d652fcb2846cbc7c885fc92482d049e520aa397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1OTg0MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r490159840", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              LogRecord.Builder buildRecord();\n          \n          \n            \n              LogRecord.Builder recordBuilder();\n          \n      \n    \n    \n  \n\nI'd expect build to return something that's already built", "author": "anuraaga", "createdAt": "2020-09-17T11:10:37Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/sdk/logging/LogSink.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.logging;\n+\n+import io.opentelemetry.sdk.logging.data.LogRecord;\n+\n+/** A LogSink accepts logging records for transmission to an aggregator or log processing system. */\n+public interface LogSink {\n+  /**\n+   * Pass a record to the SDK for transmission to a logging exporter.\n+   *\n+   * @param record record to transmit\n+   */\n+  void offer(LogRecord record);\n+\n+  /**\n+   * Convenience method for creating a record to be transmitted.\n+   *\n+   * @return builder instance\n+   */\n+  LogRecord.Builder buildRecord();", "originalCommit": "3d652fcb2846cbc7c885fc92482d049e520aa397", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE2MjE2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r490162166", "bodyText": "Though how about removing this and just adding .builder() to LogRecord? Unlike spans, we're not following the pattern of something like end on the log record offering to the sink, we call offer above. In that case, I don't see a reason to follow the pattern of returning a builder here - it's a bit surprising for a sink to create anything, it's supposed to be just a receiver of stuff.", "author": "anuraaga", "createdAt": "2020-09-17T11:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1OTg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE2MDEyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r490160128", "bodyText": "Ditto", "author": "anuraaga", "createdAt": "2020-09-17T11:11:14Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/sdk/logging/LogSinkSdkProvider.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.logging;\n+\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.sdk.logging.data.LogRecord;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class LogSinkSdkProvider {\n+  private final LogSink logSink = new SdkLogSink();\n+  private final List<LogProcessor> processors = new ArrayList<>();\n+\n+  private LogSinkSdkProvider() {}\n+\n+  public LogSink get(String instrumentationName, String instrumentationVersion) {\n+    // Currently there is no differentiation by instrumentation library\n+    return logSink;\n+  }\n+\n+  public void addLogProcessor(LogProcessor processor) {\n+    processors.add(Utils.checkNotNull(processor, \"Processor can not be null\"));\n+  }\n+\n+  /** Flushes all attached processors. */\n+  public void forceFlush() {", "originalCommit": "3d652fcb2846cbc7c885fc92482d049e520aa397", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxOTUyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r490419526", "bodyText": "Ouf. I think this one was actually hiding a bug where I wouldn't have finished flushing before shutting down the exporter.", "author": "zenmoto", "createdAt": "2020-09-17T17:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE2MDEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE2MDY1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r490160659", "bodyText": "We use set on our builder methods in general let's stick with that pattern", "author": "anuraaga", "createdAt": "2020-09-17T11:12:19Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/sdk/logging/data/LogRecord.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.logging.data;\n+\n+import com.google.auto.value.AutoValue;\n+import io.opentelemetry.common.AttributeValue;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A LogRecord is an implementation of the <a\n+ * href=\"https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/logs/data-model.md\">\n+ * OpenTelemetry logging model</a>.\n+ */\n+@AutoValue\n+public abstract class LogRecord {\n+  abstract long getTimeUnixNano();\n+\n+  abstract String getTraceId();\n+\n+  abstract String getSpanId();\n+\n+  abstract int getFlags();\n+\n+  abstract Severity getSeverity();\n+\n+  @Nullable\n+  abstract String getSeverityText();\n+\n+  @Nullable\n+  abstract String getName();\n+\n+  abstract AnyValue getBody();\n+\n+  abstract Map<String, AttributeValue> getAttributes();\n+\n+  public enum Severity {\n+    UNDEFINED_SEVERITY_NUMBER(0),\n+    TRACE(1),\n+    TRACE2(2),\n+    TRACE3(3),\n+    TRACE4(4),\n+    DEBUG(5),\n+    DEBUG2(6),\n+    DEBUG3(7),\n+    DEBUG4(8),\n+    INFO(9),\n+    INFO2(10),\n+    INFO3(11),\n+    INFO4(12),\n+    WARN(13),\n+    WARN2(14),\n+    WARN3(15),\n+    WARN4(16),\n+    ERROR(17),\n+    ERROR2(18),\n+    ERROR3(19),\n+    ERROR4(20),\n+    FATAL(21),\n+    FATAL2(22),\n+    FATAL3(23),\n+    FATAL4(24),\n+    ;\n+\n+    private final int severityNumber;\n+\n+    Severity(int severityNumber) {\n+      this.severityNumber = severityNumber;\n+    }\n+\n+    public int getSeverityNumber() {\n+      return severityNumber;\n+    }\n+  }\n+\n+  public static class Builder {\n+    private long timeUnixNano;\n+    private String traceId = \"\";\n+    private String spanId = \"\";\n+    private int flags;\n+    private Severity severity = Severity.UNDEFINED_SEVERITY_NUMBER;\n+    private String severityText;\n+    private String name;\n+    private AnyValue body = AnyValue.stringAnyValue(\"\");\n+    private final Map<String, AttributeValue> attributes = new HashMap<>();\n+\n+    public Builder withUnixTimeNano(long timestamp) {", "originalCommit": "3d652fcb2846cbc7c885fc92482d049e520aa397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE2MTA2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1524#discussion_r490161060", "bodyText": "We recently refactored BatchSpanProcessor. It'd be nice if we could update to follow the same pattern.", "author": "anuraaga", "createdAt": "2020-09-17T11:13:05Z", "path": "sdk_extensions/logging/support/src/main/java/io/opentelemetry/sdk/logging/export/BatchLogProcessor.java", "diffHunk": "@@ -0,0 +1,401 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.logging.export;\n+\n+import io.opentelemetry.OpenTelemetry;\n+import io.opentelemetry.common.Labels;\n+import io.opentelemetry.internal.Utils;\n+import io.opentelemetry.metrics.LongCounter;\n+import io.opentelemetry.metrics.LongCounter.BoundLongCounter;\n+import io.opentelemetry.metrics.Meter;\n+import io.opentelemetry.sdk.common.CompletableResultCode;\n+import io.opentelemetry.sdk.common.DaemonThreadFactory;\n+import io.opentelemetry.sdk.common.export.ConfigBuilder;\n+import io.opentelemetry.sdk.logging.LogProcessor;\n+import io.opentelemetry.sdk.logging.data.LogRecord;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.RejectedExecutionHandler;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.logging.Logger;\n+\n+public class BatchLogProcessor implements LogProcessor {\n+  private static final String WORKER_THREAD_NAME =\n+      BatchLogProcessor.class.getSimpleName() + \"_WorkerThread\";\n+  private static final String TIMER_THREAD_NAME =\n+      BatchLogProcessor.class.getSimpleName() + \"_TimerThread\";\n+\n+  private final Worker worker;\n+  private final Thread workerThread;\n+\n+  private BatchLogProcessor(\n+      int maxQueueSize,\n+      long scheduleDelayMillis,\n+      int maxExportBatchSize,\n+      long exporterTimeout,\n+      LogExporter logExporter) {\n+    this.worker =\n+        new Worker(\n+            maxQueueSize, scheduleDelayMillis, maxExportBatchSize, exporterTimeout, logExporter);\n+    this.workerThread = new DaemonThreadFactory(WORKER_THREAD_NAME).newThread(worker);\n+    this.workerThread.start();\n+  }\n+\n+  public static Builder builder(LogExporter logExporter) {\n+    return new Builder(logExporter);\n+  }\n+\n+  @Override\n+  public void addLogRecord(LogRecord record) {\n+    worker.addLogRecord(record);\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    workerThread.interrupt();\n+    worker.shutdown();\n+  }\n+\n+  @Override\n+  public void forceFlush() {\n+    worker.forceFlush();\n+  }\n+\n+  private static class Worker implements Runnable {\n+    static {\n+      Meter meter = OpenTelemetry.getMeter(\"io.opentelemetry.sdk.logging\");\n+      LongCounter logProcessorErrors =\n+          meter\n+              .longCounterBuilder(\"logProcessorErrors\")\n+              .setUnit(\"1\")\n+              .setDescription(\"Number of errors encountered while processing logs\")\n+              .build();\n+      Labels.Builder builder =\n+          Labels.of(\"logProcessorType\", BatchLogProcessor.class.getName()).toBuilder();\n+      exporterFailureCounter =\n+          logProcessorErrors.bind(builder.setLabel(\"errorType\", \"exporter failure\").build());\n+      exporterBusyCounter =\n+          logProcessorErrors.bind(builder.setLabel(\"errorType\", \"exporter busy\").build());\n+      droppedRecordCounter =\n+          logProcessorErrors.bind(\n+              builder.setLabel(\"errorType\", \"dropped record - queue full\").build());\n+    }\n+\n+    private static final BoundLongCounter exporterFailureCounter;\n+    private static final BoundLongCounter exporterBusyCounter;\n+    private static final BoundLongCounter droppedRecordCounter;\n+    private static final Logger logger = Logger.getLogger(Worker.class.getName());\n+\n+    private final Object monitor = new Object();", "originalCommit": "3d652fcb2846cbc7c885fc92482d049e520aa397", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "058d63256951cce6a63d9c4e8b47b313ccd4637e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/058d63256951cce6a63d9c4e8b47b313ccd4637e", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into logging_extension", "committedDate": "2020-09-17T16:45:46Z", "type": "commit"}, {"oid": "7b238b4cc30402c8ce6677c9fd330c3ca5a83166", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7b238b4cc30402c8ce6677c9fd330c3ca5a83166", "message": "respond to review feedback, refactored BatchLogProcessor", "committedDate": "2020-09-17T22:40:14Z", "type": "commit"}, {"oid": "d8a6d5ff08b4f380b86cf779472b4cab10fbbd9f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d8a6d5ff08b4f380b86cf779472b4cab10fbbd9f", "message": "added a couple tests", "committedDate": "2020-09-17T22:42:33Z", "type": "commit"}, {"oid": "a7155644ad3b057717778d2197be6022281f0390", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a7155644ad3b057717778d2197be6022281f0390", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into logging_extension", "committedDate": "2020-09-23T22:54:41Z", "type": "commit"}, {"oid": "adf4a3005c7c7e22149628697acddc64e4d00715", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/adf4a3005c7c7e22149628697acddc64e4d00715", "message": "update to use new Attributes, remove support directory, public LogRecord getters", "committedDate": "2020-09-23T23:23:57Z", "type": "commit"}, {"oid": "5353889244c589e72780b073048f0da253a99df5", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5353889244c589e72780b073048f0da253a99df5", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into logging_extension", "committedDate": "2020-09-29T16:50:33Z", "type": "commit"}]}