{"pr_number": 2085, "pr_title": "OpenCensus to OpenTelemetry metric exporter", "pr_createdAt": "2020-11-17T10:16:02Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085", "timeline": [{"oid": "c7dc479fcd766512c56850dea41698c7968db319", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c7dc479fcd766512c56850dea41698c7968db319", "message": "OpenCensus to OpenTelemetry metric exporter", "committedDate": "2020-11-17T10:15:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYzMjY0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r526632649", "bodyText": "Prefer a normal for loop if just for a range of ints", "author": "anuraaga", "createdAt": "2020-11-19T06:57:25Z", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+import java.util.stream.IntStream;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader = IntervalMetricReader.create(this, reader, options.build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    LOGGER.info(\"Exporting metrics\");\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        IntStream.range(0, metric.getMetricDescriptor().getLabelKeys().size())", "originalCommit": "c7dc479fcd766512c56850dea41698c7968db319", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYzMzE3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r526633179", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      long epochNanos =\n          \n          \n            \n                      long timestampNanos =\n          \n      \n    \n    \n  \n\nThe epoch is a constant :)", "author": "anuraaga", "createdAt": "2020-11-19T06:58:47Z", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+import java.util.stream.IntStream;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader = IntervalMetricReader.create(this, reader, options.build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    LOGGER.info(\"Exporting metrics\");\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        IntStream.range(0, metric.getMetricDescriptor().getLabelKeys().size())\n+            .forEach(\n+                i ->\n+                    labelsBuilder.put(\n+                        metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+                        Objects.requireNonNull(timeSeries.getLabelValues().get(i).getValue())));\n+        Labels labels = labelsBuilder.build();\n+        ArrayList<MetricData.Point> points = new ArrayList<>();\n+        MetricDescriptor.Type type = null;\n+        for (Point point : timeSeries.getPoints()) {\n+          long epochNanos =", "originalCommit": "c7dc479fcd766512c56850dea41698c7968db319", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjYzMzc4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r526633788", "bodyText": "Maybe can use io.opentelemetry.opencensusshim as name at least for now. Let's go ahead and extract a constant for the InstrumentationLibraryInfo too", "author": "anuraaga", "createdAt": "2020-11-19T07:00:17Z", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+import java.util.stream.IntStream;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader = IntervalMetricReader.create(this, reader, options.build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    LOGGER.info(\"Exporting metrics\");\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        IntStream.range(0, metric.getMetricDescriptor().getLabelKeys().size())\n+            .forEach(\n+                i ->\n+                    labelsBuilder.put(\n+                        metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+                        Objects.requireNonNull(timeSeries.getLabelValues().get(i).getValue())));\n+        Labels labels = labelsBuilder.build();\n+        ArrayList<MetricData.Point> points = new ArrayList<>();\n+        MetricDescriptor.Type type = null;\n+        for (Point point : timeSeries.getPoints()) {\n+          long epochNanos =\n+              TimeUnit.SECONDS.toNanos(point.getTimestamp().getSeconds())\n+                  + point.getTimestamp().getNanos();\n+          type = metric.getMetricDescriptor().getType();\n+          switch (type) {\n+            case GAUGE_INT64:\n+            case CUMULATIVE_INT64:\n+              points.add(\n+                  LongPoint.create(\n+                      epochNanos,\n+                      epochNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              Double::longValue,\n+                              arg -> arg,\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null)));\n+              break;\n+            case GAUGE_DOUBLE:\n+            case CUMULATIVE_DOUBLE:\n+              points.add(\n+                  DoublePoint.create(\n+                      epochNanos,\n+                      epochNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> arg,\n+                              Long::doubleValue,\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null)));\n+              break;\n+            case SUMMARY:\n+              points.add(\n+                  SummaryPoint.create(\n+                      epochNanos,\n+                      epochNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null,\n+                              Summary::getCount,\n+                              arg -> null),\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null, arg -> null, arg -> null, Summary::getSum, arg -> null),\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null,\n+                              OpenTelemetryMetricsExporter::mapPercentiles,\n+                              arg -> null)));\n+              break;\n+            default:\n+              LOGGER.warning(type + \" not supported by OpenCensus to OpenTelemetry migrator.\");\n+              break;\n+          }\n+        }\n+        MetricData.Type metricDataType = mapType(type);\n+        if (metricDataType != null) {\n+          // TODO(@zoercai): resource, attributes, instrumentationLibraryInfo need to be\n+          // added/mapped properly\n+          metricData.add(\n+              MetricData.create(\n+                  Resource.getDefault(),\n+                  InstrumentationLibraryInfo.create(\"das\", \"1\"),", "originalCommit": "c7dc479fcd766512c56850dea41698c7968db319", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "031083f1a8849520b8a57e92263da62c3dc2dc65", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/031083f1a8849520b8a57e92263da62c3dc2dc65", "message": "Add export interval configuration and tests", "committedDate": "2020-11-19T10:35:36Z", "type": "commit"}, {"oid": "a55b656f754a178b9497e9aba4491359b491f9db", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a55b656f754a178b9497e9aba4491359b491f9db", "message": "Review changes", "committedDate": "2020-11-19T10:40:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQzODY2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r528438660", "bodyText": "This message will be printed for every data point - maybe we should aggregate detected unsupported types and print one message per export?", "author": "nilebox", "createdAt": "2020-11-23T01:38:39Z", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        for (int i = 0; i < metric.getMetricDescriptor().getLabelKeys().size(); i++) {\n+          labelsBuilder.put(\n+              metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+              Objects.requireNonNull(timeSeries.getLabelValues().get(i).getValue()));\n+        }\n+        Labels labels = labelsBuilder.build();\n+        ArrayList<MetricData.Point> points = new ArrayList<>();\n+        MetricDescriptor.Type type = null;\n+        for (Point point : timeSeries.getPoints()) {\n+          long timestampNanos =\n+              TimeUnit.SECONDS.toNanos(point.getTimestamp().getSeconds())\n+                  + point.getTimestamp().getNanos();\n+          type = metric.getMetricDescriptor().getType();\n+          switch (type) {\n+            case GAUGE_INT64:\n+            case CUMULATIVE_INT64:\n+              points.add(\n+                  LongPoint.create(\n+                      timestampNanos,\n+                      timestampNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              Double::longValue,\n+                              arg -> arg,\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null)));\n+              break;\n+            case GAUGE_DOUBLE:\n+            case CUMULATIVE_DOUBLE:\n+              points.add(\n+                  DoublePoint.create(\n+                      timestampNanos,\n+                      timestampNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> arg,\n+                              Long::doubleValue,\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null)));\n+              break;\n+            case SUMMARY:\n+              points.add(\n+                  SummaryPoint.create(\n+                      timestampNanos,\n+                      timestampNanos,\n+                      labels,\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null,\n+                              Summary::getCount,\n+                              arg -> null),\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null, arg -> null, arg -> null, Summary::getSum, arg -> null),\n+                      point\n+                          .getValue()\n+                          .match(\n+                              arg -> null,\n+                              arg -> null,\n+                              arg -> null,\n+                              OpenTelemetryMetricsExporter::mapPercentiles,\n+                              arg -> null)));\n+              break;\n+            default:\n+              LOGGER.warning(type + \" not supported by OpenCensus to OpenTelemetry migrator.\");", "originalCommit": "a55b656f754a178b9497e9aba4491359b491f9db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0f927bc3873ce6a57e1ead04e826b95fbe65e256", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0f927bc3873ce6a57e1ead04e826b95fbe65e256", "message": "Merge branch 'master' of github.com:open-telemetry/opentelemetry-java into metric-migration\n\n# Conflicts:\n#\tbuild.gradle\n#\topencensus-shim/src/test/java/io/opentelemetry/opencensusshim/TraceInteroperabilityTest.java", "committedDate": "2020-11-26T08:00:58Z", "type": "commit"}, {"oid": "799667edc0494d9ec20e1484fcd3635ff9942958", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/799667edc0494d9ec20e1484fcd3635ff9942958", "message": "Review change", "committedDate": "2020-11-26T08:14:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI1MDU4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r531250585", "bodyText": "I think this should be a HashSet, otherwise it may contain duplicate types from every data point.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ArrayList<MetricDescriptor.Type> unsupportedTypes = new ArrayList<>();\n          \n          \n            \n                Set<MetricDescriptor.Type> unsupportedTypes = new HashSet<>();", "author": "nilebox", "createdAt": "2020-11-26T23:16:55Z", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import com.google.common.base.Joiner;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    ArrayList<MetricDescriptor.Type> unsupportedTypes = new ArrayList<>();", "originalCommit": "799667edc0494d9ec20e1484fcd3635ff9942958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI1MDg2Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r531250863", "bodyText": "nit: here and in other places: List<> (interface) is more idiomatic for variable type.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ArrayList<MetricData> metricData = new ArrayList<>();\n          \n          \n            \n                List<MetricData> metricData = new ArrayList<>();", "author": "nilebox", "createdAt": "2020-11-26T23:18:50Z", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import com.google.common.base.Joiner;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    ArrayList<MetricData> metricData = new ArrayList<>();", "originalCommit": "799667edc0494d9ec20e1484fcd3635ff9942958", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI1MTIwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r531251205", "bodyText": "Are you sure it's not possible to have a \"null\" label value in OpenCensus? Maybe it has to be an empty string in that case (then this code is fine)?\nMaybe not, just double checking.", "author": "nilebox", "createdAt": "2020-11-26T23:20:36Z", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import com.google.common.base.Joiner;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    ArrayList<MetricData> metricData = new ArrayList<>();\n+    ArrayList<MetricDescriptor.Type> unsupportedTypes = new ArrayList<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        for (int i = 0; i < metric.getMetricDescriptor().getLabelKeys().size(); i++) {\n+          labelsBuilder.put(\n+              metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+              Objects.requireNonNull(timeSeries.getLabelValues().get(i).getValue()));", "originalCommit": "799667edc0494d9ec20e1484fcd3635ff9942958", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI4MzA5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r531283099", "bodyText": "Ah good catch!\n\nReturns the value of this {@link LabelValue}. Returns {@code null} if the value is unset and supposed to be ignored.\n\nI've updated the code now to only add a label if it's not null.", "author": "zoercai", "createdAt": "2020-11-27T01:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTI1MTIwNQ=="}], "type": "inlineReview"}, {"oid": "7f3173515159bfec420537e02f96c3b8510df9b1", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/7f3173515159bfec420537e02f96c3b8510df9b1", "message": "Review changes & Add test for unsupported type", "committedDate": "2020-11-27T01:00:19Z", "type": "commit"}, {"oid": "6619caad1a737c0727f48140d5b083ba416a34c7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6619caad1a737c0727f48140d5b083ba416a34c7", "message": "Update README.md", "committedDate": "2020-12-03T05:17:13Z", "type": "commit"}, {"oid": "4609e4140d44d4cceddc1da1333123d154e130e7", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4609e4140d44d4cceddc1da1333123d154e130e7", "message": "Fix test maybe?", "committedDate": "2020-12-04T02:22:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjMxODE2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2085#discussion_r536318160", "bodyText": "I'd like to see the contents of the loop extracted into a method, to make this code a little easier to understand.", "author": "jkwatson", "createdAt": "2020-12-04T19:10:08Z", "path": "opencensus-shim/src/main/java/io/opentelemetry/opencensusshim/OpenTelemetryMetricsExporter.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.opencensusshim;\n+\n+import com.google.common.base.Joiner;\n+import io.opencensus.common.Duration;\n+import io.opencensus.exporter.metrics.util.IntervalMetricReader;\n+import io.opencensus.exporter.metrics.util.MetricExporter;\n+import io.opencensus.exporter.metrics.util.MetricReader;\n+import io.opencensus.metrics.Metrics;\n+import io.opencensus.metrics.export.Metric;\n+import io.opencensus.metrics.export.MetricDescriptor;\n+import io.opencensus.metrics.export.Point;\n+import io.opencensus.metrics.export.Summary;\n+import io.opencensus.metrics.export.Summary.Snapshot;\n+import io.opencensus.metrics.export.TimeSeries;\n+import io.opentelemetry.api.common.Labels;\n+import io.opentelemetry.api.common.LabelsBuilder;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.metrics.data.MetricData;\n+import io.opentelemetry.sdk.metrics.data.MetricData.DoublePoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.LongPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.SummaryPoint;\n+import io.opentelemetry.sdk.metrics.data.MetricData.ValueAtPercentile;\n+import io.opentelemetry.sdk.resources.Resource;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Logger;\n+import javax.annotation.Nonnull;\n+\n+public class OpenTelemetryMetricsExporter extends MetricExporter {\n+  private static final Logger LOGGER =\n+      Logger.getLogger(OpenTelemetryMetricsExporter.class.getName());\n+\n+  private static final String EXPORTER_NAME = \"OpenTelemetryMetricExporter\";\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"io.opentelemetry.opencensusshim\", null);\n+\n+  private final IntervalMetricReader intervalMetricReader;\n+  private final io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter;\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, Duration.create(60, 0));\n+  }\n+\n+  public static OpenTelemetryMetricsExporter createAndRegister(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    return new OpenTelemetryMetricsExporter(otelExporter, exportInterval);\n+  }\n+\n+  private OpenTelemetryMetricsExporter(\n+      io.opentelemetry.sdk.metrics.export.MetricExporter otelExporter, Duration exportInterval) {\n+    this.otelExporter = otelExporter;\n+    IntervalMetricReader.Options.Builder options = IntervalMetricReader.Options.builder();\n+    MetricReader reader =\n+        MetricReader.create(\n+            MetricReader.Options.builder()\n+                .setMetricProducerManager(Metrics.getExportComponent().getMetricProducerManager())\n+                .setSpanName(EXPORTER_NAME)\n+                .build());\n+    intervalMetricReader =\n+        IntervalMetricReader.create(\n+            this, reader, options.setExportInterval(exportInterval).build());\n+  }\n+\n+  @Override\n+  public void export(Collection<Metric> metrics) {\n+    List<MetricData> metricData = new ArrayList<>();\n+    Set<MetricDescriptor.Type> unsupportedTypes = new HashSet<>();\n+    for (Metric metric : metrics) {\n+      for (TimeSeries timeSeries : metric.getTimeSeriesList()) {\n+        LabelsBuilder labelsBuilder = Labels.builder();\n+        for (int i = 0; i < metric.getMetricDescriptor().getLabelKeys().size(); i++) {\n+          if (timeSeries.getLabelValues().get(i).getValue() != null) {\n+            labelsBuilder.put(\n+                metric.getMetricDescriptor().getLabelKeys().get(i).getKey(),\n+                timeSeries.getLabelValues().get(i).getValue());\n+          }\n+        }\n+        Labels labels = labelsBuilder.build();\n+        List<MetricData.Point> points = new ArrayList<>();\n+        MetricDescriptor.Type type = null;\n+        for (Point point : timeSeries.getPoints()) {\n+          long timestampNanos =", "originalCommit": "4609e4140d44d4cceddc1da1333123d154e130e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f69f9de5628205206449efe7c5983429c91b1b3b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f69f9de5628205206449efe7c5983429c91b1b3b", "message": "Review changes", "committedDate": "2020-12-07T01:53:44Z", "type": "commit"}]}