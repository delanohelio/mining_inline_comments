{"pr_number": 869, "pr_title": "Quick Start guide", "pr_createdAt": "2020-02-17T15:31:41Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/869", "timeline": [{"oid": "f0d5597d729038836e0188bdd893ed2fb44f4b9f", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f0d5597d729038836e0188bdd893ed2fb44f4b9f", "message": "Add initial description and configuration details", "committedDate": "2020-02-17T15:39:41Z", "type": "commit"}, {"oid": "e06e775d3a6cc5477b7fd7fa93fb963450e39298", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e06e775d3a6cc5477b7fd7fa93fb963450e39298", "message": "QuickStart - First draft", "committedDate": "2020-02-17T15:39:41Z", "type": "commit"}, {"oid": "8ab73f33e1c57b90d23903197fa51106507642d2", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8ab73f33e1c57b90d23903197fa51106507642d2", "message": "Wording", "committedDate": "2020-02-17T15:39:42Z", "type": "commit"}, {"oid": "8ab73f33e1c57b90d23903197fa51106507642d2", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8ab73f33e1c57b90d23903197fa51106507642d2", "message": "Wording", "committedDate": "2020-02-17T15:39:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5MjAwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380292005", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For more details, check out the [Overview].\n          \n          \n            \n            For more details, check out the [Specification Overview].", "author": "arminru", "createdAt": "2020-02-17T17:01:36Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5MjA0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380292041", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n          \n          \n            \n            [Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md", "author": "arminru", "createdAt": "2020-02-17T17:01:42Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5MjM5Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380292396", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n          \n          \n            \n            and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the", "author": "arminru", "createdAt": "2020-02-17T17:02:16Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the ", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5MjgwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380292801", "bodyText": "This kind of recites the previous paragraph.", "author": "arminru", "createdAt": "2020-02-17T17:03:04Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5MzAyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380293021", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n          \n          \n            \n            For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.", "author": "arminru", "createdAt": "2020-02-17T17:03:26Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  ", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5MzEwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380293103", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In order to strike a balance between observability and expenses, traces are sampled. \n          \n          \n            \n            In order to strike a balance between observability and expenses, traces can be sampled.", "author": "arminru", "createdAt": "2020-02-17T17:03:37Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. ", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5MzcyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380293728", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             - Sampling based on probability \n          \n          \n            \n             - Sampling based on probability", "author": "arminru", "createdAt": "2020-02-17T17:05:12Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability ", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5MzgwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380293800", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n          \n          \n            \n            Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.", "author": "arminru", "createdAt": "2020-02-17T17:05:24Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5NDA5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380294091", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n          \n          \n            \n            TraceConfig AlwaysOn = TraceConfig.getDefault().toBuilder().setSampler(", "author": "arminru", "createdAt": "2020-02-17T17:05:58Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5NDk2Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380294967", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n          \n          \n            \n            [`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java", "author": "arminru", "createdAt": "2020-02-17T17:08:03Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5NTE1Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380295153", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n          \n          \n            \n            The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.", "author": "arminru", "createdAt": "2020-02-17T17:08:31Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. ", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5NTI2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380295260", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n          \n          \n            \n            Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.", "author": "arminru", "createdAt": "2020-02-17T17:08:46Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5NTc2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380295762", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - In Memory Exporter: keeps the data in memory, useful for debug.\n          \n          \n            \n            - In-Memory Exporter: keeps the data in memory, useful for debugging.", "author": "arminru", "createdAt": "2020-02-17T17:10:12Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5OTAwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380299006", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n          \n          \n            \n            First, a `Tracer` must be acquired, which is responsible for creating spans and interacting with the [Context](#context-propagation).", "author": "arminru", "createdAt": "2020-02-17T17:18:11Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5OTQyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380299424", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n          \n          \n            \n            A tracer is acquired using the OpenTelemetry API by specifying the name and version of the library instrumenting the library or application to be monitored.", "author": "arminru", "createdAt": "2020-02-17T17:19:09Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. ", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5OTY1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380299650", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            More information are available in [Obtaining a Tracer].\n          \n          \n            \n            More information is available in the specification chapter [Obtaining a Tracer].", "author": "arminru", "createdAt": "2020-02-17T17:19:44Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5OTczNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380299735", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            To create a basic span, you only need to specify the name of the span. \n          \n          \n            \n            To create a basic span, you only need to specify the name of the span.", "author": "arminru", "createdAt": "2020-02-17T17:20:01Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. ", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI5OTkzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380299932", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n          \n          \n            \n            The start and end time of the span is automatically set by the OpenTelemetry SDK.", "author": "arminru", "createdAt": "2020-02-17T17:20:34Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMDExNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380300114", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Most of the time, we want to correlate spans for nested operations. \n          \n          \n            \n            Most of the time, we want to correlate spans for nested operations.", "author": "arminru", "createdAt": "2020-02-17T17:21:03Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. ", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMDY2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380300660", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            OpenTelemetry supports distributed tracing within process and remote processes.\n          \n          \n            \n            OpenTelemetry supports distributed tracing within processes and across remote processes.\n          \n      \n    \n    \n  \n\nnit: I don't know the exact definition but I don't think intra-process tracing qualifies as Distributed Tracing, that's only about inter-process calls.", "author": "arminru", "createdAt": "2020-02-17T17:22:26Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMTMzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380301336", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ```java\n          \n          \n            \n            For a method `A` calling a method `B`, the spans could be manually linked in the following way:\n          \n          \n            \n            \n          \n          \n            \n            ```java", "author": "arminru", "createdAt": "2020-02-17T17:24:13Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMjExNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380302117", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n          \n          \n            \n            void a() {\n          \n          \n            \n              parentSpan = tracer.spanBuilder(\"a\").startSpan();\n          \n          \n            \n              b();\n          \n          \n            \n              parentSpan.end();\n          \n          \n            \n            }\n          \n          \n            \n            void b() {\n          \n          \n            \n              Span childSpan = tracer.spanBuilder(\"b\").setParent(parentSpan).startSpan();\n          \n          \n            \n              // do stuff\n          \n          \n            \n              childSpan.end();\n          \n          \n            \n            }\n          \n      \n    \n    \n  \n\nAnd here it should be mentioned that one would usually \"activate\" the span using Scope scope = tracer.withSpan(parentSpan) to automatically propagate the parentSpan. Otherwise the parent would have to be kept somewhere accessible by or manually passed to B.", "author": "arminru", "createdAt": "2020-02-17T17:26:21Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzEzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380303136", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n          \n          \n            \n            Attributes provide additional context on a span to the specific operation it tracks, such as results or operation properties.", "author": "arminru", "createdAt": "2020-02-17T17:29:07Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzQzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380303439", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n          \n          \n            \n            For these, OpenTelemetry requires specific attributes to be set. These are defined in the [Semantic Conventions] in the cross-language specification.", "author": "arminru", "createdAt": "2020-02-17T17:30:03Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzQ4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380303485", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md\n          \n          \n            \n            [Semantic Conventions]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md", "author": "arminru", "createdAt": "2020-02-17T17:30:10Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n+\n+[Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzgzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380303838", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Span with links\n          \n          \n            \n            ## Create Spans with links", "author": "arminru", "createdAt": "2020-02-17T17:31:09Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n+\n+[Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md\n+\n+## Create Spans with events\n+\n+Spans can be annotated with named events that can carry zero or more [Span Attributes](#span-attributes),\n+each of which is itself a key:value map paired automatically with a timestamp.\n+\n+```java\n+span.addEvent(\"Init\");\n+...\n+span.addEvent(\"End\");\n+```\n+```java\n+Map<String, AttributeValue> eventAttributes = new HashMap<>();\n+eventAttributes.put(\"key\", AttributeValue.stringAttributeValue(\"value\"));\n+eventAttributes.put(\"result\", AttributeValue.longAttributeValue(0L));\n+\n+span.addEvent(\"End Computation\", eventAttributes);\n+```\n+\n+## Span with links", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwMzkwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380303905", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A Span may be linked to zero or more other Spans that are causally related. \n          \n          \n            \n            A Span may be linked to zero or more other Spans that are causally related.", "author": "arminru", "createdAt": "2020-02-17T17:31:20Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n+\n+[Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md\n+\n+## Create Spans with events\n+\n+Spans can be annotated with named events that can carry zero or more [Span Attributes](#span-attributes),\n+each of which is itself a key:value map paired automatically with a timestamp.\n+\n+```java\n+span.addEvent(\"Init\");\n+...\n+span.addEvent(\"End\");\n+```\n+```java\n+Map<String, AttributeValue> eventAttributes = new HashMap<>();\n+eventAttributes.put(\"key\", AttributeValue.stringAttributeValue(\"value\"));\n+eventAttributes.put(\"result\", AttributeValue.longAttributeValue(0L));\n+\n+span.addEvent(\"End Computation\", eventAttributes);\n+```\n+\n+## Span with links\n+A Span may be linked to zero or more other Spans that are causally related. ", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNDMzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380304334", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            OpenTelemetry provides a text based approach to propagate the W3C trace-context with remote processes by instrumenting the transport-layer operation.\n          \n          \n            \n            OpenTelemetry provides a text-based approach to propagate context to remote services using the [W3C Trace Context](https://www.w3.org/TR/trace-context/) HTTP headers.", "author": "arminru", "createdAt": "2020-02-17T17:32:36Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n+\n+[Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md\n+\n+## Create Spans with events\n+\n+Spans can be annotated with named events that can carry zero or more [Span Attributes](#span-attributes),\n+each of which is itself a key:value map paired automatically with a timestamp.\n+\n+```java\n+span.addEvent(\"Init\");\n+...\n+span.addEvent(\"End\");\n+```\n+```java\n+Map<String, AttributeValue> eventAttributes = new HashMap<>();\n+eventAttributes.put(\"key\", AttributeValue.stringAttributeValue(\"value\"));\n+eventAttributes.put(\"result\", AttributeValue.longAttributeValue(0L));\n+\n+span.addEvent(\"End Computation\", eventAttributes);\n+```\n+\n+## Span with links\n+A Span may be linked to zero or more other Spans that are causally related. \n+Links can be used to represent batched operations where a Span was initiated by multiple initiating Spans, each representing a single incoming item being processed in the batch.\n+\n+```java\n+Link link1 = SpanData.Link.create(parentSpan1.getContext());\n+Link link2 = SpanData.Link.create(parentSpan2.getContext());\n+Span child = tracer.spanBuilder(\"childWithLink\")\n+        .addLink(link1)\n+        .addLink(link2)\n+        .addLink(parentSpan3.getContext())\n+        .addLink(remoteContext)\n+    .startSpan();\n+```\n+\n+For more details how to read context from remote processes, see [Context Propagation](#context-propagation).\n+\n+## Context Propagation\n+\n+OpenTelemetry provides a text based approach to propagate the W3C trace-context with remote processes by instrumenting the transport-layer operation.", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNDg2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380304865", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    //Insert the context as Header\n          \n          \n            \n                    // Insert the context as Header", "author": "arminru", "createdAt": "2020-02-17T17:34:09Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n+\n+[Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md\n+\n+## Create Spans with events\n+\n+Spans can be annotated with named events that can carry zero or more [Span Attributes](#span-attributes),\n+each of which is itself a key:value map paired automatically with a timestamp.\n+\n+```java\n+span.addEvent(\"Init\");\n+...\n+span.addEvent(\"End\");\n+```\n+```java\n+Map<String, AttributeValue> eventAttributes = new HashMap<>();\n+eventAttributes.put(\"key\", AttributeValue.stringAttributeValue(\"value\"));\n+eventAttributes.put(\"result\", AttributeValue.longAttributeValue(0L));\n+\n+span.addEvent(\"End Computation\", eventAttributes);\n+```\n+\n+## Span with links\n+A Span may be linked to zero or more other Spans that are causally related. \n+Links can be used to represent batched operations where a Span was initiated by multiple initiating Spans, each representing a single incoming item being processed in the batch.\n+\n+```java\n+Link link1 = SpanData.Link.create(parentSpan1.getContext());\n+Link link2 = SpanData.Link.create(parentSpan2.getContext());\n+Span child = tracer.spanBuilder(\"childWithLink\")\n+        .addLink(link1)\n+        .addLink(link2)\n+        .addLink(parentSpan3.getContext())\n+        .addLink(remoteContext)\n+    .startSpan();\n+```\n+\n+For more details how to read context from remote processes, see [Context Propagation](#context-propagation).\n+\n+## Context Propagation\n+\n+OpenTelemetry provides a text based approach to propagate the W3C trace-context with remote processes by instrumenting the transport-layer operation.\n+The following presents an example of an outgoing HTTP request using `HttpURLConnection`.\n+ \n+```java\n+// Tell OpenTelemetry to inject the context in the HTTP headers\n+HttpTextFormat.Setter<HttpURLConnection> setter =\n+  new HttpTextFormat.Setter<HttpURLConnection>() {\n+    @Override\n+    public void put(HttpURLConnection carrier, String key, String value) {\n+        //Insert the context as Header", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNDk4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380304988", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Semantic Convention\n          \n          \n            \n            // Add the attributes defined in the Semantic Conventions", "author": "arminru", "createdAt": "2020-02-17T17:34:32Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n+\n+[Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md\n+\n+## Create Spans with events\n+\n+Spans can be annotated with named events that can carry zero or more [Span Attributes](#span-attributes),\n+each of which is itself a key:value map paired automatically with a timestamp.\n+\n+```java\n+span.addEvent(\"Init\");\n+...\n+span.addEvent(\"End\");\n+```\n+```java\n+Map<String, AttributeValue> eventAttributes = new HashMap<>();\n+eventAttributes.put(\"key\", AttributeValue.stringAttributeValue(\"value\"));\n+eventAttributes.put(\"result\", AttributeValue.longAttributeValue(0L));\n+\n+span.addEvent(\"End Computation\", eventAttributes);\n+```\n+\n+## Span with links\n+A Span may be linked to zero or more other Spans that are causally related. \n+Links can be used to represent batched operations where a Span was initiated by multiple initiating Spans, each representing a single incoming item being processed in the batch.\n+\n+```java\n+Link link1 = SpanData.Link.create(parentSpan1.getContext());\n+Link link2 = SpanData.Link.create(parentSpan2.getContext());\n+Span child = tracer.spanBuilder(\"childWithLink\")\n+        .addLink(link1)\n+        .addLink(link2)\n+        .addLink(parentSpan3.getContext())\n+        .addLink(remoteContext)\n+    .startSpan();\n+```\n+\n+For more details how to read context from remote processes, see [Context Propagation](#context-propagation).\n+\n+## Context Propagation\n+\n+OpenTelemetry provides a text based approach to propagate the W3C trace-context with remote processes by instrumenting the transport-layer operation.\n+The following presents an example of an outgoing HTTP request using `HttpURLConnection`.\n+ \n+```java\n+// Tell OpenTelemetry to inject the context in the HTTP headers\n+HttpTextFormat.Setter<HttpURLConnection> setter =\n+  new HttpTextFormat.Setter<HttpURLConnection>() {\n+    @Override\n+    public void put(HttpURLConnection carrier, String key, String value) {\n+        //Insert the context as Header\n+        carrier.setRequestProperty(key, value);\n+    }\n+};\n+\n+URL url = new URL(\"http://127.0.0.1:8080/resource\");\n+Span outGoing = tracer.spanBuilder(\"/resource\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+// Semantic Convention", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNTEzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380305132", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Similarly, the text based approach can be used to read the W3C trace-context from incoming requests.\n          \n          \n            \n            Similarly, the text-based approach can be used to read the W3C Trace Context from incoming requests.", "author": "arminru", "createdAt": "2020-02-17T17:35:01Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n+\n+[Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md\n+\n+## Create Spans with events\n+\n+Spans can be annotated with named events that can carry zero or more [Span Attributes](#span-attributes),\n+each of which is itself a key:value map paired automatically with a timestamp.\n+\n+```java\n+span.addEvent(\"Init\");\n+...\n+span.addEvent(\"End\");\n+```\n+```java\n+Map<String, AttributeValue> eventAttributes = new HashMap<>();\n+eventAttributes.put(\"key\", AttributeValue.stringAttributeValue(\"value\"));\n+eventAttributes.put(\"result\", AttributeValue.longAttributeValue(0L));\n+\n+span.addEvent(\"End Computation\", eventAttributes);\n+```\n+\n+## Span with links\n+A Span may be linked to zero or more other Spans that are causally related. \n+Links can be used to represent batched operations where a Span was initiated by multiple initiating Spans, each representing a single incoming item being processed in the batch.\n+\n+```java\n+Link link1 = SpanData.Link.create(parentSpan1.getContext());\n+Link link2 = SpanData.Link.create(parentSpan2.getContext());\n+Span child = tracer.spanBuilder(\"childWithLink\")\n+        .addLink(link1)\n+        .addLink(link2)\n+        .addLink(parentSpan3.getContext())\n+        .addLink(remoteContext)\n+    .startSpan();\n+```\n+\n+For more details how to read context from remote processes, see [Context Propagation](#context-propagation).\n+\n+## Context Propagation\n+\n+OpenTelemetry provides a text based approach to propagate the W3C trace-context with remote processes by instrumenting the transport-layer operation.\n+The following presents an example of an outgoing HTTP request using `HttpURLConnection`.\n+ \n+```java\n+// Tell OpenTelemetry to inject the context in the HTTP headers\n+HttpTextFormat.Setter<HttpURLConnection> setter =\n+  new HttpTextFormat.Setter<HttpURLConnection>() {\n+    @Override\n+    public void put(HttpURLConnection carrier, String key, String value) {\n+        //Insert the context as Header\n+        carrier.setRequestProperty(key, value);\n+    }\n+};\n+\n+URL url = new URL(\"http://127.0.0.1:8080/resource\");\n+Span outGoing = tracer.spanBuilder(\"/resource\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+// Semantic Convention\n+outGoing.setAttribute(\"http.method\", \"GET\");\n+outGoing.setAttribute(\"http.url\", url.toString());\n+HttpURLConnection transportLayer = (HttpURLConnection) url.openConnection();\n+// Inject the request with the context\n+tracer.getHttpTextFormat().inject(outGoing.getContext(), transportLayer, setter);\n+// Make outgoing call\n+...\n+```\n+\n+Similarly, the text based approach can be used to read the W3C trace-context from incoming requests.", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNTU5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380305595", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return \"\";\n          \n          \n            \n                  return null;\n          \n      \n    \n    \n  \n\nhttps://github.com/open-telemetry/opentelemetry-java/blob/master/context_prop/src/main/java/io/opentelemetry/context/propagation/HttpTextFormat.java#L120", "author": "arminru", "createdAt": "2020-02-17T17:36:16Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n+\n+[Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md\n+\n+## Create Spans with events\n+\n+Spans can be annotated with named events that can carry zero or more [Span Attributes](#span-attributes),\n+each of which is itself a key:value map paired automatically with a timestamp.\n+\n+```java\n+span.addEvent(\"Init\");\n+...\n+span.addEvent(\"End\");\n+```\n+```java\n+Map<String, AttributeValue> eventAttributes = new HashMap<>();\n+eventAttributes.put(\"key\", AttributeValue.stringAttributeValue(\"value\"));\n+eventAttributes.put(\"result\", AttributeValue.longAttributeValue(0L));\n+\n+span.addEvent(\"End Computation\", eventAttributes);\n+```\n+\n+## Span with links\n+A Span may be linked to zero or more other Spans that are causally related. \n+Links can be used to represent batched operations where a Span was initiated by multiple initiating Spans, each representing a single incoming item being processed in the batch.\n+\n+```java\n+Link link1 = SpanData.Link.create(parentSpan1.getContext());\n+Link link2 = SpanData.Link.create(parentSpan2.getContext());\n+Span child = tracer.spanBuilder(\"childWithLink\")\n+        .addLink(link1)\n+        .addLink(link2)\n+        .addLink(parentSpan3.getContext())\n+        .addLink(remoteContext)\n+    .startSpan();\n+```\n+\n+For more details how to read context from remote processes, see [Context Propagation](#context-propagation).\n+\n+## Context Propagation\n+\n+OpenTelemetry provides a text based approach to propagate the W3C trace-context with remote processes by instrumenting the transport-layer operation.\n+The following presents an example of an outgoing HTTP request using `HttpURLConnection`.\n+ \n+```java\n+// Tell OpenTelemetry to inject the context in the HTTP headers\n+HttpTextFormat.Setter<HttpURLConnection> setter =\n+  new HttpTextFormat.Setter<HttpURLConnection>() {\n+    @Override\n+    public void put(HttpURLConnection carrier, String key, String value) {\n+        //Insert the context as Header\n+        carrier.setRequestProperty(key, value);\n+    }\n+};\n+\n+URL url = new URL(\"http://127.0.0.1:8080/resource\");\n+Span outGoing = tracer.spanBuilder(\"/resource\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+// Semantic Convention\n+outGoing.setAttribute(\"http.method\", \"GET\");\n+outGoing.setAttribute(\"http.url\", url.toString());\n+HttpURLConnection transportLayer = (HttpURLConnection) url.openConnection();\n+// Inject the request with the context\n+tracer.getHttpTextFormat().inject(outGoing.getContext(), transportLayer, setter);\n+// Make outgoing call\n+...\n+```\n+\n+Similarly, the text based approach can be used to read the W3C trace-context from incoming requests.\n+The following presents an example of processing an incoming HTTP request using `HttpExchange`.\n+```java\n+HttpTextFormat.Getter<HttpExchange> getter =\n+  new HttpTextFormat.Getter<HttpExchange>() {\n+    @Override\n+    public String get(HttpExchange carrier, String key) {\n+      if (carrier.getRequestHeaders().containsKey(key)) {\n+        return carrier.getRequestHeaders().get(key).get(0);\n+      }\n+      return \"\";", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNTY3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380305679", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # Metric\n          \n          \n            \n            # Metrics", "author": "arminru", "createdAt": "2020-02-17T17:36:27Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n+\n+[Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md\n+\n+## Create Spans with events\n+\n+Spans can be annotated with named events that can carry zero or more [Span Attributes](#span-attributes),\n+each of which is itself a key:value map paired automatically with a timestamp.\n+\n+```java\n+span.addEvent(\"Init\");\n+...\n+span.addEvent(\"End\");\n+```\n+```java\n+Map<String, AttributeValue> eventAttributes = new HashMap<>();\n+eventAttributes.put(\"key\", AttributeValue.stringAttributeValue(\"value\"));\n+eventAttributes.put(\"result\", AttributeValue.longAttributeValue(0L));\n+\n+span.addEvent(\"End Computation\", eventAttributes);\n+```\n+\n+## Span with links\n+A Span may be linked to zero or more other Spans that are causally related. \n+Links can be used to represent batched operations where a Span was initiated by multiple initiating Spans, each representing a single incoming item being processed in the batch.\n+\n+```java\n+Link link1 = SpanData.Link.create(parentSpan1.getContext());\n+Link link2 = SpanData.Link.create(parentSpan2.getContext());\n+Span child = tracer.spanBuilder(\"childWithLink\")\n+        .addLink(link1)\n+        .addLink(link2)\n+        .addLink(parentSpan3.getContext())\n+        .addLink(remoteContext)\n+    .startSpan();\n+```\n+\n+For more details how to read context from remote processes, see [Context Propagation](#context-propagation).\n+\n+## Context Propagation\n+\n+OpenTelemetry provides a text based approach to propagate the W3C trace-context with remote processes by instrumenting the transport-layer operation.\n+The following presents an example of an outgoing HTTP request using `HttpURLConnection`.\n+ \n+```java\n+// Tell OpenTelemetry to inject the context in the HTTP headers\n+HttpTextFormat.Setter<HttpURLConnection> setter =\n+  new HttpTextFormat.Setter<HttpURLConnection>() {\n+    @Override\n+    public void put(HttpURLConnection carrier, String key, String value) {\n+        //Insert the context as Header\n+        carrier.setRequestProperty(key, value);\n+    }\n+};\n+\n+URL url = new URL(\"http://127.0.0.1:8080/resource\");\n+Span outGoing = tracer.spanBuilder(\"/resource\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+// Semantic Convention\n+outGoing.setAttribute(\"http.method\", \"GET\");\n+outGoing.setAttribute(\"http.url\", url.toString());\n+HttpURLConnection transportLayer = (HttpURLConnection) url.openConnection();\n+// Inject the request with the context\n+tracer.getHttpTextFormat().inject(outGoing.getContext(), transportLayer, setter);\n+// Make outgoing call\n+...\n+```\n+\n+Similarly, the text based approach can be used to read the W3C trace-context from incoming requests.\n+The following presents an example of processing an incoming HTTP request using `HttpExchange`.\n+```java\n+HttpTextFormat.Getter<HttpExchange> getter =\n+  new HttpTextFormat.Getter<HttpExchange>() {\n+    @Override\n+    public String get(HttpExchange carrier, String key) {\n+      if (carrier.getRequestHeaders().containsKey(key)) {\n+        return carrier.getRequestHeaders().get(key).get(0);\n+      }\n+      return \"\";\n+    }\n+};\n+...\n+public void handle(HttpExchange he) {\n+    // Extract the context from the request\n+    SpanContext ctx = tracer.getHttpTextFormat().extract(he, getter);\n+    Span serverSpan = tracer.spanBuilder(\"/resource\").setSpanKind(Span.Kind.SERVER)\n+        .setParent(ctx)\n+        .startSpan();\n+    // Semantic Convention\n+    serverSpan.setAttribute(\"http.method\", \"GET\");\n+    serverSpan.setAttribute(\"http.scheme\", \"http\");\n+    serverSpan.setAttribute(\"http.host\", \"localhost:8080\");\n+    serverSpan.setAttribute(\"http.target\", \"/resource\");\n+    // Serve the request\n+    ...\n+    serverSpan.end();\n+}\n+```\n+\n+# Metric", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDMwNTc4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380305783", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Semantic Convention\n          \n          \n            \n                // Add the attributes defined in the Semantic Conventions", "author": "arminru", "createdAt": "2020-02-17T17:36:44Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,273 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Span with links](#span-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metric](#metric)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+Configuration is performed only by user applications which should configure the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.  \n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces are sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability \n+\n+Additional sampler can be provided implementing the [io.opentelemetry.sdk.trace.Sampler] interface.\n+\n+```java\n+TraceConfig AlwaysON = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[io.opentelemetry.sdk.trace.Sampler]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and send them in bulk. \n+Multiple Span processors can be configured to be active at the same time using `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In Memory Exporter: keeps the data in memory, useful for debug.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, the code must acquire a `tracer` which is responsible of create spans and interact with the in-process W3C trace-context.\n+A tracer is acquired using the OpenTelemetry API specifying name and version parameters. \n+More information are available in [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span. \n+Starting/Ending time and tracing-context are provided automatically by the OpenTelemetry API.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations. \n+OpenTelemetry supports distributed tracing within process and remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+```java\n+Span childLocalParent = tracer.spanBuilder(\"Child\").setParent(parentSpan).startSpan();\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on span to the specific operation it tracks, such as results or operation properties.\n+```java\n+Span span = tracer.spanBuilder(\"/resource/path\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+span.setAttribute(\"http.method\", \"GET\");\n+span.setAttribute(\"http.url\", url.toString());\n+```\n+\n+Some of these operations represent calls that use well-known protocols like HTTP or database calls. \n+For these, OpenTelemetry requires specific attributes to be set. To see more, please refer to the [Semantic Convention].\n+\n+[Semantic Convention]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/data-semantic-conventions.md\n+\n+## Create Spans with events\n+\n+Spans can be annotated with named events that can carry zero or more [Span Attributes](#span-attributes),\n+each of which is itself a key:value map paired automatically with a timestamp.\n+\n+```java\n+span.addEvent(\"Init\");\n+...\n+span.addEvent(\"End\");\n+```\n+```java\n+Map<String, AttributeValue> eventAttributes = new HashMap<>();\n+eventAttributes.put(\"key\", AttributeValue.stringAttributeValue(\"value\"));\n+eventAttributes.put(\"result\", AttributeValue.longAttributeValue(0L));\n+\n+span.addEvent(\"End Computation\", eventAttributes);\n+```\n+\n+## Span with links\n+A Span may be linked to zero or more other Spans that are causally related. \n+Links can be used to represent batched operations where a Span was initiated by multiple initiating Spans, each representing a single incoming item being processed in the batch.\n+\n+```java\n+Link link1 = SpanData.Link.create(parentSpan1.getContext());\n+Link link2 = SpanData.Link.create(parentSpan2.getContext());\n+Span child = tracer.spanBuilder(\"childWithLink\")\n+        .addLink(link1)\n+        .addLink(link2)\n+        .addLink(parentSpan3.getContext())\n+        .addLink(remoteContext)\n+    .startSpan();\n+```\n+\n+For more details how to read context from remote processes, see [Context Propagation](#context-propagation).\n+\n+## Context Propagation\n+\n+OpenTelemetry provides a text based approach to propagate the W3C trace-context with remote processes by instrumenting the transport-layer operation.\n+The following presents an example of an outgoing HTTP request using `HttpURLConnection`.\n+ \n+```java\n+// Tell OpenTelemetry to inject the context in the HTTP headers\n+HttpTextFormat.Setter<HttpURLConnection> setter =\n+  new HttpTextFormat.Setter<HttpURLConnection>() {\n+    @Override\n+    public void put(HttpURLConnection carrier, String key, String value) {\n+        //Insert the context as Header\n+        carrier.setRequestProperty(key, value);\n+    }\n+};\n+\n+URL url = new URL(\"http://127.0.0.1:8080/resource\");\n+Span outGoing = tracer.spanBuilder(\"/resource\").setSpanKind(Span.Kind.CLIENT).startSpan();\n+// Semantic Convention\n+outGoing.setAttribute(\"http.method\", \"GET\");\n+outGoing.setAttribute(\"http.url\", url.toString());\n+HttpURLConnection transportLayer = (HttpURLConnection) url.openConnection();\n+// Inject the request with the context\n+tracer.getHttpTextFormat().inject(outGoing.getContext(), transportLayer, setter);\n+// Make outgoing call\n+...\n+```\n+\n+Similarly, the text based approach can be used to read the W3C trace-context from incoming requests.\n+The following presents an example of processing an incoming HTTP request using `HttpExchange`.\n+```java\n+HttpTextFormat.Getter<HttpExchange> getter =\n+  new HttpTextFormat.Getter<HttpExchange>() {\n+    @Override\n+    public String get(HttpExchange carrier, String key) {\n+      if (carrier.getRequestHeaders().containsKey(key)) {\n+        return carrier.getRequestHeaders().get(key).get(0);\n+      }\n+      return \"\";\n+    }\n+};\n+...\n+public void handle(HttpExchange he) {\n+    // Extract the context from the request\n+    SpanContext ctx = tracer.getHttpTextFormat().extract(he, getter);\n+    Span serverSpan = tracer.spanBuilder(\"/resource\").setSpanKind(Span.Kind.SERVER)\n+        .setParent(ctx)\n+        .startSpan();\n+    // Semantic Convention", "originalCommit": "8ab73f33e1c57b90d23903197fa51106507642d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ffae9e5b2a8cab8a92ca7e164f67682894325972", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ffae9e5b2a8cab8a92ca7e164f67682894325972", "message": "Update QUICKSTART.md\n\nCo-Authored-By: Armin Ruech <armin.ruech@dynatrace.com>", "committedDate": "2020-02-18T07:14:56Z", "type": "commit"}, {"oid": "6a289303335da0b3cb2a50705869392e62c2c7ba", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6a289303335da0b3cb2a50705869392e62c2c7ba", "message": "Update QUICKSTART.md\n\nCo-Authored-By: Armin Ruech <armin.ruech@dynatrace.com>", "committedDate": "2020-02-18T07:39:55Z", "type": "commit"}, {"oid": "6a289303335da0b3cb2a50705869392e62c2c7ba", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6a289303335da0b3cb2a50705869392e62c2c7ba", "message": "Update QUICKSTART.md\n\nCo-Authored-By: Armin Ruech <armin.ruech@dynatrace.com>", "committedDate": "2020-02-18T07:39:55Z", "type": "forcePushed"}, {"oid": "27a94c7599aaf8bd51bfb0c77cb3a89a1de8fe16", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/27a94c7599aaf8bd51bfb0c77cb3a89a1de8fe16", "message": "Add quick start to readme.", "committedDate": "2020-02-18T07:47:21Z", "type": "commit"}, {"oid": "27a94c7599aaf8bd51bfb0c77cb3a89a1de8fe16", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/27a94c7599aaf8bd51bfb0c77cb3a89a1de8fe16", "message": "Add quick start to readme.", "committedDate": "2020-02-18T07:47:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NzY1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380797659", "bodyText": "link needed?", "author": "jkwatson", "createdAt": "2020-02-18T16:45:36Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,306 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].", "originalCommit": "27a94c7599aaf8bd51bfb0c77cb3a89a1de8fe16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwMTY0MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380801640", "bodyText": "nm. I didn't know you could do this with markdown.", "author": "jkwatson", "createdAt": "2020-02-18T16:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NzY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NzkwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380797909", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            **Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n          \n          \n            \n            **Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package", "author": "jkwatson", "createdAt": "2020-02-18T16:46:02Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,306 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package", "originalCommit": "27a94c7599aaf8bd51bfb0c77cb3a89a1de8fe16", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2Mzg4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381163882", "bodyText": "I think the intent was to make clear its discouraged (or even prohibited by the spec) to access the SDK as an instrumenting library as only the application should set that up.", "author": "arminru", "createdAt": "2020-02-19T09:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NzkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5ODM3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380798378", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n          \n          \n            \n            implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].", "author": "jkwatson", "createdAt": "2020-02-18T16:46:45Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,306 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].", "originalCommit": "27a94c7599aaf8bd51bfb0c77cb3a89a1de8fe16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwMjM0MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380802341", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The configuration should set up the exporter and may tune the OpenTelemetry behavior.\n          \n          \n            \n            The configuration should install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.", "author": "jkwatson", "createdAt": "2020-02-18T16:53:11Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,306 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The configuration should set up the exporter and may tune the OpenTelemetry behavior.", "originalCommit": "27a94c7599aaf8bd51bfb0c77cb3a89a1de8fe16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwMjY3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380802677", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            TraceConfig AlwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n          \n          \n            \n            TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(", "author": "jkwatson", "createdAt": "2020-02-18T16:53:43Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,306 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The configuration should set up the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig AlwaysOn = TraceConfig.getDefault().toBuilder().setSampler(", "originalCommit": "27a94c7599aaf8bd51bfb0c77cb3a89a1de8fe16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwMjg1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r380802857", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n          \n          \n            \n            TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(", "author": "jkwatson", "createdAt": "2020-02-18T16:53:55Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,306 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry must only take dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is instrumented. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The configuration should set up the exporter and may tune the OpenTelemetry behavior.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig AlwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig AlwaysOff = TraceConfig.getDefault().toBuilder().setSampler(", "originalCommit": "27a94c7599aaf8bd51bfb0c77cb3a89a1de8fe16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5acb5d4cd93dfaf2aff6db9d620702ecccd8bf79", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/5acb5d4cd93dfaf2aff6db9d620702ecccd8bf79", "message": "Apply suggestions of @jkwatson", "committedDate": "2020-02-19T08:13:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2NTE4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381165180", "bodyText": "The trick is that this actually happens implicitly. setParent is only used to override the default behavior of taking the current (\"active\") span.", "author": "arminru", "createdAt": "2020-02-19T09:21:14Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,306 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The configuration install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.\n+Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In-Memory Exporter: keeps the data in memory, useful for debugging.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, a `Tracer` must be acquired, which is responsible for creating spans and interacting with the [Context](#context-propagation).\n+A tracer is acquired by using the OpenTelemetry API specifying the name and version of the library \n+instrumenting the instrumented library or application to be monitored. \n+More information is available in the specification chapter [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span.\n+The start and end time of the span is automatically set by the OpenTelemetry SDK.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations.\n+OpenTelemetry supports tracing within processes and across remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+For a method `A` calling a method `B`, the spans could be manually linked in the following way:\n+```java\n+void a() {\n+  Span parentSpan = tracer.spanBuilder(\"a\").startSpan();\n+  b(parentSpan);\n+  parentSpan.end();\n+}\n+void b(Span parentSpan) {\n+  Span childSpan = tracer.spanBuilder(\"b\").setParent(parentSpan).startSpan();\n+  // do stuff\n+  childSpan.end();\n+}\n+```\n+Since it is not always possible to change a method signature or rely on global variables, the OpenTelemetry API\n+offers an automated way to propagate the `parentSpan`:\n+```java\n+void a() {\n+  Span parentSpan = tracer.spanBuilder(\"a\").startSpan();\n+  try(Scope scope = tracer.withSpan(parentSpan)){\n+    b();\n+  } finally {\n+    parentSpan.end();\n+  }\n+}\n+void b() {\n+  Span parentSpan = tracer.getCurrentSpan();\n+  Span childSpan = tracer.spanBuilder(\"b\").setParent(parentSpan).startSpan();", "originalCommit": "5acb5d4cd93dfaf2aff6db9d620702ecccd8bf79", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI2NTYwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381265603", "bodyText": "The more you know \ud83d\ude04", "author": "thisthat", "createdAt": "2020-02-19T12:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2NTE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2NjAwOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381166008", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Please refer to the [contribution guide](https://github.com/open-telemetry/opentelemetry-java/blob/master/CONTRIBUTING.md)\n          \n          \n            \n            Please refer to the [contribution guide](CONTRIBUTING.md)", "author": "arminru", "createdAt": "2020-02-19T09:22:48Z", "path": "README.md", "diffHunk": "@@ -27,6 +27,10 @@ We would love to hear from the larger community: please provide feedback proacti\n Please refer to the [contribution guide](https://github.com/open-telemetry/opentelemetry-java/blob/master/CONTRIBUTING.md)", "originalCommit": "5acb5d4cd93dfaf2aff6db9d620702ecccd8bf79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2NjEwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381166104", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Please refer to the [quick start guide](https://github.com/open-telemetry/opentelemetry-java/blob/master/QUICKSTART.md) on how use the OpenTelemetry API.\n          \n          \n            \n            Please refer to the [quick start guide](QUICKSTART.md) on how use the OpenTelemetry API.", "author": "arminru", "createdAt": "2020-02-19T09:22:58Z", "path": "README.md", "diffHunk": "@@ -27,6 +27,10 @@ We would love to hear from the larger community: please provide feedback proacti\n Please refer to the [contribution guide](https://github.com/open-telemetry/opentelemetry-java/blob/master/CONTRIBUTING.md)\n on how to setup and contribute!\n \n+## Quick Start\n+Please refer to the [quick start guide](https://github.com/open-telemetry/opentelemetry-java/blob/master/QUICKSTART.md) on how use the OpenTelemetry API.", "originalCommit": "5acb5d4cd93dfaf2aff6db9d620702ecccd8bf79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2OTg5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381169891", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The configuration install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n          \n          \n            \n            The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.", "author": "arminru", "createdAt": "2020-02-19T09:29:34Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,306 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The configuration install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.", "originalCommit": "5acb5d4cd93dfaf2aff6db9d620702ecccd8bf79", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dd112ecc72f24ded4e1a0a6dff7be984c663a7ca", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/dd112ecc72f24ded4e1a0a6dff7be984c663a7ca", "message": "Address feedback of @arminru", "committedDate": "2020-02-19T13:55:11Z", "type": "commit"}, {"oid": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "message": "Fix example", "committedDate": "2020-02-19T16:06:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQxMjYwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381412607", "bodyText": "Let's also add a link over to the OpenTelemetry registry to find other java exporters.\nhttps://opentelemetry.io/registry/?s=exporter", "author": "jkwatson", "createdAt": "2020-02-19T17:02:21Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.\n+Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MjkzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381882932", "bodyText": "Nice idea!", "author": "thisthat", "createdAt": "2020-02-20T09:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQxMjYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNTE0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381535142", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n          \n          \n            \n            Span processors are initialized with an exporter which is responsible for sending telemetry data to a particular backend.\n          \n      \n    \n    \n  \n\n\nLowercased \"processors\" since other terms of art like \"span\" are mostly lowercase\n\"particular\" instead of \"your choice\" to make it clear there's one exporter per backend", "author": "c24t", "createdAt": "2020-02-19T20:48:06Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.\n+Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNTQ0Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381535442", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            - Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n          \n          \n            \n            - Jaeger Exporter: prepares and sends the collected telemetry data to a Jaeger backend via gRPC.\n          \n      \n    \n    \n  \n\nTo match the tense of the others", "author": "c24t", "createdAt": "2020-02-19T20:48:45Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.\n+Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In-Memory Exporter: keeps the data in memory, useful for debugging.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNjY0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381536645", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              ...\n          \n          \n            \n              // do stuff\n          \n      \n    \n    \n  \n\nOr change it to \"...\" above, just to make it clear that it's the same bit of code in both snippets.", "author": "c24t", "createdAt": "2020-02-19T20:51:12Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.\n+Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In-Memory Exporter: keeps the data in memory, useful for debugging.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, a `Tracer` must be acquired, which is responsible for creating spans and interacting with the [Context](#context-propagation).\n+A tracer is acquired by using the OpenTelemetry API specifying the name and version of the library \n+instrumenting the instrumented library or application to be monitored. \n+More information is available in the specification chapter [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span.\n+The start and end time of the span is automatically set by the OpenTelemetry SDK.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations.\n+OpenTelemetry supports tracing within processes and across remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+For a method `A` calling a method `B`, the spans could be manually linked in the following way:\n+```java\n+void a() {\n+  Span parentSpan = tracer.spanBuilder(\"a\").startSpan();\n+  b(parentSpan);\n+  parentSpan.end();\n+}\n+void b(Span parentSpan) {\n+  Span childSpan = tracer.spanBuilder(\"b\").setParent(parentSpan).startSpan();\n+  // do stuff\n+  childSpan.end();\n+}\n+```\n+Since it is not always possible to change a method signature or rely on global variables, the OpenTelemetry API\n+offers an automated way to propagate the `parentSpan`:\n+```java\n+void a() {\n+  Span parentSpan = tracer.spanBuilder(\"a\").startSpan();\n+  try(Scope scope = tracer.withSpan(parentSpan)){\n+    b();\n+  } finally {\n+    parentSpan.end();\n+  }\n+}\n+void b() {\n+  Span childSpan = tracer.spanBuilder(\"b\")\n+     // NOTE: setParent(parentSpan) is not required anymore, \n+     // `tracer.getCurrentSpan()` is automatically added as parent\n+    .startSpan();\n+  ...", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzNzE3Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381537177", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For a method `A` calling a method `B`, the spans could be manually linked in the following way:\n          \n          \n            \n            For a method `a` calling a method `b`, the spans could be manually linked in the following way:", "author": "c24t", "createdAt": "2020-02-19T20:52:25Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.\n+Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In-Memory Exporter: keeps the data in memory, useful for debugging.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, a `Tracer` must be acquired, which is responsible for creating spans and interacting with the [Context](#context-propagation).\n+A tracer is acquired by using the OpenTelemetry API specifying the name and version of the library \n+instrumenting the instrumented library or application to be monitored. \n+More information is available in the specification chapter [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span.\n+The start and end time of the span is automatically set by the OpenTelemetry SDK.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations.\n+OpenTelemetry supports tracing within processes and across remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+For a method `A` calling a method `B`, the spans could be manually linked in the following way:", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTc2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381539760", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n          \n          \n            \n            In OpenTelemetry spans can be created freely and it's up to the implementor to annotate them with attributes specific to the represented operation. \n          \n      \n    \n    \n  \n\nSmart quote copied from a word doc?", "author": "c24t", "createdAt": "2020-02-19T20:57:24Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.\n+Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In-Memory Exporter: keeps the data in memory, useful for debugging.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, a `Tracer` must be acquired, which is responsible for creating spans and interacting with the [Context](#context-propagation).\n+A tracer is acquired by using the OpenTelemetry API specifying the name and version of the library \n+instrumenting the instrumented library or application to be monitored. \n+More information is available in the specification chapter [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span.\n+The start and end time of the span is automatically set by the OpenTelemetry SDK.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations.\n+OpenTelemetry supports tracing within processes and across remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+For a method `A` calling a method `B`, the spans could be manually linked in the following way:\n+```java\n+void a() {\n+  Span parentSpan = tracer.spanBuilder(\"a\").startSpan();\n+  b(parentSpan);\n+  parentSpan.end();\n+}\n+void b(Span parentSpan) {\n+  Span childSpan = tracer.spanBuilder(\"b\").setParent(parentSpan).startSpan();\n+  // do stuff\n+  childSpan.end();\n+}\n+```\n+Since it is not always possible to change a method signature or rely on global variables, the OpenTelemetry API\n+offers an automated way to propagate the `parentSpan`:\n+```java\n+void a() {\n+  Span parentSpan = tracer.spanBuilder(\"a\").startSpan();\n+  try(Scope scope = tracer.withSpan(parentSpan)){\n+    b();\n+  } finally {\n+    parentSpan.end();\n+  }\n+}\n+void b() {\n+  Span childSpan = tracer.spanBuilder(\"b\")\n+     // NOTE: setParent(parentSpan) is not required anymore, \n+     // `tracer.getCurrentSpan()` is automatically added as parent\n+    .startSpan();\n+  ...\n+  childSpan.end();\n+}\n+``` \n+\n+To link spans from remote processes, it is sufficient to set the [Remote Context](#context-propagation) as parent. \n+```java\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. ", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg5NDI0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381894248", "bodyText": "Left-hand quote \ud83d\ude04", "author": "thisthat", "createdAt": "2020-02-20T09:56:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUzOTc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MDEwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381540100", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Attributes provide additional context on a span to the specific operation it tracks, such as results or operation properties.\n          \n          \n            \n            Attributes provide additional context on a span about the specific operation it tracks, such as results or operation properties.\n          \n      \n    \n    \n  \n\nOr \"specific to the operation it tracks\"", "author": "c24t", "createdAt": "2020-02-19T20:58:06Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.\n+Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In-Memory Exporter: keeps the data in memory, useful for debugging.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, a `Tracer` must be acquired, which is responsible for creating spans and interacting with the [Context](#context-propagation).\n+A tracer is acquired by using the OpenTelemetry API specifying the name and version of the library \n+instrumenting the instrumented library or application to be monitored. \n+More information is available in the specification chapter [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span.\n+The start and end time of the span is automatically set by the OpenTelemetry SDK.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations.\n+OpenTelemetry supports tracing within processes and across remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+For a method `A` calling a method `B`, the spans could be manually linked in the following way:\n+```java\n+void a() {\n+  Span parentSpan = tracer.spanBuilder(\"a\").startSpan();\n+  b(parentSpan);\n+  parentSpan.end();\n+}\n+void b(Span parentSpan) {\n+  Span childSpan = tracer.spanBuilder(\"b\").setParent(parentSpan).startSpan();\n+  // do stuff\n+  childSpan.end();\n+}\n+```\n+Since it is not always possible to change a method signature or rely on global variables, the OpenTelemetry API\n+offers an automated way to propagate the `parentSpan`:\n+```java\n+void a() {\n+  Span parentSpan = tracer.spanBuilder(\"a\").startSpan();\n+  try(Scope scope = tracer.withSpan(parentSpan)){\n+    b();\n+  } finally {\n+    parentSpan.end();\n+  }\n+}\n+void b() {\n+  Span childSpan = tracer.spanBuilder(\"b\")\n+     // NOTE: setParent(parentSpan) is not required anymore, \n+     // `tracer.getCurrentSpan()` is automatically added as parent\n+    .startSpan();\n+  ...\n+  childSpan.end();\n+}\n+``` \n+\n+To link spans from remote processes, it is sufficient to set the [Remote Context](#context-propagation) as parent. \n+```java\n+Span childRemoteParent = tracer.spanBuilder(\"Child\").setParent(remoteContext).startSpan();\n+```\n+\n+## Span Attributes\n+In OpenTelemetry spans can be created freely and it\u2019s up to the implementor to annotate them with attributes specific to the represented operation. \n+Attributes provide additional context on a span to the specific operation it tracks, such as results or operation properties.", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MjAzOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381542039", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            // Get the tracer\n          \n          \n            \n            // Initialize the tracer registry\n          \n      \n    \n    \n  \n\nSince it's the registry that gets configured, not the tracer.", "author": "c24t", "createdAt": "2020-02-19T21:01:51Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MDEyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381780124", "bodyText": "I like Get the Tracer more ;) (the tracer provider/registry may have been already initialized)", "author": "carlosalberto", "createdAt": "2020-02-20T05:50:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MjAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NDY4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381544683", "bodyText": "It might be helpful to link to https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/sdk-tracing.md#sampling here, but even that doc doesn't make it clear what happens to non-sampled traces (don't get exported, don't accept events, etc.).", "author": "c24t", "createdAt": "2020-02-19T21:07:22Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. ", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MTQxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381781413", "bodyText": "I very personally feel actual documentation (once we have an actual OTel website) could be better than the actual Specification, as it might be too dense for end users, as commented before.", "author": "carlosalberto", "createdAt": "2020-02-20T05:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NDY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NDc3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381544776", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n          \n          \n            \n            Additional samplers can be provided by implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.", "author": "c24t", "createdAt": "2020-02-19T21:07:35Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NjIyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381546229", "bodyText": "May want to note that this configuration info only applies to the SDK provided by opentelemetry-sdk since you mention \"any other implementation\" above. E.g. there's no updateActiveTraceConfig in the API package, and other SDKs are free to offer different configuration options.", "author": "c24t", "createdAt": "2020-02-19T21:10:30Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NzQwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381547404", "bodyText": "This line makes it sound like the example above is standard practice, instead of just here to demonstrate the mechanics of implicit context propagation.", "author": "c24t", "createdAt": "2020-02-19T21:12:55Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.\n+Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In-Memory Exporter: keeps the data in memory, useful for debugging.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, a `Tracer` must be acquired, which is responsible for creating spans and interacting with the [Context](#context-propagation).\n+A tracer is acquired by using the OpenTelemetry API specifying the name and version of the library \n+instrumenting the instrumented library or application to be monitored. \n+More information is available in the specification chapter [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span.\n+The start and end time of the span is automatically set by the OpenTelemetry SDK.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations.\n+OpenTelemetry supports tracing within processes and across remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+For a method `A` calling a method `B`, the spans could be manually linked in the following way:\n+```java\n+void a() {\n+  Span parentSpan = tracer.spanBuilder(\"a\").startSpan();\n+  b(parentSpan);\n+  parentSpan.end();\n+}\n+void b(Span parentSpan) {\n+  Span childSpan = tracer.spanBuilder(\"b\").setParent(parentSpan).startSpan();\n+  // do stuff\n+  childSpan.end();\n+}\n+```\n+Since it is not always possible to change a method signature or rely on global variables, the OpenTelemetry API", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MjQ0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381782446", "bodyText": "Agreed on this!", "author": "carlosalberto", "createdAt": "2020-02-20T05:55:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0NzQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODA5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381548099", "bodyText": "Maybe leave metrics for another PR (unless you're planning to fill out the TODO at the bottom in this one).", "author": "c24t", "createdAt": "2020-02-19T21:14:19Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3ODI3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381778270", "bodyText": "+1", "author": "carlosalberto", "createdAt": "2020-02-20T05:47:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODA5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkzNTcwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381935706", "bodyText": "@bogdandrutu is working on finishing the implementation of the Metric part. I will provide a follow up PR that addresses the metric part soon \ud83d\ude09", "author": "thisthat", "createdAt": "2020-02-20T11:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODA5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4MjA1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r382082055", "bodyText": "@thisthat thanks!", "author": "carlosalberto", "createdAt": "2020-02-20T15:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0ODA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MjMwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381552302", "bodyText": "There are a few places it would be helpful to link to e.g. javadocs, where the behavior isn't obvious from the name alone. This one looks like it could benefit from some links to me, e.g.:\n\nAlwaysOnSampler, which samples every trace regardless of upstream sampling decisions.\nAlwaysOffSampler, which doesn't sample any trace, regardless of upstream sampling decisions.\nProbability which samples a configurable percentage of traces, and additionally samples any trace that was sampled upstream.\n\nI linked to the source here since AFAICT there aren't hosted docs I can link to.", "author": "c24t", "createdAt": "2020-02-19T21:23:20Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3Nzk4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381777987", "bodyText": "\"for collecting telemetry data\" maybe?", "author": "carlosalberto", "createdAt": "2020-02-20T05:46:27Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3ODc5Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381778792", "bodyText": "Not sure we want end users to refer to the actual Specification - maybe put it at the end, in a \"Resources\" list?", "author": "carlosalberto", "createdAt": "2020-02-20T05:48:01Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkwODc0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381908749", "bodyText": "I agree that specification should not be part of this document, but this is the overview of the overall project. Maybe linking the openteletry website?", "author": "thisthat", "createdAt": "2020-02-20T10:22:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3ODc5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4MjI4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r382082280", "bodyText": "I'd be fine with that, yes.", "author": "carlosalberto", "createdAt": "2020-02-20T15:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3ODc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc3OTA5OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381779098", "bodyText": "\"telemetry data\" is probably better here, as opentelemetry-api includes also metrics and correlation context (even if this section focuses on traces).", "author": "carlosalberto", "createdAt": "2020-02-20T05:48:39Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MDc2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381780768", "bodyText": "I'd prefer to have this split among different lines, instead of a single long one (better readability).", "author": "carlosalberto", "createdAt": "2020-02-20T05:51:57Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTc4MjI0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/869#discussion_r381782249", "bodyText": "It would also be nice to split this line here (and other relatively long lines).", "author": "carlosalberto", "createdAt": "2020-02-20T05:54:47Z", "path": "QUICKSTART.md", "diffHunk": "@@ -0,0 +1,308 @@\n+# OpenTelemetry QuickStart\n+\n+<!-- Re-generate TOC with `markdown-toc --no-first-h1 -i` -->\n+\n+<!-- toc -->\n+\n+- [Configuration](#configuration)\n+    + [Sampler](#sampler)\n+    + [Span Processor](#span-processor)\n+    + [Exporter](#exporter)\n+- [Tracing](#tracing)\n+  * [Create basic Span](#create-basic-span)\n+  * [Create nested Spans](#create-nested-spans)\n+  * [Span Attributes](#span-attributes)\n+  * [Create Spans with events](#create-spans-with-events)\n+  * [Create Spans with links](#create-spans-with-links)\n+  * [Context Propagation](#context-propagation)\n+- [Metrics](#metrics)\n+\n+<!-- tocstop -->\n+\n+OpenTelemetry can be used to instrument code for collecting distributed traces and recording metrics.\n+For more details, check out the [Specification Overview].\n+\n+In the following examples, we demonstrate how to configure the OpenTelemetry SDK, create spans and record metrics through the OpenTelemetry API.\n+\n+[Specification Overview]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/overview.md\n+\n+# Configuration\n+\n+**Libraries** that want to export distributed tracing using OpenTelemetry only need a dependency on the `opentelemetry-api` package\n+and should never configure OpenTelemetry themselves. The configuration must be provided by **Applications** which should also depend on the \n+`opentelemetry-sdk` package, or any other implementation of the OpenTelemetry API. This way, libraries will obtain a real tracer\n+implementation only if the user application is configured for it. For more details, check out the [Library Guidelines].\n+\n+[Library Guidelines]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/library-guidelines.md\n+\n+The application has to install a span processor with an exporter and may customize the behavior of the OpenTelemetry SDK.\n+\n+For example, a basic configuration instantiates the SDK tracer registry and sets to export the traces to a logging stream.\n+\n+```java\n+// Get the tracer\n+TracerSdkRegistry tracerRegistry = OpenTelemetrySdk.getTracerRegistry();\n+\n+// Set to export the traces to a logging stream\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(new LoggingExporter()).build());\n+```\n+\n+### Sampler\n+\n+It is not always feasible to trace and export every user request in an application.\n+In order to strike a balance between observability and expenses, traces can be sampled. \n+\n+The OpenTelemetry SDK offers three samplers out of the box:\n+ - Always sample\n+ - Never sample\n+ - Sampling based on probability\n+\n+Additional samplers can be provided implementing the [`io.opentelemetry.sdk.trace.Sampler`] interface.\n+\n+```java\n+TraceConfig alwaysOn = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOn()\n+).build();\n+TraceConfig alwaysOff = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.alwaysOff()\n+).build();\n+TraceConfig half = TraceConfig.getDefault().toBuilder().setSampler(\n+        Samplers.probability(0.5)\n+).build();\n+// Configure the sampler to use\n+tracerRegistry.updateActiveTraceConfig(\n+    half\n+);\n+```\n+\n+[`io.opentelemetry.sdk.trace.Sampler`]: https://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/Sampler.java\n+\n+### Span Processor\n+\n+Different Span processors are offered by OpenTelemetry. \n+The `SimpleSpanProcessor` immediately forwards ended spans to the exporter, while the `BatchSpansProcessor` batches them and sends them in bulk.\n+Multiple Span processors can be configured to be active at the same time using the `MultiSpanProcessor`.\n+\n+```java\n+tracerRegistry.addSpanProcessor(\n+    SimpleSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(\n+    BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+);\n+tracerRegistry.addSpanProcessor(MultiSpanProcessor.create(Arrays.asList(\n+            SimpleSpansProcessor.newBuilder(new LoggingExporter()).build(),\n+            BatchSpansProcessor.newBuilder(new LoggingExporter()).build()\n+)));\n+```\n+\n+### Exporter\n+\n+Span Processor are initialized with an exporter which is responsible to send the telemetry data to your backend of choice.\n+OpenTelemetry offers four exporters out of the box:\n+- In-Memory Exporter: keeps the data in memory, useful for debugging.\n+- Jaeger Exporter: prepare and send the collected telemetry data to a Jaeger backend via gRPC.\n+- Logging Exporter: saves the telemetry data into log streams.\n+- OpenTelemetry Exporter: sends the data to the [OpenTelemetry Collector] (not yet implemented).\n+\n+[OpenTelemetry Collector]: https://github.com/open-telemetry/opentelemetry-collector\n+\n+```java\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    InMemorySpanExporter.create()\n+).build());\n+tracerRegistry.addSpanProcessor(SimpleSpansProcessor.newBuilder(\n+    new LoggingExporter()\n+).build());\n+\n+ManagedChannel jaegerChannel = ManagedChannelBuilder.forAddress([ip:String], [port:int]).usePlaintext().build();\n+JaegerGrpcSpanExporter jaegerExporter = JaegerGrpcSpanExporter.newBuilder()\n+    .setServiceName(\"example\").setChannel(jaegerChannel).setDeadline(30000)\n+    .build();\n+tracerRegistry.addSpanProcessor(BatchSpansProcessor.newBuilder(\n+    jaegerExporter\n+).build());\n+```\n+\n+# Tracing\n+\n+In the following, we present how to trace code using the OpenTelemetry API.\n+**Note:** Methods of the OpenTelemetry SDK should never be called.\n+ \n+First, a `Tracer` must be acquired, which is responsible for creating spans and interacting with the [Context](#context-propagation).\n+A tracer is acquired by using the OpenTelemetry API specifying the name and version of the library \n+instrumenting the instrumented library or application to be monitored. \n+More information is available in the specification chapter [Obtaining a Tracer].\n+\n+```java\n+Tracer tracer = OpenTelemetry.getTracerRegistry().get(\"instrumentation-library-name\",\"semver:1.0.0\");\n+```\n+\n+[Obtaining a Tracer]: https://github.com/open-telemetry/opentelemetry-specification/blob/master/specification/api-tracing.md#obtaining-a-tracer\n+\n+## Create basic Span\n+To create a basic span, you only need to specify the name of the span.\n+The start and end time of the span is automatically set by the OpenTelemetry SDK.\n+```java\n+Span span = tracer.spanBuilder(\"SpanName\").startSpan();\n+// your use case\n+...\n+span.end();\n+```\n+\n+## Create nested Spans\n+\n+Most of the time, we want to correlate spans for nested operations.\n+OpenTelemetry supports tracing within processes and across remote processes.\n+For more details how to share context between remote processes, see [Context Propagation](#context-propagation).\n+\n+For a method `A` calling a method `B`, the spans could be manually linked in the following way:\n+```java\n+void a() {\n+  Span parentSpan = tracer.spanBuilder(\"a\").startSpan();\n+  b(parentSpan);\n+  parentSpan.end();\n+}\n+void b(Span parentSpan) {\n+  Span childSpan = tracer.spanBuilder(\"b\").setParent(parentSpan).startSpan();", "originalCommit": "39b6b74a8620ee06b3456973cb85ef1d5788c6eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a29ec3ca96778d0fad1aa61f6fcc49c6f96e471", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/1a29ec3ca96778d0fad1aa61f6fcc49c6f96e471", "message": "Address review comments", "committedDate": "2020-02-20T10:25:19Z", "type": "commit"}, {"oid": "66c32327327d4ef240b49ee46bc36301826745b2", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/66c32327327d4ef240b49ee46bc36301826745b2", "message": "Use opentelemetry website", "committedDate": "2020-02-21T07:09:28Z", "type": "commit"}]}