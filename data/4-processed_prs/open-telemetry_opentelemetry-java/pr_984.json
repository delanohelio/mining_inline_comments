{"pr_number": 984, "pr_title": "Add OTLP trace implementation", "pr_createdAt": "2020-03-10T02:03:37Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/984", "timeline": [{"oid": "05d9f67255a5b237dd0e68b347f1bb6fa231c4ae", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/05d9f67255a5b237dd0e68b347f1bb6fa231c4ae", "message": "Add OTLP trace implementation\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-10T13:39:43Z", "type": "forcePushed"}, {"oid": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/19996d87b34ed932e8079d2aa87e39a1c3e59ab6", "message": "Add OTLP trace implementation\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-10T14:31:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM2NDIxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390364216", "bodyText": "I thought that we had decided that retrying would be the responsibility of the exporter, and that we wouldn't use this code any more. I guess that never got changed, but I still think the exporter should handle its own retries. (also, I don't think any of the span processors currently do any retry logic).", "author": "jkwatson", "createdAt": "2020-03-10T14:41:01Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadline;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.\n+   * @param deadline max waiting time for the collector to process each span batch. When set to 0 or\n+   *     to a negative value, the exporter will wait indefinitely.\n+   */\n+  private OtlpGrpcSpanExporter(ManagedChannel channel, long deadline) {\n+    this.managedChannel = channel;\n+    this.blockingStub = TraceServiceGrpc.newBlockingStub(channel);\n+    this.deadline = deadline;\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public ResultCode export(List<SpanData> spans) {\n+    ExportTraceServiceRequest exportTraceServiceRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(spans))\n+            .build();\n+\n+    try {\n+      TraceServiceGrpc.TraceServiceBlockingStub stub = this.blockingStub;\n+      if (deadline > 0) {\n+        stub = stub.withDeadlineAfter(deadline, TimeUnit.MILLISECONDS);\n+      }\n+\n+      // for now, there's nothing to check in the response object\n+      // noinspection ResultOfMethodCallIgnored\n+      stub.export(exportTraceServiceRequest);\n+      return ResultCode.SUCCESS;\n+    } catch (StatusRuntimeException e) {\n+      // Retryable codes from https://github.com/open-telemetry/oteps/pull/65\n+      switch (e.getStatus().getCode()) {\n+        case CANCELLED:\n+        case DEADLINE_EXCEEDED:\n+        case RESOURCE_EXHAUSTED:\n+        case OUT_OF_RANGE:\n+        case UNAVAILABLE:\n+        case DATA_LOSS:\n+          return ResultCode.FAILED_RETRYABLE;", "originalCommit": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5NzQ4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390397484", "bodyText": "Looks like this is still in the spec. I'll open up a spec issue to discuss.", "author": "jkwatson", "createdAt": "2020-03-10T15:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM2NDIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQwNDE1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390404155", "bodyText": "open-telemetry/opentelemetry-specification#509", "author": "jkwatson", "createdAt": "2020-03-10T15:32:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM2NDIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDUzNDIzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390534234", "bodyText": "As explained in that issue, this is an exporter so then I need to implement retry logic and I will use the same logic to determine when to retry.", "author": "bogdandrutu", "createdAt": "2020-03-10T18:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM2NDIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3MjIyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390372227", "bodyText": "rather than the comment, name the variable \"deadlineMillis\"", "author": "jkwatson", "createdAt": "2020-03-10T14:51:07Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadline;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.\n+   * @param deadline max waiting time for the collector to process each span batch. When set to 0 or\n+   *     to a negative value, the exporter will wait indefinitely.\n+   */\n+  private OtlpGrpcSpanExporter(ManagedChannel channel, long deadline) {\n+    this.managedChannel = channel;\n+    this.blockingStub = TraceServiceGrpc.newBlockingStub(channel);\n+    this.deadline = deadline;\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.\n+   *\n+   * @param spans the list of sampled Spans to be exported.\n+   * @return the result of the operation\n+   */\n+  @Override\n+  public ResultCode export(List<SpanData> spans) {\n+    ExportTraceServiceRequest exportTraceServiceRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(spans))\n+            .build();\n+\n+    try {\n+      TraceServiceGrpc.TraceServiceBlockingStub stub = this.blockingStub;\n+      if (deadline > 0) {\n+        stub = stub.withDeadlineAfter(deadline, TimeUnit.MILLISECONDS);\n+      }\n+\n+      // for now, there's nothing to check in the response object\n+      // noinspection ResultOfMethodCallIgnored\n+      stub.export(exportTraceServiceRequest);\n+      return ResultCode.SUCCESS;\n+    } catch (StatusRuntimeException e) {\n+      // Retryable codes from https://github.com/open-telemetry/oteps/pull/65\n+      switch (e.getStatus().getCode()) {\n+        case CANCELLED:\n+        case DEADLINE_EXCEEDED:\n+        case RESOURCE_EXHAUSTED:\n+        case OUT_OF_RANGE:\n+        case UNAVAILABLE:\n+        case DATA_LOSS:\n+          return ResultCode.FAILED_RETRYABLE;\n+        default:\n+          return ResultCode.FAILED_NOT_RETRYABLE;\n+      }\n+    } catch (Throwable t) {\n+      return ResultCode.FAILED_NOT_RETRYABLE;\n+    }\n+  }\n+\n+  /**\n+   * Creates a new builder instance.\n+   *\n+   * @return a new instance builder for this exporter\n+   */\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  /**\n+   * Initiates an orderly shutdown in which preexisting calls continue but new calls are immediately\n+   * cancelled. The channel is forcefully closed after a timeout.\n+   */\n+  @Override\n+  public void shutdown() {\n+    try {\n+      managedChannel.shutdown().awaitTermination(5, TimeUnit.SECONDS);\n+    } catch (InterruptedException e) {\n+      logger.log(Level.WARNING, \"Failed to shutdown the gRPC channel\", e);\n+    }\n+  }\n+\n+  /** Builder utility for this exporter. */\n+  public static class Builder {\n+    private ManagedChannel channel;\n+    private long deadline = 1_000; // ms", "originalCommit": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM4MTMzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390381335", "bodyText": "Done.", "author": "bogdandrutu", "createdAt": "2020-03-10T15:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3MjIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390376644", "bodyText": "Can we really have more than one Resource per SDK? I wonder if we should pass the Resource in at the top level of the export API, rather than have to make every exporter do this convoluted logic.", "author": "jkwatson", "createdAt": "2020-03-10T14:56:32Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/SpanAdapter.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.trace.v1.ResourceSpans;\n+import io.opentelemetry.proto.trace.v1.Span;\n+import io.opentelemetry.proto.trace.v1.Span.SpanKind;\n+import io.opentelemetry.proto.trace.v1.Status;\n+import io.opentelemetry.proto.trace.v1.Status.StatusCode;\n+import io.opentelemetry.sdk.contrib.otproto.TraceProtoUtils;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData.TimedEvent;\n+import io.opentelemetry.trace.AttributeValue;\n+import io.opentelemetry.trace.Link;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+final class SpanAdapter {\n+  static List<ResourceSpans> toProtoResourceSpans(List<SpanData> spanDataList) {\n+    Map<Resource, ResourceSpans.Builder> resourceSpansBuilderMap = new HashMap<>();\n+    for (SpanData spanData : spanDataList) {\n+      Resource resource = spanData.getResource();\n+      ResourceSpans.Builder resourceSpansBuilder =\n+          resourceSpansBuilderMap.get(spanData.getResource());\n+      if (resourceSpansBuilder == null) {\n+        resourceSpansBuilder =\n+            ResourceSpans.newBuilder().setResource(ResourceAdapter.toProtoResource(resource));\n+        resourceSpansBuilderMap.put(resource, resourceSpansBuilder);", "originalCommit": "19996d87b34ed932e8079d2aa87e39a1c3e59ab6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3OTkyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390379929", "bodyText": "We can have multiple instances of the SDK, but not multiple Resources per SDK. Maybe we should file an issue for this.", "author": "bogdandrutu", "createdAt": "2020-03-10T15:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5Mjk3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390392974", "bodyText": "ok. Let's extract this bit that builds the map into it's own method, for clarity.", "author": "jkwatson", "createdAt": "2020-03-10T15:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU1Nzk1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390557959", "bodyText": "I think the logic is pretty isolated, can you clarify how would you like the code to be structured?", "author": "bogdandrutu", "createdAt": "2020-03-10T19:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDYwODUxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390608518", "bodyText": "I'd just take the code that creates the Map and populates it and move it to its own method.", "author": "jkwatson", "createdAt": "2020-03-10T21:01:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0NzI2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390647266", "bodyText": "While I am constructing the Map I am also converting the Spans and add them to the builder. So not sure how to cleanly separate them.", "author": "bogdandrutu", "createdAt": "2020-03-10T22:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0ODMxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390648311", "bodyText": "couldn't lines 37 through 48 be a method that returns the Map<Resource, ResourceSpans.Builder>?", "author": "jkwatson", "createdAt": "2020-03-10T22:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0OTE4MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390649181", "bodyText": "Yes but that method also converts Spans so for me it is not that of a clear separation.", "author": "bogdandrutu", "createdAt": "2020-03-10T22:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0OTM4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390649387", "bodyText": "But if that unblocks this PR I will do it :)", "author": "bogdandrutu", "createdAt": "2020-03-10T22:31:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1MDMyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390650321", "bodyText": "I think that's fair. I won't hold it up if you want to keep it as-is. We have bigger fish to fry. :)", "author": "jkwatson", "createdAt": "2020-03-10T22:34:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM3NjY0NA=="}], "type": "inlineReview"}, {"oid": "d2c8db64e604098ad85c11f8351ee130f591f6ff", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d2c8db64e604098ad85c11f8351ee130f591f6ff", "message": "Add OTLP trace implementation\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-10T15:02:24Z", "type": "forcePushed"}, {"oid": "35e0477f12dbda89d2269a7cf17cb667989ad420", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/35e0477f12dbda89d2269a7cf17cb667989ad420", "message": "Add OTLP trace implementation\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-10T22:22:15Z", "type": "forcePushed"}, {"oid": "81c9ec5620849e484664e807af77fc7515968874", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/81c9ec5620849e484664e807af77fc7515968874", "message": "Add OTLP trace implementation\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-10T22:28:24Z", "type": "forcePushed"}, {"oid": "2715d84b5bf9075274c0af3cff32ce9135a6b403", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2715d84b5bf9075274c0af3cff32ce9135a6b403", "message": "Add OTLP trace implementation\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-10T22:54:25Z", "type": "commit"}, {"oid": "2715d84b5bf9075274c0af3cff32ce9135a6b403", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/2715d84b5bf9075274c0af3cff32ce9135a6b403", "message": "Add OTLP trace implementation\n\nSigned-off-by: Bogdan Cristian Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-03-10T22:54:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMzY5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390733694", "bodyText": "Jaeger?", "author": "carlosalberto", "createdAt": "2020-03-11T03:56:43Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadlineMs;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.", "originalCommit": "2715d84b5bf9075274c0af3cff32ce9135a6b403", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczMzc3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390733779", "bodyText": "Same.", "author": "carlosalberto", "createdAt": "2020-03-11T03:57:08Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadlineMs;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.", "originalCommit": "2715d84b5bf9075274c0af3cff32ce9135a6b403", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczNDA1Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390734056", "bodyText": "Jaeger, etc.", "author": "carlosalberto", "createdAt": "2020-03-11T03:58:22Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcSpanExporter.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.grpc.ManagedChannel;\n+import io.grpc.StatusRuntimeException;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import io.opentelemetry.proto.collector.trace.v1.TraceServiceGrpc;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import io.opentelemetry.sdk.trace.export.SpanExporter;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/** Exports spans using OTLP via gRPC, using OpenTelemetry's protobuf model. */\n+@ThreadSafe\n+public final class OtlpGrpcSpanExporter implements SpanExporter {\n+  private static final Logger logger = Logger.getLogger(OtlpGrpcSpanExporter.class.getName());\n+\n+  private final TraceServiceGrpc.TraceServiceBlockingStub blockingStub;\n+  private final ManagedChannel managedChannel;\n+  private final long deadlineMs;\n+\n+  /**\n+   * Creates a new Jaeger gRPC Span Reporter with the given name, using the given channel.\n+   *\n+   * @param channel the channel to use when communicating with the Jaeger Collector.\n+   * @param deadlineMs max waiting time for the collector to process each span batch. When set to 0\n+   *     or to a negative value, the exporter will wait indefinitely.\n+   */\n+  private OtlpGrpcSpanExporter(ManagedChannel channel, long deadlineMs) {\n+    this.managedChannel = channel;\n+    this.blockingStub = TraceServiceGrpc.newBlockingStub(channel);\n+    this.deadlineMs = deadlineMs;\n+  }\n+\n+  /**\n+   * Submits all the given spans in a single batch to the Jaeger collector.", "originalCommit": "2715d84b5bf9075274c0af3cff32ce9135a6b403", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDczNjM4OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/984#discussion_r390736389", "bodyText": "Guess no multi value attributes for now? ;)", "author": "carlosalberto", "createdAt": "2020-03-11T04:10:05Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/CommonAdapter.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.exporters.otlp;\n+\n+import io.opentelemetry.proto.common.v1.AttributeKeyValue;\n+import io.opentelemetry.proto.common.v1.AttributeKeyValue.ValueType;\n+import io.opentelemetry.trace.AttributeValue;\n+\n+final class CommonAdapter {\n+  static AttributeKeyValue toProtoAttribute(String key, AttributeValue attributeValue) {\n+    AttributeKeyValue.Builder builder = AttributeKeyValue.newBuilder().setKey(key);\n+    switch (attributeValue.getType()) {\n+      case STRING:\n+        return builder\n+            .setType(ValueType.STRING)\n+            .setStringValue(attributeValue.getStringValue())\n+            .build();\n+      case BOOLEAN:\n+        return builder\n+            .setType(ValueType.BOOL)\n+            .setBoolValue(attributeValue.getBooleanValue())\n+            .build();\n+      case LONG:\n+        return builder.setType(ValueType.INT).setIntValue(attributeValue.getLongValue()).build();\n+      case DOUBLE:\n+        return builder\n+            .setType(ValueType.DOUBLE)\n+            .setDoubleValue(attributeValue.getDoubleValue())\n+            .build();\n+    }", "originalCommit": "2715d84b5bf9075274c0af3cff32ce9135a6b403", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}