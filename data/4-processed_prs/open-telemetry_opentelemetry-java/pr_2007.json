{"pr_number": 2007, "pr_title": "Make the BatchRecorderSdk actually batch the recordings", "pr_createdAt": "2020-11-04T21:23:32Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007", "timeline": [{"oid": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/743ec823e5faae9f20f9deb1f2bbeb286ea3c281", "message": "Make the BatchRecorderSdk actually batch the recordings\nRather than just forwarding them immediately.", "committedDate": "2020-11-04T21:21:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4NzgzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517787835", "bodyText": "If I'm reading this right, I think there's less code duplication if we have the loop on the outside of the instanceof checks", "author": "anuraaga", "createdAt": "2020-11-05T04:37:19Z", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleValueRecorder valueRecorder, double value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(LongCounter counter, long value) {\n-    counter.add(value, labelSet);\n+    recordings.computeIfAbsent(counter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleCounter counter, double value) {\n-    counter.add(value, labelSet);\n+    recordings.computeIfAbsent(counter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(LongUpDownCounter upDownCounter, long value) {\n-    upDownCounter.add(value, labelSet);\n+    recordings.computeIfAbsent(upDownCounter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public BatchRecorder put(DoubleUpDownCounter upDownCounter, double value) {\n-    upDownCounter.add(value, labelSet);\n+    recordings.computeIfAbsent(upDownCounter, instrument -> new ArrayList<>()).add(value);\n     return this;\n   }\n \n   @Override\n   public void record() {\n-    // No-op in this minimal implementation.\n+    previousRecordings.clear();\n+\n+    Map<Instrument, List<Number>> temp = recordings;\n+    recordings = previousRecordings;\n+    previousRecordings = temp;\n+\n+    previousRecordings.forEach(\n+        (instrument, numbers) -> {\n+          if (instrument instanceof DoubleUpDownCounter) {", "originalCommit": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc5MzMyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517793320", "bodyText": "another thing I went back and forth on a couple times. I doubt it makes much difference performance-wise, so if you think it's clearer the other way, happy to change it.", "author": "jkwatson", "createdAt": "2020-11-05T04:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4NzgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NDUyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r518294526", "bodyText": "done", "author": "jkwatson", "createdAt": "2020-11-05T19:08:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4NzgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4ODQ1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517788455", "bodyText": "I'm guessing this can be called concurrently - so the maps need to be ConcurrentHashMap and the value something synchronized, probably BlockingQueue.", "author": "anuraaga", "createdAt": "2020-11-05T04:39:59Z", "path": "sdk/metrics/src/main/java/io/opentelemetry/sdk/metrics/BatchRecorderSdk.java", "diffHunk": "@@ -10,61 +10,105 @@\n import io.opentelemetry.api.metrics.DoubleCounter;\n import io.opentelemetry.api.metrics.DoubleUpDownCounter;\n import io.opentelemetry.api.metrics.DoubleValueRecorder;\n+import io.opentelemetry.api.metrics.Instrument;\n import io.opentelemetry.api.metrics.LongCounter;\n import io.opentelemetry.api.metrics.LongUpDownCounter;\n import io.opentelemetry.api.metrics.LongValueRecorder;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n \n /**\n  * Minimal implementation of the {@link BatchRecorder} that simply redirects the calls to the\n  * instruments.\n- *\n- * <p>TODO: Add an async queue processing to process batch records.\n  */\n final class BatchRecorderSdk implements BatchRecorder {\n   private final Labels labelSet;\n \n+  private volatile Map<Instrument, List<Number>> recordings = new HashMap<>();\n+  private volatile Map<Instrument, List<Number>> previousRecordings = new HashMap<>();\n+\n   BatchRecorderSdk(String... keyValuePairs) {\n     this.labelSet = Labels.of(keyValuePairs);\n   }\n \n   @Override\n   public BatchRecorder put(LongValueRecorder valueRecorder, long value) {\n-    valueRecorder.record(value, labelSet);\n+    recordings.computeIfAbsent(valueRecorder, instrument -> new ArrayList<>()).add(value);", "originalCommit": "743ec823e5faae9f20f9deb1f2bbeb286ea3c281", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4OTI2Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517789263", "bodyText": "Though given the primitive types have to be boxed anyways, I think wrapping in our own type would have very low overhead. So instead of two maps, I guess we can use a single queue? Would be easier to reason about.\nprivate static class LongRecording implements Recording {\n  private final Instrument instrument;\n  private final long value;\n}\n\nBlockingQueue<Recoding> recordings;\n\nrecord() {\n  recordings.drainTo(buffer);\n  for (Recording recording : buffer) {\n    ...\n  }", "author": "anuraaga", "createdAt": "2020-11-05T04:43:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4ODQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc5MzM3Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r517793372", "bodyText": "yeah, I went back and forth about this. I'd be happy to change it to something like that. And, yes, you're totally right about the concurrent hashmap bit.", "author": "jkwatson", "createdAt": "2020-11-05T04:59:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4ODQ1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODI5NDMwMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2007#discussion_r518294303", "bodyText": "@anuraaga take a look now.", "author": "jkwatson", "createdAt": "2020-11-05T19:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc4ODQ1NQ=="}], "type": "inlineReview"}, {"oid": "f84bda9aa993a49b7b2035dab8cbade3f729d0f4", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/f84bda9aa993a49b7b2035dab8cbade3f729d0f4", "message": "rework the batch recorder to use a queue of recordings", "committedDate": "2020-11-05T18:56:34Z", "type": "commit"}, {"oid": "24c90576b8c208f22e964660ae0a8fb0af6186cf", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/24c90576b8c208f22e964660ae0a8fb0af6186cf", "message": "remove an allocation per recording by introducing some typed classes", "committedDate": "2020-11-05T19:07:03Z", "type": "commit"}]}