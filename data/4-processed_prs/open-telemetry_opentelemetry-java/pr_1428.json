{"pr_number": 1428, "pr_title": "Makes Export methods async", "pr_createdAt": "2020-07-17T04:35:17Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDI5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456214299", "bodyText": "This felt like an ok dependency to introduce on the exporters given its usage elsewhere. While we don't use Guava in the public signatures of anything, we do use it to build completed futures internally.", "author": "huntc", "createdAt": "2020-07-17T04:40:16Z", "path": "exporters/inmemory/build.gradle", "diffHunk": "@@ -11,6 +11,8 @@ ext.moduleName = \"io.opentelemetry.exporters.inmemory\"\n dependencies {\n     api project(':opentelemetry-sdk')\n \n+    implementation libraries.guava\n+", "originalCommit": "79097e78c0e571b98d089c66bf1b2a8a60e6b976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MDc2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456850760", "bodyText": "definitely for the in-memory exporter, this is 100% fine.", "author": "jkwatson", "createdAt": "2020-07-19T02:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDI5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NTIwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456855200", "bodyText": "It will no longer be required anywhere if I contribute to apply my CompletableExportStatus.", "author": "huntc", "createdAt": "2020-07-19T03:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDQzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456214433", "bodyText": "I don't think Future is very useful in modern Java, since we target Java 7, we should probably have a callback parameter to the method instead.", "author": "anuraaga", "createdAt": "2020-07-17T04:40:52Z", "path": "exporters/inmemory/src/main/java/io/opentelemetry/exporters/inmemory/InMemoryMetricExporter.java", "diffHunk": "@@ -103,12 +105,12 @@ public void reset() {\n    * <p>If this is called after {@code shutdown}, this will return {@code ResultCode.FAILURE}.\n    */\n   @Override\n-  public ResultCode export(Collection<MetricData> metrics) {\n+  public Future<ResultCode> export(Collection<MetricData> metrics) {", "originalCommit": "79097e78c0e571b98d089c66bf1b2a8a60e6b976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNjEyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456216129", "bodyText": "Java 8's CompletableFuture implements Future. Future describes a behaviour that is very much modern Java.", "author": "huntc", "createdAt": "2020-07-17T04:47:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNjg0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456216844", "bodyText": "It implement's Future for legacy apps :) But Future itself only has the possibility of calling .get, which is a blocking method, so it's not quite asynchronous. While we weren't really clear on when this result code would actually even be used, but if the goal is to make this fully asynchronous (no blocking for the result at all) while also returning a result, on Java 7 I think it does need to be a callback, which is similar to calling .then* on CompletableFuture", "author": "anuraaga", "createdAt": "2020-07-17T04:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNzQ5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456217499", "bodyText": "Future is purely an interface that describes a behaviour. I maintain that its usage here is legitimate, particularly given the upgrade path to a CompletableFuture when writing export classes using Java 8+.", "author": "huntc", "createdAt": "2020-07-17T04:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyMDA5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456220094", "bodyText": "Are there other areas of the API that prefer callbacks over what would otherwise be futures? It is important for this PR to be consistent with them of course.", "author": "huntc", "createdAt": "2020-07-17T05:04:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyNzQ3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456227479", "bodyText": "I think this is the first async API.\nIf the goal is to make this a fully async API, Future doesn't really cut it. For example, if an event loop callback needs this result, maybe in a reactive stream, it will have to delegate to an I/O threadpool before calling Future.get. Perhaps this isn't really an expected use case in which case, we always expect .get to called in a synchronous context. If so then Future works fine but we have to be clear that it limits the use cases for the API.", "author": "anuraaga", "createdAt": "2020-07-17T05:33:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIyOTc3MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456229770", "bodyText": "How would you feel about exposing Guava's ListenableFuture here? Back in the day, this was always my go-to before Java 8 came along. And, Guava is already on the list of dependencies.\nAlternatively, OT could introduce its own Future subtype that could host a ListenableFuture and migrate to a CompletableFuture later on if/when the Java 7 dependency can be dropped.\nWDYT?", "author": "huntc", "createdAt": "2020-07-17T05:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzMzE0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456233148", "bodyText": "I like ListenableFuture but exposing Guava in the API might be a bit much - interested in others' thoughts.\nDefinitely, as opposed to a callback parameter, a custom Future subtype would work too. As long as it has something like addListener, similar to Netty's future, would work well in event loops.", "author": "anuraaga", "createdAt": "2020-07-17T05:54:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDQzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY3OTg4MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457679880", "bodyText": "Future is no longer used. Resolving.", "author": "huntc", "createdAt": "2020-07-20T20:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDc0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456214747", "bodyText": "If an exception is thrown with the export or flush methods, it is probably unrecoverable, hence allowing the exception to propagate. These methods should return a failure status for recoverable failures.", "author": "huntc", "createdAt": "2020-07-17T04:42:13Z", "path": "exporters/inmemory/src/test/java/io/opentelemetry/exporters/inmemory/InMemoryMetricExporterTest.java", "diffHunk": "@@ -51,26 +52,26 @@ private static MetricData generateFakeMetric() {\n   }\n \n   @Test\n-  public void test_getFinishedMetricItems() {\n+  public void test_getFinishedMetricItems() throws ExecutionException, InterruptedException {\n     List<MetricData> metrics = new ArrayList<MetricData>();\n     metrics.add(generateFakeMetric());\n     metrics.add(generateFakeMetric());\n     metrics.add(generateFakeMetric());\n \n-    assertThat(exporter.export(metrics)).isEqualTo(ResultCode.SUCCESS);\n+    assertThat(exporter.export(metrics).get()).isEqualTo(ResultCode.SUCCESS);\n     List<MetricData> metricItems = exporter.getFinishedMetricItems();\n     assertThat(metricItems).isNotNull();\n     assertThat(metricItems.size()).isEqualTo(3);\n   }", "originalCommit": "79097e78c0e571b98d089c66bf1b2a8a60e6b976", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNDkzNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456214937", "bodyText": "This logging is consistent with other internal call sites.", "author": "huntc", "createdAt": "2020-07-17T04:43:07Z", "path": "exporters/logging/src/main/java/io/opentelemetry/exporters/logging/LoggingMetricExporter.java", "diffHunk": "@@ -50,12 +53,16 @@ public ResultCode flush() {\n         resultCode = ResultCode.FAILURE;\n       }\n     }\n-    return resultCode;\n+    return Futures.immediateFuture(resultCode);\n   }\n \n   @Override\n   public void shutdown() {\n     // no-op\n-    this.flush();\n+    try {\n+      this.flush().get();\n+    } catch (InterruptedException | ExecutionException e) {\n+      logger.log(Level.WARNING, \"Metric Exporter threw an Exception\", e);\n+    }", "originalCommit": "79097e78c0e571b98d089c66bf1b2a8a60e6b976", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNTI1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456215259", "bodyText": "Note that if any of the existing exporters throw an exception during export or flush then they are in error in accordance with the API. I've therefore assumed that they don't.", "author": "huntc", "createdAt": "2020-07-17T04:44:20Z", "path": "exporters/logging/src/main/java/io/opentelemetry/exporters/logging/LoggingSpanExporter.java", "diffHunk": "@@ -50,11 +53,15 @@ public ResultCode flush() {\n         resultCode = ResultCode.FAILURE;\n       }\n     }\n-    return resultCode;\n+    return Futures.immediateFuture(resultCode);\n   }\n \n   @Override\n   public void shutdown() {\n-    this.flush();\n+    try {\n+      this.flush().get();\n+    } catch (InterruptedException | ExecutionException e) {\n+      logger.log(Level.WARNING, \"Span Exporter threw an Exception\", e);\n+    }\n   }\n }", "originalCommit": "79097e78c0e571b98d089c66bf1b2a8a60e6b976", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MDYyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456850621", "bodyText": "logging is fine here, agreed.", "author": "jkwatson", "createdAt": "2020-07-19T02:42:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIxNTI1OQ=="}], "type": "inlineReview"}, {"oid": "3e662fd85a93fe8e89550f3cd7c6a73ad860edcb", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3e662fd85a93fe8e89550f3cd7c6a73ad860edcb", "message": "Makes Export methods async\n\nThis commit recognises that the export and flush methods of span and trace exporters can be, and often are, implemented with long-lived operations over networks. We therefore see that these method return types are represented using Java's Future type to account for this common behaviour.", "committedDate": "2020-07-17T05:01:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MDU2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456850562", "bodyText": "if we go with this PR, we should definitely create follow-on issues to make the exporter implementations actually do their work async.", "author": "jkwatson", "createdAt": "2020-07-19T02:41:24Z", "path": "exporters/jaeger/src/main/java/io/opentelemetry/exporters/jaeger/JaegerGrpcSpanExporter.java", "diffHunk": "@@ -126,9 +128,9 @@ public ResultCode export(Collection<SpanData> spans) {\n       // for now, there's nothing to check in the response object\n       //noinspection ResultOfMethodCallIgnored\n       stub.postSpans(request);\n-      return ResultCode.SUCCESS;\n+      return Futures.immediateFuture(ResultCode.SUCCESS);", "originalCommit": "8461ffc282b1804dba851707030f291ceaf2821f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MDY5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456850694", "bodyText": "this is another point at which we should probably have a follow-on issue, so we don't lose track of the fact that we're making something sync that could be async.", "author": "jkwatson", "createdAt": "2020-07-19T02:43:34Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -285,9 +285,9 @@ private void onBatchExport(final List<SpanData> spans) {\n                 public void run() {\n                   // In case of any exception thrown by the service handlers catch and log.\n                   try {\n-                    spanExporter.export(spans);\n-                  } catch (Throwable t) {\n-                    logger.log(Level.WARNING, \"Exception thrown by the export.\", t);\n+                    spanExporter.export(spans).get();", "originalCommit": "8461ffc282b1804dba851707030f291ceaf2821f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4OTIzNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456989235", "bodyText": "I will be applying the CompletableMetricStatus here too.", "author": "huntc", "createdAt": "2020-07-20T01:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MDczNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456850735", "bodyText": "ditto on needing an issue for this one as well.", "author": "jkwatson", "createdAt": "2020-07-19T02:44:08Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/export/SimpleSpanProcessor.java", "diffHunk": "@@ -77,8 +78,8 @@ public void onEnd(ReadableSpan span) {\n     }\n     try {\n       List<SpanData> spans = Collections.singletonList(span.toSpanData());\n-      spanExporter.export(spans);\n-    } catch (Throwable e) {\n+      spanExporter.export(spans).get();", "originalCommit": "8461ffc282b1804dba851707030f291ceaf2821f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4OTI5Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456989292", "bodyText": "This will go away", "author": "huntc", "createdAt": "2020-07-20T01:54:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MDczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456851485", "bodyText": "I'm not super happy with having a public method be synchronized. There is an unintended consequence to this that if someone externally uses an instance of this class to synchronize on, it will lock this from ever executing.\nThe combination of volatile and public synchronized methods makes me a bit queasy. Can we use some more modern concurrency primitives, like Atomics to make this a little less prone to accidental (or intentional) abuse?\nAt the very least, if we do need to have old-school synchronization in here, we should synchronize on a private final field that is not accessible outside the class.", "author": "jkwatson", "createdAt": "2020-07-19T02:55:59Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.concurrent.Executor;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  public CompletableResultCode() {}\n+\n+  private volatile boolean succeeded = false;\n+  private boolean completed = false;\n+  private Runnable action = null;\n+  private Executor actionExecutor = null;\n+\n+  /** The export operation finished successfully. */\n+  public synchronized void success() {", "originalCommit": "8461ffc282b1804dba851707030f291ceaf2821f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MzYyMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456853621", "bodyText": "Agree that we can probably use atomic and cas to avoid synchronization. We're not an asynchronous framework or anything, this is just our export API so we wouldn't expect significant overhead due to extra objects from the atomics", "author": "anuraaga", "createdAt": "2020-07-19T03:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MzkzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456853933", "bodyText": "I realized my comment about list of runnables may make it impractical to avoid a lock.", "author": "anuraaga", "createdAt": "2020-07-19T03:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NTU1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456855555", "bodyText": "I can replace the use of synchronised with an internal lock. It isn\u2019t possible to use atomics for each field as we require them to be all synchronised simultaneously.", "author": "huntc", "createdAt": "2020-07-19T03:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NTc4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456855788", "bodyText": "Also, please avoid wording like \u201cqueasy\u201d when providing feedback. The use of volatile where I have it is perfectly reasonable. Please be clearer as to why an approach is unsuitable.", "author": "huntc", "createdAt": "2020-07-19T04:00:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg2MzgxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456863811", "bodyText": "Sorry.. I was just trying to express that what is implemented here has a mix of different concurrency paradigms in it. When I see that, it is a \"code smell\". And \"code smells\" make me uncomfortable. When I read this code, I have a hard time understanding why it is written the way it is, and that's a problem.", "author": "jkwatson", "createdAt": "2020-07-19T05:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4OTY2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456989660", "bodyText": "In essence, using volatile on a boolean is more efficient than using an AtomicBoolean. A reason to use AtomicBoolean would be to use its CAS operations, which are not required.", "author": "huntc", "createdAt": "2020-07-20T01:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzAwMDkwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457000906", "bodyText": "Could we just replace both fields with a single AtomicReference holding the return code itself? Then you could CAS to set it?", "author": "jkwatson", "createdAt": "2020-07-20T02:49:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA4ODY3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457088678", "bodyText": "Could we just replace both fields with a single AtomicReference holding the return code itself? Then you could CAS to set it?\n\nThey'd be three fields... We could use a CAS on a state object, but I've now pushed some code that uses a reentrant lock. See what you think of that... my code is quite focused on reducing object allocations.", "author": "huntc", "createdAt": "2020-07-20T06:19:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ3MDQxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457470415", "bodyText": "So, as far as I understand this class (and maybe I'm misunderstanding), there are 3 states. 1) incomplete, 2) complete with failure, 3) complete with success. This can be modeled with one AtomicReference that holds the success/failure. AtomicReference is unset: incomplete, AtomicReference is set to failure: complete with failure, AtomicReference is set to success: complete with success.\nAm I missing something?", "author": "jkwatson", "createdAt": "2020-07-20T15:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY4MjYwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457682606", "bodyText": "We need to lock both the completion state and the callback list (actions) at the same time. Not doing so could lead to a race condition where action is added but not executed immediately because the completion has subsequently occurred. You would, therefore, end up with an action never being called.", "author": "huntc", "createdAt": "2020-07-20T20:48:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY4ODc5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457688793", "bodyText": "Sure, but even if you need the explicit locking to manage the actions, you can still store the complete state in one nullable field, whether you store it in an AtomicReference or not. Currently, you're using two fields, updates to which need to be coordinated, which is inherently more complex that just managing one field with the result in it.", "author": "jkwatson", "createdAt": "2020-07-20T21:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzY5NTg0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457695843", "bodyText": "Ah, good point. I have now pushed the change.", "author": "huntc", "createdAt": "2020-07-20T21:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MTQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MzUxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456853518", "bodyText": "We may as well make this generic", "author": "anuraaga", "createdAt": "2020-07-19T03:27:15Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.concurrent.Executor;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {", "originalCommit": "8461ffc282b1804dba851707030f291ceaf2821f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NTkwNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456855904", "bodyText": "This will add a lot of complexity, which I don\u2019t think is warranted. Ultimately migrating to a CompleteableFuture approach for all async use cases would be best.\nI\u2019m not attempting to solve all Open Telemetry async use cases, and I want to ensure that the approach taken here remains reasonable in scope.", "author": "huntc", "createdAt": "2020-07-19T04:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1MzUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1Mzg2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456853866", "bodyText": "If we only support one callback anyways I would definitely prefer just using the callback pattern. How about we just go ahead and maintain a list of runnables here?", "author": "anuraaga", "createdAt": "2020-07-19T03:32:00Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.concurrent.Executor;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  public CompletableResultCode() {}\n+\n+  private volatile boolean succeeded = false;\n+  private boolean completed = false;\n+  private Runnable action = null;\n+  private Executor actionExecutor = null;\n+\n+  /** The export operation finished successfully. */\n+  public synchronized void success() {\n+    if (!completed) {\n+      if (!succeeded) {\n+        succeeded = true;\n+      }\n+      if (action != null) {\n+        actionExecutor.execute(action);\n+      }\n+      completed = true;\n+    }\n+  }\n+\n+  /** The export operation finished with an error. */\n+  public synchronized void failure() {\n+    if (!completed) {\n+      if (action != null) {\n+        actionExecutor.execute(action);\n+      }\n+      completed = true;\n+    }\n+  }\n+\n+  /**\n+   * Obtain the current state of completion. Generally call once completion is achieved via the\n+   * thenRun method.\n+   *\n+   * @return the current state of completion\n+   */\n+  public boolean isSuccess() {\n+    return succeeded;\n+  }\n+\n+  /**\n+   * Perform an action on completion. Actions are guaranteed to be called only once.\n+   *\n+   * <p>There should only be one action for this class instance.", "originalCommit": "8461ffc282b1804dba851707030f291ceaf2821f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1NjA2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456856069", "bodyText": "I\u2019d prefer to avoid what would be additional complexity, but composing multiple andThenAsync methods would be the idiomatic thing to do.", "author": "huntc", "createdAt": "2020-07-19T04:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1Mzg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1OTAyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456859028", "bodyText": "I think we're sort of not past the cliff in terms of complexity. For comparison, the callback pattern is just defining an interface, so it's about as close to no-complexity as changes can get. Here we've added a lot of complexity, having to worry about synchronization to boot, but it seems the only additional feature is a custom executor, which is arguably not that important (our goal was to make the API usable from an async context). So unless we go a bit further, I don't see any reason to take this approach over a normal callback.\nThinking again (thanks for bringing up the point about complexity, I was forgetting it :) ), if we can only imagine a use case where there is a single callback that does something very simple like do a log statement, update a metric, then I'd still lean towards the callback pattern (but I'm still ok with the listenable Completable as well if others prefer it).\nIt does bring to mind another idea, what about dropping the result code completely? Just a single code seems quite limiting anyways, instead registering a listener on the exporter itself (not on export calls) seems like it could cover all expected use cases, possibly in a more controlled fashion? For example, Zipkin's reporter metrics callback could work well if registered directly on the Exporter, and allows consistency in handling success, failure, etc across all exporters.\nhttps://github.com/openzipkin/zipkin-reporter-java/blob/master/core/src/main/java/zipkin2/reporter/ReporterMetrics.java#L44", "author": "anuraaga", "createdAt": "2020-07-19T04:46:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1Mzg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5MDUyNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r456990526", "bodyText": "I see a completable status as being useful in that the SDK should provide telemetry on a best-effort basis. If a previous export has not yet finished, then we should look at dropping the metrics.\nI've now also incorporated the means of having multiple actions. It turned out to be straightforward, and it was needed.", "author": "huntc", "createdAt": "2020-07-20T01:59:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njg1Mzg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA5NDQxMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457094413", "bodyText": "This TODO has been actioned.", "author": "huntc", "createdAt": "2020-07-20T06:30:08Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/metrics/export/MetricExporter.java", "diffHunk": "@@ -29,36 +30,22 @@\n  */\n public interface MetricExporter {\n \n-  /**\n-   * The possible results for the export method.\n-   *\n-   * @since 0.1.0\n-   */\n-  // TODO: extract this enum and unify it with SpanExporter.ResultCode", "originalCommit": "db478fd31bd06f702978aee22d797c69caef8220", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA5NTY5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457095695", "bodyText": "A bit of a change here is that there's no longer a timeout on export. Given that export is potentially async, we can't reliably cancel. Also, an exporter's contract is to always complete a CompletableResultCode - it is a promise that must be fulfilled.", "author": "huntc", "createdAt": "2020-07-20T06:32:26Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -96,15 +90,8 @@ private BatchSpanProcessor(\n       boolean sampled,\n       long scheduleDelayMillis,\n       int maxQueueSize,\n-      int maxExportBatchSize,\n-      int exporterTimeoutMillis) {\n-    this.worker =\n-        new Worker(\n-            spanExporter,\n-            scheduleDelayMillis,\n-            maxQueueSize,\n-            maxExportBatchSize,\n-            exporterTimeoutMillis);", "originalCommit": "db478fd31bd06f702978aee22d797c69caef8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA5NjY5NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457096695", "bodyText": "Also, we don't need to hand tasks off to a worker thread if the exporters are async. They will have their own thread pools. It is important to keep the number of threads used to a minimum. One thread for metrics and another for spans should be all that is required in total.", "author": "huntc", "createdAt": "2020-07-20T06:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA5NTY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjQ4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457806483", "bodyText": "Would recommend keeping the constants private and having factory methods ofSuccess() ofFailure() it seems to be more idiomatic now adays", "author": "anuraaga", "createdAt": "2020-07-21T02:57:24Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  /** A convenience for declaring success */\n+  public static final CompletableResultCode SUCCESS = new CompletableResultCode().success();", "originalCommit": "567548b0c7c00559fa2c0fbae9f2584cb440532b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyMDY1Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457820652", "bodyText": "Done. Changes pushed.", "author": "huntc", "createdAt": "2020-07-21T03:54:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNzI0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457807248", "bodyText": "Since we have an object for this lock now, is there any need for it to be a ReentrantLock as opposed to an Object which we use synchronized on? IIRC, the latter is a bit faster with a bit less syntax (though maybe not in Java 15 where they're finally removing biased locking)", "author": "anuraaga", "createdAt": "2020-07-21T03:00:41Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  /** A convenience for declaring success */\n+  public static final CompletableResultCode SUCCESS = new CompletableResultCode().success();\n+\n+  /** A convenience for declaring failure */\n+  public static final CompletableResultCode FAILURE = new CompletableResultCode().failure();\n+\n+  public CompletableResultCode() {}\n+\n+  private volatile Boolean succeeded = null;\n+  private final ArrayList<Runnable> actions = new ArrayList<>();\n+  private final Lock state = new ReentrantLock();", "originalCommit": "567548b0c7c00559fa2c0fbae9f2584cb440532b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgxNTk3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457815976", "bodyText": "What happens when the object is null?\nAlso, do you have a ref re. synchronized outperforming ReentrantLock. I'd imagine that the former is implemented using the latter via pthreads, at least on Posix platforms.", "author": "huntc", "createdAt": "2020-07-21T03:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNzI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgxODA3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457818071", "bodyText": "It wouldn't ever be null since you'd declare private final Object lock = new Object(). We use the pattern in the span itself too, as do many JDK classes, so it'd be a bit more consistent too.\nhttps://github.com/open-telemetry/opentelemetry-java/blob/master/sdk/src/main/java/io/opentelemetry/sdk/trace/RecordEventsReadableSpan.java#L73\nNot sure about all platforms, but on the main ones Java doesn't use OS for locks, it's all in the JVM using CAS, including crazy stuff that only applies for synchronized AFAIK (though it's going away)\nhttps://wiki.openjdk.java.net/display/HotSpot/Synchronization\nHere I'd err on consistency with the span and a couple lines of code less if there's no specific need for the ReentrantLock.", "author": "anuraaga", "createdAt": "2020-07-21T03:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNzI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyMTEzMw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457821133", "bodyText": "Sorry, I misunderstood which object you were referring to.\nWe actually do need the ReentrantLock in case an andThen action calls upon other parts of the API, right?", "author": "huntc", "createdAt": "2020-07-21T03:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNzI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyMjgyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457822828", "bodyText": "Actually, your suggestion appears to support reentrancy also (I didn't know! https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html). I shall change to be consistent with other parts of the code.", "author": "huntc", "createdAt": "2020-07-21T04:03:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNzI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNTA1OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457825059", "bodyText": "Changes pushed", "author": "huntc", "createdAt": "2020-07-21T04:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNzI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwODM5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457808397", "bodyText": "Do we need this copy? With succeeded always accessed in the lock seems ok without it", "author": "anuraaga", "createdAt": "2020-07-21T03:05:34Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  /** A convenience for declaring success */\n+  public static final CompletableResultCode SUCCESS = new CompletableResultCode().success();\n+\n+  /** A convenience for declaring failure */\n+  public static final CompletableResultCode FAILURE = new CompletableResultCode().failure();\n+\n+  public CompletableResultCode() {}\n+\n+  private volatile Boolean succeeded = null;\n+  private final ArrayList<Runnable> actions = new ArrayList<>();\n+  private final Lock state = new ReentrantLock();\n+\n+  /** The export operation finished successfully. */\n+  public CompletableResultCode success() {\n+    List<Runnable> actionsToRun = new ArrayList<>();\n+    state.lock();\n+    try {\n+      if (succeeded == null) {\n+        succeeded = true;\n+        actionsToRun.addAll(actions);", "originalCommit": "567548b0c7c00559fa2c0fbae9f2584cb440532b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgxNzIyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457817225", "bodyText": "Its paranoia on my part. By copying, we can avoid a deadlock on having this object's API called from within an action handler. Although... we're using a ReentrantLock so we can already avoid that situation! I shall remove the copying.", "author": "huntc", "createdAt": "2020-07-21T03:40:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwODM5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgxODM1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457818350", "bodyText": "Pushed changes", "author": "huntc", "createdAt": "2020-07-21T03:45:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwODM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwODYzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457808634", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (succeeded != null && succeeded) {\n          \n          \n            \n                  if (succeeded != null) {", "author": "anuraaga", "createdAt": "2020-07-21T03:06:35Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  /** A convenience for declaring success */\n+  public static final CompletableResultCode SUCCESS = new CompletableResultCode().success();\n+\n+  /** A convenience for declaring failure */\n+  public static final CompletableResultCode FAILURE = new CompletableResultCode().failure();\n+\n+  public CompletableResultCode() {}\n+\n+  private volatile Boolean succeeded = null;\n+  private final ArrayList<Runnable> actions = new ArrayList<>();\n+  private final Lock state = new ReentrantLock();\n+\n+  /** The export operation finished successfully. */\n+  public CompletableResultCode success() {\n+    List<Runnable> actionsToRun = new ArrayList<>();\n+    state.lock();\n+    try {\n+      if (succeeded == null) {\n+        succeeded = true;\n+        actionsToRun.addAll(actions);\n+      }\n+    } finally {\n+      state.unlock();\n+    }\n+    for (Runnable action : actionsToRun) {\n+      action.run();\n+    }\n+    return this;\n+  }\n+\n+  /** The export operation finished with an error. */\n+  public CompletableResultCode failure() {\n+    List<Runnable> actionsToRun = new ArrayList<>();\n+    state.lock();\n+    try {\n+      if (succeeded == null) {\n+        succeeded = false;\n+        actionsToRun.addAll(actions);\n+      }\n+    } finally {\n+      state.unlock();\n+    }\n+    for (Runnable action : actionsToRun) {\n+      action.run();\n+    }\n+    return this;\n+  }\n+\n+  /**\n+   * Obtain the current state of completion. Generally call once completion is achieved via the\n+   * thenRun method.\n+   *\n+   * @return the current state of completion\n+   */\n+  public boolean isSuccess() {\n+    return succeeded != null && succeeded;\n+  }\n+\n+  /**\n+   * Perform an action on completion. Actions are guaranteed to be called only once.\n+   *\n+   * <p>There should only be one action for this class instance.\n+   *\n+   * @param action the action to perform\n+   * @return this completable result so that it may be further composed\n+   */\n+  public CompletableResultCode thenRun(Runnable action) {\n+    boolean runActionImmediately = false;\n+    state.lock();\n+    try {\n+      if (succeeded != null && succeeded) {", "originalCommit": "567548b0c7c00559fa2c0fbae9f2584cb440532b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNTcwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457825707", "bodyText": "Whoops. Thanks. Changed", "author": "huntc", "createdAt": "2020-07-21T04:15:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwODYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwOTE5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457809197", "bodyText": "IIUC this changes the behavior to export essentially being \"scheduleAtFixedRate\" instead of the current \"scheduleAtFixedDelay\" since this always returns immediately now. I don't know if this is the intention of this class. Also given a significant refactor in #1395 which will make this class much easier to reason about, maybe we can keep the behavior unchanged for now?", "author": "anuraaga", "createdAt": "2020-07-21T03:08:57Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -277,28 +258,26 @@ private void exportBatches(ArrayList<ReadableSpan> spanList) {\n     }\n \n     // Exports the list of SpanData to the SpanExporter.\n+    @SuppressWarnings(\"BooleanParameter\")\n     private void onBatchExport(final List<SpanData> spans) {\n-      Future<?> submission =\n-          executorService.submit(\n+      if (exportAvailable.compareAndSet(true, false)) {", "originalCommit": "567548b0c7c00559fa2c0fbae9f2584cb440532b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyMjAzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457822032", "bodyText": "I think we still need the changes here. Contractually, we should guarantee that an export function is not called if it has a request in-flight. It isn't yet clear to me how the proposed changes of #1395 would help.", "author": "huntc", "createdAt": "2020-07-21T03:59:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwOTE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYyNDcyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r473624720", "bodyText": "Unfortunately, this change from \"scheduleAtFixedDelay\" to \"scheduleAtFixedRate\" results in dropped spans. onBatchExport can be called in a loop from exportBatches method. As this method now returns immediately, calling it in a tight loop guarantees data loss.", "author": "iNikem", "createdAt": "2020-08-20T05:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwOTE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzc0MDYyNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r473740624", "bodyText": "Unfortunately, this change from \"scheduleAtFixedDelay\" to \"scheduleAtFixedRate\" results in dropped spans. onBatchExport can be called in a loop from exportBatches method. As this method now returns immediately, calling it in a tight loop guarantees data loss.\n\nI think you're right - for situations where the spansList cannot be drained fast enough. I shall attend to this. Meanwhile, here's a new ticket: #1566 to capture the problem. It isn't a terrible situation as BatchSpanProcessor usage has always dictated that spans can be dropped. However, we can do better.", "author": "huntc", "createdAt": "2020-08-20T08:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwOTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNjk4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457826984", "bodyText": "Thanks last nit, these methods looks weird at the call sites since they're not verbs. Something like\nsucceed / fail\ncomplete / completeExceptionally\n?", "author": "anuraaga", "createdAt": "2020-07-21T04:20:23Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.ArrayList;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  /** A convenience for declaring success */\n+  public static CompletableResultCode ofSuccess() {\n+    return SUCCESS;\n+  }\n+\n+  /** A convenience for declaring failure */\n+  public static CompletableResultCode ofFailure() {\n+    return FAILURE;\n+  }\n+\n+  private static final CompletableResultCode SUCCESS = new CompletableResultCode().success();\n+  private static final CompletableResultCode FAILURE = new CompletableResultCode().failure();\n+\n+  public CompletableResultCode() {}\n+\n+  @GuardedBy(\"lock\")\n+  private Boolean succeeded = null;\n+\n+  @GuardedBy(\"lock\")\n+  private final ArrayList<Runnable> actions = new ArrayList<>();\n+\n+  private final Object lock = new Object();\n+\n+  /** The export operation finished successfully. */\n+  public CompletableResultCode success() {", "originalCommit": "ce97d50ca92bb2838126d272ead96e77d382cba0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNzkyMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457827922", "bodyText": "succeed/fail ok? They are both completions, and we're not completing with an exception...", "author": "huntc", "createdAt": "2020-07-21T04:24:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNjk4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyODA2Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r457828066", "bodyText": "Yes, we need unit tests... I'll put a TODO section in the summary and convert this to a draft PR.", "author": "huntc", "createdAt": "2020-07-21T04:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNjk4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODM0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464018343", "bodyText": "this makes me think that we probably should think about adding an Exception/Throwable to the CompletableResultCode, but that isn't necessary for this PR.", "author": "jkwatson", "createdAt": "2020-08-02T01:32:28Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/export/BatchSpanProcessor.java", "diffHunk": "@@ -277,28 +258,26 @@ private void exportBatches(ArrayList<ReadableSpan> spanList) {\n     }\n \n     // Exports the list of SpanData to the SpanExporter.\n+    @SuppressWarnings(\"BooleanParameter\")\n     private void onBatchExport(final List<SpanData> spans) {\n-      Future<?> submission =\n-          executorService.submit(\n+      if (exportAvailable.compareAndSet(true, false)) {\n+        try {\n+          final CompletableResultCode result = spanExporter.export(spans);\n+          result.thenRun(\n               new Runnable() {\n                 @Override\n                 public void run() {\n-                  // In case of any exception thrown by the service handlers catch and log.\n-                  try {\n-                    spanExporter.export(spans);\n-                  } catch (Throwable t) {\n-                    logger.log(Level.WARNING, \"Exception thrown by the export.\", t);\n+                  if (!result.isSuccess()) {\n+                    logger.log(Level.FINE, \"Exporter failed\");", "originalCommit": "b6deaad5a33e748eab694382a57da7764c3ade1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzODU2Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464038567", "bodyText": "The contract is for an exporter to either succeed or fail as per the result code. In the case of failure, it could be worth indicating why, with an optional throwable as a parameter. I'd say that it is up to the export class itself to determine what should constitute being worthy of logging here though, as failure may well be \"normal\" and I don't think we want to pollute the logs.", "author": "huntc", "createdAt": "2020-08-02T06:31:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODM0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODQzNA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464018434", "bodyText": "is anything waiting on this latch?", "author": "jkwatson", "createdAt": "2020-08-02T01:34:12Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/export/MultiSpanExporter.java", "diffHunk": "@@ -67,18 +68,19 @@ public ResultCode export(Collection<SpanData> spans) {\n    * @return the result of the operation\n    */\n   @Override\n-  public ResultCode flush() {\n-    ResultCode currentResultCode = SUCCESS;\n+  public CompletableResultCode flush() {\n+    final CompletableResultCode compositeResultCode = new CompletableResultCode();\n+    final CountDownLatch completionsToProcess = new CountDownLatch(spanExporters.length);", "originalCommit": "b6deaad5a33e748eab694382a57da7764c3ade1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzODE4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464038185", "bodyText": "No - nothing needs to wait - See https://github.com/open-telemetry/opentelemetry-java/pull/1428/files#diff-99eb9ce2c0a6fa65d07ccbbee42ba836R107 - when the latch reaches zero, given that there's been a success for the entire composition of result codes, we then succeed the composite.", "author": "huntc", "createdAt": "2020-08-02T06:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTI0MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464151240", "bodyText": "If not waiting on it, may as well use AtomicInteger to clarify that it's just for counting.", "author": "anuraaga", "createdAt": "2020-08-03T01:22:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAxODQzNA=="}], "type": "inlineReview"}, {"oid": "34dae0f7f27d56c9fa43ef9e7bd3ca819e662767", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/34dae0f7f27d56c9fa43ef9e7bd3ca819e662767", "message": "Makes Export methods async\n\nThis commit recognises that the export and flush methods of span and trace exporters can be, and often are, implemented with long-lived operations over networks. We therefore see that these method return types are represented using Java's Future type to account for this common behaviour.", "committedDate": "2020-08-02T06:19:27Z", "type": "forcePushed"}, {"oid": "d3e3d8d0cab3ad409b156bdb0a63a142d44aee18", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d3e3d8d0cab3ad409b156bdb0a63a142d44aee18", "message": "Makes Export methods async\n\nThis commit recognises that the export and flush methods of span and trace exporters can be, and often are, implemented with long-lived operations over networks. We therefore see that these method return types are represented using Java's Future type to account for this common behaviour.", "committedDate": "2020-08-02T07:06:22Z", "type": "forcePushed"}, {"oid": "b7cfcab79e4cad7dbc7edf2269e0355a506d39f8", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b7cfcab79e4cad7dbc7edf2269e0355a506d39f8", "message": "Re-instated batch span processor cancellation\n\nCancellation now provides the exporter with the opportunity to handle it. An exporter could, for example, cancel activity in flight in the way it knows how.", "committedDate": "2020-08-03T00:09:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MDg5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464150890", "bodyText": "@carlosalberto We will need to change this from MetricsServiceBlockingStub to MetricsServiceFutureStub to see the main result of this PR, making at least the gRPC exporters truly async. I'm ok with that being in a followup but do you want to see it now?\n@huntc I guess it's not a huge code change so maybe can knock it out.", "author": "anuraaga", "createdAt": "2020-08-03T01:20:55Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcMetricExporter.java", "diffHunk": "@@ -89,7 +90,7 @@ private OtlpGrpcMetricExporter(ManagedChannel channel, long deadlineMs) {\n    * @return the result of the operation\n    */\n   @Override\n-  public ResultCode export(Collection<MetricData> metrics) {\n+  public CompletableResultCode export(Collection<MetricData> metrics) {", "originalCommit": "b7cfcab79e4cad7dbc7edf2269e0355a506d39f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1NDYwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464154605", "bodyText": "That'd be great @anuraaga - could you make a PR on my branch?", "author": "huntc", "createdAt": "2020-08-03T01:41:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MDg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1NzA3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464157074", "bodyText": "@huntc Sure sent huntc#1", "author": "anuraaga", "createdAt": "2020-08-03T01:54:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MDg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE2MDUzMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464160531", "bodyText": "Merged - thanks @anuraaga. @carlosalberto You've now got a fully async exporter.", "author": "huntc", "createdAt": "2020-08-03T02:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MDg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464151587", "bodyText": "For SimpleSpanProcessor I think I'd expect it to be simple and just call export in all cases (if there is a backup in the exporter, that is a reason to use a more complicated span processor like batch span processor).", "author": "anuraaga", "createdAt": "2020-08-03T01:24:57Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/export/SimpleSpanProcessor.java", "diffHunk": "@@ -71,15 +74,30 @@ public boolean isStartRequired() {\n   }\n \n   @Override\n+  @SuppressWarnings(\"BooleanParameter\")\n   public void onEnd(ReadableSpan span) {\n-    if (sampled && !span.getSpanContext().getTraceFlags().isSampled()) {\n-      return;\n-    }\n-    try {\n-      List<SpanData> spans = Collections.singletonList(span.toSpanData());\n-      spanExporter.export(spans);\n-    } catch (Throwable e) {\n-      logger.log(Level.WARNING, \"Exception thrown by the export.\", e);\n+    if (exportAvailable.compareAndSet(true, false)) {", "originalCommit": "b7cfcab79e4cad7dbc7edf2269e0355a506d39f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE2MDI3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464160271", "bodyText": "That would then require exporters to become re-entrant. My assumption at present, as per the existing blocking API, is that only one export is called at a time (which is probably something we should document - it can simplify the authoring of exporters greatly - wdyt?).", "author": "huntc", "createdAt": "2020-08-03T02:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3ODIwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464178200", "bodyText": "I'm not sure what you mean by \"re-entrant\" here. Do you just mean having more than one export running at a time, or are you actuallyreferring to sending the same spans more than once and having the exporter be able to handle de-duping them?", "author": "jkwatson", "createdAt": "2020-08-03T03:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3ODUzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464178536", "bodyText": "Meanwhile, I've added some API docs to clearly state the position on re-entrancy.", "author": "huntc", "createdAt": "2020-08-03T03:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3OTAxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464179010", "bodyText": "I'm not sure what you mean by \"re-entrant\" here. Do you just mean having more than one export running at a time, or are you actuallyreferring to sending the same spans more than once and having the exporter be able to handle de-duping them?\n\nI was referring to the number of export or flush calls in flight at one time, which is what this code is associated with. We only want one of each of these calls in flight. In fact, we shouldn't really call export and flush at the same time either. Keeps the programming model simpler for exporters.", "author": "huntc", "createdAt": "2020-08-03T03:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE3OTMxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464179315", "bodyText": "BTW I'm not seeing that the SDK ever calls on flush. I'm now wondering about its utility. :-)", "author": "huntc", "createdAt": "2020-08-03T03:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4MDg5NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464180894", "bodyText": "The idea with flush wasn't for the SDK itself to call it, but for (for example), a lambda to be able to call flush explicitly, so that spans wouldn't be left in a queue, unsent, when the lambda shuts down.", "author": "jkwatson", "createdAt": "2020-08-03T03:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4MTYwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464181602", "bodyText": "Thanks for the clarification. Should we be marking it as protected then, to clarify the intent?", "author": "huntc", "createdAt": "2020-08-03T03:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4MTk3OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464181979", "bodyText": "We only want one of each of these calls in flight.\n\nI dunno about this - since an exporter is a function that takes spans and pushes them to a sink, I'd be surprised that it would generally matter whether there is one or more in flight. An exporter that depended on being called only once sounds like it's more complicated than it should be. I think right now, if SimpleSpanProcessor is used and two spans are ended at the same time, maybe as a result of being parallel client RPCs, one of them is guaranteed to be dropped right? I don't think that's the intention of the SimpleSpanProcessor.", "author": "anuraaga", "createdAt": "2020-08-03T03:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4MjczOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464182738", "bodyText": "Ah - very good point. I'll document them as being re-entrable.", "author": "huntc", "createdAt": "2020-08-03T04:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4MzIyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464183220", "bodyText": "Should we be marking it as protected then, to clarify the intent?\n\nBy lambda, I think @jkwatson meant AWS Lambda, not Java lambda, or other Google Cloud Functions type of serverless environment where background threads get suspended as soon as a response is returned. So flush needs to stay public to be called from the app.", "author": "anuraaga", "createdAt": "2020-08-03T04:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE4NDEzMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464184130", "bodyText": "Got it. Thanks.", "author": "huntc", "createdAt": "2020-08-03T04:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5MTQ5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464191491", "bodyText": "I've just made another commit that now clarifies that an export or flush can be called simultaneously. This thinking has really cleared up the code as I was also able to remove the barrier that enforced one export at a time. All tests appear to be working locally for me now.", "author": "huntc", "createdAt": "2020-08-03T04:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5NjUxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464196511", "bodyText": "@anuraaga I'm worried that the OtlpGrpc and other exporters have no appearance of backpressure in place. I'm presuming that when there's a problem trying to connect, many requests will pile up (this could happen prior to this PR).\nThe exporters should generally handle CompletableResultCode.whenCompleted, test for failure and then do what is necessary to cancel any in-flight request. That would at least mitigate some requests piling up.\nAdditionally, an exporter might decide to avoid another export if there's one in-flight and also buffer a small amount.\nWith Akka-streams, writing an exporter is quite straightforward. I'd create a bounded queue and drop new elements given any back-pressure. This can mostly be achieved with a Source.queue call. We don't have Akka-streams here though. :-)\nAny thoughts on this?", "author": "huntc", "createdAt": "2020-08-03T05:07:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE5NzU0Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464197547", "bodyText": "I think this sort of backpressure is handled by the batch processor which drops when the queue is full.\nThe simplespanprocessor doesn't but it's why we recommend batch for most apps, simple is more specialized that requires some thought to use.\nThis seems ok to me but what do you think?", "author": "anuraaga", "createdAt": "2020-08-03T05:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwMDM0Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464200346", "bodyText": "I think we should document SimpleSpanProcessor with a cautionary note. I shall do this now.", "author": "huntc", "createdAt": "2020-08-03T05:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwMDY4OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464200688", "bodyText": "Having said that, the IntervalMetricReader has no such back-pressure mechanism, and never did.", "author": "huntc", "createdAt": "2020-08-03T05:27:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwOTk0NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464209944", "bodyText": "So, should I re-instate the ability to only call export one at a time for the IntervalMetricReader and BatchSpanProcessor, and have them drop any new telemetry in the case where an export is in-flight? We can leave the SimpleSpanProcessor as-is though i.e. without the \"in-flight\" check. The SimpleSpanProcessor will be perfect for those more sophisticated exporters, such as what can be written with Akka-streams.", "author": "huntc", "createdAt": "2020-08-03T06:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI0NzYxNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464247615", "bodyText": "This SGTM", "author": "anuraaga", "createdAt": "2020-08-03T07:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDI2NDcyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464264725", "bodyText": "I've now pushed a commit with updated documentation for the exporters, and the reinstatement of backpressure handling for the IntervalMetricReader and BatchSpanProcessor.\nBTW Is there an equivalent of SimpleSpanProcessor for metrics?", "author": "huntc", "createdAt": "2020-08-03T08:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDQ3ODgwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r464478800", "bodyText": "Metrics have a somewhat different pipeline structure. The closest equivalent is probably the IntervalMetricReader class for push-based exporters. Pull-based, of course, manage all of that themselves.", "author": "jkwatson", "createdAt": "2020-08-03T15:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDE1MTU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NTg3NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r465145874", "bodyText": "This does make me think we should consider adding an optional Throwable/message to the fail() method.", "author": "jkwatson", "createdAt": "2020-08-04T15:41:13Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporters/otlp/OtlpGrpcMetricExporter.java", "diffHunk": "@@ -89,26 +97,29 @@ private OtlpGrpcMetricExporter(ManagedChannel channel, long deadlineMs) {\n    * @return the result of the operation\n    */\n   @Override\n-  public ResultCode export(Collection<MetricData> metrics) {\n+  public CompletableResultCode export(Collection<MetricData> metrics) {\n     ExportMetricsServiceRequest exportMetricsServiceRequest =\n         ExportMetricsServiceRequest.newBuilder()\n             .addAllResourceMetrics(MetricAdapter.toProtoResourceMetrics(metrics))\n             .build();\n \n-    try {\n-      MetricsServiceGrpc.MetricsServiceBlockingStub stub = this.blockingStub;\n-      if (deadlineMs > 0) {\n-        stub = stub.withDeadlineAfter(deadlineMs, TimeUnit.MILLISECONDS);\n-      }\n+    final CompletableResultCode result = new CompletableResultCode();\n+    Futures.addCallback(\n+        metricsService.export(exportMetricsServiceRequest),\n+        new FutureCallback<ExportMetricsServiceResponse>() {\n+          @Override\n+          public void onSuccess(@Nullable ExportMetricsServiceResponse response) {\n+            result.succeed();\n+          }\n \n-      // for now, there's nothing to check in the response object\n-      // noinspection ResultOfMethodCallIgnored\n-      stub.export(exportMetricsServiceRequest);\n-      return ResultCode.SUCCESS;\n-    } catch (Throwable e) {\n-      logger.log(Level.WARNING, \"Failed to export metrics\", e);\n-      return ResultCode.FAILURE;\n-    }\n+          @Override\n+          public void onFailure(Throwable t) {\n+            logger.log(Level.WARNING, \"Failed to export spans\", t);\n+            result.fail();", "originalCommit": "6ed3e68bf135eda445e777a9f28108349cb37cfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNjc3OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r465416778", "bodyText": "I think there's some trade-off (a higher chance if double logging) bug either seems fine for me, including following up in another PR since it's not an API break.\nCurrently this PR seems to have been blocked by\n#1428 (comment)\nwith no real action item.", "author": "anuraaga", "createdAt": "2020-08-05T01:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NTg3NA=="}], "type": "inlineReview"}, {"oid": "dfc71f62a19a8c31bacfe117a537028940588775", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/dfc71f62a19a8c31bacfe117a537028940588775", "message": "Re-instated back-pressure handling for IntervalMetricReader and BatchSpanProcessor\n\nThis has been done so that we avoid overwhelming exporters.", "committedDate": "2020-08-14T22:26:18Z", "type": "forcePushed"}, {"oid": "a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "message": "Makes Export methods async\n\nThis commit recognises that the export and flush methods of span and trace exporters can be, and often are, implemented with long-lived operations over networks. We therefore see that these method return types are represented using Java's Future type to account for this common behaviour.", "committedDate": "2020-08-14T22:53:33Z", "type": "commit"}, {"oid": "a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "message": "Makes Export methods async\n\nThis commit recognises that the export and flush methods of span and trace exporters can be, and often are, implemented with long-lived operations over networks. We therefore see that these method return types are represented using Java's Future type to account for this common behaviour.", "committedDate": "2020-08-14T22:53:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjIxOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r470926218", "bodyText": "Should we early return here? Similar comment elsewhere", "author": "anuraaga", "createdAt": "2020-08-15T02:22:55Z", "path": "exporters/logging/src/main/java/io/opentelemetry/exporters/logging/LoggingMetricExporter.java", "diffHunk": "@@ -41,16 +42,16 @@ public ResultCode export(Collection<MetricData> metrics) {\n    * @return the result of the operation\n    */\n   @Override\n-  public ResultCode flush() {\n-    ResultCode resultCode = ResultCode.SUCCESS;\n+  public CompletableResultCode flush() {\n+    CompletableResultCode resultCode = new CompletableResultCode();\n     for (Handler handler : logger.getHandlers()) {\n       try {\n         handler.flush();\n       } catch (Throwable t) {\n-        resultCode = ResultCode.FAILURE;\n+        resultCode.fail();", "originalCommit": "a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1MzUzMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471653532", "bodyText": "I think it doesn't matter in this particular case, since we might want to flush all the handlers, even if one fails. The call to succeed() below is a no-op if it's been previously failed.", "author": "jkwatson", "createdAt": "2020-08-17T17:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwODg2MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471908860", "bodyText": "I'll add a return to make it clear but, as John mentioned, it makes no diff.", "author": "huntc", "createdAt": "2020-08-18T04:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjYwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r470926605", "bodyText": "This could be second sentence, first sentences should describe the class. e.g. A result which will be completed at a later time asynchronously.", "author": "anuraaga", "createdAt": "2020-08-15T02:27:03Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.ArrayList;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to", "originalCommit": "a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwOTI4Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471909283", "bodyText": "Sentences swapped, although my personal preference is to lead with the rationale as the type name is good enough.", "author": "huntc", "createdAt": "2020-08-18T04:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjcxMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r470926711", "bodyText": "Returns a {@link CompletableResultCode} that has been completed successfully.\nDitto for below with unsuccessfully", "author": "anuraaga", "createdAt": "2020-08-15T02:28:29Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.ArrayList;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  /** A convenience for declaring success. */", "originalCommit": "a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjg1NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r470926854", "bodyText": "Realized we can probably just copy paste javadoc from CompletableFuture", "author": "anuraaga", "createdAt": "2020-08-15T02:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkwOTc1MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471909750", "bodyText": "Done", "author": "huntc", "createdAt": "2020-08-18T04:41:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjc3Ng==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r470926776", "bodyText": "Completed this {@link CompletableResultCode} successfully.", "author": "anuraaga", "createdAt": "2020-08-15T02:29:26Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.ArrayList;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  /** A convenience for declaring success. */\n+  public static CompletableResultCode ofSuccess() {\n+    return SUCCESS;\n+  }\n+\n+  /** A convenience for declaring failure. */\n+  public static CompletableResultCode ofFailure() {\n+    return FAILURE;\n+  }\n+\n+  private static final CompletableResultCode SUCCESS = new CompletableResultCode().succeed();\n+  private static final CompletableResultCode FAILURE = new CompletableResultCode().fail();\n+\n+  public CompletableResultCode() {}\n+\n+  @Nullable\n+  @GuardedBy(\"lock\")\n+  private Boolean succeeded = null;\n+\n+  @GuardedBy(\"lock\")\n+  private final ArrayList<Runnable> completionActions = new ArrayList<>();\n+\n+  private final Object lock = new Object();\n+\n+  /** The export operation finished successfully. */", "originalCommit": "a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkxMDAwMg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471910002", "bodyText": "Done", "author": "huntc", "createdAt": "2020-08-18T04:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyNjc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1MDA0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471650045", "bodyText": "I don't think this is needed on this method.", "author": "jkwatson", "createdAt": "2020-08-17T17:32:48Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/trace/export/SimpleSpanProcessor.java", "diffHunk": "@@ -71,15 +74,25 @@ public boolean isStartRequired() {\n   }\n \n   @Override\n+  @SuppressWarnings(\"BooleanParameter\")", "originalCommit": "a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkxMDE5MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471910191", "bodyText": "Hangover from the past. Removed.", "author": "huntc", "createdAt": "2020-08-18T04:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1MDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NDA4Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471654082", "bodyText": "This behavior should be documented, since I think it's non-obvious that it's first-in-wins with succeed/fail.", "author": "jkwatson", "createdAt": "2020-08-17T17:40:31Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.ArrayList;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  /** A convenience for declaring success. */\n+  public static CompletableResultCode ofSuccess() {\n+    return SUCCESS;\n+  }\n+\n+  /** A convenience for declaring failure. */\n+  public static CompletableResultCode ofFailure() {\n+    return FAILURE;\n+  }\n+\n+  private static final CompletableResultCode SUCCESS = new CompletableResultCode().succeed();\n+  private static final CompletableResultCode FAILURE = new CompletableResultCode().fail();\n+\n+  public CompletableResultCode() {}\n+\n+  @Nullable\n+  @GuardedBy(\"lock\")\n+  private Boolean succeeded = null;\n+\n+  @GuardedBy(\"lock\")\n+  private final ArrayList<Runnable> completionActions = new ArrayList<>();\n+\n+  private final Object lock = new Object();\n+\n+  /** The export operation finished successfully. */\n+  public CompletableResultCode succeed() {\n+    synchronized (lock) {\n+      if (succeeded == null) {", "originalCommit": "a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NzI5MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471657290", "bodyText": "Also, unit tests to verify it would also be very good.", "author": "jkwatson", "createdAt": "2020-08-17T17:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NDA4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkyMTk3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471921973", "bodyText": "Done. New test added also.", "author": "huntc", "createdAt": "2020-08-18T05:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NDA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NTE5Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471655193", "bodyText": "This can be declared as a simple List on the LHS, correct?", "author": "jkwatson", "createdAt": "2020-08-17T17:42:53Z", "path": "sdk/src/main/java/io/opentelemetry/sdk/common/export/CompletableResultCode.java", "diffHunk": "@@ -0,0 +1,109 @@\n+/*\n+ * Copyright 2019, OpenTelemetry Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.opentelemetry.sdk.common.export;\n+\n+import java.util.ArrayList;\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.GuardedBy;\n+\n+/**\n+ * The implementation of Export operations are often asynchronous in nature, hence the need to\n+ * convey a result at a later time. CompletableResultCode facilitates this.\n+ *\n+ * <p>This class models JDK 8's CompletableFuture to afford migration should Open Telemetry's SDK\n+ * select JDK 8 or greater as a baseline, and also to offer familiarity to developers.\n+ */\n+public class CompletableResultCode {\n+  /** A convenience for declaring success. */\n+  public static CompletableResultCode ofSuccess() {\n+    return SUCCESS;\n+  }\n+\n+  /** A convenience for declaring failure. */\n+  public static CompletableResultCode ofFailure() {\n+    return FAILURE;\n+  }\n+\n+  private static final CompletableResultCode SUCCESS = new CompletableResultCode().succeed();\n+  private static final CompletableResultCode FAILURE = new CompletableResultCode().fail();\n+\n+  public CompletableResultCode() {}\n+\n+  @Nullable\n+  @GuardedBy(\"lock\")\n+  private Boolean succeeded = null;\n+\n+  @GuardedBy(\"lock\")\n+  private final ArrayList<Runnable> completionActions = new ArrayList<>();", "originalCommit": "a1c86fa263d17dd82da3af413bb9c4d071b03c3a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTkyMjE2NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1428#discussion_r471922164", "bodyText": "Done", "author": "huntc", "createdAt": "2020-08-18T05:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1NTE5Mw=="}], "type": "inlineReview"}, {"oid": "ca101359423ea888c7f64127a709a2397cf15a52", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/ca101359423ea888c7f64127a709a2397cf15a52", "message": "PR feedback", "committedDate": "2020-08-18T05:27:42Z", "type": "commit"}]}