{"pr_number": 1628, "pr_title": "Move the TraceFlags isSampled boolean into the SpanContext", "pr_createdAt": "2020-09-08T15:23:49Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628", "timeline": [{"oid": "b213ed58a8d2ecf57afb069e2221b047a92d95f8", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b213ed58a8d2ecf57afb069e2221b047a92d95f8", "message": "move TraceFlags into the SpanContext, and expose the relevant flags.", "committedDate": "2020-09-08T15:13:38Z", "type": "commit"}, {"oid": "c1cac9df2febe7a30c1841eeb28724886509b30b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c1cac9df2febe7a30c1841eeb28724886509b30b", "message": "Cleanup from rebase from main branch", "committedDate": "2020-09-08T15:22:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MDA2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485260062", "bodyText": "Think we're using getHexLength\nhttps://github.com/open-telemetry/opentelemetry-java/blob/master/api/src/main/java/io/opentelemetry/trace/TraceId.java", "author": "anuraaga", "createdAt": "2020-09-09T00:02:38Z", "path": "api/src/main/java/io/opentelemetry/trace/TraceFlags.java", "diffHunk": "@@ -16,45 +16,32 @@\n \n package io.opentelemetry.trace;\n \n-import io.opentelemetry.internal.Utils;\n-import java.util.Arrays;\n-import javax.annotation.Nullable;\n import javax.annotation.concurrent.Immutable;\n \n /**\n- * A class that represents global trace options. These options are propagated to all child {@link\n- * Span spans}. These determine features such as whether a {@code Span} should be traced. It is\n- * implemented as a bitmask.\n+ * Helper methods for dealing with trace flags options. These options are propagated to all child\n+ * {@link Span spans}. These determine features such as whether a {@code Span} should be traced. It\n+ * is implemented as a bitmask.\n  *\n  * @since 0.1.0\n  */\n @Immutable\n public final class TraceFlags {\n-  // Default options. Nothing set.\n-  private static final byte DEFAULT_OPTIONS = 0;\n+  private TraceFlags() {}\n+\n   // Bit to represent whether trace is sampled or not.\n   private static final byte IS_SAMPLED = 0x1;\n \n   private static final int SIZE = 1;\n   private static final int BASE16_SIZE = 2 * SIZE;\n-  private static final TraceFlags DEFAULT = fromByte(DEFAULT_OPTIONS);\n-\n-  // The set of enabled features is determined by all the enabled bits.\n-  private final byte options;\n-\n-  // Creates a new {@code TraceFlags} with the given options.\n-  private TraceFlags(byte options) {\n-    this.options = options;\n-  }\n \n   /**\n-   * Returns the size in bytes of the {@code TraceFlags}.\n+   * Returns the size in Hex of trace flags.\n    *\n-   * @return the size in bytes of the {@code TraceFlags}.\n-   * @since 0.1.0\n+   * @since 0.9.0\n    */\n-  public static int getSize() {\n-    return SIZE;\n+  public static int getBase16Size() {", "originalCommit": "c1cac9df2febe7a30c1841eeb28724886509b30b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NjIwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485276206", "bodyText": "yep. good catch.", "author": "jkwatson", "createdAt": "2020-09-09T01:02:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MDA2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNzgwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485927807", "bodyText": "done", "author": "jkwatson", "createdAt": "2020-09-09T21:18:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MDA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MTE5Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485261197", "bodyText": "Do you think we can just keep this in the w3c propagator? We previously had a data object that corresponded with the w3c concept of traceflags, but now if we don't, it seems we don't need this here in the first place. I guess this comment applies to the entire TraceFlags class itself too.", "author": "anuraaga", "createdAt": "2020-09-09T00:06:32Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanContext.java", "diffHunk": "@@ -136,13 +136,13 @@ public String getSpanIdAsHexString() {\n     return SpanId.bytesFromHex(getSpanIdHex(), 0);\n   }\n \n-  /**\n-   * Returns the {@code TraceFlags} associated with this {@code SpanContext}.\n-   *\n-   * @return the {@code TraceFlags} associated with this {@code SpanContext}.\n-   * @since 0.1.0\n-   */\n-  public abstract TraceFlags getTraceFlags();\n+  /** Whether the span in this context is sampled. */\n+  public abstract boolean isSampled();\n+\n+  public void copyTraceFlagsHexTo(char[] dest, int destOffset) {", "originalCommit": "c1cac9df2febe7a30c1841eeb28724886509b30b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NjE4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485276184", "bodyText": "I think that seems fair to me, yes.", "author": "jkwatson", "createdAt": "2020-09-09T01:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MTE5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyNDg5Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485924892", "bodyText": "Let's consider that as a follow-on change, if you're ok with that. TraceFlags is used in other places that just the w3c propagator right now.", "author": "jkwatson", "createdAt": "2020-09-09T21:12:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MTE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MTUyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485261527", "bodyText": "Nit but we should rename these variables to sampled throughout", "author": "anuraaga", "createdAt": "2020-09-09T00:07:48Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/JaegerPropagator.java", "diffHunk": "@@ -206,7 +204,7 @@ public static JaegerPropagator getInstance() {\n   private static SpanContext buildSpanContext(String traceId, String spanId, String flags) {\n     try {\n       int flagsInt = Integer.parseInt(flags);\n-      TraceFlags traceFlags = ((flagsInt & 1) == 1) ? SAMPLED_FLAGS : NOT_SAMPLED_FLAGS;\n+      boolean traceFlags = ((flagsInt & 1) == 1) ? SAMPLED_FLAGS : NOT_SAMPLED_FLAGS;", "originalCommit": "c1cac9df2febe7a30c1841eeb28724886509b30b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NjI2NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485276265", "bodyText": "agreed. will do.", "author": "jkwatson", "createdAt": "2020-09-09T01:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MTUyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkyODA0NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485928045", "bodyText": "done. I think I caught a few of them. let me know if there are others I missed", "author": "jkwatson", "createdAt": "2020-09-09T21:19:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI2MTUyNw=="}], "type": "inlineReview"}, {"oid": "e6df33d55ee6f2b7591df1928ce7af4092a8829d", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/e6df33d55ee6f2b7591df1928ce7af4092a8829d", "message": "Address comments from PR review", "committedDate": "2020-09-09T21:18:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2NzIxNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485967216", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Boolean isSampled = TraceFlags.getDefault();\n          \n          \n            \n                boolean isSampled = TraceFlags.getDefault();", "author": "anuraaga", "createdAt": "2020-09-09T22:59:39Z", "path": "extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/AwsXRayPropagator.java", "diffHunk": "@@ -150,7 +150,7 @@ public static AwsXRayPropagator getInstance() {\n \n     String traceId = TraceId.getInvalid();\n     String spanId = SpanId.getInvalid();\n-    TraceFlags traceFlags = TraceFlags.getDefault();\n+    Boolean isSampled = TraceFlags.getDefault();", "originalCommit": "e6df33d55ee6f2b7591df1928ce7af4092a8829d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2ODY1NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485968655", "bodyText": "Just for context, this is a big reason for removing / moving TraceFlags to w3c - it's pretty weird for the default TraceFlags to just be a boolean instead of 00 :)", "author": "anuraaga", "createdAt": "2020-09-09T23:04:00Z", "path": "api/src/main/java/io/opentelemetry/trace/TraceFlags.java", "diffHunk": "@@ -63,191 +50,14 @@ public static int getSize() {\n    * @return the default {@code TraceFlags}.\n    * @since 0.1.0\n    */\n-  public static TraceFlags getDefault() {\n-    return DEFAULT;\n-  }\n-\n-  /**\n-   * Returns a {@code TraceFlags} whose representation is {@code src}.\n-   *\n-   * @param src the byte representation of the {@code TraceFlags}.\n-   * @return a {@code TraceFlags} whose representation is {@code src}.\n-   * @since 0.1.0\n-   */\n-  public static TraceFlags fromByte(byte src) {\n-    return new TraceFlags(src);\n-  }\n-\n-  /**\n-   * Returns a {@code TraceOption} built from a lowercase base16 representation.\n-   *\n-   * @param src the lowercase base16 representation.\n-   * @param srcOffset the offset in the buffer where the representation of the {@code TraceFlags}\n-   *     begins.\n-   * @return a {@code TraceOption} built from a lowercase base16 representation.\n-   * @throws NullPointerException if {@code src} is null.\n-   * @throws IllegalArgumentException if {@code src.length} is not {@code 2 * TraceOption.SIZE} OR\n-   *     if the {@code str} has invalid characters.\n-   * @since 0.1.0\n-   */\n-  public static TraceFlags fromLowerBase16(CharSequence src, int srcOffset) {\n-    return new TraceFlags(BigendianEncoding.byteFromBase16String(src, srcOffset));\n-  }\n-\n-  /**\n-   * Returns the one byte representation of the {@code TraceFlags}.\n-   *\n-   * @return the one byte representation of the {@code TraceFlags}.\n-   * @since 0.1.0\n-   */\n-  public byte getByte() {\n-    return options;\n-  }\n-\n-  /**\n-   * Copies the byte representations of the {@code TraceFlags} into the {@code dest} beginning at\n-   * the {@code destOffset} offset.\n-   *\n-   * <p>Equivalent with (but faster because it avoids any new allocations):\n-   *\n-   * <pre>{@code\n-   * System.arraycopy(getBytes(), 0, dest, destOffset, TraceFlags.getSize());\n-   * }</pre>\n-   *\n-   * @param dest the destination buffer.\n-   * @param destOffset the starting offset in the destination buffer.\n-   * @throws NullPointerException if {@code dest} is null.\n-   * @throws IndexOutOfBoundsException if {@code destOffset+TraceFlags.getSize()} is greater than\n-   *     {@code dest.length}.\n-   * @since 0.1.0\n-   */\n-  public void copyBytesTo(byte[] dest, int destOffset) {\n-    Utils.checkIndex(destOffset, dest.length);\n-    dest[destOffset] = options;\n-  }\n-\n-  /**\n-   * Copies the lowercase base16 representations of the {@code TraceId} into the {@code dest}\n-   * beginning at the {@code destOffset} offset.\n-   *\n-   * @param dest the destination buffer.\n-   * @param destOffset the starting offset in the destination buffer.\n-   * @throws IndexOutOfBoundsException if {@code destOffset + 2} is greater than {@code\n-   *     dest.length}.\n-   * @since 0.1.0\n-   */\n-  public void copyLowerBase16To(char[] dest, int destOffset) {\n-    BigendianEncoding.byteToBase16String(options, dest, destOffset);\n-  }\n-\n-  /**\n-   * Returns the lowercase base16 encoding of this {@code TraceFlags}.\n-   *\n-   * @return the lowercase base16 encoding of this {@code TraceFlags}.\n-   * @since 0.1.0\n-   */\n-  public String toLowerBase16() {\n-    char[] chars = new char[BASE16_SIZE];\n-    copyLowerBase16To(chars, 0);\n-    return new String(chars);\n-  }\n-\n-  /**\n-   * Returns a new {@link Builder} with default options.\n-   *\n-   * @return a new {@code Builder} with default options.\n-   * @since 0.1.0\n-   */\n-  public static Builder builder() {\n-    return new Builder(DEFAULT_OPTIONS);\n-  }\n-\n-  /**\n-   * Returns a new {@link Builder} with all given options set.\n-   *\n-   * @param traceFlags the given options set.\n-   * @return a new {@code Builder} with all given options set.\n-   * @since 0.1.0\n-   */\n-  public static Builder builder(TraceFlags traceFlags) {\n-    return new Builder(traceFlags.options);\n-  }\n-\n-  /**\n-   * Returns a boolean indicating whether this {@code Span} is part of a sampled trace and data\n-   * should be exported to a persistent store.\n-   *\n-   * @return a boolean indicating whether the trace is sampled.\n-   * @since 0.1.0\n-   */\n-  public boolean isSampled() {\n-    return hasOption(IS_SAMPLED);\n-  }\n-\n-  @Override\n-  public boolean equals(@Nullable Object obj) {\n-    if (obj == this) {\n-      return true;\n-    }\n-\n-    if (!(obj instanceof TraceFlags)) {\n-      return false;\n-    }\n-\n-    TraceFlags that = (TraceFlags) obj;\n-    return options == that.options;\n-  }\n-\n-  @Override\n-  public int hashCode() {\n-    return Arrays.hashCode(new byte[] {options});\n-  }\n-\n-  @Override\n-  public String toString() {\n-    return \"TraceFlags{sampled=\" + isSampled() + \"}\";\n-  }\n-\n-  /**\n-   * Builder class for {@link TraceFlags}.\n-   *\n-   * @since 0.1.0\n-   */\n-  public static final class Builder {\n-    private byte options;\n-\n-    private Builder(byte options) {\n-      this.options = options;\n-    }\n-\n-    /**\n-     * Sets the sampling bit in the options.\n-     *\n-     * @param isSampled the sampling bit.\n-     * @return this.\n-     * @since 0.1.0\n-     */\n-    public Builder setIsSampled(boolean isSampled) {\n-      if (isSampled) {\n-        options = (byte) (options | IS_SAMPLED);\n-      } else {\n-        options = (byte) (options & ~IS_SAMPLED);\n-      }\n-      return this;\n-    }\n-\n-    /**\n-     * Builds and returns a {@code TraceFlags} with the desired options.\n-     *\n-     * @return a {@code TraceFlags} with the desired options.\n-     * @since 0.1.0\n-     */\n-    public TraceFlags build() {\n-      return fromByte(options);\n-    }\n+  public static boolean getDefault() {", "originalCommit": "e6df33d55ee6f2b7591df1928ce7af4092a8829d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2OTY0Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485969643", "bodyText": "Yep. I agree. I'll create an issue for it, as a follow-up.", "author": "jkwatson", "createdAt": "2020-09-09T23:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2ODY1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk3NDQ0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r485974448", "bodyText": "#1632", "author": "jkwatson", "createdAt": "2020-09-09T23:22:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk2ODY1NQ=="}], "type": "inlineReview"}, {"oid": "0abc21bc25b24cadeaac2a6f87b2d3dbd25c0a61", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/0abc21bc25b24cadeaac2a6f87b2d3dbd25c0a61", "message": "Update extensions/trace_propagators/src/main/java/io/opentelemetry/extensions/trace/propagation/AwsXRayPropagator.java\n\nCo-authored-by: Anuraag Agrawal <anuraaga@gmail.com>", "committedDate": "2020-09-09T23:06:17Z", "type": "commit"}, {"oid": "4a61910c0331785d8d9666838ec23d2699533db6", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/4a61910c0331785d8d9666838ec23d2699533db6", "message": "Undo @anuraaga's bad suggestion. ;)", "committedDate": "2020-09-09T23:15:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r486471158", "bodyText": "We should keep this as byte because more bits can be used in the future and we don't want to have to deal with adding more overloads to this method (and all public methods). What do you think?\nFor the getters we can have a getTraceFlags as well as isSampled (helper method to access properties in the flags).", "author": "bogdandrutu", "createdAt": "2020-09-10T16:19:13Z", "path": "api/src/main/java/io/opentelemetry/trace/SpanContext.java", "diffHunk": "@@ -54,24 +54,24 @@ public static SpanContext getInvalid() {\n    *\n    * @param traceIdHex the trace identifier of the span context.\n    * @param spanIdHex the span identifier of the span context.\n-   * @param traceFlags the trace options for the span context.\n+   * @param isSampled if the underlying span should be sampled.\n    * @param traceState the trace state for the span context.\n    * @return a new {@code SpanContext} with the given identifiers and options.\n    * @since 0.1.0\n    */\n   public static SpanContext create(", "originalCommit": "4a61910c0331785d8d9666838ec23d2699533db6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ4NDk2MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r486484961", "bodyText": "Agreed. Not sure more flags will be added anytime soon, but we should stay (relatively) conservative.", "author": "carlosalberto", "createdAt": "2020-09-10T16:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5NTc3MQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r486495771", "bodyText": "So, you're suggesting changing the creators to take a byte, rather than the boolean here? And, exposing the raw byte as well?", "author": "jkwatson", "createdAt": "2020-09-10T16:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NzkwOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r486597909", "bodyText": "@bogdandrutu that's an easy change, if that's what you're suggesting.", "author": "jkwatson", "createdAt": "2020-09-10T19:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgzNzY2OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r486837668", "bodyText": "I don't think we need to expose the raw byte - I'd suggest SpanContext only has the semantic meaning of the flags (isSampled, isBlah, etc). I think I would take more overloads, or adding SpanContext.Builder if we come to that later over having SpanContext concerned with any sort of marshalling (marshalling is a propagation concept, not a SpanContext concept) - the fact that traceflags are a byte that these booleans are marshalled from can be left to the w3c propagator which we're planning on refactoring to, right @jkwatson?", "author": "anuraaga", "createdAt": "2020-09-11T07:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEwMzkxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487103910", "bodyText": "I think so, yes. I think the worry is an explosion of booleans on the creation methods, if more things end up in the TraceFlags down the road.", "author": "jkwatson", "createdAt": "2020-09-11T14:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEwODQ4NQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487108485", "bodyText": "Same, slightly concerned with a potential explosion of booleans ;)", "author": "carlosalberto", "createdAt": "2020-09-11T15:06:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0MzEyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487143129", "bodyText": "My proposal, after discussion in the SIG meeting this morning, is that we keep the boolean parameter, and when/if the W3C introduces more flags, that we can create a Builder for SpanContext that exposes all the possible options (or potentially a bitmasked byte, if that makes sense for more than just the W3C propagator.", "author": "jkwatson", "createdAt": "2020-09-11T16:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NzAyOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487147028", "bodyText": "I think we've had enough history of a sampling bit to have it as a native boolean here. And when we feel that w3c adds too many booleans we can convert to a builder pattern at the time. It's also possible for the w3c header to increment it's version bit and add completely new stuff, and if everything is a constructor parameter it explodes anyways, there's no way to protect us from constructor explosion if matching w3c 1:1. I suggest one of two options\n\n\nRename SpanContext to W3CTraceParent or alternatively to match dotnet naming convention ParentId - if we want the span context to logically reflect 1:1 the spec of that header, I find the current naming to be unclear\n\n\nKeep with SpanContext being independent of marshalling format, it presents semantics. It ends up being a superset of all possible semantics with regards to tracing.\n\n\nI lean towards 2) since I don't see why a span context should care whether booleans are passed as a list of booleans or a byte, that's what propagation does, but if the intent of SpanContext is to model w3c 1:1 I think the naming is currently not intuitive.", "author": "anuraaga", "createdAt": "2020-09-11T16:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE0NzYwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487147600", "bodyText": "And see @jkwatson's comment as I wrote mine but it's exactly what I'm thinking too.", "author": "anuraaga", "createdAt": "2020-09-11T16:12:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1MDcwNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487150707", "bodyText": "@anuraaga @jkwatson the downside of this is that propagation of new properties is hard to achieve. Let's assume w3c define isBlah as the second least significant bit, and one app in the middle runs a Java version that only propagates isSampled bit (in the current design). Users will have a hard time to start using isBlah because they have to upgrade all services to propagate the new property, by propagating the whole byte we at least ensure that the property is propagate immediately. Does this argument change your vision?", "author": "bogdandrutu", "createdAt": "2020-09-11T16:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1NTQyOQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487155429", "bodyText": "This is a great example. It doesn't change my vision I think since if pass-through propagation is required, I think that's also a feature of propagation layer for the most part. I think we have similar conversation about tracestate and haven't really resolved it. But if w3c requires a byte that comes in coming to be copied outgoing, I would expect that to be implemented by the propagator, maybe by stuffing something into context. Does that sound reasonable?", "author": "anuraaga", "createdAt": "2020-09-11T16:27:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE1OTMyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487159320", "bodyText": "@anuraaga as we discussed on open-telemetry/opentelemetry-specification#875, currently the Context cannot be used for that, as it would be lost if someone called setParent(Span) or setParent(SpanContext), but I agree it should be useable for that. If we implemented open-telemetry/opentelemetry-specification#875 by merging #1611, it would work. \ud83d\ude03", "author": "Oberon00", "createdAt": "2020-09-11T16:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NzIwNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487167205", "bodyText": "@Oberon00 I personally find our current API to be too span-native to be a big fan of setting Context as parent of Span. For this or similar discussion, I would consider Context equal to map of stuff on SpanContext (former context-native, latter span-native) - latter would also be fine here I hope :)\nAlso to be clear, I don't intend to block 875 since I added my insight and that's all I can really do. FWIW when it's merged we'll of course also merge the Java PR :-D", "author": "anuraaga", "createdAt": "2020-09-11T16:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE3MDgyMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487170820", "bodyText": "Sure. I just wanted to point out that \"maybe by stuffing something into the context\" wouldn't currently work, if we are talking about the Context object returned by the propagator.", "author": "Oberon00", "createdAt": "2020-09-11T16:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE5MjkyNQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487192925", "bodyText": "But if w3c requires a byte that comes in coming to be copied outgoing, I would expect that to be implemented by the propagator, maybe by stuffing something into context. Does that sound reasonable?\n\nNot sure if this is not overcomplicating things, we have to do this now then in order to help users for future possible additions to the flags. So I think we better just carry the flags as we received (modify them if needed), and not have to deal with extra things propagated in the context for w3c.", "author": "bogdandrutu", "createdAt": "2020-09-11T17:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwNjA2Mg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487206062", "bodyText": "I think some of this boils down to the question: Is OpenTelemetry a W3C-trace-context native implementation? If so, then we should definitely keep the W3C byte, and make other propagators deal with converting their \"trace flag\" representation into the W3C/OTel byte. If, however, OTel is intended to be propagation-agnostic, then keeping the W3C byte around feels like an odd API choice to make other propagators conform to.\nI honestly am on the fence with this one. I don't mind being more aggressively W3C-centric, but it feels like that's a bigger decision than a single person should make.", "author": "jkwatson", "createdAt": "2020-09-11T18:05:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIwOTQzOA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487209438", "bodyText": "This is a great way to look at things. In my personal opinion we are w3c centric, and that is the reason we invested in that standard (again personal opinion).", "author": "bogdandrutu", "createdAt": "2020-09-11T18:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIzNjEwMQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487236101", "bodyText": "@jkwatson @anuraaga in order to make progress, I think we should use byte for the moment because that's what we had before, and discuss in a followup PR about changing that to boolean:\n\nWe had byte before so no change there\nThat is a separate change.", "author": "bogdandrutu", "createdAt": "2020-09-11T19:07:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI5NTA1Nw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487295057", "bodyText": "I'm fine with that approach. I have this prepped to go, so I'll push it in a bit.", "author": "jkwatson", "createdAt": "2020-09-11T21:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI5NTY5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/1628#discussion_r487295699", "bodyText": "pushed.", "author": "jkwatson", "createdAt": "2020-09-11T21:19:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ3MTE1OA=="}], "type": "inlineReview"}, {"oid": "6b8309623a97180d351309151b943df44e8c1215", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6b8309623a97180d351309151b943df44e8c1215", "message": "change the traceFlags input to the TraceContext be a byte, rather than a boolean.", "committedDate": "2020-09-10T19:55:21Z", "type": "commit"}]}