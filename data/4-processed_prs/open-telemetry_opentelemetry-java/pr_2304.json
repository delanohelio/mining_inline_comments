{"pr_number": 2304, "pr_title": "Add custom proto marshaler to avoid unnecessary allocation", "pr_createdAt": "2020-12-15T04:54:38Z", "pr_url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304", "timeline": [{"oid": "d68df96b64d93c6e91417fe963af99edd188a38b", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/d68df96b64d93c6e91417fe963af99edd188a38b", "message": "Add custom proto marshaler to avoid unnecessary allocation\n\nUnfortunately we cannot get the whole performance back because we need to write a custom Marshaler for grpc (which is possible but try to limit the PR size).\n\nAs the numbers show we have ~25% improvement in CPU and ~15% in memory with this PR. With a custom marshaler we can get anoter 7% CPU and 7% memory.\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-15T17:46:24Z", "type": "forcePushed"}, {"oid": "061c20e736ffe0b4a1c3e7e834d6f4e51d082203", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/061c20e736ffe0b4a1c3e7e834d6f4e51d082203", "message": "Add custom proto marshaler to avoid unnecessary allocation\n\nSome of the differences with the generated code:\n1. Avoid builders to construct the marshalers;\n2. Use less objects for Attributes because of the way `oneof` generated code is implemented; Also proto files supports arrays of any combination which is not the case for us.\n3. Take advantage on the fact that data we know are immutable, no need to wrap to unmodifiable list/maps etc;\n\nUnfortunately we cannot get the whole performance back because we need to write a custom Marshaler for grpc (which is possible but try to limit the PR size).\n\nAs the numbers show we have ~25% improvement in CPU and ~15% in memory with this PR. With a custom marshaler we can get anoter 7% CPU and 7% memory.\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-15T18:18:36Z", "type": "forcePushed"}, {"oid": "b288e09faa7d609dcd8739467ac3f1e9576b8169", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b288e09faa7d609dcd8739467ac3f1e9576b8169", "message": "Add custom proto marshaler to avoid unnecessary allocation\n\nSome of the differences with the generated code:\n1. Avoid builders to construct the marshalers;\n2. Use less objects for Attributes because of the way `oneof` generated code is implemented; Also proto files supports arrays of any combination which is not the case for us.\n3. Take advantage on the fact that data we know are immutable, no need to wrap to unmodifiable list/maps etc;\n\nUnfortunately we cannot get the whole performance back because we need to write a custom Marshaler for grpc (which is possible but try to limit the PR size).\n\nAs the numbers show we have ~25% improvement in CPU and ~15% in memory with this PR. With a custom marshaler we can get anoter 7% CPU and 7% memory.\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-15T18:27:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzNzA5OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543637099", "bodyText": "we should have a better description here, even if it won't happen under any normal circumstance", "author": "jkwatson", "createdAt": "2020-12-15T19:44:54Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {\n+    if (attributes.isEmpty()) {\n+      return EMPTY_REPEATED;\n+    }\n+\n+    AttributeMarshaler[] attributeMarshalers = new AttributeMarshaler[attributes.size()];\n+    // TODO: Revisit how to avoid the atomic integer creation.\n+    AtomicInteger pos = new AtomicInteger();\n+    attributes.forEach(\n+        (attributeKey, o) ->\n+            attributeMarshalers[pos.getAndIncrement()] =\n+                AttributeMarshaler.create(attributeKey, o));\n+    return attributeMarshalers;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  static AttributeMarshaler create(AttributeKey<?> attributeKey, Object value) {\n+    ByteString key = MarshalerUtil.toByteString(attributeKey.getKey());\n+    if (value == null) {\n+      return new KeyValueNullMarshaler(key);\n+    }\n+    switch (attributeKey.getType()) {\n+      case STRING:\n+        return new KeyValueStringMarshaler(key, MarshalerUtil.toByteString((String) value));\n+      case LONG:\n+        return new KeyValueLongMarshaler(key, (Long) value);\n+      case BOOLEAN:\n+        return new KeyValueBooleanMarshaler(key, (Boolean) value);\n+      case DOUBLE:\n+        return new KeyValueDoubleMarshaler(key, (Double) value);\n+      case STRING_ARRAY:\n+        return new KeyValueArrayStringMarshaler(key, (List<String>) value);\n+      case LONG_ARRAY:\n+        return new KeyValueArrayLongMarshaler(key, (List<Long>) value);\n+      case BOOLEAN_ARRAY:\n+        return new KeyValueArrayBooleanMarshaler(key, (List<Boolean>) value);\n+      case DOUBLE_ARRAY:\n+        return new KeyValueArrayDoubleMarshaler(key, (List<Double>) value);\n+    }\n+    throw new IllegalArgumentException(\"\");", "originalCommit": "b288e09faa7d609dcd8739467ac3f1e9576b8169", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1NTAxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543655010", "bodyText": ":))))", "author": "bogdandrutu", "createdAt": "2020-12-15T20:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYzNzA5OQ=="}], "type": "inlineReview"}, {"oid": "703e60ebf16cd5f243d466a0715ca55a3501317e", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/703e60ebf16cd5f243d466a0715ca55a3501317e", "message": "Add custom proto marshaler to avoid unnecessary allocation\n\nSome of the differences with the generated code:\n1. Avoid builders to construct the marshalers;\n2. Use less objects for Attributes because of the way `oneof` generated code is implemented; Also proto files supports arrays of any combination which is not the case for us.\n3. Take advantage on the fact that data we know are immutable, no need to wrap to unmodifiable list/maps etc;\n\nUnfortunately we cannot get the whole performance back because we need to write a custom Marshaler for grpc (which is possible but try to limit the PR size).\n\nAs the numbers show we have ~25% improvement in CPU and ~15% in memory with this PR. With a custom marshaler we can get anoter 7% CPU and 7% memory.\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-15T22:28:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyMzAwMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543823000", "bodyText": "If I recall correctly, when size is known gRPC allocates byte[] how about using byte[] instead of ByteBuffer?", "author": "anuraaga", "createdAt": "2020-12-16T02:04:31Z", "path": "exporters/otlp/src/jmh/java/io/opentelemetry/exporter/otlp/RequestMarshalBenchmarks.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.CodedOutputStream;\n+import io.opentelemetry.proto.collector.trace.v1.ExportTraceServiceRequest;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Threads;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode({Mode.AverageTime})\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(1)\n+public class RequestMarshalBenchmarks {\n+\n+  @Benchmark\n+  @Threads(1)\n+  public ByteBuffer createProtoMarshal(RequestMarshalState state) {\n+    ExportTraceServiceRequest protoRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(state.spanDataList))\n+            .build();\n+    return ByteBuffer.allocate(protoRequest.getSerializedSize());\n+  }\n+\n+  @Benchmark\n+  @Threads(1)\n+  public ByteBuffer marshalProto(RequestMarshalState state) throws IOException {\n+    ExportTraceServiceRequest protoRequest =\n+        ExportTraceServiceRequest.newBuilder()\n+            .addAllResourceSpans(SpanAdapter.toProtoResourceSpans(state.spanDataList))\n+            .build();\n+    ByteBuffer protoOutput = ByteBuffer.allocate(protoRequest.getSerializedSize());", "originalCommit": "31e7b639766295d476d83419f18f23557b85fe57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwMzAyNw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543903027", "bodyText": "Good call, will change", "author": "bogdandrutu", "createdAt": "2020-12-16T03:51:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyMzAwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkxOTgxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543919810", "bodyText": "Done.", "author": "bogdandrutu", "createdAt": "2020-12-16T04:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyMzAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyNDAzNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543824036", "bodyText": "Such 0's are relatively rare, how about using more representative IDs? Don't think it affects performance but just in case.", "author": "anuraaga", "createdAt": "2020-12-16T02:05:51Z", "path": "exporters/otlp/src/jmh/java/io/opentelemetry/exporter/otlp/RequestMarshalState.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.api.trace.Span;\n+import io.opentelemetry.api.trace.SpanContext;\n+import io.opentelemetry.api.trace.SpanId;\n+import io.opentelemetry.api.trace.TraceFlags;\n+import io.opentelemetry.api.trace.TraceId;\n+import io.opentelemetry.api.trace.TraceState;\n+import io.opentelemetry.sdk.common.InstrumentationLibraryInfo;\n+import io.opentelemetry.sdk.resources.Resource;\n+import io.opentelemetry.sdk.testing.trace.TestSpanData;\n+import io.opentelemetry.sdk.trace.data.SpanData;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+@State(Scope.Benchmark)\n+public class RequestMarshalState {\n+  private static final Resource RESOURCE =\n+      Resource.create(\n+          Attributes.builder()\n+              .put(AttributeKey.booleanKey(\"key_bool\"), true)\n+              .put(AttributeKey.stringKey(\"key_string\"), \"string\")\n+              .put(AttributeKey.longKey(\"key_int\"), 100L)\n+              .put(AttributeKey.doubleKey(\"key_double\"), 100.3)\n+              .put(\n+                  AttributeKey.stringArrayKey(\"key_string_array\"),\n+                  Arrays.asList(\"string\", \"string\"))\n+              .put(AttributeKey.longArrayKey(\"key_long_array\"), Arrays.asList(12L, 23L))\n+              .put(AttributeKey.doubleArrayKey(\"key_double_array\"), Arrays.asList(12.3, 23.1))\n+              .put(AttributeKey.booleanArrayKey(\"key_boolean_array\"), Arrays.asList(true, false))\n+              .build());\n+\n+  private static final InstrumentationLibraryInfo INSTRUMENTATION_LIBRARY_INFO =\n+      InstrumentationLibraryInfo.create(\"name\", null);\n+  private static final byte[] TRACE_ID_BYTES =", "originalCommit": "31e7b639766295d476d83419f18f23557b85fe57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwMjYwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543902606", "bodyText": "I will change them but for bytes in proto it shouldn\u2019t matter (maybe just from hex to bytes which for comparison that we do is irrelevant both of them doing it", "author": "bogdandrutu", "createdAt": "2020-12-16T03:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyNDAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkxOTg0OA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543919848", "bodyText": "Done.", "author": "bogdandrutu", "createdAt": "2020-12-16T04:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyNDAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543828484", "bodyText": "It seems unfortunate to instantiate marshallers for each object. Isn't it better to define Marshaler something like\ninterface MarshalerWithSize<T> {\n\n  int serializedSize(T value);\n\n  void writeValue(T value, CodedOutputStream stream);\n}\nand have singleton marshalers?", "author": "anuraaga", "createdAt": "2020-12-16T02:11:38Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {", "originalCommit": "31e7b639766295d476d83419f18f23557b85fe57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgzMDg2OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543830869", "bodyText": "Wilder would be to make everything static methods since we don't need to be generic, we only have a single API. But that's probably overboard.", "author": "anuraaga", "createdAt": "2020-12-16T02:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg5OTM3Mw==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543899373", "bodyText": "The problem is that the size of the key needs a conversion to utf8 which is very expensive and allocating one object I measured to be better and do the conversion once. We can always improve more once we have the initial structure in place", "author": "bogdandrutu", "createdAt": "2020-12-16T03:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwMTIwNg==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543901206", "bodyText": "I am looking also into a different approach that gogoproto uses which is to calculate size once and then write from the end to the buffer so to avoid the need of caching the size result per message. We have more ways to improve this and I will do a bit more on this during the holidays but still believe it is a good start", "author": "bogdandrutu", "createdAt": "2020-12-16T03:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkxNzAxMA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543917010", "bodyText": "Ok - also don't forget we have a fast concurrent weak map now, so it can often be used as an efficient cache when needed. If the attribute key is the main reason for the instantiation, then that'd be easy to cache and maybe a simple win.", "author": "anuraaga", "createdAt": "2020-12-16T04:09:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk1ODU0OQ==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543958549", "bodyText": "???", "author": "bogdandrutu", "createdAt": "2020-12-16T05:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgyODQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzkwNjI0MA==", "url": "https://github.com/open-telemetry/opentelemetry-java/pull/2304#discussion_r543906240", "bodyText": "I think asMap.entrySet should work fine too here escape analysis generally performs well for iteration. Otherwise, just\nnew BiConsumer<AttributeKey, Object> {\n  int index = 0;\n\n  void accept(AttributeKey, Object) {\n    attributeMarshalers[index++] = create()\n  }\n}", "author": "anuraaga", "createdAt": "2020-12-16T03:55:35Z", "path": "exporters/otlp/src/main/java/io/opentelemetry/exporter/otlp/AttributeMarshaler.java", "diffHunk": "@@ -0,0 +1,293 @@\n+/*\n+ * Copyright The OpenTelemetry Authors\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+\n+package io.opentelemetry.exporter.otlp;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.CodedOutputStream;\n+import com.google.protobuf.WireFormat;\n+import io.opentelemetry.api.common.AttributeKey;\n+import io.opentelemetry.api.common.Attributes;\n+import io.opentelemetry.proto.common.v1.AnyValue;\n+import io.opentelemetry.proto.common.v1.ArrayValue;\n+import io.opentelemetry.proto.common.v1.KeyValue;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+abstract class AttributeMarshaler extends MarshalerWithSize {\n+  private static final AttributeMarshaler[] EMPTY_REPEATED = new AttributeMarshaler[0];\n+  private final ByteString key;\n+  private final int valueSize;\n+\n+  static AttributeMarshaler[] createRepeated(Attributes attributes) {\n+    if (attributes.isEmpty()) {\n+      return EMPTY_REPEATED;\n+    }\n+\n+    AttributeMarshaler[] attributeMarshalers = new AttributeMarshaler[attributes.size()];\n+    // TODO: Revisit how to avoid the atomic integer creation.", "originalCommit": "31e7b639766295d476d83419f18f23557b85fe57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c618b050a695c1230519e690a6cbd57e1869dd68", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/c618b050a695c1230519e690a6cbd57e1869dd68", "message": "Add custom proto marshaler to avoid unnecessary allocation\n\nSome of the differences with the generated code:\n1. Avoid builders to construct the marshalers;\n2. Use less objects for Attributes because of the way `oneof` generated code is implemented; Also proto files supports arrays of any combination which is not the case for us.\n3. Take advantage on the fact that data we know are immutable, no need to wrap to unmodifiable list/maps etc;\n\nUnfortunately we cannot get the whole performance back because we need to write a custom Marshaler for grpc (which is possible but try to limit the PR size).\n\nAs the numbers show we have ~25% improvement in CPU and ~15% in memory with this PR. With a custom marshaler we can get anoter 7% CPU and 7% memory.\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T04:40:43Z", "type": "commit"}, {"oid": "6f02ed1c734c4c76cc0e6bbfbb4105a0ba736fc2", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6f02ed1c734c4c76cc0e6bbfbb4105a0ba736fc2", "message": "Always send the message information even if empty values\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T04:40:44Z", "type": "commit"}, {"oid": "64663dbe9e58d494899d6f23c6b852e107b79142", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/64663dbe9e58d494899d6f23c6b852e107b79142", "message": "Test for error status\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T04:40:45Z", "type": "commit"}, {"oid": "98582f81a75a664667c2549ad03c5731b304ffc6", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/98582f81a75a664667c2549ad03c5731b304ffc6", "message": "Test for valid ParentSpanId\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T04:40:45Z", "type": "commit"}, {"oid": "60ec03b110aa6c87012dfbdc4ba83be226e6b8e5", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/60ec03b110aa6c87012dfbdc4ba83be226e6b8e5", "message": "Fix order in status fields\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T04:40:45Z", "type": "commit"}, {"oid": "67723d9cf134bb1f9ddd8713a8f97f7ad1fe10fd", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/67723d9cf134bb1f9ddd8713a8f97f7ad1fe10fd", "message": "Address feedback from code review\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T04:40:45Z", "type": "commit"}, {"oid": "775872f8bd06808dc5990564c7b7526c98056661", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/775872f8bd06808dc5990564c7b7526c98056661", "message": "Avoid one extra object BytesString, use byte array always\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T04:40:45Z", "type": "commit"}, {"oid": "8db5cb3aecc35cafb4108a542a9fa7f559815b46", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/8db5cb3aecc35cafb4108a542a9fa7f559815b46", "message": "Fix things after PR that moved proto conversions\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T04:50:33Z", "type": "forcePushed"}, {"oid": "6b1a897f01b13f82aeb695969623b1fa7f5020b4", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6b1a897f01b13f82aeb695969623b1fa7f5020b4", "message": "Fix things after PR that moved proto conversions\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T04:55:59Z", "type": "forcePushed"}, {"oid": "b244bf83a4f793c91762d6c4b3057d0a379f08ee", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/b244bf83a4f793c91762d6c4b3057d0a379f08ee", "message": "Fix things after PR that moved proto conversions\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T05:59:57Z", "type": "forcePushed"}, {"oid": "686e2d77995f7c58b5c6238d733b355640988eef", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/686e2d77995f7c58b5c6238d733b355640988eef", "message": "Fix things after PR that moved proto conversions\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T06:05:43Z", "type": "forcePushed"}, {"oid": "12d12f3ce78d9a8db89335a29b323b03420edfaf", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/12d12f3ce78d9a8db89335a29b323b03420edfaf", "message": "Fix things after PR that moved proto conversions\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T06:13:30Z", "type": "forcePushed"}, {"oid": "3bc1c6d2459a94e1c28376c92b0865a3effcc252", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/3bc1c6d2459a94e1c28376c92b0865a3effcc252", "message": "Fix things after PR that moved proto conversions\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T06:19:37Z", "type": "forcePushed"}, {"oid": "6622c56717831fa1991592ec9f8b2b969ba51bde", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6622c56717831fa1991592ec9f8b2b969ba51bde", "message": "Fix things after PR that moved proto conversions\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T06:21:28Z", "type": "commit"}, {"oid": "6622c56717831fa1991592ec9f8b2b969ba51bde", "url": "https://github.com/open-telemetry/opentelemetry-java/commit/6622c56717831fa1991592ec9f8b2b969ba51bde", "message": "Fix things after PR that moved proto conversions\n\nSigned-off-by: Bogdan Drutu <bogdandrutu@gmail.com>", "committedDate": "2020-12-16T06:21:28Z", "type": "forcePushed"}]}