{"pr_number": 864, "pr_title": "[IOTDB-527] Refactor series reader", "pr_createdAt": "2020-03-01T13:52:23Z", "pr_url": "https://github.com/apache/iotdb/pull/864", "timeline": [{"oid": "9aa61760a9303f42b5bb3f285ccaca92964e5f04", "url": "https://github.com/apache/iotdb/commit/9aa61760a9303f42b5bb3f285ccaca92964e5f04", "message": "reorganize series reader and aggregate reader", "committedDate": "2020-02-29T10:02:39Z", "type": "commit"}, {"oid": "d229e9826042033c59a1415c6958313f161d85e8", "url": "https://github.com/apache/iotdb/commit/d229e9826042033c59a1415c6958313f161d85e8", "message": "fix point reader", "committedDate": "2020-02-29T11:31:28Z", "type": "commit"}, {"oid": "18068a9258e87eabf2c0f1576a4247ea5b820b42", "url": "https://github.com/apache/iotdb/commit/18068a9258e87eabf2c0f1576a4247ea5b820b42", "message": "fix bytimestamp", "committedDate": "2020-02-29T12:00:59Z", "type": "commit"}, {"oid": "1dadf07efb7f81a048879ee0066f671a7a89bf74", "url": "https://github.com/apache/iotdb/commit/1dadf07efb7f81a048879ee0066f671a7a89bf74", "message": "combine nextPage (#861)\n\n* fix valueFilterBug for nextOverlappedPage", "committedDate": "2020-03-01T10:06:42Z", "type": "commit"}, {"oid": "fe759e8b8282eb0764ac9034fab750b0590c8125", "url": "https://github.com/apache/iotdb/commit/fe759e8b8282eb0764ac9034fab750b0590c8125", "message": "remove set chunkmetadata=null in hasNextChunk", "committedDate": "2020-03-01T10:36:17Z", "type": "commit"}, {"oid": "17365a75a742d4095de6ea677eb37d35a7b6f7d3", "url": "https://github.com/apache/iotdb/commit/17365a75a742d4095de6ea677eb37d35a7b6f7d3", "message": "remove hasOverlappedPage", "committedDate": "2020-03-01T11:06:04Z", "type": "commit"}, {"oid": "34476e5dab28880cfe659aef01b346f35b0d11b4", "url": "https://github.com/apache/iotdb/commit/34476e5dab28880cfe659aef01b346f35b0d11b4", "message": "new groupby (#862)\n\n* new multithread groupby and  GroupByExecutor", "committedDate": "2020-03-01T13:49:54Z", "type": "commit"}, {"oid": "986f758920bab837f6d17b214bda5bb932b49d3c", "url": "https://github.com/apache/iotdb/commit/986f758920bab837f6d17b214bda5bb932b49d3c", "message": "fix hasNextPage in SeriesReader", "committedDate": "2020-03-01T14:36:12Z", "type": "commit"}, {"oid": "b7c10dab621ff5784a8dde0a2ea42953518acd55", "url": "https://github.com/apache/iotdb/commit/b7c10dab621ff5784a8dde0a2ea42953518acd55", "message": "remove unused interfaces in IAggregateReader", "committedDate": "2020-03-01T14:43:57Z", "type": "commit"}, {"oid": "3b33fbb7af9cc920a9ea23471d36fda653f30b23", "url": "https://github.com/apache/iotdb/commit/3b33fbb7af9cc920a9ea23471d36fda653f30b23", "message": "push down value filter and add log", "committedDate": "2020-03-02T01:39:44Z", "type": "commit"}, {"oid": "e51e07e323eaa93b7651d6ff22a3e960d0a4faa4", "url": "https://github.com/apache/iotdb/commit/e51e07e323eaa93b7651d6ff22a3e960d0a4faa4", "message": "fix nextPage non-stop", "committedDate": "2020-03-02T02:11:58Z", "type": "commit"}, {"oid": "01144810075682d88b066e489f67371b87981024", "url": "https://github.com/apache/iotdb/commit/01144810075682d88b066e489f67371b87981024", "message": "make hasNextPage and nextPage more robust", "committedDate": "2020-03-02T02:22:46Z", "type": "commit"}, {"oid": "d9a19dc1d55bf7898aad2e291541cb99f3f9475b", "url": "https://github.com/apache/iotdb/commit/d9a19dc1d55bf7898aad2e291541cb99f3f9475b", "message": "add stack", "committedDate": "2020-03-02T03:08:54Z", "type": "commit"}, {"oid": "6ad42e9d08c2f52e3976037773417ec0a69e3afa", "url": "https://github.com/apache/iotdb/commit/6ad42e9d08c2f52e3976037773417ec0a69e3afa", "message": "add mergeReaer check in isPageOverlapped", "committedDate": "2020-03-02T03:44:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3NDIyMA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386174220", "bodyText": "Why here delete this, if we can know from the chunk statistics that the chunk is not satisfied, we can just skip that chunk", "author": "JackieTien97", "createdAt": "2020-03-02T02:36:03Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReaderByTimestamp.java", "diffHunk": "@@ -63,24 +61,39 @@ public SeriesReaderByTimestamp(Path seriesPath, TSDataType dataType, QueryContex\n   }\n \n   private boolean hasNext(long timestamp) throws IOException {\n+\n+    /*\n+     * consume pages firstly\n+     */\n+    if (readPageData(timestamp)) {\n+      return true;\n+    }\n+\n+    /*\n+     * consume chunk secondly\n+     */\n     while (seriesReader.hasNextChunk()) {\n-      if (!satisfyTimeFilter(seriesReader.currentChunkStatistics())) {\n-        seriesReader.skipCurrentChunk();\n-        continue;", "originalCommit": "01144810075682d88b066e489f67371b87981024", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyOTAzNQ==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386229035", "bodyText": "I've made up for it", "author": "liutaohua", "createdAt": "2020-03-02T07:23:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3NDIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3OTc0NQ==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386179745", "bodyText": "It seems that if I keep calling hasNextChunk(), the firstChunkMetaData will move to next all the time.\nyou can add an if statement.\nif (firstChunkMetaData != null)\nreturn true;", "author": "JackieTien97", "createdAt": "2020-03-02T03:07:51Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -104,251 +130,274 @@ public SeriesReader(Path seriesPath, TSDataType dataType, QueryContext context,\n \n \n   public boolean hasNextChunk() throws IOException {\n-    if (hasCachedFirstChunkMetadata) {\n-      return true;", "originalCommit": "01144810075682d88b066e489f67371b87981024", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MDIxMQ==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386350211", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T11:55:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3OTc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4NDQzNA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386184434", "bodyText": "It's better name it GroupByTask", "author": "JackieTien97", "createdAt": "2020-03-02T03:35:22Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -114,159 +105,202 @@ protected RowRecord nextWithoutConstraint() throws IOException {\n     }\n     hasCachedTimeInterval = false;\n     RowRecord record = new RowRecord(curStartTime);\n-    AggregateResult[] aggregateResultList = new AggregateResult[paths.size()];\n-    for (Map.Entry<Path, List<Integer>> entry : pathToAggrIndexesMap.entrySet()) {\n-      List<AggregateResult> aggregateResults;\n+    timeRange = new TimeRange(curStartTime, curEndTime - 1);\n+\n+    final AggregateResult[] fields = new AggregateResult[paths.size()];\n+    final List<Future> asyncResult = new ArrayList(pathExecutors.size());\n+\n+    for (Entry<Path, GroupByExecutor> executorEntry : pathExecutors.entrySet()) {\n+      asyncResult.add(QueryTaskPoolManager.getInstance().submit((Callable<?>) () -> {\n+        GroupByExecutor executor = executorEntry.getValue();\n+\n+        executor.resetAggregateResults();\n+        List<Pair<AggregateResult, Integer>> aggregations = executor.calcResult();\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          fields[aggregations.get(i).right] = aggregations.get(i).left;\n+        }\n+        return null;\n+      }));\n+    }\n+    //waiting for data\n+    for (Future future : asyncResult) {\n       try {\n-        aggregateResults = nextIntervalAggregation(entry);\n-      } catch (QueryProcessException e) {\n+        future.get();\n+      } catch (Exception e) {\n+        logger.error(\"GroupByWithoutValueFilterDataSet execute has error,{}\", e);\n         throw new IOException(e);\n       }\n-      int index = 0;\n-      for (int i : entry.getValue()) {\n-        aggregateResultList[i] = aggregateResults.get(index);\n-        index++;\n-      }\n     }\n-    if (aggregateResultList.length == 0) {\n-      record.addField(new Field(null));\n-    } else {\n-      for (AggregateResult res : aggregateResultList) {\n-        record.addField(res.getResult(), res.getResultDataType());\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(new Field(null));\n+        continue;\n       }\n+      record.addField(res.getResult(), res.getResultDataType());\n     }\n     return record;\n   }\n \n-  /**\n-   * calculate the group by result of one series\n-   *\n-   * @param pathToAggrIndexes entry of path to aggregation indexes map\n-   */\n-  private List<AggregateResult> nextIntervalAggregation(Map.Entry<Path,\n-      List<Integer>> pathToAggrIndexes) throws IOException, QueryProcessException {\n-    List<AggregateResult> aggregateResultList = new ArrayList<>();\n-    List<Boolean> isCalculatedList = new ArrayList<>();\n-    List<Integer> indexList = pathToAggrIndexes.getValue();\n-\n-    int remainingToCalculate = indexList.size();\n-    TSDataType tsDataType = groupByPlan.getDeduplicatedDataTypes().get(indexList.get(0));\n-\n-    for (int index : indexList) {\n-      AggregateResult result = AggregateResultFactory\n-          .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(index), tsDataType);\n-      aggregateResultList.add(result);\n-\n-      BatchData lastBatch = cachedBatchDataList.get(index);\n-\n-      calcBatchData(result, lastBatch);\n-      if (isEndCalc(result, lastBatch)) {\n-        isCalculatedList.add(true);\n-        remainingToCalculate--;\n-        if (remainingToCalculate == 0) {\n-          return aggregateResultList;\n+\n+  private class GroupByExecutor {", "originalCommit": "d9a19dc1d55bf7898aad2e291541cb99f3f9475b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNzU0NA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386227544", "bodyText": "no , i like executor", "author": "liutaohua", "createdAt": "2020-03-02T07:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4NDQzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MDQ5MA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386350490", "bodyText": "executor or task are all fine to me", "author": "qiaojialin", "createdAt": "2020-03-02T11:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4NDQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4NTU3Ng==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386185576", "bodyText": "No need to construct these two, if pathExecutors already has the path", "author": "JackieTien97", "createdAt": "2020-03-02T03:42:10Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -64,45 +67,33 @@ public GroupByWithoutValueFilterDataSet(QueryContext context, GroupByPlan groupB\n       throws StorageEngineException {\n     super(context, groupByPlan);\n \n-    this.pathToAggrIndexesMap = new HashMap<>();\n-    this.aggregateReaders = new HashMap<>();\n-    this.cachedBatchDataList = new ArrayList<>();\n-    for (int i = 0; i < paths.size(); i++) {\n-      cachedBatchDataList.add(null);\n-    }\n     initGroupBy(context, groupByPlan);\n   }\n \n-  /**\n-   * init reader and aggregate function.\n-   */\n   private void initGroupBy(QueryContext context, GroupByPlan groupByPlan)\n       throws StorageEngineException {\n     IExpression expression = groupByPlan.getExpression();\n-    this.groupByPlan = groupByPlan;\n \n     Filter timeFilter = null;\n-    // init reader\n     if (expression != null) {\n       timeFilter = ((GlobalTimeExpression) expression).getFilter();\n     }\n \n     for (int i = 0; i < paths.size(); i++) {\n       Path path = paths.get(i);\n-      List<Integer> indexList = pathToAggrIndexesMap\n-          .computeIfAbsent(path, key -> new ArrayList<>());\n-      indexList.add(i);\n-      if (!aggregateReaders.containsKey(path)) {\n-\n-        QueryDataSource queryDataSource = QueryResourceManager.getInstance()\n-            .getQueryDataSource(path, context, timeFilter);\n-        // update filter by TTL\n-        timeFilter = queryDataSource.updateFilterUsingTTL(timeFilter);\n-\n-        IAggregateReader seriesReader = new SeriesAggregateReader(path, dataTypes.get(i), context,\n-            queryDataSource, timeFilter, null, null);\n-        aggregateReaders.put(path, seriesReader);\n-      }\n+\n+      QueryDataSource queryDataSource = QueryResourceManager.getInstance()\n+          .getQueryDataSource(path, context, timeFilter);\n+      // update filter by TTL\n+      timeFilter = queryDataSource.updateFilterUsingTTL(timeFilter);", "originalCommit": "d9a19dc1d55bf7898aad2e291541cb99f3f9475b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNzM3Mw==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386227373", "bodyText": "done", "author": "liutaohua", "createdAt": "2020-03-02T07:17:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4NTU3Ng=="}], "type": "inlineReview"}, {"oid": "b725c72fff257e3dbc52dd7b676c09cd68bee88f", "url": "https://github.com/apache/iotdb/commit/b725c72fff257e3dbc52dd7b676c09cd68bee88f", "message": "fix hasNextOverlappedPage when no data in this page under value filter", "committedDate": "2020-03-02T05:12:05Z", "type": "commit"}, {"oid": "1c391336ca5b453fc65f8b37fc3c6c68d9437da7", "url": "https://github.com/apache/iotdb/commit/1c391336ca5b453fc65f8b37fc3c6c68d9437da7", "message": "Merge remote-tracking branch 'origin/master' into optimize_series_reader", "committedDate": "2020-03-02T05:55:44Z", "type": "commit"}, {"oid": "9e85181202526fb8aaed3be40533492186587fe4", "url": "https://github.com/apache/iotdb/commit/9e85181202526fb8aaed3be40533492186587fe4", "message": "add log", "committedDate": "2020-03-02T06:08:56Z", "type": "commit"}, {"oid": "f06043b69170b31b2cc1827747523b40120cfaf6", "url": "https://github.com/apache/iotdb/commit/f06043b69170b31b2cc1827747523b40120cfaf6", "message": "add filter overlapped data test and add log", "committedDate": "2020-03-02T06:52:34Z", "type": "commit"}, {"oid": "3e6a61ffad151acbb3ed90e40a744edc8e1e4c41", "url": "https://github.com/apache/iotdb/commit/3e6a61ffad151acbb3ed90e40a744edc8e1e4c41", "message": "add log for point 100492", "committedDate": "2020-03-02T07:17:08Z", "type": "commit"}, {"oid": "46a133be76a76048e5e3b677f04313ff4f18d4ea", "url": "https://github.com/apache/iotdb/commit/46a133be76a76048e5e3b677f04313ff4f18d4ea", "message": "add log in hasNextOverlappedPage", "committedDate": "2020-03-02T07:55:54Z", "type": "commit"}, {"oid": "6ba29699230d29b7f2f6587c26a179bad14748c4", "url": "https://github.com/apache/iotdb/commit/6ba29699230d29b7f2f6587c26a179bad14748c4", "message": "Optimize_series_reader_fix (#867)\n\n* del callable task\r\n* move querysource to GroupByExecutor\r\n* skip chunk", "committedDate": "2020-03-02T08:17:47Z", "type": "commit"}, {"oid": "80456bd9f30524426fb93bc587cd571f2ce87b07", "url": "https://github.com/apache/iotdb/commit/80456bd9f30524426fb93bc587cd571f2ce87b07", "message": "add log", "committedDate": "2020-03-02T08:35:09Z", "type": "commit"}, {"oid": "23d620a3e0053d717dc8fed35b1ad742355cd726", "url": "https://github.com/apache/iotdb/commit/23d620a3e0053d717dc8fed35b1ad742355cd726", "message": "Merge remote-tracking branch 'origin/optimize_series_reader' into optimize_series_reader", "committedDate": "2020-03-02T08:35:39Z", "type": "commit"}, {"oid": "395486070c7e86f8e57b8d572904ec30d57f423e", "url": "https://github.com/apache/iotdb/commit/395486070c7e86f8e57b8d572904ec30d57f423e", "message": "fix tmp bug", "committedDate": "2020-03-02T08:55:54Z", "type": "commit"}, {"oid": "2d6e8fc825ab4a954756b9c2852837e043c5ba65", "url": "https://github.com/apache/iotdb/commit/2d6e8fc825ab4a954756b9c2852837e043c5ba65", "message": "remove debug log", "committedDate": "2020-03-02T09:15:53Z", "type": "commit"}, {"oid": "60c0f5e5b5a1ed53e04a00b77e6653ebaeb9d7d1", "url": "https://github.com/apache/iotdb/commit/60c0f5e5b5a1ed53e04a00b77e6653ebaeb9d7d1", "message": "add test and fix review", "committedDate": "2020-03-02T10:00:49Z", "type": "commit"}, {"oid": "ad50583d89fe5e420c1552df9f99190450da19d0", "url": "https://github.com/apache/iotdb/commit/ad50583d89fe5e420c1552df9f99190450da19d0", "message": "fix code smell", "committedDate": "2020-03-02T10:10:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTcwNA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386341704", "bodyText": "methods in this class could not be public", "author": "samperson1997", "createdAt": "2020-03-02T11:35:04Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -114,159 +97,194 @@ protected RowRecord nextWithoutConstraint() throws IOException {\n     }\n     hasCachedTimeInterval = false;\n     RowRecord record = new RowRecord(curStartTime);\n-    AggregateResult[] aggregateResultList = new AggregateResult[paths.size()];\n-    for (Map.Entry<Path, List<Integer>> entry : pathToAggrIndexesMap.entrySet()) {\n-      List<AggregateResult> aggregateResults;\n-      try {\n-        aggregateResults = nextIntervalAggregation(entry);\n-      } catch (QueryProcessException e) {\n-        throw new IOException(e);\n-      }\n-      int index = 0;\n-      for (int i : entry.getValue()) {\n-        aggregateResultList[i] = aggregateResults.get(index);\n-        index++;\n+    timeRange = new TimeRange(curStartTime, curEndTime - 1);\n+\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Entry<Path, GroupByExecutor> pathGroupByExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathGroupByExecutorEntry.getValue();\n+        executor.resetAggregateResults();\n+        List<Pair<AggregateResult, Integer>> aggregations = executor.calcResult();\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          fields[aggregations.get(i).right] = aggregations.get(i).left;\n+        }\n       }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error,{}\", e);\n+      throw new IOException(e.getMessage(), e);\n     }\n-    if (aggregateResultList.length == 0) {\n-      record.addField(new Field(null));\n-    } else {\n-      for (AggregateResult res : aggregateResultList) {\n-        record.addField(res.getResult(), res.getResultDataType());\n+\n+    for (AggregateResult res : fields) {\n+      if (res == null) {\n+        record.addField(null);\n+        continue;\n       }\n+      record.addField(res.getResult(), res.getResultDataType());\n     }\n     return record;\n   }\n \n-  /**\n-   * calculate the group by result of one series\n-   *\n-   * @param pathToAggrIndexes entry of path to aggregation indexes map\n-   */\n-  private List<AggregateResult> nextIntervalAggregation(Map.Entry<Path,\n-      List<Integer>> pathToAggrIndexes) throws IOException, QueryProcessException {\n-    List<AggregateResult> aggregateResultList = new ArrayList<>();\n-    List<Boolean> isCalculatedList = new ArrayList<>();\n-    List<Integer> indexList = pathToAggrIndexes.getValue();\n-\n-    int remainingToCalculate = indexList.size();\n-    TSDataType tsDataType = groupByPlan.getDeduplicatedDataTypes().get(indexList.get(0));\n-\n-    for (int index : indexList) {\n-      AggregateResult result = AggregateResultFactory\n-          .getAggrResultByName(groupByPlan.getDeduplicatedAggregations().get(index), tsDataType);\n-      aggregateResultList.add(result);\n-\n-      BatchData lastBatch = cachedBatchDataList.get(index);\n-\n-      calcBatchData(result, lastBatch);\n-      if (isEndCalc(result, lastBatch)) {\n-        isCalculatedList.add(true);\n-        remainingToCalculate--;\n-        if (remainingToCalculate == 0) {\n-          return aggregateResultList;\n+  private class GroupByExecutor {\n+\n+    private IAggregateReader reader;\n+    private BatchData preCachedData;\n+    //<aggFunction - indexForRecord> of path\n+    private List<Pair<AggregateResult, Integer>> results = new ArrayList<>();\n+\n+    public GroupByExecutor(Path path, TSDataType dataType, QueryContext context, Filter timeFilter)", "originalCommit": "ad50583d89fe5e420c1552df9f99190450da19d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MjY0NA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386372644", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T12:49:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MTcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MjU4Ng==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386342586", "bodyText": "This certainly initialize reader, but I think the comment should better be init GroupByExecutor", "author": "samperson1997", "createdAt": "2020-03-02T11:37:11Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -64,45 +63,29 @@ public GroupByWithoutValueFilterDataSet(QueryContext context, GroupByPlan groupB\n       throws StorageEngineException {\n     super(context, groupByPlan);\n \n-    this.pathToAggrIndexesMap = new HashMap<>();\n-    this.aggregateReaders = new HashMap<>();\n-    this.cachedBatchDataList = new ArrayList<>();\n-    for (int i = 0; i < paths.size(); i++) {\n-      cachedBatchDataList.add(null);\n-    }\n     initGroupBy(context, groupByPlan);\n   }\n \n-  /**\n-   * init reader and aggregate function.\n-   */\n   private void initGroupBy(QueryContext context, GroupByPlan groupByPlan)\n       throws StorageEngineException {\n     IExpression expression = groupByPlan.getExpression();\n-    this.groupByPlan = groupByPlan;\n \n     Filter timeFilter = null;\n-    // init reader\n     if (expression != null) {\n       timeFilter = ((GlobalTimeExpression) expression).getFilter();\n     }\n \n     for (int i = 0; i < paths.size(); i++) {\n       Path path = paths.get(i);\n-      List<Integer> indexList = pathToAggrIndexesMap\n-          .computeIfAbsent(path, key -> new ArrayList<>());\n-      indexList.add(i);\n-      if (!aggregateReaders.containsKey(path)) {\n-\n-        QueryDataSource queryDataSource = QueryResourceManager.getInstance()\n-            .getQueryDataSource(path, context, timeFilter);\n-        // update filter by TTL\n-        timeFilter = queryDataSource.updateFilterUsingTTL(timeFilter);\n-\n-        IAggregateReader seriesReader = new SeriesAggregateReader(path, dataTypes.get(i), context,\n-            queryDataSource, timeFilter, null, null);\n-        aggregateReaders.put(path, seriesReader);\n+      if (!pathExecutors.containsKey(path)) {\n+        //init reader", "originalCommit": "ad50583d89fe5e420c1552df9f99190450da19d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MTcyMw==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386371723", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T12:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0MjU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTQwMQ==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386349401", "bodyText": "The template T of VersionPair is only used as IPageReader... I think it is not necessary to keep T. Instead, just use:\nprivate class VersionPair {\n\n    protected long version;\n    protected IPageReader pageReader;\n\n    public VersionPair(long version, IPageReader pageReader) {\n      this.version = version;\n      this.pageReader = pageReader;\n    }\n  }\n\nWhat do you think?", "author": "samperson1997", "createdAt": "2020-03-02T11:53:17Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -55,26 +55,48 @@\n   private final Path seriesPath;\n   private final TSDataType dataType;\n   private final QueryContext context;\n+\n+  /*\n+   * There is at most one is not null between timeFilter and valueFilter\n+   *\n+   * timeFilter is pushed down to all pages (seq, unseq) without correctness problem\n+   *\n+   * valueFilter is pushed down to non-overlapped page only\n+   */\n   private final Filter timeFilter;\n   private final Filter valueFilter;\n \n+  /*\n+   * file cache\n+   */\n   private final List<TsFileResource> seqFileResource;\n   private final PriorityQueue<TsFileResource> unseqFileResource;\n \n+  /*\n+   * chunk cache\n+   */\n+  private ChunkMetaData firstChunkMetaData;\n   private final List<ChunkMetaData> seqChunkMetadatas = new LinkedList<>();\n   private final PriorityQueue<ChunkMetaData> unseqChunkMetadatas =\n       new PriorityQueue<>(Comparator.comparingLong(ChunkMetaData::getStartTime));\n \n-  private boolean hasCachedFirstChunkMetadata;\n-  private ChunkMetaData firstChunkMetaData;\n-\n-  private PriorityQueue<VersionPair<IPageReader>> overlappedPageReaders =\n+  /*\n+   * page cache\n+   */\n+  private VersionPair<IPageReader> firstPageReader;\n+  private PriorityQueue<VersionPair<IPageReader>> cachedPageReaders =", "originalCommit": "ad50583d89fe5e420c1552df9f99190450da19d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MTExNA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386371114", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T12:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTg3Ng==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386349876", "bodyText": "The name is confusing... Rename the class VersionPair to VersionReaderPair? Or something like that.", "author": "samperson1997", "createdAt": "2020-03-02T11:54:23Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -55,26 +55,48 @@\n   private final Path seriesPath;\n   private final TSDataType dataType;\n   private final QueryContext context;\n+\n+  /*\n+   * There is at most one is not null between timeFilter and valueFilter\n+   *\n+   * timeFilter is pushed down to all pages (seq, unseq) without correctness problem\n+   *\n+   * valueFilter is pushed down to non-overlapped page only\n+   */\n   private final Filter timeFilter;\n   private final Filter valueFilter;\n \n+  /*\n+   * file cache\n+   */\n   private final List<TsFileResource> seqFileResource;\n   private final PriorityQueue<TsFileResource> unseqFileResource;\n \n+  /*\n+   * chunk cache\n+   */\n+  private ChunkMetaData firstChunkMetaData;\n   private final List<ChunkMetaData> seqChunkMetadatas = new LinkedList<>();\n   private final PriorityQueue<ChunkMetaData> unseqChunkMetadatas =\n       new PriorityQueue<>(Comparator.comparingLong(ChunkMetaData::getStartTime));\n \n-  private boolean hasCachedFirstChunkMetadata;\n-  private ChunkMetaData firstChunkMetaData;\n-\n-  private PriorityQueue<VersionPair<IPageReader>> overlappedPageReaders =\n+  /*\n+   * page cache\n+   */\n+  private VersionPair<IPageReader> firstPageReader;", "originalCommit": "ad50583d89fe5e420c1552df9f99190450da19d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MTA1MQ==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386371051", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T12:45:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM0OTg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MTU4OA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386351588", "bodyText": "Codes like this in the class obey Law of Demeter a lot. I suggest adding methods getStatistics() and  getAllSatisfiedPageData() in the inner class VersionPair", "author": "samperson1997", "createdAt": "2020-03-02T11:58:29Z", "path": "server/src/main/java/org/apache/iotdb/db/query/reader/series/SeriesReader.java", "diffHunk": "@@ -104,251 +126,305 @@ public SeriesReader(Path seriesPath, TSDataType dataType, QueryContext context,\n \n \n   public boolean hasNextChunk() throws IOException {\n-    if (hasCachedFirstChunkMetadata) {\n+\n+    if (!cachedPageReaders.isEmpty() || firstPageReader != null || mergeReader\n+        .hasNextTimeValuePair()) {\n+      throw new IOException(\"all cached pages should be consumed first\");\n+    }\n+\n+    if (firstChunkMetaData != null) {\n       return true;\n     }\n+\n     // init first chunk metadata whose startTime is minimum\n-    tryToInitFirstChunk();\n+    tryToUnpackAllOverlappedFilesToChunkMetadatas();\n \n-    return hasCachedFirstChunkMetadata;\n+    return firstChunkMetaData != null;\n   }\n \n-  /**\n-   * Because seq data and unseq data intersect, the minimum startTime taken from two files at a time\n-   * is used as the reference time to start reading data\n-   */\n-  private void tryToInitFirstChunk() throws IOException {\n-    tryToFillChunkMetadatas();\n-    hasCachedFirstChunkMetadata = true;\n-    if (!seqChunkMetadatas.isEmpty() && unseqChunkMetadatas.isEmpty()) {\n-      // only has seq\n-      firstChunkMetaData = seqChunkMetadatas.remove(0);\n-    } else if (seqChunkMetadatas.isEmpty() && !unseqChunkMetadatas.isEmpty()) {\n-      // only has unseq\n-      firstChunkMetaData = unseqChunkMetadatas.poll();\n-    } else if (!seqChunkMetadatas.isEmpty()) {\n-      // has seq and unseq\n-      if (seqChunkMetadatas.get(0).getStartTime() <= unseqChunkMetadatas.peek().getStartTime()) {\n-        firstChunkMetaData = seqChunkMetadatas.remove(0);\n-      } else {\n-        firstChunkMetaData = unseqChunkMetadatas.poll();\n-      }\n-    } else {\n-      // no seq nor unseq\n-      hasCachedFirstChunkMetadata = false;\n-    }\n-    tryToFillChunkMetadatas();\n-  }\n \n   public boolean isChunkOverlapped() {\n     Statistics chunkStatistics = firstChunkMetaData.getStatistics();\n-    return mergeReader.hasNextTimeValuePair()\n-        || (!seqChunkMetadatas.isEmpty()\n-        && chunkStatistics.getEndTime() >= seqChunkMetadatas.get(0).getStartTime())\n-        || (!unseqChunkMetadatas.isEmpty()\n-        && chunkStatistics.getEndTime() >= unseqChunkMetadatas.peek().getStartTime());\n+    return !seqChunkMetadatas.isEmpty()\n+        && chunkStatistics.getEndTime() >= seqChunkMetadatas.get(0).getStartTime()\n+        || !unseqChunkMetadatas.isEmpty()\n+        && chunkStatistics.getEndTime() >= unseqChunkMetadatas.peek().getStartTime();\n   }\n \n   public Statistics currentChunkStatistics() {\n     return firstChunkMetaData.getStatistics();\n   }\n \n   public void skipCurrentChunk() {\n-    hasCachedFirstChunkMetadata = false;\n     firstChunkMetaData = null;\n   }\n \n   /**\n-   * This method should be called after hasNxtChunk\n-   * @return\n-   * @throws IOException\n+   * This method should be called after hasNextChunk() until no next page,\n+   * make sure that all overlapped pages are consumed\n    */\n   public boolean hasNextPage() throws IOException {\n-    if (!overlappedPageReaders.isEmpty()) {\n+\n+    /*\n+     * has overlapped data before\n+     */\n+    if (hasCachedNextOverlappedPage) {\n       return true;\n+    } else if (mergeReader.hasNextTimeValuePair()) {\n+      if (hasNextOverlappedPage()) {\n+        cachedBatchData = nextOverlappedPage();\n+        if (cachedBatchData != null && cachedBatchData.hasCurrent()) {\n+          hasCachedNextOverlappedPage = true;\n+          return true;\n+        }\n+      }\n     }\n \n-    fillOverlappedPageReaders();\n+    if (firstPageReader != null) {\n+      return true;\n+    }\n \n-    return !overlappedPageReaders.isEmpty();\n+    /*\n+     * construct first page reader\n+     */\n+    if (firstChunkMetaData != null) {\n+      /*\n+       * try to unpack all overlapped ChunkMetadata to cachedPageReaders\n+       */\n+      unpackAllOverlappedChunkMetadataToCachedPageReaders(firstChunkMetaData.getEndTime());\n+    } else {\n+      /*\n+       * first chunk metadata is already unpacked, consume cached pages\n+       */\n+      if (!cachedPageReaders.isEmpty()) {\n+        firstPageReader = cachedPageReaders.poll();\n+      }\n+    }\n+\n+    if (firstPageReader != null && !cachedPageReaders.isEmpty() &&\n+        firstPageReader.data.getStatistics().getEndTime() >=", "originalCommit": "ad50583d89fe5e420c1552df9f99190450da19d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MTAxNA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386371014", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T12:45:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MTU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1Mjc5Ng==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386352796", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\n          \n          \n            \n                  for (String sql : TestConstant.create_sql) {\n          \n      \n    \n    \n  \n\nAnd all the same appearance in this test class : )", "author": "samperson1997", "createdAt": "2020-03-02T12:01:32Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBCloseIT.java", "diffHunk": "@@ -85,7 +86,7 @@ private static void insertData()\n             .getConnection(Config.IOTDB_URL_PREFIX + \"127.0.0.1:6667/\", \"root\", \"root\");\n          Statement statement = connection.createStatement()) {\n \n-      for (String sql : Constant.create_sql) {\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {", "originalCommit": "ad50583d89fe5e420c1552df9f99190450da19d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NzYyNA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386367624", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T12:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1Mjc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MjkxOA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386352918", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\n          \n          \n            \n                  for (String sql : TestConstant.create_sql) {\n          \n      \n    \n    \n  \n\nAnd all the same appearance in this test class : )", "author": "samperson1997", "createdAt": "2020-03-02T12:01:48Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBEngineTimeGeneratorIT.java", "diffHunk": "@@ -100,7 +101,7 @@ private static void insertData() throws ClassNotFoundException, SQLException {\n         Statement statement = connection.createStatement()) {\n \n       // create storage group and measurement\n-      for (String sql : Constant.create_sql) {\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {", "originalCommit": "ad50583d89fe5e420c1552df9f99190450da19d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NzU5Mw==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386367593", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T12:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1MjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1Mzk0Nw==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386353947", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\n          \n          \n            \n                  for (String sql : TestConstant.create_sql) {\n          \n      \n    \n    \n  \n\nAnd all the same appearance in this test class : )", "author": "samperson1997", "createdAt": "2020-03-02T12:04:23Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBLargeDataIT.java", "diffHunk": "@@ -89,7 +90,7 @@ private static void insertData()\n         .getConnection(Config.IOTDB_URL_PREFIX + \"127.0.0.1:6667/\", \"root\", \"root\");\r\n         Statement statement = connection.createStatement()) {\r\n \r\n-      for (String sql : Constant.create_sql) {\r\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\r", "originalCommit": "ad50583d89fe5e420c1552df9f99190450da19d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NzU2NQ==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386367565", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T12:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1Mzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1NDEzOA==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386354138", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static boolean testFlag = org.apache.iotdb.db.constant.TestConstant.testFlag;\n          \n          \n            \n              private static boolean testFlag = TestConstant.testFlag;\n          \n      \n    \n    \n  \n\nAnd all the same appearance in this test class : )", "author": "samperson1997", "createdAt": "2020-03-02T12:04:51Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiSeriesIT.java", "diffHunk": "@@ -43,7 +44,7 @@\n  */\r\n public class IoTDBMultiSeriesIT {\r\n \r\n-  private static boolean testFlag = Constant.testFlag;\r\n+  private static boolean testFlag = org.apache.iotdb.db.constant.TestConstant.testFlag;\r", "originalCommit": "ad50583d89fe5e420c1552df9f99190450da19d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1NTAzNQ==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386355035", "bodyText": "And also in other test classes...", "author": "samperson1997", "createdAt": "2020-03-02T12:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1NDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2NzUxNg==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386367516", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T12:37:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM1NDEzOA=="}], "type": "inlineReview"}, {"oid": "8f5cf8b25bf191ef062e036a1efc9fe8821b33bd", "url": "https://github.com/apache/iotdb/commit/8f5cf8b25bf191ef062e036a1efc9fe8821b33bd", "message": "Update server/src/test/java/org/apache/iotdb/db/integration/IoTDBCloseIT.java\n\nCo-Authored-By: Zesong Sun <szs19@mails.tsinghua.edu.cn>", "committedDate": "2020-03-02T12:46:16Z", "type": "commit"}, {"oid": "e455a9608807d0331d764a9dbf23bfdd8d863cea", "url": "https://github.com/apache/iotdb/commit/e455a9608807d0331d764a9dbf23bfdd8d863cea", "message": "fix review", "committedDate": "2020-03-02T12:49:28Z", "type": "commit"}, {"oid": "2843e8cd200311702bbdcce8ed7ca0919dae5e3c", "url": "https://github.com/apache/iotdb/commit/2843e8cd200311702bbdcce8ed7ca0919dae5e3c", "message": "Merge remote-tracking branch 'origin/optimize_series_reader' into optimize_series_reader", "committedDate": "2020-03-02T12:49:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2ODg2Mw==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386368863", "bodyText": "no need to use {},just\nlogger.error(\"GroupByWithoutValueFilterDataSet execute has error \", e);", "author": "JackieTien97", "createdAt": "2020-03-02T12:40:28Z", "path": "server/src/main/java/org/apache/iotdb/db/query/dataset/groupby/GroupByWithoutValueFilterDataSet.java", "diffHunk": "@@ -114,159 +97,194 @@ protected RowRecord nextWithoutConstraint() throws IOException {\n     }\n     hasCachedTimeInterval = false;\n     RowRecord record = new RowRecord(curStartTime);\n-    AggregateResult[] aggregateResultList = new AggregateResult[paths.size()];\n-    for (Map.Entry<Path, List<Integer>> entry : pathToAggrIndexesMap.entrySet()) {\n-      List<AggregateResult> aggregateResults;\n-      try {\n-        aggregateResults = nextIntervalAggregation(entry);\n-      } catch (QueryProcessException e) {\n-        throw new IOException(e);\n-      }\n-      int index = 0;\n-      for (int i : entry.getValue()) {\n-        aggregateResultList[i] = aggregateResults.get(index);\n-        index++;\n+    timeRange = new TimeRange(curStartTime, curEndTime - 1);\n+\n+    AggregateResult[] fields = new AggregateResult[paths.size()];\n+\n+    try {\n+      for (Entry<Path, GroupByExecutor> pathGroupByExecutorEntry : pathExecutors.entrySet()) {\n+        GroupByExecutor executor = pathGroupByExecutorEntry.getValue();\n+        executor.resetAggregateResults();\n+        List<Pair<AggregateResult, Integer>> aggregations = executor.calcResult();\n+        for (int i = 0; i < aggregations.size(); i++) {\n+          fields[aggregations.get(i).right] = aggregations.get(i).left;\n+        }\n       }\n+    } catch (QueryProcessException e) {\n+      logger.error(\"GroupByWithoutValueFilterDataSet execute has error,{}\", e);", "originalCommit": "ad50583d89fe5e420c1552df9f99190450da19d0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwNjI3NQ==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386406275", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T13:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2ODg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MjcyMg==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386372722", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {\n          \n          \n            \n                  for (String sql : TestConstant.create_sql) {", "author": "JackieTien97", "createdAt": "2020-03-02T12:49:24Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiStatementsIT.java", "diffHunk": "@@ -85,7 +86,7 @@ private static void insertData()\n             .getConnection(Config.IOTDB_URL_PREFIX + \"127.0.0.1:6667/\", \"root\", \"root\");\n          Statement statement = connection.createStatement()) {\n \n-      for (String sql : Constant.create_sql) {\n+      for (String sql : org.apache.iotdb.db.constant.TestConstant.create_sql) {", "originalCommit": "8f5cf8b25bf191ef062e036a1efc9fe8821b33bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQwNTg1Mg==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386405852", "bodyText": "fixed", "author": "qiaojialin", "createdAt": "2020-03-02T13:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MjcyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3Mjk1Ng==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386372956", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    builder.append(resultSet1.getString(org.apache.iotdb.db.constant.TestConstant.TIMESTAMP_STR))\n          \n          \n            \n                    builder.append(resultSet1.getString(TestConstant.TIMESTAMP_STR))", "author": "JackieTien97", "createdAt": "2020-03-02T12:49:55Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiStatementsIT.java", "diffHunk": "@@ -138,7 +139,7 @@ public void selectAllTest() throws ClassNotFoundException {\n       int cnt1 = 0;\n       while (resultSet1.next() && cnt1 < 5) {\n         StringBuilder builder = new StringBuilder();\n-        builder.append(resultSet1.getString(Constant.TIMESTAMP_STR))\n+        builder.append(resultSet1.getString(org.apache.iotdb.db.constant.TestConstant.TIMESTAMP_STR))", "originalCommit": "8f5cf8b25bf191ef062e036a1efc9fe8821b33bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3MzA4MQ==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386373081", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    builder.append(resultSet2.getString(org.apache.iotdb.db.constant.TestConstant.TIMESTAMP_STR))\n          \n          \n            \n                    builder.append(resultSet2.getString(TestConstant.TIMESTAMP_STR))", "author": "JackieTien97", "createdAt": "2020-03-02T12:50:11Z", "path": "server/src/test/java/org/apache/iotdb/db/integration/IoTDBMultiStatementsIT.java", "diffHunk": "@@ -154,7 +155,7 @@ public void selectAllTest() throws ClassNotFoundException {\n       int cnt2 = 0;\n       while (resultSet2.next()) {\n         StringBuilder builder = new StringBuilder();\n-        builder.append(resultSet2.getString(Constant.TIMESTAMP_STR))\n+        builder.append(resultSet2.getString(org.apache.iotdb.db.constant.TestConstant.TIMESTAMP_STR))", "originalCommit": "8f5cf8b25bf191ef062e036a1efc9fe8821b33bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM3NDU3MQ==", "url": "https://github.com/apache/iotdb/pull/864#discussion_r386374571", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static String filePath1 = org.apache.iotdb.db.constant.TestConstant.BASE_OUTPUT_PATH.concat(\"watermarked_query_result.csv\");\n          \n          \n            \n              private static String filePath2 = org.apache.iotdb.db.constant.TestConstant.BASE_OUTPUT_PATH.concat(\"notWatermarked_query_result.csv\");\n          \n          \n            \n              private static String filePath1 = TestConstant.BASE_OUTPUT_PATH.concat(\"watermarked_query_result.csv\");\n          \n          \n            \n              private static String filePath2 = TestConstant.BASE_OUTPUT_PATH.concat(\"notWatermarked_query_result.csv\");", "author": "JackieTien97", "createdAt": "2020-03-02T12:53:11Z", "path": "server/src/test/java/org/apache/iotdb/db/tools/IoTDBWatermarkTest.java", "diffHunk": "@@ -48,8 +45,8 @@\n  */\n public class IoTDBWatermarkTest {\n \n-  private static String filePath1 = TestConstant.BASE_OUTPUT_PATH.concat(\"watermarked_query_result.csv\");\n-  private static String filePath2 = TestConstant.BASE_OUTPUT_PATH.concat(\"notWatermarked_query_result.csv\");\n+  private static String filePath1 = org.apache.iotdb.db.constant.TestConstant.BASE_OUTPUT_PATH.concat(\"watermarked_query_result.csv\");\n+  private static String filePath2 = org.apache.iotdb.db.constant.TestConstant.BASE_OUTPUT_PATH.concat(\"notWatermarked_query_result.csv\");", "originalCommit": "2843e8cd200311702bbdcce8ed7ca0919dae5e3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7a2851965acf0215719ea2344703cfd43a8cc380", "url": "https://github.com/apache/iotdb/commit/7a2851965acf0215719ea2344703cfd43a8cc380", "message": "fix import", "committedDate": "2020-03-02T12:54:00Z", "type": "commit"}, {"oid": "9101bcfee5715c078f28babe4d8bc41fc726c92d", "url": "https://github.com/apache/iotdb/commit/9101bcfee5715c078f28babe4d8bc41fc726c92d", "message": "fix review", "committedDate": "2020-03-02T13:57:33Z", "type": "commit"}]}