{"pr_number": 821, "pr_title": "[IOTDB-298]Last time-value query", "pr_createdAt": "2020-02-17T18:35:36Z", "pr_url": "https://github.com/apache/iotdb/pull/821", "timeline": [{"oid": "553ae3ca291c94906b92d78077cc64afd91e690b", "url": "https://github.com/apache/iotdb/commit/553ae3ca291c94906b92d78077cc64afd91e690b", "message": "Add Last query implement without cache", "committedDate": "2020-02-17T07:28:00Z", "type": "commit"}, {"oid": "b4f7c6f3bc7c48d9ea6f5dd75b9c731420bfa5c4", "url": "https://github.com/apache/iotdb/commit/b4f7c6f3bc7c48d9ea6f5dd75b9c731420bfa5c4", "message": "Add Last query cache in MTree node", "committedDate": "2020-02-17T07:28:00Z", "type": "commit"}, {"oid": "611237160dbe07626588463847e13b3692b80208", "url": "https://github.com/apache/iotdb/commit/611237160dbe07626588463847e13b3692b80208", "message": "Fix null measurement display for last query", "committedDate": "2020-02-17T17:59:30Z", "type": "commit"}, {"oid": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "url": "https://github.com/apache/iotdb/commit/8ba2e9695b4629f0d7d09badf5e796ee562f8451", "message": "Add Missing license comments", "committedDate": "2020-02-18T03:04:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODYyNQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380518625", "bodyText": "what's this for?", "author": "JackieTien97", "createdAt": "2020-02-18T08:26:33Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -22,10 +22,15 @@\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import com.sun.rowset.internal.Row;", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2MTEwNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380561106", "bodyText": "Removed", "author": "wshao08", "createdAt": "2020-02-18T09:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODkwMQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380518901", "bodyText": "this import is not used, please remove it.", "author": "JackieTien97", "createdAt": "2020-02-18T08:27:12Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -22,10 +22,15 @@\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import com.sun.rowset.internal.Row;\n import org.apache.iotdb.db.conf.IoTDBConstant;\n import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2MTE4NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380561185", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-18T09:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUxODkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMTgzMw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380531833", "bodyText": "You can use the chunk and page statistics if possible. The code will be like as:\n        while (seriesReader.hasNextChunk()) {\n            if (seriesReader.canUseCurrentChunkStatistics()) {\n                if (seriesReader.currentChunkStatistics().getEndTime() > maxTime) {\n                    maxTime = seriesReader.currentChunkStatistics().getEndTime();\n                    queryResult.setPairResult(maxTime, seriesReader.currentChunkStatistics().getLastValue(), tsDataType);\n                }\n                seriesReader.skipCurrentChunk();\n                continue;\n            }\n            while (seriesReader.hasNextPage()) {\n                if (seriesReader.canUseCurrentPageStatistics()) {\n                    if (seriesReader.currentPageStatistics().getEndTime() > maxTime) {\n                        maxTime = seriesReader.currentPageStatistics().getEndTime();\n                        queryResult.setPairResult(maxTime, seriesReader.currentPageStatistics().getLastValue(), tsDataType);\n                    }\n                    seriesReader.skipCurrentPage();\n                    continue;\n                }\n                // cal by page data\n                while (seriesReader.hasNextOverlappedPage()) {\n                    BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n                    int maxIndex = nextOverlappedPageData.length() - 1;\n                    if (maxIndex < 0) {\n                        continue;\n                    }\n                    long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n                    if (time > maxTime) {\n                        maxTime = time;\n                        queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n                    }\n                    nextOverlappedPageData.resetBatchData();\n                }\n            }\n        }", "author": "JackieTien97", "createdAt": "2020-02-18T08:54:53Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.constant.SQLConstant;\n+import org.apache.iotdb.db.qp.physical.crud.AggregationPlan;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.factory.AggreResultFactory;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.omg.CORBA.TIMEOUT;\n+\n+import java.io.IOException;\n+import java.sql.Time;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+    private List<Path> selectedSeries;\n+    private List<TSDataType> dataTypes;\n+\n+    public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+        this.selectedSeries = lastQueryPlan.getPaths();\n+        this.dataTypes = lastQueryPlan.getDataTypes();\n+    }\n+\n+    /**\n+     * execute last function\n+     *\n+     * @param context query context\n+     */\n+    public QueryDataSet execute(QueryContext context)\n+            throws StorageEngineException, IOException, QueryProcessException {\n+\n+        List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+        for (int i = 0; i < selectedSeries.size(); i++) {\n+            LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+            lastQueryResultList.add(lastQueryResult);\n+        }\n+\n+        RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+        SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+        dataSet.setRecord(resultRecord);\n+        return dataSet;\n+    }\n+\n+    /**\n+     * get aggregation result for one series\n+     *\n+     * @param context query context\n+     * @return AggregateResult list\n+     */\n+    private LastQueryResult calculateLastPairForOneSeries(\n+            Path seriesPath, TSDataType tsDataType,\n+            QueryContext context)\n+            throws IOException, QueryProcessException, StorageEngineException {\n+        LastQueryResult queryResult = new LastQueryResult();\n+        MNode node = null;\n+        try {\n+            node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+        } catch (PathException e) {\n+            throw new QueryProcessException(e);\n+        } catch (CacheException e) {\n+            throw new QueryProcessException(e.getMessage());\n+        }\n+        if (node.getCachedLast() != null) {\n+            queryResult.setPairResult(node.getCachedLast());\n+            return queryResult;\n+        }\n+\n+        // construct series reader without value filter\n+        Filter timeFilter = null;\n+        IAggregateReader seriesReader = new SeriesAggregateReader(\n+                seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+                .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+        long maxTime = Long.MIN_VALUE;\n+        while (seriesReader.hasNextChunk()) {\n+            while (seriesReader.hasNextPage()) {\n+                // cal by page data\n+                while (seriesReader.hasNextOverlappedPage()) {\n+                    BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+                    int maxIndex = nextOverlappedPageData.length() - 1;\n+                    if (maxIndex < 0) {\n+                        continue;\n+                    }\n+                    long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+                    if (time > maxTime) {\n+                        maxTime = time;\n+                        queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+                    }\n+                    nextOverlappedPageData.resetBatchData();\n+                }\n+            }\n+        }", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxNTY4NA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380815684", "bodyText": "Yes, adopted", "author": "wshao08", "createdAt": "2020-02-18T17:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMTgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMjYzOA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380532638", "bodyText": "A lot of imports are not used. You should check that and delete them", "author": "JackieTien97", "createdAt": "2020-02-18T08:56:26Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.constant.SQLConstant;\n+import org.apache.iotdb.db.qp.physical.crud.AggregationPlan;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.factory.AggreResultFactory;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+import org.omg.CORBA.TIMEOUT;", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU2MTM1Nw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380561357", "bodyText": "Fixed, thanks", "author": "wshao08", "createdAt": "2020-02-18T09:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzMjYzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNzg1OA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380537858", "bodyText": "It is not suitable to put the updateMNodeLastValues method in the InsertPlan.\nYou can update the last value in the before loop, there you already got the measurementNode.", "author": "JackieTien97", "createdAt": "2020-02-18T09:06:03Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -680,6 +674,7 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       }\n       insertPlan.setDataTypes(dataTypes);\n       storageEngine.insert(insertPlan);\n+      insertPlan.updateMNodeLastValues(node);", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgyMTgwNQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380821805", "bodyText": "The update function is moved into MNode structure.\nI added a loop to update the last value after storageEngine.insert(). It is possible that insert() could fail and throw exceptions. In such case the last value cache will not be updated.", "author": "wshao08", "createdAt": "2020-02-18T17:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzNzg1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzODIyOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380538229", "bodyText": "The same as before", "author": "JackieTien97", "createdAt": "2020-02-18T09:06:47Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -772,8 +767,9 @@ private void checkPathExists(MNode node, String fullPath, MeasurementSchema sche\n                   measurementNode.getSchema().getType()));\n         }\n       }\n-      return storageEngine.insertBatch(batchInsertPlan);\n-\n+      Integer[] results = storageEngine.insertBatch(batchInsertPlan);\n+      batchInsertPlan.updateMNodeLastValues(node);", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzOTI5Mw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380539293", "bodyText": "It's better to add it to the last, because you don't know whether the programmers are using the enum's ordinal() function", "author": "JackieTien97", "createdAt": "2020-02-18T09:08:53Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/Operator.java", "diffHunk": "@@ -68,7 +68,7 @@ public String toString() {\n   public enum OperatorType {\n     SFW, JOIN, UNION, FILTER, GROUPBY, ORDERBY, LIMIT, SELECT, SEQTABLESCAN, HASHTABLESCAN,\n     MERGEJOIN, FILEREAD, NULL, TABLESCAN, UPDATE, INSERT, BATCHINSERT, DELETE, BASIC_FUNC, IN, QUERY, MERGEQUERY,\n-    AGGREGATION, AUTHOR, FROM, FUNC, LOADDATA, METADATA, PROPERTY, INDEX, INDEXQUERY, FILL,\n+    AGGREGATION, AUTHOR, FROM, FUNC, LOADDATA, METADATA, PROPERTY, INDEX, INDEXQUERY, FILL, LAST,", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NzUzNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380597536", "bodyText": "Modified", "author": "wshao08", "createdAt": "2020-02-18T10:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUzOTI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDE5NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380540195", "bodyText": "This function is not the InsertPlan's responsibility", "author": "JackieTien97", "createdAt": "2020-02-18T09:10:37Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +292,23 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public void updateMNodeLastValues(MNode node) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {\n+      if (times[i] > maxTime) {\n+        maxTime = times[i];\n+        maxIndex = i;\n+      }\n+    }\n+    for (int i = 0; i < measurements.length; i++) {\n+      if (node.hasChild(measurements[i])) {\n+        Object[] column = (Object[]) columns[i];\n+        node.getChild(measurements[i]).updateCachedLast(maxTime, column[maxIndex], dataTypes[i]);\n+      }\n+    }\n+  }\n+", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NjQ4NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380796485", "bodyText": "Agree. Moved it out of InsertPlan", "author": "wshao08", "createdAt": "2020-02-18T16:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDMzMA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380540330", "bodyText": "Same as before", "author": "JackieTien97", "createdAt": "2020-02-18T09:10:51Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/InsertPlan.java", "diffHunk": "@@ -185,4 +190,13 @@ public void deserializeFrom(ByteBuffer buffer) {\n   public String toString() {\n     return \"deviceId: \" + deviceId + \", time: \" + time;\n   }\n+\n+  public void updateMNodeLastValues(MNode node) throws QueryProcessException {\n+    for (int i = 0; i < measurements.length; i++) {\n+      if (node.hasChild(measurements[i])) {\n+        Object value = CommonUtils.parseValue(dataTypes[i], values[i]);\n+        node.getChild(measurements[i]).updateCachedLast(time, value, dataTypes[i]);\n+      }\n+    }\n+  }", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NjY1MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380796650", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-18T16:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MDMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MTE4NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380541185", "bodyText": "delete it", "author": "JackieTien97", "createdAt": "2020-02-18T09:12:21Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -196,6 +196,7 @@ public static TSDataType getSeriesType(String path) throws QueryProcessException\n         case SQLConstant.FIRST_VALUE:\n         case SQLConstant.MIN_VALUE:\n         case SQLConstant.MAX_VALUE:\n+        //case SQLConstant.LAST:", "originalCommit": "8ba2e9695b4629f0d7d09badf5e796ee562f8451", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU5NjQ5MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r380596490", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-18T10:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDU0MTE4NQ=="}], "type": "inlineReview"}, {"oid": "b03c708f91031dae5dc56044211c8bebe0615fee", "url": "https://github.com/apache/iotdb/commit/b03c708f91031dae5dc56044211c8bebe0615fee", "message": "Remove unused import and adjust code format", "committedDate": "2020-02-18T09:45:24Z", "type": "commit"}, {"oid": "55f9a83f7df0d15a23465438f2122c3231ec4c6e", "url": "https://github.com/apache/iotdb/commit/55f9a83f7df0d15a23465438f2122c3231ec4c6e", "message": "Fix compilation error", "committedDate": "2020-02-18T10:48:57Z", "type": "commit"}, {"oid": "97cfadc0d8dda1ca36204d84a68f680fc6fc4a34", "url": "https://github.com/apache/iotdb/commit/97cfadc0d8dda1ca36204d84a68f680fc6fc4a34", "message": "Clarify last related function behavior", "committedDate": "2020-02-18T16:42:45Z", "type": "commit"}, {"oid": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f", "url": "https://github.com/apache/iotdb/commit/3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f", "message": "Use chunk and page stats when calculating last data", "committedDate": "2020-02-18T17:10:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAyNDI0OQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r381024249", "bodyText": "Why not combine this loop with the before one.", "author": "JackieTien97", "createdAt": "2020-02-19T01:04:04Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -680,6 +683,10 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       }\n       insertPlan.setDataTypes(dataTypes);\n       storageEngine.insert(insertPlan);\n+      for (int i = 0; i < measurementList.length; i++) {\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        measurementNode.updateCachedLast(insertPlan.composeTimeValuePair(i));\n+      }", "originalCommit": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzMjE1Mw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r381032153", "bodyText": "same as before.", "author": "JackieTien97", "createdAt": "2020-02-19T01:33:29Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -772,8 +779,12 @@ private void checkPathExists(MNode node, String fullPath, MeasurementSchema sche\n                   measurementNode.getSchema().getType()));\n         }\n       }\n-      return storageEngine.insertBatch(batchInsertPlan);\n-\n+      Integer[] results = storageEngine.insertBatch(batchInsertPlan);\n+      for (int i = 0; i < measurementList.length; i++) {\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        measurementNode.updateCachedLast(batchInsertPlan.composeLastTimeValuePair(i));\n+      }", "originalCommit": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNDUzOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r381034539", "bodyText": "No matter what measurementIndex is, this calculation process is the same. It only needs to be called once.\nYou can extract that method outside the the calling loop.", "author": "JackieTien97", "createdAt": "2020-02-19T01:42:13Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +291,19 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {\n+      if (times[i] > maxTime) {\n+        maxTime = times[i];\n+        maxIndex = i;\n+      }\n+    }", "originalCommit": "3f02f7c313c7e3dbfae12e0e5ca0cbdfdc61246f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxODI2MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384918260", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-27T05:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNDUzOQ=="}], "type": "inlineReview"}, {"oid": "21e761566a8da68446492e0aa82cedf2bd236291", "url": "https://github.com/apache/iotdb/commit/21e761566a8da68446492e0aa82cedf2bd236291", "message": "Fix last query syntax bug", "committedDate": "2020-02-20T15:30:19Z", "type": "commit"}, {"oid": "afbc0937a690fa07f25edab5e0d2236cda69e068", "url": "https://github.com/apache/iotdb/commit/afbc0937a690fa07f25edab5e0d2236cda69e068", "message": "Add java doc for last", "committedDate": "2020-02-20T15:30:36Z", "type": "commit"}, {"oid": "0abe34f828e8aab11194d8025d95cf4ad44388d2", "url": "https://github.com/apache/iotdb/commit/0abe34f828e8aab11194d8025d95cf4ad44388d2", "message": "Update java doc", "committedDate": "2020-02-20T17:27:47Z", "type": "commit"}, {"oid": "c2ee32b765b44332bbe188126729b187c119746a", "url": "https://github.com/apache/iotdb/commit/c2ee32b765b44332bbe188126729b187c119746a", "message": "Merge remote-tracking branch 'upstream/new_series_reader' into new_series_reader", "committedDate": "2020-02-20T17:47:44Z", "type": "commit"}, {"oid": "409a7b96ecfe3e68fe4d3e09405d33720092a1a4", "url": "https://github.com/apache/iotdb/commit/409a7b96ecfe3e68fe4d3e09405d33720092a1a4", "message": "Add unit test for last", "committedDate": "2020-02-20T18:40:22Z", "type": "commit"}, {"oid": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "url": "https://github.com/apache/iotdb/commit/f43426a7987c156d3d373fbf1cfa1d9858a2815d", "message": "Fix ut compilation error", "committedDate": "2020-02-21T01:12:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4MTIwNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382381206", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()) {\n          \n          \n            \n                } else if (timeValuePair.getTimestamp() >= cachedLastValuePair.getTimestamp()) {\n          \n      \n    \n    \n  \n\ninsert time-value 1-1\ninsert time-value 1-2\nthe vlaue of 1 should be updated to 2", "author": "qiaojialin", "createdAt": "2020-02-21T03:32:36Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MNode.java", "diffHunk": "@@ -238,4 +241,23 @@ public String getFullPath() {\n     }\n     return fullPath = builder.toString();\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public void setCachedLast(TimeValuePair timeValuePair) {\n+    cachedLastValuePair = timeValuePair;\n+  }\n+\n+  public void updateCachedLast(TimeValuePair timeValuePair) {\n+    if (timeValuePair == null)\n+      return;\n+    if (cachedLastValuePair == null) {\n+      cachedLastValuePair = new TimeValuePair(timeValuePair.getTimestamp(), timeValuePair.getValue());\n+    } else if (timeValuePair.getTimestamp() > cachedLastValuePair.getTimestamp()) {", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NTg0Mw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384645843", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-26T17:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM4MTIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MzczMg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382463732", "bodyText": "the time in BatchInsertPlan is always in ascending order, you could directly get the last", "author": "qiaojialin", "createdAt": "2020-02-21T08:57:09Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/crud/BatchInsertPlan.java", "diffHunk": "@@ -288,6 +291,19 @@ public long getMaxTime() {\n     return maxTime;\n   }\n \n+  public TimeValuePair composeLastTimeValuePair(int measurementIndex) {\n+    long maxTime = Long.MIN_VALUE;\n+    int maxIndex = 0;\n+    for (int i = 0; i < times.length; i++) {", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjAwNA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646004", "bodyText": "Done", "author": "wshao08", "createdAt": "2020-02-26T17:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2MzczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NDU3NA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382464574", "bodyText": "the sql needs update", "author": "qiaojialin", "createdAt": "2020-02-21T08:58:52Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/LogicalGenerator.java", "diffHunk": "@@ -1047,6 +1048,16 @@ public void enterSelectElement(SelectElementContext ctx) {\n     queryOp.setSelectOperator(selectOp);\n   }\n \n+  @Override\n+  public void enterLastElement(SqlBaseParser.LastElementContext ctx) {\n+    super.enterLastElement(ctx);\n+    selectOp = new SelectOperator(SQLConstant.TOK_SELECT);\n+    LastFunctionCallContext functionCallContext = ctx.lastFunctionCall();\n+    Path path = parseSuffixPath(functionCallContext.suffixPath());\n+    selectOp.addLastPath(path, functionCallContext.LAST().getText());\n+    queryOp.setSelectOperator(selectOp);", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjgzOA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646838", "bodyText": "Sql syntax updated", "author": "wshao08", "createdAt": "2020-02-26T17:26:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NDU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTYzOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382465639", "bodyText": "The result format should be updated to path, time, value", "author": "qiaojialin", "createdAt": "2020-02-21T09:01:09Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NzAyMA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384647020", "bodyText": "Result set updated", "author": "wshao08", "createdAt": "2020-02-26T17:26:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NTYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NzA5MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382467091", "bodyText": "I think this class is not needed, you could use TimeValuePair directly unless you store the path of a series in this class.", "author": "qiaojialin", "createdAt": "2020-02-21T09:04:14Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;\n+    IAggregateReader seriesReader = new SeriesAggregateReader(\n+            seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+            .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+    long maxTime = Long.MIN_VALUE;\n+    while (seriesReader.hasNextChunk()) {\n+      // cal by chunk statistics\n+      if (seriesReader.canUseCurrentChunkStatistics()) {\n+        Statistics chunkStatistics = seriesReader.currentChunkStatistics();\n+        if (chunkStatistics.getEndTime() > maxTime) {\n+          maxTime = chunkStatistics.getEndTime();\n+          queryResult.setPairResult(maxTime, chunkStatistics.getLastValue(), tsDataType);\n+        }\n+        seriesReader.skipCurrentChunk();\n+        continue;\n+      }\n+      while (seriesReader.hasNextPage()) {\n+        //cal by page statistics\n+        if (seriesReader.canUseCurrentPageStatistics()) {\n+          Statistics pageStatistic = seriesReader.currentPageStatistics();\n+          if (pageStatistic.getEndTime() > maxTime) {\n+            maxTime = pageStatistic.getEndTime();\n+            queryResult.setPairResult(maxTime, pageStatistic.getLastValue(), tsDataType);\n+          }\n+          seriesReader.skipCurrentPage();\n+          continue;\n+        }\n+        // cal by page data\n+        while (seriesReader.hasNextOverlappedPage()) {\n+          BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+          int maxIndex = nextOverlappedPageData.length() - 1;\n+          if (maxIndex < 0) {\n+            continue;\n+          }\n+          long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+          if (time > maxTime) {\n+            maxTime = time;\n+            queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+          }\n+          nextOverlappedPageData.resetBatchData();\n+        }\n+      }\n+    }\n+    if (queryResult.hasResult())\n+      node.setCachedLast(queryResult.getPairResult());\n+    return queryResult;\n+  }\n+\n+  /**\n+   * using last result data list construct QueryDataSet.\n+   *\n+   * @param lastQueryResultList last result list\n+   */\n+  private RowRecord constructLastRowRecord(List<LastQueryResult> lastQueryResultList) {\n+    long maxTime = Long.MIN_VALUE;\n+    for (LastQueryResult lastPair : lastQueryResultList) {\n+      if (lastPair.hasResult() && lastPair.getTimestamp() > maxTime)\n+        maxTime = lastPair.getTimestamp();\n+    }\n+\n+    RowRecord resultRecord = new RowRecord(maxTime);\n+    for (int i = 0; i < lastQueryResultList.size(); i++) {\n+      TSDataType dataType = dataTypes.get(i);\n+      LastQueryResult lastPair = lastQueryResultList.get(i);\n+      if (lastPair.hasResult() && lastPair.getTimestamp() == maxTime)\n+        resultRecord.addField(lastPair.getValue(), dataType);\n+      else\n+        resultRecord.addField(null, dataType);\n+    }\n+\n+    return resultRecord;\n+  }\n+\n+  class LastQueryResult {", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjE3Ng==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646176", "bodyText": "Removed in the new version", "author": "wshao08", "createdAt": "2020-02-26T17:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ2NzA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NjQwNA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382476404", "bodyText": "remove this field and use null directly", "author": "qiaojialin", "createdAt": "2020-02-21T09:24:28Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjI0Mg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646242", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-26T17:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ3NjQwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4MjA0MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r382482041", "bodyText": "Notice:  considering inserting a point while querying.\nIt's better to remove the setCachedLast and change updateCachedLast method to a synchronized one. Then, extend updateCachedLast with a parameter: boolean highPriority, which is to determine whether update the value if the time is equal to the previous cached one.\nThen, in the normal inserting process, update the cache with high priority. Here, update the cache with low priority.\nThis could resolve the condition: there is an insert (10,11) when you get the last point (10,10) from disk.", "author": "qiaojialin", "createdAt": "2020-02-21T09:36:10Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.path.PathException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.aggregation.AggregateResult;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.SingleDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.exception.cache.CacheException;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.filter.basic.Filter;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+          throws StorageEngineException, IOException, QueryProcessException {\n+\n+    List<LastQueryResult> lastQueryResultList = new ArrayList<>();\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      LastQueryResult lastQueryResult = calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      lastQueryResultList.add(lastQueryResult);\n+    }\n+\n+    RowRecord resultRecord = constructLastRowRecord(lastQueryResultList);\n+    SingleDataSet dataSet = new SingleDataSet(selectedSeries, dataTypes);\n+    dataSet.setRecord(resultRecord);\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get aggregation result for one series\n+   *\n+   * @param context query context\n+   * @return AggregateResult list\n+   */\n+  private LastQueryResult calculateLastPairForOneSeries(\n+          Path seriesPath, TSDataType tsDataType,\n+          QueryContext context)\n+          throws IOException, QueryProcessException, StorageEngineException {\n+    LastQueryResult queryResult = new LastQueryResult();\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getNodeByPathFromCache(seriesPath.toString());\n+    } catch (PathException e) {\n+      throw new QueryProcessException(e);\n+    } catch (CacheException e) {\n+      throw new QueryProcessException(e.getMessage());\n+    }\n+    if (node.getCachedLast() != null) {\n+      queryResult.setPairResult(node.getCachedLast());\n+      return queryResult;\n+    }\n+\n+    // construct series reader without value filter\n+    Filter timeFilter = null;\n+    IAggregateReader seriesReader = new SeriesAggregateReader(\n+            seriesPath, tsDataType, context, QueryResourceManager.getInstance()\n+            .getQueryDataSource(seriesPath, context, timeFilter), timeFilter, null);\n+\n+    long maxTime = Long.MIN_VALUE;\n+    while (seriesReader.hasNextChunk()) {\n+      // cal by chunk statistics\n+      if (seriesReader.canUseCurrentChunkStatistics()) {\n+        Statistics chunkStatistics = seriesReader.currentChunkStatistics();\n+        if (chunkStatistics.getEndTime() > maxTime) {\n+          maxTime = chunkStatistics.getEndTime();\n+          queryResult.setPairResult(maxTime, chunkStatistics.getLastValue(), tsDataType);\n+        }\n+        seriesReader.skipCurrentChunk();\n+        continue;\n+      }\n+      while (seriesReader.hasNextPage()) {\n+        //cal by page statistics\n+        if (seriesReader.canUseCurrentPageStatistics()) {\n+          Statistics pageStatistic = seriesReader.currentPageStatistics();\n+          if (pageStatistic.getEndTime() > maxTime) {\n+            maxTime = pageStatistic.getEndTime();\n+            queryResult.setPairResult(maxTime, pageStatistic.getLastValue(), tsDataType);\n+          }\n+          seriesReader.skipCurrentPage();\n+          continue;\n+        }\n+        // cal by page data\n+        while (seriesReader.hasNextOverlappedPage()) {\n+          BatchData nextOverlappedPageData = seriesReader.nextOverlappedPage();\n+          int maxIndex = nextOverlappedPageData.length() - 1;\n+          if (maxIndex < 0) {\n+            continue;\n+          }\n+          long time = nextOverlappedPageData.getTimeByIndex(maxIndex);\n+          if (time > maxTime) {\n+            maxTime = time;\n+            queryResult.setPairResult(maxTime, nextOverlappedPageData.getValueInTimestamp(time), tsDataType);\n+          }\n+          nextOverlappedPageData.resetBatchData();\n+        }\n+      }\n+    }\n+    if (queryResult.hasResult())\n+      node.setCachedLast(queryResult.getPairResult());", "originalCommit": "f43426a7987c156d3d373fbf1cfa1d9858a2815d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0NjQ1Nw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384646457", "bodyText": "Updated, thanks", "author": "wshao08", "createdAt": "2020-02-26T17:25:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQ4MjA0MQ=="}], "type": "inlineReview"}, {"oid": "1f1f2c0279cbbd3931357944655d51d92e953cc3", "url": "https://github.com/apache/iotdb/commit/1f1f2c0279cbbd3931357944655d51d92e953cc3", "message": "Merge remote-tracking branch 'upstream/new_series_reader' into new_series_reader", "committedDate": "2020-02-24T09:04:11Z", "type": "commit"}, {"oid": "3e175b5a2a31f5bcb600d9a4afc811d3b635f299", "url": "https://github.com/apache/iotdb/commit/3e175b5a2a31f5bcb600d9a4afc811d3b635f299", "message": "Merge branch 'master' into new_series_reader", "committedDate": "2020-02-24T09:18:40Z", "type": "commit"}, {"oid": "92c43917a94f540416413eb85ed95c55b606b628", "url": "https://github.com/apache/iotdb/commit/92c43917a94f540416413eb85ed95c55b606b628", "message": "Fix compilation error", "committedDate": "2020-02-24T09:24:05Z", "type": "commit"}, {"oid": "e10aa614335133d5f9dac0d893063fe237cafa3f", "url": "https://github.com/apache/iotdb/commit/e10aa614335133d5f9dac0d893063fe237cafa3f", "message": "Update new version of LAST query in java doc", "committedDate": "2020-02-24T16:38:22Z", "type": "commit"}, {"oid": "5736f861baa2cf0d4a02735450492f2fd2b4946a", "url": "https://github.com/apache/iotdb/commit/5736f861baa2cf0d4a02735450492f2fd2b4946a", "message": "Modify Last query syntax", "committedDate": "2020-02-25T16:17:42Z", "type": "commit"}, {"oid": "c561dc58b9c267c3aa8533f74a6bfa25a310d2ec", "url": "https://github.com/apache/iotdb/commit/c561dc58b9c267c3aa8533f74a6bfa25a310d2ec", "message": "Update last query behavior", "committedDate": "2020-02-26T17:14:03Z", "type": "commit"}, {"oid": "1e65ee361738ebcf5162108b57c42071290a76d6", "url": "https://github.com/apache/iotdb/commit/1e65ee361738ebcf5162108b57c42071290a76d6", "message": "Merge remote-tracking branch 'upstream/master' into new_series_reader", "committedDate": "2020-02-26T17:23:39Z", "type": "commit"}, {"oid": "c137074a1623d27db285673a9e39b161743cd9d0", "url": "https://github.com/apache/iotdb/commit/c137074a1623d27db285673a9e39b161743cd9d0", "message": "Fix test compile issue", "committedDate": "2020-02-27T00:50:50Z", "type": "commit"}, {"oid": "f6fb25b2b7d96e1459911b09844e2418defb7362", "url": "https://github.com/apache/iotdb/commit/f6fb25b2b7d96e1459911b09844e2418defb7362", "message": "Update unit tests for new syntax", "committedDate": "2020-02-27T01:12:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkyOTkxOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384929919", "bodyText": "check this", "author": "qiaojialin", "createdAt": "2020-02-27T06:10:42Z", "path": "docs/Documentation-CHN/UserGuide/5-Operation Manual/2-DML (Data Manipulation Language).md", "diffHunk": "@@ -257,6 +257,39 @@ GROUP BY\u7684SELECT\u5b50\u53e5\u91cc\u7684\u67e5\u8be2\u8def\u5f84\u5fc5\u987b\u662f\u805a\u5408\u51fd\u6570\uff0c\u5426\u5219\u7cfb\u7edf\u5c06\n \n <center><img style=\"width:100%; max-width:800px; max-height:600px; margin-left:auto; margin-right:auto; display:block;\" src=\"https://user-images.githubusercontent.com/16079446/69116099-0b715300-0ac6-11ea-8074-84e04797b8c7.png\"></center>\n \n+### \u6700\u8fd1\u65f6\u95f4\u6233\u6570\u636e\u67e5\u8be2\n+\n+\u5bf9\u5e94\u7684SQL\u8bed\u53e5\u662f\uff1a\n+\n+```\n+select last <Path> [COMMA <Path>]* from < PrefixPath > [COMMA < PrefixPath >]* <DISABLE ALIGN>\n+```\n+\u5176\u542b\u4e49\u662f\uff1a\n+\n+\u67e5\u8be2\u65f6\u95f4\u5e8f\u5217prefixPath.path\u4e2d\u6700\u8fd1\u65f6\u95f4\u6233\u7684\u6570\u636e\n+\n+\u4e0b\u9762\u7684\u4f8b\u5b50\u4e2d\u67e5\u8be2\u65f6\u95f4\u5e8f\u5217root.ln.wf01.wt01.status\u6700\u8fd1\u65f6\u95f4\u6233\u7684\u6570\u636e:\n+```\n+select last(status) from root.ln.wf01.wt01 disable align", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzM2Ng==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593366", "bodyText": "fixed", "author": "wshao08", "createdAt": "2020-02-28T09:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkyOTkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDU3OA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384930578", "bodyText": "move this to LeafMNode", "author": "qiaojialin", "createdAt": "2020-02-27T06:13:31Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -43,6 +44,8 @@\n    */\n   protected String fullPath;\n \n+  private TimeValuePair cachedLastValuePair = null;", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzQyNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593426", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-28T09:36:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDU3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMDc2MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384930761", "bodyText": "add javadoc for highPriorityUpdate", "author": "qiaojialin", "createdAt": "2020-02-27T06:14:11Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -113,4 +116,22 @@ public String getName() {\n   public void setName(String name) {\n     this.name = name;\n   }\n-}\n\\ No newline at end of file\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTI2Mg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384931262", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private boolean hasLast;\n          \n          \n            \n              private boolean lastQuery;", "author": "qiaojialin", "createdAt": "2020-02-27T06:16:04Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java", "diffHunk": "@@ -30,6 +30,7 @@\n \n   private List<Path> suffixList;\n   private List<String> aggregations;\n+  private boolean hasLast;", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTUxNA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384931514", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                } else if (queryOperator.hasLast()) {\n          \n          \n            \n                } else if (queryOperator.isLastQuery()) {", "author": "qiaojialin", "createdAt": "2020-02-27T06:17:04Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/strategy/PhysicalGenerator.java", "diffHunk": "@@ -236,6 +237,8 @@ private PhysicalPlan transformQuery(QueryOperator queryOperator)\n       queryPlan = new AggregationPlan();\n       ((AggregationPlan) queryPlan)\n           .setAggregations(queryOperator.getSelectOperator().getAggregations());\n+    } else if (queryOperator.hasLast()) {", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTcxMQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384931711", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                ListDataSet dataSet =\n          \n          \n            \n                        new ListDataSet(\n          \n          \n            \n                ListDataSet dataSet = new ListDataSet(", "author": "qiaojialin", "createdAt": "2020-02-27T06:17:55Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.series.IAggregateReader;\n+import org.apache.iotdb.db.query.reader.series.SeriesAggregateReader;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.common.BatchData;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet =\n+            new ListDataSet(", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzU2MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593560", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-28T09:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzMTcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNDMwMA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384934300", "bodyText": "\uff1f", "author": "qiaojialin", "createdAt": "2020-02-27T06:28:07Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -646,7 +644,7 @@ private TSExecuteStatementResp executeQueryStatement(\n       resp.setOperationType(plan.getOperatorType().toString());\n       // generate the queryId for the operation\n       long queryId = generateQueryId(true);\n-      // put it into the corresponding Set\n+      // put it into the corresponding SetO", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU5MzYwNQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385593605", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-28T09:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNDMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNDY4MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r384934680", "bodyText": "I don't remember, doesn't the respColumns contain time column?", "author": "qiaojialin", "createdAt": "2020-02-27T06:29:38Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -916,6 +913,15 @@ else if (constMeasurementsLoc < plan.getConstMeasurements().size()\n     plan.setDataTypeConsistencyChecker(null);\n   }\n \n+  private void getLastQueryHeaders(", "originalCommit": "f6fb25b2b7d96e1459911b09844e2418defb7362", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "548e0af47927cc49cafc1fb0d75fc8a73e70a2fa", "url": "https://github.com/apache/iotdb/commit/548e0af47927cc49cafc1fb0d75fc8a73e70a2fa", "message": "Optimize last query process and fix review issues", "committedDate": "2020-02-28T07:08:11Z", "type": "commit"}, {"oid": "c4039c28586158ceb5c2a23f7c9bc10dfee9e1b1", "url": "https://github.com/apache/iotdb/commit/c4039c28586158ceb5c2a23f7c9bc10dfee9e1b1", "message": "Modify last cache update strategy", "committedDate": "2020-02-28T09:28:17Z", "type": "commit"}, {"oid": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "url": "https://github.com/apache/iotdb/commit/2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "message": "Move last cache insert into StorageGroupProcessor", "committedDate": "2020-02-28T10:36:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTI1MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385661250", "bodyText": "add a blank line...", "author": "qiaojialin", "createdAt": "2020-02-28T12:08:40Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/StorageEngine.java", "diffHunk": "@@ -235,7 +235,6 @@ public void insert(InsertPlan insertPlan)\n       throw new QueryProcessException(e);\n     }\n   }\n-", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjc2OQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032769", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2MTgyMg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385661822", "bodyText": "rename this to latestDeviceFlushedTimeInEachPartition distinguish with globalLatestFlushedTimeForEachDevice", "author": "qiaojialin", "createdAt": "2020-02-28T12:10:11Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -178,6 +180,12 @@\n    * file.\n    */\n   private Map<Long, Map<String, Long>> latestFlushedTimeForEachDevice = new HashMap<>();", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2Njc3MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385666771", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n          \n          \n            \n                  long globalLatestFlushTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "author": "qiaojialin", "createdAt": "2020-02-28T12:23:18Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NzM1NA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385667354", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (latestFlushedTime < insertPlan.getTime())\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n          \n          \n            \n                  if (latestFlushedTime < insertPlan.getTime()) {\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n          \n          \n            \n                  }", "author": "qiaojialin", "createdAt": "2020-02-28T12:24:43Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n+\n+      updateInsertPlanLast(insertPlan, latestFlushedTime);\n+      if (latestFlushedTime < insertPlan.getTime())\n+        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MjUxMQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385672511", "bodyText": "Then, move these three lines to insertToTsFileProcessor(), make it updated at the same time as the lastFlushTimeForEachDevice", "author": "qiaojialin", "createdAt": "2020-02-28T12:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NzM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjgxOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032819", "bodyText": "Yes moved, looks better now.", "author": "wshao08", "createdAt": "2020-02-29T14:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY2NzM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3Mjc4NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385672785", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void updateInsertPlanLast(InsertPlan plan, Long latestFlushedTime)\n          \n          \n            \n              public void tryToUpdateCache(InsertPlan plan, Long latestFlushedTime)", "author": "qiaojialin", "createdAt": "2020-02-28T12:38:00Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -496,15 +511,38 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n       latestFlushedTimeForEachDevice.computeIfAbsent(timePartitionId, id -> new HashMap<>())\n           .putIfAbsent(insertPlan.getDeviceId(), Long.MIN_VALUE);\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              insertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // insert to sequence or unSequence file\n       insertToTsFileProcessor(insertPlan,\n           insertPlan.getTime() > latestFlushedTimeForEachDevice.get(timePartitionId)\n               .get(insertPlan.getDeviceId()));\n+\n+      updateInsertPlanLast(insertPlan, latestFlushedTime);\n+      if (latestFlushedTime < insertPlan.getTime())\n+        globalLatestFlushedTimeForEachDevice.put(insertPlan.getDeviceId(), insertPlan.getTime());\n     } finally {\n       writeUnlock();\n     }\n   }\n \n+  public void updateInsertPlanLast(InsertPlan plan, Long latestFlushedTime)", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzM2MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385673361", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n          \n          \n            \n                  long globalLatestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "author": "qiaojialin", "createdAt": "2020-02-28T12:39:20Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzUyOA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385673528", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (latestFlushedTime < batchInsertPlan.getMaxTime())\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n          \n          \n            \n                  if (latestFlushedTime < batchInsertPlan.getMaxTime()) {\n          \n          \n            \n                    globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n          \n          \n            \n                  }", "author": "qiaojialin", "createdAt": "2020-02-28T12:39:45Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n+      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n+      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n+        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzcyNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385673726", "bodyText": "move this into insertBatchToTsFileProcessor()", "author": "qiaojialin", "createdAt": "2020-02-28T12:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzUyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjY1OA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032658", "bodyText": "Moved", "author": "wshao08", "createdAt": "2020-02-29T14:45:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3MzUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NDM1Nw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385674357", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    ((LeafMNode)measurementNode).updateCachedLast(\n          \n          \n            \n                    ((LeafMNode) measurementNode).updateCachedLast(\n          \n      \n    \n    \n  \n\nimport java-google-code.xml  code style and format the code", "author": "qiaojialin", "createdAt": "2020-02-28T12:41:33Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -569,18 +607,40 @@ public void insert(InsertPlan insertPlan) throws QueryProcessException {\n         }\n       }\n \n+      long latestFlushedTime = globalLatestFlushedTimeForEachDevice.computeIfAbsent(\n+              batchInsertPlan.getDeviceId(), k -> Long.MIN_VALUE);\n       // do not forget last part\n       if (before < loc) {\n         insertBatchToTsFileProcessor(batchInsertPlan, before, loc, isSequence, results,\n             beforeTimePartition);\n       }\n+      updateBatchInsertPlanLast(batchInsertPlan, latestFlushedTime);\n+      if (latestFlushedTime < batchInsertPlan.getMaxTime())\n+        globalLatestFlushedTimeForEachDevice.put(batchInsertPlan.getDeviceId(), batchInsertPlan.getMaxTime());\n \n       return results;\n     } finally {\n       writeUnlock();\n     }\n   }\n \n+  public void updateBatchInsertPlanLast(BatchInsertPlan plan, Long latestFlushedTime)\n+          throws QueryProcessException {\n+    try {\n+      MNode node =\n+              MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(plan.getDeviceId());\n+      String[] measurementList = plan.getMeasurements();\n+      for (int i = 0; i < measurementList.length; i++) {\n+        // Update cached last value with high priority\n+        MNode measurementNode = node.getChild(measurementList[i]);\n+        ((LeafMNode)measurementNode).updateCachedLast(", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjY0NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032645", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NDM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTMzNw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385675337", "bodyText": "update javadoc", "author": "qiaojialin", "createdAt": "2020-02-28T12:43:51Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1695,6 +1759,10 @@ private void updateLatestTimeMap(TsFileResource newTsFileResource) {\n             .computeIfAbsent(timePartitionId, id -> new HashMap<String, Long>())\n             .put(device, endTime);\n       }\n+      if (!globalLatestFlushedTimeForEachDevice.containsKey(device)", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTU1Ng==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385675556", "bodyText": "remove", "author": "qiaojialin", "createdAt": "2020-02-28T12:44:26Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/InternalMNode.java", "diffHunk": "@@ -20,6 +20,8 @@\n \n import java.util.LinkedHashMap;\n import java.util.Map;\n+\n+import org.apache.iotdb.tsfile.read.TimeValuePair;", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjY0MA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032640", "bodyText": "Done", "author": "wshao08", "createdAt": "2020-02-29T14:45:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTgxNA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385675814", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {\n          \n          \n            \n                  if (!insertionUpdate || latestFlushedTime <= timeValuePair.getTimestamp()) {", "author": "qiaojialin", "createdAt": "2020-02-28T12:44:58Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;\n+\n+    if (cachedLastValuePair == null){\n+      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n+      if (!insertionUpdate || latestFlushedTime < timeValuePair.getTimestamp()) {", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYzOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032639", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3NjA1NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385676055", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n          \n          \n            \n              public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean updateAtSameTime,\n          \n      \n    \n    \n  \n\nadd java doc", "author": "qiaojialin", "createdAt": "2020-02-28T12:45:33Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODkwOA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385678908", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.\n          \n          \n            \n                  // If no cached last, (1) a last query or (2) an unseq insertion at globalLastFlushTime or (3) a seq insertion will update cache.", "author": "qiaojialin", "createdAt": "2020-02-28T12:52:32Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;\n+\n+    if (cachedLastValuePair == null){\n+      // If no cached last, a last read or an insertion to a sequenceTsFile will update cache.", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODk1NQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385678955", "bodyText": "format", "author": "qiaojialin", "createdAt": "2020-02-28T12:52:38Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/LeafMNode.java", "diffHunk": "@@ -74,4 +77,25 @@ public int getLeafCount() {\n   public MeasurementSchema getSchema() {\n     return schema;\n   }\n+\n+  public TimeValuePair getCachedLast() {\n+    return cachedLastValuePair;\n+  }\n+\n+  public synchronized void updateCachedLast(TimeValuePair timeValuePair, boolean insertionUpdate,\n+                                            Long latestFlushedTime) {\n+    if (timeValuePair == null || timeValuePair.getValue() == null) return;", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYyMw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032623", "bodyText": "Done", "author": "wshao08", "createdAt": "2020-02-29T14:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3ODk1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3OTEwOA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385679108", "bodyText": "remove this and its import", "author": "qiaojialin", "createdAt": "2020-02-28T12:52:58Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/mnode/MNode.java", "diffHunk": "@@ -43,6 +44,8 @@\n    */\n   protected String fullPath;\n \n+  private TimeValuePair cachedLastValuePair = null;", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYyMA==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032620", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:44:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3OTEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY3OTgzNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385679836", "bodyText": "I suggest use addSelectPath to replace this method and add a setLastQuery()", "author": "qiaojialin", "createdAt": "2020-02-28T12:54:52Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/logical/crud/SelectOperator.java", "diffHunk": "@@ -50,6 +52,11 @@ public void addClusterPath(Path suffixPath, String aggregation) {\n     aggregations.add(aggregation);\n   }\n \n+  public void addLastPath(Path suffixPath) {", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDc3Mw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385680773", "bodyText": "extract this to a Tools static method", "author": "qiaojialin", "createdAt": "2020-02-28T12:57:02Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);\n+    return resultPair;\n+  }\n+\n+  private List<ChunkMetaData> loadSatisfiedChunkMetadata(", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjU5Mg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032592", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:43:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDk3MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385680971", "bodyText": "no need to loop, get the last one directly", "author": "qiaojialin", "createdAt": "2020-02-28T12:57:35Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYwMQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032601", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MDk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MTc1MQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385681751", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                TimeValuePair lastPair = new TimeValuePair(timestamp, TsPrimitiveType.getByType(dataType, value));\n          \n          \n            \n                return lastPair;\n          \n          \n            \n                return TimeValuePair(timestamp, TsPrimitiveType.getByType(dataType, value));", "author": "qiaojialin", "createdAt": "2020-02-28T12:59:26Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);\n+    return resultPair;\n+  }\n+\n+  private List<ChunkMetaData> loadSatisfiedChunkMetadata(\n+      TsFileResource resource, Path seriesPath, QueryContext context) throws IOException {\n+    List<ChunkMetaData> currentChunkMetaDataList;\n+    if (resource == null) {\n+      return new ArrayList<>();\n+    }\n+    if (resource.isClosed()) {\n+      currentChunkMetaDataList = DeviceMetaDataCache.getInstance().get(resource, seriesPath);\n+    } else {\n+      currentChunkMetaDataList = resource.getChunkMetaDataList();\n+    }\n+    List<Modification> pathModifications =\n+            context.getPathModifications(resource.getModFile(), seriesPath.getFullPath());\n+\n+    if (!pathModifications.isEmpty()) {\n+      QueryUtils.modifyChunkMetaData(currentChunkMetaDataList, pathModifications);\n+    }\n+\n+    for (ChunkMetaData data : currentChunkMetaDataList) {\n+      if (data.getChunkLoader() == null) {\n+        TsFileSequenceReader tsFileSequenceReader = FileReaderManager.getInstance()\n+                .get(resource, resource.isClosed());\n+        data.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n+      }\n+    }\n+    List<ReadOnlyMemChunk> memChunks = resource.getReadOnlyMemChunk();\n+    if (memChunks != null) {\n+      for (ReadOnlyMemChunk readOnlyMemChunk : memChunks) {\n+        if (!memChunks.isEmpty()) {\n+          currentChunkMetaDataList.add(readOnlyMemChunk.getChunkMetaData());\n+        }\n+      }\n+    }\n+    return currentChunkMetaDataList;\n+  }\n+\n+  private TimeValuePair constructLastPair(long timestamp, Object value, TSDataType dataType) {\n+    TimeValuePair lastPair = new TimeValuePair(timestamp, TsPrimitiveType.getByType(dataType, value));\n+    return lastPair;", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAzMjYwOQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386032609", "bodyText": "Fixed", "author": "wshao08", "createdAt": "2020-02-29T14:44:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MTc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MjQwNw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385682407", "bodyText": "when I saw this line, I think maybe move the lastFlushTime out of the updateCachedLast mehod and check in the insertion is better", "author": "qiaojialin", "createdAt": "2020-02-28T13:01:05Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n+\n+    for (int i = seqFileResources.size() - 1; i >= 0; i--) {\n+      List<ChunkMetaData> chunkMetadata =\n+          loadSatisfiedChunkMetadata(seqFileResources.get(i), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair = constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+        break;\n+      }\n+    }\n+\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata = loadSatisfiedChunkMetadata(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair = constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+\n+    // Update cached last value with low priority\n+    ((LeafMNode)node).updateCachedLast(resultPair, false, Long.MIN_VALUE);", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4MzcxNQ==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r385683715", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);\n          \n          \n            \n                TimeValuePair resultPair;", "author": "qiaojialin", "createdAt": "2020-02-28T13:04:18Z", "path": "server/src/main/java/org/apache/iotdb/db/query/executor/LastQueryExecutor.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.db.query.executor;\n+\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_VALUE;\n+import static org.apache.iotdb.db.conf.IoTDBConstant.COLUMN_TIMESERIES;\n+\n+import org.apache.iotdb.db.engine.cache.DeviceMetaDataCache;\n+import org.apache.iotdb.db.engine.modification.Modification;\n+import org.apache.iotdb.db.engine.querycontext.QueryDataSource;\n+import org.apache.iotdb.db.engine.querycontext.ReadOnlyMemChunk;\n+import org.apache.iotdb.db.engine.storagegroup.TsFileResource;\n+import org.apache.iotdb.db.exception.StorageEngineException;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.mnode.LeafMNode;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.LastQueryPlan;\n+import org.apache.iotdb.db.query.context.QueryContext;\n+import org.apache.iotdb.db.query.control.FileReaderManager;\n+import org.apache.iotdb.db.query.control.QueryResourceManager;\n+import org.apache.iotdb.db.query.dataset.ListDataSet;\n+import org.apache.iotdb.db.query.reader.chunk.DiskChunkLoader;\n+import org.apache.iotdb.db.utils.QueryUtils;\n+import org.apache.iotdb.tsfile.file.metadata.ChunkMetaData;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.statistics.Statistics;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.read.TsFileSequenceReader;\n+import org.apache.iotdb.tsfile.read.common.Field;\n+import org.apache.iotdb.tsfile.read.common.Path;\n+import org.apache.iotdb.tsfile.read.common.RowRecord;\n+import org.apache.iotdb.tsfile.read.query.dataset.QueryDataSet;\n+import org.apache.iotdb.tsfile.utils.Binary;\n+import org.apache.iotdb.tsfile.utils.TsPrimitiveType;\n+\n+import java.io.IOException;\n+import java.util.*;\n+\n+public class LastQueryExecutor {\n+  private List<Path> selectedSeries;\n+  private List<TSDataType> dataTypes;\n+\n+  public LastQueryExecutor(LastQueryPlan lastQueryPlan) {\n+    this.selectedSeries = lastQueryPlan.getPaths();\n+    this.dataTypes = lastQueryPlan.getDataTypes();\n+  }\n+\n+  /**\n+   * execute last function\n+   *\n+   * @param context query context\n+   */\n+  public QueryDataSet execute(QueryContext context)\n+      throws StorageEngineException, IOException, QueryProcessException {\n+\n+    ListDataSet dataSet = new ListDataSet(\n+            Arrays.asList(new Path(COLUMN_TIMESERIES), new Path(COLUMN_VALUE)),\n+            Arrays.asList(TSDataType.TEXT, TSDataType.TEXT));\n+\n+    for (int i = 0; i < selectedSeries.size(); i++) {\n+      TimeValuePair lastTimeValuePair =\n+          calculateLastPairForOneSeries(selectedSeries.get(i), dataTypes.get(i), context);\n+      if (lastTimeValuePair.getValue() != null) {\n+        RowRecord resultRecord = new RowRecord(lastTimeValuePair.getTimestamp());\n+        Field pathField = new Field(TSDataType.TEXT);\n+        pathField.setBinaryV(new Binary(selectedSeries.get(i).getFullPath()));\n+        resultRecord.addField(pathField);\n+\n+        Field valueField = new Field(TSDataType.TEXT);\n+        valueField.setBinaryV(new Binary(lastTimeValuePair.getValue().getStringValue()));\n+        resultRecord.addField(valueField);\n+\n+        dataSet.putRecord(resultRecord);\n+      }\n+    }\n+\n+    return dataSet;\n+  }\n+\n+  /**\n+   * get last result for one series\n+   *\n+   * @param context query context\n+   * @return TimeValuePair\n+   */\n+  private TimeValuePair calculateLastPairForOneSeries(\n+      Path seriesPath, TSDataType tsDataType, QueryContext context)\n+      throws IOException, QueryProcessException, StorageEngineException {\n+\n+    // Retrieve last value from MNode\n+    MNode node = null;\n+    try {\n+      node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+    } catch (MetadataException e) {\n+      throw new QueryProcessException(e);\n+    }\n+    if (((LeafMNode)node).getCachedLast() != null) {\n+      return ((LeafMNode)node).getCachedLast();\n+    }\n+\n+    QueryDataSource dataSource =\n+        QueryResourceManager.getInstance().getQueryDataSource(seriesPath, context, null);\n+\n+    List<TsFileResource> seqFileResources = dataSource.getSeqResources();\n+    List<TsFileResource> unseqFileResources = dataSource.getUnseqResources();\n+\n+    TimeValuePair resultPair = new TimeValuePair(Long.MIN_VALUE, null);", "originalCommit": "2492f8ae47d881ed405a9e0d9c150e0992ca89e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "url": "https://github.com/apache/iotdb/commit/39974ad8a6c173dbc43a0b7fe5f7e971b1325026", "message": "Fix review issues and make code more readable", "committedDate": "2020-02-29T14:37:36Z", "type": "commit"}, {"oid": "6e15c19a473971cb135bf8209fb8bff55464d6bc", "url": "https://github.com/apache/iotdb/commit/6e15c19a473971cb135bf8209fb8bff55464d6bc", "message": "Add more java docs and rename some variables", "committedDate": "2020-03-02T02:14:13Z", "type": "commit"}, {"oid": "f136bcce40237672236cca1f1de738cfb450a9a8", "url": "https://github.com/apache/iotdb/commit/f136bcce40237672236cca1f1de738cfb450a9a8", "message": "Merge remote-tracking branch 'upstream/master' into new_series_reader", "committedDate": "2020-03-02T02:15:15Z", "type": "commit"}, {"oid": "8aa9e2b608c9f6d88a3547a89f19e8229dd0486e", "url": "https://github.com/apache/iotdb/commit/8aa9e2b608c9f6d88a3547a89f19e8229dd0486e", "message": "add sync property file to pass sync test case", "committedDate": "2020-03-02T09:30:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjMzMTQ3Nw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386331477", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Last\u7f13\u5b58\u66f4\u65b0\u7684\u903b\u8f91\u4f4d\u4e8e`LeafNode`\u7684`updateCachedLast`\u65b9\u6cd5\u5185\uff0c\u8fd9\u91cc\u5f15\u5165\u4e24\u4e2a\u989d\u5916\u7684\u53c2\u6570`highPriorityUpdate`\u548c`latestFlushTime`\u3002`highPriorityUpdate`\u7528\u6765\u8868\u793a\u672c\u6b21\u66f4\u65b0\u662f\u5426\u662f\u9ad8\u4f18\u5148\u7ea7\u7684\uff0c\u65b0\u6570\u636e\u5199\u5165\u800c\u5bfc\u81f4\u7684\u7f13\u5b58\u66f4\u65b0\u90fd\u88ab\u8ba4\u4e3a\u662f\u9ad8\u4f18\u5148\u7ea7\u66f4\u65b0\uff0c\u800c\u67e5\u8be2\u65f6\u66f4\u65b0\u7f13\u5b58\u9ed8\u8ba4\u4e3a\u4f4e\u4f18\u5148\u7ea7\u66f4\u65b0\u3002`latestFlushTime`\u7528\u6765\u8bb0\u5f55\u5f53\u524d\u5df2\u88ab\u5199\u56de\u5230\u78c1\u76d8\u7684\u6570\u636e\u7684\u6700\u5927\u65f6\u95f4\u6233\u3002\n          \n          \n            \n            Last\u7f13\u5b58\u66f4\u65b0\u7684\u903b\u8f91\u4f4d\u4e8e`LeafMNode`\u7684`updateCachedLast`\u65b9\u6cd5\u5185\uff0c\u8fd9\u91cc\u5f15\u5165\u4e24\u4e2a\u989d\u5916\u7684\u53c2\u6570`highPriorityUpdate`\u548c`latestFlushTime`\u3002`highPriorityUpdate`\u7528\u6765\u8868\u793a\u672c\u6b21\u66f4\u65b0\u662f\u5426\u662f\u9ad8\u4f18\u5148\u7ea7\u7684\uff0c\u65b0\u6570\u636e\u5199\u5165\u800c\u5bfc\u81f4\u7684\u7f13\u5b58\u66f4\u65b0\u90fd\u88ab\u8ba4\u4e3a\u662f\u9ad8\u4f18\u5148\u7ea7\u66f4\u65b0\uff0c\u800c\u67e5\u8be2\u65f6\u66f4\u65b0\u7f13\u5b58\u9ed8\u8ba4\u4e3a\u4f4e\u4f18\u5148\u7ea7\u66f4\u65b0\u3002`latestFlushTime`\u7528\u6765\u8bb0\u5f55\u5f53\u524d\u5df2\u88ab\u5199\u56de\u5230\u78c1\u76d8\u7684\u6570\u636e\u7684\u6700\u5927\u65f6\u95f4\u6233\u3002", "author": "qiaojialin", "createdAt": "2020-03-02T11:11:42Z", "path": "docs/Documentation-CHN/SystemDesign/5-DataQuery/6-LastQuery.md", "diffHunk": "@@ -0,0 +1,119 @@\n+<!--\n+\n+    Licensed to the Apache Software Foundation (ASF) under one\n+    or more contributor license agreements.  See the NOTICE file\n+    distributed with this work for additional information\n+    regarding copyright ownership.  The ASF licenses this file\n+    to you under the Apache License, Version 2.0 (the\n+    \"License\"); you may not use this file except in compliance\n+    with the License.  You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing,\n+    software distributed under the License is distributed on an\n+    \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+    KIND, either express or implied.  See the License for the\n+    specific language governing permissions and limitations\n+    under the License.\n+\n+-->\n+\n+# \u6700\u8fd1\u65f6\u95f4\u6233 Last \u67e5\u8be2\n+\n+Last \u67e5\u8be2\u7684\u4e3b\u8981\u903b\u8f91\u5728 LastQueryExecutor\n+\n+* org.apache.iotdb.db.query.executor.LastQueryExecutor\n+\n+Last\u67e5\u8be2\u5bf9\u6bcf\u4e2a\u6307\u5b9a\u7684\u65f6\u95f4\u5e8f\u5217\u6267\u884c`calculateLastPairForOneSeries`\u65b9\u6cd5\u3002\n+\n+## \u8bfb\u53d6MNode\u7f13\u5b58\u6570\u636e\n+\n+\u6211\u4eec\u5728\u9700\u8981\u67e5\u8be2\u7684\u65f6\u95f4\u5e8f\u5217\u6240\u5bf9\u5e94\u7684MNode\u7ed3\u6784\u4e2d\u6dfb\u52a0Last\u6570\u636e\u7f13\u5b58\u3002`calculateLastPairForOneSeries`\u65b9\u6cd5\u5bf9\u4e8e\u67d0\u4e2a\u65f6\u95f4\u5e8f\u5217\u7684Last\u67e5\u8be2\uff0c\u9996\u5148\u5c1d\u8bd5\u8bfb\u53d6MNode\u4e2d\u7684\u7f13\u5b58\u6570\u636e\u3002\n+```\n+try {\n+  node = MManager.getInstance().getDeviceNodeWithAutoCreateStorageGroup(seriesPath.toString());\n+} catch (MetadataException e) {\n+  throw new QueryProcessException(e);\n+}\n+if (((LeafMNode) node).getCachedLast() != null) {\n+  return ((LeafMNode) node).getCachedLast();\n+}\n+```\n+\u5982\u679c\u53d1\u73b0\u7f13\u5b58\u6ca1\u6709\u88ab\u5199\u5165\u8fc7\uff0c\u5219\u6267\u884c\u4e0b\u9762\u7684\u6807\u51c6\u67e5\u8be2\u6d41\u7a0b\u8bfb\u53d6TsFile\u6570\u636e\u3002\n+\n+## Last\u6807\u51c6\u67e5\u8be2\u6d41\u7a0b\n+\n+Last\u6807\u51c6\u67e5\u8be2\u6d41\u7a0b\u9700\u8981\u904d\u5386\u6240\u6709\u7684\u987a\u5e8f\u6587\u4ef6\u548c\u4e71\u5e8f\u6587\u4ef6\u5f97\u5230\u67e5\u8be2\u7ed3\u679c\uff0c\u6700\u540e\u5c06\u67e5\u8be2\u7ed3\u679c\u5199\u56de\u5230MNode\u7f13\u5b58\u3002\u7b97\u6cd5\u4e2d\u5bf9\u987a\u5e8f\u6587\u4ef6\u548c\u4e71\u5e8f\u6587\u4ef6\u5206\u522b\u8fdb\u884c\u5904\u7406\u3002\n+- \u987a\u5e8f\u6587\u4ef6\u7531\u4e8e\u662f\u5bf9\u5176\u5199\u5165\u65f6\u95f4\u5df2\u7ecf\u6392\u597d\u5e8f\uff0c\u56e0\u6b64\u76f4\u63a5\u4f7f\u7528`loadChunkMetadataFromTsFileResource`\u65b9\u6cd5\u53d6\u51fa\u6700\u540e\u4e00\u4e2a`ChunkMetadata`\uff0c\u901a\u8fc7`ChunkMetadata`\u7684\u7edf\u8ba1\u6570\u636e\u5f97\u5230\u6700\u5927\u65f6\u95f4\u6233\u548c\u5bf9\u5e94\u7684\u503c\u3002\n+    ```\n+    if (!seqFileResources.isEmpty()) {\n+      List<ChunkMetaData> chunkMetadata =\n+          FileLoaderUtils.loadChunkMetadataFromTsFileResource(\n+              seqFileResources.get(seqFileResources.size() - 1), seriesPath, context);\n+      if (!chunkMetadata.isEmpty()) {\n+        ChunkMetaData lastChunkMetaData = chunkMetadata.get(chunkMetadata.size() - 1);\n+        Statistics chunkStatistics = lastChunkMetaData.getStatistics();\n+        resultPair =\n+            constructLastPair(\n+                chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+      }\n+    }\n+    ```\n+- \u4e71\u5e8f\u6587\u4ef6\u5219\u9700\u8981\u904d\u5386\u6240\u6709\u7684`ChunkMetadata`\u7ed3\u6784\u5f97\u5230\u6700\u5927\u65f6\u95f4\u6233\u6570\u636e\u3002\u9700\u8981\u6ce8\u610f\u7684\u662f\u5f53\u591a\u4e2a`ChunkMetadata`\u62e5\u6709\u76f8\u540c\u7684\u65f6\u95f4\u6233\u65f6\uff0c\u6211\u4eec\u53d6`version`\u503c\u6700\u5927\u7684`ChunkMatadata`\u4e2d\u7684\u6570\u636e\u4f5c\u4e3aLast\u7684\u7ed3\u679c\u3002\n+\n+    ```\n+    long version = 0;\n+    for (TsFileResource resource : unseqFileResources) {\n+      if (resource.getEndTimeMap().get(seriesPath.getDevice()) < resultPair.getTimestamp()) {\n+        break;\n+      }\n+      List<ChunkMetaData> chunkMetadata =\n+          FileLoaderUtils.loadChunkMetadataFromTsFileResource(resource, seriesPath, context);\n+      for (ChunkMetaData chunkMetaData : chunkMetadata) {\n+        if (chunkMetaData.getEndTime() == resultPair.getTimestamp()\n+            && chunkMetaData.getVersion() > version) {\n+          Statistics chunkStatistics = chunkMetaData.getStatistics();\n+          resultPair =\n+              constructLastPair(\n+                  chunkStatistics.getEndTime(), chunkStatistics.getLastValue(), tsDataType);\n+          version = chunkMetaData.getVersion();\n+        }\n+      }\n+    }\n+    ```\n+ - \u6700\u540e\u5c06\u67e5\u8be2\u7ed3\u679c\u5199\u5165\u5230MNode\u7684Last\u7f13\u5b58\n+    ```\n+    ((LeafMNode) node).updateCachedLast(resultPair, false, Long.MIN_VALUE);\n+    ```\n+\n+## Last \u7f13\u5b58\u66f4\u65b0\u7b56\u7565\n+\n+Last\u7f13\u5b58\u66f4\u65b0\u7684\u903b\u8f91\u4f4d\u4e8e`LeafNode`\u7684`updateCachedLast`\u65b9\u6cd5\u5185\uff0c\u8fd9\u91cc\u5f15\u5165\u4e24\u4e2a\u989d\u5916\u7684\u53c2\u6570`highPriorityUpdate`\u548c`latestFlushTime`\u3002`highPriorityUpdate`\u7528\u6765\u8868\u793a\u672c\u6b21\u66f4\u65b0\u662f\u5426\u662f\u9ad8\u4f18\u5148\u7ea7\u7684\uff0c\u65b0\u6570\u636e\u5199\u5165\u800c\u5bfc\u81f4\u7684\u7f13\u5b58\u66f4\u65b0\u90fd\u88ab\u8ba4\u4e3a\u662f\u9ad8\u4f18\u5148\u7ea7\u66f4\u65b0\uff0c\u800c\u67e5\u8be2\u65f6\u66f4\u65b0\u7f13\u5b58\u9ed8\u8ba4\u4e3a\u4f4e\u4f18\u5148\u7ea7\u66f4\u65b0\u3002`latestFlushTime`\u7528\u6765\u8bb0\u5f55\u5f53\u524d\u5df2\u88ab\u5199\u56de\u5230\u78c1\u76d8\u7684\u6570\u636e\u7684\u6700\u5927\u65f6\u95f4\u6233\u3002", "originalCommit": "8aa9e2b608c9f6d88a3547a89f19e8229dd0486e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2MDcwNg==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386360706", "bodyText": "Remove the if judgement, it will cause the file closed null pointer exception.\nlike:\nfor (ChunkMetaData data : currentChunkMetaDataList) {\nTsFileSequenceReader tsFileSequenceReader =\nFileReaderManager.getInstance().get(resource, resource.isClosed());\ndata.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n}\nit's ok to do so. because tsFileSequenceReader has been cached.", "author": "JackieTien97", "createdAt": "2020-03-02T12:21:14Z", "path": "server/src/main/java/org/apache/iotdb/db/utils/FileLoaderUtils.java", "diffHunk": "@@ -64,4 +72,40 @@ public static void updateTsFileResource(TsFileMetaData metaData, TsFileSequenceR\n       }\n     }\n   }\n+\n+  public static List<ChunkMetaData> loadChunkMetadataFromTsFileResource(\n+      TsFileResource resource, Path seriesPath, QueryContext context) throws IOException {\n+    List<ChunkMetaData> currentChunkMetaDataList;\n+    if (resource == null) {\n+      return new ArrayList<>();\n+    }\n+    if (resource.isClosed()) {\n+      currentChunkMetaDataList = DeviceMetaDataCache.getInstance().get(resource, seriesPath);\n+    } else {\n+      currentChunkMetaDataList = resource.getChunkMetaDataList();\n+    }\n+    List<Modification> pathModifications =\n+        context.getPathModifications(resource.getModFile(), seriesPath.getFullPath());\n+\n+    if (!pathModifications.isEmpty()) {\n+      QueryUtils.modifyChunkMetaData(currentChunkMetaDataList, pathModifications);\n+    }\n+\n+    for (ChunkMetaData data : currentChunkMetaDataList) {\n+      if (data.getChunkLoader() == null) {\n+        TsFileSequenceReader tsFileSequenceReader =\n+            FileReaderManager.getInstance().get(resource, resource.isClosed());\n+        data.setChunkLoader(new DiskChunkLoader(tsFileSequenceReader));\n+      }", "originalCommit": "8aa9e2b608c9f6d88a3547a89f19e8229dd0486e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM5NDgxNw==", "url": "https://github.com/apache/iotdb/pull/821#discussion_r386394817", "bodyText": "removed", "author": "wshao08", "createdAt": "2020-03-02T13:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjM2MDcwNg=="}], "type": "inlineReview"}, {"oid": "bebfc0e4e1758b16d15a75b84343feb03e5aa4ab", "url": "https://github.com/apache/iotdb/commit/bebfc0e4e1758b16d15a75b84343feb03e5aa4ab", "message": "Fix unit test bugs", "committedDate": "2020-03-02T13:04:10Z", "type": "commit"}, {"oid": "c26b2b5c6b1fe1e39d6d0afb59840554ac871301", "url": "https://github.com/apache/iotdb/commit/c26b2b5c6b1fe1e39d6d0afb59840554ac871301", "message": "Add Integration test for last query", "committedDate": "2020-03-02T14:34:17Z", "type": "commit"}, {"oid": "6d009ad198cc8e9c094e071d160275c290c72d6a", "url": "https://github.com/apache/iotdb/commit/6d009ad198cc8e9c094e071d160275c290c72d6a", "message": "Add missing licence", "committedDate": "2020-03-02T15:05:20Z", "type": "commit"}]}