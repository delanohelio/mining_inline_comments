{"pr_number": 1464, "pr_title": "add cluster version mmanager", "pr_createdAt": "2020-07-06T09:48:31Z", "pr_url": "https://github.com/apache/iotdb/pull/1464", "timeline": [{"oid": "1ef447e2d4b3bbcf73885fb00d26d4ba3fd9e8a7", "url": "https://github.com/apache/iotdb/commit/1ef447e2d4b3bbcf73885fb00d26d4ba3fd9e8a7", "message": "add cluster version mmanager\n\nadd cache for remote schema\n\nfix series path bug", "committedDate": "2020-07-07T02:55:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4Njk0Mw==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450586943", "bodyText": "Throwing an exception would fill the stack trace, so how about changing it to return null?", "author": "jt2594838", "createdAt": "2020-07-07T03:08:22Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/metadata/CMManager.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.metadata;\n+\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.metadata.PathNotExistException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MeasurementMeta;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.InsertPlan;\n+import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.tsfile.common.cache.LRUCache;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class CMManager extends MManager {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CMManager.class);\n+\n+  // currently, if a key is not existed in the mRemoteMetaCache, an IOException will be thrown\n+  private ReentrantReadWriteLock cacheLock = new ReentrantReadWriteLock();;\n+  private LRUCache<String, MeasurementMeta> mRemoteMetaCache;\n+  private MetaPuller metaPuller;\n+\n+  protected CMManager() {\n+    super();\n+    metaPuller = MetaPuller.getInstance();\n+    int remoteCacheSize = config.getmRemoteSchemaCacheSize();\n+    mRemoteMetaCache = new LRUCache<String, MeasurementMeta>(remoteCacheSize) {\n+      @Override\n+      protected MeasurementMeta loadObjectByKey(String key) throws IOException {\n+        throw new IOException(key + \" not found!\");", "originalCommit": "1ef447e2d4b3bbcf73885fb00d26d4ba3fd9e8a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0NTk0NA==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450645944", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-07-07T06:50:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4Njk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4NzYyOA==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450587628", "bodyText": "When is the schema pulled in this case?", "author": "jt2594838", "createdAt": "2020-07-07T03:11:20Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/metadata/CMManager.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.metadata;\n+\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.metadata.PathNotExistException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MeasurementMeta;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.InsertPlan;\n+import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.tsfile.common.cache.LRUCache;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class CMManager extends MManager {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CMManager.class);\n+\n+  // currently, if a key is not existed in the mRemoteMetaCache, an IOException will be thrown\n+  private ReentrantReadWriteLock cacheLock = new ReentrantReadWriteLock();;\n+  private LRUCache<String, MeasurementMeta> mRemoteMetaCache;\n+  private MetaPuller metaPuller;\n+\n+  protected CMManager() {\n+    super();\n+    metaPuller = MetaPuller.getInstance();\n+    int remoteCacheSize = config.getmRemoteSchemaCacheSize();\n+    mRemoteMetaCache = new LRUCache<String, MeasurementMeta>(remoteCacheSize) {\n+      @Override\n+      protected MeasurementMeta loadObjectByKey(String key) throws IOException {\n+        throw new IOException(key + \" not found!\");\n+      }\n+\n+      @Override\n+      public synchronized void removeItem(String key) {\n+        cache.keySet().removeIf(s -> s.startsWith(key));\n+      }\n+    };\n+  }\n+\n+  private static class MManagerHolder {\n+\n+    private MManagerHolder() {\n+      // allowed to do nothing\n+    }\n+\n+    private static final CMManager INSTANCE = new CMManager();\n+  }\n+\n+  /**\n+   * we should not use this function in other place, but only in IoTDB class\n+   * @return\n+   */\n+  public static MManager getInstance() {\n+    return CMManager.MManagerHolder.INSTANCE;\n+  }\n+\n+  @Override\n+  public String deleteTimeseries(String prefixPath) throws MetadataException {\n+    cacheLock.writeLock().lock();\n+    mRemoteMetaCache.removeItem(prefixPath);\n+    cacheLock.writeLock().unlock();\n+    return super.deleteTimeseries(prefixPath);\n+  }\n+\n+  @Override\n+  public void deleteStorageGroups(List<String> storageGroups) throws MetadataException {\n+    cacheLock.writeLock().lock();\n+    for (String storageGroup : storageGroups) {\n+      mRemoteMetaCache.removeItem(storageGroup);\n+    }\n+    cacheLock.writeLock().unlock();\n+    super.deleteStorageGroups(storageGroups);\n+  }\n+\n+  @Override\n+  public TSDataType getSeriesType(String path) throws MetadataException {\n+    try {\n+      cacheLock.readLock().lock();\n+      MeasurementMeta measurementMeta = mRemoteMetaCache.get(path);\n+      return measurementMeta.getMeasurementSchema().getType();\n+    } catch (IOException e) {\n+      //do nothing", "originalCommit": "1ef447e2d4b3bbcf73885fb00d26d4ba3fd9e8a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0NTk2MQ==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450645961", "bodyText": "the caller will pull by themselves.", "author": "mychaow", "createdAt": "2020-07-07T06:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4NzYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4ODExMw==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450588113", "bodyText": "It would be better to show which series is not found and just throw PathNotExistException.", "author": "jt2594838", "createdAt": "2020-07-07T03:13:22Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/metadata/CMManager.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.metadata;\n+\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.metadata.PathNotExistException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MeasurementMeta;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.InsertPlan;\n+import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.tsfile.common.cache.LRUCache;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class CMManager extends MManager {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CMManager.class);\n+\n+  // currently, if a key is not existed in the mRemoteMetaCache, an IOException will be thrown\n+  private ReentrantReadWriteLock cacheLock = new ReentrantReadWriteLock();;\n+  private LRUCache<String, MeasurementMeta> mRemoteMetaCache;\n+  private MetaPuller metaPuller;\n+\n+  protected CMManager() {\n+    super();\n+    metaPuller = MetaPuller.getInstance();\n+    int remoteCacheSize = config.getmRemoteSchemaCacheSize();\n+    mRemoteMetaCache = new LRUCache<String, MeasurementMeta>(remoteCacheSize) {\n+      @Override\n+      protected MeasurementMeta loadObjectByKey(String key) throws IOException {\n+        throw new IOException(key + \" not found!\");\n+      }\n+\n+      @Override\n+      public synchronized void removeItem(String key) {\n+        cache.keySet().removeIf(s -> s.startsWith(key));\n+      }\n+    };\n+  }\n+\n+  private static class MManagerHolder {\n+\n+    private MManagerHolder() {\n+      // allowed to do nothing\n+    }\n+\n+    private static final CMManager INSTANCE = new CMManager();\n+  }\n+\n+  /**\n+   * we should not use this function in other place, but only in IoTDB class\n+   * @return\n+   */\n+  public static MManager getInstance() {\n+    return CMManager.MManagerHolder.INSTANCE;\n+  }\n+\n+  @Override\n+  public String deleteTimeseries(String prefixPath) throws MetadataException {\n+    cacheLock.writeLock().lock();\n+    mRemoteMetaCache.removeItem(prefixPath);\n+    cacheLock.writeLock().unlock();\n+    return super.deleteTimeseries(prefixPath);\n+  }\n+\n+  @Override\n+  public void deleteStorageGroups(List<String> storageGroups) throws MetadataException {\n+    cacheLock.writeLock().lock();\n+    for (String storageGroup : storageGroups) {\n+      mRemoteMetaCache.removeItem(storageGroup);\n+    }\n+    cacheLock.writeLock().unlock();\n+    super.deleteStorageGroups(storageGroups);\n+  }\n+\n+  @Override\n+  public TSDataType getSeriesType(String path) throws MetadataException {\n+    try {\n+      cacheLock.readLock().lock();\n+      MeasurementMeta measurementMeta = mRemoteMetaCache.get(path);\n+      return measurementMeta.getMeasurementSchema().getType();\n+    } catch (IOException e) {\n+      //do nothing\n+    } finally {\n+      cacheLock.readLock().unlock();\n+    }\n+    return super.getSeriesType(path);\n+  }\n+\n+  @Override\n+  public MeasurementSchema[] getSchemas(String deviceId, String[] measurements) throws MetadataException {\n+    try {\n+      return super.getSchemas(deviceId, measurements);\n+    } catch (MetadataException e) {\n+      // some measurements not exist in local\n+      // try cache\n+      MeasurementSchema[] measurementSchemas = new MeasurementSchema[measurements.length];\n+      boolean allSeriesExists = true;\n+      cacheLock.readLock().lock();\n+      for (int i = 0; i < measurements.length; i++) {\n+        try {\n+          MeasurementMeta measurementMeta = mRemoteMetaCache.get(deviceId + measurements[i]);\n+          measurementSchemas[i] = measurementMeta.getMeasurementSchema();\n+        } catch (IOException ex) {\n+          // not all cached, pull from remote\n+          allSeriesExists = false;\n+          break;\n+        }\n+      }\n+      cacheLock.readLock().unlock();\n+      if (allSeriesExists) {\n+        return measurementSchemas;\n+      }\n+\n+      pullSeriesSchemas(deviceId, measurements);\n+\n+      // try again\n+      boolean allExist = true;\n+      cacheLock.readLock().lock();\n+      for (int i = 0; i < measurements.length; i++) {\n+        try {\n+          MeasurementMeta measurementMeta = mRemoteMetaCache.get(deviceId + measurements[i]);\n+          measurementSchemas[i] = measurementMeta.getMeasurementSchema();\n+        } catch (IOException ex) {\n+          allExist = false;\n+          break;\n+        }\n+      }\n+      cacheLock.readLock().unlock();\n+      if (!allExist) {\n+        throw new MetadataException(deviceId + \" has some mesurements not found\");", "originalCommit": "1ef447e2d4b3bbcf73885fb00d26d4ba3fd9e8a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0NjAxOQ==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450646019", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-07-07T06:50:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4ODExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4OTEzMg==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450589132", "bodyText": "I think this is urgent, or you can extract the lock method separately. Otherwise, an IllegalMonitorStateException will be thrown because the next step will try to unlock but it is not locked.", "author": "jt2594838", "createdAt": "2020-07-07T03:17:46Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/metadata/CMManager.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.metadata;\n+\n+import org.apache.iotdb.db.conf.IoTDBConstant;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.metadata.PathNotExistException;\n+import org.apache.iotdb.db.metadata.MManager;\n+import org.apache.iotdb.db.metadata.MeasurementMeta;\n+import org.apache.iotdb.db.metadata.mnode.MNode;\n+import org.apache.iotdb.db.qp.physical.crud.InsertPlan;\n+import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.tsfile.common.cache.LRUCache;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.read.TimeValuePair;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+public class CMManager extends MManager {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(CMManager.class);\n+\n+  // currently, if a key is not existed in the mRemoteMetaCache, an IOException will be thrown\n+  private ReentrantReadWriteLock cacheLock = new ReentrantReadWriteLock();;\n+  private LRUCache<String, MeasurementMeta> mRemoteMetaCache;\n+  private MetaPuller metaPuller;\n+\n+  protected CMManager() {\n+    super();\n+    metaPuller = MetaPuller.getInstance();\n+    int remoteCacheSize = config.getmRemoteSchemaCacheSize();\n+    mRemoteMetaCache = new LRUCache<String, MeasurementMeta>(remoteCacheSize) {\n+      @Override\n+      protected MeasurementMeta loadObjectByKey(String key) throws IOException {\n+        throw new IOException(key + \" not found!\");\n+      }\n+\n+      @Override\n+      public synchronized void removeItem(String key) {\n+        cache.keySet().removeIf(s -> s.startsWith(key));\n+      }\n+    };\n+  }\n+\n+  private static class MManagerHolder {\n+\n+    private MManagerHolder() {\n+      // allowed to do nothing\n+    }\n+\n+    private static final CMManager INSTANCE = new CMManager();\n+  }\n+\n+  /**\n+   * we should not use this function in other place, but only in IoTDB class\n+   * @return\n+   */\n+  public static MManager getInstance() {\n+    return CMManager.MManagerHolder.INSTANCE;\n+  }\n+\n+  @Override\n+  public String deleteTimeseries(String prefixPath) throws MetadataException {\n+    cacheLock.writeLock().lock();\n+    mRemoteMetaCache.removeItem(prefixPath);\n+    cacheLock.writeLock().unlock();\n+    return super.deleteTimeseries(prefixPath);\n+  }\n+\n+  @Override\n+  public void deleteStorageGroups(List<String> storageGroups) throws MetadataException {\n+    cacheLock.writeLock().lock();\n+    for (String storageGroup : storageGroups) {\n+      mRemoteMetaCache.removeItem(storageGroup);\n+    }\n+    cacheLock.writeLock().unlock();\n+    super.deleteStorageGroups(storageGroups);\n+  }\n+\n+  @Override\n+  public TSDataType getSeriesType(String path) throws MetadataException {\n+    try {\n+      cacheLock.readLock().lock();\n+      MeasurementMeta measurementMeta = mRemoteMetaCache.get(path);\n+      return measurementMeta.getMeasurementSchema().getType();\n+    } catch (IOException e) {\n+      //do nothing\n+    } finally {\n+      cacheLock.readLock().unlock();\n+    }\n+    return super.getSeriesType(path);\n+  }\n+\n+  @Override\n+  public MeasurementSchema[] getSchemas(String deviceId, String[] measurements) throws MetadataException {\n+    try {\n+      return super.getSchemas(deviceId, measurements);\n+    } catch (MetadataException e) {\n+      // some measurements not exist in local\n+      // try cache\n+      MeasurementSchema[] measurementSchemas = new MeasurementSchema[measurements.length];\n+      boolean allSeriesExists = true;\n+      cacheLock.readLock().lock();\n+      for (int i = 0; i < measurements.length; i++) {\n+        try {\n+          MeasurementMeta measurementMeta = mRemoteMetaCache.get(deviceId + measurements[i]);\n+          measurementSchemas[i] = measurementMeta.getMeasurementSchema();\n+        } catch (IOException ex) {\n+          // not all cached, pull from remote\n+          allSeriesExists = false;\n+          break;\n+        }\n+      }\n+      cacheLock.readLock().unlock();\n+      if (allSeriesExists) {\n+        return measurementSchemas;\n+      }\n+\n+      pullSeriesSchemas(deviceId, measurements);\n+\n+      // try again\n+      boolean allExist = true;\n+      cacheLock.readLock().lock();\n+      for (int i = 0; i < measurements.length; i++) {\n+        try {\n+          MeasurementMeta measurementMeta = mRemoteMetaCache.get(deviceId + measurements[i]);\n+          measurementSchemas[i] = measurementMeta.getMeasurementSchema();\n+        } catch (IOException ex) {\n+          allExist = false;\n+          break;\n+        }\n+      }\n+      cacheLock.readLock().unlock();\n+      if (!allExist) {\n+        throw new MetadataException(deviceId + \" has some mesurements not found\");\n+      }\n+      return measurementSchemas;\n+    }\n+  }\n+\n+  private void pullSeriesSchemas(String deviceId, String[] measurementList)\n+    throws MetadataException {\n+    List<String> schemasToPull = new ArrayList<>();\n+    for (String s : measurementList) {\n+      schemasToPull.add(deviceId + IoTDBConstant.PATH_SEPARATOR + s);\n+    }\n+    List<MeasurementSchema> schemas = metaPuller.pullTimeSeriesSchemas(schemasToPull);\n+    for (MeasurementSchema schema : schemas) {\n+      cacheMeta(deviceId + IoTDBConstant.PATH_SEPARATOR + schema.getMeasurementId(), new MeasurementMeta(schema));\n+    }\n+    logger.debug(\"Pulled {}/{} schemas from remote\", schemas.size(), measurementList.length);\n+  }\n+\n+  @Override\n+  public void cacheMeta(String seriesPath, MeasurementMeta meta) {\n+    cacheLock.writeLock().lock();\n+    mRemoteMetaCache.put(seriesPath, meta);\n+    cacheLock.writeLock().unlock();\n+  }\n+\n+  @Override\n+  public void updateLastCache(String seriesPath, TimeValuePair timeValuePair, boolean highPriorityUpdate, Long latestFlushedTime) {\n+    cacheLock.writeLock().lock();\n+    try {\n+      MeasurementMeta measurementMeta = mRemoteMetaCache.get(seriesPath);\n+      measurementMeta.updateCachedLast(timeValuePair, highPriorityUpdate, latestFlushedTime);\n+    } catch (IOException e) {\n+      // not found\n+    } finally {\n+      cacheLock.writeLock().unlock();\n+    }\n+    // maybe local also has the timeseries\n+    super.updateLastCache(seriesPath, timeValuePair, highPriorityUpdate, latestFlushedTime);\n+  }\n+\n+  @Override\n+  public TimeValuePair getLastCache(String seriesPath) {\n+    try {\n+      MeasurementMeta measurementMeta = mRemoteMetaCache.get(seriesPath);\n+      return measurementMeta.getTimeValuePair();\n+    } catch (IOException e) {\n+      // do nothing\n+    }\n+    return super.getLastCache(seriesPath);\n+  }\n+\n+  @Override\n+  public MeasurementSchema[] getSeriesSchemasAndReadLockDevice(String deviceId, String[] measurementList, InsertPlan plan) throws MetadataException {\n+    //TODO cluster also need to lock device node", "originalCommit": "1ef447e2d4b3bbcf73885fb00d26d4ba3fd9e8a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0NjExMQ==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450646111", "bodyText": "unlock will catch IllegalMonitorStateException, so that's ok.", "author": "mychaow", "createdAt": "2020-07-07T06:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4OTEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzMjUyMA==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r451932520", "bodyText": "Yes, I added that just as a temporary solution, but I still hope you consider to do some refactoring, maybe not in this PR, though, since generating exceptions is somehow burdensome.", "author": "jt2594838", "createdAt": "2020-07-09T02:45:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4OTEzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkzNTY1Nw==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r451935657", "bodyText": "ok\uff0cby the way, I use force-push just because some modifications are small, so I think it could be merged with the previous  commit. Anyway, I will avoid do it again.", "author": "mychaow", "createdAt": "2020-07-09T02:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4OTEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4OTU2OQ==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450589569", "bodyText": "How about using parallel pulling?", "author": "jt2594838", "createdAt": "2020-07-07T03:19:59Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/metadata/MetaPuller.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.metadata;\n+\n+import org.apache.iotdb.cluster.client.async.AsyncDataClient;\n+import org.apache.iotdb.cluster.client.sync.SyncClientAdaptor;\n+import org.apache.iotdb.cluster.exception.CheckConsistencyException;\n+import org.apache.iotdb.cluster.partition.PartitionGroup;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.rpc.thrift.PullSchemaRequest;\n+import org.apache.iotdb.cluster.server.member.MetaGroupMember;\n+import org.apache.iotdb.db.exception.metadata.MetadataException;\n+import org.apache.iotdb.db.exception.metadata.StorageGroupNotSetException;\n+import org.apache.iotdb.db.service.IoTDB;\n+import org.apache.iotdb.tsfile.write.schema.MeasurementSchema;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class MetaPuller {\n+  private static final Logger logger = LoggerFactory.getLogger(MetaPuller.class);\n+  private MetaGroupMember metaGroupMember;\n+\n+  private MetaPuller() {\n+  }\n+\n+  private static class MetaPullerHolder {\n+\n+    private static final MetaPuller INSTANCE = new MetaPuller();\n+  }\n+\n+  public void init(MetaGroupMember metaGroupMember) {\n+    this.metaGroupMember = metaGroupMember;\n+  }\n+\n+  /**\n+   * we should not use this function in other place, but only in IoTDB class\n+   * @return\n+   */\n+  public static MetaPuller getInstance() {\n+    return MetaPullerHolder.INSTANCE;\n+  }\n+\n+  /**\n+   * Pull the all timeseries schemas of given prefixPaths from remote nodes. All prefixPaths must\n+   * contain the storage group.\n+   */\n+  public List<MeasurementSchema> pullTimeSeriesSchemas(List<String> prefixPaths)\n+    throws MetadataException {\n+    logger.debug(\"{}: Pulling timeseries schemas of {}\", metaGroupMember.getName(), prefixPaths);\n+    // split the paths by the data groups that will hold them\n+    Map<PartitionGroup, List<String>> partitionGroupPathMap = new HashMap<>();\n+    for (String prefixPath : prefixPaths) {\n+      PartitionGroup partitionGroup;\n+      try {\n+        partitionGroup = metaGroupMember.getPartitionTable().partitionByPathTime(prefixPath, 0);\n+      } catch (StorageGroupNotSetException e) {\n+        // the storage group is not found locally, but may be found in the leader, retry after\n+        // synchronizing with the leader\n+\n+        try {\n+          metaGroupMember.syncLeaderWithConsistencyCheck();\n+        } catch (CheckConsistencyException checkConsistencyException) {\n+          throw new MetadataException(checkConsistencyException.getMessage());\n+        }\n+        partitionGroup = metaGroupMember.getPartitionTable().partitionByPathTime(prefixPath, 0);\n+\n+      }\n+      partitionGroupPathMap.computeIfAbsent(partitionGroup, g -> new ArrayList<>()).add(prefixPath);\n+    }\n+\n+    List<MeasurementSchema> schemas = new ArrayList<>();\n+    // pull timeseries schema from every group involved\n+    if (logger.isDebugEnabled()) {\n+      logger.debug(\"{}: pulling schemas of {} and other {} paths from {} groups\", metaGroupMember.getName(),\n+        prefixPaths.get(0), prefixPaths.size() - 1,\n+        partitionGroupPathMap.size());\n+    }\n+    for (Map.Entry<PartitionGroup, List<String>> partitionGroupListEntry : partitionGroupPathMap\n+      .entrySet()) {\n+      PartitionGroup partitionGroup = partitionGroupListEntry.getKey();\n+      List<String> paths = partitionGroupListEntry.getValue();\n+      pullTimeSeriesSchemas(partitionGroup, paths, schemas);\n+    }", "originalCommit": "1ef447e2d4b3bbcf73885fb00d26d4ba3fd9e8a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDY0NzE0Ng==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450647146", "bodyText": "It will be complicated, I will do it later", "author": "mychaow", "createdAt": "2020-07-07T06:53:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU4OTU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDM5Mg==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450590392", "bodyText": "Adding the parameter after \"quorum\" is a bit confusing, maybe we can use:\n\"{}: Log[{}] {} is accepted by the quorum\", member.getName(), log.getCurrLogIndex(), log", "author": "jt2594838", "createdAt": "2020-07-07T03:23:56Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/handlers/caller/AppendNodeEntryHandler.java", "diffHunk": "@@ -66,7 +67,7 @@ public void onComplete(Long response) {\n         logger.debug(\"{}: Received an agreement from {} for {}, remaining votes to succeed: {}\",\n             member.getName(), receiver, log, remaining);\n         if (remaining == 0) {\n-          logger.debug(\"{}: Log {} is accepted by the quorum\", member.getName(), log);\n+          logger.debug(\"{}: Log {} is accepted by the quorum {}\", member.getName(), log, log.getCurrLogIndex());", "originalCommit": "1ef447e2d4b3bbcf73885fb00d26d4ba3fd9e8a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU5MDgwMA==", "url": "https://github.com/apache/iotdb/pull/1464#discussion_r450590800", "bodyText": "Why are these commented?", "author": "jt2594838", "createdAt": "2020-07-07T03:25:48Z", "path": "cluster/src/test/java/org/apache/iotdb/cluster/log/applier/DataLogApplierTest.java", "diffHunk": "@@ -184,15 +182,15 @@ public void testApplyInsert()\n     assertFalse(dataSet.hasNext());\n \n     // this series is not created but can be fetched\n-    insertPlan.setDeviceId(TestUtils.getTestSg(4));\n-    applier.apply(log);\n-    dataSet = query(Collections.singletonList(TestUtils.getTestSeries(4, 0)), null);\n-    assertTrue(dataSet.hasNext());\n-    record = dataSet.next();\n-    assertEquals(1, record.getTimestamp());\n-    assertEquals(1, record.getFields().size());\n-    assertEquals(1.0, record.getFields().get(0).getDoubleV(), 0.00001);\n-    assertFalse(dataSet.hasNext());\n+//    insertPlan.setDeviceId(TestUtils.getTestSg(4));\n+//    applier.apply(log);\n+//    dataSet = query(Collections.singletonList(TestUtils.getTestSeries(4, 0)), null);\n+//    assertTrue(dataSet.hasNext());\n+//    record = dataSet.next();\n+//    assertEquals(1, record.getTimestamp());\n+//    assertEquals(1, record.getFields().size());\n+//    assertEquals(1.0, record.getFields().get(0).getDoubleV(), 0.00001);\n+//    assertFalse(dataSet.hasNext());", "originalCommit": "1ef447e2d4b3bbcf73885fb00d26d4ba3fd9e8a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dcfb6eed9492e6c685f9ffdb712b82429c18edf1", "url": "https://github.com/apache/iotdb/commit/dcfb6eed9492e6c685f9ffdb712b82429c18edf1", "message": "fix some bugs", "committedDate": "2020-07-07T13:01:33Z", "type": "forcePushed"}, {"oid": "42537e84d6206d4ef66217959cbcc19ea3fbc52a", "url": "https://github.com/apache/iotdb/commit/42537e84d6206d4ef66217959cbcc19ea3fbc52a", "message": "resolve conflict", "committedDate": "2020-07-09T05:26:16Z", "type": "forcePushed"}, {"oid": "06fb3169966e6e5766a8cc225750d4fed0945e31", "url": "https://github.com/apache/iotdb/commit/06fb3169966e6e5766a8cc225750d4fed0945e31", "message": "add cluster version mmanager\n\nadd cache for remote schema\n\nfix series path bug", "committedDate": "2020-07-09T05:30:28Z", "type": "commit"}, {"oid": "de7cd6b9b994e333e41a340a53ec6e881f57b008", "url": "https://github.com/apache/iotdb/commit/de7cd6b9b994e333e41a340a53ec6e881f57b008", "message": "fix some bugs", "committedDate": "2020-07-09T05:31:43Z", "type": "commit"}, {"oid": "fc719276faa867e0dd15dbc50d775ce6d266042b", "url": "https://github.com/apache/iotdb/commit/fc719276faa867e0dd15dbc50d775ce6d266042b", "message": "resolve conflict", "committedDate": "2020-07-09T05:31:45Z", "type": "commit"}, {"oid": "fc719276faa867e0dd15dbc50d775ce6d266042b", "url": "https://github.com/apache/iotdb/commit/fc719276faa867e0dd15dbc50d775ce6d266042b", "message": "resolve conflict", "committedDate": "2020-07-09T05:31:45Z", "type": "forcePushed"}]}