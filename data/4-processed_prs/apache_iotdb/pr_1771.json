{"pr_number": 1771, "pr_title": "[IOTDB-884] batch create timeSeriesPlan", "pr_createdAt": "2020-09-27T05:41:15Z", "pr_url": "https://github.com/apache/iotdb/pull/1771", "timeline": [{"oid": "3f0cd65f499698adf341746b1aa68edb4a6e952b", "url": "https://github.com/apache/iotdb/commit/3f0cd65f499698adf341746b1aa68edb4a6e952b", "message": "[IOTDB-884] batch create timeSeriesPlan", "committedDate": "2020-09-27T04:27:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NjAwMQ==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496346001", "bodyText": "alias maybe null, please change the logic here.", "author": "Alima777", "createdAt": "2020-09-29T02:45:28Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.qp.physical.sys;\n+\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * create multiple timeSeries, could be split to several sub Plans to execute in different DataGroup\n+ */\n+public class CreateMultiTimeSeriesPlan extends PhysicalPlan {\n+  private List<PartialPath> paths;\n+  private List<TSDataType> dataTypes;\n+  private List<TSEncoding> encodings;\n+  private List<CompressionType> compressors;\n+  private List<String> alias;\n+  private List<Map<String, String>> props = null;\n+  private List<Map<String, String>> tags = null;\n+  private List<Map<String, String>> attributes = null;\n+\n+  /*\n+   ** record the result of creation of time series\n+   */\n+  private Map<Integer, Boolean> results = new HashMap<>();\n+  private List<Integer> indexes;\n+\n+  public CreateMultiTimeSeriesPlan() {\n+    super(false, Operator.OperatorType.CREATE_MULTI_TIMESERIES);\n+  }\n+\n+  @Override\n+  public List<PartialPath> getPaths() {\n+    return paths;\n+  }\n+\n+  public void setPaths(List<PartialPath> paths) {\n+    this.paths = paths;\n+  }\n+\n+  public List<TSDataType> getDataTypes() {\n+    return dataTypes;\n+  }\n+\n+  public void setDataTypes(List<TSDataType> dataTypes) {\n+    this.dataTypes = dataTypes;\n+  }\n+\n+  public List<TSEncoding> getEncodings() {\n+    return encodings;\n+  }\n+\n+  public void setEncodings(List<TSEncoding> encodings) {\n+    this.encodings = encodings;\n+  }\n+\n+  public List<CompressionType> getCompressors() {\n+    return compressors;\n+  }\n+\n+  public void setCompressors(List<CompressionType> compressors) {\n+    this.compressors = compressors;\n+  }\n+\n+  public List<String> getAlias() {\n+    return alias;\n+  }\n+\n+  public void setAlias(List<String> alias) {\n+    this.alias = alias;\n+  }\n+\n+  public List<Map<String, String>> getProps() {\n+    return props;\n+  }\n+\n+  public void setProps(List<Map<String, String>> props) {\n+    this.props = props;\n+  }\n+\n+  public List<Map<String, String>> getTags() {\n+    return tags;\n+  }\n+\n+  public void setTags(List<Map<String, String>> tags) {\n+    this.tags = tags;\n+  }\n+\n+  public List<Map<String, String>> getAttributes() {\n+    return attributes;\n+  }\n+\n+  public void setAttributes(List<Map<String, String>> attributes) {\n+    this.attributes = attributes;\n+  }\n+\n+  public List<Integer> getIndexes() {\n+    return indexes;\n+  }\n+\n+  public void setIndexes(List<Integer> indexes) {\n+    this.indexes = indexes;\n+  }\n+\n+  public Map<Integer, Boolean> getResults() {\n+    return results;\n+  }\n+\n+  public void setResults(Map<Integer, Boolean> results) {\n+    this.results = results;\n+  }\n+\n+  @Override\n+  public void serialize(DataOutputStream stream) throws IOException {\n+    int type = PhysicalPlanType.MULTI_CREATE_TIMESERIES.ordinal();\n+    stream.write(type);\n+    stream.writeInt(paths.size());\n+\n+    for (PartialPath path : paths) {\n+      putString(stream, path.getFullPath());\n+    }\n+\n+    for (TSDataType dataType : dataTypes) {\n+      stream.write(dataType.ordinal());\n+    }\n+\n+    for (TSEncoding encoding : encodings) {\n+      stream.write(encoding.ordinal());\n+    }\n+\n+    for (CompressionType compressor : compressors) {\n+      stream.write(compressor.ordinal());\n+    }\n+\n+    for (String name : alias) {", "originalCommit": "3f0cd65f499698adf341746b1aa68edb4a6e952b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM1MjA5Mg==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496352092", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-09-29T03:09:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NjAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NjIxMg==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496346212", "bodyText": "Same.", "author": "Alima777", "createdAt": "2020-09-29T02:46:16Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.qp.physical.sys;\n+\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * create multiple timeSeries, could be split to several sub Plans to execute in different DataGroup\n+ */\n+public class CreateMultiTimeSeriesPlan extends PhysicalPlan {\n+  private List<PartialPath> paths;\n+  private List<TSDataType> dataTypes;\n+  private List<TSEncoding> encodings;\n+  private List<CompressionType> compressors;\n+  private List<String> alias;\n+  private List<Map<String, String>> props = null;\n+  private List<Map<String, String>> tags = null;\n+  private List<Map<String, String>> attributes = null;\n+\n+  /*\n+   ** record the result of creation of time series\n+   */\n+  private Map<Integer, Boolean> results = new HashMap<>();\n+  private List<Integer> indexes;\n+\n+  public CreateMultiTimeSeriesPlan() {\n+    super(false, Operator.OperatorType.CREATE_MULTI_TIMESERIES);\n+  }\n+\n+  @Override\n+  public List<PartialPath> getPaths() {\n+    return paths;\n+  }\n+\n+  public void setPaths(List<PartialPath> paths) {\n+    this.paths = paths;\n+  }\n+\n+  public List<TSDataType> getDataTypes() {\n+    return dataTypes;\n+  }\n+\n+  public void setDataTypes(List<TSDataType> dataTypes) {\n+    this.dataTypes = dataTypes;\n+  }\n+\n+  public List<TSEncoding> getEncodings() {\n+    return encodings;\n+  }\n+\n+  public void setEncodings(List<TSEncoding> encodings) {\n+    this.encodings = encodings;\n+  }\n+\n+  public List<CompressionType> getCompressors() {\n+    return compressors;\n+  }\n+\n+  public void setCompressors(List<CompressionType> compressors) {\n+    this.compressors = compressors;\n+  }\n+\n+  public List<String> getAlias() {\n+    return alias;\n+  }\n+\n+  public void setAlias(List<String> alias) {\n+    this.alias = alias;\n+  }\n+\n+  public List<Map<String, String>> getProps() {\n+    return props;\n+  }\n+\n+  public void setProps(List<Map<String, String>> props) {\n+    this.props = props;\n+  }\n+\n+  public List<Map<String, String>> getTags() {\n+    return tags;\n+  }\n+\n+  public void setTags(List<Map<String, String>> tags) {\n+    this.tags = tags;\n+  }\n+\n+  public List<Map<String, String>> getAttributes() {\n+    return attributes;\n+  }\n+\n+  public void setAttributes(List<Map<String, String>> attributes) {\n+    this.attributes = attributes;\n+  }\n+\n+  public List<Integer> getIndexes() {\n+    return indexes;\n+  }\n+\n+  public void setIndexes(List<Integer> indexes) {\n+    this.indexes = indexes;\n+  }\n+\n+  public Map<Integer, Boolean> getResults() {\n+    return results;\n+  }\n+\n+  public void setResults(Map<Integer, Boolean> results) {\n+    this.results = results;\n+  }\n+\n+  @Override\n+  public void serialize(DataOutputStream stream) throws IOException {\n+    int type = PhysicalPlanType.MULTI_CREATE_TIMESERIES.ordinal();\n+    stream.write(type);\n+    stream.writeInt(paths.size());\n+\n+    for (PartialPath path : paths) {\n+      putString(stream, path.getFullPath());\n+    }\n+\n+    for (TSDataType dataType : dataTypes) {\n+      stream.write(dataType.ordinal());\n+    }\n+\n+    for (TSEncoding encoding : encodings) {\n+      stream.write(encoding.ordinal());\n+    }\n+\n+    for (CompressionType compressor : compressors) {\n+      stream.write(compressor.ordinal());\n+    }\n+\n+    for (String name : alias) {\n+      putString(stream, name);\n+    }\n+\n+    if (props != null) {\n+      stream.write(1);\n+      for (Map<String, String> prop : props) {\n+        ReadWriteIOUtils.write(prop, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+\n+    if (tags != null) {\n+      stream.write(1);\n+      for (Map<String, String> tag : tags) {\n+        ReadWriteIOUtils.write(tag, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+\n+    if (attributes != null) {\n+      stream.write(1);\n+      for (Map<String, String> attribute : attributes) {\n+        ReadWriteIOUtils.write(attribute, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+  }\n+\n+  @Override\n+  public void serialize(ByteBuffer buffer) {\n+    int type = PhysicalPlanType.MULTI_CREATE_TIMESERIES.ordinal();\n+    buffer.put((byte) type);\n+    buffer.putInt(paths.size());\n+\n+    for (PartialPath path : paths) {\n+      putString(buffer, path.getFullPath());\n+    }\n+\n+    for (TSDataType dataType : dataTypes) {\n+      buffer.put((byte) dataType.ordinal());\n+    }\n+\n+    for (TSEncoding encoding : encodings) {\n+      buffer.put((byte) encoding.ordinal());\n+    }\n+\n+    for (CompressionType compressor : compressors) {\n+      buffer.put((byte) compressor.ordinal());\n+    }\n+\n+    for (String name : alias) {\n+      putString(buffer, name);\n+    }\n+\n+    if (props != null) {\n+      buffer.put((byte) 1);\n+      for (Map<String, String> prop : props) {\n+        ReadWriteIOUtils.write(prop, buffer);\n+      }\n+    } else {\n+      buffer.put((byte) 0);\n+    }\n+\n+    if (tags != null) {\n+      buffer.put((byte) 1);\n+      for (Map<String, String> tag : tags) {\n+        ReadWriteIOUtils.write(tag, buffer);\n+      }\n+    } else {\n+      buffer.put((byte) 0);\n+    }\n+\n+    if (attributes != null) {\n+      buffer.put((byte) 1);\n+      for (Map<String, String> attribute : attributes) {\n+        ReadWriteIOUtils.write(attribute, buffer);\n+      }\n+    } else {\n+      buffer.put((byte) 0);\n+    }\n+  }\n+\n+  @Override\n+  public void deserialize(ByteBuffer buffer) throws IllegalPathException {\n+    int totalSize = buffer.getInt();\n+    for (int i = 0; i < totalSize; i++) {\n+      paths.add(new PartialPath(readString(buffer)));\n+    }\n+    for (int i = 0; i < totalSize; i++) {\n+      dataTypes.add(TSDataType.values()[buffer.get()]);\n+    }\n+    for (int i = 0; i < totalSize; i++) {\n+      encodings.add(TSEncoding.values()[buffer.get()]);\n+    }\n+\n+    for (int i = 0; i < totalSize; i++) {\n+      alias.add(readString(buffer));\n+    }", "originalCommit": "3f0cd65f499698adf341746b1aa68edb4a6e952b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM0NjI3Mg==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496346272", "bodyText": "Same.", "author": "Alima777", "createdAt": "2020-09-29T02:46:28Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/physical/sys/CreateMultiTimeSeriesPlan.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.db.qp.physical.sys;\n+\n+import org.apache.iotdb.db.exception.metadata.IllegalPathException;\n+import org.apache.iotdb.db.metadata.PartialPath;\n+import org.apache.iotdb.db.qp.logical.Operator;\n+import org.apache.iotdb.db.qp.physical.PhysicalPlan;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.utils.ReadWriteIOUtils;\n+\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * create multiple timeSeries, could be split to several sub Plans to execute in different DataGroup\n+ */\n+public class CreateMultiTimeSeriesPlan extends PhysicalPlan {\n+  private List<PartialPath> paths;\n+  private List<TSDataType> dataTypes;\n+  private List<TSEncoding> encodings;\n+  private List<CompressionType> compressors;\n+  private List<String> alias;\n+  private List<Map<String, String>> props = null;\n+  private List<Map<String, String>> tags = null;\n+  private List<Map<String, String>> attributes = null;\n+\n+  /*\n+   ** record the result of creation of time series\n+   */\n+  private Map<Integer, Boolean> results = new HashMap<>();\n+  private List<Integer> indexes;\n+\n+  public CreateMultiTimeSeriesPlan() {\n+    super(false, Operator.OperatorType.CREATE_MULTI_TIMESERIES);\n+  }\n+\n+  @Override\n+  public List<PartialPath> getPaths() {\n+    return paths;\n+  }\n+\n+  public void setPaths(List<PartialPath> paths) {\n+    this.paths = paths;\n+  }\n+\n+  public List<TSDataType> getDataTypes() {\n+    return dataTypes;\n+  }\n+\n+  public void setDataTypes(List<TSDataType> dataTypes) {\n+    this.dataTypes = dataTypes;\n+  }\n+\n+  public List<TSEncoding> getEncodings() {\n+    return encodings;\n+  }\n+\n+  public void setEncodings(List<TSEncoding> encodings) {\n+    this.encodings = encodings;\n+  }\n+\n+  public List<CompressionType> getCompressors() {\n+    return compressors;\n+  }\n+\n+  public void setCompressors(List<CompressionType> compressors) {\n+    this.compressors = compressors;\n+  }\n+\n+  public List<String> getAlias() {\n+    return alias;\n+  }\n+\n+  public void setAlias(List<String> alias) {\n+    this.alias = alias;\n+  }\n+\n+  public List<Map<String, String>> getProps() {\n+    return props;\n+  }\n+\n+  public void setProps(List<Map<String, String>> props) {\n+    this.props = props;\n+  }\n+\n+  public List<Map<String, String>> getTags() {\n+    return tags;\n+  }\n+\n+  public void setTags(List<Map<String, String>> tags) {\n+    this.tags = tags;\n+  }\n+\n+  public List<Map<String, String>> getAttributes() {\n+    return attributes;\n+  }\n+\n+  public void setAttributes(List<Map<String, String>> attributes) {\n+    this.attributes = attributes;\n+  }\n+\n+  public List<Integer> getIndexes() {\n+    return indexes;\n+  }\n+\n+  public void setIndexes(List<Integer> indexes) {\n+    this.indexes = indexes;\n+  }\n+\n+  public Map<Integer, Boolean> getResults() {\n+    return results;\n+  }\n+\n+  public void setResults(Map<Integer, Boolean> results) {\n+    this.results = results;\n+  }\n+\n+  @Override\n+  public void serialize(DataOutputStream stream) throws IOException {\n+    int type = PhysicalPlanType.MULTI_CREATE_TIMESERIES.ordinal();\n+    stream.write(type);\n+    stream.writeInt(paths.size());\n+\n+    for (PartialPath path : paths) {\n+      putString(stream, path.getFullPath());\n+    }\n+\n+    for (TSDataType dataType : dataTypes) {\n+      stream.write(dataType.ordinal());\n+    }\n+\n+    for (TSEncoding encoding : encodings) {\n+      stream.write(encoding.ordinal());\n+    }\n+\n+    for (CompressionType compressor : compressors) {\n+      stream.write(compressor.ordinal());\n+    }\n+\n+    for (String name : alias) {\n+      putString(stream, name);\n+    }\n+\n+    if (props != null) {\n+      stream.write(1);\n+      for (Map<String, String> prop : props) {\n+        ReadWriteIOUtils.write(prop, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+\n+    if (tags != null) {\n+      stream.write(1);\n+      for (Map<String, String> tag : tags) {\n+        ReadWriteIOUtils.write(tag, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+\n+    if (attributes != null) {\n+      stream.write(1);\n+      for (Map<String, String> attribute : attributes) {\n+        ReadWriteIOUtils.write(attribute, stream);\n+      }\n+    } else {\n+      stream.write(0);\n+    }\n+  }\n+\n+  @Override\n+  public void serialize(ByteBuffer buffer) {\n+    int type = PhysicalPlanType.MULTI_CREATE_TIMESERIES.ordinal();\n+    buffer.put((byte) type);\n+    buffer.putInt(paths.size());\n+\n+    for (PartialPath path : paths) {\n+      putString(buffer, path.getFullPath());\n+    }\n+\n+    for (TSDataType dataType : dataTypes) {\n+      buffer.put((byte) dataType.ordinal());\n+    }\n+\n+    for (TSEncoding encoding : encodings) {\n+      buffer.put((byte) encoding.ordinal());\n+    }\n+\n+    for (CompressionType compressor : compressors) {\n+      buffer.put((byte) compressor.ordinal());\n+    }\n+\n+    for (String name : alias) {\n+      putString(buffer, name);\n+    }", "originalCommit": "3f0cd65f499698adf341746b1aa68edb4a6e952b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "279942253e08a2636c25e4f523542fbf805ac069", "url": "https://github.com/apache/iotdb/commit/279942253e08a2636c25e4f523542fbf805ac069", "message": "fix tags null", "committedDate": "2020-09-29T03:18:28Z", "type": "commit"}, {"oid": "366b8d082e26881f43f5946e29b63a62a583b120", "url": "https://github.com/apache/iotdb/commit/366b8d082e26881f43f5946e29b63a62a583b120", "message": "fix cross-tests", "committedDate": "2020-09-29T05:21:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0NDQyMA==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496444420", "bodyText": "I recommend that you straightly make results a Map<Integer, Exception> and record the potential QueryProcessException into it since createTimeSeries always returns true if there is no exception. And when changed this way, you would be able to tell the user what are the reasons behind the failures, instead of a simple failure.", "author": "jt2594838", "createdAt": "2020-09-29T06:23:59Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -1040,6 +1029,31 @@ private boolean createTimeSeries(CreateTimeSeriesPlan createTimeSeriesPlan)\n     return true;\n   }\n \n+  private boolean createMultiTimeSeries(CreateMultiTimeSeriesPlan createMultiTimeSeriesPlan) {\n+    Map<Integer, Boolean> results = new HashMap<>(createMultiTimeSeriesPlan.getPaths().size());\n+    for (int i = 0; i < createMultiTimeSeriesPlan.getPaths().size(); i++) {\n+      CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(createMultiTimeSeriesPlan.getPaths().get(i),\n+        createMultiTimeSeriesPlan.getDataTypes().get(i), createMultiTimeSeriesPlan.getEncodings().get(i),\n+        createMultiTimeSeriesPlan.getCompressors().get(i),\n+        createMultiTimeSeriesPlan.getProps() == null ? null : createMultiTimeSeriesPlan.getProps().get(i),\n+        createMultiTimeSeriesPlan.getTags() == null ? null : createMultiTimeSeriesPlan.getTags().get(i),\n+        createMultiTimeSeriesPlan.getAttributes() == null ? null : createMultiTimeSeriesPlan.getAttributes().get(i),\n+        createMultiTimeSeriesPlan.getAlias() == null ? null : createMultiTimeSeriesPlan.getAlias().get(i));\n+\n+      boolean success = false;\n+      try {\n+        success = createTimeSeries(plan);\n+      } catch (QueryProcessException e) {\n+        // do nothing\n+        logger.debug(\"meet error while processing create timeseries. \", e);\n+      } finally {\n+        results.put(createMultiTimeSeriesPlan.getIndexes().get(i), success);", "originalCommit": "366b8d082e26881f43f5946e29b63a62a583b120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ4NzY1Mw==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496487653", "bodyText": "ok", "author": "mychaow", "createdAt": "2020-09-29T07:48:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0NDQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0NDkyOA==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496444928", "bodyText": "What is this plan for?", "author": "jt2594838", "createdAt": "2020-09-29T06:25:13Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -1533,14 +1528,35 @@ public TSStatus createMultiTimeseries(TSCreateMultiTimeseriesReq req) {\n             req.getPaths().size(), req.getPaths().get(0));\n       }\n       List<TSStatus> statusList = new ArrayList<>(req.paths.size());\n+      CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan();", "originalCommit": "366b8d082e26881f43f5946e29b63a62a583b120", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ4OTI0MA==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r496489240", "bodyText": "Just to do some check, like checkAuthority before execute the CreateMultiTimeSeriesPlan.", "author": "mychaow", "createdAt": "2020-09-29T07:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ0NDkyOA=="}], "type": "inlineReview"}, {"oid": "72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "url": "https://github.com/apache/iotdb/commit/72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "message": "record exception when failed", "committedDate": "2020-09-29T08:22:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NzI3MQ==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r502167271", "bodyText": "It's not recommended to use star syntax in import", "author": "yuqi1129", "createdAt": "2020-10-09T03:39:53Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -98,26 +98,7 @@\n import org.apache.iotdb.db.qp.physical.crud.QueryPlan;\n import org.apache.iotdb.db.qp.physical.crud.RawDataQueryPlan;\n import org.apache.iotdb.db.qp.physical.crud.UpdatePlan;\n-import org.apache.iotdb.db.qp.physical.sys.AlterTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.AuthorPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CountPlan;\n-import org.apache.iotdb.db.qp.physical.sys.CreateTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DataAuthPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DeleteStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.DeleteTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.FlushPlan;\n-import org.apache.iotdb.db.qp.physical.sys.LoadConfigurationPlan;\n-import org.apache.iotdb.db.qp.physical.sys.MergePlan;\n-import org.apache.iotdb.db.qp.physical.sys.OperateFilePlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.SetTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowChildPathsPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowDevicesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowStorageGroupPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowTTLPlan;\n-import org.apache.iotdb.db.qp.physical.sys.ShowTimeSeriesPlan;\n-import org.apache.iotdb.db.qp.physical.sys.TracingPlan;\n+import org.apache.iotdb.db.qp.physical.sys.*;", "originalCommit": "72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3NzEyNQ==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r502177125", "bodyText": "thanks, I will fix it", "author": "mychaow", "createdAt": "2020-10-09T04:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE2NzI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3MDQyMg==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r502170422", "bodyText": "Maybe we need a switch to allow partial success if error log was output in debug level", "author": "yuqi1129", "createdAt": "2020-10-09T03:46:40Z", "path": "server/src/main/java/org/apache/iotdb/db/qp/executor/PlanExecutor.java", "diffHunk": "@@ -1040,6 +1029,29 @@ private boolean createTimeSeries(CreateTimeSeriesPlan createTimeSeriesPlan)\n     return true;\n   }\n \n+  private boolean createMultiTimeSeries(CreateMultiTimeSeriesPlan createMultiTimeSeriesPlan) {\n+    Map<Integer, Exception> results = new HashMap<>(createMultiTimeSeriesPlan.getPaths().size());\n+    for (int i = 0; i < createMultiTimeSeriesPlan.getPaths().size(); i++) {\n+      CreateTimeSeriesPlan plan = new CreateTimeSeriesPlan(createMultiTimeSeriesPlan.getPaths().get(i),\n+        createMultiTimeSeriesPlan.getDataTypes().get(i), createMultiTimeSeriesPlan.getEncodings().get(i),\n+        createMultiTimeSeriesPlan.getCompressors().get(i),\n+        createMultiTimeSeriesPlan.getProps() == null ? null : createMultiTimeSeriesPlan.getProps().get(i),\n+        createMultiTimeSeriesPlan.getTags() == null ? null : createMultiTimeSeriesPlan.getTags().get(i),\n+        createMultiTimeSeriesPlan.getAttributes() == null ? null : createMultiTimeSeriesPlan.getAttributes().get(i),\n+        createMultiTimeSeriesPlan.getAlias() == null ? null : createMultiTimeSeriesPlan.getAlias().get(i));\n+\n+      try {\n+        createTimeSeries(plan);\n+      } catch (QueryProcessException e) {\n+        // do nothing\n+        results.put(createMultiTimeSeriesPlan.getIndexes().get(i), e);\n+        logger.debug(\"meet error while processing create timeseries. \", e);", "originalCommit": "72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjIwODQ1Ng==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r502208456", "bodyText": "yes, I will return error message to client", "author": "mychaow", "createdAt": "2020-10-09T06:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE3MDQyMg=="}], "type": "inlineReview"}, {"oid": "eb7f704ca6ef61d77c40772d45ad540f12875700", "url": "https://github.com/apache/iotdb/commit/eb7f704ca6ef61d77c40772d45ad540f12875700", "message": "return error message to client when create time series", "committedDate": "2020-10-12T07:45:35Z", "type": "commit"}, {"oid": "eb7f704ca6ef61d77c40772d45ad540f12875700", "url": "https://github.com/apache/iotdb/commit/eb7f704ca6ef61d77c40772d45ad540f12875700", "message": "return error message to client when create time series", "committedDate": "2020-10-12T07:45:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzMDY5OQ==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r503130699", "bodyText": "I think the messages of the exceptions should be put into the statuses.\nRpcUtils.getStatus(TSStatusCode.EXECUTE_STATEMENT_ERROR, entry.getValue().getMessage())", "author": "jt2594838", "createdAt": "2020-10-12T08:38:21Z", "path": "server/src/main/java/org/apache/iotdb/db/service/TSServiceImpl.java", "diffHunk": "@@ -1607,9 +1607,9 @@ public TSStatus createMultiTimeseries(TSCreateMultiTimeseriesReq req) {\n \n       boolean isAllSuccessful = true;\n \n-      for (Map.Entry<Integer, Boolean> entry : createMultiTimeSeriesPlan.getResults().entrySet()) {\n-        if (!entry.getValue()) {\n-          isAllSuccessful = false;\n+      if (createMultiTimeSeriesPlan.getResults().entrySet().size() > 0) {\n+        isAllSuccessful = false;\n+        for (Map.Entry<Integer, Exception> entry : createMultiTimeSeriesPlan.getResults().entrySet()) {\n           statusList.set(entry.getKey(), RpcUtils.getStatus(TSStatusCode.EXECUTE_STATEMENT_ERROR));", "originalCommit": "72ceeb61e0531bb3b02c8c2607ffad53b3d326ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE2NjI2OA==", "url": "https://github.com/apache/iotdb/pull/1771#discussion_r503166268", "bodyText": "yes, I have fixed it.", "author": "mychaow", "createdAt": "2020-10-12T09:34:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzMDY5OQ=="}], "type": "inlineReview"}]}