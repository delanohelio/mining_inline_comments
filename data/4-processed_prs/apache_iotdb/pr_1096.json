{"pr_number": 1096, "pr_title": "[IOTDB-617] Support alter one time series's tag/attribute property", "pr_createdAt": "2020-04-24T14:07:30Z", "pr_url": "https://github.com/apache/iotdb/pull/1096", "timeline": [{"oid": "3f7692250bd1a74d72f5adbec95599d1c3b796a9", "url": "https://github.com/apache/iotdb/commit/3f7692250bd1a74d72f5adbec95599d1c3b796a9", "message": "alter tag", "committedDate": "2020-04-24T14:04:47Z", "type": "commit"}, {"oid": "da5a7d28b79749d9917c64b1a27071660a51f99d", "url": "https://github.com/apache/iotdb/commit/da5a7d28b79749d9917c64b1a27071660a51f99d", "message": "changes to sonar", "committedDate": "2020-04-25T03:53:00Z", "type": "commit"}, {"oid": "15963aa539b30d551726181c320fbdf02bca5241", "url": "https://github.com/apache/iotdb/commit/15963aa539b30d551726181c320fbdf02bca5241", "message": "resolve conflicts", "committedDate": "2020-04-25T03:56:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMDI2Mw==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415020263", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static final String CHANGE_OFFSET = \"12\";\n          \n          \n            \n              public static final String SET_OFFSET = \"12\";", "author": "qiaojialin", "createdAt": "2020-04-25T09:08:50Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MetadataOperationType.java", "diffHunk": "@@ -29,4 +29,5 @@ private MetadataOperationType(){\n   public static final String SET_STORAGE_GROUP = \"2\";\n   public static final String SET_TTL = \"10\";\n   public static final String DELETE_STORAGE_GROUP = \"11\";\n+  public static final String CHANGE_OFFSET = \"12\";", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMTk2OA==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415021968", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n          \n          \n            \n              public void dropTagsOrAttributes(Set<String> keySet, String fullPath) throws MetadataException, IOException {", "author": "qiaojialin", "createdAt": "2020-04-25T09:18:31Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjM5Mw==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022393", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \n          \n          \n            \n            // tag key -> tag values", "author": "qiaojialin", "createdAt": "2020-04-25T09:21:06Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjQzNw==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, String> deleteTag = new HashMap<>();\n          \n          \n            \n                  Map<String, String> deletedTags = new HashMap<>();", "author": "qiaojialin", "createdAt": "2020-04-25T09:21:18Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjcyOQ==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022729", "bodyText": "add javadoc\nremove the empty tag value and tag key", "author": "qiaojialin", "createdAt": "2020-04-25T09:23:13Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjc4MA==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022780", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void setTag(Map<String, String> alterMap, String fullPath)\n          \n          \n            \n              public void changeTagValue(Map<String, String> alterMap, String fullPath)", "author": "qiaojialin", "createdAt": "2020-04-25T09:23:41Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjgzNw==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022837", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, String> beforeTagValue = new HashMap<>();\n          \n          \n            \n                  Map<String, String> oldTagValue = new HashMap<>();", "author": "qiaojialin", "createdAt": "2020-04-25T09:24:02Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMjg4NQ==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415022885", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, String> currentTagValue = new HashMap<>();\n          \n          \n            \n                  Map<String, String> newTagValue = new HashMap<>();", "author": "qiaojialin", "createdAt": "2020-04-25T09:24:15Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzA4Mw==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023083", "bodyText": "add some example...", "author": "qiaojialin", "createdAt": "2020-04-25T09:25:29Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();\n+      for (Entry<String, String> entry : alterMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // check tag map\n+        if (pair.left.containsKey(key)) {\n+          beforeTagValue.put(key, pair.left.get(key));\n+          currentTagValue.put(key, value);\n+          pair.left.put(key, value);\n+        } else if (pair.right.containsKey(key)) {\n+          // check attribute map\n+          pair.right.put(key, value);\n+        } else {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] does not have tag/attribute [%s].\", fullPath, key));\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : beforeTagValue.entrySet()) {", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzExMw==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023113", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    tagIndex\n          \n          \n            \n                            .computeIfAbsent(key, k -> new HashMap<>())\n          \n          \n            \n                    tagIndex.computeIfAbsent(key, k -> new HashMap<>())", "author": "qiaojialin", "createdAt": "2020-04-25T09:25:53Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();\n+      for (Entry<String, String> entry : alterMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // check tag map\n+        if (pair.left.containsKey(key)) {\n+          beforeTagValue.put(key, pair.left.get(key));\n+          currentTagValue.put(key, value);\n+          pair.left.put(key, value);\n+        } else if (pair.right.containsKey(key)) {\n+          // check attribute map\n+          pair.right.put(key, value);\n+        } else {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] does not have tag/attribute [%s].\", fullPath, key));\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : beforeTagValue.entrySet()) {\n+        String key = entry.getKey();\n+        String beforeValue = entry.getValue();\n+        String currentValue = currentTagValue.get(key);\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(beforeValue).remove(leafMNode);\n+        tagIndex\n+                .computeIfAbsent(key, k -> new HashMap<>())", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzc5NA==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023794", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String value = pair.left.remove(beforeName);\n          \n          \n            \n                    String oldTagvalue = pair.left.remove(beforeName);", "author": "qiaojialin", "createdAt": "2020-04-25T09:29:52Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MManager.java", "diffHunk": "@@ -931,9 +956,247 @@ public void setTTL(String storageGroup, long dataTTL) throws MetadataException,\n     }\n   }\n \n-  /**\n-   * Check whether the given path contains a storage group\n-   */\n+  public void changeOffset(String path, long offset) throws MetadataException {\n+    lock.writeLock().lock();\n+    try {\n+      ((LeafMNode)mtree.getNodeByPath(path)).setOffset(offset);\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+\n+  public void addAttributes(Map<String, String> attributesMap, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(Collections.EMPTY_MAP, attributesMap);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : attributesMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.right.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the attribute [%s].\", fullPath, key));\n+        }\n+        pair.right.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void addTags(Map<String, String> tagsMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, we need to add a new record in log\n+      if (leafMNode.getOffset() < 0) {\n+        long offset = tagLogFile.write(tagsMap, Collections.EMPTY_MAP);\n+        logWriter.changeOffset(fullPath, offset);\n+        leafMNode.setOffset(offset);\n+        return;\n+      }\n+\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : tagsMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        if (pair.left.containsKey(key)) {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] already has the tag [%s].\", fullPath, key));\n+        }\n+        pair.left.put(key, value);\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      // update tag inverted map\n+      tagsMap.forEach(\n+              (key, value) ->\n+                      tagIndex\n+                              .computeIfAbsent(key, k -> new HashMap<>())\n+                              .computeIfAbsent(value, v -> new HashSet<>())\n+                              .add(leafMNode));\n+\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void dropTag(Set<String> keySet, String fullPath) throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      // no tag or attribute, just do nothing.\n+      if (leafMNode.getOffset() < 0) {\n+        return;\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      Map<String, String> deleteTag = new HashMap<>();\n+      for (String key : keySet) {\n+        // check tag map\n+        // check attribute map\n+        if (pair.left.containsKey(key)) {\n+          deleteTag.put(key, pair.left.remove(key));\n+        } else {\n+          pair.right.remove(key);\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : deleteTag.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(value).remove(leafMNode);\n+        if (tagIndex.get(key).get(value).isEmpty()) {\n+          tagIndex.get(key).remove(value);\n+          if (tagIndex.get(key).isEmpty()) {\n+            tagIndex.remove(key);\n+          }\n+        }\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void setTag(Map<String, String> alterMap, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have any tag/attribute.\", fullPath));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+      Map<String, String> beforeTagValue = new HashMap<>();\n+      Map<String, String> currentTagValue = new HashMap<>();\n+      for (Entry<String, String> entry : alterMap.entrySet()) {\n+        String key = entry.getKey();\n+        String value = entry.getValue();\n+        // check tag map\n+        if (pair.left.containsKey(key)) {\n+          beforeTagValue.put(key, pair.left.get(key));\n+          currentTagValue.put(key, value);\n+          pair.left.put(key, value);\n+        } else if (pair.right.containsKey(key)) {\n+          // check attribute map\n+          pair.right.put(key, value);\n+        } else {\n+          throw new MetadataException(\n+                  String.format(\"TimeSeries [%s] does not have tag/attribute [%s].\", fullPath, key));\n+        }\n+      }\n+\n+      // persist the change to disk\n+      tagLogFile.write(pair.left, pair.right, leafMNode.getOffset());\n+\n+      for (Entry<String, String> entry : beforeTagValue.entrySet()) {\n+        String key = entry.getKey();\n+        String beforeValue = entry.getValue();\n+        String currentValue = currentTagValue.get(key);\n+        // change the tag inverted index map\n+        tagIndex.get(key).get(beforeValue).remove(leafMNode);\n+        tagIndex\n+                .computeIfAbsent(key, k -> new HashMap<>())\n+                .computeIfAbsent(currentValue, k -> new HashSet<>())\n+                .add(leafMNode);\n+      }\n+    } finally {\n+      lock.writeLock().unlock();\n+    }\n+  }\n+\n+  public void renameTag(String beforeName, String currentName, String fullPath)\n+      throws MetadataException, IOException {\n+    lock.writeLock().lock();\n+    try {\n+      MNode mNode = mtree.getNodeByPath(fullPath);\n+      if (!(mNode instanceof LeafMNode)) {\n+        throw new MetadataException(\"TimeSeries [\" + fullPath + \"] does not exist.\");\n+      }\n+      LeafMNode leafMNode = (LeafMNode) mNode;\n+      if (leafMNode.getOffset() < 0) {\n+        throw new MetadataException(\n+                String.format(\"TimeSeries [%s] does not have [%s] tag/attribute.\", fullPath, beforeName));\n+      }\n+      Pair<Map<String, String>, Map<String, String>> pair =\n+              tagLogFile.read(config.getTagAttributeTotalSize(), leafMNode.getOffset());\n+\n+      // current name has existed\n+      if (pair.left.containsKey(currentName) || pair.right.containsKey(currentName)) {\n+        throw new MetadataException(\n+                String.format(\n+                        \"TimeSeries [%s] already has a tag/attribute named [%s].\", fullPath, currentName));\n+      }\n+\n+      // check tag map\n+      if (pair.left.containsKey(beforeName)) {\n+        String value = pair.left.remove(beforeName);", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTAyMzk0NA==", "url": "https://github.com/apache/iotdb/pull/1096#discussion_r415023944", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void changeOffset(String path, long offset) throws IOException {\n          \n          \n            \n              public void setOffset(String path, long offset) throws IOException {", "author": "qiaojialin", "createdAt": "2020-04-25T09:30:53Z", "path": "server/src/main/java/org/apache/iotdb/db/metadata/MLogWriter.java", "diffHunk": "@@ -115,6 +115,12 @@ public void setTTL(String storageGroup, long ttl) throws IOException {\n     writer.flush();\n   }\n \n+  public void changeOffset(String path, long offset) throws IOException {", "originalCommit": "15963aa539b30d551726181c320fbdf02bca5241", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5d405613a98c80fd9c7fe5097d40bf4ab404efa7", "url": "https://github.com/apache/iotdb/commit/5d405613a98c80fd9c7fe5097d40bf4ab404efa7", "message": "reformat code", "committedDate": "2020-04-25T09:35:00Z", "type": "commit"}, {"oid": "4b118f69052a5e2342b4e1131d610e1243e0ba0d", "url": "https://github.com/apache/iotdb/commit/4b118f69052a5e2342b4e1131d610e1243e0ba0d", "message": "resolve conflict", "committedDate": "2020-04-25T14:15:24Z", "type": "commit"}, {"oid": "4b7842c7ea4b825904050d96c726016cc0dfd7b0", "url": "https://github.com/apache/iotdb/commit/4b7842c7ea4b825904050d96c726016cc0dfd7b0", "message": "add javadoc", "committedDate": "2020-04-25T14:27:43Z", "type": "commit"}, {"oid": "007da5d577e52f105e8a0f55ea85abbfadfb8c62", "url": "https://github.com/apache/iotdb/commit/007da5d577e52f105e8a0f55ea85abbfadfb8c62", "message": "fix sonar", "committedDate": "2020-04-25T14:44:22Z", "type": "commit"}]}