{"pr_number": 1401, "pr_title": "[Tmp IOTDB-706] Introduce virtual memtable for larger Chunk", "pr_createdAt": "2020-06-22T02:17:00Z", "pr_url": "https://github.com/apache/iotdb/pull/1401", "timeline": [{"oid": "72169dc1d6afc43fb8f1aab158d0fcaf83eed888", "url": "https://github.com/apache/iotdb/commit/72169dc1d6afc43fb8f1aab158d0fcaf83eed888", "message": "feat:add vm", "committedDate": "2020-06-19T15:24:29Z", "type": "commit"}, {"oid": "1771ef0934377ee309150b246f44e6bb1a55a49c", "url": "https://github.com/apache/iotdb/commit/1771ef0934377ee309150b246f44e6bb1a55a49c", "message": "fix chunkmeta bugs", "committedDate": "2020-06-21T09:40:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM0OTM2Mw==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443349363", "bodyText": "You can use getOrDefault method to save time", "author": "SilverNarcissus", "createdAt": "2020-06-22T06:51:47Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -497,6 +509,34 @@ else if (upgradeFolder.exists()) {\n     return new Pair<>(ret, upgradeRet);\n   }\n \n+  private Map<String, List<TsFileResource>> getAllVms(List<String> folders) throws IOException {\n+    List<File> vmFiles = new ArrayList<>();\n+    for (String baseDir : folders) {\n+      File fileFolder = fsFactory.getFile(baseDir, storageGroupName);\n+      if (!fileFolder.exists()) {\n+        continue;\n+      }\n+      Collections\n+          .addAll(vmFiles, fsFactory.listFilesBySuffix(fileFolder.getAbsolutePath(), VM_SUFFIX));\n+    }\n+\n+    Map<String, List<TsFileResource>> vmTsFileResourceMap = new HashMap<>();\n+    for (File f : vmFiles) {\n+      TsFileResource fileResource = new TsFileResource(f);\n+      fileResource.setClosed(false);\n+      // make sure the flush command is called before IoTDB is down.\n+      fileResource.deserialize();\n+      String tsfilePrefix = f.getName().split(TSFILE_SEPARATOR)[0];\n+      List<TsFileResource> vmTsFileResource = new ArrayList<>();\n+      if (vmTsFileResourceMap.containsKey(tsfilePrefix)) {\n+        vmTsFileResource = vmTsFileResourceMap.get(tsfilePrefix);", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1Mjk0NQ==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443352945", "bodyText": "Maybe you should use isVm and isFull to replace true, true", "author": "SilverNarcissus", "createdAt": "2020-06-22T07:00:28Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -549,15 +615,86 @@ public void flushOneMemTable() {\n     memTableToFlush = flushingMemTables.getFirst();\n     if (logger.isInfoEnabled()) {\n       logger.info(\"{}: {} starts to flush a memtable in a flush thread\", storageGroupName,\n-              tsFileResource.getFile().getName());\n+          tsFileResource.getFile().getName());\n     }\n     // signal memtable only may appear when calling asyncClose()\n     if (!memTableToFlush.isSignalMemTable()) {\n-      MemTableFlushTask flushTask = new MemTableFlushTask(memTableToFlush, writer,\n-          storageGroupName);\n       try {\n+        boolean isVm = false;\n+        boolean isFull = false;\n+        MemTableFlushTask flushTask;\n+        if (config.isEnableVm()) {\n+          long vmPointNum = 0;\n+          for (RestorableTsFileIOWriter vmWriter : vmWriters) {\n+            Map<String, Map<String, List<ChunkMetadata>>> metadatasForQuery = vmWriter\n+                .getMetadatasForQuery();\n+            for (String device : metadatasForQuery.keySet()) {\n+              Map<String, List<ChunkMetadata>> chunkMetadataListMap = metadatasForQuery.get(device);\n+              for (String sensor : chunkMetadataListMap.keySet()) {\n+                for (ChunkMetadata chunkMetadata : chunkMetadataListMap.get(sensor)) {\n+                  vmPointNum += chunkMetadata.getNumOfPoints();\n+                }\n+              }\n+            }\n+          }\n+          // all flush to target file\n+          if ((\n+              (vmPointNum + memTableToFlush.getTotalPointsNum()) / memTableToFlush.getSeriesNumber()\n+                  > config\n+                  .getMemtablePointThreshold()) || (shouldClose && flushingMemTables.size() == 1)) {\n+            isVm = false;\n+            isFull = false;\n+            flushTask = new MemTableFlushTask(memTableToFlush, writer, vmWriters, false,\n+                false,\n+                storageGroupName);\n+          } else {\n+            // merge vm files\n+            if (config.getMaxVmNum() <= vmTsFileResources.size()) {\n+              isVm = true;\n+              isFull = true;\n+              flushTask = new MemTableFlushTask(memTableToFlush, writer, vmWriters,\n+                  true, true,", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1MzA4MQ==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443353081", "bodyText": "like above~", "author": "SilverNarcissus", "createdAt": "2020-06-22T07:00:50Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -549,15 +615,86 @@ public void flushOneMemTable() {\n     memTableToFlush = flushingMemTables.getFirst();\n     if (logger.isInfoEnabled()) {\n       logger.info(\"{}: {} starts to flush a memtable in a flush thread\", storageGroupName,\n-              tsFileResource.getFile().getName());\n+          tsFileResource.getFile().getName());\n     }\n     // signal memtable only may appear when calling asyncClose()\n     if (!memTableToFlush.isSignalMemTable()) {\n-      MemTableFlushTask flushTask = new MemTableFlushTask(memTableToFlush, writer,\n-          storageGroupName);\n       try {\n+        boolean isVm = false;\n+        boolean isFull = false;\n+        MemTableFlushTask flushTask;\n+        if (config.isEnableVm()) {\n+          long vmPointNum = 0;\n+          for (RestorableTsFileIOWriter vmWriter : vmWriters) {\n+            Map<String, Map<String, List<ChunkMetadata>>> metadatasForQuery = vmWriter\n+                .getMetadatasForQuery();\n+            for (String device : metadatasForQuery.keySet()) {\n+              Map<String, List<ChunkMetadata>> chunkMetadataListMap = metadatasForQuery.get(device);\n+              for (String sensor : chunkMetadataListMap.keySet()) {\n+                for (ChunkMetadata chunkMetadata : chunkMetadataListMap.get(sensor)) {\n+                  vmPointNum += chunkMetadata.getNumOfPoints();\n+                }\n+              }\n+            }\n+          }\n+          // all flush to target file\n+          if ((\n+              (vmPointNum + memTableToFlush.getTotalPointsNum()) / memTableToFlush.getSeriesNumber()\n+                  > config\n+                  .getMemtablePointThreshold()) || (shouldClose && flushingMemTables.size() == 1)) {\n+            isVm = false;\n+            isFull = false;\n+            flushTask = new MemTableFlushTask(memTableToFlush, writer, vmWriters, false,\n+                false,\n+                storageGroupName);\n+          } else {\n+            // merge vm files\n+            if (config.getMaxVmNum() <= vmTsFileResources.size()) {\n+              isVm = true;\n+              isFull = true;\n+              flushTask = new MemTableFlushTask(memTableToFlush, writer, vmWriters,\n+                  true, true,\n+                  storageGroupName);\n+            } else {\n+              isVm = true;\n+              isFull = false;\n+              File newVmFile = createNewVMFile();\n+              vmTsFileResources.add(new TsFileResource(newVmFile));\n+              vmWriters.add(new RestorableTsFileIOWriter(newVmFile));\n+              flushTask = new MemTableFlushTask(memTableToFlush, writer, vmWriters,\n+                  true, false,\n+                  storageGroupName);", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1MzIwOA==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443353208", "bodyText": "like below~", "author": "SilverNarcissus", "createdAt": "2020-06-22T07:01:10Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -549,15 +615,86 @@ public void flushOneMemTable() {\n     memTableToFlush = flushingMemTables.getFirst();\n     if (logger.isInfoEnabled()) {\n       logger.info(\"{}: {} starts to flush a memtable in a flush thread\", storageGroupName,\n-              tsFileResource.getFile().getName());\n+          tsFileResource.getFile().getName());\n     }\n     // signal memtable only may appear when calling asyncClose()\n     if (!memTableToFlush.isSignalMemTable()) {\n-      MemTableFlushTask flushTask = new MemTableFlushTask(memTableToFlush, writer,\n-          storageGroupName);\n       try {\n+        boolean isVm = false;\n+        boolean isFull = false;\n+        MemTableFlushTask flushTask;\n+        if (config.isEnableVm()) {\n+          long vmPointNum = 0;\n+          for (RestorableTsFileIOWriter vmWriter : vmWriters) {\n+            Map<String, Map<String, List<ChunkMetadata>>> metadatasForQuery = vmWriter\n+                .getMetadatasForQuery();\n+            for (String device : metadatasForQuery.keySet()) {\n+              Map<String, List<ChunkMetadata>> chunkMetadataListMap = metadatasForQuery.get(device);\n+              for (String sensor : chunkMetadataListMap.keySet()) {\n+                for (ChunkMetadata chunkMetadata : chunkMetadataListMap.get(sensor)) {\n+                  vmPointNum += chunkMetadata.getNumOfPoints();\n+                }\n+              }\n+            }\n+          }\n+          // all flush to target file\n+          if ((\n+              (vmPointNum + memTableToFlush.getTotalPointsNum()) / memTableToFlush.getSeriesNumber()\n+                  > config\n+                  .getMemtablePointThreshold()) || (shouldClose && flushingMemTables.size() == 1)) {\n+            isVm = false;\n+            isFull = false;\n+            flushTask = new MemTableFlushTask(memTableToFlush, writer, vmWriters, false,\n+                false,", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkwOTU5Mg==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443909592", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # When a memTable's point num exceeds this, the vm memtable is flushed to disk. The default threshold is 1024.\n          \n          \n            \n            # When a memTable's average point nums of one chunk exceeds this, the vm memtable is flushed to disk. The default threshold is 1024.", "author": "JackieTien97", "createdAt": "2020-06-23T01:24:29Z", "path": "server/src/assembly/resources/conf/iotdb-engine.properties", "diffHunk": "@@ -245,6 +245,14 @@ default_fill_interval=-1\n ####################\n ### Merge Configurations\n ####################\n+# Is vm merge enable.\n+enable_vm=false\n+\n+# When a memTable's point num exceeds this, the vm memtable is flushed to disk. The default threshold is 1024.", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxMDYxMw==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443910613", "bodyText": "The default value is set so high, it that for convenience of testing while starting from IoTDB.java\uff1f", "author": "JackieTien97", "createdAt": "2020-06-23T01:28:41Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -440,6 +441,21 @@\n    */\n   private int mergeThreadNum = 1;\n \n+  /**\n+   * Is vm merge enable\n+   */\n+  private boolean enableVm = true;\n+\n+  /**\n+   * When a memTable's point num exceeds this, the vm memtable is flushed to disk\n+   */\n+  private int memtablePointThreshold = 1024;\n+\n+  /**\n+   * The max vm num of each memtable. When vm num exceeds this, the vm files will merge to one.\n+   */\n+  private int maxVmNum = 100000;", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkxMDkxNw==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443910917", "bodyText": "change back,  the Notice statement should be a new line", "author": "JackieTien97", "createdAt": "2020-06-23T01:29:58Z", "path": "server/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java", "diffHunk": "@@ -556,9 +572,9 @@\n   private int defaultFillInterval = -1;\n \n   /**\n-   * default TTL for storage groups that are not set TTL by statements, in ms\n-   * Notice: if this property is changed, previous created storage group which are not set TTL will\n-   * also be affected.\n+   * default TTL for storage groups that are not set TTL by statements, in ms Notice: if this\n+   * property is changed, previous created storage group which are not set TTL will also be", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk0MTM1Mw==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443941353", "bodyText": "While isVM=false and isFull=false, it seems that the current memTable will be firstly written into writer,  and then all the vm files will be merge and written into writer. However, we should firstly merge the current memTable with all the vm files and then write all of them into writer together instead of separating them.", "author": "JackieTien97", "createdAt": "2020-06-23T03:31:12Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/flush/MemTableFlushTask.java", "diffHunk": "@@ -230,12 +294,56 @@ public void run() {\n         long starTime = System.currentTimeMillis();\n         try {\n           if (ioMessage instanceof StartFlushGroupIOTask) {\n-            writer.startChunkGroup(((StartFlushGroupIOTask) ioMessage).deviceId);\n+            if (isVm) {\n+              this.vmWriters\n+                  .get(MemTableFlushTask.this.vmWriters.size() - 1)\n+                  .startChunkGroup(((StartFlushGroupIOTask) ioMessage).deviceId);\n+            } else {\n+              writer.startChunkGroup(((StartFlushGroupIOTask) ioMessage).deviceId);\n+            }\n+          } else if (ioMessage instanceof MergeVmIoTask) {\n+            RestorableTsFileIOWriter mergeWriter = ((MergeVmIoTask) ioMessage).mergeWriter;\n+            for (String deviceId : memTable.getMemTableMap().keySet()) {\n+              mergeWriter.startChunkGroup(deviceId);\n+              for (String measurementId : memTable.getMemTableMap().get(deviceId).keySet()) {\n+                ChunkMetadata newChunkMetadata = null;\n+                Chunk newChunk = null;\n+                for (RestorableTsFileIOWriter vmWriter : vmWriters) {\n+                  TsFileSequenceReader reader = new TsFileSequenceReader(\n+                      vmWriter.getFile().getAbsolutePath());\n+                  List<ChunkMetadata> chunkMetadataList = vmWriter.getMetadatasForQuery()\n+                      .get(deviceId).get(measurementId);\n+                  for (ChunkMetadata chunkMetadata : chunkMetadataList) {\n+                    Chunk chunk = reader.readMemChunk(chunkMetadata);\n+                    if (newChunkMetadata == null) {\n+                      newChunkMetadata = chunkMetadata;\n+                      newChunk = chunk;\n+                    } else {\n+                      newChunkMetadata.mergeChunkMetadata(chunkMetadata);\n+                      newChunk.mergeChunk(chunk);\n+                    }\n+                  }\n+                }\n+                if (newChunkMetadata != null && newChunk != null) {\n+                  mergeWriter.writeChunk(newChunk, newChunkMetadata);\n+                }\n+              }\n+              mergeWriter.endChunkGroup();\n+            }", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk2MzExOQ==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443963119", "bodyText": "same as above", "author": "JackieTien97", "createdAt": "2020-06-23T05:04:38Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -228,22 +230,20 @@\n   private TsFileFlushPolicy fileFlushPolicy;\n \n   /**\n-   * partitionDirectFileVersions records the versions of the direct TsFiles (generated by close,\n-   * not including the files generated by merge) of each partition.\n-   * As data file close is managed by the leader in the distributed version, the files with the\n-   * same version(s) have the same data, despite that the inner structure (the size and\n-   * organization of chunks) may be different, so we can easily find what remote files we do not\n-   * have locally.\n-   * partition number -> version number set\n+   * partitionDirectFileVersions records the versions of the direct TsFiles (generated by close, not\n+   * including the files generated by merge) of each partition. As data file close is managed by the\n+   * leader in the distributed version, the files with the same version(s) have the same data,\n+   * despite that the inner structure (the size and organization of chunks) may be different, so we\n+   * can easily find what remote files we do not have locally. partition number -> version number\n+   * set\n    */\n   private Map<Long, Set<Long>> partitionDirectFileVersions = new HashMap<>();\n \n   /**\n-   * The max file versions in each partition. By recording this, if several IoTDB instances have\n-   * the same policy of closing file and their ingestion is identical, then files of the same\n-   * version in different IoTDB instance will have identical data, providing convenience for data\n-   * comparison across different instances.\n-   * partition number -> max version number\n+   * The max file versions in each partition. By recording this, if several IoTDB instances have the\n+   * same policy of closing file and their ingestion is identical, then files of the same version in\n+   * different IoTDB instance will have identical data, providing convenience for data comparison\n+   * across different instances. partition number -> max version number", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk2MzE3MQ==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443963171", "bodyText": "change back", "author": "JackieTien97", "createdAt": "2020-06-23T05:04:43Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -228,22 +230,20 @@\n   private TsFileFlushPolicy fileFlushPolicy;\n \n   /**\n-   * partitionDirectFileVersions records the versions of the direct TsFiles (generated by close,\n-   * not including the files generated by merge) of each partition.\n-   * As data file close is managed by the leader in the distributed version, the files with the\n-   * same version(s) have the same data, despite that the inner structure (the size and\n-   * organization of chunks) may be different, so we can easily find what remote files we do not\n-   * have locally.\n-   * partition number -> version number set\n+   * partitionDirectFileVersions records the versions of the direct TsFiles (generated by close, not\n+   * including the files generated by merge) of each partition. As data file close is managed by the\n+   * leader in the distributed version, the files with the same version(s) have the same data,\n+   * despite that the inner structure (the size and organization of chunks) may be different, so we\n+   * can easily find what remote files we do not have locally. partition number -> version number\n+   * set", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk2MzIwNg==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443963206", "bodyText": "same as above", "author": "JackieTien97", "createdAt": "2020-06-23T05:04:48Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -228,22 +230,20 @@\n   private TsFileFlushPolicy fileFlushPolicy;\n \n   /**\n-   * partitionDirectFileVersions records the versions of the direct TsFiles (generated by close,\n-   * not including the files generated by merge) of each partition.\n-   * As data file close is managed by the leader in the distributed version, the files with the\n-   * same version(s) have the same data, despite that the inner structure (the size and\n-   * organization of chunks) may be different, so we can easily find what remote files we do not\n-   * have locally.\n-   * partition number -> version number set\n+   * partitionDirectFileVersions records the versions of the direct TsFiles (generated by close, not\n+   * including the files generated by merge) of each partition. As data file close is managed by the\n+   * leader in the distributed version, the files with the same version(s) have the same data,\n+   * despite that the inner structure (the size and organization of chunks) may be different, so we\n+   * can easily find what remote files we do not have locally. partition number -> version number\n+   * set\n    */\n   private Map<Long, Set<Long>> partitionDirectFileVersions = new HashMap<>();\n \n   /**\n-   * The max file versions in each partition. By recording this, if several IoTDB instances have\n-   * the same policy of closing file and their ingestion is identical, then files of the same\n-   * version in different IoTDB instance will have identical data, providing convenience for data\n-   * comparison across different instances.\n-   * partition number -> max version number\n+   * The max file versions in each partition. By recording this, if several IoTDB instances have the\n+   * same policy of closing file and their ingestion is identical, then files of the same version in\n+   * different IoTDB instance will have identical data, providing convenience for data comparison\n+   * across different instances. partition number -> max version number", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk2NDU4NA==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443964584", "bodyText": "change back", "author": "JackieTien97", "createdAt": "2020-06-23T05:10:22Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -710,8 +758,8 @@ private boolean isAlive(long time) {\n   }\n \n   /**\n-   * insert batch to tsfile processor thread-safety that the caller need to guarantee\n-   * The rows to be inserted are in the range [start, end)\n+   * insert batch to tsfile processor thread-safety that the caller need to guarantee The rows to be\n+   * inserted are in the range [start, end)", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk2NDk0Mw==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443964943", "bodyText": "change back", "author": "JackieTien97", "createdAt": "2020-06-23T05:11:43Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1858,12 +1907,12 @@ private long computeMaxVersion(Long oldVersion, Long newVersion) {\n   }\n \n   /**\n-   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into them.\n-   * @param newTsFileResource\n-   * @param newFilePartitionId\n-   * @return POS_ALREADY_EXIST(-2) if some file has the same name as the one to be inserted\n-   *         POS_OVERLAP(-3) if some file overlaps the new file\n-   *         an insertion position i >= -1 if the new file can be inserted between [i, i+1]\n+   * Find the position of \"newTsFileResource\" in the sequence files if it can be inserted into\n+   * them.\n+   *\n+   * @return POS_ALREADY_EXIST(- 2) if some file has the same name as the one to be inserted\n+   * POS_OVERLAP(-3) if some file overlaps the new file an insertion position i >= -1 if the new\n+   * file can be inserted between [i, i+1]", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk2NDk3NQ==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443964975", "bodyText": "change back", "author": "JackieTien97", "createdAt": "2020-06-23T05:11:53Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1904,11 +1953,9 @@ private int findInsertionPosition(TsFileResource newTsFileResource, long newFile\n \n   /**\n    * Compare each device in the two files to find the time relation of them.\n-   * @param fileA\n-   * @param fileB\n-   * @return -1 if fileA is totally older than fileB (A < B)\n-   *          0 if fileA is partially older than fileB and partially newer than fileB (A X B)\n-   *          1 if fileA is totally newer than fileB (B < A)\n+   *\n+   * @return -1 if fileA is totally older than fileB (A < B) 0 if fileA is partially older than\n+   * fileB and partially newer than fileB (A X B) 1 if fileA is totally newer than fileB (B < A)", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk2NTA0Ng==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443965046", "bodyText": "change back", "author": "JackieTien97", "createdAt": "2020-06-23T05:12:13Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "diffHunk": "@@ -1944,11 +1991,9 @@ private int compareTsFileDevices(TsFileResource fileA, TsFileResource fileB) {\n   }\n \n   /**\n-   * If the historical versions of a file is a sub-set of the given file's, (close and) remove it to reduce\n-   * unnecessary merge. Only used when the file sender and the receiver share the same file\n-   * close policy.\n-   * Warning: DO NOT REMOVE\n-   * @param resource\n+   * If the historical versions of a file is a sub-set of the given file's, (close and) remove it to\n+   * reduce unnecessary merge. Only used when the file sender and the receiver share the same file\n+   * close policy. Warning: DO NOT REMOVE", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk2NzU0OA==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443967548", "bodyText": "change back", "author": "JackieTien97", "createdAt": "2020-06-23T05:20:08Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -400,8 +419,8 @@ void asyncClose() {\n   }\n \n   /**\n-   * TODO if the flushing thread is too fast, the tmpMemTable.wait() may never wakeup\n-   * Tips: I am trying to solve this issue by checking whether the table exist before wait()\n+   * TODO if the flushing thread is too fast, the tmpMemTable.wait() may never wakeup Tips: I am\n+   * trying to solve this issue by checking whether the table exist before wait()", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzk3MjE0MQ==", "url": "https://github.com/apache/iotdb/pull/1401#discussion_r443972141", "bodyText": "The denominator should add the number of series that exist in vmWriters but not in memTableToFlush", "author": "JackieTien97", "createdAt": "2020-06-23T05:34:39Z", "path": "server/src/main/java/org/apache/iotdb/db/engine/storagegroup/TsFileProcessor.java", "diffHunk": "@@ -549,15 +615,86 @@ public void flushOneMemTable() {\n     memTableToFlush = flushingMemTables.getFirst();\n     if (logger.isInfoEnabled()) {\n       logger.info(\"{}: {} starts to flush a memtable in a flush thread\", storageGroupName,\n-              tsFileResource.getFile().getName());\n+          tsFileResource.getFile().getName());\n     }\n     // signal memtable only may appear when calling asyncClose()\n     if (!memTableToFlush.isSignalMemTable()) {\n-      MemTableFlushTask flushTask = new MemTableFlushTask(memTableToFlush, writer,\n-          storageGroupName);\n       try {\n+        boolean isVm = false;\n+        boolean isFull = false;\n+        MemTableFlushTask flushTask;\n+        if (config.isEnableVm()) {\n+          long vmPointNum = 0;\n+          for (RestorableTsFileIOWriter vmWriter : vmWriters) {\n+            Map<String, Map<String, List<ChunkMetadata>>> metadatasForQuery = vmWriter\n+                .getMetadatasForQuery();\n+            for (String device : metadatasForQuery.keySet()) {\n+              Map<String, List<ChunkMetadata>> chunkMetadataListMap = metadatasForQuery.get(device);\n+              for (String sensor : chunkMetadataListMap.keySet()) {\n+                for (ChunkMetadata chunkMetadata : chunkMetadataListMap.get(sensor)) {\n+                  vmPointNum += chunkMetadata.getNumOfPoints();\n+                }\n+              }\n+            }\n+          }\n+          // all flush to target file\n+          if ((\n+              (vmPointNum + memTableToFlush.getTotalPointsNum()) / memTableToFlush.getSeriesNumber()", "originalCommit": "1771ef0934377ee309150b246f44e6bb1a55a49c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ea534cf2d97afa88cf1c6e6fc5cc4443cd32ebcd", "url": "https://github.com/apache/iotdb/commit/ea534cf2d97afa88cf1c6e6fc5cc4443cd32ebcd", "message": "update hot merge", "committedDate": "2020-06-23T09:35:25Z", "type": "commit"}, {"oid": "de6130e27bf62bf5d765159e58174c4d6441ecbd", "url": "https://github.com/apache/iotdb/commit/de6130e27bf62bf5d765159e58174c4d6441ecbd", "message": "Merge branch 'hot_compaction' into add_vm_merge\n\n# Conflicts:\n#\tserver/src/main/java/org/apache/iotdb/db/conf/IoTDBConfig.java\n#\tserver/src/main/java/org/apache/iotdb/db/engine/storagegroup/StorageGroupProcessor.java", "committedDate": "2020-06-23T09:38:55Z", "type": "commit"}]}