{"pr_number": 1157, "pr_title": "[IOTDB-567] Apache IoTDB's Peer Tracker for The Raft Protocol", "pr_createdAt": "2020-05-06T07:17:53Z", "pr_url": "https://github.com/apache/iotdb/pull/1157", "timeline": [{"oid": "373c55b80383733beabde1946acf2d5b69663622", "url": "https://github.com/apache/iotdb/commit/373c55b80383733beabde1946acf2d5b69663622", "message": "fix a leader_not_found bug by amending appendEntry rpc", "committedDate": "2020-05-01T08:28:45Z", "type": "commit"}, {"oid": "5a8e06f00513891af02e6acd9369891fa93ac141", "url": "https://github.com/apache/iotdb/commit/5a8e06f00513891af02e6acd9369891fa93ac141", "message": "fix addnode failed", "committedDate": "2020-05-06T01:45:04Z", "type": "commit"}, {"oid": "12c4eb8c028bf7ffa381df0cb18f8309c6ff3ca8", "url": "https://github.com/apache/iotdb/commit/12c4eb8c028bf7ffa381df0cb18f8309c6ff3ca8", "message": "add peer tracker", "committedDate": "2020-05-06T05:37:39Z", "type": "commit"}, {"oid": "398a9da4c0438ce2f0f466c895d96313a752f7c4", "url": "https://github.com/apache/iotdb/commit/398a9da4c0438ce2f0f466c895d96313a752f7c4", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_peer_tracker", "committedDate": "2020-05-06T06:14:18Z", "type": "commit"}, {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d", "url": "https://github.com/apache/iotdb/commit/701f328eb1ed191f38482f1d192fb067d1ec3d5d", "message": "add checkTest", "committedDate": "2020-05-06T08:25:39Z", "type": "forcePushed"}, {"oid": "701f328eb1ed191f38482f1d192fb067d1ec3d5d", "url": "https://github.com/apache/iotdb/commit/701f328eb1ed191f38482f1d192fb067d1ec3d5d", "message": "add checkTest", "committedDate": "2020-05-06T08:25:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMzIwOA==", "url": "https://github.com/apache/iotdb/pull/1157#discussion_r421203208", "bodyText": "It would be better to perform a binary search, but it is fine for now.", "author": "jt2594838", "createdAt": "2020-05-07T02:31:47Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/catchup/CatchUpTask.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.catchup;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.rpc.thrift.AppendEntryRequest;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.rpc.thrift.RaftService.AsyncClient;\n+import org.apache.iotdb.cluster.server.NodeCharacter;\n+import org.apache.iotdb.cluster.server.Peer;\n+import org.apache.iotdb.cluster.server.RaftServer;\n+import org.apache.iotdb.cluster.server.handlers.caller.LogCatchUpHandler;\n+import org.apache.iotdb.cluster.server.member.RaftMember;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CatchUpTask implements Runnable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LogCatchUpTask.class);\n+\n+  private Node node;\n+  private Peer peer;\n+  private RaftMember raftMember;\n+  private Snapshot snapshot;\n+  private List<Log> logs;\n+\n+\n+  public CatchUpTask(Node node, Peer peer, RaftMember raftMember) {\n+    this.node = node;\n+    this.peer = peer;\n+    this.raftMember = raftMember;\n+    this.logs = Collections.emptyList();\n+    this.snapshot = null;\n+  }\n+\n+  boolean checkMatchIndex() throws TException, InterruptedException {\n+    AppendEntryRequest request = new AppendEntryRequest();\n+    AtomicBoolean isMatch = new AtomicBoolean(false);\n+\n+    LogCatchUpHandler handler = new LogCatchUpHandler();\n+    handler.setAppendSucceed(isMatch);\n+    handler.setRaftMember(raftMember);\n+    handler.setFollower(node);\n+    if (raftMember.getHeader() != null) {\n+      request.setHeader(raftMember.getHeader());\n+    }\n+    request.setLeader(raftMember.getThisNode());\n+    // not update follower's commitIndex in order to append the log which index is matchIndex twice\n+    request.setLeaderCommit(-1);\n+    synchronized (raftMember.getLogManager()) {\n+      peer.setNextIndex(raftMember.getLogManager().getLastLogIndex());\n+      try {\n+        logs = raftMember.getLogManager().getEntries(\n+            Math.max(raftMember.getLogManager().getFirstIndex(), peer.getMatchIndex() + 1),\n+            peer.getNextIndex() + 1);\n+      } catch (Exception e) {\n+        logger.error(\"Unexpected error in logManager's getEntries during matchIndexCheck\", e);\n+      }\n+    }\n+\n+    int index = logs.size() - 1;\n+    EmptyContentLog emptyLog = new EmptyContentLog();\n+    while (index >= 0) {\n+      Log log = logs.get(index);\n+      emptyLog.setCurrLogIndex(log.getCurrLogIndex());\n+      emptyLog.setCurrLogTerm(log.getCurrLogTerm());\n+      synchronized (raftMember.getTerm()) {\n+        // make sure this node is still a leader\n+        if (raftMember.getCharacter() != NodeCharacter.LEADER) {\n+          logger.debug(\"Leadership is lost when doing a catch-up to {}, aborting\", node);\n+          break;\n+        }\n+        request.setTerm(raftMember.getTerm().get());\n+      }\n+      if (index > 0) {\n+        request.setPrevLogIndex(logs.get(index - 1).getCurrLogIndex());\n+        request.setPrevLogTerm(logs.get(index - 1).getCurrLogTerm());\n+      } else {\n+        request.setPrevLogIndex(log.getCurrLogIndex() - 1);\n+        try {\n+          request.setPrevLogTerm(raftMember.getLogManager().getTerm(log.getCurrLogIndex() - 1));\n+        } catch (Exception e) {\n+          logger.error(\"getTerm failed for newly append entries\", e);\n+        }\n+      }\n+\n+      handler.setLog(log);\n+      request.setEntry(emptyLog.serialize());\n+\n+      synchronized (isMatch) {\n+        AsyncClient client = raftMember.connectNode(node);\n+        if (client == null) {\n+          break;\n+        }\n+        client.appendEntry(request, handler);\n+        raftMember.getLastCatchUpResponseTime().put(node, System.currentTimeMillis());\n+        isMatch.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      if (isMatch.get()) {\n+        // if follower return RESPONSE.AGREE with this empty log, then start sending real logs from this emptyContentLog's index.\n+        // which means the log which index is matchIndex will be send twice, but at the first time it sent an empty log.\n+        logs.subList(0, index).clear();\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", raftMember.getName(), node,\n+              logs.size());\n+        }\n+        return false;\n+      }\n+      index--;", "originalCommit": "701f328eb1ed191f38482f1d192fb067d1ec3d5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxNDc0OA==", "url": "https://github.com/apache/iotdb/pull/1157#discussion_r421214748", "bodyText": "Inconsistencies are generally rare, and there aren't many missing logs, so this may actually be enough. If a performance bottleneck occurs, I will modify here ~", "author": "LebronAl", "createdAt": "2020-05-07T03:16:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMzIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMzgzMw==", "url": "https://github.com/apache/iotdb/pull/1157#discussion_r421203833", "bodyText": "Batched log catch-up has been introduced, better to switch to better.", "author": "jt2594838", "createdAt": "2020-05-07T02:34:13Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/catchup/CatchUpTask.java", "diffHunk": "@@ -0,0 +1,169 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.catchup;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.rpc.thrift.AppendEntryRequest;\n+import org.apache.iotdb.cluster.rpc.thrift.Node;\n+import org.apache.iotdb.cluster.rpc.thrift.RaftService.AsyncClient;\n+import org.apache.iotdb.cluster.server.NodeCharacter;\n+import org.apache.iotdb.cluster.server.Peer;\n+import org.apache.iotdb.cluster.server.RaftServer;\n+import org.apache.iotdb.cluster.server.handlers.caller.LogCatchUpHandler;\n+import org.apache.iotdb.cluster.server.member.RaftMember;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CatchUpTask implements Runnable {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(LogCatchUpTask.class);\n+\n+  private Node node;\n+  private Peer peer;\n+  private RaftMember raftMember;\n+  private Snapshot snapshot;\n+  private List<Log> logs;\n+\n+\n+  public CatchUpTask(Node node, Peer peer, RaftMember raftMember) {\n+    this.node = node;\n+    this.peer = peer;\n+    this.raftMember = raftMember;\n+    this.logs = Collections.emptyList();\n+    this.snapshot = null;\n+  }\n+\n+  boolean checkMatchIndex() throws TException, InterruptedException {\n+    AppendEntryRequest request = new AppendEntryRequest();\n+    AtomicBoolean isMatch = new AtomicBoolean(false);\n+\n+    LogCatchUpHandler handler = new LogCatchUpHandler();\n+    handler.setAppendSucceed(isMatch);\n+    handler.setRaftMember(raftMember);\n+    handler.setFollower(node);\n+    if (raftMember.getHeader() != null) {\n+      request.setHeader(raftMember.getHeader());\n+    }\n+    request.setLeader(raftMember.getThisNode());\n+    // not update follower's commitIndex in order to append the log which index is matchIndex twice\n+    request.setLeaderCommit(-1);\n+    synchronized (raftMember.getLogManager()) {\n+      peer.setNextIndex(raftMember.getLogManager().getLastLogIndex());\n+      try {\n+        logs = raftMember.getLogManager().getEntries(\n+            Math.max(raftMember.getLogManager().getFirstIndex(), peer.getMatchIndex() + 1),\n+            peer.getNextIndex() + 1);\n+      } catch (Exception e) {\n+        logger.error(\"Unexpected error in logManager's getEntries during matchIndexCheck\", e);\n+      }\n+    }\n+\n+    int index = logs.size() - 1;\n+    EmptyContentLog emptyLog = new EmptyContentLog();\n+    while (index >= 0) {\n+      Log log = logs.get(index);\n+      emptyLog.setCurrLogIndex(log.getCurrLogIndex());\n+      emptyLog.setCurrLogTerm(log.getCurrLogTerm());\n+      synchronized (raftMember.getTerm()) {\n+        // make sure this node is still a leader\n+        if (raftMember.getCharacter() != NodeCharacter.LEADER) {\n+          logger.debug(\"Leadership is lost when doing a catch-up to {}, aborting\", node);\n+          break;\n+        }\n+        request.setTerm(raftMember.getTerm().get());\n+      }\n+      if (index > 0) {\n+        request.setPrevLogIndex(logs.get(index - 1).getCurrLogIndex());\n+        request.setPrevLogTerm(logs.get(index - 1).getCurrLogTerm());\n+      } else {\n+        request.setPrevLogIndex(log.getCurrLogIndex() - 1);\n+        try {\n+          request.setPrevLogTerm(raftMember.getLogManager().getTerm(log.getCurrLogIndex() - 1));\n+        } catch (Exception e) {\n+          logger.error(\"getTerm failed for newly append entries\", e);\n+        }\n+      }\n+\n+      handler.setLog(log);\n+      request.setEntry(emptyLog.serialize());\n+\n+      synchronized (isMatch) {\n+        AsyncClient client = raftMember.connectNode(node);\n+        if (client == null) {\n+          break;\n+        }\n+        client.appendEntry(request, handler);\n+        raftMember.getLastCatchUpResponseTime().put(node, System.currentTimeMillis());\n+        isMatch.wait(RaftServer.connectionTimeoutInMS);\n+      }\n+      if (isMatch.get()) {\n+        // if follower return RESPONSE.AGREE with this empty log, then start sending real logs from this emptyContentLog's index.\n+        // which means the log which index is matchIndex will be send twice, but at the first time it sent an empty log.\n+        logs.subList(0, index).clear();\n+        if (logger.isDebugEnabled()) {\n+          logger.debug(\"{} makes {} catch up with {} cached logs\", raftMember.getName(), node,\n+              logs.size());\n+        }\n+        return false;\n+      }\n+      index--;\n+    }\n+    try {\n+      raftMember.getLogManager().takeSnapshot();\n+    } catch (IOException e) {\n+      logger.error(\"Unexpected error when taking snapshot.\", e);\n+    }\n+    snapshot = raftMember.getLogManager().getSnapshot();\n+    if (logger.isDebugEnabled()) {\n+      logger\n+          .debug(\"{}: Logs in {} are too old, catch up with snapshot\", raftMember.getName(), node);\n+    }\n+    return true;\n+  }\n+\n+  public void run() {\n+    try {\n+      if (checkMatchIndex()) {\n+        SnapshotCatchUpTask task = new SnapshotCatchUpTask(logs, snapshot, node, raftMember);\n+        task.run();\n+      } else {\n+        LogCatchUpTask task = new LogCatchUpTask(logs, node, raftMember);\n+        task.run();\n+      }", "originalCommit": "701f328eb1ed191f38482f1d192fb067d1ec3d5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIxNTc1Mg==", "url": "https://github.com/apache/iotdb/pull/1157#discussion_r421215752", "bodyText": "Batched log catch-up or not is only related to the configuration item, and the code here supports batched log catch-up if related configuration item has been set~", "author": "LebronAl", "createdAt": "2020-05-07T03:20:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTIwMzgzMw=="}], "type": "inlineReview"}, {"oid": "4f30050d78638fec749b19a19cc31ec25482bb64", "url": "https://github.com/apache/iotdb/commit/4f30050d78638fec749b19a19cc31ec25482bb64", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_peer_tracker", "committedDate": "2020-05-07T03:30:38Z", "type": "commit"}, {"oid": "1e7590f46abd0b6bd10acd99e4219e3f9f31e7e0", "url": "https://github.com/apache/iotdb/commit/1e7590f46abd0b6bd10acd99e4219e3f9f31e7e0", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_peer_tracker", "committedDate": "2020-05-07T03:39:31Z", "type": "commit"}, {"oid": "1ce349b8b09e2d3dd3a385a02dda15a9aac375ed", "url": "https://github.com/apache/iotdb/commit/1ce349b8b09e2d3dd3a385a02dda15a9aac375ed", "message": "Merge branch 'cluster_new' of github.com:Apache/incubator-iotdb into cluster_new_peer_tracker", "committedDate": "2020-05-07T03:45:20Z", "type": "commit"}]}