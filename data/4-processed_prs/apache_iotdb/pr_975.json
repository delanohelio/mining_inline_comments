{"pr_number": 975, "pr_title": "Refactoring raft log module", "pr_createdAt": "2020-04-02T12:28:12Z", "pr_url": "https://github.com/apache/iotdb/pull/975", "timeline": [{"oid": "f4d38afc8c868224c46a40f3cb73ee17e90cc3f4", "url": "https://github.com/apache/iotdb/commit/f4d38afc8c868224c46a40f3cb73ee17e90cc3f4", "message": "add applyingSnapshot & adjust logger level & update JavaDoc", "committedDate": "2020-04-02T12:30:15Z", "type": "forcePushed"}, {"oid": "4977debad6fa9390d1610d9ebf5b7831d6b06496", "url": "https://github.com/apache/iotdb/commit/4977debad6fa9390d1610d9ebf5b7831d6b06496", "message": "add maybeCommit for leader", "committedDate": "2020-04-03T09:21:41Z", "type": "forcePushed"}, {"oid": "2a506b74edbff00bc878f5a959348b19eb227d48", "url": "https://github.com/apache/iotdb/commit/2a506b74edbff00bc878f5a959348b19eb227d48", "message": "rename snapshot lastLogId to lastLogIndex", "committedDate": "2020-04-06T09:49:22Z", "type": "forcePushed"}, {"oid": "3508760b387ed18913904c7ea5ab8323372adec8", "url": "https://github.com/apache/iotdb/commit/3508760b387ed18913904c7ea5ab8323372adec8", "message": "Use native snapshot && update license", "committedDate": "2020-04-06T10:10:08Z", "type": "forcePushed"}, {"oid": "c21f8268b132fbfed7a826e9797585ed24def997", "url": "https://github.com/apache/iotdb/commit/c21f8268b132fbfed7a826e9797585ed24def997", "message": "Use native snapshot && update license", "committedDate": "2020-04-07T00:49:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyODQ0MA==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r404728440", "bodyText": "If the caller change the subList, our manager will be impacted. You can use a new arrayList to return or add some comment at the method", "author": "SilverNarcissus", "createdAt": "2020-04-07T11:13:46Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/UnCommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log;\n+\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class UnCommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnCommittedEntryManager.class);\n+    // all entries that have not been committed.\n+    private List<Log> entries;\n+    // the first uncommitted entry index.\n+    private long offset;\n+\n+    public UnCommittedEntryManager(long offset) {\n+        this.offset = offset;\n+        this.entries = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Return the first uncommitted index.\n+     *\n+     * @return offset\n+     */\n+    public long getFirstUnCommittedIndex() {\n+        return offset;\n+    }\n+\n+\n+    /**\n+     * Return last entry's index if this instance has at least one uncommitted entry.\n+     *\n+     * @return -1 if entries are empty, or last entry's index\n+     */\n+    public long maybeLastIndex() {\n+        int entryNum = entries.size();\n+        if (entryNum != 0) {\n+            return offset + entryNum - 1;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index.\n+     * Note that the called should ensure index >= offset.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index < offset, throw EntryUnavailableException if\n+     * index > last or entries is empty, or return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     */\n+    public long maybeTerm(long index) throws EntryUnavailableException {\n+        if (index < offset) {\n+            logger.debug(\"invalid unCommittedEntryManager maybeTerm : parameter: index({}) < offset({})\", index, offset);\n+            return -1;\n+        }\n+        long last = maybeLastIndex();\n+        if (last == -1 || index > last) {\n+            long boundary = last == -1 ? offset - 1 : last;\n+            logger.info(\"unCommittedEntryManager maybeTerm out of bound : parameter: index({}) > lastIndex({})\", index, boundary);\n+            throw new EntryUnavailableException(index, boundary);\n+        }\n+        return entries.get((int) (index - offset)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Remove useless prefix entries as long as these entries has been committed and persisted.\n+     * This method is only called after persisting newly committed entries.\n+     *\n+     * @param index request entry's index\n+     * @param term  request entry's term\n+     */\n+    public void stableTo(long index, long term) {\n+        try {\n+            long entryTerm = maybeTerm(index);\n+            // only update the uncommitted entries if term is matched with an uncommitted entry.\n+            if (entryTerm == term) {\n+                entries.subList(0, (int) (index + 1 - offset)).clear();\n+                offset = index + 1;\n+            }\n+        } catch (EntryUnavailableException e) {\n+            logger.info(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Update offset and clear entries because leader's snapshot is more up-to-date.\n+     * This method is only called for applying snapshot from leader.\n+     *\n+     * @param snapshot leader's snapshot\n+     */\n+    public void applyingSnapshot(Snapshot snapshot) {\n+        this.offset = snapshot.getLastLogIndex() + 1;\n+        this.entries.clear();\n+    }\n+\n+    /**\n+     * TruncateAndAppend uncommitted entries.\n+     * This method will truncate conflict entries if it finds inconsistencies.\n+     * Note that the caller should ensure appendingEntries[0].index <= entries[entries.size()-1].index + 1.\n+     * Note that the caller should ensure not to truncate entries which have been committed.\n+     *\n+     * @param appendingEntries request entries\n+     */\n+    public void truncateAndAppend(List<Log> appendingEntries) {\n+        long after = appendingEntries.get(0).getCurrLogIndex();\n+        long len = after - offset;\n+        if (len < 0) {\n+            // the logs are being truncated to before our current offset portion, which is committed entries\n+            // unconditional obedience to the leader's request. Maybe throw a exception here is better\n+            offset = after;\n+            entries = appendingEntries;\n+            logger.error(\"The logs which first index is {} are going to truncate committed logs\", after);\n+        } else if (len == entries.size()) {\n+            // after is the next index in the entries\n+            // directly append\n+            entries.addAll(appendingEntries);\n+        } else {\n+            // clear conflict entries\n+            // then append\n+            logger.info(\"truncate the entries after index {}\", after);\n+            int truncateIndex = (int) (after - offset);\n+            if (truncateIndex < entries.size()) {\n+                entries.subList(truncateIndex, entries.size()).clear();\n+            }\n+            entries.addAll(appendingEntries);\n+        }\n+    }\n+\n+    /**\n+     * Pack entries from low through high - 1, just like slice (entries[low:high]).\n+     * offset <= low <= high.\n+     * Note that caller must ensure low <= high.\n+     *\n+     * @param low  request index low bound\n+     * @param high request index upper bound\n+     */\n+    public List<Log> getEntries(long low, long high) {\n+        if (low > high) {\n+            logger.debug(\"invalid unCommittedEntryManager getEntries: parameter: low({}) > high({})\", low, high);\n+        }\n+        long upper = offset + entries.size();\n+        if (low > upper) {\n+            // don't throw a exception to support\n+            // getEntries(low, Integer.MAX_VALUE) if low is larger than lastIndex.\n+            logger.info(\"unCommittedEntryManager getEntries[{},{}) out of bound : [{},{}] , return empty ArrayList\", low, high, offset, upper);\n+            return new ArrayList<>();\n+        }\n+        if (low < offset) {\n+            logger.debug(\"unCommittedEntryManager getEntries[{},{}) out of bound : [{},{}]\", low, high, offset, upper);\n+            low = offset;\n+        }\n+        if (high > upper) {\n+            logger.info(\"unCommittedEntryManager getEntries[{},{}) out of bound : [{},{}] , adjust parameter 'high' to {}\", low, high, offset, upper, upper);\n+            // don't throw a exception to support getEntries(low, Integer.MAX_VALUE).\n+            high = upper;\n+        }\n+        return entries.subList((int) (low - offset), (int) (high - offset));", "originalCommit": "c21f8268b132fbfed7a826e9797585ed24def997", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MzQzMg==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r404873432", "bodyText": "Actually,In RaftLogManager's getEntries implemetation,a new list is created to deeply copy these references.So it is safe to change the list outside RaftLogManager.\nThanks for reviewing!", "author": "LebronAl", "createdAt": "2020-04-07T14:53:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDcyODQ0MA=="}], "type": "inlineReview"}, {"oid": "5c83ab8bbbe9c56dd511791d4ed35e886532365a", "url": "https://github.com/apache/iotdb/commit/5c83ab8bbbe9c56dd511791d4ed35e886532365a", "message": "Use native snapshot && update license", "committedDate": "2020-04-08T12:24:33Z", "type": "forcePushed"}, {"oid": "0f0aeb92ae336153bfb3033722e06976655e71b0", "url": "https://github.com/apache/iotdb/commit/0f0aeb92ae336153bfb3033722e06976655e71b0", "message": "Use native snapshot && update license", "committedDate": "2020-04-09T07:16:02Z", "type": "forcePushed"}, {"oid": "d7c5782d330cd59f732c7a671bcf08dce65f3738", "url": "https://github.com/apache/iotdb/commit/d7c5782d330cd59f732c7a671bcf08dce65f3738", "message": "Use native snapshot && update license", "committedDate": "2020-04-11T03:38:02Z", "type": "forcePushed"}, {"oid": "bd6a71bbaa392deab30fabac5fa9d1b10655609d", "url": "https://github.com/apache/iotdb/commit/bd6a71bbaa392deab30fabac5fa9d1b10655609d", "message": "rename some method to old version && add some placeholder method", "committedDate": "2020-04-13T02:11:44Z", "type": "forcePushed"}, {"oid": "684029618ca7979ee398025c213676b56ab6dbb9", "url": "https://github.com/apache/iotdb/commit/684029618ca7979ee398025c213676b56ab6dbb9", "message": "initial embedded", "committedDate": "2020-04-13T11:36:20Z", "type": "forcePushed"}, {"oid": "872858780e15a7fcdb4638e004ddf500849659d7", "url": "https://github.com/apache/iotdb/commit/872858780e15a7fcdb4638e004ddf500849659d7", "message": "initial embedded", "committedDate": "2020-04-13T11:57:52Z", "type": "forcePushed"}, {"oid": "49f879bc156ef82e41273fa6e755010b89556bcc", "url": "https://github.com/apache/iotdb/commit/49f879bc156ef82e41273fa6e755010b89556bcc", "message": "initial embedded", "committedDate": "2020-04-13T12:00:04Z", "type": "forcePushed"}, {"oid": "1ad9dbcc87bbe9c7d1c9aa3576e9921a7352cd36", "url": "https://github.com/apache/iotdb/commit/1ad9dbcc87bbe9c7d1c9aa3576e9921a7352cd36", "message": "initial embedded", "committedDate": "2020-04-13T15:04:45Z", "type": "forcePushed"}, {"oid": "b59238839beef9a450ac54639730429e4129ca1e", "url": "https://github.com/apache/iotdb/commit/b59238839beef9a450ac54639730429e4129ca1e", "message": "initial embedded", "committedDate": "2020-04-14T12:33:58Z", "type": "forcePushed"}, {"oid": "ba017a22e472c547f783cd96aaecda2fd81522c1", "url": "https://github.com/apache/iotdb/commit/ba017a22e472c547f783cd96aaecda2fd81522c1", "message": "initial embedded", "committedDate": "2020-04-14T13:04:09Z", "type": "forcePushed"}, {"oid": "3aa1ec60602248764fea067eefae3574cd4e967a", "url": "https://github.com/apache/iotdb/commit/3aa1ec60602248764fea067eefae3574cd4e967a", "message": "initial embedded", "committedDate": "2020-04-14T13:05:36Z", "type": "forcePushed"}, {"oid": "fc4f24057a08a9ed0d5efcabd32799b4fcd60535", "url": "https://github.com/apache/iotdb/commit/fc4f24057a08a9ed0d5efcabd32799b4fcd60535", "message": "initial embedded", "committedDate": "2020-04-14T14:56:22Z", "type": "forcePushed"}, {"oid": "2f7abf9961c20ad389a111497b190f24653db9c7", "url": "https://github.com/apache/iotdb/commit/2f7abf9961c20ad389a111497b190f24653db9c7", "message": "initial embedded", "committedDate": "2020-04-14T14:56:53Z", "type": "forcePushed"}, {"oid": "8d9e0ace1b3f539f2f6c3a880ddfdf9613e600d2", "url": "https://github.com/apache/iotdb/commit/8d9e0ace1b3f539f2f6c3a880ddfdf9613e600d2", "message": "initial embedded", "committedDate": "2020-04-14T15:05:09Z", "type": "forcePushed"}, {"oid": "e546b36aa132daeebb7db231dfecd386bff4f86e", "url": "https://github.com/apache/iotdb/commit/e546b36aa132daeebb7db231dfecd386bff4f86e", "message": "add EmptyContentLog && add persistence", "committedDate": "2020-04-15T10:35:15Z", "type": "forcePushed"}, {"oid": "ded3d983022679d8ca50e784e80f92b360f6e515", "url": "https://github.com/apache/iotdb/commit/ded3d983022679d8ca50e784e80f92b360f6e515", "message": "add EmptyContentLog && add persistence", "committedDate": "2020-04-15T14:40:13Z", "type": "forcePushed"}, {"oid": "5c56fada1e515bba70a35615707edfaa4d8b7bc1", "url": "https://github.com/apache/iotdb/commit/5c56fada1e515bba70a35615707edfaa4d8b7bc1", "message": "add EmptyContentLog && add persistence", "committedDate": "2020-04-15T15:26:11Z", "type": "forcePushed"}, {"oid": "0b5014a91a57d7bc6e1a99a1e67429e25fd47638", "url": "https://github.com/apache/iotdb/commit/0b5014a91a57d7bc6e1a99a1e67429e25fd47638", "message": "add EmptyContentLog && add persistence", "committedDate": "2020-04-16T02:49:07Z", "type": "forcePushed"}, {"oid": "6c6ebaa45ddb423b644d0ec0fd89afc95e454892", "url": "https://github.com/apache/iotdb/commit/6c6ebaa45ddb423b644d0ec0fd89afc95e454892", "message": "add EmptyContentLog && add persistence", "committedDate": "2020-04-16T02:50:05Z", "type": "forcePushed"}, {"oid": "ea40183f241b21ee94ef63345a6c29b4f59c2e4f", "url": "https://github.com/apache/iotdb/commit/ea40183f241b21ee94ef63345a6c29b4f59c2e4f", "message": "add EmptyContentLog && add persistence", "committedDate": "2020-04-16T03:13:41Z", "type": "forcePushed"}, {"oid": "74c40df791811a0637a0e3ac69f4fe8197940492", "url": "https://github.com/apache/iotdb/commit/74c40df791811a0637a0e3ac69f4fe8197940492", "message": "add EmptyContentLog && add persistence", "committedDate": "2020-04-16T03:24:09Z", "type": "forcePushed"}, {"oid": "b32da62ba8ceca97fac188edfab1e40e2629fa9e", "url": "https://github.com/apache/iotdb/commit/b32da62ba8ceca97fac188edfab1e40e2629fa9e", "message": "add EmptyContentLog && add persistence", "committedDate": "2020-04-16T04:07:10Z", "type": "forcePushed"}, {"oid": "4c00f033b1a91bb70fe50459e5addd6f578af65f", "url": "https://github.com/apache/iotdb/commit/4c00f033b1a91bb70fe50459e5addd6f578af65f", "message": "raftLogManager init", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "5b586785111694821ee5a370f4662c46d10870cc", "url": "https://github.com/apache/iotdb/commit/5b586785111694821ee5a370f4662c46d10870cc", "message": "fix Log Module", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "e9f80c22a18a554f656407eeffba5feafa71e0b9", "url": "https://github.com/apache/iotdb/commit/e9f80c22a18a554f656407eeffba5feafa71e0b9", "message": "fix bugs & add exception & sublist.clear()", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "b949fcfb385b3c02213a8f9830b93d766d5bf553", "url": "https://github.com/apache/iotdb/commit/b949fcfb385b3c02213a8f9830b93d766d5bf553", "message": "add unCommitEntryManager Junit test", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "6ed5fc882aaa0964401fdf2acfd409890e9133c6", "url": "https://github.com/apache/iotdb/commit/6ed5fc882aaa0964401fdf2acfd409890e9133c6", "message": "fix review", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "0735e6099c071f37bdd3fec86e38376cd3e706d2", "url": "https://github.com/apache/iotdb/commit/0735e6099c071f37bdd3fec86e38376cd3e706d2", "message": "add CommittedEntryManager test and fix", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "6f03fa00c1bdabb1851af9b77b27767e5f4f20c5", "url": "https://github.com/apache/iotdb/commit/6f03fa00c1bdabb1851af9b77b27767e5f4f20c5", "message": "add license", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "3bcd05fb5bfd540cd0d00214d520139a37d4f69c", "url": "https://github.com/apache/iotdb/commit/3bcd05fb5bfd540cd0d00214d520139a37d4f69c", "message": "add commitEntryManager JavaDoc", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "85b2acc41db102a44f45cdd86ef85a1b5850d738", "url": "https://github.com/apache/iotdb/commit/85b2acc41db102a44f45cdd86ef85a1b5850d738", "message": "remove internal unused exceptions & update logger format & fix bugs", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "55f6b81fa2f42c13e8bdb336a4195cba3aadfbcd", "url": "https://github.com/apache/iotdb/commit/55f6b81fa2f42c13e8bdb336a4195cba3aadfbcd", "message": "add raftlogmanager junit test & fix bugs", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "9af76a5722f452f34e0e71452bf7c88c357d068a", "url": "https://github.com/apache/iotdb/commit/9af76a5722f452f34e0e71452bf7c88c357d068a", "message": "add RaftLoaManager JavaDoc", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "5f1b62f88601fac1b69aa66af4cf6688b70cdc96", "url": "https://github.com/apache/iotdb/commit/5f1b62f88601fac1b69aa66af4cf6688b70cdc96", "message": "add applyingSnapshot & adjust logger level & update JavaDoc", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "60c647e448a8be3b2743aef62af302fa58e26935", "url": "https://github.com/apache/iotdb/commit/60c647e448a8be3b2743aef62af302fa58e26935", "message": "add maybeCommit for leader", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "e1a932ee973db187c5f8ea67f164aa4603265492", "url": "https://github.com/apache/iotdb/commit/e1a932ee973db187c5f8ea67f164aa4603265492", "message": "rename snapshot lastLogId to lastLogIndex", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "fb2a4e91783dbee51537e82ee0e5c9e3d519b483", "url": "https://github.com/apache/iotdb/commit/fb2a4e91783dbee51537e82ee0e5c9e3d519b483", "message": "Use native snapshot && update license", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "4269925f6e6632f89fdec34fe2b96b694a426465", "url": "https://github.com/apache/iotdb/commit/4269925f6e6632f89fdec34fe2b96b694a426465", "message": "add applier for raftLogManager", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "08739025f50308a86421c736dc24a33b1210b854", "url": "https://github.com/apache/iotdb/commit/08739025f50308a86421c736dc24a33b1210b854", "message": "rename some method to old version && add some placeholder method", "committedDate": "2020-04-16T04:17:50Z", "type": "commit"}, {"oid": "7843e579ab05bec77b081e0ca4144bf6ea25c9bf", "url": "https://github.com/apache/iotdb/commit/7843e579ab05bec77b081e0ca4144bf6ea25c9bf", "message": "initial embedded", "committedDate": "2020-04-16T04:24:25Z", "type": "commit"}, {"oid": "d825142d171683a39e870c6005e17236a512277e", "url": "https://github.com/apache/iotdb/commit/d825142d171683a39e870c6005e17236a512277e", "message": "add EmptyContentLog && add persistence && fix format && resolve conflict", "committedDate": "2020-04-16T05:28:41Z", "type": "forcePushed"}, {"oid": "cba6ef2f0dfb71759ff3134bd0a54623943b66af", "url": "https://github.com/apache/iotdb/commit/cba6ef2f0dfb71759ff3134bd0a54623943b66af", "message": "add EmptyContentLog && add persistence && fix format && resolve conflict", "committedDate": "2020-04-16T16:12:41Z", "type": "forcePushed"}, {"oid": "a7246eda04adf068e26eca4a3ae2adcfb40d032a", "url": "https://github.com/apache/iotdb/commit/a7246eda04adf068e26eca4a3ae2adcfb40d032a", "message": "add EmptyContentLog && add persistence && fix format && resolve conflict", "committedDate": "2020-04-17T07:18:26Z", "type": "commit"}, {"oid": "48f65255bb3d96fca94da33edc93ebaa5b9da141", "url": "https://github.com/apache/iotdb/commit/48f65255bb3d96fca94da33edc93ebaa5b9da141", "message": "Merge branch 'cluster_new' of https://github.com/apache/incubator-iotdb into cluster_new_log", "committedDate": "2020-04-17T07:24:38Z", "type": "commit"}, {"oid": "abb5001f569e22b6445304226941a6ba6075175f", "url": "https://github.com/apache/iotdb/commit/abb5001f569e22b6445304226941a6ba6075175f", "message": "minor fix", "committedDate": "2020-04-17T07:51:21Z", "type": "forcePushed"}, {"oid": "1692a55a9a4e2d5bbc52fff4b9f27858ef4cbd8f", "url": "https://github.com/apache/iotdb/commit/1692a55a9a4e2d5bbc52fff4b9f27858ef4cbd8f", "message": "minor fix", "committedDate": "2020-04-17T09:00:22Z", "type": "forcePushed"}, {"oid": "c1199b83d471516941c1b5e42cca912f862e0bb2", "url": "https://github.com/apache/iotdb/commit/c1199b83d471516941c1b5e42cca912f862e0bb2", "message": "minor fix", "committedDate": "2020-04-17T09:03:02Z", "type": "forcePushed"}, {"oid": "7da4f49032b2506a2a7048e2164ea88f8c957b0d", "url": "https://github.com/apache/iotdb/commit/7da4f49032b2506a2a7048e2164ea88f8c957b0d", "message": "minor fix", "committedDate": "2020-04-17T09:09:31Z", "type": "commit"}, {"oid": "7da4f49032b2506a2a7048e2164ea88f8c957b0d", "url": "https://github.com/apache/iotdb/commit/7da4f49032b2506a2a7048e2164ea88f8c957b0d", "message": "minor fix", "committedDate": "2020-04-17T09:09:31Z", "type": "forcePushed"}, {"oid": "e838ca4587541ccc284aac59f87ec2632774233c", "url": "https://github.com/apache/iotdb/commit/e838ca4587541ccc284aac59f87ec2632774233c", "message": "Merge branch 'cluster_new' of https://github.com/apache/incubator-iotdb into cluster_new_log", "committedDate": "2020-04-20T05:30:54Z", "type": "commit"}, {"oid": "e838ca4587541ccc284aac59f87ec2632774233c", "url": "https://github.com/apache/iotdb/commit/e838ca4587541ccc284aac59f87ec2632774233c", "message": "Merge branch 'cluster_new' of https://github.com/apache/incubator-iotdb into cluster_new_log", "committedDate": "2020-04-20T05:30:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE4NzIxNg==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411187216", "bodyText": "I wonder if the checks are necessary, as you comment \"This method is only called after persisting newly committed entries\".", "author": "jt2594838", "createdAt": "2020-04-20T08:23:20Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/UnCommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class UnCommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnCommittedEntryManager.class);\n+    // all entries that have not been committed.\n+    private List<Log> entries;\n+    // the first uncommitted entry index.\n+    private long offset;\n+\n+    public UnCommittedEntryManager(long offset) {\n+        this.offset = offset;\n+        this.entries = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Return the first uncommitted index.\n+     *\n+     * @return offset\n+     */\n+    public long getFirstUnCommittedIndex() {\n+        return offset;\n+    }\n+\n+\n+    /**\n+     * Return last entry's index if this instance has at least one uncommitted entry.\n+     *\n+     * @return -1 if entries are empty, or last entry's index\n+     */\n+    public long maybeLastIndex() {\n+        int entryNum = entries.size();\n+        if (entryNum != 0) {\n+            return offset + entryNum - 1;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index. Note that the called should ensure index >= offset.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index < offset, throw EntryUnavailableException if index > last or entries is\n+     * empty, or return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     */\n+    public long maybeTerm(long index) throws EntryUnavailableException {\n+        if (index < offset) {\n+            logger.debug(\n+                \"invalid unCommittedEntryManager maybeTerm : parameter: index({}) < offset({})\",\n+                index, offset);\n+            return -1;\n+        }\n+        long last = maybeLastIndex();\n+        if (last == -1 || index > last) {\n+            long boundary = last == -1 ? offset - 1 : last;\n+            logger.info(\n+                \"unCommittedEntryManager maybeTerm out of bound : parameter: index({}) > lastIndex({})\",\n+                index, boundary);\n+            throw new EntryUnavailableException(index, boundary);\n+        }\n+        return entries.get((int) (index - offset)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Remove useless prefix entries as long as these entries has been committed and persisted. This\n+     * method is only called after persisting newly committed entries.\n+     *\n+     * @param index request entry's index\n+     * @param term  request entry's term\n+     */\n+    public void stableTo(long index, long term) {\n+        try {\n+            long entryTerm = maybeTerm(index);\n+            // only update the uncommitted entries if term is matched with an uncommitted entry.\n+            if (entryTerm == term) {", "originalCommit": "e838ca4587541ccc284aac59f87ec2632774233c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIyNDY2NQ==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411224665", "bodyText": "This check is not required under the current design. I will delete it~", "author": "LebronAl", "createdAt": "2020-04-20T09:19:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE4NzIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE4OTg2NQ==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411189865", "bodyText": "It would be better to give also a single-log-append interface, as in the normal procedure, logs mainly go to followers one-by-one and it is costly to wrap them as singleton lists.", "author": "jt2594838", "createdAt": "2020-04-20T08:27:16Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/RaftLogManager.java", "diffHunk": "@@ -0,0 +1,420 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryCompactedException;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.exception.GetEntriesWrongParametersException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.LogApplier;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.db.exception.metadata.PathAlreadyExistException;\n+import org.apache.iotdb.db.exception.query.QueryProcessException;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class RaftLogManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RaftLogManager.class);\n+\n+    // manage uncommitted entries\n+    public UnCommittedEntryManager unCommittedEntryManager;\n+    // manage committed entries in memory as a cache\n+    public CommittedEntryManager committedEntryManager;\n+    // manage committed entries in disk for safety\n+    public StableEntryManager stableEntryManager;\n+\n+    private long commitIndex;\n+    private LogApplier logApplier;\n+\n+    public RaftLogManager(CommittedEntryManager committedEntryManager,\n+        StableEntryManager stableEntryManager, LogApplier applier) {\n+        this.logApplier = applier;\n+        this.committedEntryManager = committedEntryManager;\n+        this.stableEntryManager = stableEntryManager;\n+        this.committedEntryManager.append(stableEntryManager.getAllEntries());\n+        long last = committedEntryManager.getLastIndex();\n+        this.unCommittedEntryManager = new UnCommittedEntryManager(last + 1);\n+        // must have applied entry [compactIndex,last] to state machine\n+        this.commitIndex = last;\n+    }\n+\n+    // placeholder method\n+    public Snapshot getSnapshot() {\n+        return null;\n+    }\n+\n+    // placeholder method\n+    public void takeSnapshot() throws IOException {\n+\n+    }\n+\n+    public LogApplier getApplier() {\n+        return logApplier;\n+    }\n+\n+    /**\n+     * Return the raftNode's commitIndex.\n+     *\n+     * @return commitIndex\n+     */\n+    public long getCommitLogIndex() {\n+        return commitIndex;\n+    }\n+\n+    /**\n+     * Set the raftNode's commitIndex.\n+     *\n+     * @param commitIndex request commitIndex\n+     */\n+    public void setCommitLogIndex(long commitIndex) {\n+        this.commitIndex = commitIndex;\n+    }\n+\n+    /**\n+     * Return the first entry's index which have not been compacted.\n+     *\n+     * @return firstIndex\n+     */\n+    public long getFirstIndex() {\n+        return committedEntryManager.getFirstIndex();\n+    }\n+\n+    /**\n+     * Return the last entry's index which have been added into log module.\n+     *\n+     * @return lastIndex\n+     */\n+    public long getLastLogIndex() {\n+        long last = unCommittedEntryManager.maybeLastIndex();\n+        if (last != -1) {\n+            return last;\n+        }\n+        return committedEntryManager.getLastIndex();\n+    }\n+\n+    /**\n+     * Returns the term for given index.\n+     *\n+     * @param index request entry index\n+     * @return throw EntryCompactedException if index < dummyIndex, throw EntryUnavailableException if\n+     * index > lastIndex, otherwise return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     * @throws EntryCompactedException\n+     */\n+    public long getTerm(long index) throws EntryUnavailableException, EntryCompactedException {\n+        long dummyIndex = getFirstIndex() - 1;\n+        if (index < dummyIndex) {\n+            logger.info(\"invalid getTerm: parameter: index({}) < compactIndex({})\", index,\n+                dummyIndex);\n+            throw new EntryCompactedException(index, dummyIndex);\n+        }\n+        long lastIndex = getLastLogIndex();\n+        if (index > lastIndex) {\n+            logger.info(\"invalid getTerm: parameter: index({}) > lastIndex({})\", index, lastIndex);\n+            throw new EntryUnavailableException(index, lastIndex);\n+        }\n+        if (index >= unCommittedEntryManager.getFirstUnCommittedIndex()) {\n+            return unCommittedEntryManager.maybeTerm(index);\n+        }\n+        return committedEntryManager.maybeTerm(index);\n+    }\n+\n+    /**\n+     * Return the last entry's term. If it goes wrong, there must be an unexpected exception.\n+     *\n+     * @return last entry's term\n+     */\n+    public long getLastLogTerm() {\n+        long term = -1;\n+        try {\n+            term = getTerm(getLastLogIndex());\n+        } catch (Exception e) {\n+            logger.error(\"unexpected error when getting the last term : {}\", e.getMessage());\n+        }\n+        return term;\n+    }\n+\n+    /**\n+     * Return the commitIndex's term. If it goes wrong, there must be an unexpected exception.\n+     *\n+     * @return commitIndex's term\n+     */\n+    public long getCommitLogTerm() {\n+        long term = -1;\n+        try {\n+            term = getTerm(getCommitLogIndex());\n+        } catch (Exception e) {\n+            logger.error(\"unexpected error when getting the last term : {}\", e.getMessage());\n+        }\n+        return term;\n+    }\n+\n+    /**\n+     * Used by follower node to support leader's complicated log replication rpc parameters and try to\n+     * commit entries.\n+     *\n+     * @param lastIndex    leader's matchIndex for this follower node\n+     * @param lastTerm     the entry's term which index is leader's matchIndex for this follower node\n+     * @param leaderCommit leader's commitIndex\n+     * @param entries      entries sent from the leader node Note that the leader must ensure\n+     *                     entries[0].index = lastIndex + 1\n+     * @return -1 if the entries cannot be appended, otherwise the last index of new entries\n+     */\n+    public long maybeAppend(long lastIndex, long lastTerm, long leaderCommit, List<Log> entries) {\n+        if (matchTerm(lastTerm, lastIndex)) {\n+            long newLastIndex = lastIndex + entries.size();\n+            long ci = findConflict(entries);\n+            if (ci == 0 || ci <= commitIndex) {\n+                logger\n+                    .error(\"entry {} conflict with committed entry [commitIndex({})]\", ci,\n+                        commitIndex);\n+            } else {\n+                long offset = lastIndex + 1;\n+                append(entries.subList((int) (ci - offset), entries.size()));\n+            }\n+            commitTo(Math.min(leaderCommit, newLastIndex));\n+            return newLastIndex;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Used by leader node or MaybeAppend to directly append to unCommittedEntryManager. Note that the\n+     * caller should ensure entries[0].index > committed.\n+     *\n+     * @param entries appendingEntries\n+     * @return the newly generated lastIndex\n+     */\n+    public long append(List<Log> entries) {", "originalCommit": "e838ca4587541ccc284aac59f87ec2632774233c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI3NTA4Mg==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411275082", "bodyText": "I think that as long as batch replication is supported, any log will be sent in batches to follower, and the single-log-append interface will only be used for leader to append member changes logs as long as the client can also send a batch of logs~ But for scalability and efficiency,  I have added a single-log-append  interface~", "author": "LebronAl", "createdAt": "2020-04-20T10:40:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE4OTg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE5NzU2NQ==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411197565", "bodyText": "It would be better to eliminate this overhead with a new interface.", "author": "jt2594838", "createdAt": "2020-04-20T08:38:43Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/DataGroupMember.java", "diffHunk": "@@ -918,7 +916,9 @@ public boolean closePartition(String storageGroupName, long partitionId, boolean\n       log.setPreviousLogTerm(logManager.getLastLogTerm());\n       log.setCurrLogIndex(logManager.getLastLogIndex() + 1);\n \n-      logManager.appendLog(log);\n+      logManager.append(new ArrayList<Log>() {{\n+        add(log);\n+      }});", "originalCommit": "e838ca4587541ccc284aac59f87ec2632774233c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTI3NTk5MQ==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411275991", "bodyText": "OK~I will fix it.", "author": "LebronAl", "createdAt": "2020-04-20T10:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE5NzU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwMDA4Nw==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411200087", "bodyText": "The new ArrayList() seems unused.\nEven if !allLogsValid holds, the logs after the snapshot point should still be attained.\nPlease log e instead of e.getMessage() for the sake of debugging.", "author": "jt2594838", "createdAt": "2020-04-20T08:42:40Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/server/member/RaftMember.java", "diffHunk": "@@ -671,17 +672,22 @@ public void catchUp(Node follower, long followerLastLogIndex) {\n \n     AsyncClient client = connectNode(follower);\n     if (client != null) {\n-      List<Log> logs;\n+      List<Log> logs = new ArrayList<>();\n       boolean allLogsValid;\n       Snapshot snapshot = null;\n       synchronized (logManager) {\n         // check if the very first log has been snapshot\n         allLogsValid = logManager.logValid(followerLastLogIndex);\n-        logs = logManager.getLogs(followerLastLogIndex, Long.MAX_VALUE);\n         if (!allLogsValid) {\n           // if the first log has been snapshot, the snapshot should also be sent to the\n           // follower, otherwise some data will be missing\n           snapshot = logManager.getSnapshot();\n+        }else{\n+          try {\n+            logs = logManager.getEntries(followerLastLogIndex, Long.MAX_VALUE);\n+          }catch (Exception e){\n+              logger.error(\"Unexpected error: {}\" ,e.getMessage());\n+          }", "originalCommit": "e838ca4587541ccc284aac59f87ec2632774233c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM5MzIwNw==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411393207", "bodyText": "Sorry,I misunderstood the code here. I thought the logs weren't needed when the snapshot was sent.I will fix this~", "author": "LebronAl", "createdAt": "2020-04-20T13:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwMDA4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwMzAxNQ==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411203015", "bodyText": "The indents seem too long in the tests, please check the code style.", "author": "jt2594838", "createdAt": "2020-04-20T08:47:07Z", "path": "cluster/src/test/java/org/apache/iotdb/cluster/log/manage/RaftLogManagerTest.java", "diffHunk": "@@ -0,0 +1,787 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import org.apache.iotdb.cluster.common.TestLogApplier;\n+import org.apache.iotdb.cluster.common.TestUtils;\n+import org.apache.iotdb.cluster.exception.EntryCompactedException;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.exception.GetEntriesWrongParametersException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.LogApplier;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.cluster.log.snapshot.SimpleSnapshot;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class RaftLogManagerTest {\n+\n+\tprivate Set<Log> appliedLogs;\n+\tprivate LogApplier logApplier = new TestLogApplier() {\n+\t\t@Override\n+\t\tpublic void apply(Log log) {\n+\t\t\tappliedLogs.add(log);\n+\t\t}\n+\t};\n+", "originalCommit": "e838ca4587541ccc284aac59f87ec2632774233c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIzNDA5NQ==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411234095", "bodyText": "OK~", "author": "LebronAl", "createdAt": "2020-04-20T09:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIwMzAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MDA4MQ==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411350081", "bodyText": "May be you should just return here or throw an IllegalArugumentException", "author": "SilverNarcissus", "createdAt": "2020-04-20T12:49:52Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/CommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryCompactedException;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.cluster.log.logtypes.EmptyContentLog;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(CommittedEntryManager.class);\n+\n+    // memory cache for logs which have been persisted in disk.\n+    private List<Log> entries;\n+\n+    /**\n+     * Note that it is better to use applyingSnapshot to update dummy entry immediately after this\n+     * instance is created.\n+     */\n+    public CommittedEntryManager() {\n+        entries = new ArrayList<Log>() {{\n+            add(new EmptyContentLog(-1, -1));\n+        }};\n+    }\n+\n+    /**\n+     * Overwrite the contents of this object with those of the given snapshot. Note that this function\n+     * is only used if you want to override all the contents, otherwise please use\n+     * compactEntries(snapshot.lastIndex()).\n+     *\n+     * @param snapshot snapshot\n+     */\n+    public void applyingSnapshot(Snapshot snapshot) {\n+        long localIndex = getDummyIndex();\n+        long snapIndex = snapshot.getLastLogIndex();\n+        if (localIndex >= snapIndex) {\n+            logger.info(\"requested snapshot is older than the existing snapshot\");\n+            return;\n+        }\n+        entries.clear();\n+        entries.add(new EmptyContentLog(snapshot.getLastLogIndex(), snapshot.getLastLogTerm()));\n+    }\n+\n+    /**\n+     * Return the last entry's index which have been compacted.\n+     *\n+     * @return dummyIndex\n+     */\n+    public Long getDummyIndex() {\n+        return entries.get(0).getCurrLogIndex();\n+    }\n+\n+    /**\n+     * Return the first entry's index which have not been compacted.\n+     *\n+     * @return firstIndex\n+     */\n+    public Long getFirstIndex() {\n+        return getDummyIndex() + 1;\n+    }\n+\n+    /**\n+     * Return the last entry's index which have been committed and persisted.\n+     *\n+     * @return getLastIndex\n+     */\n+    public Long getLastIndex() {\n+        return getDummyIndex() + entries.size() - 1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index. Note that the called should ensure index <=\n+     * entries[entries.size()-1].index.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index > entries[entries.size()-1].index, throw EntryCompactedException if index <\n+     * dummyIndex, or return the entry's term for given index\n+     * @throws EntryCompactedException\n+     */\n+    public long maybeTerm(long index) throws EntryCompactedException {\n+        long dummyIndex = getDummyIndex();\n+        if (index < dummyIndex) {\n+            logger.info(\n+                \"invalid committedEntryManager maybeTerm: parameter: index({}) < compactIndex({})\",\n+                index, dummyIndex);\n+            throw new EntryCompactedException(index, dummyIndex);\n+        }\n+        if ((int) (index - dummyIndex) >= entries.size()) {\n+            logger.debug(\n+                \"invalid committedEntryManager maybeTerm : parameter: index({}) > lastIndex({})\",\n+                index, getLastIndex());\n+            return -1;\n+        }\n+        return entries.get((int) (index - dummyIndex)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Pack entries from low through high - 1, just like slice (entries[low:high]). dummyIndex < low\n+     * <= high. Note that caller must ensure low <= high.\n+     *\n+     * @param low  request index low bound\n+     * @param high request index upper bound\n+     * @throws EntryCompactedException\n+     */\n+    public List<Log> getEntries(long low, long high) throws EntryCompactedException {\n+        if (low > high) {\n+            logger.debug(\"invalid getEntries: parameter: {} > {}\", low, high);", "originalCommit": "e838ca4587541ccc284aac59f87ec2632774233c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM5NjA2Ng==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411396066", "bodyText": "OK~ I will return a empty list here~", "author": "LebronAl", "createdAt": "2020-04-20T13:53:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MDA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MzM2MQ==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411353361", "bodyText": "May be you should just return here or throw an IllegalArugumentException", "author": "SilverNarcissus", "createdAt": "2020-04-20T12:54:49Z", "path": "cluster/src/main/java/org/apache/iotdb/cluster/log/manage/UnCommittedEntryManager.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.iotdb.cluster.log.manage;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.apache.iotdb.cluster.exception.EntryUnavailableException;\n+import org.apache.iotdb.cluster.log.Log;\n+import org.apache.iotdb.cluster.log.Snapshot;\n+import org.apache.iotdb.db.utils.TestOnly;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class UnCommittedEntryManager {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(UnCommittedEntryManager.class);\n+    // all entries that have not been committed.\n+    private List<Log> entries;\n+    // the first uncommitted entry index.\n+    private long offset;\n+\n+    public UnCommittedEntryManager(long offset) {\n+        this.offset = offset;\n+        this.entries = new ArrayList<>();\n+    }\n+\n+    /**\n+     * Return the first uncommitted index.\n+     *\n+     * @return offset\n+     */\n+    public long getFirstUnCommittedIndex() {\n+        return offset;\n+    }\n+\n+\n+    /**\n+     * Return last entry's index if this instance has at least one uncommitted entry.\n+     *\n+     * @return -1 if entries are empty, or last entry's index\n+     */\n+    public long maybeLastIndex() {\n+        int entryNum = entries.size();\n+        if (entryNum != 0) {\n+            return offset + entryNum - 1;\n+        }\n+        return -1;\n+    }\n+\n+    /**\n+     * Return the entry's term for given index. Note that the called should ensure index >= offset.\n+     *\n+     * @param index request entry index\n+     * @return -1 if index < offset, throw EntryUnavailableException if index > last or entries is\n+     * empty, or return the entry's term for given index\n+     * @throws EntryUnavailableException\n+     */\n+    public long maybeTerm(long index) throws EntryUnavailableException {\n+        if (index < offset) {\n+            logger.debug(\n+                \"invalid unCommittedEntryManager maybeTerm : parameter: index({}) < offset({})\",\n+                index, offset);\n+            return -1;\n+        }\n+        long last = maybeLastIndex();\n+        if (last == -1 || index > last) {\n+            long boundary = last == -1 ? offset - 1 : last;\n+            logger.info(\n+                \"unCommittedEntryManager maybeTerm out of bound : parameter: index({}) > lastIndex({})\",\n+                index, boundary);\n+            throw new EntryUnavailableException(index, boundary);\n+        }\n+        return entries.get((int) (index - offset)).getCurrLogTerm();\n+    }\n+\n+    /**\n+     * Remove useless prefix entries as long as these entries has been committed and persisted. This\n+     * method is only called after persisting newly committed entries.\n+     *\n+     * @param index request entry's index\n+     * @param term  request entry's term\n+     */\n+    public void stableTo(long index, long term) {\n+        try {\n+            long entryTerm = maybeTerm(index);\n+            // only update the uncommitted entries if term is matched with an uncommitted entry.\n+            if (entryTerm == term) {\n+                entries.subList(0, (int) (index + 1 - offset)).clear();\n+                offset = index + 1;\n+            }\n+        } catch (EntryUnavailableException e) {\n+            logger.info(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Update offset and clear entries because leader's snapshot is more up-to-date. This method is\n+     * only called for applying snapshot from leader.\n+     *\n+     * @param snapshot leader's snapshot\n+     */\n+    public void applyingSnapshot(Snapshot snapshot) {\n+        this.offset = snapshot.getLastLogIndex() + 1;\n+        this.entries.clear();\n+    }\n+\n+    /**\n+     * TruncateAndAppend uncommitted entries. This method will truncate conflict entries if it finds\n+     * inconsistencies. Note that the caller should ensure appendingEntries[0].index <=\n+     * entries[entries.size()-1].index + 1. Note that the caller should ensure not to truncate entries\n+     * which have been committed.\n+     *\n+     * @param appendingEntries request entries\n+     */\n+    public void truncateAndAppend(List<Log> appendingEntries) {\n+        long after = appendingEntries.get(0).getCurrLogIndex();\n+        long len = after - offset;\n+        if (len < 0) {\n+            // the logs are being truncated to before our current offset portion, which is committed entries\n+            // unconditional obedience to the leader's request. Maybe throw a exception here is better\n+            offset = after;\n+            entries = appendingEntries;\n+            logger.error(\"The logs which first index is {} are going to truncate committed logs\",\n+                after);\n+        } else if (len == entries.size()) {\n+            // after is the next index in the entries\n+            // directly append\n+            entries.addAll(appendingEntries);\n+        } else {\n+            // clear conflict entries\n+            // then append\n+            logger.info(\"truncate the entries after index {}\", after);\n+            int truncateIndex = (int) (after - offset);\n+            if (truncateIndex < entries.size()) {\n+                entries.subList(truncateIndex, entries.size()).clear();\n+            }\n+            entries.addAll(appendingEntries);\n+        }\n+    }\n+\n+    /**\n+     * Pack entries from low through high - 1, just like slice (entries[low:high]). offset <= low <=\n+     * high. Note that caller must ensure low <= high.\n+     *\n+     * @param low  request index low bound\n+     * @param high request index upper bound\n+     */\n+    public List<Log> getEntries(long low, long high) {\n+        if (low > high) {\n+            logger\n+                .debug(\"invalid unCommittedEntryManager getEntries: parameter: low({}) > high({})\",\n+                    low, high);\n+        }", "originalCommit": "e838ca4587541ccc284aac59f87ec2632774233c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM5NjM5NQ==", "url": "https://github.com/apache/iotdb/pull/975#discussion_r411396395", "bodyText": "Fine~", "author": "LebronAl", "createdAt": "2020-04-20T13:53:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTM1MzM2MQ=="}], "type": "inlineReview"}, {"oid": "22f5676a9430d084a7aa5c8cb98bc8fbab399889", "url": "https://github.com/apache/iotdb/commit/22f5676a9430d084a7aa5c8cb98bc8fbab399889", "message": "fix review", "committedDate": "2020-04-20T14:13:31Z", "type": "commit"}, {"oid": "22f5676a9430d084a7aa5c8cb98bc8fbab399889", "url": "https://github.com/apache/iotdb/commit/22f5676a9430d084a7aa5c8cb98bc8fbab399889", "message": "fix review", "committedDate": "2020-04-20T14:13:31Z", "type": "forcePushed"}, {"oid": "914d561f51e97596dc181229977d6231b66b9c42", "url": "https://github.com/apache/iotdb/commit/914d561f51e97596dc181229977d6231b66b9c42", "message": "Merge branch 'cluster_new' into cluster_new_log", "committedDate": "2020-04-20T14:16:46Z", "type": "commit"}, {"oid": "8c12af0cefa87ed34b98ebe5c1fa96871c12f251", "url": "https://github.com/apache/iotdb/commit/8c12af0cefa87ed34b98ebe5c1fa96871c12f251", "message": "Merge branch 'cluster_new' of https://github.com/apache/incubator-iotdb into cluster_new_log", "committedDate": "2020-04-21T03:44:34Z", "type": "commit"}, {"oid": "91ef6ec694d0a4d0e7ee4749dffdbce8da10e915", "url": "https://github.com/apache/iotdb/commit/91ef6ec694d0a4d0e7ee4749dffdbce8da10e915", "message": "Merge branch 'cluster_new' into cluster_new_log", "committedDate": "2020-04-21T05:37:29Z", "type": "commit"}, {"oid": "88b85cf56704193734bd1a995441587a27bd8b05", "url": "https://github.com/apache/iotdb/commit/88b85cf56704193734bd1a995441587a27bd8b05", "message": "Merge branch 'cluster_new' into cluster_new_log", "committedDate": "2020-04-22T04:25:47Z", "type": "commit"}, {"oid": "9aaa03f78f636aae7fc352f580ba42c54c4a5148", "url": "https://github.com/apache/iotdb/commit/9aaa03f78f636aae7fc352f580ba42c54c4a5148", "message": "Merge branch 'cluster_new' into cluster_new_log", "committedDate": "2020-04-22T09:30:30Z", "type": "commit"}, {"oid": "40f5a9d19c0b89a6375bb96cc6ee2ca85b15a8e1", "url": "https://github.com/apache/iotdb/commit/40f5a9d19c0b89a6375bb96cc6ee2ca85b15a8e1", "message": "Merge branch 'cluster_new' into cluster_new_log", "committedDate": "2020-04-23T01:59:53Z", "type": "commit"}]}