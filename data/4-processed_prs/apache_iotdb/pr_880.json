{"pr_number": 880, "pr_title": "[IOTDB-538]add a simple connection pool for session api", "pr_createdAt": "2020-03-03T17:56:12Z", "pr_url": "https://github.com/apache/iotdb/pull/880", "timeline": [{"oid": "75647e03b45973a0ce8593dca7304ab9f96364f4", "url": "https://github.com/apache/iotdb/commit/75647e03b45973a0ce8593dca7304ab9f96364f4", "message": "add a simple connection pool for session api", "committedDate": "2020-03-03T17:52:56Z", "type": "commit"}, {"oid": "779dd275acd330bcc9cbf4393109cb77b5ee23a0", "url": "https://github.com/apache/iotdb/commit/779dd275acd330bcc9cbf4393109cb77b5ee23a0", "message": "add a simple connection pool for session api", "committedDate": "2020-03-03T17:54:09Z", "type": "commit"}, {"oid": "0482887e22a21291cf58de76cff4066866d33ead", "url": "https://github.com/apache/iotdb/commit/0482887e22a21291cf58de76cff4066866d33ead", "message": "add apache rat", "committedDate": "2020-03-04T00:20:43Z", "type": "commit"}, {"oid": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d", "url": "https://github.com/apache/iotdb/commit/e7157addd0a53bf9cba3a4a20c7648d714ec2b8d", "message": "add close() method and fix ut bug", "committedDate": "2020-03-05T00:43:18Z", "type": "commit"}, {"oid": "aceefbf5bd3ef46f9a5597d6fbd2decd2539d673", "url": "https://github.com/apache/iotdb/commit/aceefbf5bd3ef46f9a5597d6fbd2decd2539d673", "message": "fix typo", "committedDate": "2020-03-05T03:04:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NTcwOA==", "url": "https://github.com/apache/iotdb/pull/880#discussion_r388055708", "bodyText": "should the password be printed?", "author": "qiaojialin", "createdAt": "2020-03-05T03:05:32Z", "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);", "originalCommit": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjA4Mw==", "url": "https://github.com/apache/iotdb/pull/880#discussion_r388056083", "bodyText": "Is it needed to export the methods of Session in this Pool? the codes are double...", "author": "qiaojialin", "createdAt": "2020-03-05T03:07:07Z", "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);\n+      }\n+      session = new Session(ip, port, user, password, fetchSize);\n+      session.open();\n+      return session;\n+    }\n+  }\n+\n+  public int currentAvailableSize() {\n+    return queue.size();\n+  }\n+\n+  public int currentOccupiedSize() {\n+    return occupied.size();\n+  }\n+\n+  private void putBack(Session session) {\n+    queue.push(session);\n+    synchronized (this) {\n+      this.notifyAll();\n+    }\n+  }\n+\n+  private void occupy(Session session) {\n+    occupied.put(session, session);\n+  }\n+\n+  /**\n+   * close all connections in the pool\n+   */\n+  public synchronized void close() {\n+    for (Session session : queue) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    for (Session session : occupied.keySet()) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    queue.clear();\n+    occupied.clear();\n+  }\n+\n+  public void closeResultSet(SessionDataSetWrapper wrapper) throws SQLException {\n+    boolean putback = true;\n+    try {\n+      wrapper.sessionDataSet.closeOperationHandle();\n+    } catch (SQLException e) {\n+      if (e.getCause() instanceof TException) {\n+        // the connection is broken.\n+        removeSession();\n+        putback = false;\n+      } else {\n+        throw e;\n+      }\n+    } finally {\n+      Session session = occupied.remove(wrapper.session);\n+      if (putback && session != null) {\n+        putBack(wrapper.session);\n+      }\n+    }\n+  }\n+\n+  private synchronized void removeSession() {\n+    if (logger.isDebugEnabled()) {\n+      logger.error(\"Remove a broken Session {}, {}, {}, {}\", ip, port, user, password);\n+    }\n+    size--;\n+  }\n+\n+  private void closeSession(Session session) {\n+    if (session != null) {\n+      try {\n+        session.close();\n+      } catch (Exception e2) {\n+        //do nothing. We just want to guarantee the session is closed.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * use batch interface to insert sorted data times in row batch must be sorted before!\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertSortedBatch(RowBatch rowBatch)", "originalCommit": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNzgzMw==", "url": "https://github.com/apache/iotdb/pull/880#discussion_r389237833", "bodyText": "the codes are double...\n\nAh?", "author": "jixuan1989", "createdAt": "2020-03-07T08:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc4OTgzNA==", "url": "https://github.com/apache/iotdb/pull/880#discussion_r390789834", "bodyText": "the interfaces are double...", "author": "qiaojialin", "createdAt": "2020-03-11T07:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjA4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjE4MQ==", "url": "https://github.com/apache/iotdb/pull/880#discussion_r388056181", "bodyText": "get a new one?", "author": "qiaojialin", "createdAt": "2020-03-05T03:07:35Z", "path": "session/src/main/java/org/apache/iotdb/session/pool/SessionPool.java", "diffHunk": "@@ -0,0 +1,670 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.iotdb.session.pool;\n+\n+import java.sql.SQLException;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedDeque;\n+import java.util.concurrent.ConcurrentMap;\n+import org.apache.iotdb.rpc.IoTDBRPCException;\n+import org.apache.iotdb.service.rpc.thrift.TSExecuteBatchStatementResp;\n+import org.apache.iotdb.service.rpc.thrift.TSStatus;\n+import org.apache.iotdb.session.Config;\n+import org.apache.iotdb.session.IoTDBSessionException;\n+import org.apache.iotdb.session.Session;\n+import org.apache.iotdb.session.SessionDataSet;\n+import org.apache.iotdb.tsfile.file.metadata.enums.CompressionType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSDataType;\n+import org.apache.iotdb.tsfile.file.metadata.enums.TSEncoding;\n+import org.apache.iotdb.tsfile.write.record.RowBatch;\n+import org.apache.thrift.TException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * SessionPool is a wrapper of a Session Set.\n+ * Using SessionPool, the user do not need to consider how to reuse a session connection.\n+ * Even if the session is disconnected, the session pool can recognize it and remove the borken\n+ * session connection and create a new one.\n+ *\n+ * If there is no available connections and the pool reaches its max size, the all methods will hang\n+ * until there is a available connection.\n+ *\n+ * If a user has waited for a session for more than 60 seconds, a warn log will be printed.\n+ *\n+ *\n+ * The only thing you have to remember is that:\n+ *\n+ * For a query, if you have get all data, i.e., SessionDataSetWrapper.hasNext() == false, it is ok.\n+ * Otherwise, i.e., you want to stop the query before you get all data (SessionDataSetWrapper.hasNext() == true),\n+ * then you have to call closeResultSet(SessionDataSetWrapper wrapper) manually.\n+ * Otherwise the connection is occupied by the query.\n+ *\n+ * Another case that you have to manually call closeResultSet() is that when there is exception\n+ * when you call SessionDataSetWrapper.hasNext() or next()\n+ *\n+ *\n+ */\n+public class SessionPool {\n+\n+  private static final Logger logger = LoggerFactory.getLogger(SessionPool.class);\n+  private ConcurrentLinkedDeque<Session> queue = new ConcurrentLinkedDeque<>();\n+  //for session whose resultSet is not released.\n+  private ConcurrentMap<Session, Session> occupied = new ConcurrentHashMap<>();\n+\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize) {\n+    this(ip, port, user, password, maxSize, Config.DEFAULT_FETCH_SIZE);\n+  }\n+\n+  public SessionPool(String ip, int port, String user, String password, int maxSize, int fetchSize) {\n+    this.maxSize = maxSize;\n+    this.ip = ip;\n+    this.port = port;\n+    this.user = user;\n+    this.password = password;\n+    this.fetchSize = fetchSize;\n+  }\n+\n+  private int size = 0;\n+  private int maxSize = 0;\n+  private String ip;\n+  private int port;\n+  private String user;\n+  private String password;\n+\n+  private int fetchSize;\n+\n+  //if this method throws an exception, either the server is broken, or the ip/port/user/password is incorrect.\n+  //TODO: we can add a mechanism that if the user waits too long time, throw exception.\n+  private Session getSession() throws IoTDBSessionException {\n+    Session session = queue.poll();\n+    if (session != null) {\n+      return session;\n+    } else {\n+      synchronized (this) {\n+        long start = System.currentTimeMillis();\n+        while (session == null) {\n+          if (size < maxSize) {\n+            //we can create more session\n+            size++;\n+            //but we do it after skip synchronized block because connection a session is time consuming.\n+            break;\n+          } else {\n+            //we have to wait for someone returns a session.\n+            try {\n+              this.wait(1000);\n+              if (System.currentTimeMillis() - start > 60_000) {\n+                logger.warn(\n+                    \"the SessionPool has wait for {} seconds to get a new connection: {}:{} with {}, {}\",\n+                    (System.currentTimeMillis() - start) / 1000, ip, port, user, password);\n+              }\n+            } catch (InterruptedException e) {\n+              logger.error(\"the SessionPool is damaged\", e);\n+              Thread.currentThread().interrupt();\n+            }\n+            session = queue.poll();\n+          }\n+        }\n+        if (session != null) {\n+          return session;\n+        }\n+      }\n+      if (logger.isDebugEnabled()) {\n+        logger.error(\"Create a new Session {}, {}, {}, {}\", ip, port, user, password);\n+      }\n+      session = new Session(ip, port, user, password, fetchSize);\n+      session.open();\n+      return session;\n+    }\n+  }\n+\n+  public int currentAvailableSize() {\n+    return queue.size();\n+  }\n+\n+  public int currentOccupiedSize() {\n+    return occupied.size();\n+  }\n+\n+  private void putBack(Session session) {\n+    queue.push(session);\n+    synchronized (this) {\n+      this.notifyAll();\n+    }\n+  }\n+\n+  private void occupy(Session session) {\n+    occupied.put(session, session);\n+  }\n+\n+  /**\n+   * close all connections in the pool\n+   */\n+  public synchronized void close() {\n+    for (Session session : queue) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    for (Session session : occupied.keySet()) {\n+      try {\n+        session.close();\n+      } catch (IoTDBSessionException e) {\n+        //do nothing\n+      }\n+    }\n+    queue.clear();\n+    occupied.clear();\n+  }\n+\n+  public void closeResultSet(SessionDataSetWrapper wrapper) throws SQLException {\n+    boolean putback = true;\n+    try {\n+      wrapper.sessionDataSet.closeOperationHandle();\n+    } catch (SQLException e) {\n+      if (e.getCause() instanceof TException) {\n+        // the connection is broken.\n+        removeSession();\n+        putback = false;\n+      } else {\n+        throw e;\n+      }\n+    } finally {\n+      Session session = occupied.remove(wrapper.session);\n+      if (putback && session != null) {\n+        putBack(wrapper.session);\n+      }\n+    }\n+  }\n+\n+  private synchronized void removeSession() {\n+    if (logger.isDebugEnabled()) {\n+      logger.error(\"Remove a broken Session {}, {}, {}, {}\", ip, port, user, password);\n+    }\n+    size--;\n+  }\n+\n+  private void closeSession(Session session) {\n+    if (session != null) {\n+      try {\n+        session.close();\n+      } catch (Exception e2) {\n+        //do nothing. We just want to guarantee the session is closed.\n+      }\n+    }\n+  }\n+\n+  /**\n+   * use batch interface to insert sorted data times in row batch must be sorted before!\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertSortedBatch(RowBatch rowBatch)\n+      throws IoTDBSessionException {\n+    while (true) {\n+      Session session = getSession();\n+      try {\n+        TSExecuteBatchStatementResp resp = session.insertSortedBatch(rowBatch);\n+        putBack(session);\n+        return resp;\n+      } catch (IoTDBSessionException e) {\n+        if (e.getCause() instanceof TException) {\n+          // TException means the connection is broken, remove it and get a new one.\n+          closeSession(session);\n+          removeSession();\n+        } else {\n+          putBack(session);\n+          throw e;\n+        }\n+      }\n+    }\n+  }\n+\n+\n+\n+  /**\n+   * use batch interface to insert data\n+   *\n+   * @param rowBatch data batch\n+   */\n+  public TSExecuteBatchStatementResp insertBatch(RowBatch rowBatch) throws IoTDBSessionException {\n+    while (true) {\n+      Session session = getSession();\n+      try {\n+        TSExecuteBatchStatementResp resp = session.insertBatch(rowBatch);\n+        putBack(session);\n+        return resp;\n+      } catch (IoTDBSessionException e) {\n+        if (e.getCause() instanceof TException) {\n+          // TException means the connection is broken, remove it and get a new one.", "originalCommit": "e7157addd0a53bf9cba3a4a20c7648d714ec2b8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIzNzgxNA==", "url": "https://github.com/apache/iotdb/pull/880#discussion_r389237814", "bodyText": "will fix.", "author": "jixuan1989", "createdAt": "2020-03-07T08:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODA1NjE4MQ=="}], "type": "inlineReview"}, {"oid": "e5002afbdadb68848233f081149de90488690be8", "url": "https://github.com/apache/iotdb/commit/e5002afbdadb68848233f081149de90488690be8", "message": "add timeout and retry times", "committedDate": "2020-03-13T00:58:33Z", "type": "commit"}, {"oid": "5d57b17daff36c1de7f1382d2464ad2f4fd52cf2", "url": "https://github.com/apache/iotdb/commit/5d57b17daff36c1de7f1382d2464ad2f4fd52cf2", "message": "merge with master to match new Exceptions", "committedDate": "2020-03-13T03:49:26Z", "type": "commit"}, {"oid": "5d3db5201aed160cc5c06104ca09748dbc2a9c1c", "url": "https://github.com/apache/iotdb/commit/5d3db5201aed160cc5c06104ca09748dbc2a9c1c", "message": "add columnNameList in SessionDataSet", "committedDate": "2020-03-14T02:04:26Z", "type": "commit"}, {"oid": "33b684ed3677087a7ac074cda98511e521498f9f", "url": "https://github.com/apache/iotdb/commit/33b684ed3677087a7ac074cda98511e521498f9f", "message": "add doc for getColumnNames of SessionDataSet", "committedDate": "2020-03-14T02:45:15Z", "type": "commit"}]}