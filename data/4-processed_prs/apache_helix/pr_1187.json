{"pr_number": 1187, "pr_title": "Add latency metric support for customized view aggregation", "pr_createdAt": "2020-07-29T17:46:02Z", "pr_url": "https://github.com/apache/helix/pull/1187", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MDgxMw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r464040813", "bodyText": "static final?", "author": "huizhilu", "createdAt": "2020-08-02T06:57:30Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,63 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);", "originalCommit": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MTI2Mw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r464041263", "bodyText": "Often, the only use for the ERROR level within a certain application is when a valuable business use case cannot be completed due to technical issues or a bug.\nI'd prefer not to use this logging level too generously because that would add too much noise to the logs and reduce the significance of a single ERROR event.\nThe WARN level should be used when something bad happened, but the application still has the chance to heal itself or the issue can wait a day or two to be fixed.", "author": "huizhilu", "createdAt": "2020-08-02T07:01:39Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,63 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.START_TIME, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  private void setCustomizedStateProperty(CustomizedState.CustomizedStateProperty propertyName,\n+      String stateType, String resourceName, Partition partition, String instanceName,\n+      String state) {\n+    Map<String, Map<String, Map<Partition, Map<String, String>>>> mapToUpdate;\n+    switch (propertyName) {\n+      case CURRENT_STATE:\n+        mapToUpdate = _customizedStateMap;\n+        break;\n+      case START_TIME:\n+        mapToUpdate = _startTimeMap;\n+        break;\n+      default:\n+        LOG.error(", "originalCommit": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMjk2NA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465212964", "bodyText": "Good to know. Thanks! I changed all the ERROR level to warning since it's not significant issue", "author": "mgao0", "createdAt": "2020-08-04T17:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MTI2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MjIxNA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r464042214", "bodyText": "We could make it simpler and cleaner by adopting computeIfAbsent:\nmapToUpdate.computeIfAbsent(stateType, k -> new HashMap<>())\n  .computeIfAbsent(resourceName, k -> new HashMap<>())\n  .computeIfAbsent(partition, k -> new HashMap<>())\n  .put(instanceName, state);", "author": "huizhilu", "createdAt": "2020-08-02T07:12:38Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,63 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.START_TIME, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  private void setCustomizedStateProperty(CustomizedState.CustomizedStateProperty propertyName,\n+      String stateType, String resourceName, Partition partition, String instanceName,\n+      String state) {\n+    Map<String, Map<String, Map<Partition, Map<String, String>>>> mapToUpdate;\n+    switch (propertyName) {\n+      case CURRENT_STATE:\n+        mapToUpdate = _customizedStateMap;\n+        break;\n+      case START_TIME:\n+        mapToUpdate = _startTimeMap;\n+        break;\n+      default:\n+        LOG.error(\n+            \"The customized state property is not supported, could not update customized state output.\");\n+        return;\n+    }\n+    if (!mapToUpdate.containsKey(stateType)) {\n+      mapToUpdate.put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n     }\n-    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n-      _customizedStateMap.get(stateType)\n-          .put(resourceName, new HashMap<Partition, Map<String, String>>());\n+    if (!mapToUpdate.get(stateType).containsKey(resourceName)) {\n+      mapToUpdate.get(stateType).put(resourceName, new HashMap<Partition, Map<String, String>>());\n     }\n-    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n-      _customizedStateMap.get(stateType).get(resourceName)\n-          .put(partition, new HashMap<String, String>());\n+    if (!mapToUpdate.get(stateType).get(resourceName).containsKey(partition)) {\n+      mapToUpdate.get(stateType).get(resourceName).put(partition, new HashMap<String, String>());\n     }\n-    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+    mapToUpdate.get(stateType).get(resourceName).get(partition).put(instanceName, state);", "originalCommit": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MjQ1NQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r464042455", "bodyText": "I suggest warn level.", "author": "huizhilu", "createdAt": "2020-08-02T07:15:03Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -152,6 +161,31 @@ private void computeCustomizedStateView(final Resource resource, final String st\n     if (curCustomizedView == null || !curCustomizedView.getRecord().equals(view.getRecord())) {\n       // Add customized view to the list which will be written to ZK later.\n       updatedCustomizedViews.add(view);\n+      updatedStartTimestamps.put(resourceName,\n+          customizedStateOutput.getResourceStartTimeMap(stateType, resourceName));\n     }\n   }\n+\n+  private CustomizedViewMonitor getOrCreateMonitor(ClusterEvent event) {\n+    String clusterName = event.getClusterName();\n+    if (_monitors.get(clusterName) == null) {\n+      _monitors.put(clusterName, new CustomizedViewMonitor(clusterName));\n+    }\n+    return _monitors.get(clusterName);\n+  }\n+\n+  private void asyncReportLatency(ExecutorService threadPool, CustomizedViewMonitor monitor,\n+      List<CustomizedView> updatedCustomizedViews, Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, String>>> updatedStartTimestamps,\n+      boolean[] updateSuccess, long curTime) {\n+    AbstractBaseStage.asyncExecute(threadPool, () -> {\n+      try {\n+        monitor.reportLatency(updatedCustomizedViews, curCustomizedViews, updatedStartTimestamps,\n+            updateSuccess, curTime);\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to report UpdateToAggregationLatency metric.\", e);", "originalCommit": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MjYwNg==", "url": "https://github.com/apache/helix/pull/1187#discussion_r464042606", "bodyText": "The latest helix-style doesn't format two empty lines. Maybe good to update helix-style in your IntelliJ.", "author": "huizhilu", "createdAt": "2020-08-02T07:16:43Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import com.google.common.collect.MapDifference;\n+import com.google.common.collect.Maps;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.collections.Lists;\n+", "originalCommit": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MjYzNQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r464042635", "bodyText": "static final", "author": "huizhilu", "createdAt": "2020-08-02T07:16:53Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import com.google.common.collect.MapDifference;\n+import com.google.common.collect.Maps;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.collections.Lists;\n+\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);", "originalCommit": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0Mjc4NQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r464042785", "bodyText": "Apache License?", "author": "huizhilu", "createdAt": "2020-08-02T07:18:31Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.apache.helix.monitoring.mbeans;\n+", "originalCommit": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MzQ3OA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r464043478", "bodyText": "It seems we need to consider concurrency?", "author": "huizhilu", "createdAt": "2020-08-02T07:25:59Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,190 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import com.google.common.collect.MapDifference;\n+import com.google.common.collect.Maps;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.collections.Lists;\n+\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName =\n+        String.format(\"%s.%s\", MonitorDomainNames.RoutingTableProvider.name(), _clusterName);\n+    _updateToAggregationLatencyGauge = new HistogramDynamicMetric(\"UpdateToAggregationLatencyGauge\",\n+        new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.CustomizedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  private void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,", "originalCommit": "ba1e4df91a9fc834c0382ae5a0269f4ce7da977a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxNDE0Nw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465214147", "bodyText": "These events are put into a thread pool for async execution, but the parameters we put in are all hard copied so they won't interfere with each other. So each event is independent.", "author": "mgao0", "createdAt": "2020-08-04T17:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDA0MzQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5Njk3OA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465396978", "bodyText": "CustomizedView -> AggregatedView ? In this case, we can transfer EV TEV metrics to this domain in the future.", "author": "jiajunwang", "createdAt": "2020-08-05T00:06:30Z", "path": "helix-core/src/main/java/org/apache/helix/InstanceType.java", "diffHunk": "@@ -37,7 +37,8 @@\n       MonitorDomainNames.ClusterStatus.name(),\n       MonitorDomainNames.HelixZkClient.name(),\n       MonitorDomainNames.HelixCallback.name(),\n-      MonitorDomainNames.Rebalancer.name()\n+      MonitorDomainNames.Rebalancer.name(),\n+      MonitorDomainNames.CustomizedView.name()", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NzQ3MQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465397471", "bodyText": "Will it be simpler if you set the start time inside setCustomizedState()? Are there any other cases that you want to update the state but don't touch the start time?\nThis will help to reduce duplicate code.", "author": "jiajunwang", "createdAt": "2020-08-05T00:08:16Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateComputationStage.java", "diffHunk": "@@ -86,6 +86,9 @@ private void updateCustomizedStates(String instanceName, String customizedStateT\n           customizedStateOutput\n               .setCustomizedState(customizedStateType, resourceName, partition, instanceName,\n                   customizedState.getState(partitionName));\n+          customizedStateOutput", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0NDcyNA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r466644724", "bodyText": "I added another parameter to setCustomizedState() and now this method can set both fields.\nOriginally I didn't want to change the interface of setCustomizedState() because it is a public method. But I think your comment also makes sense since we are going to keep this start time field, and this is the only place setCustomizedState()  is called.", "author": "mgao0", "createdAt": "2020-08-06T19:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5NzQ3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5Nzg5Nw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465397897", "bodyText": "Can you process the long type inside the method? Converting the type in the caller is not clean. If you have multiple callers, then you will need to convert every time.", "author": "jiajunwang", "createdAt": "2020-08-05T00:09:43Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateComputationStage.java", "diffHunk": "@@ -86,6 +86,9 @@ private void updateCustomizedStates(String instanceName, String customizedStateT\n           customizedStateOutput\n               .setCustomizedState(customizedStateType, resourceName, partition, instanceName,\n                   customizedState.getState(partitionName));\n+          customizedStateOutput\n+              .setStartTime(customizedStateType, resourceName, partition, instanceName,\n+                  String.valueOf(customizedState.getStartTime(partitionName)));", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0MzIyMQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r466643221", "bodyText": "Good suggestion. I'll keep the long type, and save the two conversions of types for saving to and  retrieving from the map.", "author": "mgao0", "createdAt": "2020-08-06T19:39:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5Nzg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM5OTcxNg==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465399716", "bodyText": "It is called set start time, but you put a \"state\" in the parameter. It looks strange.", "author": "jiajunwang", "createdAt": "2020-08-05T00:16:09Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n-      _customizedStateMap.get(stateType)\n-          .put(resourceName, new HashMap<Partition, Map<String, String>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n-      _customizedStateMap.get(stateType).get(resourceName)\n-          .put(partition, new HashMap<String, String>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMDE1MQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465400151", "bodyText": "These are duplicate logic with the switch block in getCustomizedStateProperty().", "author": "jiajunwang", "createdAt": "2020-08-05T00:17:48Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n-      _customizedStateMap.get(stateType)\n-          .put(resourceName, new HashMap<Partition, Map<String, String>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n-      _customizedStateMap.get(stateType).get(resourceName)\n-          .put(partition, new HashMap<String, String>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.START_TIME, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  private void setCustomizedStateProperty(CustomizedState.CustomizedStateProperty propertyName,\n+      String stateType, String resourceName, Partition partition, String instanceName,\n+      String state) {\n+    Map<String, Map<String, Map<Partition, Map<String, String>>>> mapToUpdate;\n+    switch (propertyName) {", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMDQyNg==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465400426", "bodyText": "Why not save the Long type for the startTime here?", "author": "jiajunwang", "createdAt": "2020-08-05T00:18:47Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMTI4Ng==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465401286", "bodyText": "I know we are doing this style (separate maps for different fields) everywhere, but I am thinking if we can make it better. Either using the Pair or make a private class will definitely help to simplify the code here.", "author": "jiajunwang", "createdAt": "2020-08-05T00:22:04Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0NTc0OQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r466645749", "bodyText": "Discussed offline, I tried the private class design and it didn't work ideally. I think we need a better and more comprehensive design to improve this. For now, let's just keep them separated since it is clear to the callers.", "author": "mgao0", "createdAt": "2020-08-06T19:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMTI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMjU1NQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465402555", "bodyText": "Do you really need to clone the success array?", "author": "jiajunwang", "createdAt": "2020-08-05T00:26:36Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -107,8 +114,11 @@ public void execute(final ClusterEvent event) throws Exception {\n           }\n           // add/update customized-views from zk and cache\n           if (updatedCustomizedViews.size() > 0) {\n-            dataAccessor.setChildren(keys, updatedCustomizedViews);\n+            boolean[] success = dataAccessor.setChildren(keys, updatedCustomizedViews);\n             cache.updateCustomizedViews(stateType, updatedCustomizedViews);\n+            asyncReportLatency(cache.getAsyncTasksThreadPool(), getOrCreateMonitor(event),\n+                new ArrayList<>(updatedCustomizedViews), curCustomizedViewsCopy,\n+                new HashMap<>(updatedStartTimestamps), success.clone(), System.currentTimeMillis());", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwOTYzMw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465409633", "bodyText": "I think we shall make stage object stateless. So this monitor map shall be in the cache.", "author": "jiajunwang", "createdAt": "2020-08-05T00:53:47Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -35,17 +37,20 @@\n import org.apache.helix.controller.LogUtil;\n import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AbstractBaseStage;\n import org.apache.helix.controller.pipeline.AsyncWorkerType;\n import org.apache.helix.controller.pipeline.StageException;\n import org.apache.helix.model.CustomizedView;\n import org.apache.helix.model.Partition;\n import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.CustomizedViewMonitor;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n \n public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n   private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+  private Map<String, CustomizedViewMonitor> _monitors = new HashMap<>();", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQxNTkyNA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465415924", "bodyText": "Once we put this map into the cache object, concurrent control is necessary for this method.", "author": "jiajunwang", "createdAt": "2020-08-05T01:16:54Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -152,6 +163,33 @@ private void computeCustomizedStateView(final Resource resource, final String st\n     if (curCustomizedView == null || !curCustomizedView.getRecord().equals(view.getRecord())) {\n       // Add customized view to the list which will be written to ZK later.\n       updatedCustomizedViews.add(view);\n+      updatedStartTimestamps.put(resourceName,\n+          customizedStateOutput.getResourceStartTimeMap(stateType, resourceName));\n     }\n   }\n+\n+  private CustomizedViewMonitor getOrCreateMonitor(ClusterEvent event) throws JMException {", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3MDk2Mw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465470963", "bodyText": "Good change!", "author": "zhangmeng916", "createdAt": "2020-08-05T04:51:06Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n-      _customizedStateMap.get(stateType)\n-          .put(resourceName, new HashMap<Partition, Map<String, String>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n-      _customizedStateMap.get(stateType).get(resourceName)\n-          .put(partition, new HashMap<String, String>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.START_TIME, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  private void setCustomizedStateProperty(CustomizedState.CustomizedStateProperty propertyName,\n+      String stateType, String resourceName, Partition partition, String instanceName,\n+      String state) {\n+    Map<String, Map<String, Map<Partition, Map<String, String>>>> mapToUpdate;\n+    switch (propertyName) {\n+      case CURRENT_STATE:\n+        mapToUpdate = _customizedStateMap;\n+        break;\n+      case START_TIME:\n+        mapToUpdate = _startTimeMap;\n+        break;\n+      default:\n+        LOG.warn(\n+            \"The customized state property is not supported, could not update customized state output.\");\n+        return;\n     }\n-    _customizedStateMap.get(stateType).get(resourceName).get(partition).put(instanceName, state);\n+\n+    mapToUpdate.computeIfAbsent(stateType, k -> new HashMap<>())\n+        .computeIfAbsent(resourceName, k -> new HashMap<>())\n+        .computeIfAbsent(partition, k -> new HashMap<>())\n+        .put(instanceName, state);", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3MjY4OA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465472688", "bodyText": "Can we rename mapToUpdate and the following readFromMap to be more meaningful and following convention.", "author": "zhangmeng916", "createdAt": "2020-08-05T04:56:58Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -24,32 +24,58 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.apache.helix.model.CustomizedState;\n import org.apache.helix.model.Partition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n \n public class CustomizedStateOutput {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedStateOutput.class);\n+\n   // stateType -> (resourceName -> (Partition -> (instanceName -> customizedState)))\n   private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _customizedStateMap;\n+  // stateType -> (resourceName -> (Partition -> (instanceName -> startTime)))\n+  private final Map<String, Map<String, Map<Partition, Map<String, String>>>> _startTimeMap;\n \n   public CustomizedStateOutput() {\n     _customizedStateMap = new HashMap<>();\n+    _startTimeMap = new HashMap<>();\n   }\n \n   public void setCustomizedState(String stateType, String resourceName, Partition partition,\n       String instanceName, String state) {\n-    if (!_customizedStateMap.containsKey(stateType)) {\n-      _customizedStateMap\n-          .put(stateType, new HashMap<String, Map<Partition, Map<String, String>>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).containsKey(resourceName)) {\n-      _customizedStateMap.get(stateType)\n-          .put(resourceName, new HashMap<Partition, Map<String, String>>());\n-    }\n-    if (!_customizedStateMap.get(stateType).get(resourceName).containsKey(partition)) {\n-      _customizedStateMap.get(stateType).get(resourceName)\n-          .put(partition, new HashMap<String, String>());\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.CURRENT_STATE, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  public void setStartTime(String stateType, String resourceName, Partition partition,\n+      String instanceName, String state) {\n+    setCustomizedStateProperty(CustomizedState.CustomizedStateProperty.START_TIME, stateType,\n+        resourceName, partition, instanceName, state);\n+  }\n+\n+  private void setCustomizedStateProperty(CustomizedState.CustomizedStateProperty propertyName,\n+      String stateType, String resourceName, Partition partition, String instanceName,\n+      String state) {\n+    Map<String, Map<String, Map<Partition, Map<String, String>>>> mapToUpdate;", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0NjYyNw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r466646627", "bodyText": "I updated this part. I was trying to simplify the code but found it makes things more complicated. Now I just separate the two methods, as they do not really cause a lot duplicated code.", "author": "mgao0", "createdAt": "2020-08-06T19:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3MjY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3NDgzMw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465474833", "bodyText": "As you never use this variable in other places, just move it to line 120.", "author": "zhangmeng916", "createdAt": "2020-08-05T05:05:03Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -97,7 +103,8 @@ public void execute(final ClusterEvent event) throws Exception {\n       for (Resource resource : resourceMap.values()) {\n         try {\n           computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n-              updatedCustomizedViews);\n+              updatedCustomizedViews, updatedStartTimestamps);\n+          Map<String, CustomizedView> curCustomizedViewsCopy = new HashMap<>(curCustomizedViews);", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0NzE4Nw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r466647187", "bodyText": "See the next reply.", "author": "mgao0", "createdAt": "2020-08-06T19:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3NDgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3NTExNQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465475115", "bodyText": "Have you run the whole integration tests? I'm a bit concerned about the extra memory cost. Do you need to whole curCustomizedViewCopy? The ones that are corresponding to the updatedViews should be fine, right? as you only need those timestamps to compare.", "author": "zhangmeng916", "createdAt": "2020-08-05T05:06:02Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -107,8 +114,11 @@ public void execute(final ClusterEvent event) throws Exception {\n           }\n           // add/update customized-views from zk and cache\n           if (updatedCustomizedViews.size() > 0) {\n-            dataAccessor.setChildren(keys, updatedCustomizedViews);\n+            boolean[] success = dataAccessor.setChildren(keys, updatedCustomizedViews);\n             cache.updateCustomizedViews(stateType, updatedCustomizedViews);\n+            asyncReportLatency(cache.getAsyncTasksThreadPool(), getOrCreateMonitor(event),\n+                new ArrayList<>(updatedCustomizedViews), curCustomizedViewsCopy,", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0ODc5OA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r466648798", "bodyText": "Discussed offline, current curCustomizedViewCopy is a whole copy of the entire set of customized views. We do not need that, so I will only save the curCustomizedView of what's changed, so we won't need to be concerned about memory usage. So curCustomizedViewCopy will be initialized as an empty map, and when we compare the customized views, if it's changed, we put the old customized view into this map, for later use to find out which partition state changed.", "author": "mgao0", "createdAt": "2020-08-06T19:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3NTExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3NjU4NQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465476585", "bodyText": "-> timestamp, one word.", "author": "zhangmeng916", "createdAt": "2020-08-05T05:11:20Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.CustomizedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.CustomizedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, String>>> updatedStartTimestamps,\n+      boolean[] updateSuccess, long endTime) {\n+    if (updatedCustomizedViews == null || curCustomizedViews == null\n+        || updatedStartTimestamps == null) {\n+      LOG.warn(\"Cannot find updated time stamps for customized states, input parameter is null.\");\n+      return;\n+    }\n+\n+    List<Long> collectedTimestamps = new ArrayList<>();\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      if (!updateSuccess[i]) {\n+        continue;\n+      }\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+      CustomizedView oldCV =\n+          curCustomizedViews.getOrDefault(resourceName, new CustomizedView(resourceName));\n+      if (newCV.getRecord().equals(oldCV.getRecord())) {\n+        continue;\n+      }\n+\n+      Map<String, Map<String, String>> newPartitionStateMaps = newCV.getRecord().getMapFields();\n+      Map<String, Map<String, String>> oldPartitionStateMaps = oldCV.getRecord().getMapFields();\n+      Map<Partition, Map<String, String>> partitionStartTimeMaps =\n+          updatedStartTimestamps.getOrDefault(resourceName, Collections.emptyMap());\n+\n+      for (Map.Entry<String, Map<String, String>> partitionStateMapEntry : newPartitionStateMaps\n+          .entrySet()) {\n+        String partitionName = partitionStateMapEntry.getKey();\n+        Map<String, String> newStateMap = partitionStateMapEntry.getValue();\n+        Map<String, String> oldStateMap =\n+            oldPartitionStateMaps.getOrDefault(partitionName, Collections.emptyMap());\n+        if (!newStateMap.equals(oldStateMap)) {\n+          Map<String, String> partitionStartTimeMap = partitionStartTimeMaps\n+              .getOrDefault(new Partition(partitionName), Collections.emptyMap());\n+\n+          for (Map.Entry<String, String> stateMapEntry : newStateMap.entrySet()) {\n+            String instanceName = stateMapEntry.getKey();\n+            if (!stateMapEntry.getValue().equals(oldStateMap.get(instanceName))) {\n+              try {\n+                long timestamp = Long.parseLong(partitionStartTimeMap.get(instanceName));\n+                if (timestamp > 0) {\n+                  collectedTimestamps.add(timestamp);\n+                } else {\n+                  LOG.warn(\n+                      \"Failed to find customized state update time stamp for reos, the number should be positive.\");\n+                }\n+              } catch (NumberFormatException e) {\n+                LOG.warn(\"Error occurs while parsing customized state update time stamp\");", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3ODA2OA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465478068", "bodyText": "Is this still necessary? The updated customized views should have been compared and filtered.", "author": "zhangmeng916", "createdAt": "2020-08-05T05:16:32Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.CustomizedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.CustomizedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, String>>> updatedStartTimestamps,\n+      boolean[] updateSuccess, long endTime) {\n+    if (updatedCustomizedViews == null || curCustomizedViews == null\n+        || updatedStartTimestamps == null) {\n+      LOG.warn(\"Cannot find updated time stamps for customized states, input parameter is null.\");\n+      return;\n+    }\n+\n+    List<Long> collectedTimestamps = new ArrayList<>();\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      if (!updateSuccess[i]) {\n+        continue;\n+      }\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+      CustomizedView oldCV =\n+          curCustomizedViews.getOrDefault(resourceName, new CustomizedView(resourceName));\n+      if (newCV.getRecord().equals(oldCV.getRecord())) {", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0NzAzOQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r466647039", "bodyText": "I was trying to be safe. But you are right, it's not necessary. Removed it.", "author": "mgao0", "createdAt": "2020-08-06T19:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3ODA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3ODg0Nw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465478847", "bodyText": "typo?", "author": "zhangmeng916", "createdAt": "2020-08-05T05:19:32Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,151 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.CustomizedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.CustomizedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, String>>> updatedStartTimestamps,\n+      boolean[] updateSuccess, long endTime) {\n+    if (updatedCustomizedViews == null || curCustomizedViews == null\n+        || updatedStartTimestamps == null) {\n+      LOG.warn(\"Cannot find updated time stamps for customized states, input parameter is null.\");\n+      return;\n+    }\n+\n+    List<Long> collectedTimestamps = new ArrayList<>();\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      if (!updateSuccess[i]) {\n+        continue;\n+      }\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+      CustomizedView oldCV =\n+          curCustomizedViews.getOrDefault(resourceName, new CustomizedView(resourceName));\n+      if (newCV.getRecord().equals(oldCV.getRecord())) {\n+        continue;\n+      }\n+\n+      Map<String, Map<String, String>> newPartitionStateMaps = newCV.getRecord().getMapFields();\n+      Map<String, Map<String, String>> oldPartitionStateMaps = oldCV.getRecord().getMapFields();\n+      Map<Partition, Map<String, String>> partitionStartTimeMaps =\n+          updatedStartTimestamps.getOrDefault(resourceName, Collections.emptyMap());\n+\n+      for (Map.Entry<String, Map<String, String>> partitionStateMapEntry : newPartitionStateMaps\n+          .entrySet()) {\n+        String partitionName = partitionStateMapEntry.getKey();\n+        Map<String, String> newStateMap = partitionStateMapEntry.getValue();\n+        Map<String, String> oldStateMap =\n+            oldPartitionStateMaps.getOrDefault(partitionName, Collections.emptyMap());\n+        if (!newStateMap.equals(oldStateMap)) {\n+          Map<String, String> partitionStartTimeMap = partitionStartTimeMaps\n+              .getOrDefault(new Partition(partitionName), Collections.emptyMap());\n+\n+          for (Map.Entry<String, String> stateMapEntry : newStateMap.entrySet()) {\n+            String instanceName = stateMapEntry.getKey();\n+            if (!stateMapEntry.getValue().equals(oldStateMap.get(instanceName))) {\n+              try {\n+                long timestamp = Long.parseLong(partitionStartTimeMap.get(instanceName));\n+                if (timestamp > 0) {\n+                  collectedTimestamps.add(timestamp);\n+                } else {\n+                  LOG.warn(\n+                      \"Failed to find customized state update time stamp for reos, the number should be positive.\");", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4MDUzOQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465480539", "bodyText": "Can you explain what is verified as 0?", "author": "zhangmeng916", "createdAt": "2020-08-05T05:25:12Z", "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestCustomizedViewStage.java", "diffHunk": "@@ -112,4 +110,60 @@ public void testCachedCustomizedViews() throws Exception {\n     deleteLiveInstances(clusterName);\n     deleteCluster(clusterName);\n   }\n+\n+  @Test\n+  public void testLatencyMetricReporting() throws Exception {\n+    String clusterName = \"CLUSTER_\" + TestHelper.getTestMethodName();\n+\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n+    HelixManager manager = new DummyClusterManager(clusterName, accessor);\n+\n+    // ideal state: node0 is MASTER, node1 is SLAVE\n+    // replica=2 means 1 master and 1 slave\n+    setupIdealState(clusterName, new int[]{0, 1}, new String[]{\"TestDB\"}, 1, 2);\n+    setupLiveInstances(clusterName, new int[]{0, 1});\n+    setupStateModel(clusterName);\n+\n+    ClusterEvent event = new ClusterEvent(clusterName, ClusterEventType.Unknown);\n+    ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n+    event.addAttribute(AttributeName.helixmanager.name(), manager);\n+    event.addAttribute(AttributeName.ControllerDataProvider.name(), cache);\n+\n+    CustomizedStateConfig config = new CustomizedStateConfig();\n+    List<String> aggregationEnabledTypes = new ArrayList<>();\n+    aggregationEnabledTypes.add(CUSTOMIZED_STATE_NAME);\n+    config.setAggregationEnabledTypes(aggregationEnabledTypes);\n+\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    accessor.setProperty(keyBuilder.customizedStateConfig(), config);\n+\n+    CustomizedState customizedState = new CustomizedState(RESOURCE_NAME);\n+    customizedState.setState(PARTITION_NAME, \"STATE\");\n+    customizedState.setStartTime(PARTITION_NAME, 0);\n+    accessor.setProperty(\n+        keyBuilder.customizedState(INSTANCE_NAME, CUSTOMIZED_STATE_NAME, RESOURCE_NAME),\n+        customizedState);\n+\n+    Pipeline dataRefresh = new Pipeline();\n+    dataRefresh.addStage(new ReadClusterDataStage());\n+    runPipeline(event, dataRefresh);\n+    runStage(event, new ResourceComputationStage());\n+    runStage(event, new CustomizedStateComputationStage());\n+    runStage(event, new CustomizedViewAggregationStage());\n+\n+    ObjectName objectName = new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.CustomizedView.name(), \"Cluster\", clusterName));\n+    ObjectInstance monitor = _server.getObjectInstance(objectName);\n+    Assert.assertNotNull(monitor);\n+    TestHelper.verify(() -> (long) _server.getAttribute(objectName,\n+        CustomizedViewMonitor.UPDATE_TO_AGGREGATION_LATENCY_GAUGE + \".Max\") == 0,", "originalCommit": "55b0a4c0a31bae95dc420e1fca7a6e0cc0b3b191", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkyMDY0Mg==", "url": "https://github.com/apache/helix/pull/1187#discussion_r465920642", "bodyText": "Good catch. I made a mistake here, it should be not equal to 0, which means there is a latency data point reported.", "author": "mgao0", "createdAt": "2020-08-05T18:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ4MDUzOQ=="}], "type": "inlineReview"}, {"oid": "2568e8a5308b21ff171831700a9bdbdde8ba9cae", "url": "https://github.com/apache/helix/commit/2568e8a5308b21ff171831700a9bdbdde8ba9cae", "message": "add metrics", "committedDate": "2020-08-07T01:02:30Z", "type": "commit"}, {"oid": "717c8b82ed7dbce7780bd2c05c0ddb18197c409a", "url": "https://github.com/apache/helix/commit/717c8b82ed7dbce7780bd2c05c0ddb18197c409a", "message": "Modified implementation and add test", "committedDate": "2020-08-07T01:02:30Z", "type": "commit"}, {"oid": "4e79fd2381dd2265c74fb4c1036d6cc70892d830", "url": "https://github.com/apache/helix/commit/4e79fd2381dd2265c74fb4c1036d6cc70892d830", "message": "Modify existing tests", "committedDate": "2020-08-07T01:02:30Z", "type": "commit"}, {"oid": "512f65bf3234874a83426cc62cac22d37ae99be6", "url": "https://github.com/apache/helix/commit/512f65bf3234874a83426cc62cac22d37ae99be6", "message": "Modify aggregation stage and move monitor to cache", "committedDate": "2020-08-07T01:04:50Z", "type": "commit"}, {"oid": "512f65bf3234874a83426cc62cac22d37ae99be6", "url": "https://github.com/apache/helix/commit/512f65bf3234874a83426cc62cac22d37ae99be6", "message": "Modify aggregation stage and move monitor to cache", "committedDate": "2020-08-07T01:04:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MTY0OA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r466841648", "bodyText": "Can we log somewhere how many updates are failed? It's useful information.", "author": "zhangmeng916", "createdAt": "2020-08-07T06:14:11Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -112,14 +115,18 @@ public void execute(final ClusterEvent event) throws Exception {\n       }\n       // add/update customized-views from zk and cache\n       if (updatedCustomizedViews.size() > 0) {\n-        dataAccessor.setChildren(keys, updatedCustomizedViews);\n+        boolean[] success = dataAccessor.setChildren(keys, updatedCustomizedViews);", "originalCommit": "512f65bf3234874a83426cc62cac22d37ae99be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4MjEzNQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r467182135", "bodyText": "I added a logging in CustomizedViewMonitor because it is already looping through this boolean[] so it's the most convenient place to add it.", "author": "mgao0", "createdAt": "2020-08-07T17:45:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MTY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0MjQ0MQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r466842441", "bodyText": "You commented as not necessary?", "author": "zhangmeng916", "createdAt": "2020-08-07T06:16:37Z", "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestCustomizedViewStage.java", "diffHunk": "@@ -112,4 +110,60 @@ public void testCachedCustomizedViews() throws Exception {\n     deleteLiveInstances(clusterName);\n     deleteCluster(clusterName);\n   }\n+\n+  @Test\n+  public void testLatencyMetricReporting() throws Exception {\n+    String clusterName = \"CLUSTER_\" + TestHelper.getTestMethodName();\n+\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n+    HelixManager manager = new DummyClusterManager(clusterName, accessor);\n+\n+    // ideal state: node0 is MASTER, node1 is SLAVE\n+    // replica=2 means 1 master and 1 slave\n+    setupIdealState(clusterName, new int[]{0, 1}, new String[]{\"TestDB\"}, 1, 2);\n+    setupLiveInstances(clusterName, new int[]{0, 1});\n+    setupStateModel(clusterName);\n+\n+    ClusterEvent event = new ClusterEvent(clusterName, ClusterEventType.Unknown);\n+    ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n+    event.addAttribute(AttributeName.helixmanager.name(), manager);\n+    event.addAttribute(AttributeName.ControllerDataProvider.name(), cache);\n+\n+    CustomizedStateConfig config = new CustomizedStateConfig();\n+    List<String> aggregationEnabledTypes = new ArrayList<>();\n+    aggregationEnabledTypes.add(CUSTOMIZED_STATE_NAME);\n+    config.setAggregationEnabledTypes(aggregationEnabledTypes);\n+\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    accessor.setProperty(keyBuilder.customizedStateConfig(), config);\n+\n+    CustomizedState customizedState = new CustomizedState(RESOURCE_NAME);\n+    customizedState.setState(PARTITION_NAME, \"STATE\");\n+    customizedState.setStartTime(PARTITION_NAME, 0);\n+    accessor.setProperty(\n+        keyBuilder.customizedState(INSTANCE_NAME, CUSTOMIZED_STATE_NAME, RESOURCE_NAME),\n+        customizedState);\n+\n+    Pipeline dataRefresh = new Pipeline();\n+    dataRefresh.addStage(new ReadClusterDataStage());\n+    runPipeline(event, dataRefresh);\n+    runStage(event, new ResourceComputationStage());\n+    runStage(event, new CustomizedStateComputationStage());\n+    runStage(event, new CustomizedViewAggregationStage());\n+\n+    ObjectName objectName = new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Cluster\", clusterName));\n+    ObjectInstance monitor = _server.getObjectInstance(objectName);\n+    Assert.assertNotNull(monitor);\n+    TestHelper.verify(() -> (long) _server.getAttribute(objectName,\n+        CustomizedViewMonitor.UPDATE_TO_AGGREGATION_LATENCY_GAUGE + \".Max\") != 0,\n+        TestHelper.WAIT_DURATION);\n+\n+    if (manager.isConnected()) {\n+      manager.disconnect(); // For DummyClusterManager, this is not necessary", "originalCommit": "512f65bf3234874a83426cc62cac22d37ae99be6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0NTE0Mw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r466845143", "bodyText": "Is getOrDefault necessary? You already new one in aggregation stage.", "author": "zhangmeng916", "createdAt": "2020-08-07T06:24:49Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, Long>>> updatedStartTimestamps,\n+      boolean[] updateSuccess, long endTime) {\n+    if (updatedCustomizedViews == null || curCustomizedViews == null\n+        || updatedStartTimestamps == null) {\n+      LOG.warn(\"Cannot find updated time stamps for customized states, input parameter is null.\");\n+      return;\n+    }\n+\n+    List<Long> collectedTimestamps = new ArrayList<>();\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      if (!updateSuccess[i]) {\n+        continue;\n+      }\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+      CustomizedView oldCV =\n+          curCustomizedViews.getOrDefault(resourceName, new CustomizedView(resourceName));", "originalCommit": "512f65bf3234874a83426cc62cac22d37ae99be6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NzA3MA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r467177070", "bodyText": "I feel it's safer. It's just a check so it doesn't add any burden. Although it's unlikely, but this is a public method so it theoretically can be called somewhere else other than aggregation stage where the handling is not done the same. So I personally want to keep this check, please let me know if you think we should remove it.", "author": "mgao0", "createdAt": "2020-08-07T17:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg0NTE0Mw=="}], "type": "inlineReview"}, {"oid": "dfc72a7bb55393cd8fb96da3f5a78915e017a623", "url": "https://github.com/apache/helix/commit/dfc72a7bb55393cd8fb96da3f5a78915e017a623", "message": "Update logging", "committedDate": "2020-08-07T17:43:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MTMzNg==", "url": "https://github.com/apache/helix/pull/1187#discussion_r468261336", "bodyText": "Besides cluster name, can we also have customized View as part of the key? Maybe type = customized view? This is mainly for future extension.", "author": "jiajunwang", "createdAt": "2020-08-11T00:39:34Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Cluster\", _clusterName));", "originalCommit": "dfc72a7bb55393cd8fb96da3f5a78915e017a623", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MjM5NA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r468262394", "bodyText": "Please mention a little bit more about the parameter usage here. Basically we only update the timestamp if the state has been changed, right?", "author": "jiajunwang", "createdAt": "2020-08-11T00:43:21Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,149 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state", "originalCommit": "dfc72a7bb55393cd8fb96da3f5a78915e017a623", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MzYxOA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r468263618", "bodyText": "On my second thought, let's follow the convention (refer to _clusterStatusMonitor) and put it in GenericHelixController. What do you think?\nThe problem with the cache is that this object won't be available if we change to pass the snapshot later.\nIn general, we should always use the event to carry the monitors. And GenericHelixController is one of the easiest options.", "author": "jiajunwang", "createdAt": "2020-08-11T00:47:51Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -79,6 +82,7 @@\n   // Maintain a set of all ChangeTypes for change detection\n   private Set<HelixConstants.ChangeType> _refreshedChangeTypes;\n   private Set<String> _aggregationEnabledTypes = new HashSet<>();\n+  private Map<String, CustomizedViewMonitor> _customizedViewMonitors = new HashMap<>();", "originalCommit": "dfc72a7bb55393cd8fb96da3f5a78915e017a623", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTQ1NTA4MQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r469455081", "bodyText": "As we discussed, I put CustomizedViewMonitor as a field in ClusterStatusMonitor, so now in CustomizedViewAggregationStage, we'll just get the CustomizedViewMonitor from the event's ClusterStatusMonitor attribute.", "author": "mgao0", "createdAt": "2020-08-12T18:23:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI2MzYxOA=="}], "type": "inlineReview"}, {"oid": "1813eecb8e015c400e7c88c24c6e635e67301541", "url": "https://github.com/apache/helix/commit/1813eecb8e015c400e7c88c24c6e635e67301541", "message": "Move monitor from cache to cluster status monitor", "committedDate": "2020-08-11T23:57:37Z", "type": "forcePushed"}, {"oid": "db48ed9d8ca7b94d141bbc15c72955dd39dc50a5", "url": "https://github.com/apache/helix/commit/db48ed9d8ca7b94d141bbc15c72955dd39dc50a5", "message": "Move monitor from cache to cluster status monitor", "committedDate": "2020-08-12T19:00:01Z", "type": "forcePushed"}, {"oid": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "url": "https://github.com/apache/helix/commit/fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "message": "Move monitor from cache to cluster status monitor", "committedDate": "2020-08-12T19:02:10Z", "type": "commit"}, {"oid": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "url": "https://github.com/apache/helix/commit/fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "message": "Move monitor from cache to cluster status monitor", "committedDate": "2020-08-12T19:02:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYwNzQyMQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r469607421", "bodyText": "This should match the ObjectName", "author": "jiajunwang", "createdAt": "2020-08-12T23:44:28Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+  private ClusterStatusMonitor _clusterStatusMonitor;\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);", "originalCommit": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYwNzY1NA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r469607654", "bodyText": "nit, remove the \"CustomizedView\" hard code.", "author": "jiajunwang", "createdAt": "2020-08-12T23:45:09Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+  private ClusterStatusMonitor _clusterStatusMonitor;\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s,%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Type\",\n+            \"CustomizedView\", \"Cluster\", _clusterName));", "originalCommit": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYwOTYxMw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r469609613", "bodyText": "So this is a single metric for all the states. I'm thinking if we will need per-resource metrics in the future?\nThe thing is that, if you do per-resource for now, we can always get the global latency data by aggregating on the readers' side. But if you do the global latency, then there is no way we can get per-resource latency.", "author": "jiajunwang", "createdAt": "2020-08-12T23:51:14Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,154 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+  private ClusterStatusMonitor _clusterStatusMonitor;\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String.format(\"%s.%s\", MonitorDomainNames.AggregatedView.name(), _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s,%s=%s\", MonitorDomainNames.AggregatedView.name(), \"Type\",\n+            \"CustomizedView\", \"Cluster\", _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {\n+      _updateToAggregationLatencyGauge.updateValue(latency);\n+    }\n+  }\n+\n+  /**\n+   * Find updated customized states and report the aggregation latency of each customized state\n+   * Latency reporting excludes: updating a customized state that is the same as previous customized state,\n+   * deleting a customized state\n+   * @param updatedCustomizedViews Customized views that have been updated, obtained from CustomizedStateOutput\n+   * @param curCustomizedViews Current customized view values from the CustomizedViewCache\n+   * @param updatedStartTimestamps All customized state START_TIME property values from CustomizedStateOutput.\n+   * START_TIME field is automatically updated when a customized state for a partition is updated by CustomizedStateProvider.\n+   * @param updateSuccess If the customized view update to ZK is successful or not\n+   * @param endTime The timestamp when the new customized view is updated to ZK\n+   */\n+  public void reportLatency(List<CustomizedView> updatedCustomizedViews,", "originalCommit": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYzNDAyNg==", "url": "https://github.com/apache/helix/pull/1187#discussion_r469634026", "bodyText": "I discussed with @zhangmeng916 , we think global latency is good enough for our purpose. So we won't use per-resource latency since it can cause complexities and won't bring additional benefit for us in the foreseeable future.", "author": "mgao0", "createdAt": "2020-08-13T01:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYwOTYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxMTAxMg==", "url": "https://github.com/apache/helix/pull/1187#discussion_r469611012", "bodyText": "System.currentTimeMillis() can be inside asyncReportLatency.", "author": "jiajunwang", "createdAt": "2020-08-12T23:55:55Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -112,15 +119,22 @@ public void execute(final ClusterEvent event) throws Exception {\n       }\n       // add/update customized-views from zk and cache\n       if (updatedCustomizedViews.size() > 0) {\n-        dataAccessor.setChildren(keys, updatedCustomizedViews);\n+        boolean[] success = dataAccessor.setChildren(keys, updatedCustomizedViews);\n         cache.updateCustomizedViews(stateType, updatedCustomizedViews);\n+        asyncReportLatency(cache.getAsyncTasksThreadPool(),\n+            event.getAttribute(AttributeName.clusterStatusMonitor.name()),\n+            new ArrayList<>(updatedCustomizedViews), curCustomizedViewsCopy,\n+            new HashMap<>(updatedStartTimestamps), success, System.currentTimeMillis(),", "originalCommit": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTYxNDIyNA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r469614224", "bodyText": "As we discussed, since this stage is already async stage, we don't need to introduce these complicities, we can make the report logic synchronizely done in this stage.", "author": "jiajunwang", "createdAt": "2020-08-13T00:06:09Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -88,7 +93,9 @@ public void execute(final ClusterEvent event) throws Exception {\n     // update customized view\n     for (String stateType : customizedStateOutput.getAllStateTypes()) {\n       List<CustomizedView> updatedCustomizedViews = new ArrayList<>();\n+      Map<String, Map<Partition, Map<String, Long>>> updatedStartTimestamps = new HashMap<>();\n       Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      Map<String, CustomizedView> curCustomizedViewsCopy = new HashMap<>();", "originalCommit": "fbe0bade1ba47646dd7f3c92cfa36b844a8255b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7b9ca288466dffce324583ae0a8941e48316cc9b", "url": "https://github.com/apache/helix/commit/7b9ca288466dffce324583ae0a8941e48316cc9b", "message": "Make reporting latency synchronous", "committedDate": "2020-08-13T00:53:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NDQwOQ==", "url": "https://github.com/apache/helix/pull/1187#discussion_r470284409", "bodyText": "nit, could it be null?", "author": "jiajunwang", "createdAt": "2020-08-13T22:30:46Z", "path": "helix-core/src/main/java/org/apache/helix/monitoring/mbeans/CustomizedViewMonitor.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package org.apache.helix.monitoring.mbeans;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import javax.management.JMException;\n+import javax.management.MalformedObjectNameException;\n+import javax.management.ObjectName;\n+\n+import com.codahale.metrics.Histogram;\n+import com.codahale.metrics.SlidingTimeWindowArrayReservoir;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMBeanProvider;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.DynamicMetric;\n+import org.apache.helix.monitoring.mbeans.dynamicMBeans.HistogramDynamicMetric;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class CustomizedViewMonitor extends DynamicMBeanProvider {\n+  private static final Logger LOG = LoggerFactory.getLogger(CustomizedViewMonitor.class);\n+\n+  private static final String MBEAN_DESCRIPTION = \"Helix Customized View Aggregation Monitor\";\n+  private final String _clusterName;\n+  private final String _sensorName;\n+  private HistogramDynamicMetric _updateToAggregationLatencyGauge;\n+  public static final String UPDATE_TO_AGGREGATION_LATENCY_GAUGE =\n+      \"UpdateToAggregationLatencyGauge\";\n+  private ClusterStatusMonitor _clusterStatusMonitor;\n+  private static final String TYPE_KEY = \"Type\";\n+  private static final String CLUSTER_KEY = \"Cluster\";\n+  private static final String CUSTOMIZED_VIEW = \"CustomizedView\";\n+\n+  public CustomizedViewMonitor(String clusterName) {\n+    _clusterName = clusterName;\n+    _sensorName = String\n+        .format(\"%s:%s=%s,%s=%s\", MonitorDomainNames.AggregatedView.name(), TYPE_KEY,\n+            CUSTOMIZED_VIEW, CLUSTER_KEY, _clusterName);\n+    _updateToAggregationLatencyGauge =\n+        new HistogramDynamicMetric(UPDATE_TO_AGGREGATION_LATENCY_GAUGE, new Histogram(\n+            new SlidingTimeWindowArrayReservoir(getResetIntervalInMs(), TimeUnit.MILLISECONDS)));\n+  }\n+\n+  @Override\n+  public DynamicMBeanProvider register() throws JMException {\n+    List<DynamicMetric<?, ?>> attributeList = new ArrayList<>();\n+    attributeList.add(_updateToAggregationLatencyGauge);\n+    doRegister(attributeList, MBEAN_DESCRIPTION, getMBeanObjectName());\n+    return this;\n+  }\n+\n+  private ObjectName getMBeanObjectName() throws MalformedObjectNameException {\n+    return new ObjectName(String\n+        .format(\"%s:%s=%s,%s=%s\", MonitorDomainNames.AggregatedView.name(), TYPE_KEY,\n+            CUSTOMIZED_VIEW, CLUSTER_KEY, _clusterName));\n+  }\n+\n+  @Override\n+  public String getSensorName() {\n+    return _sensorName;\n+  }\n+\n+  public void recordUpdateToAggregationLatency(long latency) {\n+    if (_updateToAggregationLatencyGauge != null) {", "originalCommit": "7b9ca288466dffce324583ae0a8941e48316cc9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0MjQ5NA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r470342494", "bodyText": "Seems no other callers, make it private? In that case, no need to make it unmodifiableMap", "author": "jiajunwang", "createdAt": "2020-08-14T00:49:30Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateOutput.java", "diffHunk": "@@ -65,6 +70,11 @@ public void setCustomizedState(String stateType, String resourceName, Partition\n     return Collections.emptyMap();\n   }\n \n+  public Map<String, Map<Partition, Map<String, Long>>> getStartTimeMap(String stateType) {", "originalCommit": "7b9ca288466dffce324583ae0a8941e48316cc9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0NjQ5OA==", "url": "https://github.com/apache/helix/pull/1187#discussion_r470346498", "bodyText": "If the resource is newly created, will the oldCV contain the object?", "author": "jiajunwang", "createdAt": "2020-08-14T00:55:17Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -152,6 +162,68 @@ private void computeCustomizedStateView(final Resource resource, final String st\n     if (curCustomizedView == null || !curCustomizedView.getRecord().equals(view.getRecord())) {\n       // Add customized view to the list which will be written to ZK later.\n       updatedCustomizedViews.add(view);\n+      updatedStartTimestamps.put(resourceName,\n+          customizedStateOutput.getResourceStartTimeMap(stateType, resourceName));\n+    }\n+  }\n+\n+  private void reportLatency(ClusterEvent event, List<CustomizedView> updatedCustomizedViews,\n+      Map<String, CustomizedView> curCustomizedViews,\n+      Map<String, Map<Partition, Map<String, Long>>> updatedStartTimestamps,\n+      boolean[] updateSuccess) {\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+    if (clusterStatusMonitor == null) {\n+      return;\n+    }\n+    long curTime = System.currentTimeMillis();\n+    String clusterName = event.getClusterName();\n+    CustomizedViewMonitor customizedViewMonitor =\n+        clusterStatusMonitor.getOrCreateCustomizedViewMonitor(clusterName);\n+\n+    for (int i = 0; i < updatedCustomizedViews.size(); i++) {\n+      CustomizedView newCV = updatedCustomizedViews.get(i);\n+      String resourceName = newCV.getResourceName();\n+\n+      if (!updateSuccess[i]) {\n+        LOG.warn(\"Customized views are not updated successfully for resource {} on cluster {}\",\n+            resourceName, clusterName);\n+        continue;\n+      }\n+\n+      CustomizedView oldCV =", "originalCommit": "7b9ca288466dffce324583ae0a8941e48316cc9b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0Njk5Ng==", "url": "https://github.com/apache/helix/pull/1187#discussion_r470346996", "bodyText": "On the other hand, if the resource is removed, then this loop won't check the latency of that resource? But I think this is OK, since there is no start time to track anyway.", "author": "jiajunwang", "createdAt": "2020-08-14T00:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0NjQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM1ODYyMw==", "url": "https://github.com/apache/helix/pull/1187#discussion_r470358623", "bodyText": "If the resource is newly created, the oldCV won't have the object, that's why I initialize an empty CustomizedView object here, otherwise it will return a null and will complicate the following comparisons.\nYes, we decided not to put a start timestamp when deleting a state, thus there's no need to check for a removed resource too.", "author": "mgao0", "createdAt": "2020-08-14T01:13:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM0NjQ5OA=="}], "type": "inlineReview"}, {"oid": "f9e17e010d33a58b53006d2fbee129960500288d", "url": "https://github.com/apache/helix/commit/f9e17e010d33a58b53006d2fbee129960500288d", "message": "Fix for comments", "committedDate": "2020-08-14T01:14:44Z", "type": "commit"}]}