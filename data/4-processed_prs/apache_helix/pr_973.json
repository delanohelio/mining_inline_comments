{"pr_number": 973, "pr_title": "TaskStateModelFactory configurable thread pool size", "pr_createdAt": "2020-04-27T21:08:56Z", "pr_url": "https://github.com/apache/helix/pull/973", "timeline": [{"oid": "7b1f44607fa667a0aed42469c39fcd383fc68fae", "url": "https://github.com/apache/helix/commit/7b1f44607fa667a0aed42469c39fcd383fc68fae", "message": "Modify TaskStateModelFactory to get pool size from InstanceConfig/ClusterConfig", "committedDate": "2020-04-27T18:33:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDYxMw==", "url": "https://github.com/apache/helix/pull/973#discussion_r416940613", "bodyText": "Why does this need to be a public field?\nAlso, it seems that this constant and some of the other enums are duplicated in different places. Is it possible to put this in one place? (Hint. TaskConstants.java)", "author": "narendly", "createdAt": "2020-04-28T21:40:15Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -137,6 +140,7 @@\n   private final static int MAX_REBALANCE_PREFERENCE = 10;\n   private final static int MIN_REBALANCE_PREFERENCE = 0;\n   public final static boolean DEFAULT_GLOBAL_REBALANCE_ASYNC_MODE_ENABLED = true;\n+  public static final int TARGET_TASK_THREAD_POOL_SIZE_NOT_SET = -1;", "originalCommit": "7b1f44607fa667a0aed42469c39fcd383fc68fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1MTUxNA==", "url": "https://github.com/apache/helix/pull/973#discussion_r416951514", "bodyText": "Since InstanceConfig and ClusterConfig are both using the same enum and constant, how about only defining them in InstanceConfig and make them public, then ClusterConfig can reuse the values?\nAll the config field names we have so far are enums in one of the several ConfigPropertys, and I think it's better to maintain that convention; a separate file like TaskConstants.java having a InstanceConfig field name might come as a surprise to others.", "author": "NealSun96", "createdAt": "2020-04-28T22:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3Mzk4MQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r416973981", "bodyText": "IMO, the cluster level default value is different from the node level pool size.\nBetter to use a different name for the cluster level default number.\nDEFAULT_TARGET_TASK_THREAD_POOL_SIZE\nDEFAULT_TARGET_TASK_THREAD_POOL_SIZE_NOT_SET", "author": "jiajunwang", "createdAt": "2020-04-28T23:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY4NjAzMQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r419686031", "bodyText": "+1 to what @jiajunwang  said.", "author": "narendly", "createdAt": "2020-05-04T19:48:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1Mzc0Mw==", "url": "https://github.com/apache/helix/pull/973#discussion_r416953743", "bodyText": "Could we add setters as well with some sort of validation logic?", "author": "narendly", "createdAt": "2020-04-28T22:08:39Z", "path": "helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java", "diffHunk": "@@ -506,6 +508,16 @@ public void setMaxConcurrentTask(int maxConcurrentTask) {\n     _record.setIntField(InstanceConfigProperty.MAX_CONCURRENT_TASK.name(), maxConcurrentTask);\n   }\n \n+  /**\n+   * Get the target size of task thread pool\n+   * @return the target size of task thread pool\n+   */\n+  public int getTargetTaskThreadPoolSize() {", "originalCommit": "7b1f44607fa667a0aed42469c39fcd383fc68fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MDYwNg==", "url": "https://github.com/apache/helix/pull/973#discussion_r416960606", "bodyText": "I agree.", "author": "NealSun96", "createdAt": "2020-04-28T22:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1Mzc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NDE0Nw==", "url": "https://github.com/apache/helix/pull/973#discussion_r416954147", "bodyText": "Could we potentially move this constant to TaskConstants? Do you think that would be a good idea?", "author": "narendly", "createdAt": "2020-04-28T22:09:28Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -44,11 +49,11 @@\n   private final ScheduledExecutorService _taskExecutor;\n   private final ScheduledExecutorService _timerTaskExecutor;\n   private ThreadPoolExecutorMonitor _monitor;\n-  public final static int TASK_THREADPOOL_SIZE = 40;\n+  public final static int DEFAULT_TASK_THREAD_POOL_SIZE = 40;", "originalCommit": "7b1f44607fa667a0aed42469c39fcd383fc68fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MTIwMg==", "url": "https://github.com/apache/helix/pull/973#discussion_r416961202", "bodyText": "Since it's only used in this class, would it be better to have it here? And make it private?", "author": "NealSun96", "createdAt": "2020-04-28T22:26:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NDE0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzU5NTQ1OQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r417595459", "bodyText": "I realized that this is actually incorrect. I'll move it to TaskConstants.", "author": "NealSun96", "createdAt": "2020-04-29T20:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NDE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NDQwMQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r416954401", "bodyText": "Why are we including an underscore for a method name?", "author": "narendly", "createdAt": "2020-04-28T22:10:07Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -102,4 +107,40 @@ public boolean isShutdown() {\n   public boolean isTerminated() {\n     return _taskExecutor.isTerminated();\n   }\n+\n+  /*\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   */\n+  private static int _getTaskThreadPoolSize(HelixManager manager) {", "originalCommit": "7b1f44607fa667a0aed42469c39fcd383fc68fae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NjAyNg==", "url": "https://github.com/apache/helix/pull/973#discussion_r416956026", "bodyText": "Try-catch is not necessary here. There are other ways to check if InstanceConfig exists or not.\nE.g.) Perform one read, if it's null, then it will return null. If exists, then you'll have read the config.", "author": "narendly", "createdAt": "2020-04-28T22:13:50Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -102,4 +107,40 @@ public boolean isShutdown() {\n   public boolean isTerminated() {\n     return _taskExecutor.isTerminated();\n   }\n+\n+  /*\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   */\n+  private static int _getTaskThreadPoolSize(HelixManager manager) {\n+    ConfigAccessor configAccessor = manager.getConfigAccessor();\n+    // Check instance config first for thread pool size\n+    try {\n+      InstanceConfig instanceConfig =\n+          configAccessor.getInstanceConfig(manager.getClusterName(), manager.getInstanceName());\n+      int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+      if (_verifyTargetThreadPoolSize(targetTaskThreadPoolSize)) {\n+        return targetTaskThreadPoolSize;\n+      }\n+    } catch (HelixException e) {\n+      // Pass if InstanceConfig doesn't exist.\n+    }", "originalCommit": "7b1f44607fa667a0aed42469c39fcd383fc68fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2MzA3Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r416963072", "bodyText": "Thank you for correcting!", "author": "NealSun96", "createdAt": "2020-04-28T22:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NjAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1NzcxNw==", "url": "https://github.com/apache/helix/pull/973#discussion_r416957717", "bodyText": "Again, this might be an incorrect use of a try-catch clause", "author": "narendly", "createdAt": "2020-04-28T22:17:47Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -102,4 +107,40 @@ public boolean isShutdown() {\n   public boolean isTerminated() {\n     return _taskExecutor.isTerminated();\n   }\n+\n+  /*\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   */\n+  private static int _getTaskThreadPoolSize(HelixManager manager) {\n+    ConfigAccessor configAccessor = manager.getConfigAccessor();\n+    // Check instance config first for thread pool size\n+    try {\n+      InstanceConfig instanceConfig =\n+          configAccessor.getInstanceConfig(manager.getClusterName(), manager.getInstanceName());\n+      int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+      if (_verifyTargetThreadPoolSize(targetTaskThreadPoolSize)) {\n+        return targetTaskThreadPoolSize;\n+      }\n+    } catch (HelixException e) {\n+      // Pass if InstanceConfig doesn't exist.\n+    }\n+\n+    // Fallback to cluster config since instance config doesn't provide the value\n+    try {\n+      ClusterConfig clusterConfig = configAccessor.getClusterConfig(manager.getClusterName());\n+      int targetTaskThreadPoolSize = clusterConfig.getTargetTaskThreadPoolSize();\n+      if (_verifyTargetThreadPoolSize(targetTaskThreadPoolSize)) {\n+        return targetTaskThreadPoolSize;\n+      }\n+    } catch (HelixException e) {\n+      // Pass if ClusterConfig doesn't exist.\n+    }", "originalCommit": "7b1f44607fa667a0aed42469c39fcd383fc68fae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1Nzg2Ng==", "url": "https://github.com/apache/helix/pull/973#discussion_r416957866", "bodyText": "You could do this in the setter?", "author": "narendly", "createdAt": "2020-04-28T22:18:11Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -102,4 +107,40 @@ public boolean isShutdown() {\n   public boolean isTerminated() {\n     return _taskExecutor.isTerminated();\n   }\n+\n+  /*\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   */\n+  private static int _getTaskThreadPoolSize(HelixManager manager) {\n+    ConfigAccessor configAccessor = manager.getConfigAccessor();\n+    // Check instance config first for thread pool size\n+    try {\n+      InstanceConfig instanceConfig =\n+          configAccessor.getInstanceConfig(manager.getClusterName(), manager.getInstanceName());\n+      int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+      if (_verifyTargetThreadPoolSize(targetTaskThreadPoolSize)) {\n+        return targetTaskThreadPoolSize;\n+      }\n+    } catch (HelixException e) {\n+      // Pass if InstanceConfig doesn't exist.\n+    }\n+\n+    // Fallback to cluster config since instance config doesn't provide the value\n+    try {\n+      ClusterConfig clusterConfig = configAccessor.getClusterConfig(manager.getClusterName());\n+      int targetTaskThreadPoolSize = clusterConfig.getTargetTaskThreadPoolSize();\n+      if (_verifyTargetThreadPoolSize(targetTaskThreadPoolSize)) {\n+        return targetTaskThreadPoolSize;\n+      }\n+    } catch (HelixException e) {\n+      // Pass if ClusterConfig doesn't exist.\n+    }\n+\n+    return DEFAULT_TASK_THREAD_POOL_SIZE;\n+  }\n+\n+  private static boolean _verifyTargetThreadPoolSize(int targetTaskThreadPoolSize) {", "originalCommit": "7b1f44607fa667a0aed42469c39fcd383fc68fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2NDcyMA==", "url": "https://github.com/apache/helix/pull/973#discussion_r416964720", "bodyText": "This is to check against the default value: when the target thread pool size is not specified in the configs, a -1 is returned from getTargetTaskThreadPoolSize(). This check makes sure the default value is filtered out.\nI don't see any other good way to do getIntField() while handling the \"not defined\" case differently, since getIntField() always asks for a default value; if getIntField() throws an exception when the value is not defined it's much cleaner. This is the best solution I came up with while using getIntField().", "author": "NealSun96", "createdAt": "2020-04-28T22:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1Nzg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxMTcxNQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r419711715", "bodyText": "@narendly Reminder on this conversation.\nI want to know if there's a good way to use getIntField() while handling the \"not defined\" case differently. If not, I will proceed with the current design.", "author": "NealSun96", "createdAt": "2020-05-04T20:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk1Nzg2Ng=="}], "type": "inlineReview"}, {"oid": "dab0a534cef49b6f9512ce338ef3c5276041df7f", "url": "https://github.com/apache/helix/commit/dab0a534cef49b6f9512ce338ef3c5276041df7f", "message": "Address some comments", "committedDate": "2020-04-28T22:53:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTEzNQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r416975135", "bodyText": "nit, shall we throw exception if the instance config or cluster config is not found?\nThis mostly because the read is not done successfully. In which case, we don't know the real configured numbers. So better stop initialization instead of guess it shall be 40.", "author": "jiajunwang", "createdAt": "2020-04-28T23:03:07Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -102,4 +107,36 @@ public boolean isShutdown() {\n   public boolean isTerminated() {\n     return _taskExecutor.isTerminated();\n   }\n+\n+  /*\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   */\n+  private static int getTaskThreadPoolSize(HelixManager manager) {\n+    ConfigAccessor configAccessor = manager.getConfigAccessor();\n+    // Check instance config first for thread pool size\n+    InstanceConfig instanceConfig =\n+        configAccessor.getInstanceConfig(manager.getClusterName(), manager.getInstanceName());\n+    if (instanceConfig != null) {", "originalCommit": "dab0a534cef49b6f9512ce338ef3c5276041df7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk4ODQ2NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r416988465", "bodyText": "For InstanceConfig it's actually valid to get null. When an instance is set up for the first time it's not going to have InstanceConfig when this code is executed, so an exception is not very appropriate because that situation is actually correct.\nI do think the ClusterConfig should have been there, but I still think an exception may be too strong.", "author": "NealSun96", "createdAt": "2020-04-28T23:40:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTY4ODA1OQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r419688059", "bodyText": "I am okay with returning the default size because creating a thread pool with a default size won't be the end of the world and won't affect the user too much. And the user can always try to set it again or restart if they want to change the thread pool size.\nBut we should make it clear to the user. I don't see any log or notification here, so that could be a problem.", "author": "narendly", "createdAt": "2020-05-04T19:52:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxMDc3MQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r419710771", "bodyText": "So the context has changed, and what I said earlier is no longer valid. Please take a look if you want to further this discussion:\n\nThread pool creation is now after HelixManager connection, which means InstanceConfig and ClusterConfig are expected to exist. It should be treated as an error if they don't exist.\nI verified with test cases and believe that an earlier comment made by @narendly is incorrect: if InstanceConfig or ClusterConfig doesn't exist, getInstanceConfig()/getClusterConfig() will throw an HelixException because isInstanceSetup()/isClusterSetup() will fail.\n\nHere are the implications of these two points:\nWith the current design as shown here, if InstanceConfig/ClusterConfig doesn't exist, the attempt to create a thread pool will result an HelixException. I believe it's fine to not catch the exception and let it propagate up, because if InstanceConfig/ClusterConfig doesn't exist, it's an erroneous state. This aligns with what @jiajunwang is saying, and is the current design as we see it.\nAlternatively, we can catch the HelixException, log it, and use the default value (this is @narendly 's idea).\nI'm leaning towards the current design (let HelixException propagate upwards if configs don't exist). Anyone has a different opinion?", "author": "NealSun96", "createdAt": "2020-05-04T20:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTEzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI0Njk0Mw==", "url": "https://github.com/apache/helix/pull/973#discussion_r420246943", "bodyText": "Additionally, we are also updating LiveInstance, which I'm giving the same treatment. Read: if InstanceConfig, ClusterConfig, LiveInstance don't exist, the TaskStateModelFactory will not handle the exception and will let the process fail, because they should exist. I believe if they don't exist, somewhere else will also fail on participant side.\nI'm open to your suggestions, what do you think? @jiajunwang @narendly", "author": "NealSun96", "createdAt": "2020-05-05T16:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NTEzNQ=="}], "type": "inlineReview"}, {"oid": "2c4e7876574a8f13a44f9b37228d0e345dc07e2e", "url": "https://github.com/apache/helix/commit/2c4e7876574a8f13a44f9b37228d0e345dc07e2e", "message": "Unit tests and lazy initialization of thread pool", "committedDate": "2020-05-02T00:24:32Z", "type": "commit"}, {"oid": "7800465c5ba4597ba95ceda7a4e1847f37d428b8", "url": "https://github.com/apache/helix/commit/7800465c5ba4597ba95ceda7a4e1847f37d428b8", "message": "Add unit tests for ClusterConfig/InstanceConfig", "committedDate": "2020-05-04T21:23:29Z", "type": "commit"}, {"oid": "8bbba63ffa2b44c5b5b7a4e9b6c9a8c8ccad606a", "url": "https://github.com/apache/helix/commit/8bbba63ffa2b44c5b5b7a4e9b6c9a8c8ccad606a", "message": "Add LiveInstance update", "committedDate": "2020-05-05T16:31:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI0ODM5OA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420248398", "bodyText": "We talked about this in an early meeting, how we want to not let users to use this constructor, therefore I added this comment.\nHowever, I realized that with this constructor, we actually cannot set CURRENT_TASK_THREAD_POOL_SIZE, because we can't get the pool size. I'm now more inclined to disable this constructor altogether. @jiajunwang @narendly", "author": "NealSun96", "createdAt": "2020-05-05T16:37:13Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -41,23 +47,15 @@\n \n   private final HelixManager _manager;\n   private final Map<String, TaskFactory> _taskFactoryRegistry;\n-  private final ScheduledExecutorService _taskExecutor;\n+  private ScheduledExecutorService _taskExecutor;\n   private final ScheduledExecutorService _timerTaskExecutor;\n   private ThreadPoolExecutorMonitor _monitor;\n-  public final static int TASK_THREADPOOL_SIZE = 40;\n \n   public TaskStateModelFactory(HelixManager manager, Map<String, TaskFactory> taskFactoryRegistry) {\n-    this(manager, taskFactoryRegistry,\n-        Executors.newScheduledThreadPool(TASK_THREADPOOL_SIZE, new ThreadFactory() {\n-          private AtomicInteger threadId = new AtomicInteger(0);\n-\n-          @Override\n-          public Thread newThread(Runnable r) {\n-            return new Thread(r, \"TaskStateModelFactory-task_thread-\" + threadId.getAndIncrement());\n-          }\n-        }));\n+    this(manager, taskFactoryRegistry, null);\n   }\n \n+  // This constructor is only for internal usage. Do not use!", "originalCommit": "8bbba63ffa2b44c5b5b7a4e9b6c9a8c8ccad606a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI3ODMzMg==", "url": "https://github.com/apache/helix/pull/973#discussion_r420278332", "bodyText": "Apache license?", "author": "huizhilu", "createdAt": "2020-05-05T17:21:42Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestTaskStateModelFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+package org.apache.helix.task;\n+", "originalCommit": "8bbba63ffa2b44c5b5b7a4e9b6c9a8c8ccad606a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4OTU5OQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420289599", "bodyText": "Not sure what happened there... Added it. Thanks for catching it!", "author": "NealSun96", "createdAt": "2020-05-05T17:39:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI3ODMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI3OTY3OQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420279679", "bodyText": "I see 2 not set constants. Did you consider using one common constant and putting it in the constants class?", "author": "huizhilu", "createdAt": "2020-05-05T17:23:47Z", "path": "helix-core/src/main/java/org/apache/helix/model/LiveInstance.java", "diffHunk": "@@ -48,6 +49,7 @@\n     TASK_EXEC_THREAD\n   }\n \n+  public static final int CURRENT_TASK_THREAD_POOL_SIZE_NOT_SET = -1;", "originalCommit": "8bbba63ffa2b44c5b5b7a4e9b6c9a8c8ccad606a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI4ODExNA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420288114", "bodyText": "in addition to what Huizhi said, shall we make it 40 for backward compatibility?", "author": "jiajunwang", "createdAt": "2020-05-05T17:37:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI3OTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5MDEyNA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420290124", "bodyText": "These values all have different meanings (see one discussion above). Also, since they are all used only in one place (LiveInstance, ClusterConfig, InstanceConfig), they should stay in the scope.", "author": "NealSun96", "createdAt": "2020-05-05T17:40:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI3OTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM1NjE2Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r420356162", "bodyText": "@jiajunwang This is an interesting point, but wouldn't it be dangerous to use a default value like 40? If the actual thread pool is 20 and the write to LiveInstance fails, then the controller will be looking at an exaggerated number.", "author": "NealSun96", "createdAt": "2020-05-05T19:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI3OTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM1NzcyMA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420357720", "bodyText": "What I meant here is actully since you have a default value anyway. There should not be a case we want the CURRENT_TASK_THREAD_POOL_SIZE_NOT_SET defined. We just always return 40 if no additional configuration is given.", "author": "jiajunwang", "createdAt": "2020-05-05T19:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI3OTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMzIzMg==", "url": "https://github.com/apache/helix/pull/973#discussion_r420433232", "bodyText": "This field is not necessary.", "author": "narendly", "createdAt": "2020-05-05T22:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI3OTY3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2Mzk0MA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420963940", "bodyText": "If there is ever a case where CURRENT_TASK_THREAD_POOL_SIZE is not set, I don't think the controller should proceed. But @narendly raised a good point offline - it could be an old participant that doesn't have this field. I'm using the default 40 instead as there's no better options in that case. Thank you all for the input.", "author": "NealSun96", "createdAt": "2020-05-06T17:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI3OTY3OQ=="}], "type": "inlineReview"}, {"oid": "0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "url": "https://github.com/apache/helix/commit/0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "message": "Apache license", "committedDate": "2020-05-05T17:39:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NDkxOA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420294918", "bodyText": "To be safe, add a sync control on this block. There is no guarantee we won't call createNewStateModel in parallel in the future.\nAnd better to put all the logics inside the initializeTaskExecutor().", "author": "jiajunwang", "createdAt": "2020-05-05T17:48:20Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -81,6 +79,12 @@ public Thread newThread(Runnable r) {\n \n   @Override\n   public TaskStateModel createNewStateModel(String resourceName, String partitionKey) {\n+    if (_taskExecutor == null) {", "originalCommit": "8bbba63ffa2b44c5b5b7a4e9b6c9a8c8ccad606a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwODAwMQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420308001", "bodyText": "Agreed on the sync part.\nWhy do we need all logic inside initializeTaskExecutor()?", "author": "NealSun96", "createdAt": "2020-05-05T18:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMwOTA1Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r420309052", "bodyText": "Do you have a scenario that you need to call these methods separately? Put each line of code in separate methods are not efficient. Please try to balance the code.", "author": "jiajunwang", "createdAt": "2020-05-05T18:11:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMzNzk2Mw==", "url": "https://github.com/apache/helix/pull/973#discussion_r420337963", "bodyText": "By separating the code into multiple functions based on its purpose, I made it easier to understand. If I combine them, I either name the function initializeTaskExecutorAndTaskMonitorAndUpdateLiveInstance() or I force developers to read the code with no clue from the function titles. I'm sure it was clear for you to take a glance and understand what this block is doing because the function names explain them.\nThis is a nit, so I don't have that strong of an opinion, but I believe it is correct to break down code into logical groups. To answer your question, \"do you have a scenario that you need to call these methods separately?\", the answer is yes. I could be utilizing initializeTaskMonitor() separately in the other constructor; I'm not doing it because I think that constructor should be gone (see conversation above).", "author": "NealSun96", "createdAt": "2020-05-05T19:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDM2NDI1Mw==", "url": "https://github.com/apache/helix/pull/973#discussion_r420364253", "bodyText": "It depends, to me the whole init logic is one logical group.\n\neach method is small jumping between these methods to read the code is not comfortable.\nDo you have a scenario that you need to call these methods separately? Or how you support the statement that they are different logical groups?\nThe method name does not need to contain all the logics inside. I don't quite get this point.", "author": "jiajunwang", "createdAt": "2020-05-05T19:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NDkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk2NjY3Mw==", "url": "https://github.com/apache/helix/pull/973#discussion_r420966673", "bodyText": "With the recent changes, initializeTaskMonitor() is called by both constructors so it makes sense for it to be factored out. I'm not entirely convinced that it's correct to put all logic in one function - I always thought it's a good practice to break functions down when necessary into logical chunks to avoid big messy functions.\nSince this section of code is outdated, we can discuss in the new conversation if necessary.", "author": "NealSun96", "createdAt": "2020-05-06T17:30:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NDkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjI1OQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420296259", "bodyText": "Curious about this design.\nThe createNewStateModel() is called when we have partition assigned, right? But I think the controller needs to know the pool size before assign the tasks. How it works?", "author": "jiajunwang", "createdAt": "2020-05-05T17:50:23Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -81,6 +79,12 @@ public Thread newThread(Runnable r) {\n \n   @Override\n   public TaskStateModel createNewStateModel(String resourceName, String partitionKey) {\n+    if (_taskExecutor == null) {\n+      int taskThreadPoolSize = getTaskThreadPoolSize();\n+      updateLiveInstanceWithThreadPoolSize(taskThreadPoolSize);", "originalCommit": "8bbba63ffa2b44c5b5b7a4e9b6c9a8c8ccad606a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxMzk2Ng==", "url": "https://github.com/apache/helix/pull/973#discussion_r420313966", "bodyText": "Answering \"why lazy initialization\" question here as well:\nWhen TaskStateModelFactory is initialized, it is usually during factory registration. However, factory registration can occur before HelixManager connection, or after. When it occurs before HelixManager connection, TaskStateModelFactory actually cannot access the configs, therefore it cannot create the thread pool before manager connection.\nWe have 2 ways to make it work: 1. we enforce TaskStateModelFactory initialization to be after HelixManager connection, 2. we lazily initialize the thread pool. I chose 2 because it is backward compatible - clients don't need to change their existing code in which they registered TaskStateModelFactory before HelixManager connection (which exists).\nIn terms of createNewStateModel(), it is called during message handling when the state model of the message doesn't exist for the resource name and partition key. From the code I read, I don't think \"the controller needs to know the pool size before assign the tasks\", because as we can see from the original code of this class, the task thread pool is never exposed anywhere other than createNewStateModel(). In fact, it's not used anywhere other than createNewStateModel() either, therefore making it safe to initialize in this function.\nFeel free to correct me. @jiajunwang", "author": "NealSun96", "createdAt": "2020-05-05T18:19:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMyNTE5Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r420325192", "bodyText": "why we have to relies on the HelixManager to query for the config? You can use data accessor whenever it is requried. But if we don't even have the cluster/zk information, then it is not possible. This is one of the cons (or limitations) that we rely on ZK to pass the configuration.\nThe controller needs to know the real capacity otherwise how it ensures the assigned tasks fit the instance's capacity? I think this is the purpose of this design, no?\nAlternatively, you can report the accepted capacity without really applying it to any executor. I mean, when liveinstance is created, put the capacity there. But at that moment, there is no real executor exists. Then when we create the executor, we apply for exactly the same number there.\nTo be clear, this is not a preferred design. In this way, the CURRENT_THREAD_POOL_SIZE becomes meaningless. But that is the only thing I can think of now.", "author": "jiajunwang", "createdAt": "2020-05-05T18:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMyODQzNg==", "url": "https://github.com/apache/helix/pull/973#discussion_r420328436", "bodyText": "Reading your later comment, I think I know what you mean by \"controller needs to know the pool size\". Let me think about this.", "author": "NealSun96", "createdAt": "2020-05-05T18:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk3MTgyNw==", "url": "https://github.com/apache/helix/pull/973#discussion_r420971827", "bodyText": "Resolved offline, thank you @jiajunwang!", "author": "NealSun96", "createdAt": "2020-05-06T17:39:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjY1Mw==", "url": "https://github.com/apache/helix/pull/973#discussion_r420296653", "bodyText": "As mentioned below, I don't think we like lazy initialize the executor. Any reason for this change?", "author": "jiajunwang", "createdAt": "2020-05-05T17:51:05Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -41,23 +47,15 @@\n \n   private final HelixManager _manager;\n   private final Map<String, TaskFactory> _taskFactoryRegistry;\n-  private final ScheduledExecutorService _taskExecutor;\n+  private ScheduledExecutorService _taskExecutor;\n   private final ScheduledExecutorService _timerTaskExecutor;\n   private ThreadPoolExecutorMonitor _monitor;\n-  public final static int TASK_THREADPOOL_SIZE = 40;\n \n   public TaskStateModelFactory(HelixManager manager, Map<String, TaskFactory> taskFactoryRegistry) {\n-    this(manager, taskFactoryRegistry,\n-        Executors.newScheduledThreadPool(TASK_THREADPOOL_SIZE, new ThreadFactory() {\n-          private AtomicInteger threadId = new AtomicInteger(0);\n-\n-          @Override\n-          public Thread newThread(Runnable r) {\n-            return new Thread(r, \"TaskStateModelFactory-task_thread-\" + threadId.getAndIncrement());\n-          }\n-        }));\n+    this(manager, taskFactoryRegistry, null);", "originalCommit": "8bbba63ffa2b44c5b5b7a4e9b6c9a8c8ccad606a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMxNDA3MQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420314071", "bodyText": "Combined with the previous comment.", "author": "NealSun96", "createdAt": "2020-05-05T18:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NjY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5NzUxNQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420297515", "bodyText": "You are also excluding 0. Let's make the comment clear and fitting the code.", "author": "jiajunwang", "createdAt": "2020-05-05T17:52:32Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -102,4 +106,73 @@ public boolean isShutdown() {\n   public boolean isTerminated() {\n     return _taskExecutor.isTerminated();\n   }\n+\n+  /*\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   */\n+  private int getTaskThreadPoolSize() {\n+    ConfigAccessor configAccessor = _manager.getConfigAccessor();\n+    // Check instance config first for thread pool size\n+    InstanceConfig instanceConfig =\n+        configAccessor.getInstanceConfig(_manager.getClusterName(), _manager.getInstanceName());\n+    if (instanceConfig != null) {\n+      int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+      if (verifyTargetThreadPoolSize(targetTaskThreadPoolSize)) {\n+        return targetTaskThreadPoolSize;\n+      }\n+    }\n+\n+    // Fallback to cluster config since instance config doesn't provide the value\n+    ClusterConfig clusterConfig = configAccessor.getClusterConfig(_manager.getClusterName());\n+    if (clusterConfig != null) {\n+      int targetTaskThreadPoolSize = clusterConfig.getDefaultTargetTaskThreadPoolSize();\n+      if (verifyTargetThreadPoolSize(targetTaskThreadPoolSize)) {\n+        return targetTaskThreadPoolSize;\n+      }\n+    }\n+\n+    return TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE;\n+  }\n+\n+  /*\n+   * Checks against the default values of -1 when pool sizes are not defined; we don't want -1's", "originalCommit": "8bbba63ffa2b44c5b5b7a4e9b6c9a8c8ccad606a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5ODQwNA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420298404", "bodyText": "Instead of updating after the live node created, we shall ensure it is included when the node is created the first time. Or we may have some serious issue that the controller violates the capacity limitation.", "author": "jiajunwang", "createdAt": "2020-05-05T17:53:51Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -102,4 +106,73 @@ public boolean isShutdown() {\n   public boolean isTerminated() {\n     return _taskExecutor.isTerminated();\n   }\n+\n+  /*\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   */\n+  private int getTaskThreadPoolSize() {\n+    ConfigAccessor configAccessor = _manager.getConfigAccessor();\n+    // Check instance config first for thread pool size\n+    InstanceConfig instanceConfig =\n+        configAccessor.getInstanceConfig(_manager.getClusterName(), _manager.getInstanceName());\n+    if (instanceConfig != null) {\n+      int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+      if (verifyTargetThreadPoolSize(targetTaskThreadPoolSize)) {\n+        return targetTaskThreadPoolSize;\n+      }\n+    }\n+\n+    // Fallback to cluster config since instance config doesn't provide the value\n+    ClusterConfig clusterConfig = configAccessor.getClusterConfig(_manager.getClusterName());\n+    if (clusterConfig != null) {\n+      int targetTaskThreadPoolSize = clusterConfig.getDefaultTargetTaskThreadPoolSize();\n+      if (verifyTargetThreadPoolSize(targetTaskThreadPoolSize)) {\n+        return targetTaskThreadPoolSize;\n+      }\n+    }\n+\n+    return TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE;\n+  }\n+\n+  /*\n+   * Checks against the default values of -1 when pool sizes are not defined; we don't want -1's\n+   */\n+  private static boolean verifyTargetThreadPoolSize(int targetTaskThreadPoolSize) {\n+    return targetTaskThreadPoolSize > 0;\n+  }\n+\n+  /*\n+   * Update LiveInstance with the current used thread pool size\n+   */\n+  private void updateLiveInstanceWithThreadPoolSize(int taskThreadPoolSize) {", "originalCommit": "8bbba63ffa2b44c5b5b7a4e9b6c9a8c8ccad606a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDMyMTA1NA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420321054", "bodyText": "This is a good point. Let me think about this.", "author": "NealSun96", "createdAt": "2020-05-05T18:31:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDI5ODQwNA=="}], "type": "inlineReview"}, {"oid": "80989ebe45b60f1a0ef4233ae385ce1d10b5f977", "url": "https://github.com/apache/helix/commit/80989ebe45b60f1a0ef4233ae385ce1d10b5f977", "message": "Comment changes", "committedDate": "2020-05-05T22:11:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyODc1NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420428755", "bodyText": "I find myself repeating this again, why does this field need to be public?", "author": "narendly", "createdAt": "2020-05-05T21:52:24Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -137,6 +141,7 @@\n   private final static int MAX_REBALANCE_PREFERENCE = 10;\n   private final static int MIN_REBALANCE_PREFERENCE = 0;\n   public final static boolean DEFAULT_GLOBAL_REBALANCE_ASYNC_MODE_ENABLED = true;\n+  public static final int DEFAULT_TARGET_TASK_THREAD_POOL_SIZE_NOT_SET = -1;", "originalCommit": "0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQyOTQ3MQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420429471", "bodyText": "We're confusing terminology here. Let's please try to be exact:\nWhat you want here is the global target task thread pool size, not default.\nThe \"default\" value refers to 40. It's okay to use the NOT_SET bit and resort to 40 at initialization time.", "author": "narendly", "createdAt": "2020-05-05T21:54:01Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -709,6 +714,32 @@ public void setInstanceCapacityKeys(List<String> capacityKeys) {\n     _record.setListField(ClusterConfigProperty.INSTANCE_CAPACITY_KEYS.name(), capacityKeys);\n   }\n \n+  /**\n+   * Get the default target size of task thread pools. This values applies to participants and is\n+   * overwritten by participants' own values if they specified individual pool sizes in\n+   * InstanceConfigs\n+   * @return the target size of task thread pool\n+   */\n+  public int getDefaultTargetTaskThreadPoolSize() {\n+    return _record.getIntField(\n+        ClusterConfig.ClusterConfigProperty.DEFAULT_TARGET_TASK_THREAD_POOL_SIZE.name(),", "originalCommit": "0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMDE5OA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420430198", "bodyText": "Fix the name.", "author": "narendly", "createdAt": "2020-05-05T21:55:35Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -709,6 +714,32 @@ public void setInstanceCapacityKeys(List<String> capacityKeys) {\n     _record.setListField(ClusterConfigProperty.INSTANCE_CAPACITY_KEYS.name(), capacityKeys);\n   }\n \n+  /**\n+   * Get the default target size of task thread pools. This values applies to participants and is\n+   * overwritten by participants' own values if they specified individual pool sizes in\n+   * InstanceConfigs\n+   * @return the target size of task thread pool\n+   */\n+  public int getDefaultTargetTaskThreadPoolSize() {\n+    return _record.getIntField(\n+        ClusterConfig.ClusterConfigProperty.DEFAULT_TARGET_TASK_THREAD_POOL_SIZE.name(),\n+        DEFAULT_TARGET_TASK_THREAD_POOL_SIZE_NOT_SET);\n+  }\n+\n+  /**\n+   * Set the default target size of task thread pools for this cluster.\n+   * @param defaultTargetTaskThreadPoolSize - the new target task thread pool size\n+   * @throws IllegalArgumentException - when the provided new thread pool size is not greater than 0\n+   */\n+  public void setDefaultTargetTaskThreadPoolSize(int defaultTargetTaskThreadPoolSize)", "originalCommit": "0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMDQ0NA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420430444", "bodyText": "Not default, but global value. The default value for the global config should be 40.", "author": "narendly", "createdAt": "2020-05-05T21:55:59Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -709,6 +714,32 @@ public void setInstanceCapacityKeys(List<String> capacityKeys) {\n     _record.setListField(ClusterConfigProperty.INSTANCE_CAPACITY_KEYS.name(), capacityKeys);\n   }\n \n+  /**\n+   * Get the default target size of task thread pools. This values applies to participants and is\n+   * overwritten by participants' own values if they specified individual pool sizes in\n+   * InstanceConfigs\n+   * @return the target size of task thread pool\n+   */\n+  public int getDefaultTargetTaskThreadPoolSize() {\n+    return _record.getIntField(\n+        ClusterConfig.ClusterConfigProperty.DEFAULT_TARGET_TASK_THREAD_POOL_SIZE.name(),\n+        DEFAULT_TARGET_TASK_THREAD_POOL_SIZE_NOT_SET);\n+  }\n+\n+  /**\n+   * Set the default target size of task thread pools for this cluster.", "originalCommit": "0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMTAxMQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420431011", "bodyText": "Fix the message.", "author": "narendly", "createdAt": "2020-05-05T21:57:09Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -709,6 +714,32 @@ public void setInstanceCapacityKeys(List<String> capacityKeys) {\n     _record.setListField(ClusterConfigProperty.INSTANCE_CAPACITY_KEYS.name(), capacityKeys);\n   }\n \n+  /**\n+   * Get the default target size of task thread pools. This values applies to participants and is\n+   * overwritten by participants' own values if they specified individual pool sizes in\n+   * InstanceConfigs\n+   * @return the target size of task thread pool\n+   */\n+  public int getDefaultTargetTaskThreadPoolSize() {\n+    return _record.getIntField(\n+        ClusterConfig.ClusterConfigProperty.DEFAULT_TARGET_TASK_THREAD_POOL_SIZE.name(),\n+        DEFAULT_TARGET_TASK_THREAD_POOL_SIZE_NOT_SET);\n+  }\n+\n+  /**\n+   * Set the default target size of task thread pools for this cluster.\n+   * @param defaultTargetTaskThreadPoolSize - the new target task thread pool size\n+   * @throws IllegalArgumentException - when the provided new thread pool size is not greater than 0\n+   */\n+  public void setDefaultTargetTaskThreadPoolSize(int defaultTargetTaskThreadPoolSize)\n+      throws IllegalArgumentException {\n+    if (defaultTargetTaskThreadPoolSize <= 0) {\n+      throw new IllegalArgumentException(\"targetTaskThreadPoolSize must be greater than 0!\");", "originalCommit": "0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMTU2Ng==", "url": "https://github.com/apache/helix/pull/973#discussion_r420431566", "bodyText": "Nit: fix the comment (space)", "author": "narendly", "createdAt": "2020-05-05T21:58:26Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -109,7 +109,11 @@\n     // https://github.com/apache/helix/wiki/Weight-aware-Globally-Evenly-distributed-Rebalancer#rebalance-coordinator\n     //\n     // Default to be true.\n-    GLOBAL_REBALANCE_ASYNC_MODE\n+    GLOBAL_REBALANCE_ASYNC_MODE,\n+\n+    // The target size of task thread pools for each participant. This is the \"default\" value\n+    //that's used when participants don't specify their individual pool sizes.", "originalCommit": "0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMTcwMA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420431700", "bodyText": "\"global\" value to the cluster", "author": "narendly", "createdAt": "2020-05-05T21:58:44Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -109,7 +109,11 @@\n     // https://github.com/apache/helix/wiki/Weight-aware-Globally-Evenly-distributed-Rebalancer#rebalance-coordinator\n     //\n     // Default to be true.\n-    GLOBAL_REBALANCE_ASYNC_MODE\n+    GLOBAL_REBALANCE_ASYNC_MODE,\n+\n+    // The target size of task thread pools for each participant. This is the \"default\" value", "originalCommit": "0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMjkyNA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420432924", "bodyText": "private?", "author": "narendly", "createdAt": "2020-05-05T22:01:27Z", "path": "helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java", "diffHunk": "@@ -56,11 +56,13 @@\n     DOMAIN,\n     DELAY_REBALANCE_ENABLED,\n     MAX_CONCURRENT_TASK,\n-    INSTANCE_CAPACITY_MAP\n+    INSTANCE_CAPACITY_MAP,\n+    TARGET_TASK_THREAD_POOL_SIZE\n   }\n \n   public static final int WEIGHT_NOT_SET = -1;\n   public static final int MAX_CONCURRENT_TASK_NOT_SET = -1;\n+  public static final int TARGET_TASK_THREAD_POOL_SIZE_NOT_SET = -1;", "originalCommit": "0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzNDIxOQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420434219", "bodyText": "Please try to understand the proposed design thoroughly.\nFor example, what does it mean for an instance to have a task thread pool of size -1? (it is meaningless, we shouldn't create a task pool with size -1).", "author": "narendly", "createdAt": "2020-05-05T22:04:37Z", "path": "helix-core/src/main/java/org/apache/helix/model/LiveInstance.java", "diffHunk": "@@ -190,6 +192,24 @@ public void setWebserviceUrl(String url) {\n     _record.setSimpleField(LiveInstanceProperty.ZKPROPERTYTRANSFERURL.toString(), url);\n   }\n \n+  /**\n+   * Get the current task thread pool size of the instance\n+   * @return the current task thread pool size\n+   */\n+  public int getCurrentTaskThreadPoolSize() {\n+    return _record.getIntField(LiveInstanceProperty.CURRENT_TASK_THREAD_POOL_SIZE.name(),\n+        CURRENT_TASK_THREAD_POOL_SIZE_NOT_SET);", "originalCommit": "0bfb594f3647ee06be90b0fe86ed56a1c349c0d6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk3NTQ4NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r420975485", "bodyText": "Discussed offline: this is meant to be a bit signaling an error, because field should always be set. But it's true that old participants don't have this field. I'm using the default 40 instead as there's no better options in that case. Thank you.", "author": "NealSun96", "createdAt": "2020-05-06T17:44:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzNDIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NjAxOA==", "url": "https://github.com/apache/helix/pull/973#discussion_r420466018", "bodyText": "Update:\nNeal and I had an offline discussion. To simplify the design, we will create a temporary ZK connection to read the task pool size configs and close right away. This would greatly simplify the code and this won't be that much of a burden since the connection is closed right away.\nThis is to populate the current task size pool at the time of LiveInstance (ephemeral node) initialization.\n@NealSun96 Please remember to put a TODO here to potentially revisit the logic - ideally, we shouldn't have to create multiple ZK client connections when there already is a manager there.", "author": "narendly", "createdAt": "2020-05-05T23:25:41Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -41,23 +47,15 @@\n \n   private final HelixManager _manager;\n   private final Map<String, TaskFactory> _taskFactoryRegistry;\n-  private final ScheduledExecutorService _taskExecutor;\n+  private ScheduledExecutorService _taskExecutor;", "originalCommit": "80989ebe45b60f1a0ef4233ae385ce1d10b5f977", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5MzczNg==", "url": "https://github.com/apache/helix/pull/973#discussion_r420993736", "bodyText": "Fyi @jiajunwang", "author": "NealSun96", "createdAt": "2020-05-06T18:13:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2NjAxOA=="}], "type": "inlineReview"}, {"oid": "a4bc7d86c4b7b3838557a086664e8459395aa7fd", "url": "https://github.com/apache/helix/commit/a4bc7d86c4b7b3838557a086664e8459395aa7fd", "message": "LiveInstance related changes", "committedDate": "2020-05-06T18:00:20Z", "type": "commit"}, {"oid": "315af87330177b112dea8fb24c5254c540b137c2", "url": "https://github.com/apache/helix/commit/315af87330177b112dea8fb24c5254c540b137c2", "message": "Quick small fixups", "committedDate": "2020-05-06T18:09:53Z", "type": "commit"}, {"oid": "1b723e0c00de5f7f2f6a33cbc3468970fb64a453", "url": "https://github.com/apache/helix/commit/1b723e0c00de5f7f2f6a33cbc3468970fb64a453", "message": "Fix broken tests", "committedDate": "2020-05-06T21:56:10Z", "type": "commit"}, {"oid": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "url": "https://github.com/apache/helix/commit/8ae50c1841cde6b68854fdff41d6092d9081a7f9", "message": "Fix routing data conflict", "committedDate": "2020-05-08T22:25:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTE2NA==", "url": "https://github.com/apache/helix/pull/973#discussion_r422451164", "bodyText": "Let's clarify which config takes precedence and also what would it mean to not have this field defined.\nFor example, consider the following:\n\nwhat if an instance has a target value set in InstanceConfig and there is a global thread pool size config set as well?\nwhat if there's nothing set at all? which value will this use?\netc..", "author": "narendly", "createdAt": "2020-05-09T04:20:52Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -109,7 +109,11 @@\n     // https://github.com/apache/helix/wiki/Weight-aware-Globally-Evenly-distributed-Rebalancer#rebalance-coordinator\n     //\n     // Default to be true.\n-    GLOBAL_REBALANCE_ASYNC_MODE\n+    GLOBAL_REBALANCE_ASYNC_MODE,\n+\n+    // The target size of task thread pools for each participant. This is the global value\n+    // that's used when participants don't specify their individual pool sizes.", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTE5NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r422451195", "bodyText": "What if this value is not set?", "author": "narendly", "createdAt": "2020-05-09T04:21:17Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -709,6 +714,33 @@ public void setInstanceCapacityKeys(List<String> capacityKeys) {\n     _record.setListField(ClusterConfigProperty.INSTANCE_CAPACITY_KEYS.name(), capacityKeys);\n   }\n \n+  /**\n+   * Get the global target size of task thread pools. This values applies to participants and is\n+   * overwritten by participants' own values if they specified individual pool sizes in\n+   * InstanceConfigs", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTMxNw==", "url": "https://github.com/apache/helix/pull/973#discussion_r422451317", "bodyText": "Technically, I think the value 0 is also valid. It just wouldn't process any tasks. What do you think?\nI think that we might be able to use this config as a workaround to \"disable\" task framework globally, or only have certain participants process tasks - say, global is 0, but certain participants will have their individual configs set.", "author": "narendly", "createdAt": "2020-05-09T04:23:26Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -709,6 +714,33 @@ public void setInstanceCapacityKeys(List<String> capacityKeys) {\n     _record.setListField(ClusterConfigProperty.INSTANCE_CAPACITY_KEYS.name(), capacityKeys);\n   }\n \n+  /**\n+   * Get the global target size of task thread pools. This values applies to participants and is\n+   * overwritten by participants' own values if they specified individual pool sizes in\n+   * InstanceConfigs\n+   * @return the global target size of task thread pool\n+   */\n+  public int getGlobalTargetTaskThreadPoolSize() {\n+    return _record\n+        .getIntField(ClusterConfig.ClusterConfigProperty.GLOBAL_TARGET_TASK_THREAD_POOL_SIZE.name(),\n+            GLOBAL_TARGET_TASK_THREAD_POOL_SIZE_NOT_SET);\n+  }\n+\n+  /**\n+   * Set the global target size of task thread pools for this cluster.\n+   * @param globalTargetTaskThreadPoolSize - the new global target task thread pool size\n+   * @throws IllegalArgumentException - when the provided new thread pool size is not greater than 0\n+   */\n+  public void setGlobalTargetTaskThreadPoolSize(int globalTargetTaskThreadPoolSize)\n+      throws IllegalArgumentException {\n+    if (globalTargetTaskThreadPoolSize <= 0) {\n+      throw new IllegalArgumentException(\"globalTargetTaskThreadPoolSize must be greater than 0!\");\n+    }", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MTI1Mw==", "url": "https://github.com/apache/helix/pull/973#discussion_r423171253", "bodyText": "I was thinking that negative values and 0 both produce unusable thread pools. But your second point is convincing - this is a legitimate use.", "author": "NealSun96", "createdAt": "2020-05-11T16:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTQ3OA==", "url": "https://github.com/apache/helix/pull/973#discussion_r422451478", "bodyText": "Good description! :)", "author": "narendly", "createdAt": "2020-05-09T04:26:00Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskConstants.java", "diffHunk": "@@ -49,4 +49,11 @@\n   public static final String PREV_RA_NODE = \"PreviousResourceAssignment\";\n \n   public static final boolean DEFAULT_TASK_ENABLE_COMPRESSION = false;\n+\n+  /**\n+   * The default task thread pool size that will be used to create thread pools if target thread\n+   * pool sizes are not defined in InstanceConfig or ClusterConfig; also used as the current thread\n+   * pool size default value if the current thread pool size is not defined in LiveInstance", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTU1MQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r422451551", "bodyText": "Let's also add that we want to avoid using this because Task Framework needs to have full control of the thread pool unlike the state transition thread pool.", "author": "narendly", "createdAt": "2020-05-09T04:27:33Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -44,39 +48,29 @@\n   private final ScheduledExecutorService _taskExecutor;\n   private final ScheduledExecutorService _timerTaskExecutor;\n   private ThreadPoolExecutorMonitor _monitor;\n-  public final static int TASK_THREADPOOL_SIZE = 40;\n \n   public TaskStateModelFactory(HelixManager manager, Map<String, TaskFactory> taskFactoryRegistry) {\n-    this(manager, taskFactoryRegistry,\n-        Executors.newScheduledThreadPool(TASK_THREADPOOL_SIZE, new ThreadFactory() {\n-          private AtomicInteger threadId = new AtomicInteger(0);\n-\n-          @Override\n-          public Thread newThread(Runnable r) {\n-            return new Thread(r, \"TaskStateModelFactory-task_thread-\" + threadId.getAndIncrement());\n-          }\n-        }));\n+    _manager = manager;\n+    _taskFactoryRegistry = taskFactoryRegistry;\n+    // TODO: revisit the logic here; we are creating a connection although we already have a manager\n+    ConfigAccessor configAccessor = createConfigAccessor();\n+    int threadPoolSize = TaskUtil.getTargetThreadPoolSize(configAccessor, _manager.getClusterName(),\n+        _manager.getInstanceName());\n+    configAccessor.close();\n+    _taskExecutor = createTaskExecutor(threadPoolSize);\n+    _timerTaskExecutor = createTimerTaskExecutor();\n+    initializeTaskMonitor();\n   }\n \n+  // FIXME: DO NOT USE! This size of provided thread pool will not be reflected to controller\n+  // properly, the controller may over schedule tasks to this participant.", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTY5Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r422451692", "bodyText": "It would be a good idea to give more context:\nThis is only so because we don't enforce the order in which the manager should be connected. Some users register a taskFactoryRegistry before connecting the manager, others do so after. Either works. This is only a problem for the former case.\nSo the real TODO is to think about what the right order should be and to determine whether we should enforce this order (which would make it backward incompatible), but arguably cleaner because we then won't have to create an extra ZK connection.", "author": "narendly", "createdAt": "2020-05-09T04:29:48Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -44,39 +48,29 @@\n   private final ScheduledExecutorService _taskExecutor;\n   private final ScheduledExecutorService _timerTaskExecutor;\n   private ThreadPoolExecutorMonitor _monitor;\n-  public final static int TASK_THREADPOOL_SIZE = 40;\n \n   public TaskStateModelFactory(HelixManager manager, Map<String, TaskFactory> taskFactoryRegistry) {\n-    this(manager, taskFactoryRegistry,\n-        Executors.newScheduledThreadPool(TASK_THREADPOOL_SIZE, new ThreadFactory() {\n-          private AtomicInteger threadId = new AtomicInteger(0);\n-\n-          @Override\n-          public Thread newThread(Runnable r) {\n-            return new Thread(r, \"TaskStateModelFactory-task_thread-\" + threadId.getAndIncrement());\n-          }\n-        }));\n+    _manager = manager;\n+    _taskFactoryRegistry = taskFactoryRegistry;\n+    // TODO: revisit the logic here; we are creating a connection although we already have a manager", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTgyNg==", "url": "https://github.com/apache/helix/pull/973#discussion_r422451826", "bodyText": "Cluster name doesn't have a \"/\". So this ternary check is not necessary?", "author": "narendly", "createdAt": "2020-05-09T04:32:25Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -102,4 +96,53 @@ public boolean isShutdown() {\n   public boolean isTerminated() {\n     return _taskExecutor.isTerminated();\n   }\n+\n+  private ScheduledExecutorService createTaskExecutor(int taskThreadPoolSize) {\n+    return Executors.newScheduledThreadPool(taskThreadPoolSize, new ThreadFactory() {\n+      private AtomicInteger threadId = new AtomicInteger(0);\n+\n+      @Override\n+      public Thread newThread(Runnable r) {\n+        return new Thread(r, \"TaskStateModelFactory-task_thread-\" + threadId.getAndIncrement());\n+      }\n+    });\n+  }\n+\n+  private ScheduledExecutorService createTimerTaskExecutor() {\n+    return Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {\n+      @Override\n+      public Thread newThread(Runnable r) {\n+        return new Thread(r, \"TaskStateModelFactory-timeTask_thread\");\n+      }\n+    });\n+  }\n+\n+  private void initializeTaskMonitor() {\n+    if (_taskExecutor instanceof ThreadPoolExecutor) {\n+      try {\n+        _monitor = new ThreadPoolExecutorMonitor(TaskConstants.STATE_MODEL_NAME,\n+            (ThreadPoolExecutor) _taskExecutor);\n+      } catch (JMException e) {\n+        LOG.warn(\"Error in creating ThreadPoolExecutorMonitor for TaskStateModelFactory.\");\n+      }\n+    }\n+  }\n+\n+  /*\n+   * Create a config accessor to get the thread pool size\n+   */\n+  protected ConfigAccessor createConfigAccessor() {\n+    if (Boolean.getBoolean(SystemPropertyKeys.MULTI_ZK_ENABLED)) {\n+      String clusterName = _manager.getClusterName();\n+      String shardingKey = clusterName.charAt(0) == '/' ? clusterName : \"/\" + clusterName;", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3ODg5Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423178892", "bodyText": "In ZkHelixManager, the sharding building is done like this:\n  private String buildShardingKey() {\n    return _clusterName.charAt(0) == '/' ? _clusterName : \"/\" + _clusterName;\n  }\n\nI figured the state model factory should do the same. It doesn't hurt to check anyways.", "author": "NealSun96", "createdAt": "2020-05-11T16:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwMjkzMQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423202931", "bodyText": "Why not make buildShardingKey() a util method? Will we have more and more this kind of code elsewhere?", "author": "jiajunwang", "createdAt": "2020-05-11T17:30:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI2MjQ2MQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423262461", "bodyText": "I was tempted to do it but I don't want to expand this PR with that change - there could always be debates about it, and I want this PR approved fast to unblock other items. If we don't have high urgency for this, can we have this as a later item?", "author": "NealSun96", "createdAt": "2020-05-11T19:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTgyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI5OTY0NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423299645", "bodyText": "Went ahead and did it.", "author": "NealSun96", "createdAt": "2020-05-11T20:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTgyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MTk3NA==", "url": "https://github.com/apache/helix/pull/973#discussion_r422451974", "bodyText": "Should we allow 0?", "author": "narendly", "createdAt": "2020-05-09T04:35:10Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "diffHunk": "@@ -1045,4 +1048,54 @@ private static void setNextJobPurgeTime(String workflow, long currentTime, long\n       rebalanceScheduler.scheduleRebalance(manager, workflow, nextPurgeTime);\n     }\n   }\n+\n+  /**\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   * @param configAccessor - accessor used for the configs\n+   * @param clusterName - the cluster name for InstanceConfig and ClusterConfig\n+   * @param instanceName - the instance name for InstanceConfig\n+   * @return target thread pool size\n+   */\n+  public static int getTargetThreadPoolSize(ConfigAccessor configAccessor, String clusterName,\n+      String instanceName) {\n+    // Check instance config first for thread pool size\n+    try {\n+      InstanceConfig instanceConfig = configAccessor.getInstanceConfig(clusterName, instanceName);\n+      if (instanceConfig != null) {\n+        int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+        if (targetTaskThreadPoolSize > 0) {", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjA0Ng==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452046", "bodyText": "Nit: your last \"Exception: \" is not necessary since you're just providing it as the last parameter. Log4j I think formats it already.", "author": "narendly", "createdAt": "2020-05-09T04:36:13Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "diffHunk": "@@ -1045,4 +1048,54 @@ private static void setNextJobPurgeTime(String workflow, long currentTime, long\n       rebalanceScheduler.scheduleRebalance(manager, workflow, nextPurgeTime);\n     }\n   }\n+\n+  /**\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   * @param configAccessor - accessor used for the configs\n+   * @param clusterName - the cluster name for InstanceConfig and ClusterConfig\n+   * @param instanceName - the instance name for InstanceConfig\n+   * @return target thread pool size\n+   */\n+  public static int getTargetThreadPoolSize(ConfigAccessor configAccessor, String clusterName,\n+      String instanceName) {\n+    // Check instance config first for thread pool size\n+    try {\n+      InstanceConfig instanceConfig = configAccessor.getInstanceConfig(clusterName, instanceName);\n+      if (instanceConfig != null) {\n+        int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+        if (targetTaskThreadPoolSize > 0) {\n+          return targetTaskThreadPoolSize;\n+        }\n+      } else {\n+        LOG.warn(\n+            \"Got null as InstanceConfig for instance {} in cluster {}. Continuing with ClusterConfig. \",\n+            instanceName, clusterName);\n+      }\n+    } catch (HelixException e) {\n+      LOG.warn(", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjA1Ng==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452056", "bodyText": "0?", "author": "narendly", "createdAt": "2020-05-09T04:36:33Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "diffHunk": "@@ -1045,4 +1048,54 @@ private static void setNextJobPurgeTime(String workflow, long currentTime, long\n       rebalanceScheduler.scheduleRebalance(manager, workflow, nextPurgeTime);\n     }\n   }\n+\n+  /**\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   * @param configAccessor - accessor used for the configs\n+   * @param clusterName - the cluster name for InstanceConfig and ClusterConfig\n+   * @param instanceName - the instance name for InstanceConfig\n+   * @return target thread pool size\n+   */\n+  public static int getTargetThreadPoolSize(ConfigAccessor configAccessor, String clusterName,\n+      String instanceName) {\n+    // Check instance config first for thread pool size\n+    try {\n+      InstanceConfig instanceConfig = configAccessor.getInstanceConfig(clusterName, instanceName);\n+      if (instanceConfig != null) {\n+        int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+        if (targetTaskThreadPoolSize > 0) {\n+          return targetTaskThreadPoolSize;\n+        }\n+      } else {\n+        LOG.warn(\n+            \"Got null as InstanceConfig for instance {} in cluster {}. Continuing with ClusterConfig. \",\n+            instanceName, clusterName);\n+      }\n+    } catch (HelixException e) {\n+      LOG.warn(\n+          \"Encountered an exception while fetching InstanceConfig for instance {} in cluster {}. Continuing with ClusterConfig. Exception: \",\n+          instanceName, clusterName, e);\n+    }\n+\n+    // Fallback to cluster config since instance config doesn't provide the value\n+    try {\n+      ClusterConfig clusterConfig = configAccessor.getClusterConfig(clusterName);\n+      if (clusterConfig != null) {\n+        int globalTargetTaskThreadPoolSize = clusterConfig.getGlobalTargetTaskThreadPoolSize();\n+        if (globalTargetTaskThreadPoolSize > 0) {", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjA4Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452082", "bodyText": "It would be nice to include the default size constant here.", "author": "narendly", "createdAt": "2020-05-09T04:37:17Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "diffHunk": "@@ -1045,4 +1048,54 @@ private static void setNextJobPurgeTime(String workflow, long currentTime, long\n       rebalanceScheduler.scheduleRebalance(manager, workflow, nextPurgeTime);\n     }\n   }\n+\n+  /**\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   * @param configAccessor - accessor used for the configs\n+   * @param clusterName - the cluster name for InstanceConfig and ClusterConfig\n+   * @param instanceName - the instance name for InstanceConfig\n+   * @return target thread pool size\n+   */\n+  public static int getTargetThreadPoolSize(ConfigAccessor configAccessor, String clusterName,\n+      String instanceName) {\n+    // Check instance config first for thread pool size\n+    try {\n+      InstanceConfig instanceConfig = configAccessor.getInstanceConfig(clusterName, instanceName);\n+      if (instanceConfig != null) {\n+        int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+        if (targetTaskThreadPoolSize > 0) {\n+          return targetTaskThreadPoolSize;\n+        }\n+      } else {\n+        LOG.warn(\n+            \"Got null as InstanceConfig for instance {} in cluster {}. Continuing with ClusterConfig. \",\n+            instanceName, clusterName);\n+      }\n+    } catch (HelixException e) {\n+      LOG.warn(\n+          \"Encountered an exception while fetching InstanceConfig for instance {} in cluster {}. Continuing with ClusterConfig. Exception: \",\n+          instanceName, clusterName, e);\n+    }\n+\n+    // Fallback to cluster config since instance config doesn't provide the value\n+    try {\n+      ClusterConfig clusterConfig = configAccessor.getClusterConfig(clusterName);\n+      if (clusterConfig != null) {\n+        int globalTargetTaskThreadPoolSize = clusterConfig.getGlobalTargetTaskThreadPoolSize();\n+        if (globalTargetTaskThreadPoolSize > 0) {\n+          return globalTargetTaskThreadPoolSize;\n+        }\n+      } else {\n+        LOG.warn(\"Got null as ClusterConfig for cluster {}. Returning default value. \",", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjExNw==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452117", "bodyText": "TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE", "author": "narendly", "createdAt": "2020-05-09T04:37:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjEwOQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452109", "bodyText": "Say what the default value is, and no need for \"Exception: \".", "author": "narendly", "createdAt": "2020-05-09T04:37:44Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "diffHunk": "@@ -1045,4 +1048,54 @@ private static void setNextJobPurgeTime(String workflow, long currentTime, long\n       rebalanceScheduler.scheduleRebalance(manager, workflow, nextPurgeTime);\n     }\n   }\n+\n+  /**\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   * @param configAccessor - accessor used for the configs\n+   * @param clusterName - the cluster name for InstanceConfig and ClusterConfig\n+   * @param instanceName - the instance name for InstanceConfig\n+   * @return target thread pool size\n+   */\n+  public static int getTargetThreadPoolSize(ConfigAccessor configAccessor, String clusterName,\n+      String instanceName) {\n+    // Check instance config first for thread pool size\n+    try {\n+      InstanceConfig instanceConfig = configAccessor.getInstanceConfig(clusterName, instanceName);\n+      if (instanceConfig != null) {\n+        int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+        if (targetTaskThreadPoolSize > 0) {\n+          return targetTaskThreadPoolSize;\n+        }\n+      } else {\n+        LOG.warn(\n+            \"Got null as InstanceConfig for instance {} in cluster {}. Continuing with ClusterConfig. \",\n+            instanceName, clusterName);\n+      }\n+    } catch (HelixException e) {\n+      LOG.warn(\n+          \"Encountered an exception while fetching InstanceConfig for instance {} in cluster {}. Continuing with ClusterConfig. Exception: \",\n+          instanceName, clusterName, e);\n+    }\n+\n+    // Fallback to cluster config since instance config doesn't provide the value\n+    try {\n+      ClusterConfig clusterConfig = configAccessor.getClusterConfig(clusterName);\n+      if (clusterConfig != null) {\n+        int globalTargetTaskThreadPoolSize = clusterConfig.getGlobalTargetTaskThreadPoolSize();\n+        if (globalTargetTaskThreadPoolSize > 0) {\n+          return globalTargetTaskThreadPoolSize;\n+        }\n+      } else {\n+        LOG.warn(\"Got null as ClusterConfig for cluster {}. Returning default value. \",\n+            clusterName);\n+      }\n+    } catch (HelixException e) {\n+      LOG.warn(\n+          \"Encountered an exception while fetching ClusterConfig in cluster {}. Returning default value. Exception: \",", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjI1NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452255", "bodyText": "Consider adding a TODO here - I'm not sure why this needs to be a single thread executor. We could certainly use more threads for timer tasks, but let's tackle this at a later point of this project.", "author": "narendly", "createdAt": "2020-05-09T04:40:26Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -102,4 +96,53 @@ public boolean isShutdown() {\n   public boolean isTerminated() {\n     return _taskExecutor.isTerminated();\n   }\n+\n+  private ScheduledExecutorService createTaskExecutor(int taskThreadPoolSize) {\n+    return Executors.newScheduledThreadPool(taskThreadPoolSize, new ThreadFactory() {\n+      private AtomicInteger threadId = new AtomicInteger(0);\n+\n+      @Override\n+      public Thread newThread(Runnable r) {\n+        return new Thread(r, \"TaskStateModelFactory-task_thread-\" + threadId.getAndIncrement());\n+      }\n+    });\n+  }\n+\n+  private ScheduledExecutorService createTimerTaskExecutor() {\n+    return Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {\n+      @Override\n+      public Thread newThread(Runnable r) {\n+        return new Thread(r, \"TaskStateModelFactory-timeTask_thread\");\n+      }\n+    });\n+  }", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjMzNg==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452336", "bodyText": "Nit, let's add e as the second parameter for log.warn.", "author": "narendly", "createdAt": "2020-05-09T04:41:21Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -102,4 +96,53 @@ public boolean isShutdown() {\n   public boolean isTerminated() {\n     return _taskExecutor.isTerminated();\n   }\n+\n+  private ScheduledExecutorService createTaskExecutor(int taskThreadPoolSize) {\n+    return Executors.newScheduledThreadPool(taskThreadPoolSize, new ThreadFactory() {\n+      private AtomicInteger threadId = new AtomicInteger(0);\n+\n+      @Override\n+      public Thread newThread(Runnable r) {\n+        return new Thread(r, \"TaskStateModelFactory-task_thread-\" + threadId.getAndIncrement());\n+      }\n+    });\n+  }\n+\n+  private ScheduledExecutorService createTimerTaskExecutor() {\n+    return Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {\n+      @Override\n+      public Thread newThread(Runnable r) {\n+        return new Thread(r, \"TaskStateModelFactory-timeTask_thread\");\n+      }\n+    });\n+  }\n+\n+  private void initializeTaskMonitor() {\n+    if (_taskExecutor instanceof ThreadPoolExecutor) {\n+      try {\n+        _monitor = new ThreadPoolExecutorMonitor(TaskConstants.STATE_MODEL_NAME,\n+            (ThreadPoolExecutor) _taskExecutor);\n+      } catch (JMException e) {\n+        LOG.warn(\"Error in creating ThreadPoolExecutorMonitor for TaskStateModelFactory.\");", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjM4NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452385", "bodyText": "How is this test relevant to this PR?", "author": "narendly", "createdAt": "2020-05-09T04:42:56Z", "path": "helix-core/src/test/java/org/apache/helix/integration/multizk/TestMultiZkHelixJavaApis.java", "diffHunk": "@@ -149,6 +150,7 @@ public void beforeClass() throws Exception {\n     System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY,\n         \"http://\" + msdsHostName + \":\" + msdsPort + \"/admin/v2/namespaces/\" + msdsNamespace);\n \n+    HttpRoutingDataReader.reset();", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE4NTA1Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423185052", "bodyText": "reset() is to avoid racing over routing data; this test and TestTaskStateModelFactory both specify routing data using the same MSDS endpoint. Without reset(), the test that starts later will be using the cached routing data specified by the test that starts earlier and fail.", "author": "NealSun96", "createdAt": "2020-05-11T17:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwODkyMw==", "url": "https://github.com/apache/helix/pull/973#discussion_r423208923", "bodyText": "Shall we put this reset into the root test class? Or to the basic ZK API test class? So that we don't need to bother changing it if more tests modify the routing data.", "author": "jiajunwang", "createdAt": "2020-05-11T17:41:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1NTgwOA==", "url": "https://github.com/apache/helix/pull/973#discussion_r423255808", "bodyText": "If that's the case, we could do this in the beforeClass().", "author": "narendly", "createdAt": "2020-05-11T19:05:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1Nzk0Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423257942", "bodyText": "@jiajunwang What you said makes the most sense but we can't do that now because TestMultiZkHelixJavaApis.java doesn't have a base test class; it should be done as a part of a refactoring ticket. This line is already in beforeClass() of this test; did you mean beforeClass() of a base class? @narendly", "author": "NealSun96", "createdAt": "2020-05-11T19:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM1MTk1Nw==", "url": "https://github.com/apache/helix/pull/973#discussion_r423351957", "bodyText": "I see. In that case, just add a quick comment saying you're clearing the routing data just in case to avoid mixup. It just looked random that you called a reset() here. Otherwise, I am fine with this.", "author": "narendly", "createdAt": "2020-05-11T22:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjUxMQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452511", "bodyText": "Nit: might be a display of better craftsmanship/readability if you could explain why you're adding 1 here. I believe you're just trying to use a value that's not 40?", "author": "narendly", "createdAt": "2020-05-09T04:44:31Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestParticipantManager.java", "diffHunk": "@@ -145,6 +147,43 @@ public void testSessionExpiryCreateLiveInstance() throws Exception {\n     deleteCluster(clusterName);\n   }\n \n+  @Test(dependsOnMethods = \"testSessionExpiryCreateLiveInstance\")\n+  public void testCurrentTaskThreadPoolSizeCreation() throws Exception {\n+    final int testThreadPoolSize = TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE + 1;", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjU2MA==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452560", "bodyText": "If possible, could we start phasing out deprecated constructors (I believe this is deprecated)?", "author": "narendly", "createdAt": "2020-05-09T04:45:21Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestParticipantManager.java", "diffHunk": "@@ -145,6 +147,43 @@ public void testSessionExpiryCreateLiveInstance() throws Exception {\n     deleteCluster(clusterName);\n   }\n \n+  @Test(dependsOnMethods = \"testSessionExpiryCreateLiveInstance\")\n+  public void testCurrentTaskThreadPoolSizeCreation() throws Exception {\n+    final int testThreadPoolSize = TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE + 1;\n+    final String className = TestHelper.getTestClassName();\n+    final String methodName = TestHelper.getTestMethodName();\n+    final String clusterName = className + \"_\" + methodName;\n+\n+    final ZKHelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(ZK_ADDR));", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjY4Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452682", "bodyText": "Are you stopping this manager and cleaning up this cluster after the test?", "author": "narendly", "createdAt": "2020-05-09T04:46:53Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestParticipantManager.java", "diffHunk": "@@ -145,6 +147,43 @@ public void testSessionExpiryCreateLiveInstance() throws Exception {\n     deleteCluster(clusterName);\n   }\n \n+  @Test(dependsOnMethods = \"testSessionExpiryCreateLiveInstance\")\n+  public void testCurrentTaskThreadPoolSizeCreation() throws Exception {\n+    final int testThreadPoolSize = TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE + 1;\n+    final String className = TestHelper.getTestClassName();\n+    final String methodName = TestHelper.getTestMethodName();\n+    final String clusterName = className + \"_\" + methodName;\n+\n+    final ZKHelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(ZK_ADDR));\n+    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR,\n+        12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        1, // resources\n+        10, // partitions per resource\n+        5, // number of nodes\n+        3, // replicas\n+        \"MasterSlave\",\n+        true); // do rebalance\n+\n+    final String instanceName = \"localhost_12918\";\n+    final MockParticipantManager manager =\n+        new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+\n+    InstanceConfig instanceConfig = accessor.getProperty(keyBuilder.instanceConfig(instanceName));\n+    instanceConfig.setTargetTaskThreadPoolSize(testThreadPoolSize);\n+    accessor.setProperty(keyBuilder.instanceConfig(instanceName), instanceConfig);\n+\n+    manager.syncStart();", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1Mjc0NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452745", "bodyText": "We should maybe consider allowing the value 0. Negative values don't make any sense so those should still not be allowed.", "author": "narendly", "createdAt": "2020-05-09T04:48:15Z", "path": "helix-core/src/test/java/org/apache/helix/model/TestClusterConfig.java", "diffHunk": "@@ -69,6 +69,30 @@ public void testSetCapacityKeysEmptyList() {\n     testConfig.setInstanceCapacityKeys(Collections.emptyList());\n   }\n \n+  @Test\n+  public void testGetGlobalTargetTaskThreadPoolSize() {\n+    ClusterConfig testConfig = new ClusterConfig(\"testId\");\n+    testConfig.getRecord().setIntField(\n+        ClusterConfig.ClusterConfigProperty.GLOBAL_TARGET_TASK_THREAD_POOL_SIZE.name(), 100);\n+\n+    Assert.assertEquals(testConfig.getGlobalTargetTaskThreadPoolSize(), 100);\n+  }\n+\n+  @Test\n+  public void testSetGlobalTargetTaskThreadPoolSize() {\n+    ClusterConfig testConfig = new ClusterConfig(\"testId\");\n+    testConfig.setGlobalTargetTaskThreadPoolSize(100);\n+\n+    Assert.assertEquals(testConfig.getRecord().getIntField(\n+        ClusterConfig.ClusterConfigProperty.GLOBAL_TARGET_TASK_THREAD_POOL_SIZE.name(), -1), 100);\n+  }\n+\n+  @Test(expectedExceptions = IllegalArgumentException.class)\n+  public void testSetGlobalTargetTaskThreadPoolSizeIllegalArgument() {\n+    ClusterConfig testConfig = new ClusterConfig(\"testId\");\n+    testConfig.setGlobalTargetTaskThreadPoolSize(0);", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1Mjc1OA==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452758", "bodyText": "We should consider allowing the value 0. Negative values don't make any sense so those should still not be allowed.", "author": "narendly", "createdAt": "2020-05-09T04:48:39Z", "path": "helix-core/src/test/java/org/apache/helix/model/TestInstanceConfig.java", "diffHunk": "@@ -123,4 +123,28 @@ public void testSetInstanceCapacityMapInvalid() {\n     InstanceConfig testConfig = new InstanceConfig(\"testConfig\");\n     testConfig.setInstanceCapacityMap(capacityDataMap);\n   }\n+\n+  @Test\n+  public void testGetTargetTaskThreadPoolSize() {\n+    InstanceConfig testConfig = new InstanceConfig(\"testConfig\");\n+    testConfig.getRecord().setIntField(\n+        InstanceConfig.InstanceConfigProperty.TARGET_TASK_THREAD_POOL_SIZE.name(), 100);\n+\n+    Assert.assertEquals(testConfig.getTargetTaskThreadPoolSize(), 100);\n+  }\n+\n+  @Test\n+  public void testSetTargetTaskThreadPoolSize() {\n+    InstanceConfig testConfig = new InstanceConfig(\"testConfig\");\n+    testConfig.setTargetTaskThreadPoolSize(100);\n+\n+    Assert.assertEquals(testConfig.getRecord().getIntField(\n+        InstanceConfig.InstanceConfigProperty.TARGET_TASK_THREAD_POOL_SIZE.name(), -1), 100);\n+  }\n+\n+  @Test(expectedExceptions = IllegalArgumentException.class)\n+  public void testSetTargetTaskThreadPoolSizeIllegalArgument() {\n+    InstanceConfig testConfig = new InstanceConfig(\"testConfig\");\n+    testConfig.setTargetTaskThreadPoolSize(0);", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MjgyMQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r422452821", "bodyText": "Great!", "author": "narendly", "createdAt": "2020-05-09T04:49:41Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestTaskStateModelFactory.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ConfigAccessor;\n+import org.apache.helix.SystemPropertyKeys;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.TaskTestBase;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestTaskStateModelFactory extends TaskTestBase {\n+  // This value has to be different from the default value to verify correctness", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzU0Mw==", "url": "https://github.com/apache/helix/pull/973#discussion_r422453543", "bodyText": "Did you mean to say turn \"off\"? :)", "author": "narendly", "createdAt": "2020-05-09T05:01:38Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestTaskStateModelFactory.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ConfigAccessor;\n+import org.apache.helix.SystemPropertyKeys;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.TaskTestBase;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestTaskStateModelFactory extends TaskTestBase {\n+  // This value has to be different from the default value to verify correctness\n+  private static final int TEST_TARGET_TASK_THREAD_POOL_SIZE =\n+      TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE + 1;\n+\n+  @Test\n+  public void testConfigAccessorCreationMultiZk() throws Exception {\n+    MockParticipantManager anyParticipantManager = _participants[0];\n+\n+    InstanceConfig instanceConfig =\n+        InstanceConfig.toInstanceConfig(anyParticipantManager.getInstanceName());\n+    instanceConfig.setTargetTaskThreadPoolSize(TEST_TARGET_TASK_THREAD_POOL_SIZE);\n+    anyParticipantManager.getConfigAccessor()\n+        .setInstanceConfig(anyParticipantManager.getClusterName(),\n+            anyParticipantManager.getInstanceName(), instanceConfig);\n+\n+    // Start a msds server\n+    // TODO: TestMultiZkHelixJavaApis already defined MSDS_SERVER_ENDPOINT, which goes into\n+    // HttpRoutingDataReader and is recorded as final. As a result this test case has to use the\n+    // same endpoint. There's no workaround at this moment.\n+    final String msdsHostName = \"localhost\";\n+    final int msdsPort = 11117;\n+    final String msdsNamespace = \"multiZkTest\";\n+    Map<String, Collection<String>> routingData = new HashMap<>();\n+    routingData\n+        .put(ZK_ADDR, Collections.singletonList(\"/\" + anyParticipantManager.getClusterName()));\n+    MockMetadataStoreDirectoryServer msds =\n+        new MockMetadataStoreDirectoryServer(msdsHostName, msdsPort, msdsNamespace, routingData);\n+    msds.startServer();\n+\n+    // Save previously-set system configs\n+    String prevMultiZkEnabled = System.getProperty(SystemPropertyKeys.MULTI_ZK_ENABLED);\n+    String prevMsdsServerEndpoint =\n+        System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+    // Turn on multiZk mode in System config\n+    System.setProperty(SystemPropertyKeys.MULTI_ZK_ENABLED, \"true\");\n+    // MSDS endpoint: http://localhost:11117/admin/v2/namespaces/testTaskStateModelFactory\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY,\n+        \"http://\" + msdsHostName + \":\" + msdsPort + \"/admin/v2/namespaces/\" + msdsNamespace);\n+\n+    HttpRoutingDataReader.reset();\n+    TaskStateModelFactory taskStateModelFactory =\n+        new TaskStateModelFactory(anyParticipantManager, Collections.emptyMap());\n+    ConfigAccessor configAccessor = taskStateModelFactory.createConfigAccessor();\n+    Assert.assertEquals(TaskUtil\n+        .getTargetThreadPoolSize(configAccessor, anyParticipantManager.getClusterName(),\n+            anyParticipantManager.getInstanceName()), TEST_TARGET_TASK_THREAD_POOL_SIZE);\n+\n+    // Restore system properties\n+    if (prevMultiZkEnabled == null) {\n+      System.clearProperty(SystemPropertyKeys.MULTI_ZK_ENABLED);\n+    } else {\n+      System.setProperty(SystemPropertyKeys.MULTI_ZK_ENABLED, prevMultiZkEnabled);\n+    }\n+    if (prevMsdsServerEndpoint == null) {\n+      System.clearProperty(SystemPropertyKeys.MSDS_SERVER_ENDPOINT_KEY);\n+    } else {\n+      System.setProperty(SystemPropertyKeys.MSDS_SERVER_ENDPOINT_KEY, prevMsdsServerEndpoint);\n+    }\n+    msds.stopServer();\n+  }\n+\n+  @Test(dependsOnMethods = \"testConfigAccessorCreationMultiZk\")\n+  public void testConfigAccessorCreationSingleZk() {\n+    MockParticipantManager anyParticipantManager = _participants[0];\n+\n+    // Save previously-set system configs\n+    String prevMultiZkEnabled = System.getProperty(SystemPropertyKeys.MULTI_ZK_ENABLED);\n+    // Turn on multiZk mode in System config", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5MzUzMA==", "url": "https://github.com/apache/helix/pull/973#discussion_r423193530", "bodyText": "Yes, it was a copy-paste mistake.", "author": "NealSun96", "createdAt": "2020-05-11T17:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzY4NA==", "url": "https://github.com/apache/helix/pull/973#discussion_r422453684", "bodyText": "This is okay. I'm not sure if we want to make it a TODO, but \"multiZkTest\" is a generic enough a name, so I'm not too bothered by this at the moment. The reason this is tricky is that in production, in order to set up a different MSDS, you would have to change the JVM config and restart the JVM, thereby updating the final field.\nI think the right TODO here is that now that we have a few tests that need to use the MSDS, so it would be a good idea to move this MSDS creation to the abstract test base so that we make it transparent to all tests, not a single test that tests multi-zk functionalities. What do you think? That way, we could make these values like msdsHostName, port, namespace all accessible to child classes, so you don't have to redefine them (just like how we do with ZK_ADDR and such).", "author": "narendly", "createdAt": "2020-05-09T05:04:12Z", "path": "helix-core/src/test/java/org/apache/helix/task/TestTaskStateModelFactory.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package org.apache.helix.task;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.helix.ConfigAccessor;\n+import org.apache.helix.SystemPropertyKeys;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.integration.task.TaskTestBase;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.mock.MockMetadataStoreDirectoryServer;\n+import org.apache.helix.zookeeper.util.HttpRoutingDataReader;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestTaskStateModelFactory extends TaskTestBase {\n+  // This value has to be different from the default value to verify correctness\n+  private static final int TEST_TARGET_TASK_THREAD_POOL_SIZE =\n+      TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE + 1;\n+\n+  @Test\n+  public void testConfigAccessorCreationMultiZk() throws Exception {\n+    MockParticipantManager anyParticipantManager = _participants[0];\n+\n+    InstanceConfig instanceConfig =\n+        InstanceConfig.toInstanceConfig(anyParticipantManager.getInstanceName());\n+    instanceConfig.setTargetTaskThreadPoolSize(TEST_TARGET_TASK_THREAD_POOL_SIZE);\n+    anyParticipantManager.getConfigAccessor()\n+        .setInstanceConfig(anyParticipantManager.getClusterName(),\n+            anyParticipantManager.getInstanceName(), instanceConfig);\n+\n+    // Start a msds server\n+    // TODO: TestMultiZkHelixJavaApis already defined MSDS_SERVER_ENDPOINT, which goes into\n+    // HttpRoutingDataReader and is recorded as final. As a result this test case has to use the\n+    // same endpoint. There's no workaround at this moment.\n+    final String msdsHostName = \"localhost\";\n+    final int msdsPort = 11117;\n+    final String msdsNamespace = \"multiZkTest\";", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NDI1NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423194255", "bodyText": "That's exactly what I planned to do at first, but then I realized that TestMultiZkHelixJavaApis doesn't extend any class, which makes refactoring a bit more difficult. I will update to TODO accordingly.", "author": "NealSun96", "createdAt": "2020-05-11T17:16:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ1MzY4NA=="}], "type": "inlineReview"}, {"oid": "282255567d6df3085f2583bea1c4dd2de514ae86", "url": "https://github.com/apache/helix/commit/282255567d6df3085f2583bea1c4dd2de514ae86", "message": "Address comments", "committedDate": "2020-05-11T17:28:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5Mjc3Nw==", "url": "https://github.com/apache/helix/pull/973#discussion_r423192777", "bodyText": "Can you share the reason why we change to GLOBAL_XXXX instead of DEFAULT_XXXX? I think default value is closer to how it is used. If participant specifies their values individually, it is not globally applied, right?", "author": "jiajunwang", "createdAt": "2020-05-11T17:14:08Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -109,7 +109,11 @@\n     // https://github.com/apache/helix/wiki/Weight-aware-Globally-Evenly-distributed-Rebalancer#rebalance-coordinator\n     //\n     // Default to be true.\n-    GLOBAL_REBALANCE_ASYNC_MODE\n+    GLOBAL_REBALANCE_ASYNC_MODE,\n+\n+    // The target size of task thread pools for each participant. This is the global value\n+    // that's used when participants don't specify their individual pool sizes.\n+    GLOBAL_TARGET_TASK_THREAD_POOL_SIZE", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1MTk0Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423251942", "bodyText": "@jiajunwang\nI think we should make a distinction between global and default, and I think global is the more appropriate name here.\nThis \"global\" config in ClusterConfig is used to determine what config should apply to the cluster globally. There's a \"default\" value for this \"global\" config, which is 40.", "author": "narendly", "createdAt": "2020-05-11T18:58:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5Mjc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNTUzMg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423315532", "bodyText": "IMO, there could be 2 potential misunderstandings if we use GLOBAL.\n\nThis size is the total thread count of all the participant thread pool size.\nThis size will be applied to every single participant.\n\nTo avoid those confusing, using DEFAULT is easier.\nRegarding the internal DEFAULT value which is 40,\n\nit is internal only, so even we name the above one as DEFAULT, it won't confuse the users.\nI think we only have NOT_SET which is -1. There is no DEFAULT TARGET thread pool size, right? The 40 is the default thread pool size which is corresponding to the current thread poll size.", "author": "jiajunwang", "createdAt": "2020-05-11T20:58:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5Mjc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2MzE0Nw==", "url": "https://github.com/apache/helix/pull/973#discussion_r423463147", "bodyText": "As a counter argument, \"global target\" sounds like the target value that's applied globally, which is correct here. The confusion over \"default\" may also apply to developers too.\nPersonally, I think different people have different interpretation to the field names, but what I can do is to provide well-written javadocs that explain clearly what these fields do on CRUD APIs, then the naming doesn't matter as much. What do you think?", "author": "NealSun96", "createdAt": "2020-05-12T05:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5Mjc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzc1NTA3OA==", "url": "https://github.com/apache/helix/pull/973#discussion_r423755078", "bodyText": "I still think \"global\" makes more sense in this context and more intuitive for devs to understand, but it seems that Jiajun has used \"default\" for the WAGED rebalancer related configs that serve a similar purpose.\nI don't think it'd be hugely off either way, so you could either get a third opinion or make the call yourself :) But I agree that we should make this clear in both JavaDoc and a user manual of some sort.", "author": "narendly", "createdAt": "2020-05-12T13:57:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5Mjc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDAzNTg3OA==", "url": "https://github.com/apache/helix/pull/973#discussion_r424035878", "bodyText": "Based on a vote within the dev team, we have decided on using \"GLOBAL_XXX\".", "author": "NealSun96", "createdAt": "2020-05-12T21:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5Mjc3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NjcxMw==", "url": "https://github.com/apache/helix/pull/973#discussion_r423196713", "bodyText": "Deprecate?\nAnd if anyone is using this method, what is the current thread pool size in the live instance node?", "author": "jiajunwang", "createdAt": "2020-05-11T17:20:28Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -44,39 +48,29 @@\n   private final ScheduledExecutorService _taskExecutor;\n   private final ScheduledExecutorService _timerTaskExecutor;\n   private ThreadPoolExecutorMonitor _monitor;\n-  public final static int TASK_THREADPOOL_SIZE = 40;\n \n   public TaskStateModelFactory(HelixManager manager, Map<String, TaskFactory> taskFactoryRegistry) {\n-    this(manager, taskFactoryRegistry,\n-        Executors.newScheduledThreadPool(TASK_THREADPOOL_SIZE, new ThreadFactory() {\n-          private AtomicInteger threadId = new AtomicInteger(0);\n-\n-          @Override\n-          public Thread newThread(Runnable r) {\n-            return new Thread(r, \"TaskStateModelFactory-task_thread-\" + threadId.getAndIncrement());\n-          }\n-        }));\n+    _manager = manager;\n+    _taskFactoryRegistry = taskFactoryRegistry;\n+    // TODO: revisit the logic here; we are creating a connection although we already have a manager\n+    ConfigAccessor configAccessor = createConfigAccessor();\n+    int threadPoolSize = TaskUtil.getTargetThreadPoolSize(configAccessor, _manager.getClusterName(),\n+        _manager.getInstanceName());\n+    configAccessor.close();\n+    _taskExecutor = createTaskExecutor(threadPoolSize);\n+    _timerTaskExecutor = createTimerTaskExecutor();\n+    initializeTaskMonitor();\n   }\n \n+  // FIXME: DO NOT USE! This size of provided thread pool will not be reflected to controller\n+  // properly, the controller may over schedule tasks to this participant.\n   public TaskStateModelFactory(HelixManager manager, Map<String, TaskFactory> taskFactoryRegistry,", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1MzM1Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423253352", "bodyText": "@jiajunwang\nI shared this thought with Neal offline, but let me also share it here.\nThe reason I think it would be more appropriate to just add a FIXME or a warning here is because there's a slim chance that we might need to use this constructor. This might be useful later when we want to make the thread pool size change take place dynamically, without requiring a JVM restart.\nI didn't think it'd be a good idea to deprecate and undeprecate public APIs in the future, so I've asked Neal to put a FIXME here. If you think otherwise, let us know.", "author": "narendly", "createdAt": "2020-05-11T19:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NjcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI5NTM1Nw==", "url": "https://github.com/apache/helix/pull/973#discussion_r423295357", "bodyText": "@jiajunwang To answer your question the current thread pool size will be based on target size defined in configs. If they don't exist, it will come out as the default value.", "author": "NealSun96", "createdAt": "2020-05-11T20:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NjcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMxNjYzMg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423316632", "bodyText": "That won't be the case. If we have a dynamic pool size later, the change will be done inside this class (configuration, or some new defined Helix executors) instead of being exposed as a public constructor, I guess.", "author": "jiajunwang", "createdAt": "2020-05-11T21:00:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NjcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2NDk3OQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423464979", "bodyText": "If it'll be us using it, how about we make it private? Users shouldn't gain access to it anyways, right?", "author": "NealSun96", "createdAt": "2020-05-12T05:08:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NjcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkyNDY1Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423924652", "bodyText": "That could be another option. The point here is to prevent users from using it in order to retain control. But I'm not sure it's possible to make it private - isn't this required by the interface?", "author": "narendly", "createdAt": "2020-05-12T17:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NjcxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkzODcyMg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423938722", "bodyText": "Deprecating it as resolved offline.", "author": "NealSun96", "createdAt": "2020-05-12T18:16:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE5NjcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwMDE4NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423200185", "bodyText": "You have some duplicate code in your 2 constructors. Why not keep the original style?\nAnd, I still think merging the init logic in a single method or fewer methods make the code cleaner.", "author": "jiajunwang", "createdAt": "2020-05-11T17:26:21Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskStateModelFactory.java", "diffHunk": "@@ -44,39 +48,29 @@\n   private final ScheduledExecutorService _taskExecutor;\n   private final ScheduledExecutorService _timerTaskExecutor;\n   private ThreadPoolExecutorMonitor _monitor;\n-  public final static int TASK_THREADPOOL_SIZE = 40;\n \n   public TaskStateModelFactory(HelixManager manager, Map<String, TaskFactory> taskFactoryRegistry) {", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI1OTk0Mw==", "url": "https://github.com/apache/helix/pull/973#discussion_r423259943", "bodyText": "I can no longer use the original style because _taskExecutor is created differently - the first constructor's logic is no longer a subset of the second constructor's.\nAs a result of that, I factored out the timer task thread pool creation etc into methods to avoid duplicate code.", "author": "NealSun96", "createdAt": "2020-05-11T19:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwMDE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMzAzMg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423333032", "bodyText": "I'm not convinced. It seems that if you put the get threadpool size and createTaskExecutor(threadPoolSize) into one method, then you can put this method as a parameter so you can do exactly what was here before.", "author": "jiajunwang", "createdAt": "2020-05-11T21:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwMDE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNDY1OQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423204659", "bodyText": "nit, It would be helpful to note what happens if it is \"else\" condition.", "author": "jiajunwang", "createdAt": "2020-05-11T17:33:47Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "diffHunk": "@@ -1045,4 +1048,54 @@ private static void setNextJobPurgeTime(String workflow, long currentTime, long\n       rebalanceScheduler.scheduleRebalance(manager, workflow, nextPurgeTime);\n     }\n   }\n+\n+  /**\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   * @param configAccessor - accessor used for the configs\n+   * @param clusterName - the cluster name for InstanceConfig and ClusterConfig\n+   * @param instanceName - the instance name for InstanceConfig\n+   * @return target thread pool size\n+   */\n+  public static int getTargetThreadPoolSize(ConfigAccessor configAccessor, String clusterName,\n+      String instanceName) {\n+    // Check instance config first for thread pool size\n+    try {\n+      InstanceConfig instanceConfig = configAccessor.getInstanceConfig(clusterName, instanceName);\n+      if (instanceConfig != null) {\n+        int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+        if (targetTaskThreadPoolSize > 0) {\n+          return targetTaskThreadPoolSize;\n+        }", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI2Mjc1OQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423262759", "bodyText": "Ok, adding a comment.", "author": "NealSun96", "createdAt": "2020-05-11T19:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNDY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNTA4Ng==", "url": "https://github.com/apache/helix/pull/973#discussion_r423205086", "bodyText": "If it is HelixException, is it safe to just return the default value?", "author": "jiajunwang", "createdAt": "2020-05-11T17:34:30Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "diffHunk": "@@ -1045,4 +1048,54 @@ private static void setNextJobPurgeTime(String workflow, long currentTime, long\n       rebalanceScheduler.scheduleRebalance(manager, workflow, nextPurgeTime);\n     }\n   }\n+\n+  /**\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   * @param configAccessor - accessor used for the configs\n+   * @param clusterName - the cluster name for InstanceConfig and ClusterConfig\n+   * @param instanceName - the instance name for InstanceConfig\n+   * @return target thread pool size\n+   */\n+  public static int getTargetThreadPoolSize(ConfigAccessor configAccessor, String clusterName,\n+      String instanceName) {\n+    // Check instance config first for thread pool size\n+    try {\n+      InstanceConfig instanceConfig = configAccessor.getInstanceConfig(clusterName, instanceName);\n+      if (instanceConfig != null) {\n+        int targetTaskThreadPoolSize = instanceConfig.getTargetTaskThreadPoolSize();\n+        if (targetTaskThreadPoolSize > 0) {\n+          return targetTaskThreadPoolSize;\n+        }\n+      } else {\n+        LOG.warn(\n+            \"Got null as InstanceConfig for instance {} in cluster {}. Continuing with ClusterConfig. \",\n+            instanceName, clusterName);\n+      }\n+    } catch (HelixException e) {\n+      LOG.warn(\n+          \"Encountered an exception while fetching InstanceConfig for instance {} in cluster {}. Continuing with ClusterConfig. Exception: \",\n+          instanceName, clusterName, e);\n+    }\n+\n+    // Fallback to cluster config since instance config doesn't provide the value\n+    try {\n+      ClusterConfig clusterConfig = configAccessor.getClusterConfig(clusterName);\n+      if (clusterConfig != null) {\n+        int globalTargetTaskThreadPoolSize = clusterConfig.getGlobalTargetTaskThreadPoolSize();\n+        if (globalTargetTaskThreadPoolSize > 0) {\n+          return globalTargetTaskThreadPoolSize;\n+        }\n+      } else {\n+        LOG.warn(\"Got null as ClusterConfig for cluster {}. Returning default value. \",\n+            clusterName);\n+      }\n+    } catch (HelixException e) {\n+      LOG.warn(\n+          \"Encountered an exception while fetching ClusterConfig in cluster {}. Returning default value. Exception: \",\n+          clusterName, e);\n+    }\n+\n+    return TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE;", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI4NTk0NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423285945", "bodyText": "When HelixException is thrown on this line, it means the cluster is not set up. I don't have a strong preference on \"returning default\" vs \"rethrow the exception\". What do you think?", "author": "NealSun96", "createdAt": "2020-05-11T20:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNTA4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzMzMzg0Mg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423333842", "bodyText": "I would prefer exception because it fails the logic earlier.", "author": "jiajunwang", "createdAt": "2020-05-11T21:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNTA4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ2NTc3MQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423465771", "bodyText": "Resolved offline. Now the logic rethrows exceptions.", "author": "NealSun96", "createdAt": "2020-05-12T05:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNTA4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNjgyOA==", "url": "https://github.com/apache/helix/pull/973#discussion_r423206828", "bodyText": "You have 2 very similar code blocks, especially the warning messages. Is it possible to make it concise? I understand the warning messages might look the same in that case, but it won't hurt IMO. Since we just need to know that the configuration is missing.\nDuplicate code is a bigger problem.", "author": "jiajunwang", "createdAt": "2020-05-11T17:37:33Z", "path": "helix-core/src/main/java/org/apache/helix/task/TaskUtil.java", "diffHunk": "@@ -1045,4 +1048,54 @@ private static void setNextJobPurgeTime(String workflow, long currentTime, long\n       rebalanceScheduler.scheduleRebalance(manager, workflow, nextPurgeTime);\n     }\n   }\n+\n+  /**\n+   * Get target thread pool size from InstanceConfig first; if that fails, get it from\n+   * ClusterConfig; if that fails, fall back to the default value.\n+   * @param configAccessor - accessor used for the configs\n+   * @param clusterName - the cluster name for InstanceConfig and ClusterConfig\n+   * @param instanceName - the instance name for InstanceConfig\n+   * @return target thread pool size\n+   */\n+  public static int getTargetThreadPoolSize(ConfigAccessor configAccessor, String clusterName,", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI4ODU3MA==", "url": "https://github.com/apache/helix/pull/973#discussion_r423288570", "bodyText": "This is the first thing I tried with this PR, and my conclusion was there is no way to not have duplicate lines here. The main reason is due to the \"try catch\" + \"optional return\" structure, making it very difficult to factor out. Also, since the getters have different signatures, that's an additional difficulty to factor it out (which also makes the 2 blocks technically not duplicate). If you have a good way to make it not duplicate, I'd love to try it.", "author": "NealSun96", "createdAt": "2020-05-11T20:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwNjgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwOTYzNg==", "url": "https://github.com/apache/helix/pull/973#discussion_r423209636", "bodyText": "Can you checkout TestZKLiveInstanceData and see if you can merge them?", "author": "jiajunwang", "createdAt": "2020-05-11T17:42:19Z", "path": "helix-core/src/test/java/org/apache/helix/model/TestLiveInstance.java", "diffHunk": "@@ -0,0 +1,51 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import org.apache.helix.task.TaskConstants;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestLiveInstance {", "originalCommit": "8ae50c1841cde6b68854fdff41d6092d9081a7f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzI5NDY3NQ==", "url": "https://github.com/apache/helix/pull/973#discussion_r423294675", "bodyText": "Combined.", "author": "NealSun96", "createdAt": "2020-05-11T20:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzIwOTYzNg=="}], "type": "inlineReview"}, {"oid": "a50ed69ee00053cfd1c2168322d31cd1960679b5", "url": "https://github.com/apache/helix/commit/a50ed69ee00053cfd1c2168322d31cd1960679b5", "message": "Extra changes", "committedDate": "2020-05-11T20:32:52Z", "type": "commit"}, {"oid": "b892090cc4ed50fe5d025bedaed20559f142fdae", "url": "https://github.com/apache/helix/commit/b892090cc4ed50fe5d025bedaed20559f142fdae", "message": "Address comments", "committedDate": "2020-05-12T04:53:32Z", "type": "commit"}, {"oid": "879a221acc68b13dc2eb988e101ddb14ee6da927", "url": "https://github.com/apache/helix/commit/879a221acc68b13dc2eb988e101ddb14ee6da927", "message": "Deprecate and add comments", "committedDate": "2020-05-12T23:34:07Z", "type": "commit"}]}