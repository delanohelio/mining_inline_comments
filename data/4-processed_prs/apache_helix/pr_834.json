{"pr_number": 834, "pr_title": "Complete the Routing Table Provider for CustomizedView", "pr_createdAt": "2020-02-28T00:57:17Z", "pr_url": "https://github.com/apache/helix/pull/834", "timeline": [{"oid": "be3d54001a9a418282b21bbf8ddc7a72aaefa772", "url": "https://github.com/apache/helix/commit/be3d54001a9a418282b21bbf8ddc7a72aaefa772", "message": "Complete the Routing Table Provider for CustomizedView\n\nIn this commit, the routing table provider has been changed in a way\nto include customized view feature.", "committedDate": "2020-02-28T22:14:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0MzQyOQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r386543429", "bodyText": "Java doc for the new constructor.", "author": "zhangmeng916", "createdAt": "2020-03-02T17:39:31Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -30,53 +30,80 @@\n import java.util.Set;\n import java.util.TreeSet;\n \n+import org.apache.helix.PropertyType;\n import org.apache.helix.model.CurrentState;\n+import org.apache.helix.model.CustomizedView;\n import org.apache.helix.model.ExternalView;\n import org.apache.helix.model.InstanceConfig;\n import org.apache.helix.model.LiveInstance;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n   private final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n+  private final Collection<CustomizedView> _customizedViews;\n+\n+  private final PropertyType _propertyType;\n+  private final String _aggregationType;\n \n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  public RoutingTable(PropertyType propertyType, String aggregationType) {\n+    this(Collections.<ExternalView> emptyList(), Collections.<CustomizedView> emptyList(), Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertyType, aggregationType);\n+  }\n+\n   public RoutingTable(Map<String, Map<String, Map<String, CurrentState>>> currentStateMap,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n     // TODO Aggregate currentState to an ExternalView in the RoutingTable, so there is no need to\n     // refresh according to the currentStateMap. - jjwang\n-    this(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances);\n+    this(Collections.<ExternalView> emptyList(), Collections.<CustomizedView> emptyList(),\n+        instanceConfigs, liveInstances, PropertyType.CURRENTSTATES, null);\n     refresh(currentStateMap);\n   }\n \n   public RoutingTable(Collection<ExternalView> externalViews,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+    this(externalViews, Collections.<CustomizedView> emptyList(), instanceConfigs, liveInstances,\n+        PropertyType.EXTERNALVIEW, null);\n+  }\n+\n+  protected RoutingTable(Collection<ExternalView> externalViews,", "originalCommit": "be3d54001a9a418282b21bbf8ddc7a72aaefa772", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzOTIzMQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r387339231", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-03T22:42:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0MzQyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0MzU3Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r386543576", "bodyText": "Java doc for the new constructor.", "author": "zhangmeng916", "createdAt": "2020-03-02T17:39:47Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -41,13 +44,24 @@\n   private static Logger LOG = LoggerFactory.getLogger(RoutingDataCache.class.getName());\n \n   private final PropertyType _sourceDataType;\n+  // Aggregation type is used for CustomizedView only.\n+  private final String _aggregationType;\n+\n   private CurrentStateCache _currentStateCache;\n+  private CustomizedViewCache _customizedViewCache;\n   private TargetExternalViewCache _targetExternalViewCache;\n \n+\n   public RoutingDataCache(String clusterName, PropertyType sourceDataType) {\n+    this (clusterName, sourceDataType, null);\n+  }\n+\n+  public RoutingDataCache(String clusterName, PropertyType sourceDataType, String aggregationType) {", "originalCommit": "be3d54001a9a418282b21bbf8ddc7a72aaefa772", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMzOTA5NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r387339094", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-03T22:42:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0MzU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU3OTc2Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r386579767", "bodyText": "This will not work as expected, use \"aggregationType == null || aggregationType.isEmpty()\"", "author": "zhangmeng916", "createdAt": "2020-03-02T18:48:12Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,62 +610,158 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n    * Return names of all resources (shown in ExternalView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  /**\n+   * Function that returns the key associated with the specific _routingTableRef\n+   * @return\n+   */\n+  private String getRoutingTableKey() {\n+    // Check whether there exist only one snapshot (_routingTableRef)\n+    if (_routingTableRef.keySet().size() == 1) {\n+      return _routingTableRef.keySet().iterator().next();\n+    } else {\n+      throw new HelixException(\"There is none or more than one RoutingTableSnapshot\");\n+    }\n+  }\n+\n+  private String getRoutingTableKey(PropertyType propertyType) {\n+    if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+      throw new HelixException(\"Specific type needs to be used for CUSTOMIZEDVIEW PropertyType\");\n+    } else {\n+      return getRoutingTableKey(propertyType, null);\n+    }\n+  }\n+\n+  private String getRoutingTableKey(PropertyType propertyType, String aggregationType) {\n+    if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+      if (aggregationType == null) {", "originalCommit": "be3d54001a9a418282b21bbf8ddc7a72aaefa772", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0NTg2MA==", "url": "https://github.com/apache/helix/pull/834#discussion_r387345860", "bodyText": "Addressed.", "author": "alirezazamani", "createdAt": "2020-03-03T22:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU3OTc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5ODg3NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r386598875", "bodyText": "can we specify propertyType in case we'd like to extend later or the wrong type is input.", "author": "zhangmeng916", "createdAt": "2020-03-02T19:22:42Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -30,53 +30,80 @@\n import java.util.Set;\n import java.util.TreeSet;\n \n+import org.apache.helix.PropertyType;\n import org.apache.helix.model.CurrentState;\n+import org.apache.helix.model.CustomizedView;\n import org.apache.helix.model.ExternalView;\n import org.apache.helix.model.InstanceConfig;\n import org.apache.helix.model.LiveInstance;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n   private final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n+  private final Collection<CustomizedView> _customizedViews;\n+\n+  private final PropertyType _propertyType;\n+  private final String _aggregationType;\n \n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  public RoutingTable(PropertyType propertyType, String aggregationType) {\n+    this(Collections.<ExternalView> emptyList(), Collections.<CustomizedView> emptyList(), Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertyType, aggregationType);\n+  }\n+\n   public RoutingTable(Map<String, Map<String, Map<String, CurrentState>>> currentStateMap,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n     // TODO Aggregate currentState to an ExternalView in the RoutingTable, so there is no need to\n     // refresh according to the currentStateMap. - jjwang\n-    this(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances);\n+    this(Collections.<ExternalView> emptyList(), Collections.<CustomizedView> emptyList(),\n+        instanceConfigs, liveInstances, PropertyType.CURRENTSTATES, null);\n     refresh(currentStateMap);\n   }\n \n   public RoutingTable(Collection<ExternalView> externalViews,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+    this(externalViews, Collections.<CustomizedView> emptyList(), instanceConfigs, liveInstances,\n+        PropertyType.EXTERNALVIEW, null);\n+  }\n+\n+  protected RoutingTable(Collection<ExternalView> externalViews,\n+      Collection<CustomizedView> customizedViews, Collection<InstanceConfig> instanceConfigs,\n+      Collection<LiveInstance> liveInstances, PropertyType propertytype, String aggregationType) {\n+    _propertyType = propertytype;\n+    _aggregationType = aggregationType;\n     _resourceInfoMap = new HashMap<>();\n     _resourceGroupInfoMap = new HashMap<>();\n     _liveInstances = new HashSet<>(liveInstances);\n     _instanceConfigs = new HashSet<>(instanceConfigs);\n     _externalViews = new HashSet<>(externalViews);\n-    refresh(externalViews);\n+    _customizedViews = new HashSet<>(customizedViews);\n+    if (_propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+      refreshCustomizedView(customizedViews);\n+    } else {", "originalCommit": "be3d54001a9a418282b21bbf8ddc7a72aaefa772", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0MjM1OQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r387342359", "bodyText": "Add a general function that has switch case. I think that satisfies what you are proposing.", "author": "alirezazamani", "createdAt": "2020-03-03T22:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU5ODg3NQ=="}], "type": "inlineReview"}, {"oid": "ed3b93c999cc5aa700a734b48f3a866b69eb1167", "url": "https://github.com/apache/helix/commit/ed3b93c999cc5aa700a734b48f3a866b69eb1167", "message": "Address comments", "committedDate": "2020-03-03T23:03:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NDMyMA==", "url": "https://github.com/apache/helix/pull/834#discussion_r388644320", "bodyText": "Is it overlapped with Meng's PR?\nhttps://github.com/apache/helix/pull/851/files\nCan we change this part as a pre-requisite change so both of you are on the same page.", "author": "jiajunwang", "createdAt": "2020-03-06T00:31:18Z", "path": "helix-core/src/main/java/org/apache/helix/PropertyPathBuilder.java", "diffHunk": "@@ -72,6 +74,7 @@\n     typeToClassMapping.put(IDEALSTATES, IdealState.class);\n     typeToClassMapping.put(CONFIGS, InstanceConfig.class);\n     typeToClassMapping.put(EXTERNALVIEW, ExternalView.class);\n+    typeToClassMapping.put(CUSTOMIZEDVIEW, CustomizedView.class);", "originalCommit": "ed3b93c999cc5aa700a734b48f3a866b69eb1167", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0MTExNQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r389841115", "bodyText": "I looked at the other PR. They are exactly same. I think it makes sense to have both of them and one of us will resolve the conflict before the merge. It might take longer if we submit pre-requisite PR again. I will double check with Meng.", "author": "alirezazamani", "createdAt": "2020-03-09T17:22:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NDMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NzYyNw==", "url": "https://github.com/apache/helix/pull/834#discussion_r388647627", "bodyText": "If _aggregationType is empty, do we need to to the following refresh?", "author": "jiajunwang", "createdAt": "2020-03-06T00:40:21Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -84,13 +104,23 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n       LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n     }\n \n+    if (_sourceDataType.equals(PropertyType.CUSTOMIZEDVIEW) && _propertyDataChangedMap\n+        .get(HelixConstants.ChangeType.CUSTOMIZED_VIEW) && _aggregationType != null) {", "originalCommit": "ed3b93c999cc5aa700a734b48f3a866b69eb1167", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0MTQ2Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r389841467", "bodyText": "Fixed. Thanks.", "author": "alirezazamani", "createdAt": "2020-03-09T17:22:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NzYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0ODUzNw==", "url": "https://github.com/apache/helix/pull/834#discussion_r388648537", "bodyText": "With more cases, using if to check _sourceDataType.equals() does not work well.\nCan we change to use switch-case?", "author": "jiajunwang", "createdAt": "2020-03-06T00:43:18Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -84,13 +104,23 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n       LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n     }\n \n+    if (_sourceDataType.equals(PropertyType.CUSTOMIZEDVIEW) && _propertyDataChangedMap", "originalCommit": "ed3b93c999cc5aa700a734b48f3a866b69eb1167", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg1ODg4MQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r389858881", "bodyText": "Done. Thanks for the suggestion", "author": "alirezazamani", "createdAt": "2020-03-09T17:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0ODUzNw=="}], "type": "inlineReview"}, {"oid": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "url": "https://github.com/apache/helix/commit/78d4faf6adf9d892fd930308fb65ba30c6616f2e", "message": "new review fixes", "committedDate": "2020-03-09T17:49:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MzYzMA==", "url": "https://github.com/apache/helix/pull/834#discussion_r389983630", "bodyText": "What's the usage of this constructor? Can we just have one of them?", "author": "jiajunwang", "createdAt": "2020-03-09T21:55:12Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  private final String _aggregationType;\n+\n+  public CustomizedViewRoutingTable(PropertyType propertyType, String aggregationType) {\n+    this(Collections.<CustomizedView> emptyList(), propertyType, aggregationType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ1NTcyMA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390455720", "bodyText": "Here, I used the same type of constructor that we have in RoutingTable constructor. The code will be more understandable if we keep both of them. Basically one of them has been used to initialize this object and the second one is used for RoutingTableProvider refresh function.", "author": "alirezazamani", "createdAt": "2020-03-10T16:43:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4MzYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NDQxMg==", "url": "https://github.com/apache/helix/pull/834#discussion_r389984412", "bodyText": "This method looks exactly same as \"private void refresh(Collection externalViewList)\".\nCan we do a template class here, and ExternalView/CustomizedView can be the template type.", "author": "jiajunwang", "createdAt": "2020-03-09T21:56:58Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  private final String _aggregationType;\n+\n+  public CustomizedViewRoutingTable(PropertyType propertyType, String aggregationType) {\n+    this(Collections.<CustomizedView> emptyList(), propertyType, aggregationType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      PropertyType propertytype, String aggregationType) {\n+    this(customizedViews, Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertytype, aggregationType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances,\n+      PropertyType propertytype, String aggregationType) {\n+    super(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances,\n+        PropertyType.CUSTOMIZEDVIEW);\n+    _aggregationType = aggregationType;\n+    _customizedViews = new HashSet<>(customizedViews);\n+    refresh(_customizedViews);\n+  }\n+\n+  private void refresh(Collection<CustomizedView> customizedViewList) {", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ3NjMxNw==", "url": "https://github.com/apache/helix/pull/834#discussion_r390476317", "bodyText": "Actually I tried  that at the beginning. However, I decided to go this way. If you look at the refresh implementation they are not exactly same. For example in externalView we have isGroupRoutingEnabled but we do not have such thing for customizedView. Even we do not have this field in CustomizedView Helix property. That is why they look similar but they are kind of different. Please let me know if that answers your question.", "author": "alirezazamani", "createdAt": "2020-03-10T17:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk4NDQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTgwOA==", "url": "https://github.com/apache/helix/pull/834#discussion_r389999808", "bodyText": "I cannot remember what _aggregationType is... This part will need to be commented heavily.", "author": "jiajunwang", "createdAt": "2020-03-09T22:38:04Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,104 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  private final String _aggregationType;", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMTEyOA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390001128", "bodyText": "I guess we call it customizedStateType?", "author": "jiajunwang", "createdAt": "2020-03-09T22:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQ1MTM4Mg==", "url": "https://github.com/apache/helix/pull/834#discussion_r390451382", "bodyText": "Fixed. Change to _customizedStateType as suggested.\nI put several lines of comments to clarify this concept.", "author": "alirezazamani", "createdAt": "2020-03-10T16:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMjE3Mw==", "url": "https://github.com/apache/helix/pull/834#discussion_r390002173", "bodyText": "Maybe throw an exception here.", "author": "jiajunwang", "createdAt": "2020-03-09T22:45:01Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -66,31 +85,46 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n \n     super.refresh(accessor);\n \n-    if (_sourceDataType.equals(PropertyType.TARGETEXTERNALVIEW) && _propertyDataChangedMap\n-        .get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n-      long start = System.currentTimeMillis();\n-      _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n-      _targetExternalViewCache.refresh(accessor);\n-      LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n-          + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n-    }\n-\n-    if (_sourceDataType.equals(PropertyType.CURRENTSTATES) && _propertyDataChangedMap\n-        .get(HelixConstants.ChangeType.CURRENT_STATE)) {\n-      long start = System.currentTimeMillis();\n-      _propertyDataChangedMap.put(HelixConstants.ChangeType.CURRENT_STATE, false);\n-      Map<String, LiveInstance> liveInstanceMap = getLiveInstances();\n-      _currentStateCache.refresh(accessor, liveInstanceMap);\n-      LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+    switch (_sourceDataType) {\n+    case TARGETEXTERNALVIEW:\n+      if (_propertyDataChangedMap.get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n+        long start = System.currentTimeMillis();\n+        _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n+        _targetExternalViewCache.refresh(accessor);\n+        LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n+            + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+      }\n+      break;\n+    case CURRENTSTATES:\n+      if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CURRENT_STATE)) {\n+        long start = System.currentTimeMillis();\n+        _propertyDataChangedMap.put(HelixConstants.ChangeType.CURRENT_STATE, false);\n+        Map<String, LiveInstance> liveInstanceMap = getLiveInstances();\n+        _currentStateCache.refresh(accessor, liveInstanceMap);\n+        LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+      }\n+      break;\n+    case CUSTOMIZEDVIEW:\n+      if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW)\n+          && !_aggregationType.isEmpty()) {\n+        long start = System.currentTimeMillis();\n+        _propertyDataChangedMap.put(HelixConstants.ChangeType.CUSTOMIZED_VIEW, false);\n+        _customizedViewCache.refresh(accessor);\n+        LOG.info(\"Reload \" + _customizedViewCache.getCustomizedViewMap().keySet().size()\n+            + \" CustomizedView. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+      }\n+      break;\n+    default:\n+      break;", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTI5MjM0NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r391292345", "bodyText": "I think we shouldn't throw an exception here. If you look at the original code (without my changes), we do not through an exception and we only refresh for TargettedExternalView and CurrentState. Also since we do not have ExternalView case here, we just want to ignore cases and continue with other propertyTypes.", "author": "alirezazamani", "createdAt": "2020-03-11T22:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMjE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNTI4Mg==", "url": "https://github.com/apache/helix/pull/834#discussion_r390005282", "bodyText": "So based on your usage now, the cache can be a combination of 2 types of data.\n\nthe partition state map\nthe customized view state map\n\nI can see you are trying to keep the assumption that one cache only serves for one type (also customize state type). However, that assumption becomes useless when we need to output snapshot to be a combination.\nSo 2 alternative ways as my suggestion:\n\nSplit the current cache object as you did for CustomizedViewRoutingTable. So they are still one-one mapping.\nOr, make this cache support multiple types, so it is one-one mapping with the RoutingTableProvider.", "author": "jiajunwang", "createdAt": "2020-03-09T22:54:47Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -41,13 +43,30 @@\n   private static Logger LOG = LoggerFactory.getLogger(RoutingDataCache.class.getName());\n \n   private final PropertyType _sourceDataType;\n+  // Aggregation type is used for CustomizedView only.\n+  private final String _aggregationType;\n+\n   private CurrentStateCache _currentStateCache;\n+  private CustomizedViewCache _customizedViewCache;\n   private TargetExternalViewCache _targetExternalViewCache;\n \n+\n   public RoutingDataCache(String clusterName, PropertyType sourceDataType) {", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODY3Mg==", "url": "https://github.com/apache/helix/pull/834#discussion_r390008672", "bodyText": "BTW, option 2 looks easier to me. I will assume this is the option we take for the following comments.", "author": "jiajunwang", "createdAt": "2020-03-09T23:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNTI4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwODM5NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r391308394", "bodyText": "Sure. Fixed.", "author": "alirezazamani", "createdAt": "2020-03-11T22:33:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNTI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNTUzNA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390005534", "bodyText": "comment out of date? There is no _aggregationType.", "author": "jiajunwang", "createdAt": "2020-03-09T22:55:38Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -38,42 +39,62 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n-  private final Collection<InstanceConfig> _instanceConfigs;\n+  protected final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n \n+  private final PropertyType _propertyType;\n+\n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  /**\n+   * Initialize empty RoutingTable and set _propertyType and _aggregationType fields.", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMDY5Mw==", "url": "https://github.com/apache/helix/pull/834#discussion_r391310693", "bodyText": "Fixed.", "author": "alirezazamani", "createdAt": "2020-03-11T22:40:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNTUzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNjU4MA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390006580", "bodyText": "Protected?", "author": "jiajunwang", "createdAt": "2020-03-09T22:58:53Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -38,42 +39,62 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n-  private final Collection<InstanceConfig> _instanceConfigs;\n+  protected final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n \n+  private final PropertyType _propertyType;\n+\n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  /**\n+   * Initialize empty RoutingTable and set _propertyType and _aggregationType fields.\n+   * @param propertyType\n+   */\n+  public RoutingTable(PropertyType propertyType) {", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMTM3NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r391311374", "bodyText": "Fixed.", "author": "alirezazamani", "createdAt": "2020-03-11T22:42:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNjU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNjg2Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r390006867", "bodyText": "Is this one deprecated?", "author": "jiajunwang", "createdAt": "2020-03-09T22:59:46Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -38,42 +39,62 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n-  private final Collection<InstanceConfig> _instanceConfigs;\n+  protected final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n \n+  private final PropertyType _propertyType;\n+\n   public RoutingTable() {", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMTk4NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r391311984", "bodyText": "Ok. Deprecated this method.", "author": "alirezazamani", "createdAt": "2020-03-11T22:43:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNjg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODIzOA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390008238", "bodyText": "Return something constant like \"HELIX_DEFAULT\"", "author": "jiajunwang", "createdAt": "2020-03-09T23:03:45Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -351,6 +372,23 @@ ResourceGroupInfo getResourceGroup(String resourceGroupName) {\n     return Collections.unmodifiableCollection(_externalViews);\n   }\n \n+  /**\n+   * Returns PropertyTYpe\n+   * @return the PropertyTYpe of this RoutingTable\n+   */\n+  protected PropertyType getPropertyType() {\n+    return _propertyType;\n+  }\n+\n+  /**\n+   * Returns AggregationType\n+   * @return the AggregationType of this RoutingTable (Used for CustomizedView)\n+   */\n+  protected String getAggregationType() {\n+    return \"\";", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMzg4NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r391313885", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-11T22:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODM0NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r390008345", "bodyText": "_routingTableRefMap", "author": "jiajunwang", "createdAt": "2020-03-09T23:04:06Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -64,15 +67,15 @@\n \n public class RoutingTableProvider\n     implements ExternalViewChangeListener, InstanceConfigChangeListener, ConfigChangeListener,\n-    LiveInstanceChangeListener, CurrentStateChangeListener {\n+    LiveInstanceChangeListener, CurrentStateChangeListener, CustomizedViewChangeListener {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTableProvider.class);\n   private static final long DEFAULT_PERIODIC_REFRESH_INTERVAL = 300000L; // 5 minutes\n-  private final AtomicReference<RoutingTable> _routingTableRef;\n+  private final Map<String, AtomicReference<RoutingTable>> _routingTableRef;", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTMzOQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r391315339", "bodyText": "Good suggestion. Fixed.", "author": "alirezazamani", "createdAt": "2020-03-11T22:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODM0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODQ3Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r390008476", "bodyText": "Better to be one updater fand one cache inside.", "author": "jiajunwang", "createdAt": "2020-03-09T23:04:28Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -64,15 +67,15 @@\n \n public class RoutingTableProvider\n     implements ExternalViewChangeListener, InstanceConfigChangeListener, ConfigChangeListener,\n-    LiveInstanceChangeListener, CurrentStateChangeListener {\n+    LiveInstanceChangeListener, CurrentStateChangeListener, CustomizedViewChangeListener {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTableProvider.class);\n   private static final long DEFAULT_PERIODIC_REFRESH_INTERVAL = 300000L; // 5 minutes\n-  private final AtomicReference<RoutingTable> _routingTableRef;\n+  private final Map<String, AtomicReference<RoutingTable>> _routingTableRef;\n   private final HelixManager _helixManager;\n-  private final RouterUpdater _routerUpdater;\n-  private final PropertyType _sourceDataType;\n+  private final Map<String, RouterUpdater> _routerUpdater;", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNTQzMw==", "url": "https://github.com/apache/helix/pull/834#discussion_r391315433", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-11T22:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODg3OQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r390008879", "bodyText": "_monitorMap", "author": "jiajunwang", "createdAt": "2020-03-09T23:05:48Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -64,15 +67,15 @@\n \n public class RoutingTableProvider\n     implements ExternalViewChangeListener, InstanceConfigChangeListener, ConfigChangeListener,\n-    LiveInstanceChangeListener, CurrentStateChangeListener {\n+    LiveInstanceChangeListener, CurrentStateChangeListener, CustomizedViewChangeListener {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTableProvider.class);\n   private static final long DEFAULT_PERIODIC_REFRESH_INTERVAL = 300000L; // 5 minutes\n-  private final AtomicReference<RoutingTable> _routingTableRef;\n+  private final Map<String, AtomicReference<RoutingTable>> _routingTableRef;\n   private final HelixManager _helixManager;\n-  private final RouterUpdater _routerUpdater;\n-  private final PropertyType _sourceDataType;\n+  private final Map<String, RouterUpdater> _routerUpdater;\n+  private final Map<PropertyType, List<String>> _sourceDataTypes;\n   private final Map<RoutingTableChangeListener, ListenerContext> _routingTableChangeListenerMap;\n-  private final RoutingTableProviderMonitor _monitor;\n+  private final Map<PropertyType, RoutingTableProviderMonitor> _monitor;", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNjAwNA==", "url": "https://github.com/apache/helix/pull/834#discussion_r391316004", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-11T22:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODk0OQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r390008949", "bodyText": "_sourceDataTypeMap", "author": "jiajunwang", "createdAt": "2020-03-09T23:05:56Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -64,15 +67,15 @@\n \n public class RoutingTableProvider\n     implements ExternalViewChangeListener, InstanceConfigChangeListener, ConfigChangeListener,\n-    LiveInstanceChangeListener, CurrentStateChangeListener {\n+    LiveInstanceChangeListener, CurrentStateChangeListener, CustomizedViewChangeListener {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTableProvider.class);\n   private static final long DEFAULT_PERIODIC_REFRESH_INTERVAL = 300000L; // 5 minutes\n-  private final AtomicReference<RoutingTable> _routingTableRef;\n+  private final Map<String, AtomicReference<RoutingTable>> _routingTableRef;\n   private final HelixManager _helixManager;\n-  private final RouterUpdater _routerUpdater;\n-  private final PropertyType _sourceDataType;\n+  private final Map<String, RouterUpdater> _routerUpdater;\n+  private final Map<PropertyType, List<String>> _sourceDataTypes;", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxNzcxOA==", "url": "https://github.com/apache/helix/pull/834#discussion_r391317718", "bodyText": "Fixed.", "author": "alirezazamani", "createdAt": "2020-03-11T23:00:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwODk0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMDk4Mg==", "url": "https://github.com/apache/helix/pull/834#discussion_r390010982", "bodyText": "nit, Make this a private method?\nAnd maybe we can simplify it little bit. I understand this is for clearly log the error. But we can also put the error message more briefly and log the type/path details in the error log so we can debug.", "author": "jiajunwang", "createdAt": "2020-03-09T23:12:19Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,61 +115,131 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypes\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypes, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    // Check and validate the input of the sourceDataTypes parameter\n+    for (PropertyType propertyType : sourceDataTypes.keySet()) {\n+      if (propertyType.equals(PropertyType.CUSTOMIZEDVIEW)", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyMjQ2NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r391322464", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-11T23:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMDk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTY4Mg==", "url": "https://github.com/apache/helix/pull/834#discussion_r390011682", "bodyText": "This should be default string as well.", "author": "jiajunwang", "createdAt": "2020-03-09T23:14:24Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,61 +115,131 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypes\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypes, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    // Check and validate the input of the sourceDataTypes parameter\n+    for (PropertyType propertyType : sourceDataTypes.keySet()) {\n+      if (propertyType.equals(PropertyType.CUSTOMIZEDVIEW)\n+          && sourceDataTypes.get(propertyType).size() == 0) {\n+        logger.error(\"CustomizedView has been used without any aggregation type!\");\n+        throw new HelixException(\"CustomizedView has been used without any aggregation type!\");\n+      }\n+      if (!propertyType.equals(PropertyType.CUSTOMIZEDVIEW)\n+          && sourceDataTypes.get(propertyType).size() != 0) {\n+        logger.error(\"Type has been used in addition to the property type {} !\",\n+            propertyType.name());\n+        throw new HelixException(String.format(\n+            \"Type has been used in addition to the property type %s !\", propertyType.name()));\n+      }\n+    }\n+\n+    _routingTableRef = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _routerUpdater = new HashMap<>();\n+    _sourceDataTypes = sourceDataTypes;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _monitor = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypes.keySet()) {\n+      _monitor.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitor.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypes.keySet()) {\n+      if (_sourceDataTypes.get(propertyType).size() == 0) {\n+        // Empty aggregationType\n+        String aggregationType = \"\";", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxODIzMQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r391318231", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-11T23:01:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMjMwNA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390012304", "bodyText": "This can be combined to a method together with the previous condition's code. And, actually, I suggest to put this logic into routerUpdater. And make the routerUpdater support multiple types.", "author": "jiajunwang", "createdAt": "2020-03-09T23:16:21Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,61 +115,131 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypes\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypes, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    // Check and validate the input of the sourceDataTypes parameter\n+    for (PropertyType propertyType : sourceDataTypes.keySet()) {\n+      if (propertyType.equals(PropertyType.CUSTOMIZEDVIEW)\n+          && sourceDataTypes.get(propertyType).size() == 0) {\n+        logger.error(\"CustomizedView has been used without any aggregation type!\");\n+        throw new HelixException(\"CustomizedView has been used without any aggregation type!\");\n+      }\n+      if (!propertyType.equals(PropertyType.CUSTOMIZEDVIEW)\n+          && sourceDataTypes.get(propertyType).size() != 0) {\n+        logger.error(\"Type has been used in addition to the property type {} !\",\n+            propertyType.name());\n+        throw new HelixException(String.format(\n+            \"Type has been used in addition to the property type %s !\", propertyType.name()));\n+      }\n+    }\n+\n+    _routingTableRef = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _routerUpdater = new HashMap<>();\n+    _sourceDataTypes = sourceDataTypes;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _monitor = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypes.keySet()) {\n+      _monitor.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitor.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypes.keySet()) {\n+      if (_sourceDataTypes.get(propertyType).size() == 0) {\n+        // Empty aggregationType\n+        String aggregationType = \"\";\n+        String key = propertyType.name() + \"_\" + aggregationType;\n+        if (_routerUpdater.get(key) == null) {\n+          _routerUpdater.put(key, new RouterUpdater(clusterName, propertyType, aggregationType, key));\n+          _routerUpdater.get(key).start();\n+          _routingTableRef.put(key, new AtomicReference<>(new RoutingTable(propertyType)));\n         }\n-\n-        try {\n-          _helixManager.addTargetExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach TargetExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach TargetExternalView Listener to HelixManager!\",\n-              e);\n+      } else {\n+        for (String aggregationType : _sourceDataTypes.get(propertyType)) {\n+          String key = propertyType.name() + \"_\" + aggregationType;", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyMTYyNg==", "url": "https://github.com/apache/helix/pull/834#discussion_r391321626", "bodyText": "I move as much as I could to the RouterUpdater. the key has been used to _routingTableRefMap now here. Now routerUpdater supports multiple types.", "author": "alirezazamani", "createdAt": "2020-03-11T23:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMjMwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzU4Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r390013587", "bodyText": "I would suggest making the return more comprehensive.\nMap<String (path), Map<String (type), RoutingTableSnapshot>>", "author": "jiajunwang", "createdAt": "2020-03-09T23:20:29Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -237,7 +332,42 @@ public void shutdown() {\n    * @return snapshot of current routing table.\n    */\n   public RoutingTableSnapshot getRoutingTableSnapshot() {\n-    return new RoutingTableSnapshot(_routingTableRef.get());\n+      String key = getRoutingTableKey();\n+      return new RoutingTableSnapshot(_routingTableRef.get(key).get());\n+  }\n+\n+  /**\n+   * Get an snapshot of current RoutingTable information for specific PropertyType.\n+   * The snapshot is immutable, it reflects the routing table information at the time this method is\n+   * called.\n+   * @return snapshot of current routing table.\n+   */\n+  public RoutingTableSnapshot getRoutingTableSnapshot (PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return new RoutingTableSnapshot(_routingTableRef.get(key).get());\n+  }\n+\n+  /**\n+   * Get an snapshot of all of the available RoutingTable information. The snapshot is immutable, it\n+   * reflects the routing table information at the time this method is called.\n+   * @return snapshot associated with specific propertyType and type.\n+   */\n+  public RoutingTableSnapshot getRoutingTableSnapshot(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return new RoutingTableSnapshot(_routingTableRef.get(key).get());\n+  }\n+\n+  /**\n+   * Get an snapshot of all of the available RoutingTable information. The snapshot is immutable, it\n+   * reflects the routing table information at the time this method is called.\n+   * @return all of the available snapshots of current routing table.\n+   */\n+  public Map<String, RoutingTableSnapshot> getRoutingTableSnapshots() {", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMyOTUzNQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r391329535", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-11T23:38:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzgyMQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r390013821", "bodyText": "Are we support customize state reverse search? If not in the design, let's hold this for now.", "author": "jiajunwang", "createdAt": "2020-03-09T23:21:13Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -279,6 +409,16 @@ public Object removeRoutingTableChangeListener(\n     return getInstancesForResource(resourceName, partitionName, state);\n   }\n \n+  public List<InstanceConfig> getInstances(String resourceName, String partitionName, String state,", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMTI3Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r391331277", "bodyText": "Removed.", "author": "alirezazamani", "createdAt": "2020-03-11T23:44:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAwMjM0OQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r394002349", "bodyText": "Removed?", "author": "jiajunwang", "createdAt": "2020-03-17T22:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzgyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMjc5NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r395312795", "bodyText": "Now removed.", "author": "alirezazamani", "createdAt": "2020-03-19T20:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzg4OA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390013888", "bodyText": "Same here. If not in the design, let's hold this for now.", "author": "jiajunwang", "createdAt": "2020-03-09T23:21:26Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -290,7 +430,23 @@ public Object removeRoutingTableChangeListener(\n    */\n   public List<InstanceConfig> getInstancesForResource(String resourceName, String partitionName,\n       String state) {\n-    return _routingTableRef.get().getInstancesForResource(resourceName, partitionName, state);\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResource(resourceName, partitionName,\n+        state);\n+  }\n+\n+  public List<InstanceConfig> getInstancesForResource(String resourceName, String partitionName,", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMTQ1MQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r391331451", "bodyText": "Removed.", "author": "alirezazamani", "createdAt": "2020-03-11T23:44:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzg4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzk0NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r390013945", "bodyText": "Same here. If not in the design, let's hold this for now.", "author": "jiajunwang", "createdAt": "2020-03-09T23:21:36Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -305,8 +461,23 @@ public Object removeRoutingTableChangeListener(\n    */\n   public List<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName,\n       String partitionName, String state) {\n-    return _routingTableRef.get().getInstancesForResourceGroup(resourceGroupName, partitionName,\n-        state);\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResourceGroup(resourceGroupName,\n+        partitionName, state);\n+  }\n+\n+  public List<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName,", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMjA3MQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r391332071", "bodyText": "Removed.", "author": "alirezazamani", "createdAt": "2020-03-11T23:46:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzk0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDAwNg==", "url": "https://github.com/apache/helix/pull/834#discussion_r390014006", "bodyText": "Same here. If not in the design, let's hold this for now.", "author": "jiajunwang", "createdAt": "2020-03-09T23:21:49Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -322,8 +493,24 @@ public Object removeRoutingTableChangeListener(\n    */\n   public List<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName,\n       String partitionName, String state, List<String> resourceTags) {\n-    return _routingTableRef.get().getInstancesForResourceGroup(resourceGroupName, partitionName,\n-        state, resourceTags);\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResourceGroup(resourceGroupName,\n+        partitionName, state, resourceTags);\n+  }\n+\n+  public List<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName,", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMjE2NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r391332164", "bodyText": "Removed.", "author": "alirezazamani", "createdAt": "2020-03-11T23:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDAzOA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390014038", "bodyText": "Same here. If not in the design, let's hold this for now.", "author": "jiajunwang", "createdAt": "2020-03-09T23:21:55Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -338,14 +525,37 @@ public Object removeRoutingTableChangeListener(\n     return getInstancesForResource(resourceName, state);\n   }\n \n+  public Set<InstanceConfig> getInstances(String resourceName, String state,", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMjQ5Mg==", "url": "https://github.com/apache/helix/pull/834#discussion_r391332492", "bodyText": "removed.", "author": "alirezazamani", "createdAt": "2020-03-11T23:48:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAwMjIxOQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r394002219", "bodyText": "Just to confirm that, are we going to remove it or not? This one is duplicate to getInstancesForResource.", "author": "jiajunwang", "createdAt": "2020-03-17T22:17:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDAzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxNjkyMw==", "url": "https://github.com/apache/helix/pull/834#discussion_r395316923", "bodyText": "Removed this method and other newly added public methods based in propertyType and stateType", "author": "alirezazamani", "createdAt": "2020-03-19T21:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDA4MA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390014080", "bodyText": "Same here. If not in the design, let's hold this for now.", "author": "jiajunwang", "createdAt": "2020-03-09T23:22:00Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -338,14 +525,37 @@ public Object removeRoutingTableChangeListener(\n     return getInstancesForResource(resourceName, state);\n   }\n \n+  public Set<InstanceConfig> getInstances(String resourceName, String state,\n+      PropertyType propertyType) {\n+    return getInstancesForResource(resourceName, state, propertyType);\n+  }\n+\n+  public Set<InstanceConfig> getInstances(String resourceName, String state,\n+      PropertyType propertyType, String type) {\n+    return getInstancesForResource(resourceName, state, propertyType, type);\n+  }\n+\n   /**\n    * returns all instances for {resource} that are in a specific {state}.\n    * @param resourceName\n    * @param state\n    * @return empty list if there is no instance in a given state\n    */\n   public Set<InstanceConfig> getInstancesForResource(String resourceName, String state) {\n-    return _routingTableRef.get().getInstancesForResource(resourceName, state);\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResource(resourceName, state);\n+  }\n+\n+  public Set<InstanceConfig> getInstancesForResource(String resourceName, String state,", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMjYxMQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r391332611", "bodyText": "removed.", "author": "alirezazamani", "createdAt": "2020-03-11T23:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDEwOA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390014108", "bodyText": "Same here. If not in the design, let's hold this for now.", "author": "jiajunwang", "createdAt": "2020-03-09T23:22:07Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -355,7 +565,20 @@ public Object removeRoutingTableChangeListener(\n    * @return empty list if there is no instance in a given state\n    */\n   public Set<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName, String state) {\n-    return _routingTableRef.get().getInstancesForResourceGroup(resourceGroupName, state);\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResourceGroup(resourceGroupName, state);\n+  }\n+\n+  public Set<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName, String state,", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMjczNg==", "url": "https://github.com/apache/helix/pull/834#discussion_r391332736", "bodyText": "Removed.", "author": "alirezazamani", "createdAt": "2020-03-11T23:49:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDEzNA==", "url": "https://github.com/apache/helix/pull/834#discussion_r390014134", "bodyText": "Same here. If not in the design, let's hold this for now.", "author": "jiajunwang", "createdAt": "2020-03-09T23:22:13Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -367,7 +590,22 @@ public Object removeRoutingTableChangeListener(\n    */\n   public Set<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName, String state,\n       List<String> resourceTags) {\n-    return _routingTableRef.get().getInstancesForResourceGroup(resourceGroupName, state,\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstancesForResourceGroup(resourceGroupName, state,\n+        resourceTags);\n+  }\n+\n+  public Set<InstanceConfig> getInstancesForResourceGroup(String resourceGroupName, String state,", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzMjg1Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r391332857", "bodyText": "Removed.", "author": "alirezazamani", "createdAt": "2020-03-11T23:49:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDMxMQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r390014311", "bodyText": "This, I don't understand. Why live instance would be different with different state?", "author": "jiajunwang", "createdAt": "2020-03-09T23:22:43Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,62 +614,158 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType) {", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzNTA1NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r391335054", "bodyText": "Ok I picked one of the keys and merge all of them to one API.", "author": "alirezazamani", "createdAt": "2020-03-11T23:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDUxMg==", "url": "https://github.com/apache/helix/pull/834#discussion_r390014512", "bodyText": "Same here, instance config would be different with a different type?", "author": "jiajunwang", "createdAt": "2020-03-09T23:23:22Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,62 +614,158 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType) {", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzNTE1MQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r391335151", "bodyText": "Removed this method.", "author": "alirezazamani", "createdAt": "2020-03-11T23:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDUxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2NDkxNQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r391764915", "bodyText": "Ok I picked one of the keys and merge all of them to one API.", "author": "alirezazamani", "createdAt": "2020-03-12T17:05:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDU1NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r390014555", "bodyText": "Same here.", "author": "jiajunwang", "createdAt": "2020-03-09T23:23:32Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,62 +614,158 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n    * Return names of all resources (shown in ExternalView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType) {", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMzNDM0NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r391334344", "bodyText": "Removed.", "author": "alirezazamani", "createdAt": "2020-03-11T23:54:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDg2Mw==", "url": "https://github.com/apache/helix/pull/834#discussion_r390014863", "bodyText": "Just keep this one. For the other 2 usages, just merge the check logic inside here. Put default values in the caller if necessary.", "author": "jiajunwang", "createdAt": "2020-03-09T23:24:28Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,62 +614,158 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n+  }\n+\n+  public Collection<LiveInstance> getLiveInstances(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n+  }\n+\n+  public Collection<InstanceConfig> getInstanceConfigs(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n    * Return names of all resources (shown in ExternalView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey();\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType) {\n+    String key = getRoutingTableKey(propertyType);\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType, type);\n+    return _routingTableRef.get(key).get().getResources();\n+  }\n+\n+  /**\n+   * Function that returns the key associated with the specific _routingTableRef\n+   * @return\n+   */\n+  private String getRoutingTableKey() {\n+    // Check whether there exist only one snapshot (_routingTableRef)\n+    if (_routingTableRef.keySet().size() == 1) {\n+      return _routingTableRef.keySet().iterator().next();\n+    } else {\n+      throw new HelixException(\"There is none or more than one RoutingTableSnapshot\");\n+    }\n+  }\n+\n+  private String getRoutingTableKey(PropertyType propertyType) {\n+    if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+      throw new HelixException(\"Specific type needs to be used for CUSTOMIZEDVIEW PropertyType\");\n+    } else {\n+      return getRoutingTableKey(propertyType, \"\");\n+    }\n+  }\n+\n+  private String getRoutingTableKey(PropertyType propertyType, String aggregationType) {", "originalCommit": "78d4faf6adf9d892fd930308fb65ba30c6616f2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTc2MzU0NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r391763544", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-12T17:03:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNDg2Mw=="}], "type": "inlineReview"}, {"oid": "24990ea51b35660e0862cee735c24d9bd3694e32", "url": "https://github.com/apache/helix/commit/24990ea51b35660e0862cee735c24d9bd3694e32", "message": "Complete the Routing Table Provider for CustomizedView\n\nIn this commit, the routing table provider has been changed in a way\nto include customized view feature.", "committedDate": "2020-03-12T18:23:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODk1Mw==", "url": "https://github.com/apache/helix/pull/834#discussion_r392518953", "bodyText": "customizedState?", "author": "jiajunwang", "createdAt": "2020-03-13T22:51:22Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  /*\n+   * The customizedStateType field is the type the controller is aggregating.\n+   * For example if RoutingTableProvider initialized using the code below:\n+   * Map<PropertyType, List<String>> sourceDataTypes = new HashMap<>();\n+   * sourceDataTypes.put(PropertyType.CUSTOMIZEDVIEW, Arrays.asList(\"typeA\", \"typeB\"));\n+   * RoutingTableProvider routingTableProvider =\n+   * new RoutingTableProvider(_spectator, sourceDataTypes);\n+   *\n+   * Each one of the TypeA and TypeB is a customizedStateType.\n+   */\n+  private final String _customizedStateType;\n+\n+  public CustomizedViewRoutingTable(PropertyType propertyType, String customizedStateType) {\n+    this(Collections.<CustomizedView> emptyList(), propertyType, customizedStateType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      PropertyType propertytype, String customizedStateType) {\n+    this(customizedViews, Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertytype, customizedStateType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances,\n+      PropertyType propertytype, String customizedStateType) {\n+    super(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances,\n+        PropertyType.CUSTOMIZEDVIEW);\n+    _customizedStateType = customizedStateType;\n+    _customizedViews = new HashSet<>(customizedViews);\n+    refresh(_customizedViews);\n+  }\n+\n+  private void refresh(Collection<CustomizedView> customizedViewList) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    if (customizedViewList != null && !customizedViewList.isEmpty()) {\n+      for (InstanceConfig config : _instanceConfigs) {\n+        instanceConfigMap.put(config.getId(), config);\n+      }\n+      for (CustomizedView customView : customizedViewList) {\n+        String resourceName = customView.getId();\n+        for (String partitionName : customView.getPartitionSet()) {\n+          Map<String, String> stateMap = customView.getStateMap(partitionName);\n+          for (String instanceName : stateMap.keySet()) {\n+            String currentState = stateMap.get(instanceName);", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwODI3NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392608274", "bodyText": "Fixed.", "author": "alirezazamani", "createdAt": "2020-03-14T18:20:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxODk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxOTQxNg==", "url": "https://github.com/apache/helix/pull/834#discussion_r392519416", "bodyText": "Let's add a TODO there. Once we migrate all cache to propetyCache, this hardcoded list of fields won't be necessary.", "author": "jiajunwang", "createdAt": "2020-03-13T22:53:22Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -40,14 +47,29 @@\n class RoutingDataCache extends BasicClusterDataCache {\n   private static Logger LOG = LoggerFactory.getLogger(RoutingDataCache.class.getName());\n \n-  private final PropertyType _sourceDataType;\n+  private final Map<PropertyType, List<String>> _sourceDataTypeMap;\n+\n   private CurrentStateCache _currentStateCache;", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwODU3OQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r392608579", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-14T18:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUxOTQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDAwMA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392520000", "bodyText": "This could be outside the loop?", "author": "jiajunwang", "createdAt": "2020-03-13T22:56:01Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -65,32 +87,55 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     long startTime = System.currentTimeMillis();\n \n     super.refresh(accessor);\n-\n-    if (_sourceDataType.equals(PropertyType.TARGETEXTERNALVIEW) && _propertyDataChangedMap\n-        .get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n-      long start = System.currentTimeMillis();\n-      _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n-      _targetExternalViewCache.refresh(accessor);\n-      LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n-          + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      switch (propertyType) {\n+      case TARGETEXTERNALVIEW:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n+          _targetExternalViewCache.refresh(accessor);\n+          LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n+              + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CURRENTSTATES:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CURRENT_STATE)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.CURRENT_STATE, false);\n+          Map<String, LiveInstance> liveInstanceMap = getLiveInstances();\n+          _currentStateCache.refresh(accessor, liveInstanceMap);\n+          LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CUSTOMIZEDVIEW: {\n+        for (String customizedStateType : _sourceDataTypeMap.get(PropertyType.CUSTOMIZEDVIEW)) {\n+          if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW)) {", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwODc0Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r392608746", "bodyText": "Sure.", "author": "alirezazamani", "createdAt": "2020-03-14T18:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDUyMA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392520520", "bodyText": "This can be out of the switch block to reduce code.", "author": "jiajunwang", "createdAt": "2020-03-13T22:58:22Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -65,32 +87,55 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     long startTime = System.currentTimeMillis();\n \n     super.refresh(accessor);\n-\n-    if (_sourceDataType.equals(PropertyType.TARGETEXTERNALVIEW) && _propertyDataChangedMap\n-        .get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n-      long start = System.currentTimeMillis();\n-      _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n-      _targetExternalViewCache.refresh(accessor);\n-      LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n-          + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      switch (propertyType) {\n+      case TARGETEXTERNALVIEW:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n+          _targetExternalViewCache.refresh(accessor);\n+          LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n+              + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CURRENTSTATES:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CURRENT_STATE)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.CURRENT_STATE, false);\n+          Map<String, LiveInstance> liveInstanceMap = getLiveInstances();\n+          _currentStateCache.refresh(accessor, liveInstanceMap);\n+          LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CUSTOMIZEDVIEW: {\n+        for (String customizedStateType : _sourceDataTypeMap.get(PropertyType.CUSTOMIZEDVIEW)) {\n+          if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW)) {\n+            long start = System.currentTimeMillis();", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwOTQ5Mw==", "url": "https://github.com/apache/helix/pull/834#discussion_r392609493", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-14T18:37:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDUyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDY3OA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392520678", "bodyText": "Also, this log should be able to move out if we add some local vars for the log info.", "author": "jiajunwang", "createdAt": "2020-03-13T22:59:01Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -65,32 +87,55 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     long startTime = System.currentTimeMillis();\n \n     super.refresh(accessor);\n-\n-    if (_sourceDataType.equals(PropertyType.TARGETEXTERNALVIEW) && _propertyDataChangedMap\n-        .get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n-      long start = System.currentTimeMillis();\n-      _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n-      _targetExternalViewCache.refresh(accessor);\n-      LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n-          + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      switch (propertyType) {\n+      case TARGETEXTERNALVIEW:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.TARGET_EXTERNAL_VIEW, false);\n+          _targetExternalViewCache.refresh(accessor);\n+          LOG.info(\"Reload \" + _targetExternalViewCache.getExternalViewMap().keySet().size()\n+              + \" TargetExternalViews. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CURRENTSTATES:\n+        if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CURRENT_STATE)) {\n+          long start = System.currentTimeMillis();\n+          _propertyDataChangedMap.put(HelixConstants.ChangeType.CURRENT_STATE, false);\n+          Map<String, LiveInstance> liveInstanceMap = getLiveInstances();\n+          _currentStateCache.refresh(accessor, liveInstanceMap);\n+          LOG.info(\"Reload CurrentStates. Takes \" + (System.currentTimeMillis() - start) + \" ms\");\n+        }\n+        break;\n+      case CUSTOMIZEDVIEW: {\n+        for (String customizedStateType : _sourceDataTypeMap.get(PropertyType.CUSTOMIZEDVIEW)) {\n+          if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW)) {\n+            long start = System.currentTimeMillis();\n+            _customizedViewCaches.get(customizedStateType).refresh(accessor);\n+            LOG.info(\"Reload \"", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYwOTUwNw==", "url": "https://github.com/apache/helix/pull/834#discussion_r392609507", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-14T18:38:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDk5NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392520994", "bodyText": "Check null. The caller might pass an unknown type.", "author": "jiajunwang", "createdAt": "2020-03-13T23:00:24Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -103,6 +148,14 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     return _targetExternalViewCache.getExternalViewMap();\n   }\n \n+  /**\n+   * Retrieves the CustomizedView for all resources\n+   * @return\n+   */\n+  public Map<String, CustomizedView> getCustomizedView(String customizedStateType) {\n+    return _customizedViewCaches.get(customizedStateType).getCustomizedViewMap();", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYxMDA2Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r392610066", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-14T18:45:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMDk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMTc0NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392521744", "bodyText": "Add a TODO here, we really need to refactor these constructors.", "author": "jiajunwang", "createdAt": "2020-03-13T23:03:42Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -38,42 +39,63 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * A class to consume ExternalViews of a cluster and provide {resource, partition, state} to\n- * {instances} map function.\n+ * A class to consume ExternalViews or CustomizedViews of a cluster and provide\n+ * {resource, partition, state} to {instances} map function.\n  */\n class RoutingTable {\n   private static final Logger logger = LoggerFactory.getLogger(RoutingTable.class);\n \n   // mapping a resourceName to the ResourceInfo\n   private final Map<String, ResourceInfo> _resourceInfoMap;\n+\n   // mapping a resource group name to a resourceGroupInfo\n   private final Map<String, ResourceGroupInfo> _resourceGroupInfoMap;\n \n   private final Collection<LiveInstance> _liveInstances;\n-  private final Collection<InstanceConfig> _instanceConfigs;\n+  protected final Collection<InstanceConfig> _instanceConfigs;\n   private final Collection<ExternalView> _externalViews;\n \n+  private final PropertyType _propertyType;\n+\n+  @Deprecated\n   public RoutingTable() {\n     this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n         Collections.<LiveInstance> emptyList());\n   }\n \n+  /**\n+   * Initialize empty RoutingTable and set _propertyType fields.\n+   * @param propertyType\n+   */\n+  protected RoutingTable(PropertyType propertyType) {\n+    this(Collections.<ExternalView> emptyList(), Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertyType);\n+  }\n+\n   public RoutingTable(Map<String, Map<String, Map<String, CurrentState>>> currentStateMap,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n     // TODO Aggregate currentState to an ExternalView in the RoutingTable, so there is no need to\n     // refresh according to the currentStateMap. - jjwang\n-    this(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances);\n+    this(Collections.<ExternalView> emptyList(),\n+        instanceConfigs, liveInstances, PropertyType.CURRENTSTATES);\n     refresh(currentStateMap);\n   }\n \n   public RoutingTable(Collection<ExternalView> externalViews,\n       Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+    this(externalViews, instanceConfigs, liveInstances,\n+        PropertyType.EXTERNALVIEW);\n+  }\n+\n+  protected RoutingTable(Collection<ExternalView> externalViews, Collection<InstanceConfig> instanceConfigs,", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMjA0NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392522044", "bodyText": "And try to make it private if possible.", "author": "jiajunwang", "createdAt": "2020-03-13T23:05:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMTc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYxMDUzMg==", "url": "https://github.com/apache/helix/pull/834#discussion_r392610532", "bodyText": "Added todo.", "author": "alirezazamani", "createdAt": "2020-03-14T18:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMTc0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYxMDYzNQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r392610635", "bodyText": "Since we use this constructor in RT provider, private is not quite possible.", "author": "alirezazamani", "createdAt": "2020-03-14T18:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMTc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMjQ4NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392522484", "bodyText": "Make it more generic, getStateType(). Every state can refer to this type.", "author": "jiajunwang", "createdAt": "2020-03-13T23:06:34Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTable.java", "diffHunk": "@@ -351,6 +373,23 @@ ResourceGroupInfo getResourceGroup(String resourceGroupName) {\n     return Collections.unmodifiableCollection(_externalViews);\n   }\n \n+  /**\n+   * Returns PropertyTYpe\n+   * @return the PropertyTYpe of this RoutingTable\n+   */\n+  protected PropertyType getPropertyType() {\n+    return _propertyType;\n+  }\n+\n+  /**\n+   * Returns CustomizedStateType\n+   * @return the CustomizedStateType of this RoutingTable (Used for CustomizedView)\n+   */\n+  protected String getCustomizedStateType() {", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYxMDkxOA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392610918", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-14T18:57:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyMjQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNDk0MA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392524940", "bodyText": "nit, Some common logic could be merged. We can set the local vars and finish the _routingTableRefMap set up after the condition check.", "author": "jiajunwang", "createdAt": "2020-03-13T23:18:26Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,61 +120,113 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypeMap\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypeMap, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    validateSourceDataTypeMap(sourceDataTypeMap);\n+\n+    _routingTableRefMap = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _routerUpdater = new RouterUpdater(clusterName, sourceDataTypeMap);\n+    _routerUpdater.start();\n+    _monitorMap = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      _monitorMap.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitorMap.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      if (_sourceDataTypeMap.get(propertyType).size() == 0) {\n+        // Empty CustomizedStateType\n+        String customizedStateType = DEFAULT_TYPE;\n+        String key = propertyType.name() + \"_\" + customizedStateType;\n+        if (_routingTableRefMap.get(key) == null) {\n+          _routingTableRefMap.put(key, new AtomicReference<>(new RoutingTable(propertyType)));\n         }\n-\n-        try {\n-          _helixManager.addTargetExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach TargetExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach TargetExternalView Listener to HelixManager!\",\n-              e);\n+      } else {\n+        for (String customizedStateType : _sourceDataTypeMap.get(propertyType)) {\n+          String key = propertyType.name() + \"_\" + customizedStateType;", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyMTQzMQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r393321431", "bodyText": "I moved the key generation to a private method. I think it is simpler and easier to understand now. Let me know if further change is needed.", "author": "alirezazamani", "createdAt": "2020-03-16T21:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNDk0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTEwNw==", "url": "https://github.com/apache/helix/pull/834#discussion_r392525107", "bodyText": "nit, can we move this block to a private method?", "author": "jiajunwang", "createdAt": "2020-03-13T23:19:10Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,61 +120,113 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypeMap\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypeMap, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    validateSourceDataTypeMap(sourceDataTypeMap);\n+\n+    _routingTableRefMap = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _routerUpdater = new RouterUpdater(clusterName, sourceDataTypeMap);\n+    _routerUpdater.start();\n+    _monitorMap = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      _monitorMap.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitorMap.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      if (_sourceDataTypeMap.get(propertyType).size() == 0) {\n+        // Empty CustomizedStateType\n+        String customizedStateType = DEFAULT_TYPE;\n+        String key = propertyType.name() + \"_\" + customizedStateType;\n+        if (_routingTableRefMap.get(key) == null) {\n+          _routingTableRefMap.put(key, new AtomicReference<>(new RoutingTable(propertyType)));\n         }\n-\n-        try {\n-          _helixManager.addTargetExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach TargetExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach TargetExternalView Listener to HelixManager!\",\n-              e);\n+      } else {\n+        for (String customizedStateType : _sourceDataTypeMap.get(propertyType)) {\n+          String key = propertyType.name() + \"_\" + customizedStateType;\n+          if (_routingTableRefMap.get(key) == null) {\n+            _routingTableRefMap.put(key, new AtomicReference<>(\n+                new CustomizedViewRoutingTable(propertyType, customizedStateType)));\n+          }\n         }\n-        break;\n+      }\n+    }\n \n-      case CURRENTSTATES:\n-        // CurrentState change listeners will be added later in LiveInstanceChange call.\n-        break;\n+    if (_helixManager != null) {", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcxMzY0OA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392713648", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-15T21:17:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTM5MA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392525390", "bodyText": "Better to check NPE for these calls.", "author": "jiajunwang", "createdAt": "2020-03-13T23:20:37Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -237,7 +337,48 @@ public void shutdown() {\n    * @return snapshot of current routing table.\n    */\n   public RoutingTableSnapshot getRoutingTableSnapshot() {\n-    return new RoutingTableSnapshot(_routingTableRef.get());\n+      String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+      return new RoutingTableSnapshot(_routingTableRefMap.get(key).get());", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcxNjk3Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r392716976", "bodyText": "Basically this NPE check has been added in the getRoutingTableKey. Hence for these method we automatically check NPE and see of key existed in the _routingTableRefMap.", "author": "alirezazamani", "createdAt": "2020-03-15T21:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5OTM4MA==", "url": "https://github.com/apache/helix/pull/834#discussion_r393999380", "bodyText": "It seems all the usage of getRoutingTableKey is for getting the table ref. Why not change it to directly return the table that we find?", "author": "jiajunwang", "createdAt": "2020-03-17T22:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1ODc2Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r395358766", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-19T22:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNTM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjUwMg==", "url": "https://github.com/apache/helix/pull/834#discussion_r392526502", "bodyText": "The \"type\" here is not clear what does it mean.\n\nstate type would be cleaner.\nfor all the public method, add java doc.", "author": "jiajunwang", "createdAt": "2020-03-13T23:26:22Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -338,14 +510,26 @@ public Object removeRoutingTableChangeListener(\n     return getInstancesForResource(resourceName, state);\n   }\n \n+  public Set<InstanceConfig> getInstances(String resourceName, String state,\n+      PropertyType propertyType, String type) {", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcxODk4Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r392718986", "bodyText": "done\ndone. Added java doc for all of the newly added public methods.", "author": "alirezazamani", "createdAt": "2020-03-15T22:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjc2Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r392526766", "bodyText": "This could be a potential concern since each table will keep a separate instance list. There should be only one copy of the data. Let's add a TODO here for the future improvement.", "author": "jiajunwang", "createdAt": "2020-03-13T23:27:52Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +575,104 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcxOTM1Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r392719356", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-15T22:25:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjk2Mw==", "url": "https://github.com/apache/helix/pull/834#discussion_r392526963", "bodyText": "Just call it statetype so it's more generic.", "author": "jiajunwang", "createdAt": "2020-03-13T23:28:50Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +575,104 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType.name(), type);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+\n+  private String getRoutingTableKey(String propertyTypeName, String customizedStateType) {", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcxOTQ4MA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392719480", "bodyText": "Fixed.", "author": "alirezazamani", "createdAt": "2020-03-15T22:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNjk2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMzE3NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r392533175", "bodyText": "Do we have DEFAULT_PROPERTY but none DEFAULT_TYPE case? If not, shall we just ignore the state type if DEFAULT_PROPERTY is used?", "author": "jiajunwang", "createdAt": "2020-03-14T00:02:56Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +575,104 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType.name(), type);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+\n+  private String getRoutingTableKey(String propertyTypeName, String customizedStateType) {\n+    if (propertyTypeName.equals(DEFAULT_PROPERTY) && customizedStateType.equals(DEFAULT_TYPE)) {", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIwOTE5MQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r393209191", "bodyText": "Makes sense. Done.", "author": "alirezazamani", "createdAt": "2020-03-16T17:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMzE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMzI3NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392533274", "bodyText": "DEFAULT_PROPERTY_TYPE and DEFAULT_STATE_TYPE are cleaner, IMHO.", "author": "jiajunwang", "createdAt": "2020-03-14T00:03:38Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -83,17 +87,27 @@\n   private ExecutorService _reportExecutor;\n   private Future _reportingTask = null;\n \n+  protected static final  String DEFAULT_PROPERTY = \"HELIX_DEFAULT_PROPERTY\";", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjYxMTMyNg==", "url": "https://github.com/apache/helix/pull/834#discussion_r392611326", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-14T19:03:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzMzI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNDQ3OQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r392534479", "bodyText": "This formula is better to be done in a private method. Otherwise, if you want to replace  \"_\", it would be a headache.", "author": "jiajunwang", "createdAt": "2020-03-14T00:10:56Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +575,104 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType.name(), type);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+\n+  private String getRoutingTableKey(String propertyTypeName, String customizedStateType) {\n+    if (propertyTypeName.equals(DEFAULT_PROPERTY) && customizedStateType.equals(DEFAULT_TYPE)) {\n+      // Check whether there exist only one snapshot (_routingTableRefMap)\n+      if (_routingTableRefMap.keySet().size() == 1) {\n+        return _routingTableRefMap.keySet().iterator().next();\n+      } else {\n+        throw new HelixException(\"There is none or more than one RoutingTableSnapshot\");\n+      }\n+    }\n+\n+    if (!propertyTypeName.equals(DEFAULT_PROPERTY) && customizedStateType.equals(DEFAULT_TYPE)) {\n+      if (propertyTypeName.equals(PropertyType.CUSTOMIZEDVIEW.name())) {\n+        throw new HelixException(\"Specific type needs to be used for CUSTOMIZEDVIEW PropertyType\");\n+      }\n+    }\n+\n+    String key = propertyTypeName + \"_\" + customizedStateType;\n+    if (!_routingTableRefMap.containsKey(key)) {\n+      throw new HelixException(\n+          String.format(\"Currently there is no snapshot available for PropertyType %s and type %s\",\n+              propertyTypeName, customizedStateType));\n+    }\n+    return key;\n+\n   }\n \n   @Override\n   @PreFetch(enabled = false)\n   public void onExternalViewChange(List<ExternalView> externalViewList,\n       NotificationContext changeContext) {\n     HelixConstants.ChangeType changeType = changeContext.getChangeType();\n-    if (changeType != null && !changeType.getPropertyType().equals(_sourceDataType)) {\n+    if (changeType != null && !_sourceDataTypeMap.containsKey(changeType.getPropertyType())) {\n       logger.warn(\n-          \"onExternalViewChange called with mismatched change types. Source data type {}, changed data type: {}\",\n-          _sourceDataType, changeType);\n+          \"onExternalViewChange called with mismatched change types. Source data types does not contain changed data type: {}\",\n+          changeType);\n       return;\n     }\n     // Refresh with full list of external view.\n     if (externalViewList != null && externalViewList.size() > 0) {\n       // keep this here for back-compatibility, application can call onExternalViewChange directly\n       // with externalview list supplied.\n-      refresh(externalViewList, changeContext);\n+      String keyReference = PropertyType.EXTERNALVIEW.name() + \"_\" + DEFAULT_TYPE;", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzIyMzg5Mw==", "url": "https://github.com/apache/helix/pull/834#discussion_r393223893", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-16T18:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNDQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNTI5Mw==", "url": "https://github.com/apache/helix/pull/834#discussion_r392535293", "bodyText": "Instead of having one this type of refresh method, we should split it into 2 refresh methods. One for externalview, another for customizeStatem. Maybe the 3rd one for current state.\nOtherwise, a typical problem is that as a reviewer, I don't know what is \"Collections.emptyList()\" for. As a user, I won't be able to know as well.\nMoreover, the behavior of passing both parameters is not clean.", "author": "jiajunwang", "createdAt": "2020-03-14T00:16:23Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +575,104 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY, DEFAULT_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  public Collection<String> getResources(PropertyType propertyType, String type) {\n+    String key = getRoutingTableKey(propertyType.name(), type);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+\n+  private String getRoutingTableKey(String propertyTypeName, String customizedStateType) {\n+    if (propertyTypeName.equals(DEFAULT_PROPERTY) && customizedStateType.equals(DEFAULT_TYPE)) {\n+      // Check whether there exist only one snapshot (_routingTableRefMap)\n+      if (_routingTableRefMap.keySet().size() == 1) {\n+        return _routingTableRefMap.keySet().iterator().next();\n+      } else {\n+        throw new HelixException(\"There is none or more than one RoutingTableSnapshot\");\n+      }\n+    }\n+\n+    if (!propertyTypeName.equals(DEFAULT_PROPERTY) && customizedStateType.equals(DEFAULT_TYPE)) {\n+      if (propertyTypeName.equals(PropertyType.CUSTOMIZEDVIEW.name())) {\n+        throw new HelixException(\"Specific type needs to be used for CUSTOMIZEDVIEW PropertyType\");\n+      }\n+    }\n+\n+    String key = propertyTypeName + \"_\" + customizedStateType;\n+    if (!_routingTableRefMap.containsKey(key)) {\n+      throw new HelixException(\n+          String.format(\"Currently there is no snapshot available for PropertyType %s and type %s\",\n+              propertyTypeName, customizedStateType));\n+    }\n+    return key;\n+\n   }\n \n   @Override\n   @PreFetch(enabled = false)\n   public void onExternalViewChange(List<ExternalView> externalViewList,\n       NotificationContext changeContext) {\n     HelixConstants.ChangeType changeType = changeContext.getChangeType();\n-    if (changeType != null && !changeType.getPropertyType().equals(_sourceDataType)) {\n+    if (changeType != null && !_sourceDataTypeMap.containsKey(changeType.getPropertyType())) {\n       logger.warn(\n-          \"onExternalViewChange called with mismatched change types. Source data type {}, changed data type: {}\",\n-          _sourceDataType, changeType);\n+          \"onExternalViewChange called with mismatched change types. Source data types does not contain changed data type: {}\",\n+          changeType);\n       return;\n     }\n     // Refresh with full list of external view.\n     if (externalViewList != null && externalViewList.size() > 0) {\n       // keep this here for back-compatibility, application can call onExternalViewChange directly\n       // with externalview list supplied.\n-      refresh(externalViewList, changeContext);\n+      String keyReference = PropertyType.EXTERNALVIEW.name() + \"_\" + DEFAULT_TYPE;\n+      refresh(externalViewList, Collections.emptyList(), changeContext, keyReference);", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM1MTc5OA==", "url": "https://github.com/apache/helix/pull/834#discussion_r393351798", "bodyText": "Sure. Done.", "author": "alirezazamani", "createdAt": "2020-03-16T22:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNTI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNTkzNg==", "url": "https://github.com/apache/helix/pull/834#discussion_r392535936", "bodyText": "Isn't is fixed for current state? Why need to pass it in?", "author": "jiajunwang", "createdAt": "2020-03-14T00:20:57Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -529,68 +791,95 @@ private void updateCurrentStatesListeners(List<LiveInstance> liveInstances,\n \n   private void reset() {\n     logger.info(\"Resetting the routing table.\");\n-    RoutingTable newRoutingTable = new RoutingTable();\n-    _routingTableRef.set(newRoutingTable);\n+    for (String key: _routingTableRefMap.keySet()) {\n+      PropertyType propertyType = _routingTableRefMap.get(key).get().getPropertyType();\n+      if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+        String type = _routingTableRefMap.get(key).get().getCustomizedStateType();\n+        RoutingTable newRoutingTable = new CustomizedViewRoutingTable(propertyType, type);\n+        _routingTableRefMap.get(key).set(newRoutingTable);\n+      } else {\n+        RoutingTable newRoutingTable = new RoutingTable(propertyType);\n+        _routingTableRefMap.get(key).set(newRoutingTable);\n+      }\n+    }\n   }\n \n-  protected void refresh(List<ExternalView> externalViewList, NotificationContext changeContext) {\n+  protected void refresh(List<ExternalView> externalViewList,\n+      List<CustomizedView> customizedViewList, NotificationContext changeContext,\n+      String referenceKey) {\n     HelixDataAccessor accessor = changeContext.getManager().getHelixDataAccessor();\n     PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n \n     List<InstanceConfig> configList = accessor.getChildValues(keyBuilder.instanceConfigs());\n     List<LiveInstance> liveInstances = accessor.getChildValues(keyBuilder.liveInstances());\n-    refresh(externalViewList, configList, liveInstances);\n+    refresh(externalViewList, customizedViewList, configList, liveInstances, referenceKey);\n   }\n \n   protected void refresh(Collection<ExternalView> externalViews,\n-      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+      Collection<CustomizedView> customizedViews, Collection<InstanceConfig> instanceConfigs,\n+      Collection<LiveInstance> liveInstances, String referenceKey) {\n     long startTime = System.currentTimeMillis();\n-    RoutingTable newRoutingTable = new RoutingTable(externalViews, instanceConfigs, liveInstances);\n-    resetRoutingTableAndNotify(startTime, newRoutingTable);\n+    PropertyType propertyType = _routingTableRefMap.get(referenceKey).get().getPropertyType();\n+    if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+      String customizedStateType = _routingTableRefMap.get(referenceKey).get().getCustomizedStateType();\n+      RoutingTable newRoutingTable = new CustomizedViewRoutingTable(customizedViews,\n+          instanceConfigs, liveInstances, propertyType, customizedStateType);\n+      resetRoutingTableAndNotify(startTime, newRoutingTable, referenceKey);\n+    } else {\n+      RoutingTable newRoutingTable = new RoutingTable(externalViews, instanceConfigs,\n+          liveInstances, propertyType);\n+      resetRoutingTableAndNotify(startTime, newRoutingTable, referenceKey);\n+    }\n   }\n \n   protected void refresh(Map<String, Map<String, Map<String, CurrentState>>> currentStateMap,\n-      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances) {\n+      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances,\n+      String referenceKey) {\n     long startTime = System.currentTimeMillis();\n     RoutingTable newRoutingTable =\n         new RoutingTable(currentStateMap, instanceConfigs, liveInstances);\n-    resetRoutingTableAndNotify(startTime, newRoutingTable);\n+    resetRoutingTableAndNotify(startTime, newRoutingTable, referenceKey);", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2NzY3NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r393367675", "bodyText": "we need referenceKey to not what routingTableRef should be reseted. However, I agree with you we can infer referenceKey. But since we have it already in routerUpdater, I think it does not make huge difference. Also it is consistent with other refresh calls as well.", "author": "alirezazamani", "createdAt": "2020-03-16T23:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNTkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzM0OA==", "url": "https://github.com/apache/helix/pull/834#discussion_r392537348", "bodyText": "One question, if we have multiple state types for the customized state view, do we have multiple event count for this monitor? Wil that be bad?", "author": "jiajunwang", "createdAt": "2020-03-14T00:31:02Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -700,12 +1003,13 @@ public void queueEvent(NotificationContext context, ClusterEventType eventType,\n       event.addAttribute(AttributeName.helixmanager.name(), context.getManager());\n       event.addAttribute(AttributeName.changeContext.name(), context);\n       queueEvent(event);\n-\n-      _monitor.increaseCallbackCounters(_eventQueue.size());\n+      for (PropertyType propertyType : _monitorMap.keySet()) {\n+        _monitorMap.get(propertyType).increaseCallbackCounters(_eventQueue.size());", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4NTg3Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r393385877", "bodyText": "Yes this could potentially be not ideal and have some room to improvement. Based on this design (which we have one routerUpdater for all of the different types), we have one queue/RouterUpdater per RoutingTableProvider. Even here we are sharing the queue between them. Hence when we have hendle_event, we add queue size to all of them regarding the type and content of the queue. This is one of the drawbacks of having one RouterUpdater per RoutingTable. We can have TODO for improvement here maybe? What do you think?", "author": "alirezazamani", "createdAt": "2020-03-17T00:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODY3Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r394048676", "bodyText": "TODO is fine, but we need 2 items.\n\nSplit the monitor into 2. One is general router callback tracking. The other one is for each type of tracking. Then we have the right numbers.\nWe may need to add more complexity to the customized view monitor for each state type.", "author": "jiajunwang", "createdAt": "2020-03-18T00:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzM0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyODgyNg==", "url": "https://github.com/apache/helix/pull/834#discussion_r395328826", "bodyText": "Agree. Added the TODO with your points.", "author": "alirezazamani", "createdAt": "2020-03-19T21:25:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzQzMw==", "url": "https://github.com/apache/helix/pull/834#discussion_r392537433", "bodyText": "StateType should be good enough.", "author": "jiajunwang", "createdAt": "2020-03-14T00:31:34Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableSnapshot.java", "diffHunk": "@@ -33,9 +36,13 @@\n  */\n public class RoutingTableSnapshot {\n   private final RoutingTable _routingTable;\n+  private final PropertyType _propertyType;\n+  private final String _customizedStateType;", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4NjM3Mg==", "url": "https://github.com/apache/helix/pull/834#discussion_r393386372", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-17T00:45:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzQzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzUyOQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r392537529", "bodyText": "Since you already kept the routingTable, is it still necessary to keep them as private fields?", "author": "jiajunwang", "createdAt": "2020-03-14T00:32:19Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableSnapshot.java", "diffHunk": "@@ -33,9 +36,13 @@\n  */\n public class RoutingTableSnapshot {\n   private final RoutingTable _routingTable;\n+  private final PropertyType _propertyType;\n+  private final String _customizedStateType;\n \n   public RoutingTableSnapshot(RoutingTable routingTable) {\n     _routingTable = routingTable;\n+    _propertyType = routingTable.getPropertyType();", "originalCommit": "24990ea51b35660e0862cee735c24d9bd3694e32", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4ODAwOQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r393388009", "bodyText": "It is used mainly in one of the methods called getCustomizeViews. Based on this type we decide what to return (either empty list or do type casting between routingTable and customizedViewRoutingTable). Please have a look and let me know if that answers your question.", "author": "alirezazamani", "createdAt": "2020-03-17T00:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUzNzUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2MTc2Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r393961766", "bodyText": "Not a must fix, I just want to suggest you try lamda. It would be very convenient and simple here.", "author": "jiajunwang", "createdAt": "2020-03-17T20:50:42Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingDataCache.java", "diffHunk": "@@ -40,14 +47,31 @@\n class RoutingDataCache extends BasicClusterDataCache {\n   private static Logger LOG = LoggerFactory.getLogger(RoutingDataCache.class.getName());\n \n-  private final PropertyType _sourceDataType;\n+  private final Map<PropertyType, List<String>> _sourceDataTypeMap;\n+\n   private CurrentStateCache _currentStateCache;\n+  // TODO: CustomizedCache needs to be migrated to propertyCache. Once we migrate all cache to\n+  // propertyCache, this hardcoded list of fields won't be necessary.\n+  private Map<String, CustomizedViewCache> _customizedViewCaches;\n   private TargetExternalViewCache _targetExternalViewCache;\n \n   public RoutingDataCache(String clusterName, PropertyType sourceDataType) {\n+    this (clusterName, ImmutableMap.of(sourceDataType, Collections.emptyList()));\n+  }\n+\n+  /**\n+   * Initialize empty RoutingDataCache with clusterName, _propertyTypes.\n+   * @param clusterName\n+   * @param sourceDataTypeMap\n+   */\n+  public RoutingDataCache(String clusterName, Map<PropertyType, List<String>> sourceDataTypeMap) {\n     super(clusterName);\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _currentStateCache = new CurrentStateCache(clusterName);\n+    _customizedViewCaches = new HashMap<>();", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUzOTg3Mg==", "url": "https://github.com/apache/helix/pull/834#discussion_r394539872", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-18T18:00:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2MTc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2NDI2MA==", "url": "https://github.com/apache/helix/pull/834#discussion_r393964260", "bodyText": "I guess we want to start the updater after monitors ready.", "author": "jiajunwang", "createdAt": "2020-03-17T20:54:29Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,74 +120,62 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypeMap\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypeMap, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    validateSourceDataTypeMap(sourceDataTypeMap);\n+\n+    _routingTableRefMap = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _routerUpdater = new RouterUpdater(clusterName, sourceDataTypeMap);\n+    _routerUpdater.start();\n+    _monitorMap = new HashMap<>();", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU0MDA4NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r394540085", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-18T18:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2NDI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5Mzk5NQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r393993995", "bodyText": "This else is arbitrary. I know we have the validation to check. But it would be safer to check if the type is as expected again.", "author": "jiajunwang", "createdAt": "2020-03-17T21:56:44Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,74 +120,62 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypeMap\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypeMap, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    validateSourceDataTypeMap(sourceDataTypeMap);\n+\n+    _routingTableRefMap = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _routerUpdater = new RouterUpdater(clusterName, sourceDataTypeMap);\n+    _routerUpdater.start();\n+    _monitorMap = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      _monitorMap.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitorMap.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      if (_sourceDataTypeMap.get(propertyType).size() == 0) {\n+        String key = generateReferenceKey(propertyType.name(),  DEFAULT_STATE_TYPE);\n+        if (_routingTableRefMap.get(key) == null) {\n+          _routingTableRefMap.put(key, new AtomicReference<>(new RoutingTable(propertyType)));\n         }\n-\n-        try {\n-          _helixManager.addTargetExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach TargetExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach TargetExternalView Listener to HelixManager!\",\n-              e);\n+      } else {", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwODQyMQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r395308421", "bodyText": "Fixed.", "author": "alirezazamani", "createdAt": "2020-03-19T20:43:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5Mzk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5NjU2Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r393996567", "bodyText": "Let's move the table init even earlier than the updater start.\nIMO, it should be\n\ninit tables.\nstart monitoring\nstart updater.\nadd listeners", "author": "jiajunwang", "createdAt": "2020-03-17T22:02:44Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -106,74 +120,62 @@ public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataTy\n    */\n   public RoutingTableProvider(HelixManager helixManager, PropertyType sourceDataType,\n       boolean isPeriodicRefreshEnabled, long periodRefreshInterval) throws HelixException {\n-    _routingTableRef = new AtomicReference<>(new RoutingTable());\n+    this(helixManager, ImmutableMap.of(sourceDataType, Collections.emptyList()),\n+        isPeriodicRefreshEnabled, periodRefreshInterval);\n+  }\n+\n+  /**\n+   * Initialize an instance of RoutingTableProvider\n+   * @param helixManager\n+   * @param sourceDataTypeMap\n+   * @param isPeriodicRefreshEnabled true if periodic refresh is enabled, false otherwise\n+   * @param periodRefreshInterval only effective if isPeriodRefreshEnabled is true\n+   * @throws HelixException\n+   */\n+  public RoutingTableProvider(HelixManager helixManager,\n+      Map<PropertyType, List<String>> sourceDataTypeMap, boolean isPeriodicRefreshEnabled,\n+      long periodRefreshInterval) throws HelixException {\n+\n+    validateSourceDataTypeMap(sourceDataTypeMap);\n+\n+    _routingTableRefMap = new HashMap<>();\n     _helixManager = helixManager;\n-    _sourceDataType = sourceDataType;\n+    _sourceDataTypeMap = sourceDataTypeMap;\n     _routingTableChangeListenerMap = new ConcurrentHashMap<>();\n     String clusterName = _helixManager != null ? _helixManager.getClusterName() : null;\n+    _routerUpdater = new RouterUpdater(clusterName, sourceDataTypeMap);\n+    _routerUpdater.start();\n+    _monitorMap = new HashMap<>();\n \n-    _monitor = new RoutingTableProviderMonitor(_sourceDataType, clusterName);\n-    try {\n-      _monitor.register();\n-    } catch (JMException e) {\n-      logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+      _monitorMap.put(propertyType, new RoutingTableProviderMonitor(propertyType, clusterName));\n+      try {\n+        _monitorMap.get(propertyType).register();\n+      } catch (JMException e) {\n+        logger.error(\"Failed to register RoutingTableProvider monitor MBean.\", e);\n+      }\n     }\n     _reportExecutor = Executors.newSingleThreadExecutor();\n \n-    _routerUpdater = new RouterUpdater(clusterName, _sourceDataType);\n-    _routerUpdater.start();\n-\n-    if (_helixManager != null) {\n-      switch (_sourceDataType) {\n-      case EXTERNALVIEW:\n-        try {\n-          _helixManager.addExternalViewChangeListener(this);\n-        } catch (Exception e) {\n-          shutdown();\n-          logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n-          throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n-        }\n-        break;\n-\n-      case TARGETEXTERNALVIEW:\n-        // Check whether target external has been enabled or not\n-        if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n-            _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(), 0)) {\n-          shutdown();\n-          throw new HelixException(\"Target External View is not enabled!\");\n+    for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU0MDE3NA==", "url": "https://github.com/apache/helix/pull/834#discussion_r394540174", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-18T18:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5NjU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5NzU4Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r393997586", "bodyText": "nit, I personally don't think log then throw an exception is a good practice. If you agree, let's don't keep it in the new logic. But I don't have a strong preference here.", "author": "jiajunwang", "createdAt": "2020-03-17T22:05:12Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -199,6 +201,98 @@ public void run() {\n     }\n   }\n \n+  /**\n+   * A method that adds the ChangeListeners to HelixManager\n+   */\n+  private void addListeners() {\n+    if (_helixManager != null) {\n+      for (PropertyType propertyType : _sourceDataTypeMap.keySet()) {\n+        switch (propertyType) {\n+        case EXTERNALVIEW:\n+          try {\n+            _helixManager.addExternalViewChangeListener(this);\n+          } catch (Exception e) {\n+            shutdown();\n+            logger.error(\"Failed to attach ExternalView Listener to HelixManager!\");\n+            throw new HelixException(\"Failed to attach ExternalView Listener to HelixManager!\", e);\n+          }\n+          break;\n+        case CUSTOMIZEDVIEW:\n+          List<String> customizedStateTypes = _sourceDataTypeMap.get(propertyType);\n+          for (String customizedStateType : customizedStateTypes) {\n+            try {\n+              _helixManager.addCustomizedViewChangeListener(this, customizedStateType);\n+            } catch (Exception e) {\n+              shutdown();\n+              logger.error(\"Failed to attach CustomizedView Listener to HelixManager for type {}!\",\n+                  customizedStateType);\n+              throw new HelixException(String.format(\n+                  \"Failed to attach CustomizedView Listener to HelixManager for type %s!\",\n+                  customizedStateType), e);\n+            }\n+          }\n+          break;\n+        case TARGETEXTERNALVIEW:\n+          // Check whether target external has been enabled or not\n+          if (!_helixManager.getHelixDataAccessor().getBaseDataAccessor().exists(\n+              _helixManager.getHelixDataAccessor().keyBuilder().targetExternalViews().getPath(),\n+              0)) {\n+            shutdown();\n+            throw new HelixException(\"Target External View is not enabled!\");\n+          }\n+\n+          try {\n+            _helixManager.addTargetExternalViewChangeListener(this);\n+          } catch (Exception e) {\n+            shutdown();\n+            logger.error(\"Failed to attach TargetExternalView Listener to HelixManager!\");", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwOTU5Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r395309597", "bodyText": "I agree. Removed.", "author": "alirezazamani", "createdAt": "2020-03-19T20:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk5NzU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzNjM1MQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r394036351", "bodyText": "I'm still concerned about these get methods. I reviewed the design, it seems that we don't have a detailed list of what should be returned in the provider. So let's be strict on these public methods. My feeling is that we don't need all these additional methods. Since our application clients would use the snapshot object to get the info they need.\nOn the other hand, if the method is for testing only, try to keep them protected (and make the test case located in the same package path). Or we can leave only one method to get the detailed customized state map for testing.\nNote that once you add the public methods, we should not remove them later. Without solid business logic usage, I don't think we should add these additional methods.", "author": "jiajunwang", "createdAt": "2020-03-17T23:55:26Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -280,17 +425,50 @@ public Object removeRoutingTableChangeListener(\n   }\n \n   /**\n-   * returns the instances for {resource,partition} pair that are in a specific\n-   * {state}\n+   * For specific routing table associated with {propertyType, stateType}\n+   * returns the instances for {resource group,partition} pair contains any of the given tags that\n+   * are in a specific {state}.\n+   * @param resourceName\n+   * @param partitionName\n+   * @param state\n+   * @param propertyType\n+   * @param stateType\n+   * @return\n+   */\n+  public List<InstanceConfig> getInstances(String resourceName, String partitionName, String state,\n+      PropertyType propertyType, String stateType) {\n+    return getInstancesForResource(resourceName, partitionName, state, propertyType, stateType);\n+  }\n+\n+  /**\n+   * returns the instances for {resource,partition} pair that are in a specific {state}\n    * @param resourceName\n-   *          -\n    * @param partitionName\n    * @param state\n    * @return empty list if there is no instance in a given state\n    */\n   public List<InstanceConfig> getInstancesForResource(String resourceName, String partitionName,\n       String state) {\n-    return _routingTableRef.get().getInstancesForResource(resourceName, partitionName, state);\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY_TYPE, DEFAULT_STATE_TYPE);\n+    return _routingTableRefMap.get(key).get().getInstancesForResource(resourceName, partitionName,\n+        state);\n+  }\n+\n+  /**\n+   * For specific routing table associated with {propertyType, stateType}\n+   * returns the instances for {resource,partition} pair that are in a specific {state}\n+   * @param resourceName\n+   * @param partitionName\n+   * @param state\n+   * @param propertyType\n+   * @param stateType\n+   * @return\n+   */\n+  public List<InstanceConfig> getInstancesForResource(String resourceName, String partitionName,", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxMjg5Mg==", "url": "https://github.com/apache/helix/pull/834#discussion_r395312892", "bodyText": "I removed this method too.", "author": "alirezazamani", "createdAt": "2020-03-19T20:52:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzNjM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzNjc3Mw==", "url": "https://github.com/apache/helix/pull/834#discussion_r394036773", "bodyText": "Logic wise, the user should see the same resource list with any type of the state. So this method is not necessary.", "author": "jiajunwang", "createdAt": "2020-03-17T23:56:58Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +658,131 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    // TODO each table will keep a separate instance list.This can be improve by only keeping one copy of the data\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    // TODO each table will keep a separate instance list.This can be improve by only keeping one copy of the data\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY_TYPE, DEFAULT_STATE_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  /**\n+   * For specific RoutingTable associated with {propertyType, stateType}\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n+   * @param propertyType\n+   * @param stateType\n+   * @return\n+   */\n+  public Collection<String> getResources(PropertyType propertyType, String stateType) {", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyNzA0Mw==", "url": "https://github.com/apache/helix/pull/834#discussion_r395327043", "bodyText": "Removed.", "author": "alirezazamani", "createdAt": "2020-03-19T21:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzNjc3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzNjkwNw==", "url": "https://github.com/apache/helix/pull/834#discussion_r394036907", "bodyText": "As mentioned earlier, let this method return the table itself.", "author": "jiajunwang", "createdAt": "2020-03-17T23:57:26Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +658,131 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    // TODO each table will keep a separate instance list.This can be improve by only keeping one copy of the data\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getLiveInstances();\n   }\n \n   /**\n    * Return all instance's config in this cluster.\n    * @return\n    */\n   public Collection<InstanceConfig> getInstanceConfigs() {\n-    return _routingTableRef.get().getInstanceConfigs();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    // TODO each table will keep a separate instance list.This can be improve by only keeping one copy of the data\n+    String key = null;\n+    Iterator<String> iter = _routingTableRefMap.keySet().iterator();\n+    if (iter.hasNext()) {\n+      key = iter.next();\n+    }\n+    if (key == null) {\n+      throw new HelixException(\"There is no key available in this RoutingTableProvider.\");\n+    }\n+    return _routingTableRefMap.get(key).get().getInstanceConfigs();\n   }\n \n   /**\n-   * Return names of all resources (shown in ExternalView) in this cluster.\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n    */\n   public Collection<String> getResources() {\n-    return _routingTableRef.get().getResources();\n+    String key = getRoutingTableKey(DEFAULT_PROPERTY_TYPE, DEFAULT_STATE_TYPE);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  /**\n+   * For specific RoutingTable associated with {propertyType, stateType}\n+   * Return names of all resources (shown in ExternalView or CustomizedView) in this cluster.\n+   * @param propertyType\n+   * @param stateType\n+   * @return\n+   */\n+  public Collection<String> getResources(PropertyType propertyType, String stateType) {\n+    String key = getRoutingTableKey(propertyType.name(), stateType);\n+    return _routingTableRefMap.get(key).get().getResources();\n+  }\n+\n+  /**\n+   * Provide the key associated with specific PropertyType and StateType for _routingTableRefMap lookup.\n+   * @param propertyTypeName\n+   * @param stateType\n+   * @return\n+   */\n+  private String getRoutingTableKey(String propertyTypeName, String stateType) {", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1ODgzNw==", "url": "https://github.com/apache/helix/pull/834#discussion_r395358837", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-19T22:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzNjkwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0MjgzMw==", "url": "https://github.com/apache/helix/pull/834#discussion_r394042833", "bodyText": "Safer to add the same source type check we did for the other listeners.", "author": "jiajunwang", "createdAt": "2020-03-18T00:20:57Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -457,13 +819,23 @@ public void onLiveInstanceChange(List<LiveInstance> liveInstances,\n   @PreFetch(enabled = false)\n   public void onStateChange(String instanceName, List<CurrentState> statesInfo,\n       NotificationContext changeContext) {\n-    if (_sourceDataType.equals(PropertyType.CURRENTSTATES)) {\n+    if (_sourceDataTypeMap.containsKey(PropertyType.CURRENTSTATES)) {\n       _routerUpdater.queueEvent(changeContext, ClusterEventType.CurrentStateChange,\n           HelixConstants.ChangeType.CURRENT_STATE);\n     } else {\n       logger.warn(\n           \"RoutingTableProvider does not use CurrentStates as source, ignore CurrentState changes!\");\n     }\n+    _routerUpdater.queueEvent(changeContext, ClusterEventType.CurrentStateChange,\n+        HelixConstants.ChangeType.CURRENT_STATE);\n+  }\n+\n+  @Override\n+  @PreFetch(enabled = false)\n+  public void onCustomizedViewChange(List<CustomizedView> customizedViewList,\n+      NotificationContext changeContext) {\n+    _routerUpdater.queueEvent(changeContext, ClusterEventType.CustomizedViewChange,", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyNjMyNA==", "url": "https://github.com/apache/helix/pull/834#discussion_r395326324", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-19T21:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0MjgzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyNzM2MQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r395327361", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-19T21:22:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0MjgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0MzU2Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r394043567", "bodyText": "Thanks for adding this todo.\nBut for the logic, it is too verbose. Why not just get the _routingTableRefMap.values().interator().next()?", "author": "jiajunwang", "createdAt": "2020-03-18T00:23:52Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -376,50 +658,131 @@ public Object removeRoutingTableChangeListener(\n    * @return\n    */\n   public Collection<LiveInstance> getLiveInstances() {\n-    return _routingTableRef.get().getLiveInstances();\n+    // Since line instances will be the same across all _routingTableRefMap, here one of the keys\n+    // will be used without considering PropertyType\n+    // TODO each table will keep a separate instance list.This can be improve by only keeping one copy of the data", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxOTQxMA==", "url": "https://github.com/apache/helix/pull/834#discussion_r395319410", "bodyText": "Changed based on your suggestion. Thanks.", "author": "alirezazamani", "createdAt": "2020-03-19T21:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0MzU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0NDg0Ng==", "url": "https://github.com/apache/helix/pull/834#discussion_r394044846", "bodyText": "nit, move this outside the condition block for reducing verbose code.", "author": "jiajunwang", "createdAt": "2020-03-18T00:28:58Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableProvider.java", "diffHunk": "@@ -529,68 +901,88 @@ private void updateCurrentStatesListeners(List<LiveInstance> liveInstances,\n \n   private void reset() {\n     logger.info(\"Resetting the routing table.\");\n-    RoutingTable newRoutingTable = new RoutingTable();\n-    _routingTableRef.set(newRoutingTable);\n+    for (String key: _routingTableRefMap.keySet()) {\n+      PropertyType propertyType = _routingTableRefMap.get(key).get().getPropertyType();\n+      if (propertyType == PropertyType.CUSTOMIZEDVIEW) {\n+        String stateType = _routingTableRefMap.get(key).get().getStateType();\n+        RoutingTable newRoutingTable = new CustomizedViewRoutingTable(propertyType, stateType);\n+        _routingTableRefMap.get(key).set(newRoutingTable);", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjQyOA==", "url": "https://github.com/apache/helix/pull/834#discussion_r395332428", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-19T21:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0NDg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODg0Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r394048847", "bodyText": "getStateType() ?", "author": "jiajunwang", "createdAt": "2020-03-18T00:45:49Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableSnapshot.java", "diffHunk": "@@ -145,4 +152,34 @@ public RoutingTableSnapshot(RoutingTable routingTable) {\n   public Collection<ExternalView> getExternalViews() {\n     return _routingTable.getExternalViews();\n   }\n+\n+  /**\n+   * Returns a Collection of latest snapshot of CustomizedView. Note that if the RoutingTable is\n+   * instantiated using CurrentStates, this Collection will be empty.\n+   * @return\n+   */\n+  public Collection<CustomizedView> getCustomizeViews() {\n+    if (_propertyType.equals(PropertyType.CUSTOMIZEDVIEW)){\n+    CustomizedViewRoutingTable customizedViewRoutingTable =\n+        (CustomizedViewRoutingTable) _routingTable;\n+    return customizedViewRoutingTable.geCustomizedViews();\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  /**\n+   * Returns the PropertyType associated with this RoutingTableSnapshot\n+   * @return\n+   */\n+  public PropertyType getPropertyType() {\n+    return _propertyType;\n+  }\n+\n+  /**\n+   * Return the Type associated with thi RoutingTableSnapshot (mainly used for CustomizedView)\n+   * @return\n+   */\n+  public String getCustomizedStateType() {", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUzNjQxNw==", "url": "https://github.com/apache/helix/pull/834#discussion_r394536417", "bodyText": "getCustomizedStateType would be clearer. As this is a snapshot class for different kinds of views.", "author": "zhangmeng916", "createdAt": "2020-03-18T17:54:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODg0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM1OTIzMg==", "url": "https://github.com/apache/helix/pull/834#discussion_r395359232", "bodyText": "I don't have preference. I keep it for now as it is. We can change it later.", "author": "alirezazamani", "createdAt": "2020-03-19T22:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxNTYzMQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r394515631", "bodyText": "Can we use customizeView for consistency.", "author": "zhangmeng916", "createdAt": "2020-03-18T17:22:04Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  /*\n+   * The customizedStateType field is the type the controller is aggregating.\n+   * For example if RoutingTableProvider initialized using the code below:\n+   * Map<PropertyType, List<String>> sourceDataTypes = new HashMap<>();\n+   * sourceDataTypes.put(PropertyType.CUSTOMIZEDVIEW, Arrays.asList(\"typeA\", \"typeB\"));\n+   * RoutingTableProvider routingTableProvider =\n+   * new RoutingTableProvider(_spectator, sourceDataTypes);\n+   *\n+   * Each one of the TypeA and TypeB is a customizedStateType.\n+   */\n+  private final String _customizedStateType;\n+\n+  public CustomizedViewRoutingTable(PropertyType propertyType, String customizedStateType) {\n+    this(Collections.<CustomizedView> emptyList(), propertyType, customizedStateType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      PropertyType propertytype, String customizedStateType) {\n+    this(customizedViews, Collections.<InstanceConfig> emptyList(),\n+        Collections.<LiveInstance> emptyList(), propertytype, customizedStateType);\n+  }\n+\n+  protected CustomizedViewRoutingTable(Collection<CustomizedView> customizedViews,\n+      Collection<InstanceConfig> instanceConfigs, Collection<LiveInstance> liveInstances,\n+      PropertyType propertytype, String customizedStateType) {\n+    super(Collections.<ExternalView> emptyList(), instanceConfigs, liveInstances,\n+        PropertyType.CUSTOMIZEDVIEW);\n+    _customizedStateType = customizedStateType;\n+    _customizedViews = new HashSet<>(customizedViews);\n+    refresh(_customizedViews);\n+  }\n+\n+  private void refresh(Collection<CustomizedView> customizedViewList) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    if (customizedViewList != null && !customizedViewList.isEmpty()) {\n+      for (InstanceConfig config : _instanceConfigs) {\n+        instanceConfigMap.put(config.getId(), config);\n+      }\n+      for (CustomizedView customView : customizedViewList) {", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMjI5Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r395302297", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-19T20:31:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxNTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxNjYxMQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r394516611", "bodyText": "You may want to reformat the code, including comments.", "author": "zhangmeng916", "createdAt": "2020-03-18T17:23:32Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/CustomizedViewRoutingTable.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package org.apache.helix.spectator;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.ExternalView;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewRoutingTable extends RoutingTable {\n+  private static final Logger logger = LoggerFactory.getLogger(CustomizedViewRoutingTable.class);\n+\n+  private final Collection<CustomizedView> _customizedViews;\n+  /*\n+   * The customizedStateType field is the type the controller is aggregating.", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMwMTgwNQ==", "url": "https://github.com/apache/helix/pull/834#discussion_r395301805", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-03-19T20:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUxNjYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUzNTc2Nw==", "url": "https://github.com/apache/helix/pull/834#discussion_r394535767", "bodyText": "typo here.", "author": "zhangmeng916", "createdAt": "2020-03-18T17:53:44Z", "path": "helix-core/src/main/java/org/apache/helix/spectator/RoutingTableSnapshot.java", "diffHunk": "@@ -145,4 +152,34 @@ public RoutingTableSnapshot(RoutingTable routingTable) {\n   public Collection<ExternalView> getExternalViews() {\n     return _routingTable.getExternalViews();\n   }\n+\n+  /**\n+   * Returns a Collection of latest snapshot of CustomizedView. Note that if the RoutingTable is\n+   * instantiated using CurrentStates, this Collection will be empty.\n+   * @return\n+   */\n+  public Collection<CustomizedView> getCustomizeViews() {\n+    if (_propertyType.equals(PropertyType.CUSTOMIZEDVIEW)){\n+    CustomizedViewRoutingTable customizedViewRoutingTable =\n+        (CustomizedViewRoutingTable) _routingTable;\n+    return customizedViewRoutingTable.geCustomizedViews();\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  /**\n+   * Returns the PropertyType associated with this RoutingTableSnapshot\n+   * @return\n+   */\n+  public PropertyType getPropertyType() {\n+    return _propertyType;\n+  }\n+\n+  /**\n+   * Return the Type associated with thi RoutingTableSnapshot (mainly used for CustomizedView)", "originalCommit": "f7445ad61e1bd8a6e7422652b8d8f8b47bd0253b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMyMjI0OA==", "url": "https://github.com/apache/helix/pull/834#discussion_r395322248", "bodyText": "Fixed.", "author": "alirezazamani", "createdAt": "2020-03-19T21:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDUzNTc2Nw=="}], "type": "inlineReview"}, {"oid": "a13cf1b763280433ec0e951a7bf3027d74437e32", "url": "https://github.com/apache/helix/commit/a13cf1b763280433ec0e951a7bf3027d74437e32", "message": "Complete the Routing Table Provider for CustomizedView\n\nIn this commit, the routing table provider has been changed in a way\nto include customized view feature.", "committedDate": "2020-03-19T22:55:35Z", "type": "commit"}, {"oid": "4a64c703e2f698fce475190112ee2e57ccad8db2", "url": "https://github.com/apache/helix/commit/4a64c703e2f698fce475190112ee2e57ccad8db2", "message": "Address the comments", "committedDate": "2020-03-19T22:55:35Z", "type": "commit"}, {"oid": "4ab199c964177e7b65d3e8a1ad032b997f6e2d0b", "url": "https://github.com/apache/helix/commit/4ab199c964177e7b65d3e8a1ad032b997f6e2d0b", "message": "Address new comments", "committedDate": "2020-03-19T22:55:35Z", "type": "forcePushed"}, {"oid": "789ef09ae2efda1cf0129b4e6d98bfec0c7e5585", "url": "https://github.com/apache/helix/commit/789ef09ae2efda1cf0129b4e6d98bfec0c7e5585", "message": "Address new comments", "committedDate": "2020-03-20T00:29:55Z", "type": "commit"}, {"oid": "789ef09ae2efda1cf0129b4e6d98bfec0c7e5585", "url": "https://github.com/apache/helix/commit/789ef09ae2efda1cf0129b4e6d98bfec0c7e5585", "message": "Address new comments", "committedDate": "2020-03-20T00:29:55Z", "type": "forcePushed"}]}