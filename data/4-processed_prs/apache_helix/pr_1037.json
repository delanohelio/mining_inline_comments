{"pr_number": 1037, "pr_title": "Add ExcessiveTopStateResolver to gracefully fix the double-masters situation.", "pr_createdAt": "2020-05-28T23:10:22Z", "pr_url": "https://github.com/apache/helix/pull/1037", "timeline": [{"oid": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "url": "https://github.com/apache/helix/commit/8d0b0c091de5fe90828689e9944847eafc00e3d1", "message": "Add ExcessiveTopStateResolver to gracefully fix the double-masters situation.\n\nAlthough the rebalancer will fix the additional master eventually, the default operations are arbitrary and it may cause an older master to survive. This may cause serious application logic issues since many applications require the master to have the latest data.\nWith this state resolver, the rebalancer will change the default behavior to reset all the master replicas so as to ensure the remaining one is the youngest one. Then the double-masters situation is gracefully resolved.", "committedDate": "2020-05-28T23:04:08Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMzQ0Mg==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432633442", "bodyText": "Use a constant instead of 5000? TestHelper has a constant value built-in.", "author": "narendly", "createdAt": "2020-05-29T17:29:10Z", "path": "helix-core/src/test/java/org/apache/helix/integration/rebalancer/TestAbnormalStatesResolver.java", "diffHunk": "@@ -64,4 +80,101 @@ public void testConfigureResolver() {\n     clusterConfig.setAbnormalStateResolverMap(Collections.emptyMap());\n     configAccessor.setClusterConfig(CLUSTER_NAME, clusterConfig);\n   }\n+\n+  @Test(dependsOnMethods = \"testConfigureResolver\")\n+  public void testExcessiveTopStateResolver() {\n+    BestPossibleExternalViewVerifier verifier =\n+        new BestPossibleExternalViewVerifier.Builder(CLUSTER_NAME).setZkClient(_gZkClient).build();\n+    Assert.assertTrue(verifier.verify(5000));", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc2MjIzNA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432762234", "bodyText": "Sure, good point.", "author": "jiajunwang", "createdAt": "2020-05-29T22:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzMzQ0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNDAzNA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432634034", "bodyText": "gracefully\nAlso, it would be great if you could explain what the issue is instead of calling a \"double-topstates issue\" as this might not make much sense for readers without context.", "author": "narendly", "createdAt": "2020-05-29T17:30:13Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNDk1OA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432634958", "bodyText": "I think what you want to say here is:\n\"Note that Helix controller will eventually correct the fact that there are two top state replicas, but it may not happen immediately. This resolver exists to ensure that such cases are resolved right away.\"", "author": "narendly", "createdAt": "2020-05-29T17:31:53Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzOTU3OA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432639578", "bodyText": "Not exactly. Let me modify the description a little bit. But it is not about speed. It is still about correctness.", "author": "jiajunwang", "createdAt": "2020-05-29T17:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNDk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNTc0MA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432635740", "bodyText": "checkCurrentStates I think is a better name for this method. or isCurrentStateValid\nor checkForCurrentStateViolation()", "author": "narendly", "createdAt": "2020-05-29T17:33:26Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzOTkyOQ==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432639929", "bodyText": "I agree, let me change the method name.", "author": "jiajunwang", "createdAt": "2020-05-29T17:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNTc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNjg0Nw==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432636847", "bodyText": "computeCorrectedAssignment is clearer?", "author": "narendly", "createdAt": "2020-05-29T17:35:47Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NTIxMA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432665210", "bodyText": "Not really, this is not the corrected mapping, this is the next step of fixing.", "author": "jiajunwang", "createdAt": "2020-05-29T18:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNjg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNzcyMw==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432637723", "bodyText": "I wonder if this would be too much of an overhead for each pipeline run?\nDo you think it would be better to try to come up with a way to cache currentState mappings and compare diffs (going from O(n) -> O(1) check by storing results across pipelines).\nFor heavy users, this O(n) computation might become a significant bottleneck if done every pipeline.", "author": "narendly", "createdAt": "2020-05-29T17:37:33Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NDU4MQ==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432664581", "bodyText": "Could you please clarify why comparing diff will bring the complexity from O(n) to O(1)?", "author": "jiajunwang", "createdAt": "2020-05-29T18:31:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNzcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA1ODEzMA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r435058130", "bodyText": "@jiajunwang In CurrentStateOutput, could we add a top state counter map so we could cache the top state counter, like below? Then we could avoid that stream filter computation? Tradeoff is we need a bit more memory for the cache. But most of them are just references.\n  public void setCurrentState(String resourceName, Partition partition, String instanceName,\n      String state) {\n    (...... current code ......)\n    // Counter number of top state replicas for a single top state model. \n    if (state.equals(stateModelDef.getTopState())) {\n      Map<String, Integer> counterMap =\n          _topStateCounter.computeIfAbsent(resourceName, k -> new HashMap<>())\n              .computeIfAbsent(partition, k -> new HashMap<>());\n      counterMap.put(state, counterMap.getOrDefault(state, 0) + 1);\n    }\n  }\n\nNot sure if we need to optimize this. Maybe you could test it. It seems for this part, the time complexity is down from O(n) to O(1), but I am not sure what the actual time saving is, considering the whole pipeline. If the whole pipeline complexity is O(N^2), with this optimization, it is O(N), that may help. If the whole pipeline is O(2 * N), with this optimization, still O(N).", "author": "huizhilu", "createdAt": "2020-06-04T07:48:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNzcyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3NzU0Mg==", "url": "https://github.com/apache/helix/pull/1037#discussion_r435477542", "bodyText": "I see. In that case, we should add this to the cache instead of CurrentStateOutput. The cache is \"protected\" by the selective update, so it will help to reduce some calculations.\nThat is a valid idea. But that requires more changes. For this specific usage, changing the fundamental cache class seems to be not worthy.\nMoreover, if the resolver is not enabled, then we don't do the calculation at all.\nLet me add a TODO there, if we have more usage of this count, then we shall do it.", "author": "jiajunwang", "createdAt": "2020-06-04T18:47:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzNzcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzODUyOA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432638528", "bodyText": "recoverMap -> correctedStateMap?", "author": "narendly", "createdAt": "2020-05-29T17:39:08Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef,\n+      List<String> preferenceList) {\n+    Map<String, String> currentStateMap =\n+        currentStateOutput.getCurrentStateMap(resourceName, partition);\n+    if (isCurrentStatesValid(currentStateOutput, resourceName, partition, stateModelDef)) {\n+      // This method should not be triggered when the mapping is valid.\n+      // Log the warning for debug purposes.\n+      LOG.warn(\"The input current state map {} is valid, return the original current state.\",\n+          currentStateMap);\n+      return currentStateMap;\n+    }\n+\n+    Map<String, String> recoverMap = new HashMap<>(currentStateMap);", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY2NTM5MA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432665390", "bodyText": "same reason here, correctedStateMap is not accurate.", "author": "jiajunwang", "createdAt": "2020-05-29T18:32:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzODUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzODk3NQ==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432638975", "bodyText": "What is the potential data issue? It would be good to explain this somewhere.", "author": "narendly", "createdAt": "2020-05-29T17:39:57Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef,\n+      List<String> preferenceList) {\n+    Map<String, String> currentStateMap =\n+        currentStateOutput.getCurrentStateMap(resourceName, partition);\n+    if (isCurrentStatesValid(currentStateOutput, resourceName, partition, stateModelDef)) {\n+      // This method should not be triggered when the mapping is valid.\n+      // Log the warning for debug purposes.\n+      LOG.warn(\"The input current state map {} is valid, return the original current state.\",\n+          currentStateMap);\n+      return currentStateMap;\n+    }\n+\n+    Map<String, String> recoverMap = new HashMap<>(currentStateMap);\n+    String recoveryState = stateModelDef\n+        .getNextStateForTransition(stateModelDef.getTopState(), stateModelDef.getInitialState());\n+\n+    // 1. We have to reset the expected top state replica host if it is hosting the top state\n+    // replica. Otherwise, the potential data issue will never be fixed there.", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjYzOTg4OQ==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432639889", "bodyText": "no need for \"the\" in the variable name", "author": "narendly", "createdAt": "2020-05-29T17:41:39Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef,\n+      List<String> preferenceList) {\n+    Map<String, String> currentStateMap =\n+        currentStateOutput.getCurrentStateMap(resourceName, partition);\n+    if (isCurrentStatesValid(currentStateOutput, resourceName, partition, stateModelDef)) {\n+      // This method should not be triggered when the mapping is valid.\n+      // Log the warning for debug purposes.\n+      LOG.warn(\"The input current state map {} is valid, return the original current state.\",\n+          currentStateMap);\n+      return currentStateMap;\n+    }\n+\n+    Map<String, String> recoverMap = new HashMap<>(currentStateMap);\n+    String recoveryState = stateModelDef\n+        .getNextStateForTransition(stateModelDef.getTopState(), stateModelDef.getInitialState());\n+\n+    // 1. We have to reset the expected top state replica host if it is hosting the top state\n+    // replica. Otherwise, the potential data issue will never be fixed there.\n+    if (preferenceList != null && !preferenceList.isEmpty()) {\n+      String expectedTopStateHost = preferenceList.get(0);\n+      if (recoverMap.get(expectedTopStateHost).equals(stateModelDef.getTopState())) {\n+        recoverMap.put(expectedTopStateHost, recoveryState);\n+      }\n+    }\n+\n+    // 2. To minimize the impact of the resolution, we want to reserve one top state replica even\n+    // during the recovery process.\n+    boolean hasReservedTheTopState = false;", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MjA0OQ==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432642049", "bodyText": "You mean the rebalancer will continue to run this for all N resources until everything has been resolved?\nOr will it check for each resource, say, resource N, I check isValid() and correctCurrentStates() until isValid() returns true?\nWhat I am not too unsure about is what you said about \"new current state\" being \"still invalid\". Is it possible that the result is invalid after correction?", "author": "narendly", "createdAt": "2020-05-29T17:45:41Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef,\n+      List<String> preferenceList) {\n+    Map<String, String> currentStateMap =\n+        currentStateOutput.getCurrentStateMap(resourceName, partition);\n+    if (isCurrentStatesValid(currentStateOutput, resourceName, partition, stateModelDef)) {\n+      // This method should not be triggered when the mapping is valid.\n+      // Log the warning for debug purposes.\n+      LOG.warn(\"The input current state map {} is valid, return the original current state.\",\n+          currentStateMap);\n+      return currentStateMap;\n+    }\n+\n+    Map<String, String> recoverMap = new HashMap<>(currentStateMap);\n+    String recoveryState = stateModelDef\n+        .getNextStateForTransition(stateModelDef.getTopState(), stateModelDef.getInitialState());\n+\n+    // 1. We have to reset the expected top state replica host if it is hosting the top state\n+    // replica. Otherwise, the potential data issue will never be fixed there.\n+    if (preferenceList != null && !preferenceList.isEmpty()) {\n+      String expectedTopStateHost = preferenceList.get(0);\n+      if (recoverMap.get(expectedTopStateHost).equals(stateModelDef.getTopState())) {\n+        recoverMap.put(expectedTopStateHost, recoveryState);\n+      }\n+    }\n+\n+    // 2. To minimize the impact of the resolution, we want to reserve one top state replica even\n+    // during the recovery process.\n+    boolean hasReservedTheTopState = false;\n+    for (String instance : recoverMap.keySet()) {\n+      if (recoverMap.get(instance).equals(stateModelDef.getTopState())) {\n+        if (hasReservedTheTopState) {\n+          recoverMap.put(instance, recoveryState);\n+        } else {\n+          hasReservedTheTopState = true;\n+        }\n+      }\n+    }\n+    // Here's what we expect to happen next:\n+    // 1. The partition assignment is changed to the proposed recovery state. Or it may be halfway\n+    // there.\n+    // 2. If the new current state is still invalid, then continue fixing it with the same logic.", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NzI3NQ==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432787275", "bodyText": "There is no other resource considered here. Let me add \"then the resolver continues fixing it with the same logic.\"", "author": "jiajunwang", "createdAt": "2020-05-30T00:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MjA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4Nzc1NQ==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432787755", "bodyText": "What I am not too unsure about is what you said about \"new current state\" being \"still invalid\". Is it possible that the result is invalid after correction?\n\nI think that's why you have the question why the method is named computeRecoveryAssignment instead of computeCorrectedAssignment. The result is push the rebalancer to move one step toward the fix. But it is not necessarily fixing the states directly. Like in this case, it cannot be done within one step without impact the availability. This is the first point.\nSecondly, even for some resolvers, they fix the things in one step, there is no guarantee that the participant will finish the state transition immediately.", "author": "jiajunwang", "createdAt": "2020-05-30T00:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0MjA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMTk2Mg==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432731962", "bodyText": "I would suggest to put more comments here. I can understand the reason that leave a top state for the host not for first in preference list can help reduce the resetting work. But may be other people may confused with your statement in description that resetting all top state.", "author": "junkaixue", "createdAt": "2020-05-29T20:58:26Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that graceful fixes double-topstates issue for the single topstate\n+ * state model.\n+ * Note the regular Helix rebalance pipeline will also remove the excessive top state replica.\n+ * However, the default rebalancer logic cannot guarantee a clean resolution. For example, if the\n+ * double-topstates situation has already impact the data of the top state replicas, then the\n+ * controller should reset both of them, then bring back one top state replica on the right\n+ * allocation. For the application which has such a requirement, they should use this resolver or\n+ * a more advanced resolver which check the application data to ensure the resolution is complete.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean isCurrentStatesValid(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {\n+      return true;\n+    }\n+    if (currentStateOutput.getCurrentStateMap(resourceName, partition).values().stream()\n+        .filter(state -> state.equals(stateModelDef.getTopState())).count() > 1) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public Map<String, String> computeRecoveryAssignment(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef,\n+      List<String> preferenceList) {\n+    Map<String, String> currentStateMap =\n+        currentStateOutput.getCurrentStateMap(resourceName, partition);\n+    if (isCurrentStatesValid(currentStateOutput, resourceName, partition, stateModelDef)) {\n+      // This method should not be triggered when the mapping is valid.\n+      // Log the warning for debug purposes.\n+      LOG.warn(\"The input current state map {} is valid, return the original current state.\",\n+          currentStateMap);\n+      return currentStateMap;\n+    }\n+\n+    Map<String, String> recoverMap = new HashMap<>(currentStateMap);\n+    String recoveryState = stateModelDef\n+        .getNextStateForTransition(stateModelDef.getTopState(), stateModelDef.getInitialState());\n+\n+    // 1. We have to reset the expected top state replica host if it is hosting the top state\n+    // replica. Otherwise, the potential data issue will never be fixed there.\n+    if (preferenceList != null && !preferenceList.isEmpty()) {\n+      String expectedTopStateHost = preferenceList.get(0);\n+      if (recoverMap.get(expectedTopStateHost).equals(stateModelDef.getTopState())) {\n+        recoverMap.put(expectedTopStateHost, recoveryState);\n+      }\n+    }\n+\n+    // 2. To minimize the impact of the resolution, we want to reserve one top state replica even", "originalCommit": "8d0b0c091de5fe90828689e9944847eafc00e3d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4ODA1Ng==", "url": "https://github.com/apache/helix/pull/1037#discussion_r432788056", "bodyText": "That part has been covered in the below section \"Here's what we expect to happen next:\". There, the 3rd point explains how the rebalancer reset all top state eventually.", "author": "jiajunwang", "createdAt": "2020-05-30T00:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMTk2Mg=="}], "type": "inlineReview"}, {"oid": "f79a5bf21be94a945edee44faee5b69e2a2e234c", "url": "https://github.com/apache/helix/commit/f79a5bf21be94a945edee44faee5b69e2a2e234c", "message": "Address comment.", "committedDate": "2020-05-29T23:49:08Z", "type": "commit"}, {"oid": "4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc", "url": "https://github.com/apache/helix/commit/4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc", "message": "Address more comments.", "committedDate": "2020-05-30T00:18:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4OTUzMw==", "url": "https://github.com/apache/helix/pull/1037#discussion_r434789533", "bodyText": "Just a question. Now we only support single top state. Are we gonna support user defined number of top states? Say not all replicas are top state but 2 masters or something.\nWhy I am asking this is because  maybe sometimes there could be non-top state requires to be resolved as well.", "author": "junkaixue", "createdAt": "2020-06-03T19:03:40Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that gracefully fixes the abnormality of excessive top states for\n+ * single-topstate state model. For example, two replcias of a MasterSlave partition are assigned\n+ * with the Master state at the same time. This could be caused by a network partitioning or the\n+ * other unexpected issues.\n+ *\n+ * The resolver checks for the abnormality and computes recovery assignment which triggers the\n+ * rebalancer to eventually reset all the top state replias for once. After the resets, only one\n+ * replica will be assigned the top state.\n+ *\n+ * Note that without using this resolver, the regular Helix rebalance pipeline also removes the\n+ * excessive top state replicas. However, the default logic does not force resetting ALL the top\n+ * state replicas. Since the multiple top states situation may break application data, the default\n+ * resolution won't be enough to fix the potential problem.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top\n+   * state state model.\n+   */\n+  @Override\n+  public boolean checkCurrentStates(final CurrentStateOutput currentStateOutput,\n+      final String resourceName, final Partition partition, StateModelDefinition stateModelDef) {\n+    if (!stateModelDef.isSingleTopStateModel()) {", "originalCommit": "4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc5Mjc3MA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r434792770", "bodyText": "Not for this resolver.\n\nIf we have multiple top states requirements, then we need to have different resolvers.\nAs for non-top state, you mean we allow the resource to have no top state at all although the state model definition requires more than zero? Not sure how it can be done given the current rebalancer logic, but it is not considered as an abnormal for this resolver.", "author": "jiajunwang", "createdAt": "2020-06-03T19:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4OTUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk3ODgxNw==", "url": "https://github.com/apache/helix/pull/1037#discussion_r434978817", "bodyText": "For 1 is clear to me. But the question becomes if we need more than 1 resolver, how we gonna handle it.", "author": "junkaixue", "createdAt": "2020-06-04T03:58:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4OTUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk4NTgxNw==", "url": "https://github.com/apache/helix/pull/1037#discussion_r434985817", "bodyText": "This is controlled by the cluster config, if you still remember my previous PR #1028\nThe assumption is that in a certain cluster, one state model has only one resolver configured.", "author": "jiajunwang", "createdAt": "2020-06-04T04:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4OTUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAyNjI3MA==", "url": "https://github.com/apache/helix/pull/1037#discussion_r435026270", "bodyText": "I am fine with current top state one. But just thinking about the non-top state scenario. Because one resolver most likely works only for top state resolving. Anyway, we can think about it later.", "author": "junkaixue", "createdAt": "2020-06-04T06:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4OTUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA0MDc5Mg==", "url": "https://github.com/apache/helix/pull/1037#discussion_r435040792", "bodyText": "More than 1 top state?\n\"a single top state model\"?", "author": "huizhilu", "createdAt": "2020-06-04T07:16:05Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/constraint/ExcessiveTopStateResolver.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package org.apache.helix.controller.rebalancer.constraint;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.api.rebalancer.constraint.AbnormalStateResolver;\n+import org.apache.helix.controller.stages.CurrentStateOutput;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.StateModelDefinition;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The abnormal state resolver that gracefully fixes the abnormality of excessive top states for\n+ * single-topstate state model. For example, two replcias of a MasterSlave partition are assigned\n+ * with the Master state at the same time. This could be caused by a network partitioning or the\n+ * other unexpected issues.\n+ *\n+ * The resolver checks for the abnormality and computes recovery assignment which triggers the\n+ * rebalancer to eventually reset all the top state replias for once. After the resets, only one\n+ * replica will be assigned the top state.\n+ *\n+ * Note that without using this resolver, the regular Helix rebalance pipeline also removes the\n+ * excessive top state replicas. However, the default logic does not force resetting ALL the top\n+ * state replicas. Since the multiple top states situation may break application data, the default\n+ * resolution won't be enough to fix the potential problem.\n+ */\n+public class ExcessiveTopStateResolver implements AbnormalStateResolver {\n+  private static final Logger LOG = LoggerFactory.getLogger(ExcessiveTopStateResolver.class);\n+\n+  /**\n+   * The current states are not valid if there are more than 2 top state replicas for a single top", "originalCommit": "4cb4ddd5e981dd527f67bb6cb086b11dc09d1fdc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ2ODUzOQ==", "url": "https://github.com/apache/helix/pull/1037#discussion_r435468539", "bodyText": "Good catch", "author": "jiajunwang", "createdAt": "2020-06-04T18:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA0MDc5Mg=="}], "type": "inlineReview"}, {"oid": "c478eae9d3d68a8f742df039d02bb24ef246feec", "url": "https://github.com/apache/helix/commit/c478eae9d3d68a8f742df039d02bb24ef246feec", "message": "Address comments.", "committedDate": "2020-06-04T18:46:52Z", "type": "commit"}]}