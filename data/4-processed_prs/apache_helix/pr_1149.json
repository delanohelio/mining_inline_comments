{"pr_number": 1149, "pr_title": "Refine the ZkHelixManager.disconnect() method so it won't be blocked when the ZK connection breaks.", "pr_createdAt": "2020-07-14T05:06:32Z", "pr_url": "https://github.com/apache/helix/pull/1149", "timeline": [{"oid": "5623e9ccb9cc3f72c20111f0932d21cc57ebf74a", "url": "https://github.com/apache/helix/commit/5623e9ccb9cc3f72c20111f0932d21cc57ebf74a", "message": "Refine the ZkHelixManager.disconnect() method so it won't be blocked when the ZK connection breaks.\n\nThe issue was that if ZkHelixManager.disconnect() is called when the ZK connection is not synConnected, the disconnect() call will hang and never return. This usually blocks Helix users' code when they try to cleanup and finalize after ZK connection becomes unrecoverable.\nThis PR introduces a temporary thread to finish the cleanup work which relies on the ZK connection (or application code). This thread will be interrpted if ZK connection breaks before or during the disconnect process.", "committedDate": "2020-07-14T05:07:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE0MTAxMg==", "url": "https://github.com/apache/helix/pull/1149#discussion_r454141012", "bodyText": "Instead of giving a hard-coded timeout value, do you think we could use a CountDownLatch for this so the test doesn't depend on timing?", "author": "narendly", "createdAt": "2020-07-14T06:52:00Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkConnectionLost.java", "diffHunk": "@@ -103,6 +104,28 @@ public void afterClass() throws Exception {\n     TestHelper.stopZkServer(_zkServerRef.get());\n   }\n \n+  @Test\n+  public void testDisconnectWhenConnectionBreak() throws Exception {\n+    _zkServerRef.get().shutdown();\n+    AtomicBoolean disconnected = new AtomicBoolean(false);\n+    Thread testThread = new Thread(\"Testing HelixManager disconnect\") {\n+      @Override\n+      public void run() {\n+        _controller.disconnect();\n+        disconnected.set(true);\n+      }\n+    };\n+    try {\n+      testThread.start();\n+      testThread.join(5000);", "originalCommit": "8bee314ba8b8e208ca37bb5384c0bbfb2d309d25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE2Mzk2MQ==", "url": "https://github.com/apache/helix/pull/1149#discussion_r454163961", "bodyText": "I don't think so. Maybe I can make it a longer timeout. But if the logic is not working as expected, then the thread will never finish. So I'm not sure how the CountDownLatch can help here. Maybe you can elaborate on your idea?", "author": "jiajunwang", "createdAt": "2020-07-14T07:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDE0MTAxMg=="}], "type": "inlineReview"}, {"oid": "d3cc4b01503b137929f04eeb8488a4aa54ed470e", "url": "https://github.com/apache/helix/commit/d3cc4b01503b137929f04eeb8488a4aa54ed470e", "message": "Fix test.", "committedDate": "2020-07-14T08:19:32Z", "type": "forcePushed"}, {"oid": "231a65aec9f35f47f26354ebb14ae055b9054e82", "url": "https://github.com/apache/helix/commit/231a65aec9f35f47f26354ebb14ae055b9054e82", "message": "Fix test.", "committedDate": "2020-07-14T18:04:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU0OTkwNw==", "url": "https://github.com/apache/helix/pull/1149#discussion_r454549907", "bodyText": "Why are these imports needed?", "author": "narendly", "createdAt": "2020-07-14T18:13:25Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestZkConnectionLost.java", "diffHunk": "@@ -39,15 +40,15 @@\n import org.apache.helix.integration.task.WorkflowGenerator;\n import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n import org.apache.helix.manager.zk.ZNRecordSerializer;\n-import org.apache.helix.zookeeper.api.client.HelixZkClient;\n-import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;\n import org.apache.helix.task.JobConfig;\n import org.apache.helix.task.JobQueue;\n import org.apache.helix.task.TaskState;\n import org.apache.helix.task.WorkflowContext;\n import org.apache.helix.tools.ClusterSetup;\n import org.apache.helix.tools.ClusterVerifiers.BestPossibleExternalViewVerifier;\n import org.apache.helix.tools.ClusterVerifiers.ZkHelixClusterVerifier;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.impl.factory.SharedZkClientFactory;", "originalCommit": "d3cc4b01503b137929f04eeb8488a4aa54ed470e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU1NTQ3MQ==", "url": "https://github.com/apache/helix/pull/1149#discussion_r454555471", "bodyText": "Not added in this PR. This is auto re-ordering when I apply the latest format.", "author": "jiajunwang", "createdAt": "2020-07-14T18:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU0OTkwNw=="}], "type": "inlineReview"}, {"oid": "231a65aec9f35f47f26354ebb14ae055b9054e82", "url": "https://github.com/apache/helix/commit/231a65aec9f35f47f26354ebb14ae055b9054e82", "message": "Fix test.", "committedDate": "2020-07-14T18:04:14Z", "type": "forcePushed"}, {"oid": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85", "url": "https://github.com/apache/helix/commit/a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85", "message": "Simply the logic little bit.", "committedDate": "2020-07-16T01:03:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NjAwMQ==", "url": "https://github.com/apache/helix/pull/1149#discussion_r455956001", "bodyText": "Why this require an active zkclient? CallbackHandler are in memory object, is there anything we need to connection to ZK?", "author": "junkaixue", "createdAt": "2020-07-16T17:34:37Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -866,6 +858,83 @@ public void disconnect() {\n     }\n   }\n \n+  /**\n+   * The callback handler cleanup operations that require an active ZkClient connection.", "originalCommit": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk3NjYwNw==", "url": "https://github.com/apache/helix/pull/1149#discussion_r455976607", "bodyText": "we subscribe, and the subscription requires ZK connection.\nSome of our Helix callback handler implementations will read ZK even for finalizing.\nThere is no way to prevent any customer-defined handler logic to access ZK for finalizing.", "author": "jiajunwang", "createdAt": "2020-07-16T18:08:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NjAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NzQxMw==", "url": "https://github.com/apache/helix/pull/1149#discussion_r455957413", "bodyText": "It is complicated to create a listener for subscription. Shall we use some simple way to see whether the connection is alive? For example, just have an exist call for the cluster since it is in HelixManager?", "author": "junkaixue", "createdAt": "2020-07-16T17:37:04Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -866,6 +858,83 @@ public void disconnect() {\n     }\n   }\n \n+  /**\n+   * The callback handler cleanup operations that require an active ZkClient connection.\n+   * If ZkClient is not connected, Helix Manager shall skip the cleanup.\n+   *\n+   * @return true if the cleanup has been done successfully.\n+   */\n+  private boolean cleanupCallbackHandlers() {\n+    AtomicBoolean cleanupDone = new AtomicBoolean(false);\n+\n+    if (_zkclient.waitUntilConnected(_waitForConnectedTimeout, TimeUnit.MILLISECONDS)) {\n+      // Create a separate thread for executing cleanup task to avoid forever retry.\n+      Thread cleanupThread = new Thread(String\n+          .format(\"Cleanup thread for %s-%s-%s\", _clusterName, _instanceName, _instanceType)) {\n+        @Override\n+        public void run() {\n+          // TODO reset user defined handlers only\n+          resetHandlers(true);\n+\n+          if (_leaderElectionHandler != null) {\n+            _leaderElectionHandler.reset(true);\n+          }\n+\n+          ParticipantManager participantManager = _participantManager;\n+          if (participantManager != null) {\n+            participantManager.disconnect();\n+          }\n+\n+          cleanupDone.set(true);\n+        }\n+      };\n+\n+      // Define the state listener to terminate the cleanup thread when the ZkConnection breaks.\n+      IZkStateListener stateListener = new IZkStateListener() {", "originalCommit": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk3Nzk4MA==", "url": "https://github.com/apache/helix/pull/1149#discussion_r455977980", "bodyText": "just have an exist call for the cluster since it is in HelixManager? This is already done.\nHowever, this won't prevent if the connection breaks during the cleanup process.\nFor example, we have 10 callback handlers to reset, the connection breaks at the 5th one. Then the check before this cleanup process won't work. To achieve the goal, an alternative way is keeping checking the connection state in a loop. But that is a bad design compare to using the listener.", "author": "jiajunwang", "createdAt": "2020-07-16T18:10:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1NzQxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4Mzk0OA==", "url": "https://github.com/apache/helix/pull/1149#discussion_r455983948", "bodyText": "Will the call be hanging here as well? If there is no connection, cleanupThread got interrupted, but no one set this value to be true.", "author": "junkaixue", "createdAt": "2020-07-16T18:21:07Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixManager.java", "diffHunk": "@@ -866,6 +858,83 @@ public void disconnect() {\n     }\n   }\n \n+  /**\n+   * The callback handler cleanup operations that require an active ZkClient connection.\n+   * If ZkClient is not connected, Helix Manager shall skip the cleanup.\n+   *\n+   * @return true if the cleanup has been done successfully.\n+   */\n+  private boolean cleanupCallbackHandlers() {\n+    AtomicBoolean cleanupDone = new AtomicBoolean(false);\n+\n+    if (_zkclient.waitUntilConnected(_waitForConnectedTimeout, TimeUnit.MILLISECONDS)) {\n+      // Create a separate thread for executing cleanup task to avoid forever retry.\n+      Thread cleanupThread = new Thread(String\n+          .format(\"Cleanup thread for %s-%s-%s\", _clusterName, _instanceName, _instanceType)) {\n+        @Override\n+        public void run() {\n+          // TODO reset user defined handlers only\n+          resetHandlers(true);\n+\n+          if (_leaderElectionHandler != null) {\n+            _leaderElectionHandler.reset(true);\n+          }\n+\n+          ParticipantManager participantManager = _participantManager;\n+          if (participantManager != null) {\n+            participantManager.disconnect();\n+          }\n+\n+          cleanupDone.set(true);\n+        }\n+      };\n+\n+      // Define the state listener to terminate the cleanup thread when the ZkConnection breaks.\n+      IZkStateListener stateListener = new IZkStateListener() {\n+        @Override\n+        public void handleStateChanged(KeeperState state) {\n+          // If the connection breaks during the cleanup , then stop the cleanup thread.\n+          if (state != KeeperState.SyncConnected) {\n+            cleanupThread.interrupt();\n+          }\n+        }\n+\n+        @Override\n+        public void handleNewSession(String sessionId) {\n+          // nothing\n+        }\n+\n+        @Override\n+        public void handleSessionEstablishmentError(Throwable error) {\n+          // nothing\n+        }\n+      };\n+\n+      cleanupThread.start();\n+      try {\n+        // Subscribe and check the connection status one more time to ensure the thread is running\n+        // with an active ZkConnection.\n+        _zkclient.subscribeStateChanges(stateListener);\n+        if (!_zkclient.waitUntilConnected(0, TimeUnit.MILLISECONDS)) {\n+          cleanupThread.interrupt();\n+        }\n+\n+        try {\n+          cleanupThread.join();\n+        } catch (InterruptedException ex) {\n+          cleanupThread.interrupt();\n+        }\n+      } finally {\n+        _zkclient.unsubscribeStateChanges(stateListener);\n+      }\n+    } else {\n+      LOG.warn(\n+          \"ZkClient is not connected to the Zookeeper. Skip the cleanup work that requires accessing Zookeeper.\");\n+    }\n+\n+    return cleanupDone.get();", "originalCommit": "a6dcc4235af2ca71e0d6e0264b37fb5d133ecf85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4NjcyMA==", "url": "https://github.com/apache/helix/pull/1149#discussion_r455986720", "bodyText": "We are not waiting for it. It will just return whatever inside. This is a non-blocking call.", "author": "jiajunwang", "createdAt": "2020-07-16T18:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4Mzk0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4NzEzMg==", "url": "https://github.com/apache/helix/pull/1149#discussion_r455987132", "bodyText": "The result might be false if the clean up was not done completely due to disconnection.", "author": "jiajunwang", "createdAt": "2020-07-16T18:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk4Mzk0OA=="}], "type": "inlineReview"}]}