{"pr_number": 970, "pr_title": "Add async call retry to resolve the transient ZK connection issue.", "pr_createdAt": "2020-04-23T23:25:10Z", "pr_url": "https://github.com/apache/helix/pull/970", "timeline": [{"oid": "10a84592431e7a89320c3b36d07dc1da6decf78c", "url": "https://github.com/apache/helix/commit/10a84592431e7a89320c3b36d07dc1da6decf78c", "message": "Refine the method definition.", "committedDate": "2020-04-25T23:47:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMjE4Nw==", "url": "https://github.com/apache/helix/pull/970#discussion_r416922187", "bodyText": "Is this recursively self calling OK?", "author": "junkaixue", "createdAt": "2020-04-28T21:05:55Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -1758,50 +1776,66 @@ public void asyncSetData(final String path, Object datat, final int version,\n       data = serialize(datat, path);\n     } catch (ZkMarshallingError e) {\n       cb.processResult(KeeperException.Code.MARSHALLINGERROR.intValue(), path,\n-          new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT, 0, false), null);\n+          new ZkAsyncCallMonitorContext(_monitor, startT, 0, false), null);\n       return;\n     }\n+    doAsyncSetData(path, data, version, startT, cb);\n+  }\n+\n+  private void doAsyncSetData(final String path, byte[] data, final int version, final long startT,\n+      final ZkAsyncCallbacks.SetDataCallbackHandler cb) {\n     retryUntilConnected(() -> {\n       ((ZkConnection) getConnection()).getZookeeper().setData(path, data, version, cb,\n-          new ZkAsyncCallbacks.ZkAsyncCallContext(_monitor, startT,\n-              data == null ? 0 : data.length, false));\n+          new ZkAsyncRetryCallContext(_asyncCallRetryThread, cb, _monitor, startT,\n+              data == null ? 0 : data.length, false) {\n+            @Override\n+            protected void doRetry() {\n+              doAsyncSetData(path, data, version, System.currentTimeMillis(), cb);", "originalCommit": "10a84592431e7a89320c3b36d07dc1da6decf78c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNjQ1Ng==", "url": "https://github.com/apache/helix/pull/970#discussion_r416936456", "bodyText": "This is the design. If no connectivity issue, it won't be triggered. The assumption here is that the connectivity issue is transient and won't happen continuously.", "author": "jiajunwang", "createdAt": "2020-04-28T21:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMjE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwNTEzMA==", "url": "https://github.com/apache/helix/pull/970#discussion_r417505130", "bodyText": "I am not quite familiar with the way you use. I just wonder would that cause infinite call then stack overflow?", "author": "junkaixue", "createdAt": "2020-04-29T17:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMjE4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUwNzUyMA==", "url": "https://github.com/apache/helix/pull/970#discussion_r417507520", "bodyText": "If I say it won't, I guess you won't believe it so easily. Please take a look at the code carefully. In general, it is not a recursive call, it is a callback triggered in a different thread after this method is done. Even we keep retrying, only one call exists in the stack.", "author": "jiajunwang", "createdAt": "2020-04-29T18:00:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMjE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjIyNg==", "url": "https://github.com/apache/helix/pull/970#discussion_r416926226", "bodyText": "Would this be to many introduced for log?", "author": "junkaixue", "createdAt": "2020-04-28T21:12:56Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -122,44 +121,66 @@ public void handle() {\n   }\n \n   /**\n-   * Default callback for zookeeper async api\n+   * Default callback for zookeeper async api.\n    */\n-  public static abstract class DefaultCallback {\n-    AtomicBoolean _lock = new AtomicBoolean(false);\n-    int _rc = -1;\n+  public static abstract class DefaultCallback implements CancellableZkAsyncCallback {\n+    AtomicBoolean _isOperationDone = new AtomicBoolean(false);\n+    int _rc = UNKNOWN_RET_CODE;\n \n     public void callback(int rc, String path, Object ctx) {\n       if (rc != 0 && LOG.isDebugEnabled()) {\n         LOG.debug(this + \", rc:\" + Code.get(rc) + \", path: \" + path);\n       }\n \n-      if (ctx != null && ctx instanceof ZkAsyncCallContext) {\n-        ZkAsyncCallContext zkCtx = (ZkAsyncCallContext) ctx;\n-        if (zkCtx._monitor != null) {\n-          if (zkCtx._isRead) {\n-            zkCtx._monitor.record(path, zkCtx._bytes, zkCtx._startTimeMilliSec,\n-                ZkClientMonitor.AccessType.READ);\n-          } else {\n-            zkCtx._monitor.record(path, zkCtx._bytes, zkCtx._startTimeMilliSec,\n-                ZkClientMonitor.AccessType.WRITE);\n-          }\n-        }\n+      if (ctx != null && ctx instanceof ZkAsyncCallMonitorContext) {\n+        ((ZkAsyncCallMonitorContext) ctx).recordAccess(path);\n       }\n \n       _rc = rc;\n-      handle();\n \n-      synchronized (_lock) {\n-        _lock.set(true);\n-        _lock.notify();\n+      // If retry is requested by passing the retry callback context, do retry if necessary.\n+      if (needRetry(rc)) {\n+        if (ctx != null && ctx instanceof ZkAsyncRetryCallContext) {\n+          try {\n+            if (((ZkAsyncRetryCallContext) ctx).requestRetry()) {\n+              // The retry operation will be done asynchronously. Once it is done, the same callback\n+              // handler object shall be triggered to ensure the result is notified to the right\n+              // caller(s).\n+              return;\n+            } else {\n+              LOG.warn(\n+                  \"Cannot request to retry the operation. The retry request thread may have been stopped.\");\n+            }\n+          } catch (Throwable t) {\n+            LOG.error(\"Failed to request to retry the operation.\", t);\n+          }\n+        } else {\n+          LOG.warn(", "originalCommit": "10a84592431e7a89320c3b36d07dc1da6decf78c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzODU3Mw==", "url": "https://github.com/apache/helix/pull/970#discussion_r416938573", "bodyText": "I don't think so.\nThe first two logs only happen when retry is not possible because of some unknown error. We need to know in this case.\nThe third one happens if Helix devs changed the Helix code in a strange way. It never happens with the existing PR code.\nOverall, if everything works fine, we won't see any error messages.", "author": "jiajunwang", "createdAt": "2020-04-28T21:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIwOTM4OA==", "url": "https://github.com/apache/helix/pull/970#discussion_r418209388", "bodyText": "about \"Helix devs changed the Helix code in a strange way\":\nIt would be great if you can identify some of the places that code change can cause the issue and put some comments in that parts? so people will be careful about their changes that they are making later.", "author": "alirezazamani", "createdAt": "2020-04-30T18:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjIyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMjc0OQ==", "url": "https://github.com/apache/helix/pull/970#discussion_r418732749", "bodyText": "@alirezazamani I understand your concern. But there are many many ways to make it happen. I won't be able to comment about every case. Moreover, strictly speaking, this final check is not like an NPE check, this is not a failure case. This is just meaning that the caller does not want a retry. And this is not something we have to avoid, if logic requires, we shall still do it. It is just not happening, and a little bit strang for the current logic. But we shall not discourage people to use it in a different way in the future. At that moment, if this log becomes too verbose, we can downgrade it or remove it.", "author": "jiajunwang", "createdAt": "2020-05-01T20:52:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjIyNg=="}], "type": "inlineReview"}, {"oid": "385690c7e84c9ff02dc90905720b22fda058bc6a", "url": "https://github.com/apache/helix/commit/385690c7e84c9ff02dc90905720b22fda058bc6a", "message": "Add async call retry to resolve the transient ZK connection issue.\n\nThe current asyn callback will fail the operation and may return partial results eventually, if any exceptions happen during the call.\nThis change will make the ZkClient retry on the temporary ZK connection issues (CONNECTIONLOSS, OPERATIONTIMEOUT. SESSIONEXPIRED, SESSIONMOVED). So it has a larger chance to finish the operation if possible.\nNote that if the exception is due to business logic, the operation will still fail and the same return code will be sent to the callback handler.", "committedDate": "2020-05-04T17:56:48Z", "type": "commit"}, {"oid": "7a8d4b19e119b2067643a8a936a13c567f4b63c5", "url": "https://github.com/apache/helix/commit/7a8d4b19e119b2067643a8a936a13c567f4b63c5", "message": "Cancel pending retries when ZkClient is closed.", "committedDate": "2020-05-04T17:56:48Z", "type": "commit"}, {"oid": "6a5e1445b12f2dd0e070bc428584ca1407b78ce6", "url": "https://github.com/apache/helix/commit/6a5e1445b12f2dd0e070bc428584ca1407b78ce6", "message": "Add test.", "committedDate": "2020-05-04T17:56:48Z", "type": "commit"}, {"oid": "0f5944bcdd5336f30dcc8029a85eccbe9ab33f8f", "url": "https://github.com/apache/helix/commit/0f5944bcdd5336f30dcc8029a85eccbe9ab33f8f", "message": "Refine the method definition.", "committedDate": "2020-05-04T17:56:48Z", "type": "commit"}, {"oid": "0f5944bcdd5336f30dcc8029a85eccbe9ab33f8f", "url": "https://github.com/apache/helix/commit/0f5944bcdd5336f30dcc8029a85eccbe9ab33f8f", "message": "Refine the method definition.", "committedDate": "2020-05-04T17:56:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg4NzQ3Mw==", "url": "https://github.com/apache/helix/pull/970#discussion_r419887473", "bodyText": "We should give name of this thread that can be tied to the ZkEvent thread name. This way, when we debug it, we know the relation. Otherwise it would be very hard to correlate and reason.", "author": "kaisun2000", "createdAt": "2020-05-05T06:24:50Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/ZkClient.java", "diffHunk": "@@ -183,6 +190,9 @@ protected ZkClient(IZkConnection zkConnection, int connectionTimeout, long opera\n     _operationRetryTimeoutInMillis = operationRetryTimeout;\n     _isNewSessionEventFired = false;\n \n+    _asyncCallRetryThread = new ZkAsyncRetryThread(zkConnection.getServers());", "originalCommit": "0f5944bcdd5336f30dcc8029a85eccbe9ab33f8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzMjU3Mg==", "url": "https://github.com/apache/helix/pull/970#discussion_r419932572", "bodyText": "Good point, let me do it in a separate PR.", "author": "jiajunwang", "createdAt": "2020-05-05T08:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg4NzQ3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzNjE2Nw==", "url": "https://github.com/apache/helix/pull/970#discussion_r419936167", "bodyText": "Sorry I was confused by myself. Name already given in this PR.\n\"ZkClient-AsyncCallback-Retry-\" + getId() + \"-\" + name.", "author": "jiajunwang", "createdAt": "2020-05-05T08:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg4NzQ3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5OTQyMQ==", "url": "https://github.com/apache/helix/pull/970#discussion_r419899421", "bodyText": "These Aync call is normally for batch access from ZkBaseDataAccessor I believe.  Here, the idea is to not create ephemeral nodes because SESSIONEXPIRED can be retry. Then we should probably fail ephemeral code creating asyncly too, right?", "author": "kaisun2000", "createdAt": "2020-05-05T06:55:27Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -172,22 +193,52 @@ public int getRc() {\n       return _rc;\n     }\n \n+    @Override\n+    public void notifyCallers() {\n+      LOG.warn(\"The callback {} has been cancelled.\", this);\n+      markOperationDone();\n+    }\n+\n+    /**\n+     * Additional callback handling.\n+     */\n     abstract public void handle();\n-  }\n \n-  public static class ZkAsyncCallContext {\n-    private long _startTimeMilliSec;\n-    private int _bytes;\n-    private ZkClientMonitor _monitor;\n-    private boolean _isRead;\n+    private void markOperationDone() {\n+      synchronized (_isOperationDone) {\n+        _isOperationDone.set(true);\n+        _isOperationDone.notifyAll();\n+      }\n+    }\n \n-    public ZkAsyncCallContext(final ZkClientMonitor monitor, long startTimeMilliSec, int bytes,\n-        boolean isRead) {\n-      _monitor = monitor;\n-      _startTimeMilliSec = startTimeMilliSec;\n-      _bytes = bytes;\n-      _isRead = isRead;\n+    /**\n+     * @param rc the return code\n+     * @return true if the error is transient and the operation may succeed when being retried.\n+     */\n+    private boolean needRetry(int rc) {\n+      try {\n+        switch (Code.get(rc)) {\n+        /** Connection to the server has been lost */\n+        case CONNECTIONLOSS:\n+          /** The session has been expired by the server */\n+        case SESSIONEXPIRED:\n+          /** Session moved to another server, so operation is ignored */", "originalCommit": "0f5944bcdd5336f30dcc8029a85eccbe9ab33f8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzMzQzMA==", "url": "https://github.com/apache/helix/pull/970#discussion_r419933430", "bodyText": "I think we are not using the async call to create ephemeral nodes. But this might be a concern. If that becomes the case, let's make the same change for async call.", "author": "jiajunwang", "createdAt": "2020-05-05T08:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5OTQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwMTU2Mw==", "url": "https://github.com/apache/helix/pull/970#discussion_r419901563", "bodyText": "why change this value from -1 to 255?", "author": "kaisun2000", "createdAt": "2020-05-05T07:01:11Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -122,44 +121,66 @@ public void handle() {\n   }\n \n   /**\n-   * Default callback for zookeeper async api\n+   * Default callback for zookeeper async api.\n    */\n-  public static abstract class DefaultCallback {\n-    AtomicBoolean _lock = new AtomicBoolean(false);\n-    int _rc = -1;\n+  public static abstract class DefaultCallback implements CancellableZkAsyncCallback {\n+    AtomicBoolean _isOperationDone = new AtomicBoolean(false);\n+    int _rc = UNKNOWN_RET_CODE;", "originalCommit": "0f5944bcdd5336f30dcc8029a85eccbe9ab33f8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzMzUyMQ==", "url": "https://github.com/apache/helix/pull/970#discussion_r419933521", "bodyText": "-1 is a valid error code.", "author": "jiajunwang", "createdAt": "2020-05-05T08:08:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwMTU2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwOTczMQ==", "url": "https://github.com/apache/helix/pull/970#discussion_r419909731", "bodyText": "Need retry, retri-able context, but retry operation failed? What to do here? Mark done, return some retriable RC value like CONNECTIONLOSS is not what the customer expect to handle right?", "author": "kaisun2000", "createdAt": "2020-05-05T07:20:54Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/zkclient/callback/ZkAsyncCallbacks.java", "diffHunk": "@@ -122,44 +121,66 @@ public void handle() {\n   }\n \n   /**\n-   * Default callback for zookeeper async api\n+   * Default callback for zookeeper async api.\n    */\n-  public static abstract class DefaultCallback {\n-    AtomicBoolean _lock = new AtomicBoolean(false);\n-    int _rc = -1;\n+  public static abstract class DefaultCallback implements CancellableZkAsyncCallback {\n+    AtomicBoolean _isOperationDone = new AtomicBoolean(false);\n+    int _rc = UNKNOWN_RET_CODE;\n \n     public void callback(int rc, String path, Object ctx) {\n       if (rc != 0 && LOG.isDebugEnabled()) {\n         LOG.debug(this + \", rc:\" + Code.get(rc) + \", path: \" + path);\n       }\n \n-      if (ctx != null && ctx instanceof ZkAsyncCallContext) {\n-        ZkAsyncCallContext zkCtx = (ZkAsyncCallContext) ctx;\n-        if (zkCtx._monitor != null) {\n-          if (zkCtx._isRead) {\n-            zkCtx._monitor.record(path, zkCtx._bytes, zkCtx._startTimeMilliSec,\n-                ZkClientMonitor.AccessType.READ);\n-          } else {\n-            zkCtx._monitor.record(path, zkCtx._bytes, zkCtx._startTimeMilliSec,\n-                ZkClientMonitor.AccessType.WRITE);\n-          }\n-        }\n+      if (ctx != null && ctx instanceof ZkAsyncCallMonitorContext) {\n+        ((ZkAsyncCallMonitorContext) ctx).recordAccess(path);\n       }\n \n       _rc = rc;\n-      handle();\n \n-      synchronized (_lock) {\n-        _lock.set(true);\n-        _lock.notify();\n+      // If retry is requested by passing the retry callback context, do retry if necessary.\n+      if (needRetry(rc)) {\n+        if (ctx != null && ctx instanceof ZkAsyncRetryCallContext) {\n+          try {\n+            if (((ZkAsyncRetryCallContext) ctx).requestRetry()) {\n+              // The retry operation will be done asynchronously. Once it is done, the same callback\n+              // handler object shall be triggered to ensure the result is notified to the right\n+              // caller(s).\n+              return;\n+            } else {\n+              LOG.warn(\n+                  \"Cannot request to retry the operation. The retry request thread may have been stopped.\");\n+            }\n+          } catch (Throwable t) {\n+            LOG.error(\"Failed to request to retry the operation.\", t);", "originalCommit": "0f5944bcdd5336f30dcc8029a85eccbe9ab33f8f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkzNDAxNQ==", "url": "https://github.com/apache/helix/pull/970#discussion_r419934015", "bodyText": "It is. Because retry is not possible. So we have to return with a result instead of letting the caller pending forever.", "author": "jiajunwang", "createdAt": "2020-05-05T08:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTkwOTczMQ=="}], "type": "inlineReview"}]}