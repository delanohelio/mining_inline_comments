{"pr_number": 1413, "pr_title": "Feature: Offline Node Timeout During Maintenance Mode", "pr_createdAt": "2020-09-25T21:43:48Z", "pr_url": "https://github.com/apache/helix/pull/1413", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5OTcwMQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r495299701", "bodyText": "I think it may not be the place to do that. We can do it in maintenance recovery stage. I cannot remember the details of how to move the last offline time to history and set -1. It happened at cache refresh as well. So I think it is better to make it after cache refresh fully complete.", "author": "junkaixue", "createdAt": "2020-09-25T22:57:21Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -253,9 +254,34 @@ private void refreshIdealState(final HelixDataAccessor accessor,\n   private void refreshLiveInstances(final HelixDataAccessor accessor,\n       Set<HelixConstants.ChangeType> refreshedType) {\n     if (_propertyDataChangedMap.get(HelixConstants.ChangeType.LIVE_INSTANCE).getAndSet(false)) {\n+      // Keep a copy of old live instances in case of maintenance mode\n+      Map<String, LiveInstance> oldLiveInstances = getLiveInstances();\n       _liveInstanceCache.refresh(accessor);\n       _updateInstanceOfflineTime = true;\n       refreshedType.add(HelixConstants.ChangeType.LIVE_INSTANCE);\n+\n+      // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+      // for timed-out nodes\n+      long timeOutWindow = _clusterConfig.getMaintenanceOfflineNodeTimeOut();\n+      if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {\n+        for (String instance : _liveInstanceCache.getPropertyMap().keySet()) {\n+          // For every 'new' live node, check if it's timed-out\n+          if (!oldLiveInstances.containsKey(instance) && isInstanceTimedOutDuringMaintenance(", "originalCommit": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTMwNTYxNA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r495305614", "bodyText": "It needs to be here. The reason is that we need the old snapshot; see line 258. Once refresh happens, the old snapshot will be lost, and we wouldn't be able to compute the 'new' live nodes delta.\nIn terms of history update, it's updateOfflineInstanceHistory() down below. You can see that I also handled that case.", "author": "NealSun96", "createdAt": "2020-09-25T23:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5OTcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExNTExMw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496115113", "bodyText": "Then that may not be the snapshot we need. Because, this change could cause race condition and let old machine starting bootstrapping, which breaks our rule.", "author": "junkaixue", "createdAt": "2020-09-28T17:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5OTcwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI5MDA1NQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496290055", "bodyText": "Could you elaborate why there would be race conditions? The cache refresh is synchronously computed in the pipeline main thread; rebalancing is calculated on the same pipeline.\nAlso with Jiajun's comment: if filtering is done at getter, I don't think there would possibly be race conditions in this scenario.", "author": "NealSun96", "createdAt": "2020-09-28T23:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI5OTcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzODQ0OQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496138449", "bodyText": "It's better to ensure the cache has all the facts. Removing the timedout instances from the cache might be suboptimal since after this, no one tracking the real alive nodes anymore.\nIt would be easier to keep tracking the whole list and the timedout list, then if the filter option is turned on, we filter in the get method. In this way, we still have the capability to return the full list.", "author": "jiajunwang", "createdAt": "2020-09-28T18:05:41Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -253,9 +254,34 @@ private void refreshIdealState(final HelixDataAccessor accessor,\n   private void refreshLiveInstances(final HelixDataAccessor accessor,\n       Set<HelixConstants.ChangeType> refreshedType) {\n     if (_propertyDataChangedMap.get(HelixConstants.ChangeType.LIVE_INSTANCE).getAndSet(false)) {\n+      // Keep a copy of old live instances in case of maintenance mode\n+      Map<String, LiveInstance> oldLiveInstances = getLiveInstances();\n       _liveInstanceCache.refresh(accessor);\n       _updateInstanceOfflineTime = true;\n       refreshedType.add(HelixConstants.ChangeType.LIVE_INSTANCE);\n+\n+      // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+      // for timed-out nodes\n+      long timeOutWindow = _clusterConfig.getMaintenanceOfflineNodeTimeOut();\n+      if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {\n+        for (String instance : _liveInstanceCache.getPropertyMap().keySet()) {\n+          // For every 'new' live node, check if it's timed-out\n+          if (!oldLiveInstances.containsKey(instance) && isInstanceTimedOutDuringMaintenance(\n+              accessor, instance, timeOutWindow)) {\n+            _timedOutInstanceDuringMaintenance.add(instance);\n+          }\n+        }\n+\n+        // Remove all timed-out nodes that were recorded in this maintenance duration\n+        for (String instance : _timedOutInstanceDuringMaintenance) {\n+          _liveInstanceCache.deletePropertyByName(instance);", "originalCommit": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI5MDU5Mg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496290592", "bodyText": "That's a good idea. Will try.", "author": "NealSun96", "createdAt": "2020-09-28T23:29:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEzODQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MDY0MA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496140640", "bodyText": "If there is a leadership switch, the oldLiveInstances list will be empty. So the behavior would rely on isInstanceTimedOutDuringMaintenance() only. My guess is that we don't need oldLiveInstances list, since it won't be able to cover leadership switch case anyway.\nIf isInstanceTimedOutDuringMaintenance() has anything missed, so you have to relies on the oldLiveInstances list, then we need to fix it within the scope of isInstanceTimedOutDuringMaintenance().", "author": "jiajunwang", "createdAt": "2020-09-28T18:09:51Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -253,9 +254,34 @@ private void refreshIdealState(final HelixDataAccessor accessor,\n   private void refreshLiveInstances(final HelixDataAccessor accessor,\n       Set<HelixConstants.ChangeType> refreshedType) {\n     if (_propertyDataChangedMap.get(HelixConstants.ChangeType.LIVE_INSTANCE).getAndSet(false)) {\n+      // Keep a copy of old live instances in case of maintenance mode\n+      Map<String, LiveInstance> oldLiveInstances = getLiveInstances();\n       _liveInstanceCache.refresh(accessor);\n       _updateInstanceOfflineTime = true;\n       refreshedType.add(HelixConstants.ChangeType.LIVE_INSTANCE);\n+\n+      // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+      // for timed-out nodes\n+      long timeOutWindow = _clusterConfig.getMaintenanceOfflineNodeTimeOut();\n+      if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {\n+        for (String instance : _liveInstanceCache.getPropertyMap().keySet()) {\n+          // For every 'new' live node, check if it's timed-out\n+          if (!oldLiveInstances.containsKey(instance) && isInstanceTimedOutDuringMaintenance(", "originalCommit": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI5MTA4NA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496291084", "bodyText": "oldLiveInstances is for performance only. Losing it during leadership switch is still fine.", "author": "NealSun96", "createdAt": "2020-09-28T23:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MDY0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzIxMzY5Nw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r497213697", "bodyText": "Come to think about it, it's not fine: if oldLiveInstances is lost, every node is subject to timeout check; however, the timeout check only regards the node's last offline time. That means if a node is online for 8 weeks and last offline time is 9 weeks ago, we will still mark it as timed_out. That would be incorrect. Let me think about this case and update. @jiajunwang", "author": "NealSun96", "createdAt": "2020-09-30T02:52:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MDY0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYxMDUzOQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r498610539", "bodyText": "The new method should address the problem.", "author": "NealSun96", "createdAt": "2020-10-02T04:05:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MDY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MjI5NQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496142295", "bodyText": "nit, this calculation does not need to be bound with the maintenance mode, let's don't mention \"maintenance mode\" in the log.", "author": "jiajunwang", "createdAt": "2020-09-28T18:12:59Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +756,41 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    PropertyKey propertyKey = keyBuilder.participantHistory(instance);\n+    ParticipantHistory history = accessor.getProperty(propertyKey);\n+\n+    // Cannot use _instanceOfflineTimeMap. _instanceOfflineTimeMap is last updated in the previous\n+    // pipeline execution; it is possible a new offline timestamp is updated after the previous\n+    // pipeline execution, so we need the most updated timestamp.\n+    long lastOfflineTime = history.getLastTimeInOfflineHistory();\n+    // lastOfflineTime is only negative if there is no offline history or the time format is wrong.\n+    // Since this instance is a 'new' live instance, not having offline history = first time created\n+    // instance; during maintenance mode, no partition will be assigned to such a new instance,\n+    // therefore it's okay to no time it out. The wrong format case shouldn't happen at all and will\n+    // not be handled either.\n+    if (lastOfflineTime < 0) {\n+      return false;\n+    }\n+\n+    long currentTime = System.currentTimeMillis();\n+    if (currentTime - lastOfflineTime > timeOutWindow) {\n+      LogUtil.logWarn(logger, getClusterEventId(), String.format(\n+          \"During maintenance mode, instance %s is timed-out due to its offline time. Current time: \"", "originalCommit": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI5MTI3MQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496291271", "bodyText": "Why is that? This calculation is only done during the maintenance mode.", "author": "NealSun96", "createdAt": "2020-09-28T23:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MjI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NDYwMg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496144602", "bodyText": "Strictly check for ONLINE? Of course, keeping the < 0 checks for safe is still good here, but optional. I suggest adding \"lastOfflineTime == ONLINE\" to make the logic easier for the reader to understand.", "author": "jiajunwang", "createdAt": "2020-09-28T18:17:17Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +756,41 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    PropertyKey propertyKey = keyBuilder.participantHistory(instance);\n+    ParticipantHistory history = accessor.getProperty(propertyKey);\n+\n+    // Cannot use _instanceOfflineTimeMap. _instanceOfflineTimeMap is last updated in the previous\n+    // pipeline execution; it is possible a new offline timestamp is updated after the previous\n+    // pipeline execution, so we need the most updated timestamp.\n+    long lastOfflineTime = history.getLastTimeInOfflineHistory();\n+    // lastOfflineTime is only negative if there is no offline history or the time format is wrong.\n+    // Since this instance is a 'new' live instance, not having offline history = first time created\n+    // instance; during maintenance mode, no partition will be assigned to such a new instance,\n+    // therefore it's okay to no time it out. The wrong format case shouldn't happen at all and will\n+    // not be handled either.\n+    if (lastOfflineTime < 0) {", "originalCommit": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI5MjI5Ng==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496292296", "bodyText": "This isn't the actual LAST_OFFLINE_TIME field in History; I can understand the confusion due to variable name.\nI implemented a new function called getLastTimeInOfflineHistory() where the latest date in OFFLINE is returned. In the case when that cannot be returned, -1 will be the error indicator; you could refer the comment above for more detail.", "author": "NealSun96", "createdAt": "2020-09-28T23:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NDYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NjQ4MA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496146480", "bodyText": "There is a chance that we failed to record the offlinetime, or if pipeline runs slower, the offline time is not accurately recorded. I don't think there is a solution for it, but let's mention in the comment.", "author": "jiajunwang", "createdAt": "2020-09-28T18:20:51Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +756,41 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    PropertyKey propertyKey = keyBuilder.participantHistory(instance);\n+    ParticipantHistory history = accessor.getProperty(propertyKey);\n+\n+    // Cannot use _instanceOfflineTimeMap. _instanceOfflineTimeMap is last updated in the previous\n+    // pipeline execution; it is possible a new offline timestamp is updated after the previous\n+    // pipeline execution, so we need the most updated timestamp.\n+    long lastOfflineTime = history.getLastTimeInOfflineHistory();", "originalCommit": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NzY5Mg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496147692", "bodyText": "Due to the same reason, we might want to limit the timeout setup to be more than 5 mins (for example). A very small number does not make sense, and it won't work as expected anyway.", "author": "jiajunwang", "createdAt": "2020-09-28T18:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NjQ4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI5MjQ2Nw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496292467", "bodyText": "Sounds good;\nI will add that in the javadoc, what do you think? I don't think it should be strictly enforced.", "author": "NealSun96", "createdAt": "2020-09-28T23:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NjQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0ODgwMw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496148803", "bodyText": "nit, OFFLINE_NODE_TIME_OUT_FOR_MAINTENANCE_MODE?", "author": "jiajunwang", "createdAt": "2020-09-28T18:25:10Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterConfig.java", "diffHunk": "@@ -122,7 +122,13 @@\n     // don't specify their individual pool sizes, this value will be used for all participants; if\n     // none of participants or the cluster define pool sizes,\n     // TaskConstants.DEFAULT_TASK_THREAD_POOL_SIZE will be used to create pool sizes.\n-    GLOBAL_TARGET_TASK_THREAD_POOL_SIZE\n+    GLOBAL_TARGET_TASK_THREAD_POOL_SIZE,\n+\n+    // The time out window for offline nodes during maintenance mode; if an offline node has been\n+    // offline for more than this specified time period, it's treated as offline for the rest of\n+    // the maintenance mode's duration even when it comes online.\n+    // The unit is milliseconds.\n+    MAINTENANCE_OFFLINE_NODE_TIME_OUT", "originalCommit": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI5MjY5OA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496292698", "bodyText": "Sure, but wouldn't that be too long? I don't know the convention about variable length, so I took a shorter version.", "author": "NealSun96", "createdAt": "2020-09-28T23:36:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0ODgwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NzMzNA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496177334", "bodyText": "We need a test to cover the get default value case.\nMight be easier for you to combine the 2 new tests.", "author": "jiajunwang", "createdAt": "2020-09-28T19:18:42Z", "path": "helix-core/src/test/java/org/apache/helix/model/TestClusterConfig.java", "diffHunk": "@@ -298,6 +298,26 @@ public void testAsyncGlobalRebalanceOption() {\n             false), true);\n   }\n \n+  @Test\n+  public void testGetMaintenanceOfflineNodeTimeOut() {", "originalCommit": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI5Mjc0NA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496292744", "bodyText": "Sounds good.", "author": "NealSun96", "createdAt": "2020-09-28T23:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NzMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NzgwNQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496177805", "bodyText": "private?", "author": "jiajunwang", "createdAt": "2020-09-28T19:19:35Z", "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -40,7 +41,9 @@\n   private static Logger LOG = LoggerFactory.getLogger(ParticipantHistory.class);\n \n   private final static int HISTORY_SIZE = 20;\n-  private enum ConfigProperty {\n+  final static String HISTORY_DATE_FORMAT = \"yyyy-MM-dd'T'HH:mm:ss:SSS\";", "originalCommit": "ca409d40d1709a0f300c1e4fb09ac4112fbafafc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3ODYwOA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496178608", "bodyText": "If required in the test, then either put it in HelixConstants or redefine a string in the test case (this helps to prevent if anyone changes the format that breaks the compatibility)", "author": "jiajunwang", "createdAt": "2020-09-28T19:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NzgwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI5Mjg2NA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r496292864", "bodyText": "That's a great idea; I'll just redefine it in test.", "author": "NealSun96", "createdAt": "2020-09-28T23:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3NzgwNQ=="}], "type": "inlineReview"}, {"oid": "79ae83b100b296fb2a7bb2e871090c755b9bd472", "url": "https://github.com/apache/helix/commit/79ae83b100b296fb2a7bb2e871090c755b9bd472", "message": "Attempt to stabilize tests", "committedDate": "2020-09-30T01:49:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NDQ1OA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499044458", "bodyText": "It has the edge case for first interval. It is the interval online time just before maintenance mode, but somehow we dont check whether the offline time is before maintenance.\nLet's say if the instance is offline before maintenance we need the potential timeout = online time - Math.max(offlinetimestamp, maintenance entering time);", "author": "junkaixue", "createdAt": "2020-10-02T20:50:45Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +782,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {\n+      // Node is a new node in this maintenance mode, no need to time out since no partitions are\n+      // assigned to it\n+      return false;\n+    }\n+\n+    // Parse offline timestamps from offline list\n+    List<Long> offlineTimestamps = new ArrayList<>();\n+    List<String> historyOfflineList = history.getOffline();\n+    if (historyOfflineList != null) {\n+      long tailOfflineTime;\n+      for (int i = historyOfflineList.size() - 1; i >= 0; i--) {\n+        tailOfflineTime =\n+            ParticipantHistory.parseHistoryDateStringToLong(historyOfflineList.get(i));\n+        // Ignore bad format case\n+        if (tailOfflineTime != -1) {\n+          if (tailOfflineTime <= onlineTimestamps.get(0)) {\n+            break;\n+          }\n+          offlineTimestamps.add(0, tailOfflineTime);\n+        }\n+      }\n+    }\n+\n+    // At this point, onlineTimestamps contains at least 1 timestamp that's before maintenance mode;\n+    // offlineTimestamps contains 0+ timestamp that's > the first online timestamp.\n+    if (!offlineTimestamps.isEmpty()\n+        && offlineTimestamps.get(offlineTimestamps.size() - 1) > onlineTimestamps\n+        .get(onlineTimestamps.size() - 1)) {\n+      // Make sure for each offline timestamp, 2 online timestamps creates a range around it;\n+      // this is usually true unless the timestamps are malformed (missing online timestamps)\n+      onlineTimestamps.add(currentTime);\n+    }\n+\n+    // Hop between each pair of online timestamps and find the maximum offline window\n+    for (int onlineTimestampIndex = 1, offlineTimestampIndex = 0;\n+        onlineTimestampIndex < onlineTimestamps.size() && offlineTimestampIndex < offlineTimestamps\n+            .size(); onlineTimestampIndex++) {\n+      long onlineTimestamp = onlineTimestamps.get(onlineTimestampIndex);\n+      long offlineTimeStamp = offlineTimestamps.get(offlineTimestampIndex);\n+\n+      // If the offline timestamp isn't within this pair of online timestamp, continue\n+      if (offlineTimeStamp > onlineTimestamp) {\n+        continue;\n+      }\n+\n+      // Check the largest offline window against the timeout window\n+      if (onlineTimestamp - offlineTimeStamp > timeOutWindow) {", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA1MDQ4NQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499050485", "bodyText": "The first offline time is always after the first online time based on my parsing logic, see above.\nTherefore we always start checking by the second online time, and do (second online time - first offline time), for example.", "author": "NealSun96", "createdAt": "2020-10-02T21:06:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NDQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMjk4NQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499822985", "bodyText": "Do we really need to go through every pair? Can we just look at the pair with offline time before maintenance entrance and online time after it?", "author": "lei-xia", "createdAt": "2020-10-05T19:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NDQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkwMzEyNg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499903126", "bodyText": "@lei-xia We need to handle the case of \"offline for too long\" during maintenance mode as well, right?", "author": "NealSun96", "createdAt": "2020-10-05T22:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA0NDQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MDc4MA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499740780", "bodyText": "What is difference this w/ getLastOfflineTime?", "author": "lei-xia", "createdAt": "2020-10-05T16:55:58Z", "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -112,6 +129,22 @@ public long getLastOfflineTime() {\n     return offlineTime;\n   }\n \n+  /**\n+   * Get the time when this node last goes offline in history. If the node does not have offline\n+   * history or contains invalid date as the last element, return -1.\n+   *\n+   * @return\n+   */\n+  public long getLastTimeInOfflineHistory() {", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0Mzc0MQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499743741", "bodyText": "getLastOfflineTime returns LAST_OFFLINE_TIME, which can be either a timestamp or a -1 for ONLINE. getLastTimeInOfflineHistory returns the last timestamp in OFFLINE (list field), which is always a timestamp.", "author": "NealSun96", "createdAt": "2020-10-05T17:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MDc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MTQ5NA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499741494", "bodyText": "minor:  -> historyDateStringToLong?", "author": "lei-xia", "createdAt": "2020-10-05T16:57:10Z", "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +183,73 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(parseHistoryDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /**\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  public static long parseHistoryDateStringToLong(String dateString) {", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0NDc3Mg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499744772", "bodyText": "filterTimedOutInstances is a bit confusing, it could mean either the result contains only Timeouted Instances or the other way. Suggest to rename it as:  excludeTimeoutInstances.", "author": "lei-xia", "createdAt": "2020-10-05T17:03:07Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -428,13 +463,32 @@ public synchronized void setIdealStates(List<IdealState> idealStates) {\n   }\n \n   /**\n-   * Returns the LiveInstances for each of the instances that are curretnly up and running\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n    * @return\n    */\n   public Map<String, LiveInstance> getLiveInstances() {\n-    return _liveInstanceCache.getPropertyMap();\n+    return getLiveInstances(false);\n+  }\n+\n+  /**\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n+   * @param filterTimedOutInstances - Only set true during maintenance mode. If true, filter out\n+   *                                instances that are timed-out during maintenance mode; instances\n+   *                                are timed-out if they have been offline for a while before going\n+   *                                live during maintenance mode.\n+   * @return\n+   */\n+  public Map<String, LiveInstance> getLiveInstances(boolean filterTimedOutInstances) {", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODUwNQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499748505", "bodyText": "There could be some issue with this if a long-offline instance (say InstanceA) came back just after the cluster enter maintenance mode and before the next pipeline started.  InstanceA will be in the _liveInstanceSnapshotForMaintenance set (see line 261), so it will skip the timeout check here.", "author": "lei-xia", "createdAt": "2020-10-05T17:10:04Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -299,6 +306,33 @@ private void updateMaintenanceInfo(final HelixDataAccessor accessor) {\n     // The following flag is to guarantee that there's only one update per pineline run because we\n     // check for whether maintenance recovery could happen twice every pipeline\n     _hasMaintenanceSignalChanged = false;\n+\n+    // If maintenance mode has exited, clear cached timed-out nodes\n+    if (!_isMaintenanceModeEnabled) {\n+      _timedOutInstanceDuringMaintenance.clear();\n+    }\n+  }\n+\n+  private void timeoutNodesDuringMaintenance(final HelixDataAccessor accessor) {\n+    // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+    // for timed-out nodes\n+    long timeOutWindow = -1;\n+    if (_clusterConfig != null) {\n+      timeOutWindow = _clusterConfig.getOfflineNodeTimeOutForMaintenanceMode();\n+    }\n+    if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {\n+      for (String instance : _liveInstanceCache.getPropertyMap().keySet()) {\n+        // 1. Check timed-out cache and don't do repeated work;\n+        // 2. Check for nodes that didn't exist in the last iteration, because it has been checked;\n+        // 3. For all other nodes, check if it's timed-out.\n+        // When maintenance mode is first entered, all nodes will be checked as a result.\n+        if (!_timedOutInstanceDuringMaintenance.contains(instance)\n+            && !_liveInstanceSnapshotForMaintenance.containsKey(instance)\n+            && isInstanceTimedOutDuringMaintenance(accessor, instance, timeOutWindow)) {\n+          _timedOutInstanceDuringMaintenance.add(instance);", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NDUxNw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499754517", "bodyText": "For the first time it enters maintenance mode, there will be no snapshot stored. That's because maintenance mode signal is processed after refreshLiveInstances().\nSince the snapshot is empty, all nodes will be checked when we first enter maintenance mode.", "author": "NealSun96", "createdAt": "2020-10-05T17:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ0NTE1NQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500445155", "bodyText": "_liveInstanceSnapshotForMaintenance will be refreshed in the beginning of every pipeline, it contains all liveInstances (including these that should be timeout-ed), right? Say, if an (long-offline) instance comes back after the first pipeline before the next pipeline, that instance will be included in the _liveInstanceSnapshotForMaintenance and won't be checked here?   I.e, is _liveInstanceSnapshotForMaintenance\nalways equal to getLiveInstances()?  If it is, what is point of keeping a separate cache?", "author": "lei-xia", "createdAt": "2020-10-06T16:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3MTgxNA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500471814", "bodyText": "No, _liveInstanceSnapshotForMaintenance is equal to getLiveInstances() from the last pipeline. If a long-offline instance coms back after the first pipeline and before the next pipeline, it will not be in the snapshot obtained during the next pipeline, and will therefore be checked by the timeout logic. Whether this instance fails the check, it will be stored either in the snapshot or in the \"timed-out cache\", and it will not be checked by the pipeline after.", "author": "NealSun96", "createdAt": "2020-10-06T17:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODUwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY1ODgyOA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500658828", "bodyText": "This has been changed. We now rely on the previous calculation result, which makes more sense when reading.", "author": "NealSun96", "createdAt": "2020-10-06T23:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0ODUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0OTc0OQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499749749", "bodyText": "Can we cache the results somewhere (we may already have it?) instead of recomputing every time this method is called?  I think getLiveInstances are called in many places during one pipeline.", "author": "lei-xia", "createdAt": "2020-10-05T17:12:22Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -428,13 +463,32 @@ public synchronized void setIdealStates(List<IdealState> idealStates) {\n   }\n \n   /**\n-   * Returns the LiveInstances for each of the instances that are curretnly up and running\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n    * @return\n    */\n   public Map<String, LiveInstance> getLiveInstances() {\n-    return _liveInstanceCache.getPropertyMap();\n+    return getLiveInstances(false);\n+  }\n+\n+  /**\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n+   * @param filterTimedOutInstances - Only set true during maintenance mode. If true, filter out\n+   *                                instances that are timed-out during maintenance mode; instances\n+   *                                are timed-out if they have been offline for a while before going\n+   *                                live during maintenance mode.\n+   * @return\n+   */\n+  public Map<String, LiveInstance> getLiveInstances(boolean filterTimedOutInstances) {", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NTI4Ng==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499755286", "bodyText": "Makes sense.", "author": "NealSun96", "createdAt": "2020-10-05T17:22:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0OTc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MDQwNw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499750407", "bodyText": "In which places we will need  LiveInstances containing timeouted instance?", "author": "lei-xia", "createdAt": "2020-10-05T17:13:34Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -428,13 +463,32 @@ public synchronized void setIdealStates(List<IdealState> idealStates) {\n   }\n \n   /**\n-   * Returns the LiveInstances for each of the instances that are curretnly up and running\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n    * @return\n    */\n   public Map<String, LiveInstance> getLiveInstances() {", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NzY3Mg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499757672", "bodyText": "In short: everywhere else that isn't critical to \"timing out\" instances.\nThe new getLiveInstances(boolean) is minimized to only one place: MessageGenerationPhase. This approach minimizes any impact to existing code while also making the \"timed-out\" instances not reachable from the controller; effectively, those instances will have no operations done on them. This decision is made after @jiajunwang 's comment that we shouldn't directly alter the live instance cache; we should only alter the getter.\nPlease let me know if this change makes sense. I believe only changing MessageGenerationPhase is sufficient.", "author": "NealSun96", "createdAt": "2020-10-05T17:26:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MDQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1NTYzOQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499855639", "bodyText": "Actually I'm rethinking this. There could be some external view issue. Will update.", "author": "NealSun96", "createdAt": "2020-10-05T20:33:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MDQwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg5MTY4Ng==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499891686", "bodyText": "Now getLiveInstances will default to excluding timed-out ones.", "author": "NealSun96", "createdAt": "2020-10-05T21:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1MDQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5MjI4OQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499792289", "bodyText": "Could this create inconsistency since LivInstances used by all other places in the pipeline are different from here?", "author": "lei-xia", "createdAt": "2020-10-05T18:31:16Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/MessageGenerationPhase.java", "diffHunk": "@@ -89,7 +89,7 @@ protected void processEvent(ClusterEvent event, ResourcesStateMap resourcesState\n           + \". Requires HelixManager|DataCache|RESOURCES|CURRENT_STATE|INTERMEDIATE_STATE\");\n     }\n \n-    Map<String, LiveInstance> liveInstances = cache.getLiveInstances();\n+    Map<String, LiveInstance> liveInstances = cache.getLiveInstances(true);", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1NTc2Nw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499855767", "bodyText": "Duplicate discussion with the above comment.", "author": "NealSun96", "createdAt": "2020-10-05T20:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5MjI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTA4OA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499821088", "bodyText": "Can we wrap up the logic here into a method in ParticipantHistory, such as getAllOnlineHistory()?", "author": "lei-xia", "createdAt": "2020-10-05T19:25:59Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +782,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MzQ4MA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499853480", "bodyText": "Please see below.", "author": "NealSun96", "createdAt": "2020-10-05T20:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYyMTAwMA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500621000", "bodyText": "Moved to ParticipantHistory", "author": "NealSun96", "createdAt": "2020-10-06T22:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTQ2Mw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499821463", "bodyText": "Similar here, the logic should belong to ParticipantHistory, such as getAllOfflineHistory().", "author": "lei-xia", "createdAt": "2020-10-05T19:26:44Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +782,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {\n+      // Node is a new node in this maintenance mode, no need to time out since no partitions are\n+      // assigned to it\n+      return false;\n+    }\n+\n+    // Parse offline timestamps from offline list\n+    List<Long> offlineTimestamps = new ArrayList<>();\n+    List<String> historyOfflineList = history.getOffline();\n+    if (historyOfflineList != null) {\n+      long tailOfflineTime;\n+      for (int i = historyOfflineList.size() - 1; i >= 0; i--) {\n+        tailOfflineTime =\n+            ParticipantHistory.parseHistoryDateStringToLong(historyOfflineList.get(i));\n+        // Ignore bad format case\n+        if (tailOfflineTime != -1) {\n+          if (tailOfflineTime <= onlineTimestamps.get(0)) {\n+            break;\n+          }\n+          offlineTimestamps.add(0, tailOfflineTime);\n+        }\n+      }", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MzU0OA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499853548", "bodyText": "Please see below.", "author": "NealSun96", "createdAt": "2020-10-05T20:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYyMTA2MQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500621061", "bodyText": "Moved to ParticipantHistory", "author": "NealSun96", "createdAt": "2020-10-06T22:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMjM3Mg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499822372", "bodyText": "This may not be true, for example, a newly added host?  (I.e, our code should be able to handle these corner cases properly).", "author": "lei-xia", "createdAt": "2020-10-05T19:28:29Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +782,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {\n+      // Node is a new node in this maintenance mode, no need to time out since no partitions are\n+      // assigned to it\n+      return false;\n+    }\n+\n+    // Parse offline timestamps from offline list\n+    List<Long> offlineTimestamps = new ArrayList<>();\n+    List<String> historyOfflineList = history.getOffline();\n+    if (historyOfflineList != null) {\n+      long tailOfflineTime;\n+      for (int i = historyOfflineList.size() - 1; i >= 0; i--) {\n+        tailOfflineTime =\n+            ParticipantHistory.parseHistoryDateStringToLong(historyOfflineList.get(i));\n+        // Ignore bad format case\n+        if (tailOfflineTime != -1) {\n+          if (tailOfflineTime <= onlineTimestamps.get(0)) {\n+            break;\n+          }\n+          offlineTimestamps.add(0, tailOfflineTime);\n+        }\n+      }\n+    }\n+\n+    // At this point, onlineTimestamps contains at least 1 timestamp that's before maintenance mode;\n+    // offlineTimestamps contains 0+ timestamp that's > the first online timestamp.", "originalCommit": "ceff69d774c1c2a9149ae090e231df8c499ff125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTg1MzM4NA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r499853384", "bodyText": "This ties back to the previous 2 sections of algorithm: they are not just parsing the dates. The first section stops parsing as soon as the first timestamp that's before maintenance mode; if there's no such timestamp, it just returns false (for newly added host). The second section stops parsing as soon as the timestamp is just after the first online timestamp. This is also why these logic should not be a member logic to ParticipantHistory because they are not meant to be generic.", "author": "NealSun96", "createdAt": "2020-10-05T20:28:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMjM3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxMTkzOA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500511938", "bodyText": "As I mentioned above, the current logic is too complicated than it needs to be. For a newly added node, the offline time is timestamp 0. So it is definitely timeout.", "author": "jiajunwang", "createdAt": "2020-10-06T18:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMjM3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY1NDg3Mg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500654872", "bodyText": "The algorithm has been reworked to look less complicated. Its essence remains - all mentioned edge cases are taken care of.", "author": "NealSun96", "createdAt": "2020-10-06T23:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgyMjM3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5MTMyNg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500491326", "bodyText": "I suggest making it explicit.\nOne method getAllLiveInstances(), another one something like getActiveLiveInstance().\nIn the future, the later one can be extended to return different lists according to the conditions (maintenance mode is the first example).", "author": "jiajunwang", "createdAt": "2020-10-06T17:58:50Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -428,13 +471,30 @@ public synchronized void setIdealStates(List<IdealState> idealStates) {\n   }\n \n   /**\n-   * Returns the LiveInstances for each of the instances that are curretnly up and running\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n    * @return\n    */\n   public Map<String, LiveInstance> getLiveInstances() {\n+    return getLiveInstances(true);\n+  }\n+\n+  /**\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n+   * @param excludeTimeoutInstances - Only effective during maintenance mode. If true, filter out\n+   *                                instances that are timed-out during maintenance mode; instances\n+   *                                are timed-out if they have been offline for a while before going\n+   *                                live during maintenance mode.\n+   * @return\n+   */\n+  public Map<String, LiveInstance> getLiveInstances(boolean excludeTimeoutInstances) {", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNTkyMw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500605923", "bodyText": "Discussed offline: function is made private. It can be extended later on.", "author": "NealSun96", "createdAt": "2020-10-06T21:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ5MTMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUwNTc3OQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500505779", "bodyText": "Just put the logic into a non-static method getOnlineTimestamp()? Which directly returns List.", "author": "jiajunwang", "createdAt": "2020-10-06T18:22:03Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +788,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUwNzU0Nw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500507547", "bodyText": "nit, I think you need all the online timestamp before the _maintenanceSignal create time. Otherwise, you don't need this list. So the comment is not accurate.", "author": "jiajunwang", "createdAt": "2020-10-06T18:24:43Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +788,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxMDk5NQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500510995", "bodyText": "I agree these nodes shall be excluded. But we are actually doing this for a different reason.\nNote that the logic is a node is offline for a long time and back online during the M mode. In this case, the new node previous offline time is 0. So it is definitely timed out. So we don't need this logic here. The later logic shall be able to cover this case.", "author": "jiajunwang", "createdAt": "2020-10-06T18:29:53Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +788,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUxMzEwNQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500513105", "bodyText": "Same here, getOfflineTimestamp", "author": "jiajunwang", "createdAt": "2020-10-06T18:33:15Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +788,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {\n+        tailOnlineTime =\n+            ParticipantHistory.extractTimeFromSessionHistoryString(historyOnlineList.get(i));\n+        // Ignore bad format case\n+        if (tailOnlineTime != -1) {\n+          onlineTimestamps.add(0, tailOnlineTime);\n+          // We only need one online timestamp before maintenance mode starts\n+          if (tailOnlineTime <= _maintenanceSignal.getTimestamp()) {\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    if (onlineTimestamps.isEmpty() || onlineTimestamps.get(0) > _maintenanceSignal.getTimestamp()) {\n+      // Node is a new node in this maintenance mode, no need to time out since no partitions are\n+      // assigned to it\n+      return false;\n+    }\n+\n+    // Parse offline timestamps from offline list\n+    List<Long> offlineTimestamps = new ArrayList<>();\n+    List<String> historyOfflineList = history.getOffline();\n+    if (historyOfflineList != null) {\n+      long tailOfflineTime;\n+      for (int i = historyOfflineList.size() - 1; i >= 0; i--) {\n+        tailOfflineTime =\n+            ParticipantHistory.historyDateStringToLong(historyOfflineList.get(i));", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU0NjA3NQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500546075", "bodyText": "nit, the logic might be clearer for the readers if you just subtract the list and then read the last one. Otherwise, you have multiple lists with different orders. And get(0) in the following code could be a mystery for others.", "author": "jiajunwang", "createdAt": "2020-10-06T19:32:00Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +788,100 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,\n+      long timeOutWindow) {\n+    ParticipantHistory history =\n+        accessor.getProperty(accessor.keyBuilder().participantHistory(instance));\n+    long currentTime = System.currentTimeMillis();\n+\n+    // Parse online timestamps from online list\n+    List<Long> onlineTimestamps = new ArrayList<>();\n+    List<String> historyOnlineList = history.getHistory();\n+    if (historyOnlineList != null) {\n+      long tailOnlineTime;\n+      for (int i = historyOnlineList.size() - 1; i >= 0; i--) {", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1MTM5OQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500551399", "bodyText": "I guess this one is corresponding to the _liveInstanceSnapshotForMaintenance check. I prefer not to add this.\n\nIf the cache update fails due to ZK issue, then we might have the _liveInstanceSnapshotForMaintenance updated but _timedOutInstanceDuringMaintenance is not fully calculated.\nThe performance enhancement of using this map is not significant. Let's ensure it works fine first.", "author": "jiajunwang", "createdAt": "2020-10-06T19:42:09Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -299,6 +307,40 @@ private void updateMaintenanceInfo(final HelixDataAccessor accessor) {\n     // The following flag is to guarantee that there's only one update per pineline run because we\n     // check for whether maintenance recovery could happen twice every pipeline\n     _hasMaintenanceSignalChanged = false;\n+\n+    // If maintenance mode has exited, clear cached timed-out nodes\n+    if (!_isMaintenanceModeEnabled) {\n+      _timedOutInstanceDuringMaintenance.clear();\n+      _liveInstanceSnapshotForMaintenance.clear();\n+    }\n+  }\n+\n+  private void timeoutNodesDuringMaintenance(final HelixDataAccessor accessor) {\n+    // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+    // for timed-out nodes\n+    long timeOutWindow = -1;\n+    if (_clusterConfig != null) {\n+      timeOutWindow = _clusterConfig.getOfflineNodeTimeOutForMaintenanceMode();\n+    }\n+    if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {\n+      for (String instance : _liveInstanceCache.getPropertyMap().keySet()) {\n+        // 1. Check timed-out cache and don't do repeated work;\n+        // 2. Check for nodes that didn't exist in the last iteration, because it has been checked;", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwNDM4OA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500604388", "bodyText": "Discussed offline: the snapshot variable is replaced and now it's okay for ZK to be disrupted at any point. _timedOutInstanceDuringMaintenance can be partially completed - other nodes will be checked again. The new snapshot variable (which is just _liveInstanceExcludeTimedOutForMaintenance) is computed after this step and will always store the correct truth of \"what instances are checked\"; it can be partially completed - other nodes will be checked again.", "author": "NealSun96", "createdAt": "2020-10-06T21:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1MTM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1MzU4NA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500553584", "bodyText": "Please be careful about the cache update order. refreshLiveInstances is called before updateMaintenanceInfo. So I guess this map never works as expected. As I suggested, just remove this map to reduce the potential risk. ROI is low.", "author": "jiajunwang", "createdAt": "2020-10-06T19:46:21Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -253,6 +257,10 @@ private void refreshIdealState(final HelixDataAccessor accessor,\n   private void refreshLiveInstances(final HelixDataAccessor accessor,\n       Set<HelixConstants.ChangeType> refreshedType) {\n     if (_propertyDataChangedMap.get(HelixConstants.ChangeType.LIVE_INSTANCE).getAndSet(false)) {\n+      // Keep a snapshot of old live instances for maintenance mode\n+      if (isMaintenanceModeEnabled()) {", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3ODMwNA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500578304", "bodyText": "This is intentional. When maintenance mode is first started, the snapshot is left empty so that all nodes are checked.", "author": "NealSun96", "createdAt": "2020-10-06T20:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1MzU4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwMzM4Mw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500603383", "bodyText": "Discussed offline. This variable is removed and replaced by the cached result of live instances excluding timed-out ones. That way the intention is more clear.", "author": "NealSun96", "createdAt": "2020-10-06T21:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1MzU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1NDYzNA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500554634", "bodyText": "To reduce the implicit dependencies between the refresh/update methods, please input the isMaintenanceModeEnabled as a parameter. So the caller is more likely to pass the refreshed value.\nOverall, we shall reduce referring to the private field directly to decouple methods and prevent potential bugs.", "author": "jiajunwang", "createdAt": "2020-10-06T19:48:31Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -299,6 +307,40 @@ private void updateMaintenanceInfo(final HelixDataAccessor accessor) {\n     // The following flag is to guarantee that there's only one update per pineline run because we\n     // check for whether maintenance recovery could happen twice every pipeline\n     _hasMaintenanceSignalChanged = false;\n+\n+    // If maintenance mode has exited, clear cached timed-out nodes\n+    if (!_isMaintenanceModeEnabled) {\n+      _timedOutInstanceDuringMaintenance.clear();\n+      _liveInstanceSnapshotForMaintenance.clear();\n+    }\n+  }\n+\n+  private void timeoutNodesDuringMaintenance(final HelixDataAccessor accessor) {\n+    // If maintenance mode is enabled and timeout window is specified, filter 'new' live nodes\n+    // for timed-out nodes\n+    long timeOutWindow = -1;\n+    if (_clusterConfig != null) {\n+      timeOutWindow = _clusterConfig.getOfflineNodeTimeOutForMaintenanceMode();\n+    }\n+    if (timeOutWindow >= 0 && isMaintenanceModeEnabled()) {", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDYwMzQ2Mw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500603463", "bodyText": "Done.", "author": "NealSun96", "createdAt": "2020-10-06T21:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1NDYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1NzY3Mg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500557672", "bodyText": "As commented above, these 2 methods can be private if we directly return the lists of Long", "author": "jiajunwang", "createdAt": "2020-10-06T19:54:17Z", "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +183,73 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /**\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  public static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /**\n+   * Parses a history date in millisecond to string.\n+   */\n+  public static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU1ODEwMQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500558101", "bodyText": "nit, warning in these abnormal case for debugging.", "author": "jiajunwang", "createdAt": "2020-10-06T19:55:05Z", "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +183,73 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /**\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  public static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /**\n+   * Parses a history date in millisecond to string.\n+   */\n+  public static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }\n+\n+  /**\n+   * Parses the session entry map that has been converted to string back to a map.\n+   * NOTE TO CALLER: This assumes the divider between entries is \", \" and the divider between\n+   * key/value is \"=\"; if the string is malformed, parsing correctness is not guaranteed. Always\n+   * check if a key is contained before using the key.\n+   */\n+  public static Map<String, String> parseSessionHistoryStringToMap(String sessionHistoryString) {\n+    sessionHistoryString = sessionHistoryString.substring(1, sessionHistoryString.length() - 1);\n+    Map<String, String> sessionHistoryMap = new HashMap<>();\n+\n+    for (String sessionHistoryKeyValuePair : sessionHistoryString.split(\", \")) {\n+      String[] keyValuePair = sessionHistoryKeyValuePair.split(\"=\");\n+      if (keyValuePair.length < 2) {\n+        continue;", "originalCommit": "752db754f2f37633fe54742c2c8f3ca6e3ad96b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2ODM4Mg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500668382", "bodyText": "I think you don't need these 2 methods to be public?", "author": "jiajunwang", "createdAt": "2020-10-07T00:24:04Z", "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -64,6 +69,20 @@ public ParticipantHistory(ZNRecord znRecord) {\n     super(znRecord);\n   }\n \n+  /**\n+   * @return The list field for HISTORY\n+   */\n+  public List<String> getHistory() {\n+    return _record.getListField(ConfigProperty.HISTORY.name());\n+  }\n+\n+  /**\n+   * @return The list field for OFFLINE\n+   */\n+  public List<String> getOffline() {\n+    return _record.getListField(ConfigProperty.OFFLINE.name());\n+  }\n+", "originalCommit": "f2badf5808d5a0a86af52b38058fdc7bed7c02c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3NjI4MQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500676281", "bodyText": "They are public because\n\nwe should provide accessors since now there are actual code usage of ParticipantHistory; and,\nan integration test calls these functions.", "author": "NealSun96", "createdAt": "2020-10-07T00:53:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2ODM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1Nzk1OQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r501257959", "bodyText": "you have the methods which return the timestamps. The raw string is hard to use and we shall not return it.\nintegration test can rely on protected methods.", "author": "jiajunwang", "createdAt": "2020-10-07T19:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2ODM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEzMDQ3Mw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r502130473", "bodyText": "I disagree with this. For a HelixProperty class, if there is a need of a field, there should be an accessor. It is true that we have timestamp parsers now, but for example, HISTORY contains other informations too. Down the road, there may be other code that relies on other HISTORY information. What would happen then? An accessor will be built. Right now there is a need to these fields, and I don't see a reason to not create accessors.\nFor integration test it's not in the same package, so I don't think package private (nor protected) can help. This is a minor point; there are workarounds. My main point is the previous paragraph.", "author": "NealSun96", "createdAt": "2020-10-09T01:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2ODM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NjY4OA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r502596688", "bodyText": "\"What would happen then?\" Then we add other methods to access this information explicitly. The string return which requires additional parse is a bad idea in general.\n\nWhat if we change the string format? These methods return string will be non-backward-compatible. And we don't want to restrict ourselves unnecessarily, right?\nLike you add the getOnlineTimestamp now, we can add other methods that parse the HISTORY string and return the required information.\nThe necessity of testing does not require us to make it public. We can make the test in the same package. Or read the field directly from ZNRecord. There are many ways to achieve it and public is the most impactful and costly (maintenance cost) way. I think it is not good option.", "author": "jiajunwang", "createdAt": "2020-10-09T18:13:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2ODM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2ODg0OA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500668848", "bodyText": "Log the error here.", "author": "jiajunwang", "createdAt": "2020-10-07T00:25:32Z", "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +185,99 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /*\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  private static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /*\n+   * Parses a history date in millisecond to string.\n+   */\n+  private static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }\n+\n+  /**\n+   * Parses the session entry map that has been converted to string back to a map.\n+   * NOTE TO CALLER: This assumes the divider between entries is \", \" and the divider between\n+   * key/value is \"=\"; if the string is malformed, parsing correctness is not guaranteed. Always\n+   * check if a key is contained before using the key.\n+   */\n+  public static Map<String, String> parseSessionHistoryStringToMap(String sessionHistoryString) {\n+    sessionHistoryString = sessionHistoryString.substring(1, sessionHistoryString.length() - 1);\n+    Map<String, String> sessionHistoryMap = new HashMap<>();\n+\n+    for (String sessionHistoryKeyValuePair : sessionHistoryString.split(\", \")) {\n+      String[] keyValuePair = sessionHistoryKeyValuePair.split(\"=\");\n+      if (keyValuePair.length < 2) {\n+        LOG.warn(\"Ignore key value pair while parsing session history due to missing '=': \" +\n+            sessionHistoryKeyValuePair);\n+        continue;\n+      }\n+      sessionHistoryMap.put(keyValuePair[0], keyValuePair[1]);\n+    }\n+\n+    return sessionHistoryMap;\n+  }\n+\n+  /*\n+   * Take a string session history entry and extract the TIME field out of it. Return -1 if the TIME\n+   * field doesn't exist or if the TIME field cannot be parsed to a long.\n+   */\n+  private static long extractTimeFromSessionHistoryString(String sessionHistoryString) {\n+    Map<String, String> sessionHistoryMap = parseSessionHistoryStringToMap(sessionHistoryString);\n+    if (!sessionHistoryMap.containsKey(ConfigProperty.TIME.name())) {\n+      return -1;\n+    }\n+    try {\n+      return Long.parseLong(sessionHistoryMap.get(ConfigProperty.TIME.name()));\n+    } catch (NumberFormatException e) {\n+      return -1;", "originalCommit": "f2badf5808d5a0a86af52b38058fdc7bed7c02c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2OTIzNQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500669235", "bodyText": "Shall we just call it getOnlineTimestampsAsMilliseconds?", "author": "jiajunwang", "createdAt": "2020-10-07T00:27:01Z", "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +185,99 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /*\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  private static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /*\n+   * Parses a history date in millisecond to string.\n+   */\n+  private static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }\n+\n+  /**\n+   * Parses the session entry map that has been converted to string back to a map.\n+   * NOTE TO CALLER: This assumes the divider between entries is \", \" and the divider between\n+   * key/value is \"=\"; if the string is malformed, parsing correctness is not guaranteed. Always\n+   * check if a key is contained before using the key.\n+   */\n+  public static Map<String, String> parseSessionHistoryStringToMap(String sessionHistoryString) {\n+    sessionHistoryString = sessionHistoryString.substring(1, sessionHistoryString.length() - 1);\n+    Map<String, String> sessionHistoryMap = new HashMap<>();\n+\n+    for (String sessionHistoryKeyValuePair : sessionHistoryString.split(\", \")) {\n+      String[] keyValuePair = sessionHistoryKeyValuePair.split(\"=\");\n+      if (keyValuePair.length < 2) {\n+        LOG.warn(\"Ignore key value pair while parsing session history due to missing '=': \" +\n+            sessionHistoryKeyValuePair);\n+        continue;\n+      }\n+      sessionHistoryMap.put(keyValuePair[0], keyValuePair[1]);\n+    }\n+\n+    return sessionHistoryMap;\n+  }\n+\n+  /*\n+   * Take a string session history entry and extract the TIME field out of it. Return -1 if the TIME\n+   * field doesn't exist or if the TIME field cannot be parsed to a long.\n+   */\n+  private static long extractTimeFromSessionHistoryString(String sessionHistoryString) {\n+    Map<String, String> sessionHistoryMap = parseSessionHistoryStringToMap(sessionHistoryString);\n+    if (!sessionHistoryMap.containsKey(ConfigProperty.TIME.name())) {\n+      return -1;\n+    }\n+    try {\n+      return Long.parseLong(sessionHistoryMap.get(ConfigProperty.TIME.name()));\n+    } catch (NumberFormatException e) {\n+      return -1;\n+    }\n+  }\n+\n+  /**\n+   * For each entry in History, return its millisecond timestamp; for timestamps that cannot be\n+   * parsed, skip them.\n+   */\n+  public List<Long> getHistoryTimestampsAsMilliseconds() {", "originalCommit": "f2badf5808d5a0a86af52b38058fdc7bed7c02c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3ODM5OQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500678399", "bodyText": "I had this debate too, but I think in the context of ParticipantHistory, the field names should be respected. The field is HISTORY.", "author": "NealSun96", "createdAt": "2020-10-07T01:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2OTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI1NzQyMg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r501257422", "bodyText": "But it is not clear to the caller what do you get.", "author": "jiajunwang", "createdAt": "2020-10-07T19:27:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2OTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjEyOTExMg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r502129112", "bodyText": "I understand what you mean, and since I also want to call it getOnlineTimestamps, I made the change.\nThough I don't think the old naming is bad: callers get the History timestamps, as advertised. If they don't know what these are they should read the class. \ud83d\ude03", "author": "NealSun96", "createdAt": "2020-10-09T01:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2OTIzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjU5NDU5OQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r502594599", "bodyText": "A meaningful method name is always better than comments.\nThe best code does not need comments. Although it is almost impossible to achieve.", "author": "jiajunwang", "createdAt": "2020-10-09T18:08:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2OTIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1MjAzNQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500752035", "bodyText": "Any specific reason we do not put this into refreshLiveInstances()?", "author": "lei-xia", "createdAt": "2020-10-07T05:50:03Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -333,6 +370,7 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     _stateModelDefinitionCache.refresh(accessor);\n     _clusterConstraintsCache.refresh(accessor);\n     updateMaintenanceInfo(accessor);\n+    timeoutNodesDuringMaintenance(accessor, _clusterConfig, _isMaintenanceModeEnabled);", "originalCommit": "acf4d8ce322c9cb1861539692a046d74464fea49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2NTA1OA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r501165058", "bodyText": "Yes, because we want this step to be after updateMaintenanceInfo(), which makes the most logical sense.", "author": "NealSun96", "createdAt": "2020-10-07T16:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1MjAzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1Mzc3MQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500753771", "bodyText": "These two methods (getLiveInstances() and getAllLiveInstances() are very confusing to each other.  We would need a better naming here.  We have four type of instances:  All Instances, Live Instances, enabled/disabled Instances, timeout-ed instances.  We have a method called getEnabledLiveInstances(), maybe we can name this new method getNonTimeoutLiveInstances()?", "author": "lei-xia", "createdAt": "2020-10-07T05:54:57Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -428,13 +466,37 @@ public synchronized void setIdealStates(List<IdealState> idealStates) {\n   }\n \n   /**\n-   * Returns the LiveInstances for each of the instances that are curretnly up and running\n-   * @return\n+   * Returns the LiveInstances for each of the instances that are currently up and running,\n+   * excluding the instances that are considered offline during maintenance mode. Instances\n+   * are timed-out if they have been offline for a while before going live during maintenance mode.\n    */\n   public Map<String, LiveInstance> getLiveInstances() {\n+    return getLiveInstances(true);\n+  }\n+\n+  /**\n+   * Returns the LiveInstances for each of the instances that are currently up and running\n+   */\n+  public Map<String, LiveInstance> getAllLiveInstances() {", "originalCommit": "acf4d8ce322c9cb1861539692a046d74464fea49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2NjAyMA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r501166020", "bodyText": "I'm just going to remove this function and the boolean flag, since during maintenance mode, we always want to return the non-timed-out instances.", "author": "NealSun96", "createdAt": "2020-10-07T16:54:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1Mzc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NDE2MQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500754161", "bodyText": "minor:  isInstanceTimeout... -> shouldInstanceTimeout...", "author": "lei-xia", "createdAt": "2020-10-07T05:56:01Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -728,6 +790,58 @@ private void updateDisabledInstances() {\n     }\n   }\n \n+  /*\n+   * Check if the instance is timed-out during maintenance mode. An instance is timed-out if it has\n+   * been offline for longer than the user defined timeout window.\n+   * @param timeOutWindow - the timeout window; guaranteed to be non-negative\n+   */\n+  private boolean isInstanceTimedOutDuringMaintenance(HelixDataAccessor accessor, String instance,", "originalCommit": "acf4d8ce322c9cb1861539692a046d74464fea49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2NjQzMw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r501166433", "bodyText": "It's isInstanceTimedOut, which is grammatically correct. I'd prefer is over should.", "author": "NealSun96", "createdAt": "2020-10-07T16:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NDE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NDY0Mg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500754642", "bodyText": "Let us follow the name convention of another method, such as sessionHistoryStringToMap()?", "author": "lei-xia", "createdAt": "2020-10-07T05:57:26Z", "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +185,101 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /*\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  private static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /*\n+   * Parses a history date in millisecond to string.\n+   */\n+  private static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }\n+\n+  /**\n+   * Parses the session entry map that has been converted to string back to a map.\n+   * NOTE TO CALLER: This assumes the divider between entries is \", \" and the divider between\n+   * key/value is \"=\"; if the string is malformed, parsing correctness is not guaranteed. Always\n+   * check if a key is contained before using the key.\n+   */\n+  public static Map<String, String> parseSessionHistoryStringToMap(String sessionHistoryString) {", "originalCommit": "acf4d8ce322c9cb1861539692a046d74464fea49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2NjUwNA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r501166504", "bodyText": "Ok.", "author": "NealSun96", "createdAt": "2020-10-07T16:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NDY0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NDc4Mg==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500754782", "bodyText": "getTimeFromSessionHistory", "author": "lei-xia", "createdAt": "2020-10-07T05:57:53Z", "path": "helix-core/src/main/java/org/apache/helix/model/ParticipantHistory.java", "diffHunk": "@@ -153,16 +185,101 @@ private void updateOfflineHistory(long time) {\n     if (list.size() == HISTORY_SIZE) {\n       list.remove(0);\n     }\n-\n-    DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss:SSS\");\n-    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n-    String dateTime = df.format(new Date(time));\n-\n-    list.add(dateTime);\n+    list.add(historyDateLongToString(time));\n   }\n \n   @Override\n   public boolean isValid() {\n     return true;\n   }\n+\n+  /*\n+   * Parses a history date in string format to its millisecond representation.\n+   * Returns -1 if parsing fails.\n+   */\n+  private static long historyDateStringToLong(String dateString) {\n+    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    simpleDateFormat.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    try {\n+      Date date = simpleDateFormat.parse(dateString);\n+      return date.getTime();\n+    } catch (ParseException e) {\n+      LOG.warn(\"Failed to parse participant history date string: \" + dateString);\n+      return -1;\n+    }\n+  }\n+\n+  /*\n+   * Parses a history date in millisecond to string.\n+   */\n+  private static String historyDateLongToString(long dateLong) {\n+    DateFormat df = new SimpleDateFormat(HISTORY_DATE_FORMAT);\n+    df.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n+    return df.format(new Date(dateLong));\n+  }\n+\n+  /**\n+   * Parses the session entry map that has been converted to string back to a map.\n+   * NOTE TO CALLER: This assumes the divider between entries is \", \" and the divider between\n+   * key/value is \"=\"; if the string is malformed, parsing correctness is not guaranteed. Always\n+   * check if a key is contained before using the key.\n+   */\n+  public static Map<String, String> parseSessionHistoryStringToMap(String sessionHistoryString) {\n+    sessionHistoryString = sessionHistoryString.substring(1, sessionHistoryString.length() - 1);\n+    Map<String, String> sessionHistoryMap = new HashMap<>();\n+\n+    for (String sessionHistoryKeyValuePair : sessionHistoryString.split(\", \")) {\n+      String[] keyValuePair = sessionHistoryKeyValuePair.split(\"=\");\n+      if (keyValuePair.length < 2) {\n+        LOG.warn(\"Ignore key value pair while parsing session history due to missing '=': \" +\n+            sessionHistoryKeyValuePair);\n+        continue;\n+      }\n+      sessionHistoryMap.put(keyValuePair[0], keyValuePair[1]);\n+    }\n+\n+    return sessionHistoryMap;\n+  }\n+\n+  /*\n+   * Take a string session history entry and extract the TIME field out of it. Return -1 if the TIME\n+   * field doesn't exist or if the TIME field cannot be parsed to a long.\n+   */\n+  private static long extractTimeFromSessionHistoryString(String sessionHistoryString) {", "originalCommit": "acf4d8ce322c9cb1861539692a046d74464fea49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2Nzk0Ng==", "url": "https://github.com/apache/helix/pull/1413#discussion_r501167946", "bodyText": "Ok.", "author": "NealSun96", "createdAt": "2020-10-07T16:57:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NDc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NTQ2OA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r500755468", "bodyText": "Do we have an end-to-end integration test here, such as verify that a timeout-ed instance during maintenance mode will not get assigned any partitions (received any state transition messages)?", "author": "lei-xia", "createdAt": "2020-10-07T05:59:59Z", "path": "helix-core/src/test/java/org/apache/helix/integration/controller/TestOfflineNodeTimeoutDuringMaintenanceMode.java", "diffHunk": "@@ -0,0 +1,242 @@\n+package org.apache.helix.integration.controller;", "originalCommit": "acf4d8ce322c9cb1861539692a046d74464fea49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2ODMzOA==", "url": "https://github.com/apache/helix/pull/1413#discussion_r501168338", "bodyText": "I will cover that in a CHO test.", "author": "NealSun96", "createdAt": "2020-10-07T16:58:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NTQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3ODUwNw==", "url": "https://github.com/apache/helix/pull/1413#discussion_r501378507", "bodyText": "It's better to include an integration test to cover the real case in mvn test. CHO is not available to everyone.", "author": "jiajunwang", "createdAt": "2020-10-08T00:09:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NTQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY5NDA2NQ==", "url": "https://github.com/apache/helix/pull/1413#discussion_r502694065", "bodyText": "Updated.", "author": "NealSun96", "createdAt": "2020-10-09T22:29:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NTQ2OA=="}], "type": "inlineReview"}, {"oid": "8ea7fc885a672f6db965bb33e0472c20821f2aa7", "url": "https://github.com/apache/helix/commit/8ea7fc885a672f6db965bb33e0472c20821f2aa7", "message": "Feature: Offline Node Timeout During Maintenance Mode", "committedDate": "2020-10-07T18:02:08Z", "type": "commit"}, {"oid": "0ecc7eb5a8d0d9758cc804f5df3b9e8d1a4e678b", "url": "https://github.com/apache/helix/commit/0ecc7eb5a8d0d9758cc804f5df3b9e8d1a4e678b", "message": "Format", "committedDate": "2020-10-07T18:02:08Z", "type": "commit"}, {"oid": "a4fc5897a25783bf6f4a85f90064be76828e1484", "url": "https://github.com/apache/helix/commit/a4fc5897a25783bf6f4a85f90064be76828e1484", "message": "Address comments", "committedDate": "2020-10-07T18:02:08Z", "type": "commit"}, {"oid": "79064498a04261c2ad50dd81e3a2edfd4e826216", "url": "https://github.com/apache/helix/commit/79064498a04261c2ad50dd81e3a2edfd4e826216", "message": "Attempt to stabilize tests", "committedDate": "2020-10-07T18:02:08Z", "type": "commit"}, {"oid": "fc7c3e8d93def39e9b250d52c97747c824e4efcc", "url": "https://github.com/apache/helix/commit/fc7c3e8d93def39e9b250d52c97747c824e4efcc", "message": "Fix broken mock", "committedDate": "2020-10-07T18:02:08Z", "type": "commit"}, {"oid": "9d6889881589c3d71fe355aa4c90a8204b376a32", "url": "https://github.com/apache/helix/commit/9d6889881589c3d71fe355aa4c90a8204b376a32", "message": "New algorithm", "committedDate": "2020-10-07T18:02:08Z", "type": "commit"}, {"oid": "e73f8c4533006b3435e3ae6c981c25172edf896f", "url": "https://github.com/apache/helix/commit/e73f8c4533006b3435e3ae6c981c25172edf896f", "message": "Added additional subtest", "committedDate": "2020-10-07T18:02:08Z", "type": "commit"}, {"oid": "3282b63fbedc0a36b7bdd3e5d2b9fd144f3ae634", "url": "https://github.com/apache/helix/commit/3282b63fbedc0a36b7bdd3e5d2b9fd144f3ae634", "message": "Add new instance subtest case", "committedDate": "2020-10-07T18:02:09Z", "type": "commit"}, {"oid": "ecea2bdbc2d530ef1e4ad4a6314c315f5cdb2ebe", "url": "https://github.com/apache/helix/commit/ecea2bdbc2d530ef1e4ad4a6314c315f5cdb2ebe", "message": "Renaming changes", "committedDate": "2020-10-07T18:02:09Z", "type": "commit"}, {"oid": "bdcf0a5309410bbe7ffdc8da9460d9b4e3bd6fb1", "url": "https://github.com/apache/helix/commit/bdcf0a5309410bbe7ffdc8da9460d9b4e3bd6fb1", "message": "Change default behavior", "committedDate": "2020-10-07T18:02:09Z", "type": "commit"}, {"oid": "0b7b2cef4aef1dcc0a913f9bfbd5f8a1b18b8fe6", "url": "https://github.com/apache/helix/commit/0b7b2cef4aef1dcc0a913f9bfbd5f8a1b18b8fe6", "message": "Clear liveinstance snapshot", "committedDate": "2020-10-07T18:02:09Z", "type": "commit"}, {"oid": "1342619f0cb603fcb3029b250f12b235d9d3ecc1", "url": "https://github.com/apache/helix/commit/1342619f0cb603fcb3029b250f12b235d9d3ecc1", "message": "Remove unnecessary snapshot, simplify algo", "committedDate": "2020-10-07T18:02:09Z", "type": "commit"}, {"oid": "c1448e99dd2dab0495fb70f803b431b0d3d4baf4", "url": "https://github.com/apache/helix/commit/c1448e99dd2dab0495fb70f803b431b0d3d4baf4", "message": "Add 1 line to javadoc", "committedDate": "2020-10-07T18:02:09Z", "type": "commit"}, {"oid": "d649a17a056f73049db89352e5ef0c4c7cc331d2", "url": "https://github.com/apache/helix/commit/d649a17a056f73049db89352e5ef0c4c7cc331d2", "message": "reduce diff", "committedDate": "2020-10-07T18:02:09Z", "type": "commit"}, {"oid": "0d5e77a8270be4bf79c837dd732a25b10eed8796", "url": "https://github.com/apache/helix/commit/0d5e77a8270be4bf79c837dd732a25b10eed8796", "message": "Add log line", "committedDate": "2020-10-07T18:02:09Z", "type": "commit"}, {"oid": "5775343d450cc39eb3aeba05b1d2e43e85039df7", "url": "https://github.com/apache/helix/commit/5775343d450cc39eb3aeba05b1d2e43e85039df7", "message": "Renames", "committedDate": "2020-10-07T18:02:09Z", "type": "commit"}, {"oid": "5775343d450cc39eb3aeba05b1d2e43e85039df7", "url": "https://github.com/apache/helix/commit/5775343d450cc39eb3aeba05b1d2e43e85039df7", "message": "Renames", "committedDate": "2020-10-07T18:02:09Z", "type": "forcePushed"}, {"oid": "f7f8ee55777fcfbffb8be7e090cac3f867e03e8f", "url": "https://github.com/apache/helix/commit/f7f8ee55777fcfbffb8be7e090cac3f867e03e8f", "message": "Function rename", "committedDate": "2020-10-09T01:51:37Z", "type": "commit"}, {"oid": "58888ca142c3233615b207fc70d6d793cc40cb6a", "url": "https://github.com/apache/helix/commit/58888ca142c3233615b207fc70d6d793cc40cb6a", "message": "Changed integration test", "committedDate": "2020-10-09T22:28:35Z", "type": "commit"}]}