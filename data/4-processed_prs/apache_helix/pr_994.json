{"pr_number": 994, "pr_title": "Remove the scheduling decision based on PreviousAssignment", "pr_createdAt": "2020-05-04T16:34:25Z", "pr_url": "https://github.com/apache/helix/pull/994", "timeline": [{"oid": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "url": "https://github.com/apache/helix/commit/4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "message": "Remove the scheduling decsion based on PreviousAssignment\n\nIn this commit, the our previous logic which was based on PreviousAssignment,\nhas been changed. Instread, the scheduling is mostly based on CurrentState.", "committedDate": "2020-05-01T18:01:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MDcxNA==", "url": "https://github.com/apache/helix/pull/994#discussion_r423440714", "bodyText": "Did you mean \"that are in either INIT or DROPPED states\"?", "author": "narendly", "createdAt": "2020-05-12T03:29:56Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -99,16 +99,15 @@ public void updatePreviousAssignedTasksStatus(\n       }\n \n       // If not an excluded instance, we must instantiate its entry in assignedPartitions\n-      Set<Integer> pSet = prevInstanceToTaskAssignments.get(instance);\n+      Set<Integer> pSet = currentInstanceToTaskAssignments.get(instance);\n \n       // We need to remove all task pId's to be dropped because we already made an assignment in\n       // paMap above for them to be dropped. The following does this.\n       if (tasksToDrop.containsKey(instance)) {\n         pSet.removeAll(tasksToDrop.get(instance));\n       }\n \n-      // Used to keep track of partitions that are in one of the final states: COMPLETED, TIMED_OUT,\n-      // TASK_ERROR, ERROR.\n+      // Used to keep track of partitions that are in one the INIT or DROPPED states.", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzM1MA==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807350", "bodyText": "Yes. Done.", "author": "alirezazamani", "createdAt": "2020-05-18T18:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MDcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MTM4MA==", "url": "https://github.com/apache/helix/pull/994#discussion_r423441380", "bodyText": "I don't know if this would be the correct thing to do.\nSure, once a task is complete, it could be dropped from the node, but you also want to keep the state of the task in COMPLETED in JobContext.\nI'm afraid doing this might cause the otherwise-completed task's state to change to DROPPED. Then we would have no way of knowing if this task just got dropped or completed and dropped.", "author": "narendly", "createdAt": "2020-05-12T03:32:37Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -242,16 +230,16 @@ public void updatePreviousAssignedTasksStatus(\n         }\n           break;\n         case COMPLETED: {\n-          // The task has completed on this partition. Mark as such in the context object.\n-          donePartitions.add(pId);\n+          // The task has completed on this partition. Drop it from the instance and add it to assignedPartitions in\n+          // order to avoid scheduling it again in this pipeline.\n+          assignedPartitions.get(instance).add(pId);\n+          paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.DROPPED.name()));", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzQyMw==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807423", "bodyText": "You are right. I also had this concern. But note that we do not change the JobContext to DROPPED. Let\u2019s say controller sends COMPLETED to DROPPED message to the participant. Now, the current state will be COMPLETED until participant processes the message. Once it is processed, the current state will be null, and that task will not be considered again. So, to answer your question, it is totally depending on the behavior of the participant. If participant set the current state  to DROPPED, which is not the case here, your concern was correct. Since participant removes the current state of the task, we do not need to be worry about that case.", "author": "alirezazamani", "createdAt": "2020-05-18T18:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MTM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MTYzMA==", "url": "https://github.com/apache/helix/pull/994#discussion_r423441630", "bodyText": "Again, I am not sure if this would cause the JobContext to have the wrong state for the task partitions. Did you check? What state does the task go into between being dropped and getting rescheduled? (It should be ERROR or TASK_ABORTED, or whatever it was before being dropped)", "author": "narendly", "createdAt": "2020-05-12T03:33:36Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -263,7 +251,11 @@ public void updatePreviousAssignedTasksStatus(\n         case TASK_ABORTED:\n \n         case ERROR: {\n-          donePartitions.add(pId); // The task may be rescheduled on a different instance.\n+          // First make this task which is in terminal state to be dropped.\n+          // Later on, in next pipeline in handleAdditionalAssignments, the task will be retried if possible.\n+          // (meaning it is not ABORTED and max number of attempts has not been reached yet)\n+          assignedPartitions.get(instance).add(pId);\n+          paMap.put(pId, new PartitionAssignment(instance, TaskPartitionState.DROPPED.name()));", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzQ3Mg==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807472", "bodyText": "The answer to this question is also similar to COMPLETED case :). Please see it above.", "author": "alirezazamani", "createdAt": "2020-05-18T18:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MTYzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MjE0NQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r423442145", "bodyText": "the assignedParticipant \"field\" in JobContext needs to be updated...", "author": "narendly", "createdAt": "2020-05-12T03:35:53Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,57 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assigned participant needs to be updated regardless of the current state and context", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzQ5OQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807499", "bodyText": "Fixed. Thanks.", "author": "alirezazamani", "createdAt": "2020-05-18T18:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MjE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MjQyMA==", "url": "https://github.com/apache/helix/pull/994#discussion_r423442420", "bodyText": "... because this will prevent the controller from being stuck in a race condition when there are two current states found for a single task.\n-> Okay, but what kind of race condition are we talking about?", "author": "narendly", "createdAt": "2020-05-12T03:37:08Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,57 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assigned participant needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to stuck in race condition while there is two", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzUyOQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807529", "bodyText": "The race condition that here is scenario that I am talking about is the scenario where we have two current states of a task in different participants. Since we have only one slot for each task in paMap, we want to make sure that the task is DROPPED from the wrong one and is assigned to the correct instance. I am basically talking about this #922 and #461. Let me rephrase this comment to make it clear.", "author": "alirezazamani", "createdAt": "2020-05-18T18:10:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MjQyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MzE5Nw==", "url": "https://github.com/apache/helix/pull/994#discussion_r423443197", "bodyText": "Does this help us avoid the race condition?", "author": "narendly", "createdAt": "2020-05-12T03:39:45Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,57 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assigned participant needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to stuck in race condition while there is two\n+    // current states. In the updatePreviousAssignedTasksStatus, we check\n+    // instance.equals(jobCtx.getAssignedParticipant(pId)) and bypass the assignment if instance is\n+    // not equal to job context's AssignedParticipant for this pId.", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzU3Mw==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807573", "bodyText": "Exactly. We add this check in PR #923 to help resolve this scenario. Maybe using race condition is not the good word here. I rephrased the comments.", "author": "alirezazamani", "createdAt": "2020-05-18T18:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MzE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MzU3OQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r423443579", "bodyText": "-> update context while its current state exists...\nBut why do we not want to update the context when there's a current state for it? Shouldn't we update the context based on the latest current state?", "author": "narendly", "createdAt": "2020-05-12T03:41:21Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,57 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assigned participant needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to stuck in race condition while there is two\n+    // current states. In the updatePreviousAssignedTasksStatus, we check\n+    // instance.equals(jobCtx.getAssignedParticipant(pId)) and bypass the assignment if instance is\n+    // not equal to job context's AssignedParticipant for this pId.\n     jobCtx.setAssignedParticipant(pId, instance);\n-    jobCtx.setPartitionState(pId, currentState);\n-    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(pName), instance);\n-    if (taskMsg != null) {\n-      jobCtx.setPartitionInfo(pId, taskMsg);\n+    // If job context needs to be updated with new state, update it accordingly\n+    // This check is necessary because we are relying on current state and we do not want to update\n+    // context as long as current state existed. We just want to update context information", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzg5Mg==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807892", "bodyText": "Here we check the if current state has been changed and it is not equal to context information. This check is necessary because we do not need to update the context in every pipeline. Also, the more important part of this check is for the fields such as finish time. Let\u2019s say we have a delay retry time for the task. This functionality depends on the finish time in the context. If we update finish time as long as we have current state (note that we set it to current time), we will never schedule the task with delay retry time. Because finish time in the context and delay retry time will be messed up. That is why we only update the context at the first time that the current state has been changed.", "author": "alirezazamani", "createdAt": "2020-05-18T18:11:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MzU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA0OTIxOA==", "url": "https://github.com/apache/helix/pull/994#discussion_r430049218", "bodyText": "@alirezazamani -\nOkay, I think your point about not updating when there's no delta is valid, but I'm not sure if what you said about delayed scheduling is entirely true. Delayed scheduling of tasks is a feature that was previously working, right? If what you said about it was the case, then how come our delayed scheduling feature was working all this time?", "author": "narendly", "createdAt": "2020-05-25T19:02:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MzU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDcxMw==", "url": "https://github.com/apache/helix/pull/994#discussion_r430580713", "bodyText": "@narendly\nThe reason that delayed scheduling was working is because we were relying on previousAssignment. Let's say we are relying on previousAssignment and we decided to send the task to TASK_ERROR. This task will be recorded in previousAssignment and next pipeline we iterate through the task existed in previous assignment and record finish time and context information. Then this task will not be existed in future pipelines previousAssignment and we do not update finish time in the future pipelines. (Actually some of the tests have guided me toward this change).\nHowever, if we want to be independent of previousAssignment and rely on currentState (which also means we are relying on participant's reactions), we need to consider that currentState might not change for several pipelines. In this case, it is necessary to monitor these deltas and not update the context information (specially time sensitive information) multiple times.", "author": "alirezazamani", "createdAt": "2020-05-26T17:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MzU3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY2ODYzMw==", "url": "https://github.com/apache/helix/pull/994#discussion_r430668633", "bodyText": "Thanks for the explanation. The reason we need to know if CurrentState changed is because we no longer have prevAssignment.", "author": "narendly", "createdAt": "2020-05-26T19:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0MzU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0Mzg0Mw==", "url": "https://github.com/apache/helix/pull/994#discussion_r423443843", "bodyText": "This condition checks whether jobContext's state is out of date or not, right?", "author": "narendly", "createdAt": "2020-05-12T03:42:28Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,57 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assigned participant needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to stuck in race condition while there is two\n+    // current states. In the updatePreviousAssignedTasksStatus, we check\n+    // instance.equals(jobCtx.getAssignedParticipant(pId)) and bypass the assignment if instance is\n+    // not equal to job context's AssignedParticipant for this pId.\n     jobCtx.setAssignedParticipant(pId, instance);\n-    jobCtx.setPartitionState(pId, currentState);\n-    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(pName), instance);\n-    if (taskMsg != null) {\n-      jobCtx.setPartitionInfo(pId, taskMsg);\n+    // If job context needs to be updated with new state, update it accordingly\n+    // This check is necessary because we are relying on current state and we do not want to update\n+    // context as long as current state existed. We just want to update context information\n+    // (specially finish time) once.\n+    if (!currentState.equals(jobCtx.getPartitionState(pId))) {", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzYyNg==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807626", "bodyText": "Exactly. I added a comment about it.", "author": "alirezazamani", "createdAt": "2020-05-18T18:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0Mzg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTE1OQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r423445159", "bodyText": "\"add these pIds to result\" and update their states in JobContext in updatePreviousAssignedTasksStatus method...", "author": "narendly", "createdAt": "2020-05-12T03:48:04Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -380,72 +379,38 @@ private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions,\n \n   /**\n    * @param liveInstances\n-   * @param prevAssignment task partition -> (instance -> state)\n-   * @param allTaskPartitions all task partitionIds\n    * @param currStateOutput currentStates to make sure currentStates copied over expired sessions\n    *          are accounted for\n    * @param jobName job name\n    * @param tasksToDrop instance -> pId's, to gather all pIds that need to be dropped\n    * @return instance -> partitionIds from previous assignment, if the instance is still live\n    */\n-  protected static Map<String, SortedSet<Integer>> getPrevInstanceToTaskAssignments(\n-      Iterable<String> liveInstances, ResourceAssignment prevAssignment,\n-      Set<Integer> allTaskPartitions, CurrentStateOutput currStateOutput, String jobName,\n+  protected static Map<String, SortedSet<Integer>> getCurrentInstanceToTaskAssignments(\n+      Iterable<String> liveInstances, CurrentStateOutput currStateOutput, String jobName,\n       Map<String, Set<Integer>> tasksToDrop) {\n     Map<String, SortedSet<Integer>> result = new HashMap<>();\n     for (String instance : liveInstances) {\n       result.put(instance, new TreeSet<>());\n     }\n \n-    // First, add all task partitions from prevAssignment\n-    // TODO: Remove this portion to get rid of prevAssignment from Task Framework\n-    for (Partition partition : prevAssignment.getMappedPartitions()) {\n-      int pId = TaskUtil.getPartitionId(partition.getPartitionName());\n-      if (allTaskPartitions.contains(pId)) {\n-        Map<String, String> replicaMap = prevAssignment.getReplicaMap(partition);\n-        for (String instance : replicaMap.keySet()) {\n-          SortedSet<Integer> pIdSet = result.get(instance);\n-          if (pIdSet != null) {\n-            pIdSet.add(pId);\n-          }\n-        }\n-      }\n-    }\n-\n-    // Generate prevInstanceToTaskAssignment with CurrentStateOutput as source of truth\n-\n-    // Add all pIds existing in CurrentStateOutput as well because task currentStates copied over\n-    // from previous sessions won't show up in prevInstanceToTaskAssignments\n-    // We need to add these back here in order for these task partitions to be dropped (after a\n-    // copy-over, the Controller will send a message to drop the state currentState)\n-    // partitions: (partition -> instance -> currentState)\n+    // Generate currentInstanceToTaskAssignment with CurrentStateOutput as source of truth\n+    // Add all pIds existing in CurrentStateOutput\n+    // We need to add these pIds here and make decision about the existing tasks with current state\n+    // in updatePreviousAssignedTasksStatus method", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzY3Nw==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807677", "bodyText": "Fixed. Thanks.", "author": "alirezazamani", "createdAt": "2020-05-18T18:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTMxNg==", "url": "https://github.com/apache/helix/pull/994#discussion_r423445316", "bodyText": "This comment isn't giving any information. Why must we?", "author": "narendly", "createdAt": "2020-05-12T03:48:42Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -380,72 +379,38 @@ private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions,\n \n   /**\n    * @param liveInstances\n-   * @param prevAssignment task partition -> (instance -> state)\n-   * @param allTaskPartitions all task partitionIds\n    * @param currStateOutput currentStates to make sure currentStates copied over expired sessions\n    *          are accounted for\n    * @param jobName job name\n    * @param tasksToDrop instance -> pId's, to gather all pIds that need to be dropped\n    * @return instance -> partitionIds from previous assignment, if the instance is still live\n    */\n-  protected static Map<String, SortedSet<Integer>> getPrevInstanceToTaskAssignments(\n-      Iterable<String> liveInstances, ResourceAssignment prevAssignment,\n-      Set<Integer> allTaskPartitions, CurrentStateOutput currStateOutput, String jobName,\n+  protected static Map<String, SortedSet<Integer>> getCurrentInstanceToTaskAssignments(\n+      Iterable<String> liveInstances, CurrentStateOutput currStateOutput, String jobName,\n       Map<String, Set<Integer>> tasksToDrop) {\n     Map<String, SortedSet<Integer>> result = new HashMap<>();\n     for (String instance : liveInstances) {\n       result.put(instance, new TreeSet<>());\n     }\n \n-    // First, add all task partitions from prevAssignment\n-    // TODO: Remove this portion to get rid of prevAssignment from Task Framework\n-    for (Partition partition : prevAssignment.getMappedPartitions()) {\n-      int pId = TaskUtil.getPartitionId(partition.getPartitionName());\n-      if (allTaskPartitions.contains(pId)) {\n-        Map<String, String> replicaMap = prevAssignment.getReplicaMap(partition);\n-        for (String instance : replicaMap.keySet()) {\n-          SortedSet<Integer> pIdSet = result.get(instance);\n-          if (pIdSet != null) {\n-            pIdSet.add(pId);\n-          }\n-        }\n-      }\n-    }\n-\n-    // Generate prevInstanceToTaskAssignment with CurrentStateOutput as source of truth\n-\n-    // Add all pIds existing in CurrentStateOutput as well because task currentStates copied over\n-    // from previous sessions won't show up in prevInstanceToTaskAssignments\n-    // We need to add these back here in order for these task partitions to be dropped (after a\n-    // copy-over, the Controller will send a message to drop the state currentState)\n-    // partitions: (partition -> instance -> currentState)\n+    // Generate currentInstanceToTaskAssignment with CurrentStateOutput as source of truth\n+    // Add all pIds existing in CurrentStateOutput\n+    // We need to add these pIds here and make decision about the existing tasks with current state\n+    // in updatePreviousAssignedTasksStatus method\n     Map<Partition, Map<String, String>> partitions = currStateOutput.getCurrentStateMap(jobName);\n     for (Map.Entry<Partition, Map<String, String>> entry : partitions.entrySet()) {\n       // Get all (instance -> currentState) mappings\n       for (Map.Entry<String, String> instanceToCurrState : entry.getValue().entrySet()) {\n         String instance = instanceToCurrState.getKey();\n         String requestedState =\n             currStateOutput.getRequestedState(jobName, entry.getKey(), instance);\n-        TaskPartitionState currState = TaskPartitionState.valueOf(instanceToCurrState.getValue());\n         int pId = TaskUtil.getPartitionId(entry.getKey().getPartitionName());\n \n         if (result.containsKey(instance)) {\n-          // We must add all active task pIds back here because dropping transition could overwrite\n-          // an active transition in paMap\n-          // Add all task partitions in the following states:\n-          // currState = INIT, requestedState = RUNNING (bootstrap)\n-          // currState = RUNNING, requestedState = ANY (active)\n-          // ** for tasks that are just in INIT state, we do not add them here because old\n-          // Participants, upon connection reset, set tasks' currentStates to INIT. We cannot\n-          // consider those tasks active **\n-          if (currState == TaskPartitionState.INIT && requestedState != null\n-              && requestedState.equals(TaskPartitionState.RUNNING.name())\n-              || currState == TaskPartitionState.RUNNING) {\n-            result.get(instance).add(pId);\n-          }\n-\n+          // We must add all pIds back here", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzY5Nw==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807697", "bodyText": "I agree. Removed the comment. Basically, we have explained everything in the comments already.", "author": "alirezazamani", "createdAt": "2020-05-18T18:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTQzNQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r423445435", "bodyText": "Nit: This dot isn't necessary...\nIf anything, repeat again what \"a task needs to be dropped\" means. This is trying to drop tasks on a reconnected instance with a new sessionId that have all of their requestedState == DROPPED.", "author": "narendly", "createdAt": "2020-05-12T03:49:16Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -380,72 +379,38 @@ private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions,\n \n   /**\n    * @param liveInstances\n-   * @param prevAssignment task partition -> (instance -> state)\n-   * @param allTaskPartitions all task partitionIds\n    * @param currStateOutput currentStates to make sure currentStates copied over expired sessions\n    *          are accounted for\n    * @param jobName job name\n    * @param tasksToDrop instance -> pId's, to gather all pIds that need to be dropped\n    * @return instance -> partitionIds from previous assignment, if the instance is still live\n    */\n-  protected static Map<String, SortedSet<Integer>> getPrevInstanceToTaskAssignments(\n-      Iterable<String> liveInstances, ResourceAssignment prevAssignment,\n-      Set<Integer> allTaskPartitions, CurrentStateOutput currStateOutput, String jobName,\n+  protected static Map<String, SortedSet<Integer>> getCurrentInstanceToTaskAssignments(\n+      Iterable<String> liveInstances, CurrentStateOutput currStateOutput, String jobName,\n       Map<String, Set<Integer>> tasksToDrop) {\n     Map<String, SortedSet<Integer>> result = new HashMap<>();\n     for (String instance : liveInstances) {\n       result.put(instance, new TreeSet<>());\n     }\n \n-    // First, add all task partitions from prevAssignment\n-    // TODO: Remove this portion to get rid of prevAssignment from Task Framework\n-    for (Partition partition : prevAssignment.getMappedPartitions()) {\n-      int pId = TaskUtil.getPartitionId(partition.getPartitionName());\n-      if (allTaskPartitions.contains(pId)) {\n-        Map<String, String> replicaMap = prevAssignment.getReplicaMap(partition);\n-        for (String instance : replicaMap.keySet()) {\n-          SortedSet<Integer> pIdSet = result.get(instance);\n-          if (pIdSet != null) {\n-            pIdSet.add(pId);\n-          }\n-        }\n-      }\n-    }\n-\n-    // Generate prevInstanceToTaskAssignment with CurrentStateOutput as source of truth\n-\n-    // Add all pIds existing in CurrentStateOutput as well because task currentStates copied over\n-    // from previous sessions won't show up in prevInstanceToTaskAssignments\n-    // We need to add these back here in order for these task partitions to be dropped (after a\n-    // copy-over, the Controller will send a message to drop the state currentState)\n-    // partitions: (partition -> instance -> currentState)\n+    // Generate currentInstanceToTaskAssignment with CurrentStateOutput as source of truth\n+    // Add all pIds existing in CurrentStateOutput\n+    // We need to add these pIds here and make decision about the existing tasks with current state\n+    // in updatePreviousAssignedTasksStatus method\n     Map<Partition, Map<String, String>> partitions = currStateOutput.getCurrentStateMap(jobName);\n     for (Map.Entry<Partition, Map<String, String>> entry : partitions.entrySet()) {\n       // Get all (instance -> currentState) mappings\n       for (Map.Entry<String, String> instanceToCurrState : entry.getValue().entrySet()) {\n         String instance = instanceToCurrState.getKey();\n         String requestedState =\n             currStateOutput.getRequestedState(jobName, entry.getKey(), instance);\n-        TaskPartitionState currState = TaskPartitionState.valueOf(instanceToCurrState.getValue());\n         int pId = TaskUtil.getPartitionId(entry.getKey().getPartitionName());\n \n         if (result.containsKey(instance)) {\n-          // We must add all active task pIds back here because dropping transition could overwrite\n-          // an active transition in paMap\n-          // Add all task partitions in the following states:\n-          // currState = INIT, requestedState = RUNNING (bootstrap)\n-          // currState = RUNNING, requestedState = ANY (active)\n-          // ** for tasks that are just in INIT state, we do not add them here because old\n-          // Participants, upon connection reset, set tasks' currentStates to INIT. We cannot\n-          // consider those tasks active **\n-          if (currState == TaskPartitionState.INIT && requestedState != null\n-              && requestedState.equals(TaskPartitionState.RUNNING.name())\n-              || currState == TaskPartitionState.RUNNING) {\n-            result.get(instance).add(pId);\n-          }\n-\n+          // We must add all pIds back here\n+          result.get(instance).add(pId);\n           // Check if this task needs to be dropped. If so, we need to add to tasksToDrop no matter\n-          // what its current state is so that it will be dropped\n+          // what its current state is so that it will be dropped.", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzcyMg==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807722", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-05-18T18:11:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTc1OA==", "url": "https://github.com/apache/helix/pull/994#discussion_r423445758", "bodyText": "\"from CurrentStateOutput\"", "author": "narendly", "createdAt": "2020-05-12T03:50:32Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -462,10 +427,10 @@ private static boolean isJobComplete(JobContext ctx, Set<Integer> allPartitions,\n    * If partition is missing from prevInstanceToTaskAssignments (e.g. previous assignment is\n    * deleted) it is added from context. Otherwise, the context won't be updated.\n    * @param jobCtx Job Context\n-   * @param prevInstanceToTaskAssignments instance -> partitionIds from previous assignment\n+   * @param currentInstanceToTaskAssignments instance -> partitionIds from current assignment", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzc4MA==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807780", "bodyText": "Done.", "author": "alirezazamani", "createdAt": "2020-05-18T18:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQ0NTc1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NTE3MA==", "url": "https://github.com/apache/helix/pull/994#discussion_r424655170", "bodyText": "Why you remove the done partition from COMPLETED state? Then this partition will not be removed from pSet, right?", "author": "junkaixue", "createdAt": "2020-05-13T18:44:49Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -242,16 +230,16 @@ public void updatePreviousAssignedTasksStatus(\n         }\n           break;\n         case COMPLETED: {\n-          // The task has completed on this partition. Mark as such in the context object.\n-          donePartitions.add(pId);\n+          // The task has completed on this partition. Drop it from the instance and add it to assignedPartitions in\n+          // order to avoid scheduling it again in this pipeline.", "originalCommit": "4ffac81f7ca80dd02d2ab7b63e83361c9b0fdb70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjgwNzM4OA==", "url": "https://github.com/apache/helix/pull/994#discussion_r426807388", "bodyText": "The reason is the behavior has been changed in this PR. We have an assignment for it and the assignment is dropped. So, it goes to assigned partitions. Once it is dropped from participant, then we do not even consider it for the new assignment.", "author": "alirezazamani", "createdAt": "2020-05-18T18:10:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NTE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMjYyOA==", "url": "https://github.com/apache/helix/pull/994#discussion_r428322628", "bodyText": "The concern for doing this is that will this reflect the change to JobContext? So if final state will all be DROPPED. It is hard for us to determine whether the tasks is completed or it requires another retry? Because if task has problem in the middle of running, it will be DROPPED as well.", "author": "junkaixue", "createdAt": "2020-05-20T21:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NTE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyMzg4NQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r428323885", "bodyText": "Also, I dont think you will get DROPPED state as current state, right? Because the current state will be deleted from the current state if the to state is DROPPED after it completes state transition.", "author": "junkaixue", "createdAt": "2020-05-20T21:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NTE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMyNzE3NA==", "url": "https://github.com/apache/helix/pull/994#discussion_r428327174", "bodyText": "Exactly. Since we do not get DROPPED state in current state, we will not mark the the task as DROPPED in job context. If the task is completed and we send COMPLETE to DROPPED message, then the participant will DROP the currentstate (meaning it will be removed from currentState) and this function will not see the task on the instance again because we are based on CurrentState now. Hence, we will not mark the task DROPPED in jobContext in this function. Basically since in this function context follows the currentState, then DROPPED context will not be possible (because DROPPED currentState is also not possible). Right?", "author": "alirezazamani", "createdAt": "2020-05-20T21:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDY1NTE3MA=="}], "type": "inlineReview"}, {"oid": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70", "url": "https://github.com/apache/helix/commit/aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70", "message": "Address the comments", "committedDate": "2020-05-18T18:03:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMTk5MA==", "url": "https://github.com/apache/helix/pull/994#discussion_r427611990", "bodyText": "Should this function be renamed?", "author": "NealSun96", "createdAt": "2020-05-19T21:30:42Z", "path": "helix-core/src/main/java/org/apache/helix/task/JobDispatcher.java", "diffHunk": "@@ -238,21 +238,20 @@ private ResourceAssignment computeResourceMapping(String jobResource,\n     // These dropping transitions will be prioritized above all task state transition assignments\n     Map<String, Set<Integer>> tasksToDrop = new HashMap<>();\n \n-    Map<String, SortedSet<Integer>> prevInstanceToTaskAssignments =\n-        getPrevInstanceToTaskAssignments(liveInstances, prevTaskToInstanceStateAssignment,\n-            allPartitions, currStateOutput, jobResource, tasksToDrop);\n+    Map<String, SortedSet<Integer>> currentInstanceToTaskAssignments =\n+        getCurrentInstanceToTaskAssignments(liveInstances, currStateOutput, jobResource, tasksToDrop);\n \n-    updateInstanceToTaskAssignmentsFromContext(jobCtx, prevInstanceToTaskAssignments);\n+    updateInstanceToTaskAssignmentsFromContext(jobCtx, currentInstanceToTaskAssignments);\n \n     long currentTime = System.currentTimeMillis();\n \n     if (LOG.isDebugEnabled()) {\n       LOG.debug(\"All partitions: \" + allPartitions + \" taskAssignment: \"\n-          + prevInstanceToTaskAssignments + \" excludedInstances: \" + excludedInstances);\n+          + currentInstanceToTaskAssignments + \" excludedInstances: \" + excludedInstances);\n     }\n \n     // Release resource for tasks in terminal state\n-    updatePreviousAssignedTasksStatus(prevInstanceToTaskAssignments, excludedInstances, jobResource,\n+    updatePreviousAssignedTasksStatus(currentInstanceToTaskAssignments, excludedInstances, jobResource,", "originalCommit": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyODM3MQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r428928371", "bodyText": "I think it should be fine to keep it as it is. Because we are updating the state of the tasks that has been assigned in previous pipelines based on the currentstate of the tasks.", "author": "alirezazamani", "createdAt": "2020-05-21T21:33:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxMTk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjI4NQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r427616285", "bodyText": "Would it be a problem that this skipping check is now done after markPartitionCompleted/markPartitionError?", "author": "NealSun96", "createdAt": "2020-05-19T21:39:56Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -121,17 +120,6 @@ public void updatePreviousAssignedTasksStatus(\n               instance, pId);\n           continue;\n         }", "originalCommit": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzMDc0NA==", "url": "https://github.com/apache/helix/pull/994#discussion_r428930744", "bodyText": "This shouldn't be an issue because this check is specifically added before to bypass the scenario where we have two current states which non of the markPartitionCompleted/markPartitionError will not be hit because it is either Running or Dropped. Good question though.", "author": "alirezazamani", "createdAt": "2020-05-21T21:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjc0Ng==", "url": "https://github.com/apache/helix/pull/994#discussion_r427616746", "bodyText": "Is there a possibility that a message exists without state changes?", "author": "NealSun96", "createdAt": "2020-05-19T21:40:53Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,59 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assignedParticipant field needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to assign the task to the wrong participant\n+    // for targeted tasks when two CurrentStates exist for one task.\n+    // In the updatePreviousAssignedTasksStatus, we check\n+    // instance.equals(jobCtx.getAssignedParticipant(pId)) and bypass the assignment if instance is\n+    // not equal to job context's AssignedParticipant for this pId.\n     jobCtx.setAssignedParticipant(pId, instance);\n-    jobCtx.setPartitionState(pId, currentState);\n-    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(pName), instance);\n-    if (taskMsg != null) {\n-      jobCtx.setPartitionInfo(pId, taskMsg);\n+    // If job context needs to be updated with new state, update it accordingly\n+    // This check is necessary because we are relying on current state and we do not want to update\n+    // context as long as current state existed. We just want to update context information\n+    // (specially finish time) once.\n+    // This condition checks whether jobContext's state is out of date or not.\n+    if (!currentState.equals(jobCtx.getPartitionState(pId))) {\n+      jobCtx.setPartitionState(pId, currentState);\n+      String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(pName), instance);\n+      if (taskMsg != null) {\n+        jobCtx.setPartitionInfo(pId, taskMsg);\n+      }", "originalCommit": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzMTQ1MQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r428931451", "bodyText": "The participant read the message, handle state change and then delete the message. So when messages get deleted from ZK after ST is completed. So we should be safe here.", "author": "alirezazamani", "createdAt": "2020-05-21T21:40:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYxNjc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MDQ0NQ==", "url": "https://github.com/apache/helix/pull/994#discussion_r430050445", "bodyText": "@alirezazamani Another concern here:\nIs it possible for a task to be retried so fast (on the participant side) that it ends up being in the same state? For example,\ntask_error -> (controller reschedules it) -> (controller sends messages, error -> init, init -> running, running -> complete) -> participant processes message so quickly but it goes into task_error again, and by the time controller gets to this task, the states are the same as the previous run. Basically, controller sees task_error ->  task_error.\nIs that going to be an issue? I guess partition id is set before this check so that will be updated accordingly, but what about finish time or the time at which the task was marked as error?", "author": "narendly", "createdAt": "2020-05-25T19:08:23Z", "path": "helix-core/src/main/java/org/apache/helix/task/AbstractTaskDispatcher.java", "diffHunk": "@@ -389,13 +381,59 @@ private TaskPartitionState updateJobContextAndGetTaskCurrentState(\n       return stateFromContext == null ? TaskPartitionState.INIT : stateFromContext;\n     }\n     TaskPartitionState currentState = TaskPartitionState.valueOf(currentStateString);\n+    // Update job context based on current state\n+    updatePartitionInformationInJobContext(currentStateOutput, jobResource, currentState, jobCtx,\n+        pId, pName, instance);\n+    return currentState;\n+  }\n+\n+  /**\n+   * Based on the CurrentState of this task and Context information, the task information in the job\n+   * context gets updated.\n+   * @param currentStateOutput\n+   * @param jobResource\n+   * @param currentState\n+   * @param jobCtx\n+   * @param pId\n+   * @param pName\n+   * @param instance\n+   */\n+  private void updatePartitionInformationInJobContext(CurrentStateOutput currentStateOutput,\n+      String jobResource, TaskPartitionState currentState, JobContext jobCtx, Integer pId,\n+      String pName, String instance) {\n+    // The assignedParticipant field needs to be updated regardless of the current state and context\n+    // information because it will prevent controller to assign the task to the wrong participant\n+    // for targeted tasks when two CurrentStates exist for one task.\n+    // In the updatePreviousAssignedTasksStatus, we check\n+    // instance.equals(jobCtx.getAssignedParticipant(pId)) and bypass the assignment if instance is\n+    // not equal to job context's AssignedParticipant for this pId.\n     jobCtx.setAssignedParticipant(pId, instance);\n-    jobCtx.setPartitionState(pId, currentState);\n-    String taskMsg = currentStateOutput.getInfo(jobResource, new Partition(pName), instance);\n-    if (taskMsg != null) {\n-      jobCtx.setPartitionInfo(pId, taskMsg);\n+    // If job context needs to be updated with new state, update it accordingly\n+    // This check is necessary because we are relying on current state and we do not want to update\n+    // context as long as current state existed. We just want to update context information\n+    // (specially finish time) once.\n+    // This condition checks whether jobContext's state is out of date or not.\n+    if (!currentState.equals(jobCtx.getPartitionState(pId))) {", "originalCommit": "aa1cd2c4112436f4bffdfaa4ee49735dfc12fe70", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU4MDYzOA==", "url": "https://github.com/apache/helix/pull/994#discussion_r430580638", "bodyText": "@narendly Thank you for mentioning these corner cases.\nI went through the logic and I am sure the code handles this corner case as well. Let me explain why (please note that if task goes to terminal states, with this PR we are dropping the task first and schedule them in next pipeline):\nHere are the steps:\n1- Requested State is set to TASK_ERROR by the participant.\n2- Controller sends RUNNING -> TASK_ERROR to participant.\n3- Participant process it and makes current state as TASK_ERROR.\n4- Controller see this (i.e. TASK_ERROR) current state and send TASK_ERROR -> DROPPED message.\n5- Participant gets the message and drops/removes current states.\n6- Controller does not see current state (because it is removed) and sets the context of the task to be INIT.  Schedule the task again on the participant by sending INIT-> RUNNING message. (this happens in handleAdditionalTaskAssignment method).\n*Now controller by itself does not send RUNNING -> COMPLETE because COMPLETE state should be requested by the participant. The participant will either request TASK_ERROR or COMPLETE state in current state.\n7- If the task goes to error state we see this delta again (because context is set to be INIT before scheduling the task) and mark it ERROR with new finish time.\nThere are two points here that helps controller to handle this cornet case:\n1- controller will not send running -> complete unless participant requested state is COMPLETE. So if the task goes to TASK_ERROR in participant, the requested state will be TASK_ERROR and controller always respects the requested state and send RUNNING -> TASK_ERROR.\n2- Dropping the task in terminal state makes the controller to reschedule the task with jobContext as INIT. This behavior helps the controller to see these deltas in future pipelines and update the information correctly in jobContext.", "author": "alirezazamani", "createdAt": "2020-05-26T17:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MDQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDY2NTI2MA==", "url": "https://github.com/apache/helix/pull/994#discussion_r430665260", "bodyText": "1- controller will not send running -> complete unless participant requested state is COMPLETE\n\nAre you sure this is true? Can you verify that init -> running / running -> complete are not sent out at the same time? The target state during message generation phase should be complete if I recall correctly.", "author": "narendly", "createdAt": "2020-05-26T19:44:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MDQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMTA0Mw==", "url": "https://github.com/apache/helix/pull/994#discussion_r430711043", "bodyText": "I double checked again and it seems the only way that controller sends COMPLETED message to participant should be initiated by participant by setting the requested state to be completed.", "author": "alirezazamani", "createdAt": "2020-05-26T21:13:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MDQ0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcyODk1Nw==", "url": "https://github.com/apache/helix/pull/994#discussion_r430728957", "bodyText": "Sounds good. Overall I think this analysis is sound. Let's make sure we do a careful round of  E2E testing as well as load testing.", "author": "narendly", "createdAt": "2020-05-26T21:53:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA1MDQ0NQ=="}], "type": "inlineReview"}]}