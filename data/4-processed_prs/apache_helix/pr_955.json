{"pr_number": 955, "pr_title": "Fix MSD routing data refreshing", "pr_createdAt": "2020-04-15T04:18:05Z", "pr_url": "https://github.com/apache/helix/pull/955", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2NzgyMg==", "url": "https://github.com/apache/helix/pull/955#discussion_r408967822", "bodyText": "This if statement shouldn't be deleted. The reasoning is clearly shown in the logging: the callback could be triggered before ZKMetadataStoreDirectory is fully initialized. Removing this if statement leaves the rest of the logic unguarded.", "author": "NealSun96", "createdAt": "2020-04-15T16:17:46Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -304,42 +314,35 @@ public boolean deleteShardingKey(String namespace, String realm, String sharding\n    */\n   @Override\n   public void refreshRoutingData(String namespace) {\n-    // Safe to ignore the callback if any of the maps are null.\n-    // If routingDataMap is null, then it will be populated by the constructor anyway\n-    // If routingDataMap is not null, then it's safe for the callback function to update it\n-    if (_routingZkAddressMap == null || _realmToShardingKeysMap == null\n-        || _routingDataReaderMap == null || _routingDataWriterMap == null) {\n-      LOG.warn(\n-          \"refreshRoutingData callback called before ZKMetadataStoreDirectory was fully initialized. Skipping refresh!\");", "originalCommit": "290cddcc6f715353e20c8f75bac6b2412e74981c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyMjk4NQ==", "url": "https://github.com/apache/helix/pull/955#discussion_r409022985", "bodyText": "Can you help me understand in what case the callback could be triggered before ZKMetadataStoreDirectory is fully initialized?", "author": "huizhilu", "createdAt": "2020-04-15T17:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2NzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NTI1MA==", "url": "https://github.com/apache/helix/pull/955#discussion_r409085250", "bodyText": "When the ZkMetadataStoreDirectory is initialized, it initializes ZkRoutingDataReader which subscribe to ZNode changes and calls refreshRoutingData() when an event happens. It's possible that an event comes in before ZkMetadataStoreDirectory finishes initialization, which we don't want to handle.\nThis is my understanding to it. This was introduced to me first by @narendly , and he was also the first to write this statement so he could provide further comments if necessary.", "author": "NealSun96", "createdAt": "2020-04-15T19:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2NzgyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA3ODI2NQ==", "url": "https://github.com/apache/helix/pull/955#discussion_r410078265", "bodyText": "@NealSun96 Thanks for the explanation.\nAfter I check the code carefully, I don't see what you said is the case. ZkRoutingDataReader is initialized after the maps are created. So I think this check is safe to remove.", "author": "huizhilu", "createdAt": "2020-04-17T08:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk2NzgyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MDAxNw==", "url": "https://github.com/apache/helix/pull/955#discussion_r408970017", "bodyText": "The raw data shouldn't be removed here. The raw data is allowed to contain invalid routing data.", "author": "NealSun96", "createdAt": "2020-04-15T16:21:08Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -304,42 +314,35 @@ public boolean deleteShardingKey(String namespace, String realm, String sharding\n    */\n   @Override\n   public void refreshRoutingData(String namespace) {\n-    // Safe to ignore the callback if any of the maps are null.\n-    // If routingDataMap is null, then it will be populated by the constructor anyway\n-    // If routingDataMap is not null, then it's safe for the callback function to update it\n-    if (_routingZkAddressMap == null || _realmToShardingKeysMap == null\n-        || _routingDataReaderMap == null || _routingDataWriterMap == null) {\n-      LOG.warn(\n-          \"refreshRoutingData callback called before ZKMetadataStoreDirectory was fully initialized. Skipping refresh!\");\n-      return;\n-    }\n-\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\n           \"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n       return;\n     }\n \n-    // Remove the raw data first in case of failure on creation\n-    _realmToShardingKeysMap.remove(namespace);\n-    // Remove routing data first in case of failure on creation\n-    _routingDataMap.remove(namespace);\n-\n     Map<String, List<String>> rawRoutingData;\n     try {\n       rawRoutingData = _routingDataReaderMap.get(namespace).getRoutingData();\n-      _realmToShardingKeysMap.put(namespace, rawRoutingData);\n     } catch (InvalidRoutingDataException e) {\n       LOG.error(\"Failed to refresh cached routing data for namespace {}\", namespace, e);\n+      _realmToShardingKeysMap.remove(namespace);\n+      _routingDataMap.remove(namespace);\n       return;\n     }\n \n+    TrieRoutingData trieRoutingData;\n     try {\n-      _routingDataMap.put(namespace, new TrieRoutingData(rawRoutingData));\n+      trieRoutingData = new TrieRoutingData(rawRoutingData);\n     } catch (InvalidRoutingDataException e) {\n       LOG.warn(\"TrieRoutingData is not created for namespace {}\", namespace, e);\n+      _realmToShardingKeysMap.remove(namespace);", "originalCommit": "290cddcc6f715353e20c8f75bac6b2412e74981c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MDYwMA==", "url": "https://github.com/apache/helix/pull/955#discussion_r408970600", "bodyText": "As you pointed out yesterday, it's better to assign empty data here.", "author": "NealSun96", "createdAt": "2020-04-15T16:22:02Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -304,42 +314,35 @@ public boolean deleteShardingKey(String namespace, String realm, String sharding\n    */\n   @Override\n   public void refreshRoutingData(String namespace) {\n-    // Safe to ignore the callback if any of the maps are null.\n-    // If routingDataMap is null, then it will be populated by the constructor anyway\n-    // If routingDataMap is not null, then it's safe for the callback function to update it\n-    if (_routingZkAddressMap == null || _realmToShardingKeysMap == null\n-        || _routingDataReaderMap == null || _routingDataWriterMap == null) {\n-      LOG.warn(\n-          \"refreshRoutingData callback called before ZKMetadataStoreDirectory was fully initialized. Skipping refresh!\");\n-      return;\n-    }\n-\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\n           \"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n       return;\n     }\n \n-    // Remove the raw data first in case of failure on creation\n-    _realmToShardingKeysMap.remove(namespace);\n-    // Remove routing data first in case of failure on creation\n-    _routingDataMap.remove(namespace);\n-\n     Map<String, List<String>> rawRoutingData;\n     try {\n       rawRoutingData = _routingDataReaderMap.get(namespace).getRoutingData();\n-      _realmToShardingKeysMap.put(namespace, rawRoutingData);\n     } catch (InvalidRoutingDataException e) {\n       LOG.error(\"Failed to refresh cached routing data for namespace {}\", namespace, e);\n+      _realmToShardingKeysMap.remove(namespace);", "originalCommit": "290cddcc6f715353e20c8f75bac6b2412e74981c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNDI3Nw==", "url": "https://github.com/apache/helix/pull/955#discussion_r409024277", "bodyText": "I keep it here because if it is assigned empty data, one other test TestRoutingDataUpdate would fail because it assumes routing namespace is deleted. Let's have more careful discussion about the behavior before we change it here.", "author": "huizhilu", "createdAt": "2020-04-15T17:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MDYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NTk5Nw==", "url": "https://github.com/apache/helix/pull/955#discussion_r409085997", "bodyText": "My understanding is that you prefer not deleting namespaces, and I agree with your point, so it's safe to change that behavior. We can modify the test cases to reflect that.", "author": "NealSun96", "createdAt": "2020-04-15T19:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MDYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MDc5MQ==", "url": "https://github.com/apache/helix/pull/955#discussion_r410080791", "bodyText": "Discussed offline. I've changed to assign an empty map to _realmToShardingKeysMap namespace. And the tests pass.", "author": "huizhilu", "createdAt": "2020-04-17T08:44:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MDYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MTAzNg==", "url": "https://github.com/apache/helix/pull/955#discussion_r408971036", "bodyText": "Overall, I think it's more clean to do try {overwriteOldData} catch {eraseOldData} for both blocks of the logic.", "author": "NealSun96", "createdAt": "2020-04-15T16:22:38Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -304,42 +314,35 @@ public boolean deleteShardingKey(String namespace, String realm, String sharding\n    */\n   @Override\n   public void refreshRoutingData(String namespace) {\n-    // Safe to ignore the callback if any of the maps are null.\n-    // If routingDataMap is null, then it will be populated by the constructor anyway\n-    // If routingDataMap is not null, then it's safe for the callback function to update it\n-    if (_routingZkAddressMap == null || _realmToShardingKeysMap == null\n-        || _routingDataReaderMap == null || _routingDataWriterMap == null) {\n-      LOG.warn(\n-          \"refreshRoutingData callback called before ZKMetadataStoreDirectory was fully initialized. Skipping refresh!\");\n-      return;\n-    }\n-\n     // Check if namespace exists; otherwise, return as a NOP and log it\n     if (!_routingZkAddressMap.containsKey(namespace)) {\n       LOG.error(\n           \"Failed to refresh internally-cached routing data! Namespace not found: \" + namespace);\n       return;\n     }\n \n-    // Remove the raw data first in case of failure on creation\n-    _realmToShardingKeysMap.remove(namespace);\n-    // Remove routing data first in case of failure on creation\n-    _routingDataMap.remove(namespace);\n-\n     Map<String, List<String>> rawRoutingData;\n     try {\n       rawRoutingData = _routingDataReaderMap.get(namespace).getRoutingData();\n-      _realmToShardingKeysMap.put(namespace, rawRoutingData);\n     } catch (InvalidRoutingDataException e) {\n       LOG.error(\"Failed to refresh cached routing data for namespace {}\", namespace, e);\n+      _realmToShardingKeysMap.remove(namespace);\n+      _routingDataMap.remove(namespace);\n       return;\n     }\n \n+    TrieRoutingData trieRoutingData;\n     try {\n-      _routingDataMap.put(namespace, new TrieRoutingData(rawRoutingData));\n+      trieRoutingData = new TrieRoutingData(rawRoutingData);\n     } catch (InvalidRoutingDataException e) {\n       LOG.warn(\"TrieRoutingData is not created for namespace {}\", namespace, e);\n+      _realmToShardingKeysMap.remove(namespace);\n+      _routingDataMap.remove(namespace);\n+      return;\n     }\n+\n+    _realmToShardingKeysMap.put(namespace, rawRoutingData);\n+    _routingDataMap.put(namespace, trieRoutingData);", "originalCommit": "290cddcc6f715353e20c8f75bac6b2412e74981c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNTA3Ng==", "url": "https://github.com/apache/helix/pull/955#discussion_r409025076", "bodyText": "My logic here is like a validation first and update. We will discuss the behavior first and make the change.", "author": "huizhilu", "createdAt": "2020-04-15T17:49:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA4NjQzNA==", "url": "https://github.com/apache/helix/pull/955#discussion_r409086434", "bodyText": "The validation process = the exception. If something is caught it means the data is invalid. So validation will always go first before update.", "author": "NealSun96", "createdAt": "2020-04-15T19:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDA4MTkwNw==", "url": "https://github.com/apache/helix/pull/955#discussion_r410081907", "bodyText": "I prefer to catch the exception specifically for this operation trieRoutingData = new TrieRoutingData(rawRoutingData); to make it clean.", "author": "huizhilu", "createdAt": "2020-04-17T08:46:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3MTAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3NTEyMw==", "url": "https://github.com/apache/helix/pull/955#discussion_r408975123", "bodyText": "The meaning of the block on line 343 is \"ensure that an IllegalStateException is raised and the message is 'Failed to get...'\". Is this block ensuring a IllegalArgumentException is raised? That's not what this test case is testing.", "author": "NealSun96", "createdAt": "2020-04-15T16:28:56Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/TestZkMetadataStoreDirectory.java", "diffHunk": "@@ -344,6 +345,10 @@ public void testDataDeletionCallback() throws Exception {\n               + \" contains either empty or invalid routing data!\")) {\n             return false;\n           }\n+        } catch (IllegalArgumentException iae) {\n+          if (!iae.getMessage().equals(\"Provided path is not a valid Zookeeper path: anyKey\")) {\n+            return false;", "originalCommit": "290cddcc6f715353e20c8f75bac6b2412e74981c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAzMTgxOQ==", "url": "https://github.com/apache/helix/pull/955#discussion_r409031819", "bodyText": "Refreshing routing has a delay. And this is why TestHelper.verify() is used. Before routing is deleted in cached, namespace is still in cache, right? So the request still goes to TrieRouting, and IllegalArgumentException would be thrown because anyKey is invalid. In this case, we should catch the exception and retry, right?\nThe better I think is this. I will update PR.\n    Assert.assertTrue(TestHelper.verify(() -> {\n      for (String namespace : _routingZkAddrMap.keySet()) {\n        try {\n          _metadataStoreDirectory.getMetadataStoreRealm(namespace, \"anyKey\");\n          Assert.fail(\"Should not successfully get routing data\");\n        } catch (IllegalStateException e) {\n          // If other IllegalStateException, it is unexpected and this test should fail.\n          if (!e.getMessage().equals(\"Failed to get metadata store realm: Namespace \" + namespace\n              + \" contains either empty or invalid routing data!\")) {\n            throw e;\n          }\n        } catch (IllegalArgumentException iae) {\n          // If routing data is not yet refreshed, return false and retry.\n          if (iae.getMessage().equals(\"Provided path is not a valid Zookeeper path: anyKey\")) {\n            return false;\n          }\n          // If other IllegalArgumentException, it is not expected and this test should fail.\n          throw iae;\n        }\n      }\n      return true;\n    }, TestHelper.WAIT_DURATION));", "author": "huizhilu", "createdAt": "2020-04-15T18:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3NTEyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTA5MDA0MA==", "url": "https://github.com/apache/helix/pull/955#discussion_r409090040", "bodyText": "I see your point now, thanks for the explanation. Was this test case flaky because of that? This is a very good catch! \ud83d\udc4d\nI think it makes more sense to replace \"anyKey\" with an actual existing key in the routing data; the handling of IllegalArgumentException is only caused by \"anyKey\", and is not what this test case should focus on. My point is that using \"anyKey\" is a mistake. We shouldn't change the test case to accommodate that mistake; we can just correct it by using something like TEST_SHARDING_KEYS.", "author": "NealSun96", "createdAt": "2020-04-15T19:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk3NTEyMw=="}], "type": "inlineReview"}, {"oid": "8c5c5a47c2d8c629e06d27260f14f5c76c60dcbf", "url": "https://github.com/apache/helix/commit/8c5c5a47c2d8c629e06d27260f14f5c76c60dcbf", "message": "Fix routing data refreshing in MSDS", "committedDate": "2020-04-23T01:54:26Z", "type": "commit"}, {"oid": "8c5c5a47c2d8c629e06d27260f14f5c76c60dcbf", "url": "https://github.com/apache/helix/commit/8c5c5a47c2d8c629e06d27260f14f5c76c60dcbf", "message": "Fix routing data refreshing in MSDS", "committedDate": "2020-04-23T01:54:26Z", "type": "forcePushed"}]}