{"pr_number": 1500, "pr_title": "Refine the message handler error handling logic to avoid unnecessary retry.", "pr_createdAt": "2020-10-30T06:17:20Z", "pr_url": "https://github.com/apache/helix/pull/1500", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMTA2Mg==", "url": "https://github.com/apache/helix/pull/1500#discussion_r514901062", "bodyText": "this is a little confusing. what's wrong with leaving it as readMsgs? updatingMsgs is a confusing name since messages don't update themselves.\nor msgsToBeHandled or msgsToHandle could also be as equally descriptive", "author": "narendly", "createdAt": "2020-10-30T06:50:32Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -788,8 +793,8 @@ public void onMessage(String instanceName, List<Message> messages,\n     List<MessageHandler> nonStateTransitionHandlers = new ArrayList<>();\n     List<NotificationContext> nonStateTransitionContexts = new ArrayList<>();\n \n-    // message read\n-    List<Message> readMsgs = new ArrayList<>();\n+    // message to be updated in ZK\n+    List<Message> updatingMsgs = new ArrayList<>();", "originalCommit": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMzc4MA==", "url": "https://github.com/apache/helix/pull/1500#discussion_r514903780", "bodyText": "readMsgs is no longer an accurate name with this change.\nHow about msgsToBeUpdated ?", "author": "jiajunwang", "createdAt": "2020-10-30T06:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMTA2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMTM3NA==", "url": "https://github.com/apache/helix/pull/1500#discussion_r514901374", "bodyText": "is this log absolutely necessary? wouldn't it be sufficient to log when we've used up all the retry counts? i'm afraid this might just end up polluting the log", "author": "narendly", "createdAt": "2020-10-30T06:51:44Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -804,40 +809,66 @@ public void onMessage(String instanceName, List<Message> messages,\n         // skip the following operations for the no-op messages.\n         continue;\n       }\n-      // create message handlers, if handlers not found, leave its state as NEW\n+\n       NotificationContext msgWorkingContext = changeContext.clone();\n+      MessageHandler msgHandler = null;\n       try {\n-        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n-        if (msgHandler == null) {\n-          // Failed to create message handler, skip processing this message in this callback.\n-          // The same message process will be retried in the next round.\n-          continue;\n-        }\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n-            .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          if (validateAndProcessStateTransitionMessage(message, instanceName, manager,\n-              stateTransitionHandlers, msgHandler)) {\n-            // Need future process by triggering state transition\n-            String msgTarget =\n-                getMessageTarget(message.getResourceName(), message.getPartitionName());\n-            stateTransitionHandlers.put(msgTarget, msgHandler);\n-            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n-          } else {\n-            // skip the following operations for the invalid/expired state transition messages.\n-            continue;\n-          }\n+        // create message handlers, if handlers not found but no exception, leave its state as NEW\n+        msgHandler = createMessageHandler(message, msgWorkingContext);\n+      } catch (Exception ex) {\n+        // Failed to create message handler and there is an Exception.\n+        int remainingRetryCount = message.getRetryCount();\n+        LOG.error(\n+            \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n+            message.getMsgId(), remainingRetryCount);\n+        // Set the message retry count to avoid infinite retrying.\n+        message.setRetryCount(remainingRetryCount - 1);\n+        message.setExecuteSessionId(sessionId);\n+        // continue processing in the next section where handler object is double-checked.\n+      }\n+\n+      if (msgHandler == null) {\n+        if (message.getRetryCount() < 0) {\n+          // If no more retry count remains, then mark the message to be UNPROCESSABLE.\n+          String errorMsg = String\n+              .format(\"Message %s has a negative remaining retry count %d. Stop processing it!\",\n+                  message.getMsgId(), message.getRetryCount());\n+          updateUnprocessableMessage(message, null, errorMsg, manager);\n+          updatingMsgs.add(message);\n         } else {\n-          // Need future process non state transition messages by triggering the handler\n-          nonStateTransitionHandlers.add(msgHandler);\n-          nonStateTransitionContexts.add(msgWorkingContext);\n+          // Skip processing this message in this callback. The same message process will be retried\n+          // in the next round.\n+          LOG.warn(\"There is no existing handler for message {}.\"\n+                  + \" Skip processing it for now. Will retry on the next callback.\",", "originalCommit": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwNTczMA==", "url": "https://github.com/apache/helix/pull/1500#discussion_r514905730", "bodyText": "When there is no exception, but the createHandler returns null, we don't have any other output except for this line. So I think it is necessary.\nIf we see many of this line, then the application logic in participants might have some serious issue, and we shall fix it.", "author": "jiajunwang", "createdAt": "2020-10-30T07:06:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMTM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMjAxOA==", "url": "https://github.com/apache/helix/pull/1500#discussion_r514902018", "bodyText": "nit: instead of saying \"negative retry count\", what you really meant is \"this message has been retried for \"retryCount\" times\"\nalso i'd print the msgHandler here. although we could deduce this info from the code, we might want to indicate that msgHandler is null in the log message as well for faster debugging", "author": "narendly", "createdAt": "2020-10-30T06:53:52Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -804,40 +809,66 @@ public void onMessage(String instanceName, List<Message> messages,\n         // skip the following operations for the no-op messages.\n         continue;\n       }\n-      // create message handlers, if handlers not found, leave its state as NEW\n+\n       NotificationContext msgWorkingContext = changeContext.clone();\n+      MessageHandler msgHandler = null;\n       try {\n-        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n-        if (msgHandler == null) {\n-          // Failed to create message handler, skip processing this message in this callback.\n-          // The same message process will be retried in the next round.\n-          continue;\n-        }\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n-            .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          if (validateAndProcessStateTransitionMessage(message, instanceName, manager,\n-              stateTransitionHandlers, msgHandler)) {\n-            // Need future process by triggering state transition\n-            String msgTarget =\n-                getMessageTarget(message.getResourceName(), message.getPartitionName());\n-            stateTransitionHandlers.put(msgTarget, msgHandler);\n-            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n-          } else {\n-            // skip the following operations for the invalid/expired state transition messages.\n-            continue;\n-          }\n+        // create message handlers, if handlers not found but no exception, leave its state as NEW\n+        msgHandler = createMessageHandler(message, msgWorkingContext);\n+      } catch (Exception ex) {\n+        // Failed to create message handler and there is an Exception.\n+        int remainingRetryCount = message.getRetryCount();\n+        LOG.error(\n+            \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n+            message.getMsgId(), remainingRetryCount);\n+        // Set the message retry count to avoid infinite retrying.\n+        message.setRetryCount(remainingRetryCount - 1);\n+        message.setExecuteSessionId(sessionId);\n+        // continue processing in the next section where handler object is double-checked.\n+      }\n+\n+      if (msgHandler == null) {\n+        if (message.getRetryCount() < 0) {\n+          // If no more retry count remains, then mark the message to be UNPROCESSABLE.\n+          String errorMsg = String\n+              .format(\"Message %s has a negative remaining retry count %d. Stop processing it!\",", "originalCommit": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwNDk4Ng==", "url": "https://github.com/apache/helix/pull/1500#discussion_r514904986", "bodyText": "Not true for \"this message has been retried for \"retryCount\" times\". Since at this place, we don't know how many times this message has been retried. It is not possible to print this information out.\nI can add the information that the handler is not available in the error message to make it self-containing.", "author": "jiajunwang", "createdAt": "2020-10-30T07:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwMjAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwNTE3Mg==", "url": "https://github.com/apache/helix/pull/1500#discussion_r514905172", "bodyText": "are we writing this back to zk or is this for in-memory use only? if we're writing back, would that be an added amount of zk writes/updates that we should worry about?\nshould be possible to track remaining retry counts purely in-memory per cached message using message id.", "author": "narendly", "createdAt": "2020-10-30T07:04:33Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -804,40 +809,66 @@ public void onMessage(String instanceName, List<Message> messages,\n         // skip the following operations for the no-op messages.\n         continue;\n       }\n-      // create message handlers, if handlers not found, leave its state as NEW\n+\n       NotificationContext msgWorkingContext = changeContext.clone();\n+      MessageHandler msgHandler = null;\n       try {\n-        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n-        if (msgHandler == null) {\n-          // Failed to create message handler, skip processing this message in this callback.\n-          // The same message process will be retried in the next round.\n-          continue;\n-        }\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n-            .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          if (validateAndProcessStateTransitionMessage(message, instanceName, manager,\n-              stateTransitionHandlers, msgHandler)) {\n-            // Need future process by triggering state transition\n-            String msgTarget =\n-                getMessageTarget(message.getResourceName(), message.getPartitionName());\n-            stateTransitionHandlers.put(msgTarget, msgHandler);\n-            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n-          } else {\n-            // skip the following operations for the invalid/expired state transition messages.\n-            continue;\n-          }\n+        // create message handlers, if handlers not found but no exception, leave its state as NEW\n+        msgHandler = createMessageHandler(message, msgWorkingContext);\n+      } catch (Exception ex) {\n+        // Failed to create message handler and there is an Exception.\n+        int remainingRetryCount = message.getRetryCount();\n+        LOG.error(\n+            \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n+            message.getMsgId(), remainingRetryCount);\n+        // Set the message retry count to avoid infinite retrying.\n+        message.setRetryCount(remainingRetryCount - 1);\n+        message.setExecuteSessionId(sessionId);", "originalCommit": "48765de7a81fcdbbfd1a1faada4bb7686b7d1477", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkxMTQ0Nw==", "url": "https://github.com/apache/helix/pull/1500#discussion_r514911447", "bodyText": "It is a good point.\nThere were some discussions earlier yesterday about whether we want this retry count. So the decision is that we want to allow several retries, but would be a very small number. Note that this PR won't really add retry to state transition messages, since the default value of retry count is 0. We will tackle this later in the other PR.\nNow regarding if we want to use an in-memory object instead of ZK, it is totally doable. But I don't prefer doing so for 2 reasons.\n\nThis ZK write won't make it worse. The retry is not infinite after this change. Compare with the current behavior that we keep retrying infinitely, the new retry logic is much safer. And we can set 0 to the retry count, so no retry at all. It is purely optional.\nIn-memory count won't work if the participant instance is reset. If the retry count is really large, then in some corner case (like frequent participant reset) the retry will never stop.\n\nIn addition, the in-memory design requires us to track the messages, it does not exist on the participant side today. So definitely, it will increase the complicity of code. There will be more corner cases that we need to consider. Like memory leakage, etc. Given the benefit of doing so is not critical, I prefer not to choose this option.", "author": "jiajunwang", "createdAt": "2020-10-30T07:23:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkwNTE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5NzY1OA==", "url": "https://github.com/apache/helix/pull/1500#discussion_r516897658", "bodyText": "Seems even there is no exception, you will still set the message as unprocessable after retry instead of leaving it as NEW?", "author": "zhangmeng916", "createdAt": "2020-11-03T19:13:48Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -804,40 +809,67 @@ public void onMessage(String instanceName, List<Message> messages,\n         // skip the following operations for the no-op messages.\n         continue;\n       }\n-      // create message handlers, if handlers not found, leave its state as NEW\n+\n       NotificationContext msgWorkingContext = changeContext.clone();\n+      MessageHandler msgHandler = null;\n       try {\n-        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n-        if (msgHandler == null) {\n-          // Failed to create message handler, skip processing this message in this callback.\n-          // The same message process will be retried in the next round.\n-          continue;\n-        }\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n-            .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          if (validateAndProcessStateTransitionMessage(message, instanceName, manager,\n-              stateTransitionHandlers, msgHandler)) {\n-            // Need future process by triggering state transition\n-            String msgTarget =\n-                getMessageTarget(message.getResourceName(), message.getPartitionName());\n-            stateTransitionHandlers.put(msgTarget, msgHandler);\n-            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n-          } else {\n-            // skip the following operations for the invalid/expired state transition messages.\n-            continue;\n-          }\n+        // create message handlers, if handlers not found but no exception, leave its state as NEW\n+        msgHandler = createMessageHandler(message, msgWorkingContext);\n+      } catch (Exception ex) {\n+        // Failed to create message handler and there is an Exception.\n+        int remainingRetryCount = message.getRetryCount();\n+        LOG.error(\n+            \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n+            message.getMsgId(), remainingRetryCount);\n+        // Set the message retry count to avoid infinite retrying.\n+        message.setRetryCount(remainingRetryCount - 1);\n+        message.setExecuteSessionId(sessionId);\n+        // continue processing in the next section where handler object is double-checked.\n+      }\n+\n+      if (msgHandler == null) {\n+        if (message.getRetryCount() < 0) {\n+          // If no more retry count remains, then mark the message to be UNPROCESSABLE.\n+          String errorMsg = String\n+              .format(\"No available message Handler found!\"\n+                      + \" Stop processing message %s since it has a negative remaining retry count %d!\",\n+                  message.getMsgId(), message.getRetryCount());\n+          updateUnprocessableMessage(message, null, errorMsg, manager);", "originalCommit": "326bd7129fee4ed5020c62f0590f03ebdb19bd26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5MTM0OQ==", "url": "https://github.com/apache/helix/pull/1500#discussion_r516991349", "bodyText": "This is not true. The default retry count is 0. And we only reduce it if an exception happens. So if there is no exception, then it will keep retrying.", "author": "jiajunwang", "createdAt": "2020-11-03T22:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5NzY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5OTc2NQ==", "url": "https://github.com/apache/helix/pull/1500#discussion_r516899765", "bodyText": "I don't quite understand why we swallow exception here. This exception means user's reset has an issue, and can we just let the error go?", "author": "zhangmeng916", "createdAt": "2020-11-03T19:17:42Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -613,7 +613,12 @@ void reset() {\n \n       MsgHandlerFactoryRegistryItem item = _hdlrFtyRegistry.get(msgType);\n       if (item.factory() != null) {\n-        item.factory().reset();\n+        try {\n+          item.factory().reset();\n+        } catch (Exception ex) {", "originalCommit": "326bd7129fee4ed5020c62f0590f03ebdb19bd26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxODM2Mw==", "url": "https://github.com/apache/helix/pull/1500#discussion_r516918363", "bodyText": "Just wondering, is it better to log the backtrace as well for better debuggability?", "author": "xyuanlu", "createdAt": "2020-11-03T19:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5OTc2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5MjIxNg==", "url": "https://github.com/apache/helix/pull/1500#discussion_r516992216", "bodyText": "This is only called when we clean up. All the paths lead to the termination of the executor. The only result of not swallowing the exception is that the later cleanup steps will not happen.\nBacktrace is a good point. I think I missed it unintentionally. Thanks for pointing this out.", "author": "jiajunwang", "createdAt": "2020-11-03T22:27:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5OTc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNDY3OA==", "url": "https://github.com/apache/helix/pull/1500#discussion_r516904678", "bodyText": "I think we changed the original behavior, and never remove messages in this case. There is a mismatch in the comment. But, is this what we would like to do? not removing duplicated message, but only mark it? Seems we leave many unnecessary messages on ZK.", "author": "zhangmeng916", "createdAt": "2020-11-03T19:27:03Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -993,67 +1034,78 @@ private boolean checkAndProcessNoOpMessage(Message message, String instanceName,\n    * Preprocess the state transition message to validate if the request is valid.\n    * If no operation needs to be triggered, discard the the message.\n    * @param message\n-   * @param instanceName\n    * @param manager\n    * @param stateTransitionHandlers\n    * @param createHandler\n    * @return True if the requested state transition is valid, and need to schedule the transition.\n    *         False if no more operation is required.\n    */\n-  private boolean validateAndProcessStateTransitionMessage(Message message, String instanceName,\n-      HelixManager manager, Map<String, MessageHandler> stateTransitionHandlers,\n-      MessageHandler createHandler) {\n-    HelixDataAccessor accessor = manager.getHelixDataAccessor();\n-\n+  private boolean validateAndProcessStateTransitionMessage(Message message, HelixManager manager,\n+      Map<String, MessageHandler> stateTransitionHandlers, MessageHandler createHandler) {\n     String messageTarget = getMessageTarget(message.getResourceName(), message.getPartitionName());\n-    if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n-        && isStateTransitionInProgress(messageTarget)) {\n-      String taskId = _messageTaskMap.get(messageTarget);\n-      Message msg = _taskMap.get(taskId).getTask().getMessage();\n-      // If there is another state transition for same partition is going on,\n-      // discard the message. Controller will resend if this is a valid message\n-      String errMsg = String.format(\n-          \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n-          message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n-          msg.isRelayMessage(), msg.getReadTimeStamp(), System.currentTimeMillis(),\n-          message.getFromState(), message.getToState());\n-      handleUnprocessableMessage(message, null /* exception */, errMsg, accessor, instanceName,\n-          manager);\n-      return false;\n-    }\n-    if (createHandler instanceof HelixStateTransitionHandler) {\n-      // We only check to state if there is no ST task scheduled/executing.\n-      HelixStateTransitionHandler.StaleMessageValidateResult result =\n-          ((HelixStateTransitionHandler) createHandler).staleMessageValidator();\n-      if (!result.isValid) {\n-        handleUnprocessableMessage(message, null /* exception */, result.exception.getMessage(),\n-            accessor, instanceName, manager);\n+\n+    try {\n+      if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n+          && isStateTransitionInProgress(messageTarget)) {\n+        String taskId = _messageTaskMap.get(messageTarget);\n+        Message msg = _taskMap.get(taskId).getTask().getMessage();\n+        // If there is another state transition for same partition is going on,\n+        // discard the message. Controller will resend if this is a valid message\n+        String errMsg = String.format(\n+            \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n+            message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n+            msg.isRelayMessage(), msg.getReadTimeStamp(), System.currentTimeMillis(),\n+            message.getFromState(), message.getToState());\n+        updateUnprocessableMessage(message, null /* exception */, errMsg, manager);\n         return false;\n       }\n-    }\n-    if (stateTransitionHandlers.containsKey(messageTarget)) {\n-      // If there are 2 messages in same batch about same partition's state transition,\n-      // the later one is discarded\n-      Message duplicatedMessage = stateTransitionHandlers.get(messageTarget)._message;\n-      String errMsg = String.format(\n-          \"Duplicated state transition message: %s. Existing: %s->%s; New (Discarded): %s->%s\",\n-          message.getMsgId(), duplicatedMessage.getFromState(), duplicatedMessage.getToState(),\n-          message.getFromState(), message.getToState());\n-      handleUnprocessableMessage(message, null /* exception */, errMsg, accessor, instanceName,\n+      if (createHandler instanceof HelixStateTransitionHandler) {\n+        // We only check to state if there is no ST task scheduled/executing.\n+        HelixStateTransitionHandler.StaleMessageValidateResult result =\n+            ((HelixStateTransitionHandler) createHandler).staleMessageValidator();\n+        if (!result.isValid) {\n+          updateUnprocessableMessage(message, null /* exception */, result.exception.getMessage(),\n+              manager);\n+          return false;\n+        }\n+      }\n+      if (stateTransitionHandlers.containsKey(messageTarget)) {\n+        // If there are 2 messages in same batch about same partition's state transition,\n+        // the later one is discarded\n+        Message duplicatedMessage = stateTransitionHandlers.get(messageTarget)._message;\n+        String errMsg = String.format(\n+            \"Duplicated state transition message: %s. Existing: %s->%s; New (Discarded): %s->%s\",\n+            message.getMsgId(), duplicatedMessage.getFromState(), duplicatedMessage.getToState(),\n+            message.getFromState(), message.getToState());\n+        updateUnprocessableMessage(message, null /* exception */, errMsg, manager);", "originalCommit": "326bd7129fee4ed5020c62f0590f03ebdb19bd26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk5NDE2Mg==", "url": "https://github.com/apache/helix/pull/1500#discussion_r516994162", "bodyText": "I moved the removing message logic to the caller. So for this specific case, it will keep the original behavior.\nThis change is for reusing the updateUnprocessableMessage in the other conditions. In addition, I also want to avoid silently removing a message in a very deep private call. So the new logic puts all the message processing (update or remove) in a smaller scope.", "author": "jiajunwang", "createdAt": "2020-11-03T22:31:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkwNDY3OA=="}], "type": "inlineReview"}, {"oid": "56d2e229fe0acd883d0f18a2c1433de4b6af6127", "url": "https://github.com/apache/helix/commit/56d2e229fe0acd883d0f18a2c1433de4b6af6127", "message": "Refine the message handler error handling logic to avoid unnecessary retry.", "committedDate": "2020-11-04T05:53:24Z", "type": "commit"}, {"oid": "bec10b0136089416a4ec0cca67e3bc81982fddd9", "url": "https://github.com/apache/helix/commit/bec10b0136089416a4ec0cca67e3bc81982fddd9", "message": "Address comments.", "committedDate": "2020-11-04T05:53:24Z", "type": "commit"}, {"oid": "352d4408f4b72838ee62694df75031bc4f63c03b", "url": "https://github.com/apache/helix/commit/352d4408f4b72838ee62694df75031bc4f63c03b", "message": "Address more comments.", "committedDate": "2020-11-04T05:53:24Z", "type": "commit"}, {"oid": "352d4408f4b72838ee62694df75031bc4f63c03b", "url": "https://github.com/apache/helix/commit/352d4408f4b72838ee62694df75031bc4f63c03b", "message": "Address more comments.", "committedDate": "2020-11-04T05:53:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjM2OQ==", "url": "https://github.com/apache/helix/pull/1500#discussion_r517562369", "bodyText": "NIT: From the retry count definition, we should let retry count check happens before you try another round of creation. If retry count is less than 0, it means it has one more retry than what we defined for the retry count. I know this could be a minor issue. But logically, it breaks the counting rule. Better to reorganize it.", "author": "junkaixue", "createdAt": "2020-11-04T18:55:01Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -804,40 +809,67 @@ public void onMessage(String instanceName, List<Message> messages,\n         // skip the following operations for the no-op messages.\n         continue;\n       }\n-      // create message handlers, if handlers not found, leave its state as NEW\n+\n       NotificationContext msgWorkingContext = changeContext.clone();\n+      MessageHandler msgHandler = null;\n       try {\n-        MessageHandler msgHandler = createMessageHandler(message, msgWorkingContext);\n-        if (msgHandler == null) {\n-          // Failed to create message handler, skip processing this message in this callback.\n-          // The same message process will be retried in the next round.\n-          continue;\n-        }\n-        if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name()) || message.getMsgType()\n-            .equals(MessageType.STATE_TRANSITION_CANCELLATION.name())) {\n-          if (validateAndProcessStateTransitionMessage(message, instanceName, manager,\n-              stateTransitionHandlers, msgHandler)) {\n-            // Need future process by triggering state transition\n-            String msgTarget =\n-                getMessageTarget(message.getResourceName(), message.getPartitionName());\n-            stateTransitionHandlers.put(msgTarget, msgHandler);\n-            stateTransitionContexts.put(msgTarget, msgWorkingContext);\n-          } else {\n-            // skip the following operations for the invalid/expired state transition messages.\n-            continue;\n-          }\n+        // create message handlers, if handlers not found but no exception, leave its state as NEW\n+        msgHandler = createMessageHandler(message, msgWorkingContext);\n+      } catch (Exception ex) {\n+        // Failed to create message handler and there is an Exception.\n+        int remainingRetryCount = message.getRetryCount();\n+        LOG.error(\n+            \"Exception happens when creating Message Handler for message {}. Current remaining retry count is {}.\",\n+            message.getMsgId(), remainingRetryCount);\n+        // Set the message retry count to avoid infinite retrying.\n+        message.setRetryCount(remainingRetryCount - 1);\n+        message.setExecuteSessionId(sessionId);\n+        // continue processing in the next section where handler object is double-checked.\n+      }\n+\n+      if (msgHandler == null) {\n+        if (message.getRetryCount() < 0) {", "originalCommit": "352d4408f4b72838ee62694df75031bc4f63c03b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4MDUxNA==", "url": "https://github.com/apache/helix/pull/1500#discussion_r517580514", "bodyText": "Good catch! I guess I tried to simplify the code too much. Let me fix it.", "author": "jiajunwang", "createdAt": "2020-11-04T19:27:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU5NDIyMw==", "url": "https://github.com/apache/helix/pull/1500#discussion_r517594223", "bodyText": "I tried to make the change. But then realize it might be a non-backward compatible change.\nOverall, we only want to change the behavior IF the handler creating fails. But if we change like what @dasahcc mentioned, then the behavior is changed even if the handler creating logic will work fine. Given the send message interface is public, it is possible that the application configures -1 retry now.\nIn addition, the logic that uses this timeout before this PR is also executing the task before look at this value. So I think we can keep the same behavior here.", "author": "jiajunwang", "createdAt": "2020-11-04T19:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc3MzcxMw==", "url": "https://github.com/apache/helix/pull/1500#discussion_r517773713", "bodyText": "I think the basic reason is we reuse the same entry that used for transition fail timeout. We can keep the logic here but let's have a TODO for additional field, which may have the logic more clear for the new definition of the retry only before execution.", "author": "junkaixue", "createdAt": "2020-11-05T03:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjM2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg3MzIxNQ==", "url": "https://github.com/apache/helix/pull/1500#discussion_r517873215", "bodyText": "Sure, TODO might be overkill since I don't think we have a concrete plan yet. But let me comment more on this logic.", "author": "jiajunwang", "createdAt": "2020-11-05T08:35:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MjM2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2NzAzNA==", "url": "https://github.com/apache/helix/pull/1500#discussion_r517567034", "bodyText": "This changes the behavior. If the message is not exact state we are targeting, it should be a intermediate state, we should throw away this message instead of let it hanging there. Otherwise, we will face a lot of human involved operations.\nFor example, for the p2p arrived but timedout, the message will be discarded. But if you hang it as unprocessable, the partition will be stuck.", "author": "junkaixue", "createdAt": "2020-11-04T19:03:10Z", "path": "helix-core/src/main/java/org/apache/helix/messaging/handling/HelixTaskExecutor.java", "diffHunk": "@@ -993,67 +1034,78 @@ private boolean checkAndProcessNoOpMessage(Message message, String instanceName,\n    * Preprocess the state transition message to validate if the request is valid.\n    * If no operation needs to be triggered, discard the the message.\n    * @param message\n-   * @param instanceName\n    * @param manager\n    * @param stateTransitionHandlers\n    * @param createHandler\n    * @return True if the requested state transition is valid, and need to schedule the transition.\n    *         False if no more operation is required.\n    */\n-  private boolean validateAndProcessStateTransitionMessage(Message message, String instanceName,\n-      HelixManager manager, Map<String, MessageHandler> stateTransitionHandlers,\n-      MessageHandler createHandler) {\n-    HelixDataAccessor accessor = manager.getHelixDataAccessor();\n-\n+  private boolean validateAndProcessStateTransitionMessage(Message message, HelixManager manager,\n+      Map<String, MessageHandler> stateTransitionHandlers, MessageHandler createHandler) {\n     String messageTarget = getMessageTarget(message.getResourceName(), message.getPartitionName());\n-    if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n-        && isStateTransitionInProgress(messageTarget)) {\n-      String taskId = _messageTaskMap.get(messageTarget);\n-      Message msg = _taskMap.get(taskId).getTask().getMessage();\n-      // If there is another state transition for same partition is going on,\n-      // discard the message. Controller will resend if this is a valid message\n-      String errMsg = String.format(\n-          \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n-          message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n-          msg.isRelayMessage(), msg.getReadTimeStamp(), System.currentTimeMillis(),\n-          message.getFromState(), message.getToState());\n-      handleUnprocessableMessage(message, null /* exception */, errMsg, accessor, instanceName,\n-          manager);\n-      return false;\n-    }\n-    if (createHandler instanceof HelixStateTransitionHandler) {\n-      // We only check to state if there is no ST task scheduled/executing.\n-      HelixStateTransitionHandler.StaleMessageValidateResult result =\n-          ((HelixStateTransitionHandler) createHandler).staleMessageValidator();\n-      if (!result.isValid) {\n-        handleUnprocessableMessage(message, null /* exception */, result.exception.getMessage(),\n-            accessor, instanceName, manager);\n+\n+    try {\n+      if (message.getMsgType().equals(MessageType.STATE_TRANSITION.name())\n+          && isStateTransitionInProgress(messageTarget)) {\n+        String taskId = _messageTaskMap.get(messageTarget);\n+        Message msg = _taskMap.get(taskId).getTask().getMessage();\n+        // If there is another state transition for same partition is going on,\n+        // discard the message. Controller will resend if this is a valid message\n+        String errMsg = String.format(\n+            \"Another state transition for %s:%s is in progress with msg: %s, p2p: %s, read: %d, current:%d. Discarding %s->%s message\",\n+            message.getResourceName(), message.getPartitionName(), msg.getMsgId(),\n+            msg.isRelayMessage(), msg.getReadTimeStamp(), System.currentTimeMillis(),\n+            message.getFromState(), message.getToState());\n+        updateUnprocessableMessage(message, null /* exception */, errMsg, manager);", "originalCommit": "352d4408f4b72838ee62694df75031bc4f63c03b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4MTYwOA==", "url": "https://github.com/apache/helix/pull/1500#discussion_r517581608", "bodyText": "Please refer to what I reply to Meng earlier for the same code. The change I made just moves the remove logic a little bit for reusing the code. The messages will still be removed. Please check line 861.\nLet me know if you still think something missed here. I agree this is very critical, and I also want to ensure nothing changed here. So please help to double-check for me : )", "author": "jiajunwang", "createdAt": "2020-11-04T19:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2NzAzNA=="}], "type": "inlineReview"}, {"oid": "6304edd350159ab8573ac1661f336e134bcebf14", "url": "https://github.com/apache/helix/commit/6304edd350159ab8573ac1661f336e134bcebf14", "message": "Address final comment.", "committedDate": "2020-11-05T08:39:33Z", "type": "commit"}]}