{"pr_number": 1123, "pr_title": "Cleanup the persisted assignment state if no resource is on WAGED rebalancer.", "pr_createdAt": "2020-06-26T04:50:15Z", "pr_url": "https://github.com/apache/helix/pull/1123", "timeline": [{"oid": "461024d5bc97087da13541cfac701e8de6e8671a", "url": "https://github.com/apache/helix/commit/461024d5bc97087da13541cfac701e8de6e8671a", "message": "Cleanup the persisted assignment state if no resource is on WAGED rebalancer.\n\nThis is to prevent the WAGED rebalancer reads stale assignment records from the previous rebalance pipeline.\nFor example,\n1. Resource A was the only resource. And it is rebalanced by WAGED, then we have a persisted assignment for A.\n2. Resource A was reconfigured to using DelayedRebalancer, then we stop the WAGED rebalancer since there is no more resource using WAGED. So the persisted records are still in ZK.\n3. Resource A is recreated and using WAGED again. In this case, the previous persisted assignment is no longer valid. We should treat A as a brand new resource instead of considering the stale assignment record.\n\nMoreover, this change will help to clean up the ZK persisted data if no resource is using WAGED.", "committedDate": "2020-06-26T04:49:17Z", "type": "commit"}, {"oid": "0e04a577e219e665eeaad0aabdad45c92b7af7aa", "url": "https://github.com/apache/helix/commit/0e04a577e219e665eeaad0aabdad45c92b7af7aa", "message": "fix test case.", "committedDate": "2020-06-26T05:30:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMTI0NA==", "url": "https://github.com/apache/helix/pull/1123#discussion_r446001244", "bodyText": "No need to execute following removes ops? Just return the empty list?", "author": "huizhilu", "createdAt": "2020-06-26T06:55:03Z", "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/waged/TestAssignmentMetadataStore.java", "diffHunk": "@@ -172,13 +197,17 @@ public void testAssignmentCache() {\n \n   /**\n    * Returns a list of existing version numbers only.\n+   *\n    * @param metadataType\n    * @return\n    */\n   private List<String> getExistingVersionNumbers(String metadataType) {\n     List<String> children = _baseAccessor\n         .getChildNames(\"/\" + CLUSTER_NAME + \"/ASSIGNMENT_METADATA/\" + metadataType,\n             AccessOption.PERSISTENT);\n+    if (children == null) {\n+      children = Collections.EMPTY_LIST;", "originalCommit": "0e04a577e219e665eeaad0aabdad45c92b7af7aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwNTU4Mw==", "url": "https://github.com/apache/helix/pull/1123#discussion_r446005583", "bodyText": "It doesn't hurt. What if we want to add something to the list in the future? This is test, so I would like to reduce the code branch as much as possible. The only cost is a little bit more computing. But it is a test.", "author": "jiajunwang", "createdAt": "2020-06-26T07:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMTI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMTcxOQ==", "url": "https://github.com/apache/helix/pull/1123#discussion_r446001719", "bodyText": "Nit, Assert.assertTrue(_store.getBaseline().isEmpty());? Or is it because _store.getBaseline() may return null?", "author": "huizhilu", "createdAt": "2020-06-26T06:56:15Z", "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/waged/TestAssignmentMetadataStore.java", "diffHunk": "@@ -107,55 +84,103 @@ public void afterClass() {\n    */\n   @Test\n   public void testReadEmptyBaseline() {\n-    Map<String, ResourceAssignment> baseline = _store.getBaseline();\n-    Assert.assertTrue(baseline.isEmpty());\n+    // This should be the first test. Assert there is no record in ZK.\n+    // Check that only one version exists\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 0);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 0);\n+    // Read from cache and the result is empty.\n+    Assert.assertTrue(_store.getBaseline().isEmpty());\n+    Assert.assertTrue(_store.getBestPossibleAssignment().isEmpty());\n   }\n \n   /**\n    * Test that if the old assignment and new assignment are the same,\n    */\n   @Test(dependsOnMethods = \"testReadEmptyBaseline\")\n   public void testAvoidingRedundantWrite() {\n-    String baselineKey = \"BASELINE\";\n-    String bestPossibleKey = \"BEST_POSSIBLE\";\n-\n     Map<String, ResourceAssignment> dummyAssignment = getDummyAssignment();\n \n     // Call persist functions\n     _store.persistBaseline(dummyAssignment);\n     _store.persistBestPossibleAssignment(dummyAssignment);\n \n     // Check that only one version exists\n-    List<String> baselineVersions = getExistingVersionNumbers(baselineKey);\n-    List<String> bestPossibleVersions = getExistingVersionNumbers(bestPossibleKey);\n-    Assert.assertEquals(baselineVersions.size(), 1);\n-    Assert.assertEquals(bestPossibleVersions.size(), 1);\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 1);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 1);\n \n     // Call persist functions again\n     _store.persistBaseline(dummyAssignment);\n     _store.persistBestPossibleAssignment(dummyAssignment);\n \n     // Check that only one version exists still\n-    baselineVersions = getExistingVersionNumbers(baselineKey);\n-    bestPossibleVersions = getExistingVersionNumbers(bestPossibleKey);\n-    Assert.assertEquals(baselineVersions.size(), 1);\n-    Assert.assertEquals(bestPossibleVersions.size(), 1);\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 1);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 1);\n   }\n \n-  @Test\n+  @Test(dependsOnMethods = \"testAvoidingRedundantWrite\")\n   public void testAssignmentCache() {\n     Map<String, ResourceAssignment> dummyAssignment = getDummyAssignment();\n     // Call persist functions\n     _store.persistBaseline(dummyAssignment);\n     _store.persistBestPossibleAssignment(dummyAssignment);\n \n+    // Check that only one version exists\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 1);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 1);\n+\n+    // Same data in cache\n     Assert.assertEquals(_store._bestPossibleAssignment, dummyAssignment);\n     Assert.assertEquals(_store._globalBaseline, dummyAssignment);\n \n+    dummyAssignment.values().stream().forEach(assignment -> {\n+      assignment.addReplicaMap(new Partition(\"foo\"), Collections.emptyMap());\n+    });\n+\n+    // Call persist functions\n+    _store.persistBaseline(dummyAssignment);\n+    _store.persistBestPossibleAssignment(dummyAssignment);\n+\n+    // Check that two versions exist\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 2);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 2);\n+\n+    // Same data in cache\n+    Assert.assertEquals(_store._bestPossibleAssignment, dummyAssignment);\n+    Assert.assertEquals(_store._globalBaseline, dummyAssignment);\n+\n+    // Clear cache\n     _store.reset();\n \n     Assert.assertEquals(_store._bestPossibleAssignment, null);\n     Assert.assertEquals(_store._globalBaseline, null);\n+\n+    // Check the persisted data is not changed.\n+    Assert.assertEquals(getExistingVersionNumbers(BASELINE_KEY).size(), 2);\n+    Assert.assertEquals(getExistingVersionNumbers(BEST_POSSIBLE_KEY).size(), 2);\n+  }\n+\n+  @Test(dependsOnMethods = \"testAssignmentCache\")\n+  void testClearAssignment() {\n+    // Check the persisted data is not empty\n+    List<String> baselineVersions = getExistingVersionNumbers(BASELINE_KEY);\n+    List<String> bestPossibleVersions = getExistingVersionNumbers(BEST_POSSIBLE_KEY);\n+    int baselineVersionCount = baselineVersions.size();\n+    int bestPossibleVersionCount = bestPossibleVersions.size();\n+    Assert.assertTrue(baselineVersionCount > 0);\n+    Assert.assertTrue(bestPossibleVersionCount > 0);\n+\n+    _store.clearAssignmentMetadata();\n+\n+    // 1. cache is cleaned up\n+    Assert.assertEquals(_store._bestPossibleAssignment, Collections.emptyMap());\n+    Assert.assertEquals(_store._globalBaseline, Collections.emptyMap());\n+    // 2. refresh the cache and then read from ZK again to ensure the persisted assignments is empty\n+    _store.reset();\n+    Assert.assertEquals(_store.getBaseline(), Collections.emptyMap());", "originalCommit": "0e04a577e219e665eeaad0aabdad45c92b7af7aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwNDkxNA==", "url": "https://github.com/apache/helix/pull/1123#discussion_r446004914", "bodyText": "No difference. Same thing.", "author": "jiajunwang", "createdAt": "2020-06-26T07:04:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMTcxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMjU4NA==", "url": "https://github.com/apache/helix/pull/1123#discussion_r446002584", "bodyText": "How about removing the whole cluster deleteRecursively(\"/CLUSTER_NAME\")?", "author": "huizhilu", "createdAt": "2020-06-26T06:58:37Z", "path": "helix-core/src/test/java/org/apache/helix/controller/rebalancer/waged/TestAssignmentMetadataStore.java", "diffHunk": "@@ -28,74 +29,50 @@\n import org.apache.helix.HelixManagerFactory;\n import org.apache.helix.InstanceType;\n import org.apache.helix.common.ZkTestBase;\n-import org.apache.helix.integration.manager.ClusterControllerManager;\n-import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.manager.zk.ZkBucketDataAccessor;\n import org.apache.helix.model.Partition;\n import org.apache.helix.model.ResourceAssignment;\n import org.testng.Assert;\n import org.testng.annotations.AfterClass;\n import org.testng.annotations.BeforeClass;\n import org.testng.annotations.Test;\n \n-\n public class TestAssignmentMetadataStore extends ZkTestBase {\n-  protected static final int NODE_NR = 5;\n-  protected static final int START_PORT = 12918;\n-  protected static final String STATE_MODEL = \"MasterSlave\";\n-  protected static final String TEST_DB = \"TestDB\";\n-  protected static final int _PARTITIONS = 20;\n+  private static final int DEFAULT_BUCKET_SIZE = 50 * 1024; // 50KB\n+  private static final String BASELINE_KEY = \"BASELINE\";\n+  private static final String BEST_POSSIBLE_KEY = \"BEST_POSSIBLE\";\n \n+  protected static final String TEST_DB = \"TestDB\";\n   protected HelixManager _manager;\n   protected final String CLASS_NAME = getShortClassName();\n   protected final String CLUSTER_NAME = CLUSTER_PREFIX + \"_\" + CLASS_NAME;\n \n-  protected MockParticipantManager[] _participants = new MockParticipantManager[NODE_NR];\n-  protected ClusterControllerManager _controller;\n-  protected int _replica = 3;\n-\n   private AssignmentMetadataStore _store;\n \n   @BeforeClass\n-  public void beforeClass()\n-      throws Exception {\n+  public void beforeClass() throws Exception {\n     super.beforeClass();\n \n     // setup storage cluster\n     _gSetupTool.addCluster(CLUSTER_NAME, true);\n-    _gSetupTool.addResourceToCluster(CLUSTER_NAME, TEST_DB, _PARTITIONS, STATE_MODEL);\n-    for (int i = 0; i < NODE_NR; i++) {\n-      String storageNodeName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n-      _gSetupTool.addInstanceToCluster(CLUSTER_NAME, storageNodeName);\n-    }\n-    _gSetupTool.rebalanceStorageCluster(CLUSTER_NAME, TEST_DB, _replica);\n-\n-    // start dummy participants\n-    for (int i = 0; i < NODE_NR; i++) {\n-      String instanceName = PARTICIPANT_PREFIX + \"_\" + (START_PORT + i);\n-      _participants[i] = new MockParticipantManager(ZK_ADDR, CLUSTER_NAME, instanceName);\n-      _participants[i].syncStart();\n-    }\n-\n-    // start controller\n-    String controllerName = CONTROLLER_PREFIX + \"_0\";\n-    _controller = new ClusterControllerManager(ZK_ADDR, CLUSTER_NAME, controllerName);\n-    _controller.syncStart();\n \n     // create cluster manager\n     _manager = HelixManagerFactory\n         .getZKHelixManager(CLUSTER_NAME, \"Admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n     _manager.connect();\n \n-    // create AssignmentMetadataStore\n-    _store = new AssignmentMetadataStore(_manager.getMetadataStoreConnectionString(),\n-        _manager.getClusterName());\n+    // Create AssignmentMetadataStore. No version clean up to ensure the test result is stable.\n+    _store = new AssignmentMetadataStore(\n+        new ZkBucketDataAccessor(_manager.getMetadataStoreConnectionString(), DEFAULT_BUCKET_SIZE,\n+            Integer.MAX_VALUE), _manager.getClusterName());\n   }\n \n   @AfterClass\n   public void afterClass() {\n     if (_store != null) {\n       _store.close();\n     }\n+    _baseAccessor.remove(\"/\" + CLUSTER_NAME + \"/ASSIGNMENT_METADATA\", AccessOption.PERSISTENT);", "originalCommit": "0e04a577e219e665eeaad0aabdad45c92b7af7aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwNDcyNg==", "url": "https://github.com/apache/helix/pull/1123#discussion_r446004726", "bodyText": "Yeah, I think we can just remove the cluster.", "author": "jiajunwang", "createdAt": "2020-06-26T07:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMjU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMzc3Mg==", "url": "https://github.com/apache/helix/pull/1123#discussion_r446003772", "bodyText": "New elements need to add to this empty map?", "author": "huizhilu", "createdAt": "2020-06-26T07:01:41Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/AssignmentMetadataStore.java", "diffHunk": "@@ -70,7 +70,7 @@ protected AssignmentMetadataStore(BucketDataAccessor bucketDataAccessor, String\n         _globalBaseline = splitAssignments(baseline);\n       } catch (ZkNoNodeException ex) {\n         // Metadata does not exist, so return an empty map\n-        _globalBaseline = Collections.emptyMap();\n+        _globalBaseline = new HashMap<>();", "originalCommit": "0e04a577e219e665eeaad0aabdad45c92b7af7aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwNDM1Nw==", "url": "https://github.com/apache/helix/pull/1123#discussion_r446004357", "bodyText": "Yes", "author": "jiajunwang", "createdAt": "2020-06-26T07:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwMzc3Mg=="}], "type": "inlineReview"}, {"oid": "1e11aa5b4c6077268898310161faedecde189cd0", "url": "https://github.com/apache/helix/commit/1e11aa5b4c6077268898310161faedecde189cd0", "message": "Address comment.", "committedDate": "2020-06-26T07:08:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMzk1MQ==", "url": "https://github.com/apache/helix/pull/1123#discussion_r447913951", "bodyText": "This change is non-essential, right?", "author": "kaisun2000", "createdAt": "2020-06-30T19:01:59Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/AssignmentMetadataStore.java", "diffHunk": "@@ -70,7 +70,7 @@ protected AssignmentMetadataStore(BucketDataAccessor bucketDataAccessor, String\n         _globalBaseline = splitAssignments(baseline);\n       } catch (ZkNoNodeException ex) {\n         // Metadata does not exist, so return an empty map\n-        _globalBaseline = Collections.emptyMap();\n+        _globalBaseline = new HashMap<>();", "originalCommit": "1e11aa5b4c6077268898310161faedecde189cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkzMjI5MQ==", "url": "https://github.com/apache/helix/pull/1123#discussion_r447932291", "bodyText": "It is. In this PR, I changed the logic so the map will be kept. It needs to be modifiable.\nAnother option is to introduce more logic to handle the corner cases, which I don't prefer.", "author": "jiajunwang", "createdAt": "2020-06-30T19:36:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkxMzk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMjk5NQ==", "url": "https://github.com/apache/helix/pull/1123#discussion_r447922995", "bodyText": "What is going to catch this one?", "author": "kaisun2000", "createdAt": "2020-06-30T19:19:13Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/waged/AssignmentMetadataStore.java", "diffHunk": "@@ -95,53 +95,56 @@ protected AssignmentMetadataStore(BucketDataAccessor bucketDataAccessor, String\n    * @return true if a new baseline was persisted.\n    * @throws HelixException if the method failed to persist the baseline.\n    */\n-  // TODO: Enhance the return value so it is more intuitive to understand when the persist fails and\n-  // TODO: when it is skipped.\n   public synchronized boolean persistBaseline(Map<String, ResourceAssignment> globalBaseline) {\n-    // TODO: Make the write async?\n-    // If baseline hasn't changed, skip writing to metadata store\n-    if (compareAssignments(_globalBaseline, globalBaseline)) {\n-      return false;\n-    }\n-    // Persist to ZK\n-    HelixProperty combinedAssignments = combineAssignments(BASELINE_KEY, globalBaseline);\n-    try {\n-      _dataAccessor.compressedBucketWrite(_baselinePath, combinedAssignments);\n-    } catch (IOException e) {\n-      // TODO: Improve failure handling\n-      throw new HelixException(\"Failed to persist baseline!\", e);\n-    }\n-\n-    // Update the in-memory reference\n-    _globalBaseline = globalBaseline;\n-    return true;\n+    return persistAssignment(globalBaseline, getBaseline(), _baselinePath, BASELINE_KEY);\n   }\n \n   /**\n    * @return true if a new best possible assignment was persisted.\n    * @throws HelixException if the method failed to persist the baseline.\n    */\n-  // TODO: Enhance the return value so it is more intuitive to understand when the persist fails and\n-  // TODO: when it is skipped.\n   public synchronized boolean persistBestPossibleAssignment(\n       Map<String, ResourceAssignment> bestPossibleAssignment) {\n+    return persistAssignment(bestPossibleAssignment, getBestPossibleAssignment(), _bestPossiblePath,\n+        BEST_POSSIBLE_KEY);\n+  }\n+\n+  public synchronized void clearAssignmentMetadata() {\n+    persistAssignment(Collections.emptyMap(), getBaseline(), _baselinePath, BASELINE_KEY);\n+    persistAssignment(Collections.emptyMap(), getBestPossibleAssignment(), _bestPossiblePath,\n+        BEST_POSSIBLE_KEY);\n+  }\n+\n+  /**\n+   * @param newAssignment\n+   * @param cachedAssignment\n+   * @param path the path of the assignment record\n+   * @param key  the key of the assignment in the record\n+   * @return true if a new assignment was persisted.\n+   */\n+  // TODO: Enhance the return value so it is more intuitive to understand when the persist fails and\n+  // TODO: when it is skipped.\n+  private boolean persistAssignment(Map<String, ResourceAssignment> newAssignment,\n+      Map<String, ResourceAssignment> cachedAssignment, String path,\n+      String key) {\n     // TODO: Make the write async?\n-    // If bestPossibleAssignment hasn't changed, skip writing to metadata store\n-    if (compareAssignments(_bestPossibleAssignment, bestPossibleAssignment)) {\n+    // If the assignment hasn't changed, skip writing to metadata store\n+    if (compareAssignments(cachedAssignment, newAssignment)) {\n       return false;\n     }\n     // Persist to ZK\n-    HelixProperty combinedAssignments =\n-        combineAssignments(BEST_POSSIBLE_KEY, bestPossibleAssignment);\n+    HelixProperty combinedAssignments = combineAssignments(key, newAssignment);\n     try {\n-      _dataAccessor.compressedBucketWrite(_bestPossiblePath, combinedAssignments);\n+      _dataAccessor.compressedBucketWrite(path, combinedAssignments);\n     } catch (IOException e) {\n       // TODO: Improve failure handling\n-      throw new HelixException(\"Failed to persist BestPossibleAssignment!\", e);\n+      throw new HelixException(", "originalCommit": "1e11aa5b4c6077268898310161faedecde189cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkzMjQwNQ==", "url": "https://github.com/apache/helix/pull/1123#discussion_r447932405", "bodyText": "The rebalancer will catch it and wrap with rebalancer failure exceptions and add the failure type accordingly.", "author": "jiajunwang", "createdAt": "2020-06-30T19:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMjk5NQ=="}], "type": "inlineReview"}]}