{"pr_number": 1307, "pr_title": "Add TrieClusterTopology for retrieving hierarchical topology", "pr_createdAt": "2020-08-24T17:52:05Z", "pr_url": "https://github.com/apache/helix/pull/1307", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2Mjg1MQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r476662851", "bodyText": "Thanks for the detailed reply.\nI think the previous 3 points can be achieved by adding a flag to Topology::ClusterTopologyConfig and maybe using non static 'DEFAULT_DOMAIN_PREFIX'. Just like how we accommodate the 'faultZone' compute in this class.\nFor the point 4,\nMaybe we could read the tree and bypass default node (or throw exception when we find a default node in the path)\nIn my own opinion, I think the final question would be, do we construct topology tree in class Topology for these instances? If yes, its better to read from the same tree. If not, I think it's ok to have another orthogonal data structure representing the hierarchy.", "author": "xyuanlu", "createdAt": "2020-08-25T18:45:55Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \"_\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/instance will return [\"group\", \"zone\", \"rack\", \"instance\"].\n+    _topologyKeys = Arrays.asList(clusterConfig.getTopology().trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    _rootNode = new TrieNode(new HashMap<>(), DELIMITER);\n+    constructTrie(instanceConfigMap);\n+  }\n+\n+  /**\n+   * Return the topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a set of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/instance, the result may be {\n+   * [\"group_0\": {\"zone_0/rack_0/instance_0\", \"zone_1/rack_1/instance_1\"}], [\"group_1\": {\"zone_1\n+   * /rack_1/instance_1\", \"zone_1/rack_1/instance_2\"}]}\n+   */\n+  public Map<String, Set<String>> getClusterTopology() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a set of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"rack_0\": {\"instance_0\", \"instance_1\"},\n+   * [\"rack_1\": {\"instance_2\", \"instance_3\"}]}\n+   */\n+  public Map<String, Set<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, Set<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      String key = child.getKey();\n+      results.put(key,\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath() + DELIMITER));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(_topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", _topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(_topologyKeys[i], domain.get(_topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private Set<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    Set<String> results = new HashSet<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _rootNode;\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    Set<String> toRemoveConfig = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+      if (domainAsMap.isEmpty()) {\n+        logger.info(String.format(\"Domain for instance %s is not set\", instanceName));\n+        toRemoveConfig.add(instanceName);\n+      } else {\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\",\n+                domainAsMap.get(key), instanceName));\n+            toRemoveConfig.add(instanceName);\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    toRemoveConfig.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private void constructTrie(Map<String, InstanceConfig> instanceConfigMap) {\n+    removeInvalidInstanceConfig(instanceConfigMap);\n+    Map<String, Map<String, String>> instanceDomainsMap = new HashMap<>();\n+    instanceConfigMap.entrySet().forEach(\n+        entry -> instanceDomainsMap.put(entry.getKey(), entry.getValue().getDomainAsMap()));\n+\n+    for (Map.Entry<String, Map<String, String>> entry : instanceDomainsMap.entrySet()) {\n+      TrieNode curNode = _rootNode;\n+      String path = \"\";\n+      for (int i = 0; i < _topologyKeys.length; i++) {\n+        String key = _topologyKeys[i] + CONNECTOR + entry.getValue().get(_topologyKeys[i]);", "originalCommit": "3d93799208a5117168735d53f5c94f62ccd6e810", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzNDgzNg==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490534836", "bodyText": "There're some offline discussion, and the conclusion is that trie is a good fit for cluster topology, as also mentioned here: #447\nand should apply to both rebalance and user facing APIs, meaning that we only need one class for both uses.\nIn this PR, we will create a generic trie structure with validation and construction logic. Topology APIs will use this structure and do whatever traverse needed. Laster, topology logic will also use this trie structure and implement the functions it need. The new trie structure is not fundamentally different from the tree in topology now, but with a clearer organization/validation logic and present in a more generic way. topology should be able to use it, if something mismatch, we can always come back to adjust the structure.", "author": "zhangmeng916", "createdAt": "2020-09-17T20:14:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY2Mjg1MQ=="}], "type": "inlineReview"}, {"oid": "0c9b7b12e03cad3aad66cb98c1cbdbcf0e82c8fd", "url": "https://github.com/apache/helix/commit/0c9b7b12e03cad3aad66cb98c1cbdbcf0e82c8fd", "message": "add TrieClusterTopology", "committedDate": "2020-08-28T00:13:55Z", "type": "forcePushed"}, {"oid": "7f7b3a14f9b7af0184f8f5298e10d051734fedaf", "url": "https://github.com/apache/helix/commit/7f7b3a14f9b7af0184f8f5298e10d051734fedaf", "message": "Merge branch 'topology'", "committedDate": "2020-08-31T23:59:08Z", "type": "forcePushed"}, {"oid": "8e4822c59e373c9ce170880022df38b32fd07a47", "url": "https://github.com/apache/helix/commit/8e4822c59e373c9ce170880022df38b32fd07a47", "message": "Add more APIs", "committedDate": "2020-09-01T00:01:45Z", "type": "forcePushed"}, {"oid": "7e73114f7c91ae0cc63e29de4739b80648933b2b", "url": "https://github.com/apache/helix/commit/7e73114f7c91ae0cc63e29de4739b80648933b2b", "message": "add more APIs", "committedDate": "2020-09-01T00:04:37Z", "type": "forcePushed"}, {"oid": "d6c019306e0c040e9e3d844d87053fb8841b1eeb", "url": "https://github.com/apache/helix/commit/d6c019306e0c040e9e3d844d87053fb8841b1eeb", "message": "add more APIs", "committedDate": "2020-09-02T17:29:16Z", "type": "forcePushed"}, {"oid": "ed21c95682a73da4afa115403d56bd44ce5c9145", "url": "https://github.com/apache/helix/commit/ed21c95682a73da4afa115403d56bd44ce5c9145", "message": "add Helix admin API", "committedDate": "2020-09-08T16:41:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYzODk1Mw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r476638953", "bodyText": "Shall we make some marks of leaf nodes? Then leaf nodes contains a list of instance names or something. Otherwise, it may not be very efficient for most of cases.", "author": "junkaixue", "createdAt": "2020-08-25T18:02:14Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \"_\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/instance will return [\"group\", \"zone\", \"rack\", \"instance\"].\n+    _topologyKeys = Arrays.asList(clusterConfig.getTopology().trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    _rootNode = new TrieNode(new HashMap<>(), DELIMITER);\n+    constructTrie(instanceConfigMap);\n+  }\n+\n+  /**\n+   * Return the topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a set of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/instance, the result may be {\n+   * [\"group_0\": {\"zone_0/rack_0/instance_0\", \"zone_1/rack_1/instance_1\"}], [\"group_1\": {\"zone_1\n+   * /rack_1/instance_1\", \"zone_1/rack_1/instance_2\"}]}\n+   */\n+  public Map<String, Set<String>> getClusterTopology() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a set of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"rack_0\": {\"instance_0\", \"instance_1\"},\n+   * [\"rack_1\": {\"instance_2\", \"instance_3\"}]}\n+   */\n+  public Map<String, Set<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, Set<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      String key = child.getKey();\n+      results.put(key,\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath() + DELIMITER));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(_topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", _topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(_topologyKeys[i], domain.get(_topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private Set<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    Set<String> results = new HashSet<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _rootNode;\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    Set<String> toRemoveConfig = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+      if (domainAsMap.isEmpty()) {\n+        logger.info(String.format(\"Domain for instance %s is not set\", instanceName));\n+        toRemoveConfig.add(instanceName);\n+      } else {\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\",\n+                domainAsMap.get(key), instanceName));\n+            toRemoveConfig.add(instanceName);\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    toRemoveConfig.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private void constructTrie(Map<String, InstanceConfig> instanceConfigMap) {\n+    removeInvalidInstanceConfig(instanceConfigMap);\n+    Map<String, Map<String, String>> instanceDomainsMap = new HashMap<>();\n+    instanceConfigMap.entrySet().forEach(\n+        entry -> instanceDomainsMap.put(entry.getKey(), entry.getValue().getDomainAsMap()));\n+\n+    for (Map.Entry<String, Map<String, String>> entry : instanceDomainsMap.entrySet()) {\n+      TrieNode curNode = _rootNode;\n+      String path = \"\";\n+      for (int i = 0; i < _topologyKeys.length; i++) {\n+        String key = _topologyKeys[i] + CONNECTOR + entry.getValue().get(_topologyKeys[i]);\n+        path = path + DELIMITER + key;\n+        TrieNode nextNode = curNode.getChildren().get(key);\n+        if (nextNode == null) {\n+          nextNode = new TrieNode(new HashMap<>(), path);\n+        }\n+        curNode.addChild(key, nextNode);\n+        curNode = nextNode;\n+      }\n+    }\n+  }\n+\n+  private static class TrieNode {\n+    // A mapping between trie key and children nodes.\n+    private Map<String, TrieNode> _children;\n+\n+    // the complete path/prefix leading to the current node.\n+    private final String _path;", "originalCommit": "3d93799208a5117168735d53f5c94f62ccd6e810", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE5MDkxNQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r485190915", "bodyText": "This API is for the common case where instances are returned for the fault zone type:\npublic Map<String, List> getInstancesUnderFaultZone() {\nreturn getTopologyUnderDomainType(_faultZoneType);\n}\nThe name of the instance is implicitly embedded in the path field of the Trie node. e.g. the path could be like zone:myzone0/instance:myinstance0, so 'myinstance0' is the instance name.\nI didn't see the necessity of marking leaf nodes. Do you think it'll save time in querying? Because we always need to traverse to the leaves anyway.", "author": "zhangmeng916", "createdAt": "2020-09-08T20:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYzODk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjYzOTYzMQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r476639631", "bodyText": "If cluster config does not have topology, we should throw exception or give an empty return.", "author": "junkaixue", "createdAt": "2020-08-25T18:03:30Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \"_\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/instance will return [\"group\", \"zone\", \"rack\", \"instance\"].\n+    _topologyKeys = Arrays.asList(clusterConfig.getTopology().trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);", "originalCommit": "3d93799208a5117168735d53f5c94f62ccd6e810", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0MTA4Mg==", "url": "https://github.com/apache/helix/pull/1307#discussion_r476641082", "bodyText": "Is this only for testing? The input is an empty map..", "author": "junkaixue", "createdAt": "2020-08-25T18:06:05Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,244 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \"_\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/instance will return [\"group\", \"zone\", \"rack\", \"instance\"].\n+    _topologyKeys = Arrays.asList(clusterConfig.getTopology().trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    _rootNode = new TrieNode(new HashMap<>(), DELIMITER);\n+    constructTrie(instanceConfigMap);\n+  }\n+\n+  /**\n+   * Return the topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a set of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/instance, the result may be {\n+   * [\"group_0\": {\"zone_0/rack_0/instance_0\", \"zone_1/rack_1/instance_1\"}], [\"group_1\": {\"zone_1\n+   * /rack_1/instance_1\", \"zone_1/rack_1/instance_2\"}]}\n+   */\n+  public Map<String, Set<String>> getClusterTopology() {", "originalCommit": "3d93799208a5117168735d53f5c94f62ccd6e810", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MDA3Mg==", "url": "https://github.com/apache/helix/pull/1307#discussion_r485180072", "bodyText": "This is the API by default gets the full topology of the cluster. The key of the map will be the first level of domain defined in topology, e.g. zone, faultdomain, etc.", "author": "zhangmeng916", "createdAt": "2020-09-08T20:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjY0MTA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjAwMTU3NA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r486001574", "bodyText": "I think adding 5 new methods to HelixAdmin is overkill. Can we just add a method that returns the ClusterTopology and then relies on the ClusterTopology class methods to return information?", "author": "jiajunwang", "createdAt": "2020-09-10T00:59:38Z", "path": "helix-core/src/main/java/org/apache/helix/HelixAdmin.java", "diffHunk": "@@ -420,6 +420,41 @@ void addStateModelDef(String clusterName, String stateModelDef, StateModelDefini\n    */\n   void removeCloudConfig(String clusterName);\n \n+  /**\n+   * Get the topology of a specific cluster\n+   * @param clusterName\n+   */\n+  Map<String, List<String>> getClusterTopology(String clusterName);", "originalCommit": "4381a247f4967b2a2534bcca6e0cebf87803ca68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2NDg2NQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r486064865", "bodyText": "How are the callers supposed to know which instance has been removed because the configuration is invalid?\nIn addition, the removal is directly modifying the input map. So it could dangerous since it may change the caller's map implicitly.", "author": "jiajunwang", "createdAt": "2020-09-10T05:02:52Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \":\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+  private final String _faultZoneType;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (_topologyKeys.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = new TrieNode(new HashMap<>(), \"\", \"ROOT\");\n+    constructTrie(instanceConfigMap);\n+  }\n+\n+  /**\n+   * Return the topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getClusterTopology() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    if (domainType.equals(_topologyKeys[0])) {\n+      return getClusterTopology();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < _topologyKeys.length; i++) {\n+      if (_topologyKeys[i].equals(domainType)) {\n+        parentDomainType = _topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the end nodes under fault zone type. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getInstancesUnderFaultZone() {\n+    return getTopologyUnderDomainType(_faultZoneType);\n+  }\n+\n+  private Map<String, String> convertPathToDomain(String path) {\n+    Map<String, String> results = new HashMap<>();\n+    for (String part : path.substring(1).split(DELIMITER)) {\n+      results.put(part.substring(0, part.indexOf(CONNECTOR)),\n+          part.substring(part.indexOf(CONNECTOR) + 1));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(_topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", _topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(_topologyKeys[i], domain.get(_topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _rootNode;\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private List<TrieNode> getStartNodes(String domain) {\n+    List<TrieNode> results = new ArrayList<>();\n+    TrieNode curNode = _rootNode;\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode.getDomainType().equals(domain)) {\n+        results.add(curNode);\n+      } else {\n+        for (TrieNode child : curNode.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return results;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    Set<String> toRemoveConfig = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+      if (domainAsMap.isEmpty()) {\n+        logger.info(String.format(\"Domain for instance %s is not set\", instanceName));\n+        toRemoveConfig.add(instanceName);\n+      } else {\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            toRemoveConfig.add(instanceName);\n+            break;\n+          }\n+        }\n+      }\n+    }\n+    toRemoveConfig.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private void constructTrie(Map<String, InstanceConfig> instanceConfigMap) {\n+    removeInvalidInstanceConfig(instanceConfigMap);", "originalCommit": "4381a247f4967b2a2534bcca6e0cebf87803ca68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMxMzQxNw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r488313417", "bodyText": "Please see the updated PR. I add an invalid config list that customers can retrieve.", "author": "zhangmeng916", "createdAt": "2020-09-15T00:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2NDg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2NjgwNg==", "url": "https://github.com/apache/helix/pull/1307#discussion_r486066806", "bodyText": "nit, this check is not necessary. The else condition will ensure an instance with an empty list to be removed.", "author": "jiajunwang", "createdAt": "2020-09-10T05:07:07Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \":\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+  private final String _faultZoneType;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (_topologyKeys.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = new TrieNode(new HashMap<>(), \"\", \"ROOT\");\n+    constructTrie(instanceConfigMap);\n+  }\n+\n+  /**\n+   * Return the topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getClusterTopology() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    if (domainType.equals(_topologyKeys[0])) {\n+      return getClusterTopology();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < _topologyKeys.length; i++) {\n+      if (_topologyKeys[i].equals(domainType)) {\n+        parentDomainType = _topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the end nodes under fault zone type. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getInstancesUnderFaultZone() {\n+    return getTopologyUnderDomainType(_faultZoneType);\n+  }\n+\n+  private Map<String, String> convertPathToDomain(String path) {\n+    Map<String, String> results = new HashMap<>();\n+    for (String part : path.substring(1).split(DELIMITER)) {\n+      results.put(part.substring(0, part.indexOf(CONNECTOR)),\n+          part.substring(part.indexOf(CONNECTOR) + 1));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(_topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", _topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(_topologyKeys[i], domain.get(_topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _rootNode;\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private List<TrieNode> getStartNodes(String domain) {\n+    List<TrieNode> results = new ArrayList<>();\n+    TrieNode curNode = _rootNode;\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode.getDomainType().equals(domain)) {\n+        results.add(curNode);\n+      } else {\n+        for (TrieNode child : curNode.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return results;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    Set<String> toRemoveConfig = new HashSet<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+      if (domainAsMap.isEmpty()) {", "originalCommit": "4381a247f4967b2a2534bcca6e0cebf87803ca68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3OTg2Nw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r486079867", "bodyText": "What if topology awareness is disabled on this cluster? Shall we still throw Exception?", "author": "jiajunwang", "createdAt": "2020-09-10T05:47:26Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \":\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+  private final String _faultZoneType;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+\n+    String topologyDef = clusterConfig.getTopology();", "originalCommit": "4381a247f4967b2a2534bcca6e0cebf87803ca68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMxMzIyNA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r488313224", "bodyText": "Please refer to the updated PR. We do not need to topology awareness to be enabled for API purpose.", "author": "zhangmeng916", "createdAt": "2020-09-15T00:37:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3OTg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4MDQ4OA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r486080488", "bodyText": "I think we are not requiring such strict formatting elsewhere. For example, spaces are ignored.\nSo maybe you should also trim here so as to ensure the logic is consistent.", "author": "jiajunwang", "createdAt": "2020-09-10T05:49:16Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \":\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+  private final String _faultZoneType;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);", "originalCommit": "4381a247f4967b2a2534bcca6e0cebf87803ca68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3ODMzMQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r489578331", "bodyText": "I trim the topologyDef, do you mean I need to trim something else?", "author": "zhangmeng916", "createdAt": "2020-09-16T16:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4MDQ4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0OTYzOQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493049639", "bodyText": "Commented in your new code. Let me resolve this one.", "author": "jiajunwang", "createdAt": "2020-09-22T21:40:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4MDQ4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4MDkxNg==", "url": "https://github.com/apache/helix/pull/1307#discussion_r486080916", "bodyText": "Can we let constructTrie() return a root which is constructed by the private method internally?\nThis helps to simplify the code a little bit.", "author": "jiajunwang", "createdAt": "2020-09-10T05:50:27Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieClusterTopology.java", "diffHunk": "@@ -0,0 +1,340 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class TrieClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(TrieClusterTopology.class);\n+  private static final String DELIMITER = \"/\";\n+  private static final String CONNECTOR = \":\";\n+\n+  private final TrieNode _rootNode;\n+  private final String[] _topologyKeys;\n+  private final String _faultZoneType;\n+\n+  public TrieClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes : liveNodes.removeAll(instanceConfigMap.keySet())));\n+    }\n+\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (_topologyKeys.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = new TrieNode(new HashMap<>(), \"\", \"ROOT\");", "originalCommit": "4381a247f4967b2a2534bcca6e0cebf87803ca68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bcd932ecc85cddffbaf63c6aeb287f6350413cad", "url": "https://github.com/apache/helix/commit/bcd932ecc85cddffbaf63c6aeb287f6350413cad", "message": "refactor", "committedDate": "2020-09-15T00:41:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NTg2Mg==", "url": "https://github.com/apache/helix/pull/1307#discussion_r488395862", "bodyText": "Didn't we agree to add one method that returns ClusterTopology object here?", "author": "jiajunwang", "createdAt": "2020-09-15T05:33:34Z", "path": "helix-core/src/main/java/org/apache/helix/HelixAdmin.java", "diffHunk": "@@ -420,6 +420,24 @@ void addStateModelDef(String clusterName, String stateModelDef, StateModelDefini\n    */\n   void removeCloudConfig(String clusterName);\n \n+  /**\n+   * Get the topology of a specific cluster\n+   * @param clusterName\n+   */\n+  Map<String, List<String>> getAllTopology(String clusterName);\n+\n+  /**\n+   * Get all the instances under the fault zone\n+   * @param clusterName\n+   */\n+  Map<String, List<String>> getInstancesUnderFaultZone(String clusterName);\n+\n+  /**\n+   * Get all the instances whose domain config is not valid\n+   * @param clusterName\n+   */\n+  List<String> getInvalidInstances(String clusterName);\n+", "originalCommit": "bcd932ecc85cddffbaf63c6aeb287f6350413cad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU3Nzg2Nw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r489577867", "bodyText": "If we return an object, users will still need to parse it by themselves. It's a lot of work if you look at the functions in ClusterTrie. I don't think we want to have this requirement on them. Or you mean users need to call the functions inside ClusterTrie? then they need to know all the available functions? Please let me know.", "author": "zhangmeng916", "createdAt": "2020-09-16T16:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NTg2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUzNTk1Ng==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490535956", "bodyText": "Discussed offline, and we will only keep one API in HelixAdmin. Updated.", "author": "zhangmeng916", "createdAt": "2020-09-17T20:16:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NTg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NjYyNg==", "url": "https://github.com/apache/helix/pull/1307#discussion_r488396626", "bodyText": "Can we just refer to the DELIMITER and CONNECTOR in ClusterTrie?", "author": "jiajunwang", "createdAt": "2020-09-15T05:35:46Z", "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+  private static final String DELIMITER = \"/\";", "originalCommit": "bcd932ecc85cddffbaf63c6aeb287f6350413cad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "33a8259a569be75ba983bbae4c3c692fd284073a", "url": "https://github.com/apache/helix/commit/33a8259a569be75ba983bbae4c3c692fd284073a", "message": "return cluster topology as an object in Helix Amdin", "committedDate": "2020-09-17T20:22:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NDE2Ng==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490644166", "bodyText": "nit, final for the ClusterConfig too?", "author": "jiajunwang", "createdAt": "2020-09-18T01:10:48Z", "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NDc0Ng==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490644746", "bodyText": "nit, Collections.EMPTY_MAP?", "author": "jiajunwang", "createdAt": "2020-09-18T01:13:06Z", "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NjA4NQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490646085", "bodyText": "I feel these methods can be put into the ClusterTrie class, given we can generalize the domain concept to the trie node keys. But we can also refactor later when we are migrating our existing Topology.java to use the same class.", "author": "jiajunwang", "createdAt": "2020-09-18T01:18:33Z", "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domain.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _trieClusterTopology.getRootNode();\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private List<TrieNode> getStartNodes(String domain) {\n+    List<TrieNode> results = new ArrayList<>();\n+    TrieNode curNode = _trieClusterTopology.getRootNode();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode.getDomainType().equals(domain)) {\n+        results.add(curNode);\n+      } else {\n+        for (TrieNode child : curNode.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return results;\n+  }", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MDk1Ng==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493980956", "bodyText": "Any thoughts about this comment, please?", "author": "jiajunwang", "createdAt": "2020-09-24T01:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NjA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyNjE1NQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r494026155", "bodyText": "Yep, I've moved them to clustertrie.", "author": "zhangmeng916", "createdAt": "2020-09-24T04:07:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NjA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0Njk0Nw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490646947", "bodyText": "Why we need 2 ZkBaseDataAccessors here?", "author": "jiajunwang", "createdAt": "2020-09-18T01:21:43Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1156,6 +1157,30 @@ public void removeCloudConfig(String clusterName) {\n     accessor.removeProperty(keyBuilder.cloudConfig());\n   }\n \n+  @Override\n+  public ClusterTopology getClusterTopology(String clusterName) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    String path = PropertyPathBuilder.instanceConfig(clusterName);\n+    BaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_zkClient);\n+    List<ZNRecord> znRecords = baseAccessor.getChildren(path, null, 0, 0, 0);\n+    for (ZNRecord record : znRecords) {\n+      if (record != null) {\n+        InstanceConfig instanceConfig = new InstanceConfig(record);\n+        instanceConfigMap.put(instanceConfig.getInstanceName(), instanceConfig);\n+      }\n+    }\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_zkClient));", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0NzI0Mg==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490647242", "bodyText": "nit, but it would be cleaner if we use ZkBaseDataAccessor for all information access, IMHO.", "author": "jiajunwang", "createdAt": "2020-09-18T01:22:57Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ZKHelixAdmin.java", "diffHunk": "@@ -1156,6 +1157,30 @@ public void removeCloudConfig(String clusterName) {\n     accessor.removeProperty(keyBuilder.cloudConfig());\n   }\n \n+  @Override\n+  public ClusterTopology getClusterTopology(String clusterName) {\n+    Map<String, InstanceConfig> instanceConfigMap = new HashMap<>();\n+    String path = PropertyPathBuilder.instanceConfig(clusterName);\n+    BaseDataAccessor<ZNRecord> baseAccessor = new ZkBaseDataAccessor<>(_zkClient);\n+    List<ZNRecord> znRecords = baseAccessor.getChildren(path, null, 0, 0, 0);\n+    for (ZNRecord record : znRecords) {\n+      if (record != null) {\n+        InstanceConfig instanceConfig = new InstanceConfig(record);\n+        instanceConfigMap.put(instanceConfig.getInstanceName(), instanceConfig);\n+      }\n+    }\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<ZNRecord>(_zkClient));\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    List<LiveInstance> liveInstances = accessor.getChildValues(keyBuilder.liveInstances(), true);\n+    List<String> liveNodes = new ArrayList<>();\n+    liveInstances.forEach(liveInstance -> liveNodes.add(liveInstance.getInstanceName()));\n+\n+    ConfigAccessor configAccessor = new ConfigAccessor(_zkClient);\n+    ClusterConfig clusterConfig = configAccessor.getClusterConfig(clusterName);", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0Nzc5NA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490647794", "bodyText": "For generic, change to _key (node key)?", "author": "jiajunwang", "createdAt": "2020-09-18T01:24:57Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieNode.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+\n+public class TrieNode {\n+  // A mapping between trie key and children nodes.\n+  private Map<String, TrieNode> _children;\n+\n+  // the complete path/prefix leading to the current node.\n+  private final String _path;\n+\n+  private final String _domainType;", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY0ODUyOA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490648528", "bodyText": "nit, I'm not sure if it is feasible given all the usages, but we can always create new children map inside the constructor instead of allowing input.", "author": "jiajunwang", "createdAt": "2020-09-18T01:27:27Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieNode.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+\n+\n+public class TrieNode {\n+  // A mapping between trie key and children nodes.\n+  private Map<String, TrieNode> _children;\n+\n+  // the complete path/prefix leading to the current node.\n+  private final String _path;\n+\n+  private final String _domainType;\n+\n+  TrieNode(Map<String, TrieNode> children, String path, String domainType) {", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY5OTcwOQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490699709", "bodyText": "Seems the paths contain all the information starts from the root. Will it be too much duplicate information?\nConsidering this object might be created frequently depends on the caller code, it could be better to just save the info about the current layer.", "author": "jiajunwang", "createdAt": "2020-09-18T04:47:41Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            _invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        _invalidInstances.add(instanceName);\n+      }\n+    }\n+    _invalidInstances.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private void validateClusterConfig(ClusterConfig clusterConfig) {\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (_topologyKeys.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private TrieNode constructTrie(Map<String, InstanceConfig> instanceConfigMap) {\n+    TrieNode rootNode = new TrieNode(new HashMap<>(), \"\", \"ROOT\");\n+    removeInvalidInstanceConfig(instanceConfigMap);\n+    Map<String, Map<String, String>> instanceDomainsMap = new HashMap<>();\n+    instanceConfigMap.entrySet().forEach(\n+        entry -> instanceDomainsMap.put(entry.getKey(), entry.getValue().getDomainAsMap()));\n+\n+    for (Map.Entry<String, Map<String, String>> entry : instanceDomainsMap.entrySet()) {\n+      TrieNode curNode = rootNode;\n+      String path = \"\";\n+      for (int i = 0; i < _topologyKeys.length; i++) {\n+        String key = _topologyKeys[i] + CONNECTOR + entry.getValue().get(_topologyKeys[i]);\n+        path = path + DELIMITER + key;\n+        TrieNode nextNode = curNode.getChildren().get(key);\n+        if (nextNode == null) {\n+          nextNode = new TrieNode(new HashMap<>(), path, _topologyKeys[i]);", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyMzUxOQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r491123519", "bodyText": "The reason is that we don't know whether there're sub-domains with the same name, e.g. there can be /group:0/zone:0, /group:1/zone:0, /group:2/zone:0, we'll need full path to distinguish between them.", "author": "zhangmeng916", "createdAt": "2020-09-18T18:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY5OTcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1MDQ3OQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493050479", "bodyText": "I don't get the reason. With your example, it should be very simple to distinguish since these 3 zone:0 nodes are under different parent nodes. And while you are traversing, the algorithm can construct the full path based on parents' information. You can even keep a stack with paths for this purpose.", "author": "jiajunwang", "createdAt": "2020-09-22T21:42:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY5OTcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NjgwNA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493066804", "bodyText": "Do you suggest to replace the _path in TrieNode with parent node field? I feel the _path is easier for traversal. Is the concern mainly on the memory usage?", "author": "zhangmeng916", "createdAt": "2020-09-22T22:22:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY5OTcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzEyNjQ5NA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493126494", "bodyText": "It's both memory and additional computing for splitting/merging the path String.\nIf we just put minimum info into trie, then there is no need to merge Strings. And there is no additional memory usage. Then when you read the tree, you don't need to split based on the \":\" again. So I feel there would be a lot of saving on both the write and read side.\nTo be specific, I think the node needs: 1. children map<domain value, TrieNode>, 2. domain Type (optional, since the recorded topology def list can be used to determine the type), 3. domain value (optional too, duplicate with the childrm map key, but could be convient).\nThen when you read, you can fill the type according to the depth of the tree and collect the domain value based on the children map key.\nThe matter is to avoid String operations in which we create new String objects.", "author": "jiajunwang", "createdAt": "2020-09-23T01:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY5OTcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgyODgzOQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493828839", "bodyText": "I understand your point. I tried a bit with removing path variable. The problem is that I will need to compose the path when I try to return the results. e.g. if the domain given is \"zone\":\"0\", I find the trie node and all its children, and when I return, I'll need to return \"group:0/zone:0\" as the full path, so I still need to build the string with parent information, there is no other way to know the domains above it. So the path is actually very convenient. What do you think?", "author": "zhangmeng916", "createdAt": "2020-09-23T19:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY5OTcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk3OTcxNA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493979714", "bodyText": "So it either String operation on the read side or on the write side. Maybe only write side would be better since we definitely have more reads.\nLet's keep the current design for now. It is an internal method so we can optimize if necessary.", "author": "jiajunwang", "createdAt": "2020-09-24T00:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDY5OTcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwMjc0Mg==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490702742", "bodyText": "nit, domain -> domainType", "author": "jiajunwang", "createdAt": "2020-09-18T04:59:36Z", "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domain.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {\n+    TrieNode curNode = _trieClusterTopology.getRootNode();\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domain.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private List<TrieNode> getStartNodes(String domain) {", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwMjgwNA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490702804", "bodyText": "nit, domain -> domainMap", "author": "jiajunwang", "createdAt": "2020-09-18T04:59:49Z", "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domain.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getStartNode(LinkedHashMap<String, String> domain) {", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwNTIzMw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490705233", "bodyText": "And, just curious, where does the \"start\" come from? The leaf node is a special case. But here the logic is generic, so it is just getNode(), right?", "author": "jiajunwang", "createdAt": "2020-09-18T05:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwMjgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyMjA1OA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r491122058", "bodyText": "\"start\" means where we start to collect the children node information. E.g., if we have the input of ([\"group\":\"0\"], [\"zone\":\"1\"]), then we know that we should get all the children information from node /group:0/zone:1, basically this is the start point.\nAnd if we have an input as \"zone\" domainType, then we need to find all the starting nodes for that domainType, and then return all the children. e.g. they can be /group:0/zone:0, /group:0/zone:1, /group:1/zone:0, /group:1/zone:1 etc.", "author": "zhangmeng916", "createdAt": "2020-09-18T18:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwMjgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1MTExNw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493051117", "bodyText": "I understand the logic, I'm just asking about the name. Since this method can also be used to get the leaf, I feel getNode() is simpler and more generic. But no strong preference here.", "author": "jiajunwang", "createdAt": "2020-09-22T21:43:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwMjgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2Njc5NQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493066795", "bodyText": "Yeah, I agree. Changed the name.", "author": "zhangmeng916", "createdAt": "2020-09-22T22:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwMjgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwNDIwMQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490704201", "bodyText": "Regardless of what I mentioned above, I think you can merge getPathUnderNode() and getStartNodes() to avoid duplicate logic. Some minor change is required, of course. But I think its a better option.\nHigh-level, you need a method that searches for multiple nodes under a certain scope. And another method that gets a certain node (getStartNode).", "author": "jiajunwang", "createdAt": "2020-09-18T05:04:57Z", "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domain);\n+    TrieNode startNode = getStartNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domain) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domain == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domain.size(); i++) {\n+      if (!domain.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domain.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEyMjg1MQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r491122851", "bodyText": "I can merge these two, but I think it'll be a bit messy to combine the two cases, one is to find all nodes under a certain domain map, basically a branch of the trie, and the other is to find all nodes under a certain domain type, basically all branches of the trie.", "author": "zhangmeng916", "createdAt": "2020-09-18T18:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwNDIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwODA4MA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490708080", "bodyText": "We may not need these 2 functions for supporting the public methods.\nI think what we want is a query method that accepts a Map of domain type and value pairs. However, the trick is that the value could be a wildcard \"*\" or just put null. Then we just need to maintain one set of logic. And for sure, no duplicate logic.", "author": "jiajunwang", "createdAt": "2020-09-18T05:19:52Z", "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(new HashMap<>());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domain A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domain) {", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTEzMDM4OA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r491130388", "bodyText": "I tried with a null value for domainType, but feel the logic is still very difficult to merge.\nIf you look at the two functions:\nprivate TrieNode getStartNode(LinkedHashMap<String, String> domainMap) {\n    TrieNode curNode = _trieClusterTopology.getRootNode();\n    TrieNode nextNode;\n    for (Map.Entry<String, String> entry : domainMap.entrySet()) {\n      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n      if (nextNode == null) {\n        throw new IllegalArgumentException(String\n            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n                entry.getValue()));\n      }\n      curNode = nextNode;\n    }\n    return curNode;\n  }\n\n  private List<TrieNode> getStartNodes(String domainType) {\n    List<TrieNode> results = new ArrayList<>();\n    TrieNode curNode = _trieClusterTopology.getRootNode();\n    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n    nodeStack.push(curNode);\n    while (!nodeStack.isEmpty()) {\n      curNode = nodeStack.pop();\n      if (curNode.getNodeKey().equals(domainType)) {\n        results.add(curNode);\n      } else {\n        for (TrieNode child : curNode.getChildren().values()) {\n          nodeStack.push(child);\n        }\n      }\n    }\n    return results;\n  }\n\nThey're not easy to combine, since one is to find a specific node in the trie, while the other is to find all nodes for a certain level across the trie. Thoughts?", "author": "zhangmeng916", "createdAt": "2020-09-18T18:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwODA4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1NDc0MA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493054740", "bodyText": "Yeah, I see. Let's keep the current design for now.", "author": "jiajunwang", "createdAt": "2020-09-22T21:52:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwODA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwODc0Ng==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490708746", "bodyText": "Better to put _topologyKeys to the parameter. This is a better style since the private methods will not depend on each other.", "author": "jiajunwang", "createdAt": "2020-09-18T05:22:31Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcxMTEzNw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490711137", "bodyText": "In general, private methods are better to be \"independent\" with the object. So that maintenance of the class would be much easier.\nSuggest to change to\nprivate List getInvalidIstanceConfig(Map<String, InstanceConfig> instanceConfigMap);\nThen we can do instanceConfigMap.keyset().removeAll(_invalidInstances) in the caller where the object fields are updated in a centralized place.", "author": "jiajunwang", "createdAt": "2020-09-18T05:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwODc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwOTMzOQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490709339", "bodyText": "nit, just return the _topologyKeys as the return value. So we don't modify the object field secretly inside a \"validate\" method. Moreover, maybe call it getTopologyDef() would be more straightforward.", "author": "jiajunwang", "createdAt": "2020-09-18T05:24:51Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            _invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        _invalidInstances.add(instanceName);\n+      }\n+    }\n+    _invalidInstances.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private void validateClusterConfig(ClusterConfig clusterConfig) {", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwOTQ5Mw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490709493", "bodyText": "Same here, better to put the _topologyKeys into the parameter list.", "author": "jiajunwang", "createdAt": "2020-09-18T05:25:23Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            _invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        _invalidInstances.add(instanceName);\n+      }\n+    }\n+    _invalidInstances.forEach(entry -> instanceConfigMap.remove(entry));\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private void validateClusterConfig(ClusterConfig clusterConfig) {\n+    String topologyDef = clusterConfig.getTopology();\n+    if (topologyDef == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    _topologyKeys = Arrays.asList(topologyDef.trim().split(DELIMITER)).stream()\n+        .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (_topologyKeys.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private TrieNode constructTrie(Map<String, InstanceConfig> instanceConfigMap) {", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcxMDA4NA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490710084", "bodyText": "instanceConfigMap.keyset().removeAll(_invalidInstances)", "author": "jiajunwang", "createdAt": "2020-09-18T05:27:25Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);\n+  }\n+\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void removeInvalidInstanceConfig(Map<String, InstanceConfig> instanceConfigMap) {\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : _topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            _invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        _invalidInstances.add(instanceName);\n+      }\n+    }\n+    _invalidInstances.forEach(entry -> instanceConfigMap.remove(entry));", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcxMjA3MA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r490712070", "bodyText": "So to summary the following comments, my suggestion would be,\nvalidateInstanceConfig(liveNodes, instanceConfigMap);\n_topologyKeys = getTopologyKeys(clusterConfig);\n_faultZoneType = clusterConfig.getFaultZoneType();\n_invalidInstances = getInvalidInstances(instanceConfigMap);\ninstanceConfigMap.keyset().removeAll(_invalidInstances);\n_rootNode = constructTrie(instanceConfigMap, _topologyKeys);\nWould this be cleaner and easier to maintain for the long term?", "author": "jiajunwang", "createdAt": "2020-09-18T05:34:19Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,150 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    validateClusterConfig(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _rootNode = constructTrie(instanceConfigMap);", "originalCommit": "33a8259a569be75ba983bbae4c3c692fd284073a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0ODY3OQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493048679", "bodyText": "The same example that I gave Xiaoyuan for the Topology.java change,\n\"/group/ zone/ rack /host\", do we accept this one? With your current logic, I think it will return \"[\"group\", \" zone\", \" rack \", \"host\"]\". Please mind the space in the keys. It will cause a mismatch in the later algorithm.", "author": "jiajunwang", "createdAt": "2020-09-22T21:38:23Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,155 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    _topologyKeys = getTopologyDef(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _invalidInstances = getInvalidInstancesFromConfig(instanceConfigMap, _topologyKeys);\n+    instanceConfigMap.keySet().removeAll(_invalidInstances);\n+    _rootNode = constructTrie(instanceConfigMap, _topologyKeys);\n+  }\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  private List<String> getInvalidInstancesFromConfig(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    List<String> invalidInstances = new ArrayList<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        invalidInstances.add(instanceName);\n+      }\n+    }\n+    return invalidInstances;\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private String[] getTopologyDef(ClusterConfig clusterConfig) {\n+    String[] topologyDef;\n+    String topologyDefInConfig = clusterConfig.getTopology();\n+    if (topologyDefInConfig == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    topologyDef = Arrays.asList(topologyDefInConfig.trim().split(DELIMITER)).stream()", "originalCommit": "8109e14891f68cfde011ec4bfabd9e8b5e192014", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA3MDcxOA==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493070718", "bodyText": "I see what you mean. I trimmed spaces after split. I think space should be allowed. Updated PR.", "author": "zhangmeng916", "createdAt": "2020-09-22T22:33:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0ODY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNTU0Ng==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493115546", "bodyText": "I guess this is not necessary?", "author": "jiajunwang", "createdAt": "2020-09-23T01:03:36Z", "path": "helix-core/src/main/java/org/apache/helix/model/TrieNode.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\n+public class TrieNode {\n+  // A mapping between trie key and children nodes.\n+  private Map<String, TrieNode> _children;\n+\n+  // the complete path/prefix leading to the current node.\n+  private final String _path;\n+\n+  private final String _nodeKey;\n+\n+  TrieNode(String path, String nodeKey) {\n+    _path = path;\n+    _nodeKey = nodeKey;\n+    _children = new HashMap<>();\n+  }\n+\n+  public Map<String, TrieNode> getChildren() {\n+    return _children;\n+  }\n+\n+  public String getPath() {\n+    return _path;\n+  }\n+\n+  public String getNodeKey() {\n+    return _nodeKey;\n+  }\n+\n+  public void addChildrenMap(Map <String, TrieNode> children) {", "originalCommit": "cdc9581cbab07741966b99f5727149743d97b318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNjk3Ng==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493116976", "bodyText": "Better to add one more check that, if the topologyDefInConfig does not start with DELIMITER, then it is invalid.", "author": "jiajunwang", "createdAt": "2020-09-23T01:09:08Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    _topologyKeys = getTopologyDef(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _invalidInstances = getInvalidInstancesFromConfig(instanceConfigMap, _topologyKeys);\n+    instanceConfigMap.keySet().removeAll(_invalidInstances);\n+    _rootNode = constructTrie(instanceConfigMap, _topologyKeys);\n+  }\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  private List<String> getInvalidInstancesFromConfig(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    List<String> invalidInstances = new ArrayList<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        invalidInstances.add(instanceName);\n+      }\n+    }\n+    return invalidInstances;\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private String[] getTopologyDef(ClusterConfig clusterConfig) {\n+    String[] topologyDef;\n+    String topologyDefInConfig = clusterConfig.getTopology();\n+    if (topologyDefInConfig == null) {", "originalCommit": "cdc9581cbab07741966b99f5727149743d97b318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNzA3NQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493117075", "bodyText": "nit, the first tirm becomes unnecessary with the later one in the map().", "author": "jiajunwang", "createdAt": "2020-09-23T01:09:31Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    _topologyKeys = getTopologyDef(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _invalidInstances = getInvalidInstancesFromConfig(instanceConfigMap, _topologyKeys);\n+    instanceConfigMap.keySet().removeAll(_invalidInstances);\n+    _rootNode = constructTrie(instanceConfigMap, _topologyKeys);\n+  }\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  private List<String> getInvalidInstancesFromConfig(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    List<String> invalidInstances = new ArrayList<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        invalidInstances.add(instanceName);\n+      }\n+    }\n+    return invalidInstances;\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private String[] getTopologyDef(ClusterConfig clusterConfig) {\n+    String[] topologyDef;\n+    String topologyDefInConfig = clusterConfig.getTopology();\n+    if (topologyDefInConfig == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    topologyDef =\n+        Arrays.asList(topologyDefInConfig.trim().split(DELIMITER)).stream().map(str -> str.trim())", "originalCommit": "cdc9581cbab07741966b99f5727149743d97b318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExNzIxOQ==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493117219", "bodyText": "StringBuilder for the performance.", "author": "jiajunwang", "createdAt": "2020-09-23T01:10:07Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    _topologyKeys = getTopologyDef(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _invalidInstances = getInvalidInstancesFromConfig(instanceConfigMap, _topologyKeys);\n+    instanceConfigMap.keySet().removeAll(_invalidInstances);\n+    _rootNode = constructTrie(instanceConfigMap, _topologyKeys);\n+  }\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  private List<String> getInvalidInstancesFromConfig(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    List<String> invalidInstances = new ArrayList<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        invalidInstances.add(instanceName);\n+      }\n+    }\n+    return invalidInstances;\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private String[] getTopologyDef(ClusterConfig clusterConfig) {\n+    String[] topologyDef;\n+    String topologyDefInConfig = clusterConfig.getTopology();\n+    if (topologyDefInConfig == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    topologyDef =\n+        Arrays.asList(topologyDefInConfig.trim().split(DELIMITER)).stream().map(str -> str.trim())\n+            .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (topologyDef.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+    return topologyDef;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private TrieNode constructTrie(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    TrieNode rootNode = new TrieNode(\"\", \"ROOT\");\n+    Map<String, Map<String, String>> instanceDomainsMap = new HashMap<>();\n+    instanceConfigMap.entrySet().forEach(\n+        entry -> instanceDomainsMap.put(entry.getKey(), entry.getValue().getDomainAsMap()));\n+\n+    for (Map.Entry<String, Map<String, String>> entry : instanceDomainsMap.entrySet()) {\n+      TrieNode curNode = rootNode;\n+      String path = \"\";", "originalCommit": "cdc9581cbab07741966b99f5727149743d97b318", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExODA4Ng==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493118086", "bodyText": "I guess you just need the full path for the leaf node.", "author": "jiajunwang", "createdAt": "2020-09-23T01:13:44Z", "path": "helix-core/src/main/java/org/apache/helix/model/ClusterTrie.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package org.apache.helix.model;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.HelixException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * This is a class that uses a trie data structure to represent cluster topology. Each node\n+ * except the terminal node represents a certain domain in the topology, and an terminal node\n+ * represents an instance in the cluster.\n+ */\n+public class ClusterTrie {\n+  public static final String DELIMITER = \"/\";\n+  public static final String CONNECTOR = \":\";\n+\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTrie.class);\n+  private TrieNode _rootNode;\n+  private String[] _topologyKeys;\n+  private String _faultZoneType;\n+  private List<String> _invalidInstances = new ArrayList<>();\n+\n+  public ClusterTrie(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, ClusterConfig clusterConfig) {\n+    validateInstanceConfig(liveNodes, instanceConfigMap);\n+    _topologyKeys = getTopologyDef(clusterConfig);\n+    _faultZoneType = clusterConfig.getFaultZoneType();\n+    _invalidInstances = getInvalidInstancesFromConfig(instanceConfigMap, _topologyKeys);\n+    instanceConfigMap.keySet().removeAll(_invalidInstances);\n+    _rootNode = constructTrie(instanceConfigMap, _topologyKeys);\n+  }\n+\n+  public TrieNode getRootNode() {\n+    return _rootNode;\n+  }\n+\n+  public String[] getTopologyKeys() {\n+    return _topologyKeys;\n+  }\n+\n+  public  String getFaultZoneType() {\n+    return _faultZoneType;\n+  }\n+\n+  public List<String> getInvalidInstances() {\n+    return _invalidInstances;\n+  }\n+\n+  private void validateInstanceConfig(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap) {\n+    if (instanceConfigMap == null || !instanceConfigMap.keySet().containsAll(liveNodes)) {\n+      List<String> liveNodesCopy = new ArrayList<>();\n+      liveNodesCopy.addAll(liveNodes);\n+      throw new HelixException(String.format(\"Config for instances %s is not found!\",\n+          instanceConfigMap == null ? liveNodes\n+              : liveNodesCopy.removeAll(instanceConfigMap.keySet())));\n+    }\n+  }\n+\n+  private List<String> getInvalidInstancesFromConfig(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    List<String> invalidInstances = new ArrayList<>();\n+    for (String instanceName : instanceConfigMap.keySet()) {\n+      try {\n+        Map<String, String> domainAsMap = instanceConfigMap.get(instanceName).getDomainAsMap();\n+        for (String key : topologyKeys) {\n+          String value = domainAsMap.get(key);\n+          if (value == null || value.length() == 0) {\n+            logger.info(String.format(\"Domain %s for instance %s is not set\", domainAsMap.get(key),\n+                instanceName));\n+            invalidInstances.add(instanceName);\n+            break;\n+          }\n+        }\n+      } catch (IllegalArgumentException e) {\n+        invalidInstances.add(instanceName);\n+      }\n+    }\n+    return invalidInstances;\n+  }\n+\n+  // Note that we do not validate whether topology-aware is enabled or fault zone type is\n+  // defined, as they do not block the construction of the trie\n+  private String[] getTopologyDef(ClusterConfig clusterConfig) {\n+    String[] topologyDef;\n+    String topologyDefInConfig = clusterConfig.getTopology();\n+    if (topologyDefInConfig == null) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is empty!\",\n+          clusterConfig.getClusterName()));\n+    }\n+    // A list of all keys in cluster topology, e.g., a cluster topology defined as\n+    // /group/zone/rack/host will return [\"group\", \"zone\", \"rack\", \"host\"].\n+    topologyDef =\n+        Arrays.asList(topologyDefInConfig.trim().split(DELIMITER)).stream().map(str -> str.trim())\n+            .filter(str -> !str.isEmpty()).collect(Collectors.toList()).toArray(new String[0]);\n+    if (topologyDef.length == 0) {\n+      throw new HelixException(String.format(\"The topology of cluster %s is not correctly defined\",\n+          clusterConfig.getClusterName()));\n+    }\n+    return topologyDef;\n+  }\n+\n+  /**\n+   * Constructs a trie based on the provided instance config map. It loops through all instance\n+   * configs and constructs the trie in a top down manner.\n+   */\n+  private TrieNode constructTrie(Map<String, InstanceConfig> instanceConfigMap,\n+      final String[] topologyKeys) {\n+    TrieNode rootNode = new TrieNode(\"\", \"ROOT\");\n+    Map<String, Map<String, String>> instanceDomainsMap = new HashMap<>();\n+    instanceConfigMap.entrySet().forEach(\n+        entry -> instanceDomainsMap.put(entry.getKey(), entry.getValue().getDomainAsMap()));\n+\n+    for (Map.Entry<String, Map<String, String>> entry : instanceDomainsMap.entrySet()) {\n+      TrieNode curNode = rootNode;\n+      String path = \"\";\n+      for (int i = 0; i < topologyKeys.length; i++) {\n+        String key = topologyKeys[i] + CONNECTOR + entry.getValue().get(topologyKeys[i]);\n+        path = path + DELIMITER + key;\n+        TrieNode nextNode = curNode.getChildren().get(key);\n+        if (nextNode == null) {\n+          nextNode = new TrieNode(path, topologyKeys[i]);", "originalCommit": "cdc9581cbab07741966b99f5727149743d97b318", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgzMzI2Nw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493833267", "bodyText": "Please see the above comments. Actually have the full path stored in each trie node help save a lot of efforts during query. We don't need to store parents, and don't need to compose the full path when return the map.", "author": "zhangmeng916", "createdAt": "2020-09-23T19:10:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzExODA4Ng=="}], "type": "inlineReview"}, {"oid": "535026bb0c815f37bbb3ccbe3f3c37f33ce91e71", "url": "https://github.com/apache/helix/commit/535026bb0c815f37bbb3ccbe3f3c37f33ce91e71", "message": "fix comments on trim", "committedDate": "2020-09-23T19:07:19Z", "type": "forcePushed"}, {"oid": "7c8bcb2072c992ef46b4c962612423a160066794", "url": "https://github.com/apache/helix/commit/7c8bcb2072c992ef46b4c962612423a160066794", "message": "fix comments on trim", "committedDate": "2020-09-23T19:11:39Z", "type": "forcePushed"}, {"oid": "ce68505dee561049563af529635a7d1c09af1f61", "url": "https://github.com/apache/helix/commit/ce68505dee561049563af529635a7d1c09af1f61", "message": "fix comments on trim", "committedDate": "2020-09-23T22:43:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MTM3Ng==", "url": "https://github.com/apache/helix/pull/1307#discussion_r493981376", "bodyText": "Shall we move them to ClusterTrie? They are useful to read the tree for all reader classes, right?", "author": "jiajunwang", "createdAt": "2020-09-24T01:06:09Z", "path": "helix-core/src/main/java/org/apache/helix/api/topology/ClusterTopology.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package org.apache.helix.api.topology;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.model.ClusterConfig;\n+import org.apache.helix.model.ClusterTrie;\n+import org.apache.helix.model.InstanceConfig;\n+import org.apache.helix.model.TrieNode;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.helix.model.ClusterTrie.CONNECTOR;\n+import static org.apache.helix.model.ClusterTrie.DELIMITER;\n+\n+\n+public class ClusterTopology {\n+  private static Logger logger = LoggerFactory.getLogger(ClusterTopology.class);\n+\n+  private final ClusterTrie _trieClusterTopology;\n+\n+  public ClusterTopology(final List<String> liveNodes,\n+      final Map<String, InstanceConfig> instanceConfigMap, final ClusterConfig clusterConfig) {\n+    _trieClusterTopology = new ClusterTrie(liveNodes, instanceConfigMap, clusterConfig);\n+  }\n+\n+  /**\n+   * Return the whole topology of a cluster as a map. The key of the map is the first level of\n+   * domain, and the value is a list of string that represents the path to each end node in that\n+   * domain. E.g., assume the topology is defined as /group/zone/rack/host, the result may be {\n+   * [\"/group:0\": {\"/zone:0/rack:0/host:0\", \"/zone:1/rack:1/host:1\"}], [\"/group:1\": {\"/zone:1\n+   * /rack:1/host:1\", \"/zone:1/rack:1/host:2\"}]}\n+   */\n+  public Map<String, List<String>> getTopologyMap() {\n+    return getTopologyUnderDomain(Collections.emptyMap());\n+  }\n+\n+  /**\n+   * Return all the instances under fault zone type. The key of the returned map is each fault\n+   * zone name, and the value is a list of string that represents the path to each end node in\n+   * that fault zone.\n+   * @return , e.g. if the fault zone is \"zone\", it may return {[\"/group:0/zone:0\": {\"rack:0/host\n+   * :0\", \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  public Map<String, List<String>> getFaultZoneMap() {\n+    String faultZone = _trieClusterTopology.getFaultZoneType();\n+    if (faultZone == null) {\n+      throw new IllegalArgumentException(\"The fault zone in cluster config is not defined\");\n+    }\n+    return getTopologyUnderDomainType(faultZone);\n+  }\n+\n+  /**\n+   * Return the instances whose domain field is not valid\n+   */\n+  public List<String> getInvalidInstances() {\n+    return _trieClusterTopology.getInvalidInstances();\n+  }\n+\n+  /**\n+   * Return the topology under a certain domain as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param domainMap A map defining the domain name and its value, e.g. {[\"group\": \"1\"], [\"zone\",\n+   *               \"2\"]}\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomain(Map<String, String> domainMap) {\n+    LinkedHashMap<String, String> orderedDomain = validateAndOrderDomain(domainMap);\n+    TrieNode startNode = getNode(orderedDomain);\n+    Map<String, TrieNode> children = startNode.getChildren();\n+    Map<String, List<String>> results = new HashMap<>();\n+    children.entrySet().forEach(child -> {\n+      results.put(startNode.getPath() + DELIMITER + child.getKey(),\n+          truncatePath(getPathUnderNode(child.getValue()), child.getValue().getPath()));\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return the full topology of a certain domain type.\n+   * @param domainType a specific type of domain, e.g. zone\n+   * @return the topology of the given domain type, e.g. {[\"/group:0/zone:0\": {\"rack:0/host:0\",\n+   * \"rack:1/host:1\"}, [\"/group:0/zone:1\": {\"/rack:0:host:2\", \"/rack:1/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderDomainType(String domainType) {\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    if (domainType.equals(topologyKeys[0])) {\n+      return getTopologyMap();\n+    }\n+    Map<String, List<String>> results = new HashMap<>();\n+    String parentDomainType = null;\n+    for (int i = 1; i < topologyKeys.length; i++) {\n+      if (topologyKeys[i].equals(domainType)) {\n+        parentDomainType = topologyKeys[i - 1];\n+        break;\n+      }\n+    }\n+    // get all the starting nodes for the domain type\n+    List<TrieNode> startNodes = getStartNodes(parentDomainType);\n+    for (TrieNode startNode : startNodes) {\n+      results.putAll(getTopologyUnderPath(startNode.getPath()));\n+    }\n+    return results;\n+  }\n+\n+  /**\n+   * Return the topology under a certain path as a map. The key of the returned map is the next\n+   * level domain, and the value is a list of string that represents the path to each end node in\n+   * that domain.\n+   * @param path a path to a certain Trie node, e.g. /group:1/zone:2\n+   * @return the topology under the given domain, e.g. {[\"/group:1/zone:2/rack:0\": {\"/host:0\",\n+   * \"/host:1\"}, [\"/group:1/zone:2/rack:1\": {\"/host:2\", \"/host:3\"}]}\n+   */\n+  private Map<String, List<String>> getTopologyUnderPath(String path) {\n+    Map<String, String> domain = convertPathToDomain(path);\n+    return getTopologyUnderDomain(domain);\n+  }\n+\n+  /**\n+   * Validate the domain provided has continuous fields in cluster topology definition. If it\n+   * has, order the domain based on cluster topology definition. E.g. if the cluster topology is\n+   * /group/zone/rack/instance, and domain is provided as {[\"zone\": \"1\"], [\"group\", \"2\"]} will be\n+   * reordered in a LinkedinHashMap as {[\"group\", \"2\"], [\"zone\": \"1\"]}\n+   */\n+  private LinkedHashMap<String, String> validateAndOrderDomain(Map<String, String> domainMap) {\n+    LinkedHashMap<String, String> orderedDomain = new LinkedHashMap<>();\n+    if (domainMap == null) {\n+      throw new IllegalArgumentException(\"The domain should not be null\");\n+    }\n+    String[] topologyKeys = _trieClusterTopology.getTopologyKeys();\n+    for (int i = 0; i < domainMap.size(); i++) {\n+      if (!domainMap.containsKey(topologyKeys[i])) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain is not valid, the key %s is required\", topologyKeys[i]));\n+      } else {\n+        orderedDomain.put(topologyKeys[i], domainMap.get(topologyKeys[i]));\n+      }\n+    }\n+    return orderedDomain;\n+  }\n+\n+  /**\n+   * Truncate each path in the given set and only retain path starting from current node's\n+   * children to each end node.\n+   * @param toRemovePath The path from root to current node. It should be removed so that users\n+   *                     can get a better view.\n+   */\n+  private List<String> truncatePath(Set<String> paths, String toRemovePath) {\n+    List<String> results = new ArrayList<>();\n+    paths.forEach(path -> {\n+      String truncatedPath = path.replace(toRemovePath, \"\");\n+      results.add(truncatedPath);\n+    });\n+    return results;\n+  }\n+\n+  /**\n+   * Return all the paths from a TrieNode as a set.\n+   * @param node the node from where to collect all the nodes' paths.\n+   * @return All the paths under the node.\n+   */\n+  private Set<String> getPathUnderNode(TrieNode node) {\n+    Set<String> resultMap = new HashSet<>();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(node);\n+    while (!nodeStack.isEmpty()) {\n+      node = nodeStack.pop();\n+      if (node.getChildren().isEmpty()) {\n+        resultMap.add(node.getPath());\n+      } else {\n+        for (TrieNode child : node.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return resultMap;\n+  }\n+\n+  private TrieNode getNode(LinkedHashMap<String, String> domainMap) {\n+    TrieNode curNode = _trieClusterTopology.getRootNode();\n+    TrieNode nextNode;\n+    for (Map.Entry<String, String> entry : domainMap.entrySet()) {\n+      nextNode = curNode.getChildren().get(entry.getKey() + CONNECTOR + entry.getValue());\n+      if (nextNode == null) {\n+        throw new IllegalArgumentException(String\n+            .format(\"The input domain %s does not have the value %s\", entry.getKey(),\n+                entry.getValue()));\n+      }\n+      curNode = nextNode;\n+    }\n+    return curNode;\n+  }\n+\n+  private List<TrieNode> getStartNodes(String domainType) {\n+    List<TrieNode> results = new ArrayList<>();\n+    TrieNode curNode = _trieClusterTopology.getRootNode();\n+    Deque<TrieNode> nodeStack = new ArrayDeque<>();\n+    nodeStack.push(curNode);\n+    while (!nodeStack.isEmpty()) {\n+      curNode = nodeStack.pop();\n+      if (curNode.getNodeKey().equals(domainType)) {\n+        results.add(curNode);\n+      } else {\n+        for (TrieNode child : curNode.getChildren().values()) {\n+          nodeStack.push(child);\n+        }\n+      }\n+    }\n+    return results;\n+  }", "originalCommit": "ce68505dee561049563af529635a7d1c09af1f61", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyNjA2Nw==", "url": "https://github.com/apache/helix/pull/1307#discussion_r494026067", "bodyText": "Agree. Moved to cluster trie.", "author": "zhangmeng916", "createdAt": "2020-09-24T04:07:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzk4MTM3Ng=="}], "type": "inlineReview"}, {"oid": "e9928635e7566a4d903b43f6ea8b784d12120f82", "url": "https://github.com/apache/helix/commit/e9928635e7566a4d903b43f6ea8b784d12120f82", "message": "add TrieClusterTopology", "committedDate": "2020-09-24T18:31:44Z", "type": "commit"}, {"oid": "0d6fcfec749fe16780c6a8a82dc6318f549eed74", "url": "https://github.com/apache/helix/commit/0d6fcfec749fe16780c6a8a82dc6318f549eed74", "message": "add more APIs", "committedDate": "2020-09-24T18:31:44Z", "type": "commit"}, {"oid": "b0d5b5942631387765937e7666158f12f2596f7c", "url": "https://github.com/apache/helix/commit/b0d5b5942631387765937e7666158f12f2596f7c", "message": "add Helix admin API", "committedDate": "2020-09-24T18:32:50Z", "type": "commit"}, {"oid": "b8f6a43a7391b56f7f46b220fdd24f7620bbe79e", "url": "https://github.com/apache/helix/commit/b8f6a43a7391b56f7f46b220fdd24f7620bbe79e", "message": "fix comment", "committedDate": "2020-09-24T18:32:57Z", "type": "commit"}, {"oid": "67690af4a6a15ba6d70551b088ac6a7267f9e7fa", "url": "https://github.com/apache/helix/commit/67690af4a6a15ba6d70551b088ac6a7267f9e7fa", "message": "refactor", "committedDate": "2020-09-24T18:32:57Z", "type": "commit"}, {"oid": "c37ec62bf1bfcdaedf0e5cf3c1fc37c376992f00", "url": "https://github.com/apache/helix/commit/c37ec62bf1bfcdaedf0e5cf3c1fc37c376992f00", "message": "return cluster topology as an object in Helix Amdin", "committedDate": "2020-09-24T18:33:34Z", "type": "commit"}, {"oid": "bbccd628d227b44114cb26a2ef983c4c6c6abb0a", "url": "https://github.com/apache/helix/commit/bbccd628d227b44114cb26a2ef983c4c6c6abb0a", "message": "fix partial comments", "committedDate": "2020-09-24T18:33:37Z", "type": "commit"}, {"oid": "c02810fc71bcc6db0526f3bb721fdac9c9fae13a", "url": "https://github.com/apache/helix/commit/c02810fc71bcc6db0526f3bb721fdac9c9fae13a", "message": "fix function name and string space in topology def", "committedDate": "2020-09-24T18:33:37Z", "type": "commit"}, {"oid": "4dbf3c6ee6b528005ceb2a5fb9c468d48fe73e25", "url": "https://github.com/apache/helix/commit/4dbf3c6ee6b528005ceb2a5fb9c468d48fe73e25", "message": "fix comments on trim", "committedDate": "2020-09-24T18:33:37Z", "type": "commit"}, {"oid": "d6c6aafeabc55f5cd710721249177d11e3c4283d", "url": "https://github.com/apache/helix/commit/d6c6aafeabc55f5cd710721249177d11e3c4283d", "message": "move function", "committedDate": "2020-09-24T18:33:37Z", "type": "commit"}, {"oid": "d6c6aafeabc55f5cd710721249177d11e3c4283d", "url": "https://github.com/apache/helix/commit/d6c6aafeabc55f5cd710721249177d11e3c4283d", "message": "move function", "committedDate": "2020-09-24T18:33:37Z", "type": "forcePushed"}]}