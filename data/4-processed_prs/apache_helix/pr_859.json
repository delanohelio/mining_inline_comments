{"pr_number": 859, "pr_title": "Update customize state using updater", "pr_createdAt": "2020-03-04T23:03:22Z", "pr_url": "https://github.com/apache/helix/pull/859", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODExNjQ2Ng==", "url": "https://github.com/apache/helix/pull/859#discussion_r388116466", "bodyText": "Why we need the synchronized keyword at the first place? ZK should be the one who takes care of concurrent control, right?", "author": "jiajunwang", "createdAt": "2020-03-05T07:25:33Z", "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProvider.java", "diffHunk": "@@ -113,7 +113,7 @@ public CustomizedState getCustomizedState(String customizedStateName, String res\n   /**\n    * Delete the customized state for a specified resource and a specified partition\n    */\n-  public void deletePerPartitionCustomizedState(String customizedStateName, String resourceName,\n+  public synchronized void deletePerPartitionCustomizedState(String customizedStateName, String resourceName,", "originalCommit": "e4412e194f2609cd51d9eb74bf50e5313ae9385e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ2MDA4Mw==", "url": "https://github.com/apache/helix/pull/859#discussion_r388460083", "bodyText": "There can be multiple threads that try to delete partitions in a same resource. Do we want to leave the currency to the Zookeeper or maybe we can prevent it from the beginning. There are some similar pattern in the code base. We can discuss to decide whether we want to follow.", "author": "zhangmeng916", "createdAt": "2020-03-05T17:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODExNjQ2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQ2NDg3NA==", "url": "https://github.com/apache/helix/pull/859#discussion_r388464874", "bodyText": "ZK is the source of truth. Even we control the concurrency in one single node, we can not prevent multiple nodes concurrent access. So leverage ZK capability is the right way.\nIn detail, updater prevents unexpected overwrite. So I don't think the additional check is necessary. Unless we have a concrete counter-example.", "author": "jiajunwang", "createdAt": "2020-03-05T17:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODExNjQ2Ng=="}], "type": "inlineReview"}, {"oid": "650e9ab9c5667fe019853db768f1d1520565eadb", "url": "https://github.com/apache/helix/commit/650e9ab9c5667fe019853db768f1d1520565eadb", "message": "Improve CustomizedStateProvider tests (#840)\n\nAdd tests to make CustomizedStateProvider tests comprehensive.", "committedDate": "2020-03-07T00:11:54Z", "type": "commit"}, {"oid": "099d5d7216424df3c29a5278ca40d8831476ba29", "url": "https://github.com/apache/helix/commit/099d5d7216424df3c29a5278ca40d8831476ba29", "message": "Add 'synchronized' key word to delete method in CustomizedStateProvider", "committedDate": "2020-03-07T00:12:00Z", "type": "commit"}, {"oid": "5b9334d81b56ae320f2ffcb0326bb653b641e92f", "url": "https://github.com/apache/helix/commit/5b9334d81b56ae320f2ffcb0326bb653b641e92f", "message": "Modify update customized state method to leverage ZNRecordUpdater", "committedDate": "2020-03-07T00:12:07Z", "type": "commit"}, {"oid": "790a19b427c336e5646ffc55c761d0b05a620b23", "url": "https://github.com/apache/helix/commit/790a19b427c336e5646ffc55c761d0b05a620b23", "message": "Updated commit author info", "committedDate": "2020-03-07T00:13:02Z", "type": "commit"}, {"oid": "790a19b427c336e5646ffc55c761d0b05a620b23", "url": "https://github.com/apache/helix/commit/790a19b427c336e5646ffc55c761d0b05a620b23", "message": "Updated commit author info", "committedDate": "2020-03-07T00:13:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkxOTQ3MA==", "url": "https://github.com/apache/helix/pull/859#discussion_r389919470", "bodyText": "This could go to beforeClass, right?", "author": "narendly", "createdAt": "2020-03-09T19:43:12Z", "path": "helix-core/src/test/java/org/apache/helix/integration/paticipant/TestCustomizedStateUpdate.java", "diffHunk": "@@ -19,54 +19,84 @@\n  * under the License.\n  */\n \n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.stream.Collectors;\n+\n import org.apache.helix.HelixDataAccessor;\n import org.apache.helix.HelixManager;\n import org.apache.helix.HelixManagerFactory;\n import org.apache.helix.InstanceType;\n import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n import org.apache.helix.customizedstate.CustomizedStateProvider;\n import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n import org.apache.helix.integration.common.ZkStandAloneCMTestBase;\n import org.apache.helix.model.CustomizedState;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.Test;\n \n+\n public class TestCustomizedStateUpdate extends ZkStandAloneCMTestBase {\n   private static Logger LOG = LoggerFactory.getLogger(TestCustomizedStateUpdate.class);\n   private final String CUSTOMIZE_STATE_NAME = \"testState1\";\n   private final String PARTITION_NAME1 = \"testPartition1\";\n   private final String PARTITION_NAME2 = \"testPartition2\";\n   private final String RESOURCE_NAME = \"testResource1\";\n+  private final String PARTITION_STATE = \"partitionState\";\n+  private static HelixManager _manager;\n+  private static CustomizedStateProvider _mockProvider;\n \n-  @Test\n-  public void testUpdateCustomizedState() throws Exception {\n-    HelixManager manager = HelixManagerFactory.getZKHelixManager(CLUSTER_NAME, \"admin\",\n-        InstanceType.ADMINISTRATOR, ZK_ADDR);\n-    manager.connect();\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(CLUSTER_NAME, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n     _participants[0].connect();\n+    _mockProvider = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, _participants[0].getInstanceName());\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+    _manager.disconnect();\n+  }\n \n-    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+  @BeforeMethod\n+  public void beforeMethod() {\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();", "originalCommit": "790a19b427c336e5646ffc55c761d0b05a620b23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTkyMDA3MQ==", "url": "https://github.com/apache/helix/pull/859#discussion_r389920071", "bodyText": "Not a good idea to use 'n's like this - please either make it a int constant or make it more descriptive.", "author": "narendly", "createdAt": "2020-03-09T19:44:19Z", "path": "helix-core/src/test/java/org/apache/helix/integration/paticipant/TestCustomizedStateUpdate.java", "diffHunk": "@@ -113,40 +143,176 @@ public void testUpdateCustomizedState() throws Exception {\n     Map<String, String> stateMap2 = new HashMap<>();\n     stateMap2.put(\"PREVIOUS_STATE\", \"STARTED\");\n     stateMap2.put(\"CURRENT_STATE\", \"END_OF_PUSH_RECEIVED\");\n-    mockProvider.updateCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME2,\n-        stateMap2);\n+    _mockProvider\n+        .updateCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME2, stateMap2);\n \n-    customizedState = mockProvider.getCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME);\n+    customizedState = _mockProvider.getCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME);\n     Assert.assertNotNull(customizedState);\n     Assert.assertEquals(customizedState.getId(), RESOURCE_NAME);\n     mapView = customizedState.getRecord().getMapFields();\n     Assert.assertEquals(mapView.keySet().size(), 2);\n-    Assert.assertEqualsNoOrder(mapView.keySet().toArray(), new String[] {\n-        PARTITION_NAME1, PARTITION_NAME2\n-    });\n+    Assert.assertEqualsNoOrder(mapView.keySet().toArray(),\n+        new String[]{PARTITION_NAME1, PARTITION_NAME2});\n \n-    Map<String, String> partitionMap1 = mockProvider\n+    Map<String, String> partitionMap1 = _mockProvider\n         .getPerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME1);\n     Assert.assertEquals(partitionMap1.keySet().size(), 2);\n     Assert.assertEquals(partitionMap1.get(\"PREVIOUS_STATE\"), \"END_OF_PUSH_RECEIVED\");\n     Assert.assertEquals(partitionMap1.get(\"CURRENT_STATE\"), \"COMPLETED\");\n \n-    Map<String, String> partitionMap2 = mockProvider\n+    Map<String, String> partitionMap2 = _mockProvider\n         .getPerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME2);\n     Assert.assertEquals(partitionMap2.keySet().size(), 2);\n     Assert.assertEquals(partitionMap2.get(\"PREVIOUS_STATE\"), \"STARTED\");\n     Assert.assertEquals(partitionMap2.get(\"CURRENT_STATE\"), \"END_OF_PUSH_RECEIVED\");\n \n     // test delete customized state for a partition\n-    mockProvider.deletePerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME,\n-        PARTITION_NAME1);\n-    customizedState = mockProvider.getCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME);\n+    _mockProvider\n+        .deletePerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME1);\n+    customizedState = _mockProvider.getCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME);\n     Assert.assertNotNull(customizedState);\n     Assert.assertEquals(customizedState.getId(), RESOURCE_NAME);\n     mapView = customizedState.getRecord().getMapFields();\n     Assert.assertEquals(mapView.keySet().size(), 1);\n     Assert.assertEquals(mapView.keySet().iterator().next(), PARTITION_NAME2);\n+  }\n+\n+  @Test\n+  public void testUpdateSinglePartitionCustomizedState() {\n+    _mockProvider.updateCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME1,\n+        PARTITION_STATE);\n+\n+    // get customized state\n+    CustomizedState customizedState =\n+        _mockProvider.getCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME);\n+    Assert.assertEquals(\n+        customizedState.getPartitionStateMap(CustomizedState.CustomizedStateProperty.CURRENT_STATE)\n+            .size(), 1);\n+    Map<String, String> map = new HashMap<>();\n+    map.put(PARTITION_NAME1, null);\n+    Assert.assertEquals(customizedState\n+        .getPartitionStateMap(CustomizedState.CustomizedStateProperty.PREVIOUS_STATE), map);\n+    Assert.assertEquals(\n+        customizedState.getPartitionStateMap(CustomizedState.CustomizedStateProperty.START_TIME),\n+        map);\n+    Assert.assertEquals(\n+        customizedState.getPartitionStateMap(CustomizedState.CustomizedStateProperty.END_TIME),\n+        map);\n+    Assert.assertEquals(customizedState.getState(PARTITION_NAME1), PARTITION_STATE);\n+    Assert.assertNull(customizedState.getState(PARTITION_NAME2));\n+    Assert.assertTrue(customizedState.isValid());\n+\n+    // get per partition customized state\n+    map = new HashMap<>();\n+    map.put(CustomizedState.CustomizedStateProperty.CURRENT_STATE.name(), PARTITION_STATE);\n+    Map<String, String> partitionCustomizedState = _mockProvider\n+        .getPerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME1);\n+    Assert.assertEquals(partitionCustomizedState, map);\n+    Assert.assertNull(_mockProvider\n+        .getPerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME2));\n+  }\n+\n+  @Test\n+  public void testUpdateSinglePartitionCustomizedStateWithNullField() {\n+    _mockProvider\n+        .updateCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME1, (String) null);\n+\n+    // get customized state\n+    CustomizedState customizedState =\n+        _mockProvider.getCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME);\n+    Map<String, String> map = new HashMap<>();\n+    map.put(PARTITION_NAME1, null);\n+    Assert.assertEquals(\n+        customizedState.getPartitionStateMap(CustomizedState.CustomizedStateProperty.CURRENT_STATE),\n+        map);\n+    Assert.assertEquals(customizedState.getState(PARTITION_NAME1), null);\n+    Assert.assertTrue(customizedState.isValid());\n+\n+    // get per partition customized state\n+    map = new HashMap<>();\n+    map.put(CustomizedState.CustomizedStateProperty.CURRENT_STATE.name(), null);\n+    Map<String, String> partitionCustomizedState = _mockProvider\n+        .getPerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME1);\n+    Assert.assertEquals(partitionCustomizedState, map);\n+    Assert.assertNull(_mockProvider\n+        .getPerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME2));\n+  }\n+\n+  @Test\n+  public void testUpdateCustomizedStateWithEmptyMap() {\n+    _mockProvider.updateCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME1,\n+        new HashMap<>());\n+\n+    // get customized state\n+    CustomizedState customizedState =\n+        _mockProvider.getCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME);\n+    Assert.assertNull(customizedState.getState(PARTITION_NAME1));\n+    Map<String, String> partitionStateMap =\n+        customizedState.getPartitionStateMap(CustomizedState.CustomizedStateProperty.CURRENT_STATE);\n+    Assert.assertNotNull(partitionStateMap);\n+    Assert.assertTrue(partitionStateMap.containsKey(PARTITION_NAME1));\n+    Assert.assertNull(partitionStateMap.get(PARTITION_NAME1));\n+    Assert.assertNull(customizedState.getState(PARTITION_NAME1));\n+    Assert.assertFalse(partitionStateMap.containsKey(PARTITION_NAME2));\n+    Assert.assertTrue(customizedState.isValid());\n+\n+    // get per partition customized state\n+    Map<String, String> partitionCustomizedState = _mockProvider\n+        .getPerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME1);\n+    Assert.assertEquals(partitionCustomizedState.size(), 0);\n+    Assert.assertNull(_mockProvider\n+        .getPerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME2));\n+  }\n+\n+  @Test\n+  public void testDeleteNonExistingPerPartitionCustomizedState() {\n+    _mockProvider.updateCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME1,\n+        PARTITION_STATE);\n+    _mockProvider\n+        .deletePerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME2);\n+    Assert.assertNotNull(_mockProvider\n+        .getPerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME1));\n+    Assert.assertNull(_mockProvider\n+        .getPerPartitionCustomizedState(CUSTOMIZE_STATE_NAME, RESOURCE_NAME, PARTITION_NAME2));\n+  }\n+\n+  @Test\n+  public void testSimultaneousUpdateCustomizedState() {\n+    int n = 10;", "originalCommit": "790a19b427c336e5646ffc55c761d0b05a620b23", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzI5Ng==", "url": "https://github.com/apache/helix/pull/859#discussion_r390023296", "bodyText": "It is not clear what the original code tries to do here. It seems trying to merge the map. But not really doing so. Can you confirm the original logic is right or not?\nThe concern is that the default update method is doing deep merge. That is if you have an existing state map with some stale states, even after merging, those stale states will be kept in the map. But I assume we should clean those stale states for updating?", "author": "jiajunwang", "createdAt": "2020-03-09T23:53:26Z", "path": "helix-core/src/main/java/org/apache/helix/customizedstate/CustomizedStateProvider.java", "diffHunk": "@@ -61,29 +61,16 @@ public synchronized void updateCustomizedState(String customizedStateName, Strin\n    * Update a specific customized state based on the resource name and partition name. The\n    * customized state is input as a map\n    */\n-  public synchronized void updateCustomizedState(String customizedStateName, String resourceName,\n+  public void updateCustomizedState(String customizedStateName, String resourceName,\n       String partitionName, Map<String, String> customizedStateMap) {\n     PropertyKey.Builder keyBuilder = _helixDataAccessor.keyBuilder();\n     PropertyKey propertyKey =\n         keyBuilder.customizedState(_instanceName, customizedStateName, resourceName);\n     ZNRecord record = new ZNRecord(resourceName);\n-    Map<String, Map<String, String>> mapFields = new HashMap<>();\n-    CustomizedState existingState = getCustomizedState(customizedStateName, resourceName);\n-    if (existingState != null\n-        && existingState.getRecord().getMapFields().containsKey(partitionName)) {\n-      Map<String, String> existingMap = new HashMap<>();", "originalCommit": "790a19b427c336e5646ffc55c761d0b05a620b23", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyNTAyNA==", "url": "https://github.com/apache/helix/pull/859#discussion_r390025024", "bodyText": "So this is user to update a customized state for a certain partition. I don't think we have the knowledge to clean up stale states, meaning if the user only update \"CURRENT_STATE\" of customized state, we update it, and keep the other fields unchanged. If they would like to do a full update, they will use the other API and provide the full map, and the original map will be overwritten.", "author": "zhangmeng916", "createdAt": "2020-03-09T23:59:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMDA1NQ==", "url": "https://github.com/apache/helix/pull/859#discussion_r390030055", "bodyText": "I don't think you get my point, or maybe I did not get the point. Anyway, let's go with an example,\n\nThe original map {\"CSTypeA\":\"foo\", \"CSTypeB\":\"bar\"}\nUser try to update with map {\"CSTypeC\":\"foo\", \"CSTypeD\":\"bar\"}\nI assume the expect result for the custmize state is {\"CSTypeC\":\"foo\", \"CSTypeD\":\"bar\"}.\nBut really by the default merge method we get: {\"CSTypeA\":\"foo\", \"CSTypeB\":\"bar\", \"CSTypeC\":\"foo\", \"CSTypeD\":\"bar\"}\nCSTypeA and CSTypeB is the stale state that I meant.", "author": "jiajunwang", "createdAt": "2020-03-10T00:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMTgzNQ==", "url": "https://github.com/apache/helix/pull/859#discussion_r390031835", "bodyText": "Yeah, we do want the full map like instead of replacing the previous map. Because for customized state, the key are fixed, e.g. \"previous state\", \"current state\", etc. We do not allow user to delete entries, and if they do not have value, the entry will have null value.\nFor this API, it's updating the per partition customized state, not adding new type of customized states.\nSo it's a definite map of\n{\"start time\": xxx\n\"end time:xxx\n\"previous state\":xxx\n\"current state\":xxx\n}\nand customers update one entry or the full map.", "author": "zhangmeng916", "createdAt": "2020-03-10T00:25:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzI5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzNDY2Mw==", "url": "https://github.com/apache/helix/pull/859#discussion_r390034663", "bodyText": "I see. That makes sense.", "author": "jiajunwang", "createdAt": "2020-03-10T00:36:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzI5Ng=="}], "type": "inlineReview"}, {"oid": "e587596dcb70693e524e433467bb46a2d68570b3", "url": "https://github.com/apache/helix/commit/e587596dcb70693e524e433467bb46a2d68570b3", "message": "Clean up test code", "committedDate": "2020-03-10T00:42:15Z", "type": "commit"}, {"oid": "e587596dcb70693e524e433467bb46a2d68570b3", "url": "https://github.com/apache/helix/commit/e587596dcb70693e524e433467bb46a2d68570b3", "message": "Clean up test code", "committedDate": "2020-03-10T00:42:15Z", "type": "forcePushed"}, {"oid": "9ed640f4c712b207f69bb0cae87736ec5ef32d00", "url": "https://github.com/apache/helix/commit/9ed640f4c712b207f69bb0cae87736ec5ef32d00", "message": "Merge branch 'customizeView' into customizeView", "committedDate": "2020-03-10T00:44:13Z", "type": "commit"}]}