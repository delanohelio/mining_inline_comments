{"pr_number": 700, "pr_title": "Call session aware createEphemeral to create live instance.", "pr_createdAt": "2020-01-23T02:34:26Z", "pr_url": "https://github.com/apache/helix/pull/700", "timeline": [{"oid": "baa905a9a1a6de9e0b124758744a3e2c2caf69fc", "url": "https://github.com/apache/helix/commit/baa905a9a1a6de9e0b124758744a3e2c2caf69fc", "message": "Call session aware createEphemeral to create live instance.", "committedDate": "2020-01-23T02:37:17Z", "type": "forcePushed"}, {"oid": "209aa86d50a5ed19c6dacc74aefc7e9d65f9bed5", "url": "https://github.com/apache/helix/commit/209aa86d50a5ed19c6dacc74aefc7e9d65f9bed5", "message": "Call session aware createEphemeral to create live instance.", "committedDate": "2020-01-23T05:53:26Z", "type": "commit"}, {"oid": "209aa86d50a5ed19c6dacc74aefc7e9d65f9bed5", "url": "https://github.com/apache/helix/commit/209aa86d50a5ed19c6dacc74aefc7e9d65f9bed5", "message": "Call session aware createEphemeral to create live instance.", "committedDate": "2020-01-23T05:53:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2NjAwOQ==", "url": "https://github.com/apache/helix/pull/700#discussion_r369966009", "bodyText": "Question: this createLiveInstance method is supposed to check if the _sessionId is still valid or not. Could you point out where we're doing the check (besides the one happening when we catch ZkNodeExistsException)?\nAlso, is it possible that _sessionId is stale? For example, while the ParticipantManager is in the middle of handleNewSession, session expired?", "author": "narendly", "createdAt": "2020-01-23T07:37:26Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java", "diffHunk": "@@ -201,7 +201,7 @@ private void createLiveInstance() {\n     do {\n       retry = false;\n       try {\n-        _zkclient.createEphemeral(liveInstancePath, liveInstance.getRecord());\n+        _zkclient.createEphemeral(liveInstancePath, liveInstance.getRecord(), _sessionId);", "originalCommit": "209aa86d50a5ed19c6dacc74aefc7e9d65f9bed5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI4MjI2NQ==", "url": "https://github.com/apache/helix/pull/700#discussion_r370282265", "bodyText": "Good question.\n\n\nThe validation is put in create(path, dataObject, acl, mode, expectedSessionId) (which is called by createEphemeral(path, data, session)):\n\n  \n    \n      helix/helix-core/src/main/java/org/apache/helix/manager/zk/zookeeper/ZkClient.java\n    \n    \n        Lines 662 to 670\n      in\n      662dc0f\n    \n    \n    \n    \n\n        \n          \n           if (isSessionAwareOperation(expectedSessionId, mode)) { \n        \n\n        \n          \n             acquireEventLock(); \n        \n\n        \n          \n             try { \n        \n\n        \n          \n               final String actualSessionId = ZKUtil.toHexSessionId(zooKeeper.getSessionId()); \n        \n\n        \n          \n               if (!actualSessionId.equals(expectedSessionId)) { \n        \n\n        \n          \n                 throw new ZkSessionMismatchedException( \n        \n\n        \n          \n                     \"Failed to create ephemeral node! There is a session id mismatch. Expected: \" \n        \n\n        \n          \n                         + expectedSessionId + \". Actual: \" + actualSessionId); \n        \n\n        \n          \n               } \n        \n    \n  \n\n\nAnd this is the reason of current PR.\n\n\n_sessionId is possibly stale. So we want to fix it in this PR by calling the new API with session id. The new API does final check and create ephemeral node.", "author": "huizhilu", "createdAt": "2020-01-23T18:26:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2NjAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyNjc2Nw==", "url": "https://github.com/apache/helix/pull/700#discussion_r370326767", "bodyText": "Great. Could we add a quick comment here:\n\"_sessionId will be validated in createEphemeral\"", "author": "narendly", "createdAt": "2020-01-23T20:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2NjAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyODM4OA==", "url": "https://github.com/apache/helix/pull/700#discussion_r370328388", "bodyText": "Done.", "author": "huizhilu", "createdAt": "2020-01-23T20:05:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2NjAwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNDI3Ng==", "url": "https://github.com/apache/helix/pull/700#discussion_r370334276", "bodyText": "Done", "author": "huizhilu", "createdAt": "2020-01-23T20:19:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2NjAwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2NjUzNA==", "url": "https://github.com/apache/helix/pull/700#discussion_r369966534", "bodyText": "I just wanted to say thank you for being so great with JavaDoc and the PR description! Let's keep it up :)", "author": "narendly", "createdAt": "2020-01-23T07:39:07Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestParticipantManager.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+\n+import org.apache.helix.PreConnectCallback;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkTestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestParticipantManager extends ZkTestBase {\n+  private static Logger LOG = LoggerFactory.getLogger(TestParticipantManager.class);\n+\n+  /*\n+   * Simulates zk session expiry before creating live instance in participant manager. This test\n+   * makes sure the session aware create ephemeral API is called.\n+   * What this test does is:\n+   * 1. Sets up live instance with session S0\n+   * 2. Expires S0 and gets new session S1\n+   * 3. S1 is blocked before creating live instance in participant manager\n+   * 4. Expires S1 and gets new session S2\n+   * 5. Proceeds S1 to create live instance, which will fail because session S1 is expired\n+   * 6. Proceeds S2 to create live instance, which will succeed\n+   */", "originalCommit": "209aa86d50a5ed19c6dacc74aefc7e9d65f9bed5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2Nzc5Mg==", "url": "https://github.com/apache/helix/pull/700#discussion_r369967792", "bodyText": "Nit: are we using this count as a flag? If so, could we just use a boolean flag?", "author": "narendly", "createdAt": "2020-01-23T07:43:03Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestParticipantManager.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+\n+import org.apache.helix.PreConnectCallback;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkTestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestParticipantManager extends ZkTestBase {\n+  private static Logger LOG = LoggerFactory.getLogger(TestParticipantManager.class);\n+\n+  /*\n+   * Simulates zk session expiry before creating live instance in participant manager. This test\n+   * makes sure the session aware create ephemeral API is called.\n+   * What this test does is:\n+   * 1. Sets up live instance with session S0\n+   * 2. Expires S0 and gets new session S1\n+   * 3. S1 is blocked before creating live instance in participant manager\n+   * 4. Expires S1 and gets new session S2\n+   * 5. Proceeds S1 to create live instance, which will fail because session S1 is expired\n+   * 6. Proceeds S2 to create live instance, which will succeed\n+   */\n+  @Test\n+  public void testSessionExpiryCreateLiveInstance() throws Exception {\n+    final String className = TestHelper.getTestClassName();\n+    final String methodName = TestHelper.getTestMethodName();\n+    final String clusterName = className + \"_\" + methodName;\n+\n+    final ZKHelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(ZK_ADDR));\n+    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR,\n+        12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        1, // resources\n+        10, // partitions per resource\n+        5, // number of nodes\n+        3, // replicas\n+        \"MasterSlave\",\n+        true); // do rebalance\n+\n+    final String instanceName = \"localhost_12918\";\n+    final MockParticipantManager manager =\n+        new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+\n+    manager.syncStart();\n+\n+    final LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n+    final long originalCreationTime = liveInstance.getStat().getCreationTime();\n+    final String originalSessionId = manager.getSessionId();\n+\n+    // Verify current live instance.\n+    Assert.assertNotNull(liveInstance);\n+    Assert.assertEquals(liveInstance.getEphemeralOwner(), originalSessionId);\n+\n+    final CountDownLatch startCountdown = new CountDownLatch(1);\n+    final CountDownLatch endCountdown = new CountDownLatch(1);\n+    final Semaphore semaphore = new Semaphore(0);\n+    manager.addPreConnectCallback(\n+        new BlockingPreConnectCallback(instanceName, startCountdown, endCountdown, semaphore));\n+\n+    // Expire S0 and new session S1 will be created.\n+    ZkTestHelper.asyncExpireSession(manager.getZkClient());\n+\n+    // Wait for onPreConnect to start\n+    semaphore.acquire();\n+\n+    // New session S1 should not be equal to S0.\n+    Assert.assertFalse(originalSessionId.equals(manager.getSessionId()));\n+\n+    // Live instance should be gone as original session S0 is expired.\n+    Assert.assertNull(accessor.getProperty(keyBuilder.liveInstance(instanceName)));\n+\n+    final String lastSessionId = manager.getSessionId();\n+\n+    // Expire S1 when S1 is blocked in onPreConnect().\n+    // New session S2 will be created.\n+    ZkTestHelper.asyncExpireSession(manager.getZkClient());\n+\n+    TestHelper.verify(\n+        () -> !(ZKUtil.toHexSessionId(manager.getZkClient().getSessionId()).equals(lastSessionId)),\n+        3000L);\n+\n+    // New session S2 should not be equal to S1.\n+    final String latestSessionId = ZKUtil.toHexSessionId(manager.getZkClient().getSessionId());\n+    Assert.assertFalse(lastSessionId.equals(latestSessionId));\n+\n+    // Proceed S1 to create live instance, which will fail.\n+    startCountdown.countDown();\n+\n+    // Wait until S1's handling new session is completed.\n+    semaphore.acquire();\n+\n+    // Live instance should not be created because zk session is expired.\n+    Assert.assertNull(accessor.getProperty(keyBuilder.liveInstance(instanceName)),\n+        \"Live instance should not be created because zk session is expired!\");\n+\n+    // Proceed S2 to create live instance.\n+    endCountdown.countDown();\n+\n+    TestHelper.verify(() -> {\n+      // Newly created live instance should be created by the latest session S2\n+      // and have a new creation time.\n+      LiveInstance newLiveInstance =\n+          accessor.getProperty(keyBuilder.liveInstance(instanceName));\n+      return newLiveInstance != null\n+          && newLiveInstance.getStat().getCreationTime() != originalCreationTime\n+          && newLiveInstance.getEphemeralOwner().equals(latestSessionId);\n+    }, 2000L);\n+\n+    // Clean up.\n+    manager.syncStop();\n+    deleteCluster(clusterName);\n+  }\n+\n+  /*\n+   * Mocks PreConnectCallback to insert session expiry during ParticipantManager#handleNewSession()\n+   */\n+  static class BlockingPreConnectCallback implements PreConnectCallback {\n+    private final String instanceName;\n+    private final CountDownLatch startCountDown;\n+    private final CountDownLatch endCountDown;\n+    private final Semaphore semaphore;\n+\n+    private int count;", "originalCommit": "209aa86d50a5ed19c6dacc74aefc7e9d65f9bed5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI4NjM5Mw==", "url": "https://github.com/apache/helix/pull/700#discussion_r370286393", "bodyText": "Changed.", "author": "huizhilu", "createdAt": "2020-01-23T18:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2Nzc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2ODIxMA==", "url": "https://github.com/apache/helix/pull/700#discussion_r369968210", "bodyText": "Nit: we seem to be being inconsistent with wait times - could we use TestHelper's default wait time (if there is a constant defined already)?", "author": "narendly", "createdAt": "2020-01-23T07:44:27Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestParticipantManager.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+\n+import org.apache.helix.PreConnectCallback;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkTestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestParticipantManager extends ZkTestBase {\n+  private static Logger LOG = LoggerFactory.getLogger(TestParticipantManager.class);\n+\n+  /*\n+   * Simulates zk session expiry before creating live instance in participant manager. This test\n+   * makes sure the session aware create ephemeral API is called.\n+   * What this test does is:\n+   * 1. Sets up live instance with session S0\n+   * 2. Expires S0 and gets new session S1\n+   * 3. S1 is blocked before creating live instance in participant manager\n+   * 4. Expires S1 and gets new session S2\n+   * 5. Proceeds S1 to create live instance, which will fail because session S1 is expired\n+   * 6. Proceeds S2 to create live instance, which will succeed\n+   */\n+  @Test\n+  public void testSessionExpiryCreateLiveInstance() throws Exception {\n+    final String className = TestHelper.getTestClassName();\n+    final String methodName = TestHelper.getTestMethodName();\n+    final String clusterName = className + \"_\" + methodName;\n+\n+    final ZKHelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(ZK_ADDR));\n+    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR,\n+        12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        1, // resources\n+        10, // partitions per resource\n+        5, // number of nodes\n+        3, // replicas\n+        \"MasterSlave\",\n+        true); // do rebalance\n+\n+    final String instanceName = \"localhost_12918\";\n+    final MockParticipantManager manager =\n+        new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+\n+    manager.syncStart();\n+\n+    final LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n+    final long originalCreationTime = liveInstance.getStat().getCreationTime();\n+    final String originalSessionId = manager.getSessionId();\n+\n+    // Verify current live instance.\n+    Assert.assertNotNull(liveInstance);\n+    Assert.assertEquals(liveInstance.getEphemeralOwner(), originalSessionId);\n+\n+    final CountDownLatch startCountdown = new CountDownLatch(1);\n+    final CountDownLatch endCountdown = new CountDownLatch(1);\n+    final Semaphore semaphore = new Semaphore(0);\n+    manager.addPreConnectCallback(\n+        new BlockingPreConnectCallback(instanceName, startCountdown, endCountdown, semaphore));\n+\n+    // Expire S0 and new session S1 will be created.\n+    ZkTestHelper.asyncExpireSession(manager.getZkClient());\n+\n+    // Wait for onPreConnect to start\n+    semaphore.acquire();\n+\n+    // New session S1 should not be equal to S0.\n+    Assert.assertFalse(originalSessionId.equals(manager.getSessionId()));\n+\n+    // Live instance should be gone as original session S0 is expired.\n+    Assert.assertNull(accessor.getProperty(keyBuilder.liveInstance(instanceName)));\n+\n+    final String lastSessionId = manager.getSessionId();\n+\n+    // Expire S1 when S1 is blocked in onPreConnect().\n+    // New session S2 will be created.\n+    ZkTestHelper.asyncExpireSession(manager.getZkClient());\n+\n+    TestHelper.verify(\n+        () -> !(ZKUtil.toHexSessionId(manager.getZkClient().getSessionId()).equals(lastSessionId)),\n+        3000L);\n+\n+    // New session S2 should not be equal to S1.\n+    final String latestSessionId = ZKUtil.toHexSessionId(manager.getZkClient().getSessionId());\n+    Assert.assertFalse(lastSessionId.equals(latestSessionId));\n+\n+    // Proceed S1 to create live instance, which will fail.\n+    startCountdown.countDown();\n+\n+    // Wait until S1's handling new session is completed.\n+    semaphore.acquire();\n+\n+    // Live instance should not be created because zk session is expired.\n+    Assert.assertNull(accessor.getProperty(keyBuilder.liveInstance(instanceName)),\n+        \"Live instance should not be created because zk session is expired!\");\n+\n+    // Proceed S2 to create live instance.\n+    endCountdown.countDown();\n+\n+    TestHelper.verify(() -> {\n+      // Newly created live instance should be created by the latest session S2\n+      // and have a new creation time.\n+      LiveInstance newLiveInstance =\n+          accessor.getProperty(keyBuilder.liveInstance(instanceName));\n+      return newLiveInstance != null\n+          && newLiveInstance.getStat().getCreationTime() != originalCreationTime\n+          && newLiveInstance.getEphemeralOwner().equals(latestSessionId);\n+    }, 2000L);", "originalCommit": "209aa86d50a5ed19c6dacc74aefc7e9d65f9bed5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI4NjE2NA==", "url": "https://github.com/apache/helix/pull/700#discussion_r370286164", "bodyText": "There is a constant wait time (20 seconds). 20s is kind of too long for this test because if waiting is longer than 2s, the test should definitely fail. But anyway, I will adopt your suggestion to use the constant. Maybe we can add at least one more constant to TestHelper like SHORT_WAIT_DURATION", "author": "huizhilu", "createdAt": "2020-01-23T18:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk2ODIxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3MTc5MA==", "url": "https://github.com/apache/helix/pull/700#discussion_r369971790", "bodyText": "Does this really wait? At this point isn't release() called by S2?", "author": "narendly", "createdAt": "2020-01-23T07:55:40Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestParticipantManager.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+\n+import org.apache.helix.PreConnectCallback;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkTestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestParticipantManager extends ZkTestBase {\n+  private static Logger LOG = LoggerFactory.getLogger(TestParticipantManager.class);\n+\n+  /*\n+   * Simulates zk session expiry before creating live instance in participant manager. This test\n+   * makes sure the session aware create ephemeral API is called.\n+   * What this test does is:\n+   * 1. Sets up live instance with session S0\n+   * 2. Expires S0 and gets new session S1\n+   * 3. S1 is blocked before creating live instance in participant manager\n+   * 4. Expires S1 and gets new session S2\n+   * 5. Proceeds S1 to create live instance, which will fail because session S1 is expired\n+   * 6. Proceeds S2 to create live instance, which will succeed\n+   */\n+  @Test\n+  public void testSessionExpiryCreateLiveInstance() throws Exception {\n+    final String className = TestHelper.getTestClassName();\n+    final String methodName = TestHelper.getTestMethodName();\n+    final String clusterName = className + \"_\" + methodName;\n+\n+    final ZKHelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(ZK_ADDR));\n+    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR,\n+        12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        1, // resources\n+        10, // partitions per resource\n+        5, // number of nodes\n+        3, // replicas\n+        \"MasterSlave\",\n+        true); // do rebalance\n+\n+    final String instanceName = \"localhost_12918\";\n+    final MockParticipantManager manager =\n+        new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+\n+    manager.syncStart();\n+\n+    final LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n+    final long originalCreationTime = liveInstance.getStat().getCreationTime();\n+    final String originalSessionId = manager.getSessionId();\n+\n+    // Verify current live instance.\n+    Assert.assertNotNull(liveInstance);\n+    Assert.assertEquals(liveInstance.getEphemeralOwner(), originalSessionId);\n+\n+    final CountDownLatch startCountdown = new CountDownLatch(1);\n+    final CountDownLatch endCountdown = new CountDownLatch(1);\n+    final Semaphore semaphore = new Semaphore(0);\n+    manager.addPreConnectCallback(\n+        new BlockingPreConnectCallback(instanceName, startCountdown, endCountdown, semaphore));\n+\n+    // Expire S0 and new session S1 will be created.\n+    ZkTestHelper.asyncExpireSession(manager.getZkClient());\n+\n+    // Wait for onPreConnect to start\n+    semaphore.acquire();\n+\n+    // New session S1 should not be equal to S0.\n+    Assert.assertFalse(originalSessionId.equals(manager.getSessionId()));\n+\n+    // Live instance should be gone as original session S0 is expired.\n+    Assert.assertNull(accessor.getProperty(keyBuilder.liveInstance(instanceName)));\n+\n+    final String lastSessionId = manager.getSessionId();\n+\n+    // Expire S1 when S1 is blocked in onPreConnect().\n+    // New session S2 will be created.\n+    ZkTestHelper.asyncExpireSession(manager.getZkClient());\n+\n+    TestHelper.verify(\n+        () -> !(ZKUtil.toHexSessionId(manager.getZkClient().getSessionId()).equals(lastSessionId)),\n+        3000L);\n+\n+    // New session S2 should not be equal to S1.\n+    final String latestSessionId = ZKUtil.toHexSessionId(manager.getZkClient().getSessionId());\n+    Assert.assertFalse(lastSessionId.equals(latestSessionId));\n+\n+    // Proceed S1 to create live instance, which will fail.\n+    startCountdown.countDown();\n+\n+    // Wait until S1's handling new session is completed.\n+    semaphore.acquire();", "originalCommit": "209aa86d50a5ed19c6dacc74aefc7e9d65f9bed5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDI4NDEzNw==", "url": "https://github.com/apache/helix/pull/700#discussion_r370284137", "bodyText": "New sessions are sequentially handled by a single thread: Handling S1 -> S1 completes -> handling S2 -> release by S2. So this really waits if S1 takes time to complete (I've tested it). And it waits until release() is called by S2.\nI realized that my comment was not that clear. I have modified the comment: Wait until S2 starts onPreConnect, which indicates S1's handling new session is completed.", "author": "huizhilu", "createdAt": "2020-01-23T18:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3MTc5MA=="}], "type": "inlineReview"}, {"oid": "435397257c6718dfcc2106949e19e45fa2b6645a", "url": "https://github.com/apache/helix/commit/435397257c6718dfcc2106949e19e45fa2b6645a", "message": "Change wait time and comment.", "committedDate": "2020-01-23T18:37:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwODk2NA==", "url": "https://github.com/apache/helix/pull/700#discussion_r370308964", "bodyText": "Thanks for adding the test!", "author": "lei-xia", "createdAt": "2020-01-23T19:23:21Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestParticipantManager.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package org.apache.helix.manager.zk;\n+", "originalCommit": "435397257c6718dfcc2106949e19e45fa2b6645a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNDEyMQ==", "url": "https://github.com/apache/helix/pull/700#discussion_r370334121", "bodyText": "Sure. I should have added the test in the prior PR #642", "author": "huizhilu", "createdAt": "2020-01-23T20:19:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMwODk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxNzMwMA==", "url": "https://github.com/apache/helix/pull/700#discussion_r370317300", "bodyText": "not only is called, but also validates the session as expected.", "author": "jiajunwang", "createdAt": "2020-01-23T19:41:12Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestParticipantManager.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+\n+import org.apache.helix.PreConnectCallback;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkTestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestParticipantManager extends ZkTestBase {\n+  private static Logger LOG = LoggerFactory.getLogger(TestParticipantManager.class);\n+\n+  /*\n+   * Simulates zk session expiry before creating live instance in participant manager. This test\n+   * makes sure the session aware create ephemeral API is called.", "originalCommit": "435397257c6718dfcc2106949e19e45fa2b6645a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyMzQzOA==", "url": "https://github.com/apache/helix/pull/700#discussion_r370323438", "bodyText": "Validation is done in \"session aware create ephemeral API\"", "author": "huizhilu", "createdAt": "2020-01-23T19:54:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxNzMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyNDQyNA==", "url": "https://github.com/apache/helix/pull/700#discussion_r370324424", "bodyText": "np, just suggest you make the doc more generic. But I don't have a strong preference.", "author": "jiajunwang", "createdAt": "2020-01-23T19:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxNzMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMzNjUwNA==", "url": "https://github.com/apache/helix/pull/700#discussion_r370336504", "bodyText": "Completed. Thanks for carefully reviewing my PR.", "author": "huizhilu", "createdAt": "2020-01-23T20:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxNzMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxOTQzMQ==", "url": "https://github.com/apache/helix/pull/700#discussion_r370319431", "bodyText": "nit, let's just call them sessionOne, sessionTwo.", "author": "jiajunwang", "createdAt": "2020-01-23T19:45:45Z", "path": "helix-core/src/test/java/org/apache/helix/manager/zk/TestParticipantManager.java", "diffHunk": "@@ -0,0 +1,183 @@\n+package org.apache.helix.manager.zk;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Semaphore;\n+\n+import org.apache.helix.PreConnectCallback;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkTestHelper;\n+import org.apache.helix.common.ZkTestBase;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.LiveInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestParticipantManager extends ZkTestBase {\n+  private static Logger LOG = LoggerFactory.getLogger(TestParticipantManager.class);\n+\n+  /*\n+   * Simulates zk session expiry before creating live instance in participant manager. This test\n+   * makes sure the session aware create ephemeral API is called.\n+   * What this test does is:\n+   * 1. Sets up live instance with session S0\n+   * 2. Expires S0 and gets new session S1\n+   * 3. S1 is blocked before creating live instance in participant manager\n+   * 4. Expires S1 and gets new session S2\n+   * 5. Proceeds S1 to create live instance, which will fail because session S1 is expired\n+   * 6. Proceeds S2 to create live instance, which will succeed\n+   */\n+  @Test\n+  public void testSessionExpiryCreateLiveInstance() throws Exception {\n+    final String className = TestHelper.getTestClassName();\n+    final String methodName = TestHelper.getTestMethodName();\n+    final String clusterName = className + \"_\" + methodName;\n+\n+    final ZKHelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(ZK_ADDR));\n+    final PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR,\n+        12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        1, // resources\n+        10, // partitions per resource\n+        5, // number of nodes\n+        3, // replicas\n+        \"MasterSlave\",\n+        true); // do rebalance\n+\n+    final String instanceName = \"localhost_12918\";\n+    final MockParticipantManager manager =\n+        new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+\n+    manager.syncStart();\n+\n+    final LiveInstance liveInstance = accessor.getProperty(keyBuilder.liveInstance(instanceName));\n+    final long originalCreationTime = liveInstance.getStat().getCreationTime();\n+    final String originalSessionId = manager.getSessionId();\n+\n+    // Verify current live instance.\n+    Assert.assertNotNull(liveInstance);\n+    Assert.assertEquals(liveInstance.getEphemeralOwner(), originalSessionId);\n+\n+    final CountDownLatch startCountdown = new CountDownLatch(1);\n+    final CountDownLatch endCountdown = new CountDownLatch(1);\n+    final Semaphore semaphore = new Semaphore(0);\n+    manager.addPreConnectCallback(\n+        new BlockingPreConnectCallback(instanceName, startCountdown, endCountdown, semaphore));\n+\n+    // Expire S0 and new session S1 will be created.\n+    ZkTestHelper.asyncExpireSession(manager.getZkClient());\n+\n+    // Wait for onPreConnect to start\n+    semaphore.acquire();\n+\n+    // New session S1 should not be equal to S0.\n+    Assert.assertFalse(originalSessionId.equals(manager.getSessionId()));\n+\n+    // Live instance should be gone as original session S0 is expired.\n+    Assert.assertNull(accessor.getProperty(keyBuilder.liveInstance(instanceName)));\n+\n+    final String lastSessionId = manager.getSessionId();\n+\n+    // Expire S1 when S1 is blocked in onPreConnect().\n+    // New session S2 will be created.\n+    ZkTestHelper.asyncExpireSession(manager.getZkClient());\n+\n+    TestHelper.verify(\n+        () -> !(ZKUtil.toHexSessionId(manager.getZkClient().getSessionId()).equals(lastSessionId)),\n+        TestHelper.WAIT_DURATION);\n+\n+    // New session S2 should not be equal to S1.\n+    final String latestSessionId = ZKUtil.toHexSessionId(manager.getZkClient().getSessionId());", "originalCommit": "435397257c6718dfcc2106949e19e45fa2b6645a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMyMzQ4OA==", "url": "https://github.com/apache/helix/pull/700#discussion_r370323488", "bodyText": "Done.", "author": "huizhilu", "createdAt": "2020-01-23T19:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDMxOTQzMQ=="}], "type": "inlineReview"}, {"oid": "5f2f050caef8663bef30ccceb7450f2e44658ba3", "url": "https://github.com/apache/helix/commit/5f2f050caef8663bef30ccceb7450f2e44658ba3", "message": "Change session variables in test.", "committedDate": "2020-01-23T19:49:31Z", "type": "commit"}, {"oid": "35e43c0da31d23676d319490df3acc917ec31f58", "url": "https://github.com/apache/helix/commit/35e43c0da31d23676d319490df3acc917ec31f58", "message": "Add comment for session checking.", "committedDate": "2020-01-23T20:23:22Z", "type": "commit"}, {"oid": "35e43c0da31d23676d319490df3acc917ec31f58", "url": "https://github.com/apache/helix/commit/35e43c0da31d23676d319490df3acc917ec31f58", "message": "Add comment for session checking.", "committedDate": "2020-01-23T20:23:22Z", "type": "forcePushed"}]}