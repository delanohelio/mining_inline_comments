{"pr_number": 986, "pr_title": "Adjust the auto rebalancer state assignment logic to reduce top state transition.", "pr_createdAt": "2020-05-01T22:48:13Z", "pr_url": "https://github.com/apache/helix/pull/986", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng==", "url": "https://github.com/apache/helix/pull/986#discussion_r418776796", "bodyText": "I think you already sorted the preference list based on the state. Why not just replace the looping of preference list with the sorted list but add this logic?\nThis logic makes two order of preference list intersected each other that logic is not very clear.", "author": "junkaixue", "createdAt": "2020-05-01T23:21:40Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/AbstractRebalancer.java", "diffHunk": "@@ -305,45 +305,60 @@ public static int getStateCount(String state, StateModelDefinition stateModelDef\n     Set<String> liveAndEnabled = new HashSet<>(liveInstances);\n     liveAndEnabled.removeAll(disabledInstancesForPartition);\n \n-    for (String state : statesPriorityList) {\n-      // Use the the specially ordered preferenceList for choosing instance for top state.\n-      if (state.equals(statesPriorityList.get(0))) {\n-        List<String> preferenceListForTopState = new ArrayList<>(preferenceList);\n-        Collections.sort(preferenceListForTopState,\n-            new TopStatePreferenceListComparator(currentStateMap, stateModelDef));\n-        preferenceList = preferenceListForTopState;\n-      }\n+    // Sort the instances based on replicas' state priority in the current state\n+    List<String> sortedPreferenceList = new ArrayList<>(preferenceList);\n+    sortedPreferenceList.sort(new StatePriorityComparator(currentStateMap, stateModelDef));\n \n+    // Assign the state to the instances that appear in the preference list.\n+    for (String state : statesPriorityList) {\n       int stateCount =\n           getStateCount(state, stateModelDef, liveAndEnabled.size(), preferenceList.size());\n       for (String instance : preferenceList) {\n         if (stateCount <= 0) {\n-          break;\n+          break; // continue assigning for the next state\n+        }\n+        if (assigned.contains(instance) || !liveAndEnabled.contains(instance)) {\n+          continue; // continue checking for the next available instance\n         }\n-        if (!assigned.contains(instance) && liveAndEnabled.contains(instance)) {\n-          if (HelixDefinedState.ERROR.toString().equals(currentStateMap.get(instance))) {\n-            bestPossibleStateMap.put(instance, HelixDefinedState.ERROR.toString());\n-          } else {\n-            bestPossibleStateMap.put(instance, state);\n-            stateCount--;\n+        String proposedInstance = instance;\n+        // Additional check and alternate the assignment for reducing top state handoff.\n+        if (state.equals(stateModelDef.getTopState()) && !stateModelDef.getSecondTopStates()", "originalCommit": "30816eece784e18df6fedc1412a27bf39d6cd9f2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MDY2OA==", "url": "https://github.com/apache/helix/pull/986#discussion_r418780668", "bodyText": "I thought about it. But even I move this logic to the sorting logic, the sorting itself will be comparing one list with 2 logics. This interesting trick is just moved to another place. I don't have a way to eliminate it for now.\nThen why I want to put it here instead of the sorting logic? Because the sorting logic is away from this business logic block. That would be even harder for me to reason even with comments.\nPut it here, I understand it is intersecting the same list, but I can at least give it a good reason.", "author": "jiajunwang", "createdAt": "2020-05-01T23:41:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4MTAwMQ==", "url": "https://github.com/apache/helix/pull/986#discussion_r418781001", "bodyText": "Please consider this as a skiplist type design/implementation.", "author": "jiajunwang", "createdAt": "2020-05-01T23:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk3OTM3NQ==", "url": "https://github.com/apache/helix/pull/986#discussion_r420979375", "bodyText": "I see you point. Purely relies on sorting is fine because the previous author use it in wrong way. We suppose to sort it before looping.\nAnyway, I am OK to keep the current behavior. But can you add a TODO here. To remind that we can refactor the logic based on sorting with comprehensive test in the future?", "author": "junkaixue", "createdAt": "2020-05-06T17:50:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk4OTY3Ng==", "url": "https://github.com/apache/helix/pull/986#discussion_r420989676", "bodyText": "Not exactly. Actually, I don't agree this is a TODO work to put everything in a sorting method. That is just an alternative design, and I don't think it is cleaner than the current one.\nConsidering the proposed universal sorting method, it is actually merging 2 orders (preference list order and the current state order). However, there is no clear way to define the priority score.\nNote the logic here is that if the node is not on secondary state or above but it is attempted to be a master, we should find alternatives according to the current state order.\nThis logic cannot be done with only the 2 orders. We have to know the proposed states assignment. For example, how many top states and where to assign based on the preference state.\nGive this, to merging the sort in one method (instead of the current design), we will need to:\n\npropose a state assignment based on the preference list\ninput this proposed state mapping as one additional input to the sorting method, and then sort accordingly.\ncalculate another state assignment based on the re-sorted list.\n\nIt seems more confusing and slower than the current design.", "author": "jiajunwang", "createdAt": "2020-05-06T18:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEyMjI4NA==", "url": "https://github.com/apache/helix/pull/986#discussion_r421122284", "bodyText": "Hmm. The sorting logic could be complicated. Alright, let's revisit the logic if it requires refactoring later.", "author": "junkaixue", "createdAt": "2020-05-06T22:11:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc3Njc5Ng=="}], "type": "inlineReview"}, {"oid": "89ce5da03d9341174794d00fbb49d914383b7d98", "url": "https://github.com/apache/helix/commit/89ce5da03d9341174794d00fbb49d914383b7d98", "message": "Adjust the auto rebalancer state assignment logic to reduce top state transition.\n\nThe old state assignment logic assign the states to selected nodes according to the priority of the current replica state that is on the instance. Moreover, the sorting algorithm is designed to prioritize both current topstate and current secondary states equally. The result is that we will have premature mastership handoff to a current seconardy state host before the real desired master host is ready. For example,\n1. The current states are: [N1:M, N2:S, N3,S]\n2. The desired states are: [N4:M, N2:S, N1:S]\n3. Due to the sorting logic based on current states, we will have a transient preference list ordered like: [N2, N1, N4]. In which case, the controller will assign master to N2 before N4 has a slave state replica.\n4. When N4 finishes the Offline to Slave transition, the same sorting logic will sort the preference list to be: [N4, N2, N1]. Then we have another mastership handoff.\nTo be clear, we don't want step 3. But only the state transition in step 4.\n\nIn this PR, we refactor the sorting logic so that it will only move the master whenever the candidate has a \"ready\" state replica, in which case, only one mastership handoff happens.", "committedDate": "2020-05-06T22:30:49Z", "type": "commit"}, {"oid": "89ce5da03d9341174794d00fbb49d914383b7d98", "url": "https://github.com/apache/helix/commit/89ce5da03d9341174794d00fbb49d914383b7d98", "message": "Adjust the auto rebalancer state assignment logic to reduce top state transition.\n\nThe old state assignment logic assign the states to selected nodes according to the priority of the current replica state that is on the instance. Moreover, the sorting algorithm is designed to prioritize both current topstate and current secondary states equally. The result is that we will have premature mastership handoff to a current seconardy state host before the real desired master host is ready. For example,\n1. The current states are: [N1:M, N2:S, N3,S]\n2. The desired states are: [N4:M, N2:S, N1:S]\n3. Due to the sorting logic based on current states, we will have a transient preference list ordered like: [N2, N1, N4]. In which case, the controller will assign master to N2 before N4 has a slave state replica.\n4. When N4 finishes the Offline to Slave transition, the same sorting logic will sort the preference list to be: [N4, N2, N1]. Then we have another mastership handoff.\nTo be clear, we don't want step 3. But only the state transition in step 4.\n\nIn this PR, we refactor the sorting logic so that it will only move the master whenever the candidate has a \"ready\" state replica, in which case, only one mastership handoff happens.", "committedDate": "2020-05-06T22:30:49Z", "type": "forcePushed"}]}