{"pr_number": 1129, "pr_title": "Validate instance topology configuration before let it comes online ", "pr_createdAt": "2020-06-29T06:10:45Z", "pr_url": "https://github.com/apache/helix/pull/1129", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MzI5MQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r447263291", "bodyText": "No validation of post results?", "author": "kaisun2000", "createdAt": "2020-06-29T21:25:26Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestPerInstanceAccessor.java", "diffHunk": "@@ -463,5 +464,53 @@ public void testValidateWeightForInstance()\n     // Must have the results saying they are all valid (true) because capacity keys are set\n     // in ClusterConfig\n     node.iterator().forEachRemaining(child -> Assert.assertTrue(child.getBooleanValue()));\n+    System.out.println(\"End test :\" + TestHelper.getTestMethodName());\n+  }\n+\n+  @Test(dependsOnMethods = \"testValidateWeightForInstance\")\n+  public void testValidateDeltaInstanceConfigForUpdate() throws IOException {\n+    System.out.println(\"Start test :\" + TestHelper.getTestMethodName());\n+    // Enable Topology aware for the cluster\n+    ClusterConfig clusterConfig = _configAccessor.getClusterConfig(CLUSTER_NAME);\n+    clusterConfig.getRecord()\n+        .setListField(ClusterConfig.ClusterConfigProperty.INSTANCE_CAPACITY_KEYS.name(),\n+            new ArrayList<>());\n+    clusterConfig.setTopologyAwareEnabled(true);\n+    clusterConfig.setTopology(\"/Rack/Sub-Rack/Host/Instance\");\n+    clusterConfig.setFaultZoneType(\"Host\");\n+    _configAccessor.setClusterConfig(CLUSTER_NAME, clusterConfig);\n+\n+    String instanceName = CLUSTER_NAME + \"localhost_12918\";\n+    InstanceConfig instanceConfig = _configAccessor.getInstanceConfig(CLUSTER_NAME, instanceName);\n+\n+    // Update InstanceConfig with Topology Info\n+    String domain = \"Rack=rack1, Sub-Rack=Sub-Rack1, Host=Host-1\";\n+    ZNRecord record = instanceConfig.getRecord();\n+    record.getSimpleFields().put(InstanceConfig.InstanceConfigProperty.DOMAIN.name(), domain);\n+\n+    // Add these fields by way of \"update\"\n+    Entity entity =\n+        Entity.entity(OBJECT_MAPPER.writeValueAsString(record), MediaType.APPLICATION_JSON_TYPE);\n+    Response response = new JerseyUriRequestBuilder(\n+        \"clusters/{}/instances/{}/configs?command=update&doSanityCheck=true\")\n+        .format(CLUSTER_NAME, INSTANCE_NAME).post(this, entity);\n+    // Check that the fields have been added\n+    Assert.assertEquals(response.getStatus(), 200);\n+    // Check the cluster config is updated\n+    Assert.assertEquals(\n+        _configAccessor.getInstanceConfig(CLUSTER_NAME, instanceName).getDomainAsString(), domain);\n+\n+    // set domain to an invalid value\n+    record.getSimpleFields()\n+        .put(InstanceConfig.InstanceConfigProperty.DOMAIN.name(), \"InvalidDomainValue\");\n+    entity =\n+        Entity.entity(OBJECT_MAPPER.writeValueAsString(record), MediaType.APPLICATION_JSON_TYPE);\n+    // Updating using an invalid domain value should return a non-OK response\n+    new JerseyUriRequestBuilder(\n+        \"clusters/{}/instances/{}/configs?command=update&doSanityCheck=true\")\n+        .expectedReturnStatusCode(Response.Status.INTERNAL_SERVER_ERROR.getStatusCode())\n+        .format(CLUSTER_NAME, INSTANCE_NAME).post(this, entity);", "originalCommit": "b9356d361522a26a897daf5d81d6d951603ed0f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2Mzk1MA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r447263950", "bodyText": "TFTR.\nRespond status code is validated at line 511. Maybe we could validate the exception body/message as well?", "author": "xyuanlu", "createdAt": "2020-06-29T21:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MzI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2NjA2Nw==", "url": "https://github.com/apache/helix/pull/1129#discussion_r447266067", "bodyText": "I see.\nexpectedReturnStatusCode if get not expected code, what will happen? Did it throw an exception?\nBasically, will the 'mvn test' report the test as failure as the Assert failure will do?", "author": "kaisun2000", "createdAt": "2020-06-29T21:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MzI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2NjU1Ng==", "url": "https://github.com/apache/helix/pull/1129#discussion_r447266556", "bodyText": "Yes it will.\nWhen I change the expected status to 200 in line 511 where the actual call returns 500, I got the following assertion error.\njava.lang.AssertionError: \nExpected :200\nActual   :500\n\n\tat org.testng.Assert.fail(Assert.java:89)\n\tat org.testng.Assert.failNotEquals(Assert.java:480)\n\tat org.testng.Assert.assertEquals(Assert.java:118)\n\tat org.testng.Assert.assertEquals(Assert.java:365)\n\tat org.testng.Assert.assertEquals(Assert.java:375)\n\tat org.apache.helix.rest.server.util.JerseyUriRequestBuilder.post(JerseyUriRequestBuilder.java:115)\n\tat org.apache.helix.rest.server.TestPerInstanceAccessor.testValidateDeltaInstanceConfigForUpdate(TestPerInstance\n        ......\n\tat com.intellij.rt.testng.RemoteTestNGStarter.main(RemoteTestNGStarter.java:110)", "author": "xyuanlu", "createdAt": "2020-06-29T21:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MzI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2NDI1Ng==", "url": "https://github.com/apache/helix/pull/1129#discussion_r447264256", "bodyText": "If I understand correctly, we are testing changing instance config domain field via rest. Here, the validation of config is actually executed from rest server side, right?\nCan we add a small comment about the purpose of this test?", "author": "kaisun2000", "createdAt": "2020-06-29T21:27:25Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestPerInstanceAccessor.java", "diffHunk": "@@ -463,5 +464,53 @@ public void testValidateWeightForInstance()\n     // Must have the results saying they are all valid (true) because capacity keys are set\n     // in ClusterConfig\n     node.iterator().forEachRemaining(child -> Assert.assertTrue(child.getBooleanValue()));\n+    System.out.println(\"End test :\" + TestHelper.getTestMethodName());\n+  }\n+\n+  @Test(dependsOnMethods = \"testValidateWeightForInstance\")", "originalCommit": "b9356d361522a26a897daf5d81d6d951603ed0f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg2Nzg0Mw==", "url": "https://github.com/apache/helix/pull/1129#discussion_r447867843", "bodyText": "This is correct. I will update.", "author": "xyuanlu", "createdAt": "2020-06-30T17:43:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2NDI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzU5OQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458423599", "bodyText": "Updated.", "author": "xyuanlu", "createdAt": "2020-07-21T22:23:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2NDI1Ng=="}], "type": "inlineReview"}, {"oid": "73aa108ddddbb2186d76049898472661abd9c98e", "url": "https://github.com/apache/helix/commit/73aa108ddddbb2186d76049898472661abd9c98e", "message": "minor update", "committedDate": "2020-07-15T00:23:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxOTg1NQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r455419855", "bodyText": "Is this sanity check only for topology? If yes, let's name it as topoogy check for the perInstanceAccessor, because the sanity check should also involve the \"HELIX_PORT\" something like that in the simple field.", "author": "junkaixue", "createdAt": "2020-07-15T23:21:22Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/PerInstanceAccessor.java", "diffHunk": "@@ -542,4 +558,23 @@ public Response getHealthReportsOnInstance(\n   private boolean validInstance(JsonNode node, String instanceName) {\n     return instanceName.equals(node.get(Properties.id.name()).getValueAsText());\n   }\n+\n+  private boolean validateDeltaInstanceConfigForUpdate(String clusterName, String instanceName,\n+      ConfigAccessor configAccessor, InstanceConfig newInstanceConfig, boolean isDelete)\n+      throws IllegalArgumentException {\n+    InstanceConfig originalInstanceConfigCopy =\n+        configAccessor.getInstanceConfig(clusterName, instanceName);\n+    if (isDelete) {\n+      for (Map.Entry<String, String> entry : newInstanceConfig.getRecord().getSimpleFields()\n+          .entrySet()) {\n+        originalInstanceConfigCopy.getRecord().getSimpleFields().remove(entry.getKey());\n+      }\n+    } else {\n+      originalInstanceConfigCopy.getRecord().update(newInstanceConfig.getRecord());\n+    }\n+\n+    return ConfigAccessor", "originalCommit": "73aa108ddddbb2186d76049898472661abd9c98e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzk4NA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458423984", "bodyText": "Updated.", "author": "xyuanlu", "createdAt": "2020-07-21T22:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQxOTg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg3OTYzNA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r455879634", "bodyText": "It should be okey to leave it \"instanceConfig\" instead of \"newInstanceConfig\", otherwise, you need to rename this parameter in all other \"set\" or \"update\" related methods to keep them consistent.", "author": "lei-xia", "createdAt": "2020-07-16T15:35:31Z", "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -945,23 +947,23 @@ public void setInstanceConfig(String clusterName, String instanceName,\n    * replaced with the value of the same field in given config if it presents. If there is new field\n    * in given config but not in current config, the field will be added into the current config..\n    * The list fields and map fields will be replaced as a single entry.\n-   * The current Cluster config will be replaced with the given clusterConfig. WARNING: This is not\n+   * The current instanceConfig will be replaced with the given instanceConfig. WARNING: This is not\n    * thread-safe or concurrent updates safe.\n    * *\n    *\n    * @param clusterName\n    * @param instanceName\n-   * @param instanceConfig\n+   * @param newInstanceConfig\n    *\n    * @return\n    */\n   public void updateInstanceConfig(String clusterName, String instanceName,\n-      InstanceConfig instanceConfig) {\n-    updateInstanceConfig(clusterName, instanceName, instanceConfig, false);\n+      InstanceConfig newInstanceConfig) {", "originalCommit": "73aa108ddddbb2186d76049898472661abd9c98e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNDA2Mw==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458424063", "bodyText": "Updated,", "author": "xyuanlu", "createdAt": "2020-07-21T22:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg3OTYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4MzIxMQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r455883211", "bodyText": "Seems this method is not used by ConfigAccessor itself?  My suggestion is put this method into InstanceConfig (or ClusterConfig) and it does not have to be static (it can be called like myInstanceConfig.validateTopologySetting(String clusterTopologyString).", "author": "lei-xia", "createdAt": "2020-07-16T15:40:42Z", "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -1009,4 +1010,19 @@ public ConfigAccessor build() {\n               _zkAddress), false);\n     }\n   }\n+\n+  /**\n+   * Validate if the topology related settings (Domain or ZoneId) in the given instanceConfig\n+   * are valid and align with current clusterConfig.\n+   * This function should be called when instance added to cluster or caller updates instanceConfig.\n+   *\n+   * @throws IllegalArgumentException\n+   */\n+  public static boolean validateTopologySettingInInstanceConfig(ClusterConfig clusterConfig,", "originalCommit": "73aa108ddddbb2186d76049898472661abd9c98e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNDExOA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458424118", "bodyText": "Updated.", "author": "xyuanlu", "createdAt": "2020-07-21T22:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4MzIxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4MzczOA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r455883738", "bodyText": "Is this our new style to format a enum types?", "author": "lei-xia", "createdAt": "2020-07-16T15:41:27Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -43,11 +43,11 @@\n  */\n public class Topology {\n   private static Logger logger = LoggerFactory.getLogger(Topology.class);\n+\n   public enum Types {\n-    ROOT,\n-    ZONE,\n-    INSTANCE\n+    ROOT, ZONE, INSTANCE", "originalCommit": "73aa108ddddbb2186d76049898472661abd9c98e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyMzQ5Nw==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458423497", "bodyText": "I think auto formatter changes this..", "author": "xyuanlu", "createdAt": "2020-07-21T22:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4MzczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4ODU1OQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r460488559", "bodyText": "IntelliJ formats the style. But maybe unnecessary. It is recommended to only format your changes. :)", "author": "huizhilu", "createdAt": "2020-07-26T06:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg4MzczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5MzQxNQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r455893415", "bodyText": "Should we check this also before line 207?", "author": "lei-xia", "createdAt": "2020-07-16T15:55:12Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java", "diffHunk": "@@ -187,26 +187,31 @@ private void joinCluster() {\n       LOG.info(\"auto registration is false for cluster\" + _clusterName);\n     }\n \n+    InstanceConfig instanceConfig;\n     if (!ZKUtil.isInstanceSetup(_zkclient, _clusterName, _instanceName, _instanceType)) {\n       if (!autoJoin) {\n         throw new HelixException(\"Initial cluster structure is not set up for instance: \"\n             + _instanceName + \", instanceType: \" + _instanceType);\n+      }\n+      if (!autoRegistration) {\n+        LOG.info(_instanceName + \" is auto-joining cluster: \" + _clusterName);\n+        instanceConfig = HelixUtil.composeInstanceConfig(_instanceName);\n       } else {\n-        if (!autoRegistration) {\n-          LOG.info(_instanceName + \" is auto-joining cluster: \" + _clusterName);\n-          _helixAdmin.addInstance(_clusterName, HelixUtil.composeInstanceConfig(_instanceName));\n-        } else {\n-          LOG.info(_instanceName + \" is auto-registering cluster: \" + _clusterName);\n-          CloudInstanceInformation cloudInstanceInformation = getCloudInstanceInformation();\n-          String domain = cloudInstanceInformation\n-              .get(CloudInstanceInformation.CloudInstanceField.FAULT_DOMAIN.name()) + _instanceName;\n-\n-          InstanceConfig instanceConfig = HelixUtil.composeInstanceConfig(_instanceName);\n-          instanceConfig.setDomain(domain);\n-          _helixAdmin.addInstance(_clusterName, instanceConfig);\n-        }\n+        LOG.info(_instanceName + \" is auto-registering cluster: \" + _clusterName);\n+        CloudInstanceInformation cloudInstanceInformation = getCloudInstanceInformation();\n+        String domain = cloudInstanceInformation\n+            .get(CloudInstanceInformation.CloudInstanceField.FAULT_DOMAIN.name()) + _instanceName;\n+        instanceConfig = HelixUtil.composeInstanceConfig(_instanceName);\n+        instanceConfig.setDomain(domain);\n       }\n+      _helixAdmin.addInstance(_clusterName, instanceConfig);\n+    } else {\n+      ConfigAccessor.validateTopologySettingInInstanceConfig(\n+          _configAccessor.getClusterConfig(_clusterName), _instanceName,\n+          _configAccessor.getInstanceConfig(_clusterName,_instanceName));", "originalCommit": "73aa108ddddbb2186d76049898472661abd9c98e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNDc2NA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458424764", "bodyText": "The InstanceConfig is autogenerated for that branch before line 207. Do we also need to check that as well?", "author": "xyuanlu", "createdAt": "2020-07-21T22:26:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5MzQxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5NTkyNA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r455895924", "bodyText": "My suggestion is to set doSanityCheck's default value being true, i.e, we should always validate the instance config unless it is explicitly override to not doing so.", "author": "lei-xia", "createdAt": "2020-07-16T15:58:46Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/PerInstanceAccessor.java", "diffHunk": "@@ -287,6 +288,7 @@ public Response getInstanceConfig(@PathParam(\"clusterId\") String clusterId,\n   @Path(\"configs\")\n   public Response updateInstanceConfig(@PathParam(\"clusterId\") String clusterId,\n       @PathParam(\"instanceName\") String instanceName, @QueryParam(\"command\") String commandStr,\n+      @DefaultValue(\"false\") @QueryParam(\"doSanityCheck\") boolean doSanityCheck,", "originalCommit": "73aa108ddddbb2186d76049898472661abd9c98e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQyNTAzOA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458425038", "bodyText": "Updated.", "author": "xyuanlu", "createdAt": "2020-07-21T22:27:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5NTkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg5Njc3NQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r455896775", "bodyText": "If possible, let us return some useful error information to the caller, for example, where is the format error, such as \"Invalid topology setting\", etc.", "author": "lei-xia", "createdAt": "2020-07-16T16:00:02Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/PerInstanceAccessor.java", "diffHunk": "@@ -308,19 +310,33 @@ public Response updateInstanceConfig(@PathParam(\"clusterId\") String clusterId,\n     }\n     InstanceConfig instanceConfig = new InstanceConfig(record);\n     ConfigAccessor configAccessor = getConfigAccessor();\n+\n+    if (doSanityCheck && (command == Command.delete || command == Command.update)) {\n+      try {\n+        validateDeltaInstanceConfigForUpdate(clusterId, instanceName, configAccessor,\n+            instanceConfig, command == Command.delete);\n+      } catch (IllegalArgumentException ex) {\n+        LOG.error(\n+            String.format(\"Error in update instance config for instance: %s\", instanceName),\n+            ex);\n+        return serverError(ex);", "originalCommit": "73aa108ddddbb2186d76049898472661abd9c98e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkxNDI3NA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r455914274", "bodyText": "Using input parameters to populate output values is generally not a best practice, maybe fine given this is just private method. But let us see if we find a better way to return these values.", "author": "lei-xia", "createdAt": "2020-07-16T16:25:58Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -230,16 +220,57 @@ private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceNa\n         || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n   }\n \n+  /**\n+   * Populate clusterTopologyKeys and defaultDomainPathValues from clusterConfig\n+   *\n+   * @param clusterTopologyKeys       out parameter. LinkedHashSet to be populated for cluster\n+   *                                  topology keys. The set will remain empty if topology aware is\n+   *                                  not enabled or this cluster uses zone instead of domains.\n+   * @param defaultDomainPathValues   out parameter. Map to be populated for all default path keys.\n+   *                                  The map will remain empty if topology aware is not enabled or\n+   *                                  this cluster uses zone instead of domains.\n+   * @return lastValidType in clusterConfig.topology\n+   */\n+  private static String populateClusterTopologySetting(ClusterConfig clusterConfig,\n+      LinkedHashSet<String> clusterTopologyKeys /*OUT*/,\n+      Map<String, String> defaultDomainPathValues /*OUT*/) {", "originalCommit": "73aa108ddddbb2186d76049898472661abd9c98e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3Nzg1OA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458477858", "bodyText": "Updated.", "author": "xyuanlu", "createdAt": "2020-07-22T01:18:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkxNDI3NA=="}], "type": "inlineReview"}, {"oid": "aad37318e96e9d0a695ba2481d63898e0c00df69", "url": "https://github.com/apache/helix/commit/aad37318e96e9d0a695ba2481d63898e0c00df69", "message": "address comment. refactor Topology.java", "committedDate": "2020-07-19T19:04:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NDQyMQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458464421", "bodyText": "I believe you meant to call computeInstanceTopologyMap() with a false in the end here, instead of the concrete function itself?", "author": "NealSun96", "createdAt": "2020-07-22T00:29:00Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -204,8 +172,9 @@ private Node createClusterTree() {\n       InstanceConfig insConfig = _instanceConfigMap.get(instanceName);\n       try {\n         LinkedHashMap<String, String> instanceTopologyMap =\n-            computeInstanceTopologyMap(_clusterConfig.isTopologyAwareEnabled(), instanceName,\n-                insConfig, _clusterTopologyKeys);\n+            computeInstanceTopologyMapHelper(_clusterConfig.isTopologyAwareEnabled(), instanceName,", "originalCommit": "aad37318e96e9d0a695ba2481d63898e0c00df69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4NTU0OA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458485548", "bodyText": "TFTR. I think computeInstanceTopologyMap for users outside this function. They need to call 'computeInstanceTopologyMap' to construct the 'clusterTopologyConfig' (line 323) first and then build the instance topology path. Here in Topology it self, the 'clusterTopologyConfig' is computed in the constructor. So we need another layer of abstraction.\nI am open to discussion.", "author": "xyuanlu", "createdAt": "2020-07-22T01:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NDQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NTQ2Ng==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458945466", "bodyText": "I see. Typically if a concrete function involves a null value, such as this case, it usually isn't called directly by outside callers and is only called by its wrapper. I'm not 100% certain with the convention here so I'll leave it to you to decide. Thank you for explaining!", "author": "NealSun96", "createdAt": "2020-07-22T17:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NDQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NDcxNQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458464715", "bodyText": "This comment should be for computeInstanceTopologyMap()? That public function needs an entire javadoc also.", "author": "NealSun96", "createdAt": "2020-07-22T00:30:01Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -230,20 +199,73 @@ private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceNa\n         || !clusterConfig.getDisabledInstances().containsKey(instanceName)));\n   }\n \n+  /**\n+   * Populate faultZone, endNodetype and and a LinkedHashMap containing pathKeys default values for\n+   * clusterConfig.Topology. The LinkedHashMap will be empty if clusterConfig.Topology is unset.\n+   *\n+   * @return an Instance of Topology.ClusterTopologyConfig.\n+   */\n+  private static ClusterTopologyConfig getClusterTopologySetting(ClusterConfig clusterConfig) {\n+\n+    ClusterTopologyConfig clusterTopologyConfig = new ClusterTopologyConfig();\n+    if (clusterConfig.isTopologyAwareEnabled()) {\n+      String topologyDef = clusterConfig.getTopology();\n+      if (topologyDef != null) {\n+        String[] topologyKeys = topologyDef.trim().split(\"/\");\n+        int lastValidTypeIdx = 0;\n+        for (int i = 0; i < topologyKeys.length; i++) {\n+          if (topologyKeys[i].length() != 0) {\n+            clusterTopologyConfig.topologyKeyDefaultValue\n+                .put(topologyKeys[i], DEFAULT_DOMAIN_PREFIX + topologyKeys[i]);\n+            lastValidTypeIdx = i;\n+          }\n+        }\n+        if (clusterTopologyConfig.topologyKeyDefaultValue.size() == 0) {\n+          throw new IllegalArgumentException(\"Invalid cluster topology definition \" + topologyDef);\n+        }\n+        clusterTopologyConfig.endNodeType = topologyKeys[lastValidTypeIdx];\n+        String faultZoneType = clusterConfig.getFaultZoneType();\n+        if (faultZoneType == null) {\n+          clusterTopologyConfig.faultZoneType = clusterTopologyConfig.endNodeType;\n+        } else if (!clusterTopologyConfig.topologyKeyDefaultValue.containsKey(faultZoneType)) {\n+          throw new HelixException(String\n+              .format(\"Invalid fault zone type %s, not present in topology definition %s.\",\n+                  faultZoneType, clusterConfig.getTopology()));\n+        } else {\n+          clusterTopologyConfig.faultZoneType = faultZoneType;\n+        }\n+      } else {\n+        // Use default cluster topology definition, i,e. /root/zone/instance\n+        clusterTopologyConfig.endNodeType = Types.INSTANCE.name();\n+        clusterTopologyConfig.faultZoneType = Types.ZONE.name();\n+      }\n+    } else {\n+      clusterTopologyConfig.endNodeType = Types.INSTANCE.name();\n+      clusterTopologyConfig.faultZoneType = Types.INSTANCE.name();\n+    }\n+    return clusterTopologyConfig;\n+  }\n+\n   /**\n    * This function returns a LinkedHashMap<String, String> object representing\n    * the topology path for an instance.\n    * LinkedHashMap is used here since the order of the path needs to be preserved\n    * when creating the topology tree.\n    *\n+   * @param clusterTopologyKeyDefaultValue  a LinkedHashMap where keys are cluster topology path and\n+   *                                       values are their corresponding default value. The entries\n+   *                                        are ordered by ClusterConfig.topology setting.\n+   * @param faultZoneForEarlyQuit   this flag is set to true only if caller wants the path", "originalCommit": "aad37318e96e9d0a695ba2481d63898e0c00df69", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4OTEyOQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r458489129", "bodyText": "TFTR. Updated.", "author": "xyuanlu", "createdAt": "2020-07-22T01:59:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NDcxNQ=="}], "type": "inlineReview"}, {"oid": "754256a84b459ff9feb086eaf7ce68670f93b858", "url": "https://github.com/apache/helix/commit/754256a84b459ff9feb086eaf7ce68670f93b858", "message": "addresss comment", "committedDate": "2020-07-22T01:55:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4ODIzNA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r460488234", "bodyText": "Seems this import is unused?", "author": "huizhilu", "createdAt": "2020-07-26T06:54:13Z", "path": "helix-core/src/main/java/org/apache/helix/ConfigAccessor.java", "diffHunk": "@@ -20,14 +20,17 @@\n  */\n \n import java.io.IOException;\n+import java.security.InvalidParameterException;", "originalCommit": "754256a84b459ff9feb086eaf7ce68670f93b858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk2NjM4MQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r461966381", "bodyText": "TFTR. Updated.", "author": "xyuanlu", "createdAt": "2020-07-29T00:19:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4ODIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4OTAyNQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r460489025", "bodyText": "Usually runtime exception is not recommended to put in method signature. Having it in java doc is good enough.", "author": "huizhilu", "createdAt": "2020-07-26T07:01:48Z", "path": "helix-core/src/main/java/org/apache/helix/model/InstanceConfig.java", "diffHunk": "@@ -637,4 +638,19 @@ public static InstanceConfig toInstanceConfig(String instanceId) {\n     }\n     return config;\n   }\n+\n+  /**\n+   * Validate if the topology related settings (Domain or ZoneId) in the given instanceConfig\n+   * are valid and align with current clusterConfig.\n+   * This function should be called when instance added to cluster or caller updates instanceConfig.\n+   *\n+   * @throws IllegalArgumentException\n+   */\n+  public boolean validateTopologySettingInInstanceConfig(ClusterConfig clusterConfig,\n+      String instanceName) throws IllegalArgumentException{", "originalCommit": "754256a84b459ff9feb086eaf7ce68670f93b858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4OTEzMw==", "url": "https://github.com/apache/helix/pull/1129#discussion_r460489133", "bodyText": "Assert fail here to protect the test. Otherwise if expecting exception is not throw, the test will still pass. It should fail.", "author": "huizhilu", "createdAt": "2020-07-26T07:03:33Z", "path": "helix-core/src/test/java/org/apache/helix/integration/manager/TestParticipantManager.java", "diffHunk": "@@ -114,6 +118,50 @@ public void simpleIntegrationTest() throws Exception {\n     Assert.assertNull(accessor.getProperty(keyBuilder.controllerLeader()));\n   }\n \n+  @Test\n+  public void simpleIntegrationTestNeg() throws Exception {\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        1, // resources\n+        4, // partitions per resource\n+        1, // number of nodes\n+        1, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ConfigAccessor configAccessor = new ConfigAccessor(_gZkClient);\n+    ClusterConfig clusterConfig = configAccessor.getClusterConfig(clusterName);\n+    clusterConfig.getRecord()\n+        .setListField(ClusterConfig.ClusterConfigProperty.INSTANCE_CAPACITY_KEYS.name(),\n+            new ArrayList<>());\n+    clusterConfig.setTopologyAwareEnabled(true);\n+    clusterConfig.setTopology(\"/Rack/Sub-Rack/Host/Instance\");\n+    clusterConfig.setFaultZoneType(\"Host\");\n+    configAccessor.setClusterConfig(clusterName, clusterConfig);\n+\n+\n+    String instanceName = \"localhost_12918\";\n+    HelixManager participant =\n+        new ZKHelixManager(clusterName, instanceName , InstanceType.PARTICIPANT, ZK_ADDR);\n+    participant.getStateMachineEngine().registerStateModelFactory(\"MasterSlave\",\n+        new MockMSModelFactory());\n+    // We are expecting an IllegalArgumentException since the domain is not set.\n+    try {\n+      participant.connect();", "originalCommit": "754256a84b459ff9feb086eaf7ce68670f93b858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MDIxNA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r460490214", "bodyText": "I suggest changing the method signature a bit: boolean isDelete -> Command command. You could put if..else check in this private method.\nAn nice article to help with clean such boolean parameter : https://medium.com/@amlcurran/clean-code-the-curse-of-a-boolean-parameter-c237a830b7a3", "author": "huizhilu", "createdAt": "2020-07-26T07:15:01Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/PerInstanceAccessor.java", "diffHunk": "@@ -308,20 +309,34 @@ public Response updateInstanceConfig(@PathParam(\"clusterId\") String clusterId,\n     }\n     InstanceConfig instanceConfig = new InstanceConfig(record);\n     ConfigAccessor configAccessor = getConfigAccessor();\n+\n     try {\n+      /*\n+       * Even if the instance is disabled, non-valid instance topology config will cause rebalance\n+       * failure. We are doing the check whenever user updates InstanceConfig.\n+       */\n+      if (command == Command.delete || command == Command.update) {\n+        validateDeltaTopologySettingInInstanceConfig(clusterId, instanceName, configAccessor,", "originalCommit": "754256a84b459ff9feb086eaf7ce68670f93b858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ5MDM2NA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r460490364", "bodyText": "Could make advantage of parameterized logging :)\nLOG.error(\"Invalid topology setting for Instance : {}\", instanceName, ex);", "author": "huizhilu", "createdAt": "2020-07-26T07:16:26Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/PerInstanceAccessor.java", "diffHunk": "@@ -308,20 +309,34 @@ public Response updateInstanceConfig(@PathParam(\"clusterId\") String clusterId,\n     }\n     InstanceConfig instanceConfig = new InstanceConfig(record);\n     ConfigAccessor configAccessor = getConfigAccessor();\n+\n     try {\n+      /*\n+       * Even if the instance is disabled, non-valid instance topology config will cause rebalance\n+       * failure. We are doing the check whenever user updates InstanceConfig.\n+       */\n+      if (command == Command.delete || command == Command.update) {\n+        validateDeltaTopologySettingInInstanceConfig(clusterId, instanceName, configAccessor,\n+            instanceConfig, command == Command.delete);\n+      }\n       switch (command) {\n-      case update:\n-        configAccessor.updateInstanceConfig(clusterId, instanceName, instanceConfig);\n-        break;\n-      case delete:\n-        HelixConfigScope instanceScope =\n-            new HelixConfigScopeBuilder(HelixConfigScope.ConfigScopeProperty.PARTICIPANT)\n-                .forCluster(clusterId).forParticipant(instanceName).build();\n-        configAccessor.remove(instanceScope, record);\n-        break;\n-      default:\n-        return badRequest(String.format(\"Unsupported command: %s\", command));\n+        case update:\n+          // The new instanceConfig will be merged with existing one\n+          configAccessor.updateInstanceConfig(clusterId, instanceName, instanceConfig);\n+          break;\n+        case delete:\n+          HelixConfigScope instanceScope =\n+              new HelixConfigScopeBuilder(HelixConfigScope.ConfigScopeProperty.PARTICIPANT)\n+                  .forCluster(clusterId).forParticipant(instanceName).build();\n+          configAccessor.remove(instanceScope, record);\n+          break;\n+        default:\n+          return badRequest(String.format(\"Unsupported command: %s\", command));\n       }\n+    } catch (IllegalArgumentException ex) {\n+      LOG.error(String.format(\"Invalid topology setting for Instance : %s. Fail the config update\",", "originalCommit": "754256a84b459ff9feb086eaf7ce68670f93b858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cfe1c47d76af94007c4b87d915b592129ff9b7ac", "url": "https://github.com/apache/helix/commit/cfe1c47d76af94007c4b87d915b592129ff9b7ac", "message": "address comments", "committedDate": "2020-07-28T23:02:10Z", "type": "forcePushed"}, {"oid": "d69d0c454036cbeb16343c233187fa92f4952c06", "url": "https://github.com/apache/helix/commit/d69d0c454036cbeb16343c233187fa92f4952c06", "message": "address comments", "committedDate": "2020-07-28T23:08:58Z", "type": "forcePushed"}, {"oid": "471064a8a037cdac30b18595d419a3dac8bdcf76", "url": "https://github.com/apache/helix/commit/471064a8a037cdac30b18595d419a3dac8bdcf76", "message": "address comments", "committedDate": "2020-07-28T23:10:01Z", "type": "forcePushed"}, {"oid": "59da1aa03b2d662d62a5c29d2e34b0fda59ed07d", "url": "https://github.com/apache/helix/commit/59da1aa03b2d662d62a5c29d2e34b0fda59ed07d", "message": "address comments", "committedDate": "2020-07-28T23:11:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzODkxNg==", "url": "https://github.com/apache/helix/pull/1129#discussion_r462538916", "bodyText": "I suggest not throwing IllegalArgumentException in the method signature because: an unchecked exception does not need to declare in the method signature. throws keyword is used for handling checked exception. There are some good articles about this, eg: https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html#throwstag\nI suggest put this info in javadoc like this\n@throws IllegalArugmentException  when it is thrown", "author": "huizhilu", "createdAt": "2020-07-29T19:34:00Z", "path": "helix-core/src/main/java/org/apache/helix/controller/rebalancer/topology/Topology.java", "diffHunk": "@@ -289,6 +310,29 @@ private boolean isInstanceEnabled(ClusterConfig clusterConfig, String instanceNa\n     return instanceTopologyMap;\n   }\n \n+  /**\n+   * This function returns a LinkedHashMap<String, String> object representing\n+   * the topology path for an instance.\n+   * LinkedHashMap is used here since the order of the path needs to be preserved\n+   * when creating the topology tree.\n+   *\n+   * @param clusterConfig         clusterConfig of the given cluster.\n+   * @param instanceName          name of the instance.\n+   * @param instanceConfig        instanceConfig to be checked.\n+   * @param earlyQuitForFaultZone Set to true if we only need the path till faultZone.\n+   *\n+   * @return an LinkedHashMap object representing the topology path for the input instance.\n+   */\n+  public static LinkedHashMap<String, String> computeInstanceTopologyMap(\n+      ClusterConfig clusterConfig, String instanceName, InstanceConfig instanceConfig,\n+      boolean earlyQuitForFaultZone) throws IllegalArgumentException {", "originalCommit": "59da1aa03b2d662d62a5c29d2e34b0fda59ed07d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MTQ5NA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r462651494", "bodyText": "TFTR. Updated.", "author": "xyuanlu", "createdAt": "2020-07-29T23:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjUzODkxNg=="}], "type": "inlineReview"}, {"oid": "094d77517a741f58c41620910bd8813d9178eedb", "url": "https://github.com/apache/helix/commit/094d77517a741f58c41620910bd8813d9178eedb", "message": "Address comment", "committedDate": "2020-07-29T21:21:51Z", "type": "forcePushed"}, {"oid": "8e7a47458e3615fb78fece4b276a830eb49ed34b", "url": "https://github.com/apache/helix/commit/8e7a47458e3615fb78fece4b276a830eb49ed34b", "message": "--amend", "committedDate": "2020-07-31T02:01:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3Mjg2MQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r467272861", "bodyText": "Why we dont call this in the switch case? It will make the code more clear. By doing that, you can let this validateDeltaTopologySettingInInstanceConfig, return a Config if it is valid. Otherwise, return null.\nSo the following code will based on the return result to do the write to ZK.", "author": "junkaixue", "createdAt": "2020-08-07T21:18:03Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/PerInstanceAccessor.java", "diffHunk": "@@ -308,20 +309,34 @@ public Response updateInstanceConfig(@PathParam(\"clusterId\") String clusterId,\n     }\n     InstanceConfig instanceConfig = new InstanceConfig(record);\n     ConfigAccessor configAccessor = getConfigAccessor();\n+\n     try {\n+      /*\n+       * Even if the instance is disabled, non-valid instance topology config will cause rebalance\n+       * failure. We are doing the check whenever user updates InstanceConfig.\n+       */\n+      if (command == Command.delete || command == Command.update) {\n+        validateDeltaTopologySettingInInstanceConfig(clusterId, instanceName, configAccessor,", "originalCommit": "8e7a47458e3615fb78fece4b276a830eb49ed34b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3MzQ2OQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r467273469", "bodyText": "Why we dont validate it before we write to ZK?", "author": "junkaixue", "createdAt": "2020-08-07T21:19:46Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java", "diffHunk": "@@ -187,26 +187,28 @@ private void joinCluster() {\n       LOG.info(\"auto registration is false for cluster\" + _clusterName);\n     }\n \n+    InstanceConfig instanceConfig;\n     if (!ZKUtil.isInstanceSetup(_zkclient, _clusterName, _instanceName, _instanceType)) {\n       if (!autoJoin) {\n         throw new HelixException(\"Initial cluster structure is not set up for instance: \"\n             + _instanceName + \", instanceType: \" + _instanceType);\n+      }\n+      if (!autoRegistration) {\n+        LOG.info(_instanceName + \" is auto-joining cluster: \" + _clusterName);\n+        instanceConfig = HelixUtil.composeInstanceConfig(_instanceName);\n       } else {\n-        if (!autoRegistration) {\n-          LOG.info(_instanceName + \" is auto-joining cluster: \" + _clusterName);\n-          _helixAdmin.addInstance(_clusterName, HelixUtil.composeInstanceConfig(_instanceName));\n-        } else {\n-          LOG.info(_instanceName + \" is auto-registering cluster: \" + _clusterName);\n-          CloudInstanceInformation cloudInstanceInformation = getCloudInstanceInformation();\n-          String domain = cloudInstanceInformation\n-              .get(CloudInstanceInformation.CloudInstanceField.FAULT_DOMAIN.name()) + _instanceName;\n-\n-          InstanceConfig instanceConfig = HelixUtil.composeInstanceConfig(_instanceName);\n-          instanceConfig.setDomain(domain);\n-          _helixAdmin.addInstance(_clusterName, instanceConfig);\n-        }\n+        LOG.info(_instanceName + \" is auto-registering cluster: \" + _clusterName);\n+        CloudInstanceInformation cloudInstanceInformation = getCloudInstanceInformation();\n+        String domain = cloudInstanceInformation\n+            .get(CloudInstanceInformation.CloudInstanceField.FAULT_DOMAIN.name()) + _instanceName;\n+        instanceConfig = HelixUtil.composeInstanceConfig(_instanceName);\n+        instanceConfig.setDomain(domain);\n       }\n+      _helixAdmin.addInstance(_clusterName, instanceConfig);\n     }\n+    _configAccessor.getInstanceConfig(_clusterName, _instanceName)\n+        .validateTopologySettingInInstanceConfig(_configAccessor.getClusterConfig(_clusterName),", "originalCommit": "8e7a47458e3615fb78fece4b276a830eb49ed34b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b78f65ccac03935cab135b1c28fd758ccaa9baa3", "url": "https://github.com/apache/helix/commit/b78f65ccac03935cab135b1c28fd758ccaa9baa3", "message": "--amend", "committedDate": "2020-08-08T02:06:24Z", "type": "forcePushed"}, {"oid": "8498bc03bbb64284910a31c64fb7371f25d8b98e", "url": "https://github.com/apache/helix/commit/8498bc03bbb64284910a31c64fb7371f25d8b98e", "message": "address comment", "committedDate": "2020-08-08T05:45:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0NDIxOA==", "url": "https://github.com/apache/helix/pull/1129#discussion_r467644218", "bodyText": "If the autoRegistration is false, but the autoJoin is true, then the instance config will be populated without zone information. In this case, will the validation fail? If it fails, meaning that we don't allow customers to use autoJoin if it's rack aware. This is different from what we provide now. Just make sure this is the behavior you want.", "author": "zhangmeng916", "createdAt": "2020-08-09T23:49:51Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/ParticipantManager.java", "diffHunk": "@@ -187,25 +187,31 @@ private void joinCluster() {\n       LOG.info(\"auto registration is false for cluster\" + _clusterName);\n     }\n \n+    InstanceConfig instanceConfig;\n     if (!ZKUtil.isInstanceSetup(_zkclient, _clusterName, _instanceName, _instanceType)) {\n       if (!autoJoin) {\n         throw new HelixException(\"Initial cluster structure is not set up for instance: \"\n             + _instanceName + \", instanceType: \" + _instanceType);\n+      }\n+      if (!autoRegistration) {\n+        LOG.info(_instanceName + \" is auto-joining cluster: \" + _clusterName);\n+        instanceConfig = HelixUtil.composeInstanceConfig(_instanceName);\n       } else {\n-        if (!autoRegistration) {\n-          LOG.info(_instanceName + \" is auto-joining cluster: \" + _clusterName);\n-          _helixAdmin.addInstance(_clusterName, HelixUtil.composeInstanceConfig(_instanceName));\n-        } else {\n-          LOG.info(_instanceName + \" is auto-registering cluster: \" + _clusterName);\n-          CloudInstanceInformation cloudInstanceInformation = getCloudInstanceInformation();\n-          String domain = cloudInstanceInformation\n-              .get(CloudInstanceInformation.CloudInstanceField.FAULT_DOMAIN.name()) + _instanceName;\n-\n-          InstanceConfig instanceConfig = HelixUtil.composeInstanceConfig(_instanceName);\n-          instanceConfig.setDomain(domain);\n-          _helixAdmin.addInstance(_clusterName, instanceConfig);\n-        }\n+        LOG.info(_instanceName + \" is auto-registering cluster: \" + _clusterName);\n+        CloudInstanceInformation cloudInstanceInformation = getCloudInstanceInformation();\n+        String domain = cloudInstanceInformation\n+            .get(CloudInstanceInformation.CloudInstanceField.FAULT_DOMAIN.name()) + _instanceName;\n+        instanceConfig = HelixUtil.composeInstanceConfig(_instanceName);\n+        instanceConfig.setDomain(domain);\n       }\n+      instanceConfig\n+          .validateTopologySettingInInstanceConfig(_configAccessor.getClusterConfig(_clusterName),", "originalCommit": "8498bc03bbb64284910a31c64fb7371f25d8b98e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE4ODE1MQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r468188151", "bodyText": "Discussed offline. This validation here means that we won't support a customer to use zone based topology and \"auto join\" function (no auto registration) at the same time. Participant will terminate in this case. This is different from current requirement, but logically correct.", "author": "zhangmeng916", "createdAt": "2020-08-10T21:11:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0NDIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNzk4NQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r468237985", "bodyText": "Thanks for the update Meng. I would like to add a point.\nI think if the autoRegistration is false, we only support Instance autoJoin if cluster level topology aware rebalance is set up false. If the cluster level topology aware is not false, then the following validation will fail (and vice versa).", "author": "xyuanlu", "createdAt": "2020-08-10T23:20:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzY0NDIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTAwMQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r468179001", "bodyText": "Do we need a if statement here?", "author": "junkaixue", "createdAt": "2020-08-10T20:52:22Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/PerInstanceAccessor.java", "diffHunk": "@@ -310,20 +311,34 @@ public Response updateInstanceConfig(@PathParam(\"clusterId\") String clusterId,\n     }\n     InstanceConfig instanceConfig = new InstanceConfig(record);\n     ConfigAccessor configAccessor = getConfigAccessor();\n+\n     try {\n       switch (command) {\n-      case update:\n-        configAccessor.updateInstanceConfig(clusterId, instanceName, instanceConfig);\n-        break;\n-      case delete:\n-        HelixConfigScope instanceScope =\n-            new HelixConfigScopeBuilder(HelixConfigScope.ConfigScopeProperty.PARTICIPANT)\n-                .forCluster(clusterId).forParticipant(instanceName).build();\n-        configAccessor.remove(instanceScope, record);\n-        break;\n-      default:\n-        return badRequest(String.format(\"Unsupported command: %s\", command));\n+        case update:\n+          /*\n+           * The new instanceConfig will be merged with existing one.\n+           * Even if the instance is disabled, non-valid instance topology config will cause rebalance\n+           * failure. We are doing the check whenever user updates InstanceConfig.\n+           */\n+          validateDeltaTopologySettingInInstanceConfig(clusterId, instanceName, configAccessor,\n+              instanceConfig, command);\n+          configAccessor.updateInstanceConfig(clusterId, instanceName, instanceConfig);\n+          break;\n+        case delete:\n+          validateDeltaTopologySettingInInstanceConfig(clusterId, instanceName, configAccessor,", "originalCommit": "8498bc03bbb64284910a31c64fb7371f25d8b98e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI0MjM1NQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r468242355", "bodyText": "validateDeltaTopologySettingInInstanceConfig will throw exception if the input is not valid. So If I understand it correctly, no need to have a if statement here. Maybe a comment is needed to avoid confusion?", "author": "xyuanlu", "createdAt": "2020-08-10T23:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc2NzYzMg==", "url": "https://github.com/apache/helix/pull/1129#discussion_r468767632", "bodyText": "Then let's modify the function definition and internal logic. It returns boolean value will be useless.", "author": "junkaixue", "createdAt": "2020-08-11T18:05:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODc3MjIwMQ==", "url": "https://github.com/apache/helix/pull/1129#discussion_r468772201", "bodyText": "TFTR. Updated.  Let me rerun the test and finalize.", "author": "xyuanlu", "createdAt": "2020-08-11T18:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3OTAwMQ=="}], "type": "inlineReview"}, {"oid": "acf174c28914aba7f3f164ac3bbe0bb299bd6265", "url": "https://github.com/apache/helix/commit/acf174c28914aba7f3f164ac3bbe0bb299bd6265", "message": "address comment", "committedDate": "2020-08-11T18:12:06Z", "type": "forcePushed"}, {"oid": "e1352ca2d9a758ccf2817e781cb77b032428cb19", "url": "https://github.com/apache/helix/commit/e1352ca2d9a758ccf2817e781cb77b032428cb19", "message": "add sanity check before adding and updating an instance", "committedDate": "2020-08-11T20:32:54Z", "type": "commit"}, {"oid": "a9936750a9a7a3e8d5f794803d0b2fdaa8dccaa4", "url": "https://github.com/apache/helix/commit/a9936750a9a7a3e8d5f794803d0b2fdaa8dccaa4", "message": "add test", "committedDate": "2020-08-11T20:32:54Z", "type": "commit"}, {"oid": "1873131c63cb7c20c6d70108065a3d787c14be44", "url": "https://github.com/apache/helix/commit/1873131c63cb7c20c6d70108065a3d787c14be44", "message": "minor update", "committedDate": "2020-08-11T20:32:54Z", "type": "commit"}, {"oid": "55d3b6cccd0bd4574692b1702a447e521871773b", "url": "https://github.com/apache/helix/commit/55d3b6cccd0bd4574692b1702a447e521871773b", "message": "address comment. refactor Topology.java", "committedDate": "2020-08-11T20:32:54Z", "type": "commit"}, {"oid": "2746715b1df34a5654bfee03aa701090403e64b5", "url": "https://github.com/apache/helix/commit/2746715b1df34a5654bfee03aa701090403e64b5", "message": "addresss comment", "committedDate": "2020-08-11T20:32:54Z", "type": "commit"}, {"oid": "194eb7a7cfc983ac80e542a849b08507e9e6c12e", "url": "https://github.com/apache/helix/commit/194eb7a7cfc983ac80e542a849b08507e9e6c12e", "message": "address comments", "committedDate": "2020-08-11T20:32:54Z", "type": "commit"}, {"oid": "7d117b28452576219027075a98a1b9099da9b769", "url": "https://github.com/apache/helix/commit/7d117b28452576219027075a98a1b9099da9b769", "message": "Address comment", "committedDate": "2020-08-11T20:32:54Z", "type": "commit"}, {"oid": "297170c07b3d18335f31cf9fbe3e48131e379e29", "url": "https://github.com/apache/helix/commit/297170c07b3d18335f31cf9fbe3e48131e379e29", "message": "--amend", "committedDate": "2020-08-11T20:32:54Z", "type": "commit"}, {"oid": "f6cdb60b592da0b7b6e0375c26dec5cfb948fe47", "url": "https://github.com/apache/helix/commit/f6cdb60b592da0b7b6e0375c26dec5cfb948fe47", "message": "address comment", "committedDate": "2020-08-11T20:32:54Z", "type": "commit"}, {"oid": "f6cdb60b592da0b7b6e0375c26dec5cfb948fe47", "url": "https://github.com/apache/helix/commit/f6cdb60b592da0b7b6e0375c26dec5cfb948fe47", "message": "address comment", "committedDate": "2020-08-11T20:32:54Z", "type": "forcePushed"}]}