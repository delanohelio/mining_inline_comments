{"pr_number": 1178, "pr_title": "Feature: ZooScalability Improvements", "pr_createdAt": "2020-07-26T06:14:51Z", "pr_url": "https://github.com/apache/helix/pull/1178", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NDAxMw==", "url": "https://github.com/apache/helix/pull/1178#discussion_r461764013", "bodyText": "Any reason to remove IOException?", "author": "junkaixue", "createdAt": "2020-07-28T17:50:37Z", "path": "helix-core/src/main/java/org/apache/helix/manager/zk/GenericBaseDataAccessorBuilder.java", "diffHunk": "@@ -83,7 +82,7 @@ protected RealmAwareZkClient createZkClient(RealmAwareZkClient.RealmMode realmMo\n       case MULTI_REALM:\n         try {\n           zkClient = new FederatedZkClient(connectionConfig, clientConfig);\n-        } catch (IOException | InvalidRoutingDataException e) {\n+        } catch (InvalidRoutingDataException e) {", "originalCommit": "aab6cc926b6c621f28fb7065a9188b6debf1fa57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NjQ2NA==", "url": "https://github.com/apache/helix/pull/1178#discussion_r462066464", "bodyText": "It was removed from the signature. We don't throw it anymore. It will be thrown in the form of a MultiZkException, and will be a RuntimeException, not a typed exception.", "author": "narendly", "createdAt": "2020-07-29T06:26:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2NDAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ==", "url": "https://github.com/apache/helix/pull/1178#discussion_r461766775", "bodyText": "Does that mean if we dont set both, it fall backs to single realm?", "author": "junkaixue", "createdAt": "2020-07-28T17:54:57Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/api/client/RealmAwareZkClient.java", "diffHunk": "@@ -486,6 +500,13 @@ private void validate() {\n           throw new IllegalArgumentException(\n               \"RealmAwareZkConnectionConfig.Builder: ZK sharding key must be set on single-realm mode!\");\n         }\n+        if ((_routingDataSourceEndpoint == null && _routingDataSourceType != null) || (\n+            _routingDataSourceEndpoint != null && _routingDataSourceType == null)) {\n+          // For routing data source type and endpoint, if one is set and not the other, it is invalid", "originalCommit": "aab6cc926b6c621f28fb7065a9188b6debf1fa57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NjkxNQ==", "url": "https://github.com/apache/helix/pull/1178#discussion_r462066915", "bodyText": "If nothing is set, it will try to use the default MSDS endpoint, which is provided in System Properties.", "author": "narendly", "createdAt": "2020-07-29T06:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMzNzUwMA==", "url": "https://github.com/apache/helix/pull/1178#discussion_r465337500", "bodyText": "What if some other customer they dont set up the default MSDS? They are using our module for ZKClient use case. So will path ZK address still work?", "author": "junkaixue", "createdAt": "2020-08-04T21:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NTgyMg==", "url": "https://github.com/apache/helix/pull/1178#discussion_r470285822", "bodyText": "Then they shouldn't be using RealmAwareZkClient in that case since they aren't using multiple zookeepers.", "author": "narendly", "createdAt": "2020-08-13T22:34:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4OTcxMA==", "url": "https://github.com/apache/helix/pull/1178#discussion_r470289710", "bodyText": "But even for dedicated zkclient is using RealmAwareZkClient interface, right? I am OK to have this check. But we need to clarify the boundaries.", "author": "junkaixue", "createdAt": "2020-08-13T22:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI5NjIxNA==", "url": "https://github.com/apache/helix/pull/1178#discussion_r470296214", "bodyText": "DedicatedZkClientFactory gives 2 methods - one for RealmAwareZkClient, and another for HelixZkClient. The former should be used when you plan on using ZooKeeper in a multi-zk way, the latter is for when you only have one ZK (and therefore need to provide a valid ZkAddress). Or the user can use Raw zkClient as well.", "author": "narendly", "createdAt": "2020-08-13T23:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Njc3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Nzk3Ng==", "url": "https://github.com/apache/helix/pull/1178#discussion_r461767976", "bodyText": "If it is routing related property, shall we have consistent naming system starting with \"routing\"?", "author": "junkaixue", "createdAt": "2020-07-28T17:56:53Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/constant/RoutingSystemPropertyKeys.java", "diffHunk": "@@ -0,0 +1,38 @@\n+package org.apache.helix.zookeeper.constant;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+/**\n+ * This class contains various routing-related system property keys for multi-zk clients.\n+ */\n+public class RoutingSystemPropertyKeys {\n+\n+  /**\n+   * If enabled, FederatedZkClient (multiZkClient) will invalidate the cached routing data and\n+   * re-read the routing data from the routing data source upon ZK path sharding key cache miss.\n+   */\n+  public static final String UPDATE_ROUTING_DATA_ON_CACHE_MISS =\n+      \"update.routing.data.on.cache.miss.enabled\";", "originalCommit": "aab6cc926b6c621f28fb7065a9188b6debf1fa57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2NzA1NA==", "url": "https://github.com/apache/helix/pull/1178#discussion_r462067054", "bodyText": "I can rename this and put \"routing\" in front.", "author": "narendly", "createdAt": "2020-07-29T06:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc2Nzk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3MTc5Mw==", "url": "https://github.com/apache/helix/pull/1178#discussion_r461771793", "bodyText": "Do we want to move this into try? Is that possible any exception happening in build zkClient?", "author": "junkaixue", "createdAt": "2020-07-28T18:03:13Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/ZkRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,83 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+import org.apache.helix.zookeeper.impl.client.ZkClient;\n+import org.apache.helix.zookeeper.zkclient.exception.ZkNoNodeException;\n+\n+\n+/**\n+ * Zk-based RoutingDataReader that establishes a ZK connection to the routing ZK to fetch routing\n+ * data.\n+ * The reading of routing data by nature should only be performed in cases of a Helix client\n+ * initialization or routing data reset. That means we do not have to maintain an active ZK\n+ * connection. To minimize the number of client-side ZK connections, ZkRoutingDataReader establishes\n+ * a ZK session temporarily only to read from ZK afresh and closes sessions upon read completion.\n+ */\n+public class ZkRoutingDataReader implements RoutingDataReader {\n+\n+  /**\n+   * Returns a map form of metadata store routing data.\n+   * The map fields stand for metadata store realm address (key), and a corresponding list of ZK\n+   * path sharding keys (key).\n+   * @param endpoint\n+   * @return\n+   */\n+  @Override\n+  public Map<String, List<String>> getRawRoutingData(String endpoint) {\n+    ZkClient zkClient =\n+        new ZkClient.Builder().setZkServer(endpoint).setZkSerializer(new ZNRecordSerializer())\n+            .build();", "originalCommit": "aab6cc926b6c621f28fb7065a9188b6debf1fa57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2OTM2Mw==", "url": "https://github.com/apache/helix/pull/1178#discussion_r462069363", "bodyText": "If this throws an exception, we should let it throw the exception and not proceed. We should fail early.", "author": "narendly", "createdAt": "2020-07-29T06:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3MTc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3Mzc2Mg==", "url": "https://github.com/apache/helix/pull/1178#discussion_r461773762", "bodyText": "Why not let this read extends the one of the Reader instead of creating a Reader object? This will create ZkRoutingDataReader/HttpRoutingDataReader every time if continuously calling the method.\nOr can we just have make a check wither we check whether we created them as members? If yes, use it. If not, create a new one and keep it.", "author": "junkaixue", "createdAt": "2020-07-28T18:06:38Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/HttpZkFallbackRoutingDataReader.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.zookeeper.constant.RoutingDataReaderType;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+/**\n+ * HTTP and ZK-based RoutingDataReader that first tries an HTTP call to MSDS and upon failure,\n+ * falls back to ZK for routing data.\n+ * HttpZkFallbackRoutingDataReader does not maintain a ZK connection - it establishes for reading\n+ * and closes it right away.\n+ */\n+public class HttpZkFallbackRoutingDataReader implements RoutingDataReader {", "originalCommit": "aab6cc926b6c621f28fb7065a9188b6debf1fa57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA2ODI5NA==", "url": "https://github.com/apache/helix/pull/1178#discussion_r462068294", "bodyText": "The implementations of RoutingDataReader are supposed to be stateless and to be garbage-collected after use. So we should not maintain states. The Javadoc makes that clear.\nFor example, we don't want to hold onto a ZkFallbackRoutingDataReader since that would mean we hold onto an active ZK connection. We only want a RoutingDataReader instance at initialization, once.\nExtending it complicates the design, and you can ask a question of which one it should extend, and you can never do so consistently for other implementations. For that reason, I prefer composition over inheritance.", "author": "narendly", "createdAt": "2020-07-29T06:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3Mzc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MDIwMA==", "url": "https://github.com/apache/helix/pull/1178#discussion_r465340200", "bodyText": "Can we simplify the code here?\nFundamentally, it is check path in _metadataStoreRoutingData -> get exception -> update _metadataStoreRoutingData from different level.\nThere are several comment code. we can have a loop to wrap of it and based on the retried times to do different level update.", "author": "junkaixue", "createdAt": "2020-08-04T21:27:16Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/impl/client/FederatedZkClient.java", "diffHunk": "@@ -550,17 +546,71 @@ private ZkClient getZkClient(String path) {\n   }\n \n   private String getZkRealm(String path) {\n+    if (_routingDataUpdateOnCacheMissEnabled) {\n+      try {\n+        return updateRoutingDataOnCacheMiss(path);\n+      } catch (InvalidRoutingDataException e) {\n+        LOG.error(\n+            \"FederatedZkClient::getZkRealm: Failed to update routing data due to invalid routing \"\n+                + \"data!\", e);\n+        throw new MultiZkException(e);\n+      }\n+    }\n+    return _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+  }\n+\n+  /**\n+   * Perform a 2-tier routing data cache update:\n+   * 1. Do an in-memory update from the singleton RoutingDataManager\n+   * 2. Do an I/O based read from the routing data source by resetting RoutingDataManager\n+   * @param path\n+   * @return\n+   * @throws InvalidRoutingDataException\n+   */\n+  private String updateRoutingDataOnCacheMiss(String path) throws InvalidRoutingDataException {\n     String zkRealm;\n     try {\n       zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n-    } catch (NoSuchElementException ex) {\n-      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n-    }\n-\n-    if (zkRealm == null || zkRealm.isEmpty()) {\n-      throw new NoSuchElementException(\"Cannot find ZK realm for the path: \" + path);\n+    } catch (NoSuchElementException e1) {\n+      synchronized (this) {\n+        try {\n+          zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+        } catch (NoSuchElementException e2) {\n+          // Try 1) Refresh MetadataStoreRoutingData from RoutingDataManager\n+          // This is an in-memory refresh from the Singleton RoutingDataManager - other\n+          // FederatedZkClient objects may have triggered a cache refresh, so we first update the\n+          // in-memory reference. This refresh only affects this object/thread, so we synchronize\n+          // on \"this\".\n+          _metadataStoreRoutingData =\n+              RealmAwareZkClient.getMetadataStoreRoutingData(_connectionConfig);\n+          try {\n+            zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+          } catch (NoSuchElementException e3) {\n+            synchronized (FederatedZkClient.class) {\n+              try {\n+                zkRealm = _metadataStoreRoutingData.getMetadataStoreRealm(path);\n+              } catch (NoSuchElementException e4) {\n+                if (shouldThrottleRead()) {\n+                  // If routing data update from routing data source has taken place recently,\n+                  // then just skip the update and throw the exception\n+                  throw e4;\n+                }\n+                // Try 2) Reset RoutingDataManager and re-read the routing data from routing data\n+                // source via I/O. Since RoutingDataManager's cache doesn't have it either, so we\n+                // synchronize on all threads by locking on FederatedZkClient.class.\n+                RoutingDataManager.getInstance().reset();", "originalCommit": "aab6cc926b6c621f28fb7065a9188b6debf1fa57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4OTA3OA==", "url": "https://github.com/apache/helix/pull/1178#discussion_r470289078", "bodyText": "I'm not sure if that's feasible. Each update has different logic if you look closely. Also, I think if we change the structure, it runs the risk of making it harder to read/understand. Do you have a more concrete suggestion?\nTying it to the number of tries isn't a good idea since this isn't about how many times you try the same logic. In other words, this logic is not a retry (although it looks like one).", "author": "narendly", "createdAt": "2020-08-13T22:44:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0MDIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDYzNA==", "url": "https://github.com/apache/helix/pull/1178#discussion_r465344634", "bodyText": "error log here?", "author": "junkaixue", "createdAt": "2020-08-04T21:37:20Z", "path": "zookeeper-api/src/main/java/org/apache/helix/zookeeper/routing/RoutingDataManager.java", "diffHunk": "@@ -0,0 +1,210 @@\n+package org.apache.helix.zookeeper.routing;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.datamodel.MetadataStoreRoutingData;\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.zookeeper.constant.RoutingDataReaderType;\n+import org.apache.helix.zookeeper.exception.MultiZkException;\n+\n+\n+/**\n+ * RoutingDataManager is a Singleton that\n+ * 1. resolves RoutingDataReader based on the system config given\n+ * 2. caches routing data\n+ * 3. provides public methods for reading routing data from various sources (configurable)\n+ */\n+public class RoutingDataManager {\n+  /** HTTP call to MSDS is used to fetch routing data by default */\n+  private String _defaultMsdsEndpoint =\n+      System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+\n+  /** Double-checked locking requires that the following fields be final (volatile) */\n+  // The following map stands for (RoutingDataReaderType_endpoint ID, Raw Routing Data)\n+  private final Map<String, Map<String, List<String>>> _rawRoutingDataMap =\n+      new ConcurrentHashMap<>();\n+  // The following map stands for (RoutingDataReaderType_endpoint ID, MetadataStoreRoutingData)\n+  private final Map<String, MetadataStoreRoutingData> _metadataStoreRoutingDataMap =\n+      new ConcurrentHashMap<>();\n+\n+  // Tracks the time at which reset() was called last. Used to throttle reset()\n+  private volatile long _lastResetTimestamp;\n+\n+  // Singleton instance\n+  private static RoutingDataManager _instance;\n+\n+  /**\n+   * This class is a Singleton.\n+   */\n+  private RoutingDataManager() {\n+    // Private constructor for Singleton\n+  }\n+\n+  /**\n+   * Lazy initialization with double-checked locking.\n+   * @return\n+   */\n+  public static RoutingDataManager getInstance() {\n+    if (_instance == null) {\n+      synchronized (RoutingDataManager.class) {\n+        if (_instance == null) {\n+          _instance = new RoutingDataManager();\n+        }\n+      }\n+    }\n+    return _instance;\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP by querying the MSDS configured in the JVM\n+   * config.\n+   * @return\n+   */\n+  public Map<String, List<String>> getRawRoutingData() {\n+    if (_defaultMsdsEndpoint == null || _defaultMsdsEndpoint.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System \"\n+              + \"Properties!\");\n+    }\n+    return getRawRoutingData(RoutingDataReaderType.HTTP, _defaultMsdsEndpoint);\n+  }\n+\n+  /**\n+   * Fetches routing data from the data source via HTTP.\n+   * @return a mapping from \"metadata store realm addresses\" to lists of\n+   * \"metadata store sharding keys\", where the sharding keys in a value list all route to\n+   * the realm address in the key disallows a meaningful mapping to be returned.\n+   * @param routingDataReaderType\n+   * @param endpoint\n+   */\n+  public Map<String, List<String>> getRawRoutingData(RoutingDataReaderType routingDataReaderType,\n+      String endpoint) {\n+    String routingDataCacheKey = getRoutingDataCacheKey(routingDataReaderType, endpoint);\n+    Map<String, List<String>> rawRoutingData = _rawRoutingDataMap.get(routingDataCacheKey);\n+    if (rawRoutingData == null) {\n+      synchronized (RoutingDataManager.class) {\n+        rawRoutingData = _rawRoutingDataMap.get(routingDataCacheKey);\n+        if (rawRoutingData == null) {\n+          RoutingDataReader reader = resolveRoutingDataReader(routingDataReaderType);\n+          rawRoutingData = reader.getRawRoutingData(endpoint);\n+          _rawRoutingDataMap.put(routingDataCacheKey, rawRoutingData);\n+        }\n+      }\n+    }\n+    return rawRoutingData;\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS in a MetadataStoreRoutingData format by querying the\n+   * MSDS configured in the JVM config.\n+   * @return MetadataStoreRoutingData\n+   */\n+  public MetadataStoreRoutingData getMetadataStoreRoutingData() throws InvalidRoutingDataException {\n+    if (_defaultMsdsEndpoint == null || _defaultMsdsEndpoint.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"HttpRoutingDataReader was unable to find a valid MSDS endpoint String in System \"\n+              + \"Properties!\");\n+    }\n+    return getMetadataStoreRoutingData(RoutingDataReaderType.HTTP, _defaultMsdsEndpoint);\n+  }\n+\n+  /**\n+   * Returns the routing data read from MSDS as a MetadataStoreRoutingData object.\n+   * @param routingDataReaderType\n+   * @param endpoint\n+   * @return\n+   * @throws IOException\n+   * @throws InvalidRoutingDataException\n+   */\n+  public MetadataStoreRoutingData getMetadataStoreRoutingData(\n+      RoutingDataReaderType routingDataReaderType, String endpoint)\n+      throws InvalidRoutingDataException {\n+    String routingDataCacheKey = getRoutingDataCacheKey(routingDataReaderType, endpoint);\n+    MetadataStoreRoutingData metadataStoreRoutingData =\n+        _metadataStoreRoutingDataMap.get(routingDataCacheKey);\n+    if (metadataStoreRoutingData == null) {\n+      synchronized (RoutingDataManager.class) {\n+        metadataStoreRoutingData = _metadataStoreRoutingDataMap.get(routingDataCacheKey);\n+        if (metadataStoreRoutingData == null) {\n+          metadataStoreRoutingData =\n+              new TrieRoutingData(getRawRoutingData(routingDataReaderType, endpoint));\n+          _metadataStoreRoutingDataMap.put(routingDataCacheKey, metadataStoreRoutingData);\n+        }\n+      }\n+    }\n+    return metadataStoreRoutingData;\n+  }\n+\n+  /**\n+   * Clears the statically-cached routing data and private fields.\n+   */\n+  public synchronized void reset() {\n+    _rawRoutingDataMap.clear();\n+    _metadataStoreRoutingDataMap.clear();\n+    _defaultMsdsEndpoint =\n+        System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_ENDPOINT_KEY);\n+    _lastResetTimestamp = System.currentTimeMillis();\n+  }\n+\n+  /**\n+   * Returns the timestamp for the last reset().\n+   * @return\n+   */\n+  public long getLastResetTimestamp() {\n+    return _lastResetTimestamp;\n+  }\n+\n+  /**\n+   * Returns an appropriate instance of RoutingDataReader given the type.\n+   * @param routingDataReaderType\n+   * @return\n+   */\n+  private RoutingDataReader resolveRoutingDataReader(RoutingDataReaderType routingDataReaderType) {\n+    // Instantiate an instance of routing data reader using the type\n+    try {\n+      return (RoutingDataReader) Class.forName(routingDataReaderType.getClassName()).newInstance();\n+    } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {\n+      throw new MultiZkException(", "originalCommit": "aab6cc926b6c621f28fb7065a9188b6debf1fa57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI4NzA5Mg==", "url": "https://github.com/apache/helix/pull/1178#discussion_r470287092", "bodyText": "Added.", "author": "narendly", "createdAt": "2020-08-13T22:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM0NDYzNA=="}], "type": "inlineReview"}, {"oid": "59aeaf90709b72ec4956d91bbdbda0a37fcfe78d", "url": "https://github.com/apache/helix/commit/59aeaf90709b72ec4956d91bbdbda0a37fcfe78d", "message": "Implement RoutingDataManager to replace HttpRoutingDataReader\n\nWe want to make the routing data source configurable. As such, using HttpRoutingDataReader as the static Singleton that fetches and caches the routing data is no longer appropriate. This change adds an implementation of RoutingDataManager and the new RoutingDataReader interface, with HttpRoutingDataReader as one of its implementations. This is the first step towards making routing data source configurable - other readers will be added in the future commits.", "committedDate": "2020-08-14T06:32:33Z", "type": "commit"}, {"oid": "72170f6ee63ab6de6c8265e14ea3aa6bac04edd1", "url": "https://github.com/apache/helix/commit/72170f6ee63ab6de6c8265e14ea3aa6bac04edd1", "message": "Fix string", "committedDate": "2020-08-14T06:32:33Z", "type": "commit"}, {"oid": "60f3d61510654d25e2e6b24d32e40641a20c515b", "url": "https://github.com/apache/helix/commit/60f3d61510654d25e2e6b24d32e40641a20c515b", "message": "Remove unnecessary IOException", "committedDate": "2020-08-14T06:32:33Z", "type": "commit"}, {"oid": "157cedf988a520ac70f3fb4e8d77d0ea9b047c72", "url": "https://github.com/apache/helix/commit/157cedf988a520ac70f3fb4e8d77d0ea9b047c72", "message": "Change interface for RoutingDataReader\n\nThis commit changes the interface for RoutingDataReader in order to accommodate various types of routing data source.", "committedDate": "2020-08-14T06:32:33Z", "type": "commit"}, {"oid": "fddbd5172cff602f563c5e4c016777a70d86b65e", "url": "https://github.com/apache/helix/commit/fddbd5172cff602f563c5e4c016777a70d86b65e", "message": "Add HttpZkFallbackRoutingDataReader\n\nImplement an Http-ZK fallback routing data reader. ZkRoutingDataReader will follow.", "committedDate": "2020-08-14T06:32:33Z", "type": "commit"}, {"oid": "72d53623c706ebaa180658cf1d74f66131396455", "url": "https://github.com/apache/helix/commit/72d53623c706ebaa180658cf1d74f66131396455", "message": "Implement ZkRoutingDataReader\n\nIn order to allow certain users to use ZK as the sole routing data source, we add ZkRoutingDataReader that transiently creates a ZK connection to read the routing data from the routing ZK.", "committedDate": "2020-08-14T06:32:33Z", "type": "commit"}, {"oid": "68af074dd715e3be726d1e415a9463755f712644", "url": "https://github.com/apache/helix/commit/68af074dd715e3be726d1e415a9463755f712644", "message": "Modify realm-aware ZkClient and Helix API for configurable routing source\n\nThis commit changes old MSDS-based interfaces and replaces them with a more generic configurable routing data source interfaces. This commit also adds test cases for Helix API.", "committedDate": "2020-08-14T06:32:33Z", "type": "commit"}, {"oid": "af9d607d57c2336d8fe6d74895a76c75e6a98076", "url": "https://github.com/apache/helix/commit/af9d607d57c2336d8fe6d74895a76c75e6a98076", "message": "Make RoutingDataManager a pure Singleton with double-checked locking\n\nRoutingDataManager was a stateful static class, but since it contains caches, it would be better to make it a Singleton. This commit makes it a singleton and updates the code accordingly.", "committedDate": "2020-08-14T06:32:34Z", "type": "commit"}, {"oid": "cf558f738347af1846307dd592e23e292ffe28e0", "url": "https://github.com/apache/helix/commit/cf558f738347af1846307dd592e23e292ffe28e0", "message": "Refactor RealmAwareZkClient code to remove duplicate code\n\nThere was a piece of code that resolves MetadataStoreRoutingData based on RealmAwareZkConnectionConfig in all implementations of RealmAwareZkClient. This commit refactors that logic into a common static method in RealmAwareZkClient.", "committedDate": "2020-08-14T06:32:34Z", "type": "commit"}, {"oid": "5498addd63b158ba6a86b236424ee9d2a1d75852", "url": "https://github.com/apache/helix/commit/5498addd63b158ba6a86b236424ee9d2a1d75852", "message": "Implement routing data update upon cache miss for FederatedZkClient\n\nFederatedZkClient is the only implementation of RealmAwareZkClient that is capable of accesing multiple ZKs. There are potential use cases where it would be beneficial for FederatedZkClient and Helix Java APIs on multi-ZK mode to automatically trigger a routing data update when the ZK path sharding key is not found in the cached routing data.\nThis commit implements the feature and allows users to turn it on by setting a field in System Properties.", "committedDate": "2020-08-14T06:32:34Z", "type": "commit"}, {"oid": "eda83703980eaca6b305aa495ab6b85d1b9a6301", "url": "https://github.com/apache/helix/commit/eda83703980eaca6b305aa495ab6b85d1b9a6301", "message": "Implement throttling for routing data update on cache miss\n\nThis commit implements throttling for routing data update by using a timestamp for last time the cache was reset in RoutingDataManager. It defines a default interval (5 seconds) but makes this interval configurable by way of System Properties config.", "committedDate": "2020-08-14T06:32:34Z", "type": "commit"}, {"oid": "d96118b92621aaea4f850ccb2c6d3b5e80a3c80f", "url": "https://github.com/apache/helix/commit/d96118b92621aaea4f850ccb2c6d3b5e80a3c80f", "message": "Change UPDATE_ROUTING_DATA_ON_CACHE_MISS and remove unused imports\n\nThis commit updates the string constant values for UPDATE_ROUTING_DATA_ON_CACHE_MISS so that it's in line with other constants and removes unused imports and unnecessary IOExceptions thrown.", "committedDate": "2020-08-14T06:32:34Z", "type": "commit"}, {"oid": "d96118b92621aaea4f850ccb2c6d3b5e80a3c80f", "url": "https://github.com/apache/helix/commit/d96118b92621aaea4f850ccb2c6d3b5e80a3c80f", "message": "Change UPDATE_ROUTING_DATA_ON_CACHE_MISS and remove unused imports\n\nThis commit updates the string constant values for UPDATE_ROUTING_DATA_ON_CACHE_MISS so that it's in line with other constants and removes unused imports and unnecessary IOExceptions thrown.", "committedDate": "2020-08-14T06:32:34Z", "type": "forcePushed"}]}