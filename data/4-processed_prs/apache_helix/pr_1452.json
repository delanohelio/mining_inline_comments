{"pr_number": 1452, "pr_title": "thread leakage checker and memory usage reporter #1226", "pr_createdAt": "2020-10-08T06:31:00Z", "pr_url": "https://github.com/apache/helix/pull/1452", "timeline": [{"oid": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "url": "https://github.com/apache/helix/commit/83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "message": "fix #1226\nAdd thread leakage checker and memory usage reporter. The two\nutility would be invoke before and after test classes. The would\nhelp to detect/monitor resource/memory usage of the unit test.", "committedDate": "2020-10-08T06:24:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk5MjEzMg==", "url": "https://github.com/apache/helix/pull/1452#discussion_r501992132", "bodyText": "minor: int -> long?", "author": "lei-xia", "createdAt": "2020-10-08T20:26:39Z", "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -127,8 +129,22 @@\n   protected Map<String, ClusterSetup> _clusterSetupMap = new HashMap<>();\n   protected Map<String, BaseDataAccessor> _baseDataAccessorMap = new HashMap<>();\n \n+  static public void reportPhysicalMemory() {\n+    com.sun.management.OperatingSystemMXBean os = (com.sun.management.OperatingSystemMXBean)\n+        java.lang.management.ManagementFactory.getOperatingSystemMXBean();\n+    long physicalMemorySize = os.getTotalPhysicalMemorySize();\n+    System.out.println(\"************ SYSTEM Physical Memory:\"  + physicalMemorySize);\n+\n+    int MB = 1024 * 1024;", "originalCommit": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyNjUxNQ==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502026515", "bodyText": "changed.", "author": "kaisun2000", "createdAt": "2020-10-08T21:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk5MjEzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk5MzE3NA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r501993174", "bodyText": "Will this method being called by all sub test classes?", "author": "lei-xia", "createdAt": "2020-10-08T20:28:44Z", "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -710,7 +726,9 @@ protected Message createMessage(Message.MessageType type, String msgId, String f\n   }\n \n   @AfterClass\n-  public void cleanupLiveInstanceOwners() {\n+  public void cleanupLiveInstanceOwners() throws InterruptedException {", "originalCommit": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNTIwOQ==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502005209", "bodyText": "All the ones using ZkTestBase", "author": "kaisun2000", "createdAt": "2020-10-08T20:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk5MzE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMjAzMw==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502002033", "bodyText": "Isn't the 32 too small as initial value? We have a lot more than that right?", "author": "zhangmeng916", "createdAt": "2020-10-08T20:45:32Z", "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];", "originalCommit": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxNDY2MQ==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502014661", "bodyText": "It does not matter. Note in line 30  threads = new Thread[threads.length * 2];, we double the threads array if it is not large enough, exponentially.", "author": "kaisun2000", "createdAt": "2020-10-08T21:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMjAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMzQyNg==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502003426", "bodyText": "Can you give some explanation of the default value? Otherwise, it's a bit hard to follow. E.g., whey ForkJoin is default to 2?", "author": "zhangmeng916", "createdAt": "2020-10-08T20:48:16Z", "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZkServerThrdPattern =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZkSessionThrdPattern =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] ForkJoinThrdPattern = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TimerThrdPattern = new String[]{\"time\"};\n+  private static final String[] TaskStateModelThrdPattern = new String[]{\"TaskStateModel\"};\n+\n+  private static enum ThreadCategory {", "originalCommit": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxMjY2NA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502012664", "bodyText": "Good question. The two threshold are mostly empirical.\nZkServer, our version has only 4 threads now. In case later version use more. I set the limit to 100. The reasoning is that these ZkServer threads are not deemed as leaking no matter how much they have.\nZkSession is the ZkClient and native Zookeeper client we have. ZkTestBase has 12 at starting up time. Thus, if there is more than that, it is the test code leaking ZkClient.\nForkJoin is created by using parallel stream or whatever Java features. This is out of our control, similar to ZkServer. Let me change the _limit to 100 while keep a small _warningLimit. (Will make change for this one).\nTimer  should not happen. Setting limit to 2 not 0 mostly because even when you cancel the timer thread, it may take some not deterministic time for it to go away. So give it some slack here.", "author": "kaisun2000", "createdAt": "2020-10-08T21:06:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMzQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MDY0OA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502090648", "bodyText": "Please put the comment into the class. Code reviewers in the future shall not depend on this Github PR to understand the logic.", "author": "jiajunwang", "createdAt": "2020-10-09T00:17:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMzQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjExNjUwMA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502116500", "bodyText": "added the comment", "author": "kaisun2000", "createdAt": "2020-10-09T01:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwMzQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNDcxMw==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502004713", "bodyText": "nit: can you use more character for \"category\", catThreadCnt is not quit self explanatory.", "author": "zhangmeng916", "createdAt": "2020-10-08T20:50:41Z", "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZkServerThrdPattern =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZkSessionThrdPattern =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] ForkJoinThrdPattern = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TimerThrdPattern = new String[]{\"time\"};\n+  private static final String[] TaskStateModelThrdPattern = new String[]{\"TaskStateModel\"};\n+\n+  private static enum ThreadCategory {\n+    ZkServer(\"zookeeper server threads\", 4, 100, ZkServerThrdPattern),\n+    ZkSession(\"zkclient/zooKeeper session threads\", 12, 12, ZkSessionThrdPattern),\n+    ForkJoin(\"fork join pool threads\", 2, 10, ForkJoinThrdPattern),\n+    Timer(\"timer threads\", 0, 2, TimerThrdPattern),\n+    TaskStateModel(\"TaskStateModel threads\", 0, 0, TaskStateModelThrdPattern),\n+    Other(\"Other threads\", 0, 3, new String[]{\"\"});\n+\n+    private String _description;\n+    private List<String> _pattern;\n+    private int _warningLimit;\n+    private int _limit;\n+\n+    public String getDescription() {\n+      return _description;\n+    }\n+\n+    public Predicate<String> getMatchPred() {\n+      if (this.name() != ThreadCategory.Other.name()) {\n+        Predicate<String> pred = target -> {\n+          for (String p : _pattern) {\n+            if (target.toLowerCase().contains(p.toLowerCase())) {\n+              return true;\n+            }\n+          }\n+          return false;\n+        };\n+        return pred;\n+      }\n+\n+      List<Predicate<String>> predicateList = new ArrayList<>();\n+      for (ThreadCategory threadCategory : ThreadCategory.values()) {\n+        if (threadCategory == ThreadCategory.Other) {\n+          continue;\n+        }\n+        predicateList.add(threadCategory.getMatchPred());\n+      }\n+      Predicate<String> pred = target -> {\n+        for (Predicate<String> p : predicateList) {\n+          if (p.test(target)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      };\n+\n+      return pred;\n+    }\n+\n+    public int getWarningLimit() {\n+      return _warningLimit;\n+    }\n+\n+    public int getLimit() {\n+      return _limit;\n+    }\n+\n+    private ThreadCategory(String description, int warningLimit, int limit, String[] patterns) {\n+      _description = description;\n+      _pattern = Arrays.asList(patterns);\n+      _warningLimit = warningLimit;\n+      _limit = limit;\n+    }\n+  }\n+\n+  public static boolean afterClassCheck(String classname) {\n+    ZkTestBase.reportPhysicalMemory();\n+    // step 1: get all active threads\n+    List<Thread> threads = getAllThreads();\n+    System.out.println(classname + \" has active threads cnt:\" + threads.size());\n+\n+    // step 2: categorize threads\n+    Map<String, List<Thread>> threadByName = null;\n+    Map<ThreadCategory, Integer> threadByCnt = new HashMap<>();\n+    Map<ThreadCategory, Set<Thread>> threadByCat = new HashMap<>();\n+    try {\n+      threadByName = threads.\n+          stream().\n+          filter(p -> p.getThreadGroup() != null && p.getThreadGroup().getName() != null\n+              &&  ! \"system\".equals(p.getThreadGroup().getName())).\n+          collect(Collectors.groupingBy(p -> p.getName()));\n+    } catch (Exception e) {\n+      System.out.println(\"filtering thread failure with exception:\" + e.getStackTrace());\n+    }\n+\n+    threadByName.entrySet().stream().forEach(entry -> {\n+      String key = entry.getKey(); // thread name\n+      Arrays.asList(ThreadCategory.values()).stream().forEach(category -> {\n+        if (category.getMatchPred().test(key)) {\n+          Integer count = threadByCnt.containsKey(category) ? threadByCnt.get(category) : 0;\n+          threadByCnt.put(category, count + entry.getValue().size());\n+          Set<Thread> thisSet = threadByCat.getOrDefault(category, new HashSet<>());\n+          thisSet.addAll(entry.getValue());\n+          threadByCat.put(category, thisSet);\n+        }\n+      });\n+    });\n+\n+    // step 3: enforce checking policy\n+    boolean checkStatus = true;\n+    for (ThreadCategory threadCategory : ThreadCategory.values()) {\n+      int limit = threadCategory.getLimit();\n+      int warningLimit = threadCategory.getWarningLimit();\n+\n+      Integer catThreadCnt = threadByCnt.get(threadCategory);", "originalCommit": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyNjI0Mg==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502026242", "bodyText": "changed", "author": "kaisun2000", "createdAt": "2020-10-08T21:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNDcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNDk4NQ==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502004985", "bodyText": "Comments said \"10\", but I think \"100\" makes more sense.", "author": "zhangmeng916", "createdAt": "2020-10-08T20:51:08Z", "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZkServerThrdPattern =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZkSessionThrdPattern =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] ForkJoinThrdPattern = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TimerThrdPattern = new String[]{\"time\"};\n+  private static final String[] TaskStateModelThrdPattern = new String[]{\"TaskStateModel\"};\n+\n+  private static enum ThreadCategory {\n+    ZkServer(\"zookeeper server threads\", 4, 100, ZkServerThrdPattern),\n+    ZkSession(\"zkclient/zooKeeper session threads\", 12, 12, ZkSessionThrdPattern),\n+    ForkJoin(\"fork join pool threads\", 2, 10, ForkJoinThrdPattern),\n+    Timer(\"timer threads\", 0, 2, TimerThrdPattern),\n+    TaskStateModel(\"TaskStateModel threads\", 0, 0, TaskStateModelThrdPattern),\n+    Other(\"Other threads\", 0, 3, new String[]{\"\"});\n+\n+    private String _description;\n+    private List<String> _pattern;\n+    private int _warningLimit;\n+    private int _limit;\n+\n+    public String getDescription() {\n+      return _description;\n+    }\n+\n+    public Predicate<String> getMatchPred() {\n+      if (this.name() != ThreadCategory.Other.name()) {\n+        Predicate<String> pred = target -> {\n+          for (String p : _pattern) {\n+            if (target.toLowerCase().contains(p.toLowerCase())) {\n+              return true;\n+            }\n+          }\n+          return false;\n+        };\n+        return pred;\n+      }\n+\n+      List<Predicate<String>> predicateList = new ArrayList<>();\n+      for (ThreadCategory threadCategory : ThreadCategory.values()) {\n+        if (threadCategory == ThreadCategory.Other) {\n+          continue;\n+        }\n+        predicateList.add(threadCategory.getMatchPred());\n+      }\n+      Predicate<String> pred = target -> {\n+        for (Predicate<String> p : predicateList) {\n+          if (p.test(target)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      };\n+\n+      return pred;\n+    }\n+\n+    public int getWarningLimit() {\n+      return _warningLimit;\n+    }\n+\n+    public int getLimit() {\n+      return _limit;\n+    }\n+\n+    private ThreadCategory(String description, int warningLimit, int limit, String[] patterns) {\n+      _description = description;\n+      _pattern = Arrays.asList(patterns);\n+      _warningLimit = warningLimit;\n+      _limit = limit;\n+    }\n+  }\n+\n+  public static boolean afterClassCheck(String classname) {\n+    ZkTestBase.reportPhysicalMemory();\n+    // step 1: get all active threads\n+    List<Thread> threads = getAllThreads();\n+    System.out.println(classname + \" has active threads cnt:\" + threads.size());\n+\n+    // step 2: categorize threads\n+    Map<String, List<Thread>> threadByName = null;\n+    Map<ThreadCategory, Integer> threadByCnt = new HashMap<>();\n+    Map<ThreadCategory, Set<Thread>> threadByCat = new HashMap<>();\n+    try {\n+      threadByName = threads.\n+          stream().\n+          filter(p -> p.getThreadGroup() != null && p.getThreadGroup().getName() != null\n+              &&  ! \"system\".equals(p.getThreadGroup().getName())).\n+          collect(Collectors.groupingBy(p -> p.getName()));\n+    } catch (Exception e) {\n+      System.out.println(\"filtering thread failure with exception:\" + e.getStackTrace());\n+    }\n+\n+    threadByName.entrySet().stream().forEach(entry -> {\n+      String key = entry.getKey(); // thread name\n+      Arrays.asList(ThreadCategory.values()).stream().forEach(category -> {\n+        if (category.getMatchPred().test(key)) {\n+          Integer count = threadByCnt.containsKey(category) ? threadByCnt.get(category) : 0;\n+          threadByCnt.put(category, count + entry.getValue().size());\n+          Set<Thread> thisSet = threadByCat.getOrDefault(category, new HashSet<>());\n+          thisSet.addAll(entry.getValue());\n+          threadByCat.put(category, thisSet);\n+        }\n+      });\n+    });\n+\n+    // step 3: enforce checking policy\n+    boolean checkStatus = true;\n+    for (ThreadCategory threadCategory : ThreadCategory.values()) {\n+      int limit = threadCategory.getLimit();\n+      int warningLimit = threadCategory.getWarningLimit();\n+\n+      Integer catThreadCnt = threadByCnt.get(threadCategory);\n+      if (catThreadCnt != null) {\n+        boolean dumpThread = false;\n+        if (catThreadCnt > limit) {\n+          checkStatus = false;\n+          System.out.println(\n+              \"Failure \" + threadCategory.getDescription() + \" has \" + catThreadCnt + \" thread\");\n+          dumpThread = true;\n+        } else if (catThreadCnt > warningLimit) {\n+          System.out.println(\n+              \"Warning \" + threadCategory.getDescription() + \" has \" + catThreadCnt + \" thread\");\n+          dumpThread = true;\n+        } else {\n+          System.out.println(threadCategory.getDescription() + \" has \" + catThreadCnt + \" thread\");\n+        }\n+        if (!dumpThread) {\n+          continue;\n+        }\n+        // print first 10 thread names\n+        int i = 0;\n+        for (Thread t : threadByCat.get(threadCategory)) {\n+          System.out.println(i + \" thread:\" + t.getName());\n+          i++;\n+          if (i == 100) {", "originalCommit": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAyNTU3NQ==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502025575", "bodyText": "changed the comments", "author": "kaisun2000", "createdAt": "2020-10-08T21:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNDk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNjEyMg==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502006122", "bodyText": "Just to make sure, having this check here should cover all tests.", "author": "zhangmeng916", "createdAt": "2020-10-08T20:53:34Z", "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -719,6 +737,17 @@ public void cleanupLiveInstanceOwners() {\n       clientMap.clear();\n     }\n     _liveInstanceOwners.clear();\n+\n+    boolean status = false;\n+    try {\n+      status = ThreadLeakageChecker.afterClassCheck(testClassName);", "originalCommit": "83b031e53ffd92310d2d9332e9f5c1bb73e1b145", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxMzQ1OA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502013458", "bodyText": "Only those test derived from ZkTestBase. That is majority for now. We can open another ticket to track using then for all.", "author": "kaisun2000", "createdAt": "2020-10-08T21:08:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAwNjEyMg=="}], "type": "inlineReview"}, {"oid": "4e8b5718a2bf45f29bc75004b159028f30a9c91d", "url": "https://github.com/apache/helix/commit/4e8b5718a2bf45f29bc75004b159028f30a9c91d", "message": "address review comments from Meng and Lei", "committedDate": "2020-10-08T21:36:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3OTk5MA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502079990", "bodyText": "@kaisun2000 Can you add Apache License ?", "author": "huizhilu", "createdAt": "2020-10-08T23:38:09Z", "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+", "originalCommit": "4e8b5718a2bf45f29bc75004b159028f30a9c91d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NzY2MQ==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502087661", "bodyText": "added.", "author": "kaisun2000", "createdAt": "2020-10-09T00:06:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA3OTk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4MTA2Nw==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502081067", "bodyText": "Is this needed?", "author": "huizhilu", "createdAt": "2020-10-08T23:41:51Z", "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -33,6 +33,7 @@\n import javax.management.MBeanServerConnection;\n import javax.management.ObjectName;\n \n+import bsh.This;", "originalCommit": "4e8b5718a2bf45f29bc75004b159028f30a9c91d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4NzgyNA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502087824", "bodyText": "removed,", "author": "kaisun2000", "createdAt": "2020-10-09T00:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4MTA2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4MjIzOA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502082238", "bodyText": "I didn't mean to be picky, but I suggest we still follow the constant style: static final String[] THIS_IS_CONSTANT", "author": "huizhilu", "createdAt": "2020-10-08T23:46:06Z", "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZkServerThrdPattern =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZkSessionThrdPattern =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] ForkJoinThrdPattern = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TimerThrdPattern = new String[]{\"time\"};\n+  private static final String[] TaskStateModelThrdPattern = new String[]{\"TaskStateModel\"};\n+\n+  private static enum ThreadCategory {", "originalCommit": "4e8b5718a2bf45f29bc75004b159028f30a9c91d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4ODgzMA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502088830", "bodyText": "changed.", "author": "kaisun2000", "createdAt": "2020-10-09T00:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4MjIzOA=="}], "type": "inlineReview"}, {"oid": "976ffbb115d477d40249eb88c1e7d831c7b8f796", "url": "https://github.com/apache/helix/commit/976ffbb115d477d40249eb88c1e7d831c7b8f796", "message": "address hz's comments", "committedDate": "2020-10-09T00:10:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4OTg1OQ==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502089859", "bodyText": "Please comment on what is this checker doing.", "author": "jiajunwang", "createdAt": "2020-10-09T00:14:50Z", "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {", "originalCommit": "976ffbb115d477d40249eb88c1e7d831c7b8f796", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5Mjg4Nw==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502092887", "bodyText": "Another question, does it only work for sequentially run tests?\nIf so, please note in the comment.", "author": "jiajunwang", "createdAt": "2020-10-09T00:26:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4OTg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjExMzQzNQ==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502113435", "bodyText": "I think the checker by itself is thread safe. But currently if multiple test is running, checker won't be of any use for obvious reasons. Let me add an comment its usage depends on test running sequentially.", "author": "kaisun2000", "createdAt": "2020-10-09T01:09:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4OTg1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjExNjk5OA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502116998", "bodyText": "added to the comment that we need to run tests sequentially to make this leakage check to be meaningful.", "author": "kaisun2000", "createdAt": "2020-10-09T01:15:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA4OTg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MjY4NA==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502092684", "bodyText": "Any thoughts on how we are going to maintain these hardcoded patterns?", "author": "jiajunwang", "createdAt": "2020-10-09T00:26:00Z", "path": "helix-core/src/test/java/org/apache/helix/ThreadLeakageChecker.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.helix;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+\n+import org.apache.helix.common.ZkTestBase;\n+\n+\n+public class ThreadLeakageChecker {\n+  private static ThreadGroup getRootThreadGroup() {\n+    ThreadGroup candidate = Thread.currentThread().getThreadGroup();\n+    while (candidate.getParent() != null) {\n+      candidate = candidate.getParent();\n+    }\n+    return candidate;\n+  }\n+\n+  private static List<Thread> getAllThreads() {\n+    ThreadGroup rootThreadGroup = getRootThreadGroup();\n+    Thread[] threads = new Thread[32];\n+    int count = rootThreadGroup.enumerate(threads);\n+    while (count == threads.length) {\n+      threads = new Thread[threads.length * 2];\n+      count = rootThreadGroup.enumerate(threads);\n+    }\n+    return Arrays.asList(Arrays.copyOf(threads, count));\n+  }\n+\n+  private static final String[] ZKSERVER_THRD_PATTERN =\n+      {\"SessionTracker\", \"NIOServerCxn\", \"SyncThread:\", \"ProcessThread\"};\n+  private static final String[] ZKSESSION_THRD_PATTERN =\n+      new String[]{\"ZkClient-EventThread\", \"ZkClient-AsyncCallback\", \"-EventThread\", \"-SendThread\"};\n+  private static final String[] FORKJOIN_THRD_PATTERN = new String[]{\"ForkJoinPool\"};\n+  private static final String[] TIMER_THRD_PATTERN = new String[]{\"time\"};\n+  private static final String[] TASKSTATEMODEL_THRD_PATTERN = new String[]{\"TaskStateModel\"};", "originalCommit": "976ffbb115d477d40249eb88c1e7d831c7b8f796", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjExMTk5Nw==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502111997", "bodyText": "As long as developers start to use them, they can easier break out more categories and make the changes accordingly. Eventually the baton is passed code contributors.", "author": "kaisun2000", "createdAt": "2020-10-09T01:06:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MjY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MzQ3Nw==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502093477", "bodyText": "Please remove this output. I think with no leakage found, we don't need this information.", "author": "jiajunwang", "createdAt": "2020-10-09T00:29:26Z", "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -710,7 +725,9 @@ protected Message createMessage(Message.MessageType type, String msgId, String f\n   }\n \n   @AfterClass\n-  public void cleanupLiveInstanceOwners() {\n+  public void cleanupLiveInstanceOwners() throws InterruptedException {\n+    String testClassName = this.getShortClassName();\n+    System.out.println(\"AfterClass:\" + testClassName + \" afterclass of ZkTestBase called!\");", "originalCommit": "976ffbb115d477d40249eb88c1e7d831c7b8f796", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjExNzc2MQ==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502117761", "bodyText": "removed", "author": "kaisun2000", "createdAt": "2020-10-09T01:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MzQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MzczOQ==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502093739", "bodyText": "Why system out print instead of log? If I redirect the test log into a file for debugging, I won't see this information.", "author": "jiajunwang", "createdAt": "2020-10-09T00:30:20Z", "path": "helix-core/src/test/java/org/apache/helix/common/ZkTestBase.java", "diffHunk": "@@ -719,6 +736,17 @@ public void cleanupLiveInstanceOwners() {\n       clientMap.clear();\n     }\n     _liveInstanceOwners.clear();\n+\n+    boolean status = false;\n+    try {\n+      status = ThreadLeakageChecker.afterClassCheck(testClassName);\n+    } catch (Exception e) {\n+      System.out.println(\"ThreadLeakageChecker exception:\" + e.getStackTrace());", "originalCommit": "976ffbb115d477d40249eb88c1e7d831c7b8f796", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjExODU2Mw==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502118563", "bodyText": "Good point. changed to log.error", "author": "kaisun2000", "createdAt": "2020-10-09T01:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5MzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjA5Mzk3Ng==", "url": "https://github.com/apache/helix/pull/1452#discussion_r502093976", "bodyText": "Same comments as the ZkTestBase class.", "author": "jiajunwang", "createdAt": "2020-10-09T00:31:18Z", "path": "helix-core/src/test/java/org/apache/helix/integration/multizk/TestMultiZkHelixJavaApis.java", "diffHunk": "@@ -170,6 +171,9 @@ public void beforeClass() throws Exception {\n \n   @AfterClass\n   public void afterClass() throws Exception {\n+    String testClassName = getClass().getSimpleName();\n+    System.out.println(\"AfterClass: \" + testClassName + \" of TestMultiZkHelixJavaApis called.\");", "originalCommit": "976ffbb115d477d40249eb88c1e7d831c7b8f796", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e67334efc6ac10f9d50ffee3240d774b90fe012d", "url": "https://github.com/apache/helix/commit/e67334efc6ac10f9d50ffee3240d774b90fe012d", "message": "address JJ's comments", "committedDate": "2020-10-09T01:20:07Z", "type": "commit"}, {"oid": "71f8f0667149f26e0c623662f7f641f5bc6bebb1", "url": "https://github.com/apache/helix/commit/71f8f0667149f26e0c623662f7f641f5bc6bebb1", "message": "address one more logging.", "committedDate": "2020-10-09T01:25:47Z", "type": "commit"}, {"oid": "5d0d97e14cc1db3dc984edcea9e2a1e4c8fbabed", "url": "https://github.com/apache/helix/commit/5d0d97e14cc1db3dc984edcea9e2a1e4c8fbabed", "message": "added todo to remove system.out and once we achieve 0 thread", "committedDate": "2020-10-09T19:40:51Z", "type": "commit"}]}