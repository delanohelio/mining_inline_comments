{"pr_number": 912, "pr_title": "Add integration test to customized view aggregation", "pr_createdAt": "2020-03-26T04:23:20Z", "pr_url": "https://github.com/apache/helix/pull/912", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyMjM5Mw==", "url": "https://github.com/apache/helix/pull/912#discussion_r398322393", "bodyText": "Let's try to make the naming convention more standard. It should have the type + number, and the number should start from 0 instead of 1.", "author": "zhangmeng916", "createdAt": "2020-03-26T05:15:55Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;", "originalCommit": "cd3bb8e1dc9a715fb413ecae735dace047559dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAyOTU4Ng==", "url": "https://github.com/apache/helix/pull/912#discussion_r399029586", "bodyText": "I think you meant the customized state values? I changed them to type + number. Please let me know if I didn't understand this correctly.", "author": "mgao0", "createdAt": "2020-03-27T04:31:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyMjM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNDI1NQ==", "url": "https://github.com/apache/helix/pull/912#discussion_r398324255", "bodyText": "This is not the right way to restrict the customized state types for aggregation. We should change the aggregation config to denote what are the states to be aggregated.", "author": "zhangmeng916", "createdAt": "2020-03-26T05:23:53Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;\n+  private String INSTANCE_1;\n+  private final String RESOURCE_A = \"TestDB0\";\n+  private final String RESOURCE_B = \"TestDB1\";\n+  private final String PARTITION_A1 = \"TestDB0_0\";\n+  private final String PARTITION_A2 = \"TestDB0_1\";\n+  private final String PARTITION_B1 = \"TestDB1_0\";\n+  private final String PARTITION_B2 = \"TestDB1_1\";\n+\n+  // Customized state values used for test, StatusA1 - StatusA3 are values for Customized state TypeA, etc.\n+  private enum CurrentStateValues {\n+    StatusA1, StatusA2, StatusA3, StatusB1, StatusB2, StatusB3, StatusC1, StatusC2, StatusC3\n+  }\n+\n+  private enum CustomizedStateType {\n+    TYPE_A, TYPE_B, TYPE_C\n+  }\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    int n = 2;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        2, // resources\n+        2, // partitions per resource\n+        n, // number of nodes\n+        2, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    // start participants\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    INSTANCE_0 = participants[0].getInstanceName();\n+    INSTANCE_1 = participants[1].getInstanceName();\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _spectator = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"spectator\", InstanceType.SPECTATOR, ZK_ADDR);\n+    _spectator.connect();\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();\n+\n+    // Initialize customized state provider\n+    _customizedStateProvider_participant0 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[0].getInstanceName());\n+    _customizedStateProvider_participant1 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[1].getInstanceName());\n+\n+    // Set up aggregation config\n+    List<String> aggregationEnabledTypes = Arrays\n+        .asList(CustomizedStateType.TYPE_A.name(), CustomizedStateType.TYPE_B.name(),\n+            CustomizedStateType.TYPE_C.name());\n+    CustomizedStateConfig.Builder customizedStateConfigBuilder =\n+        new CustomizedStateConfig.Builder();\n+    customizedStateConfigBuilder.setAggregationEnabledTypes(aggregationEnabledTypes);\n+    dataAccessor.updateProperty(dataAccessor.keyBuilder().customizedStateConfig(),\n+        customizedStateConfigBuilder.build());\n+\n+    _localCustomizedView = new HashMap<>();\n+    _localVisibleCustomizedStateType = new HashSet<>();\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _routingTableProvider.shutdown();\n+    _manager.disconnect();\n+    _spectator.disconnect();\n+  }\n+\n+  /**\n+   * Compare the customized state values between ZK and local record\n+   * @throws Exception thread interrupted exception\n+   */\n+  private void validateAggregationSnapshot() throws Exception {\n+    boolean result = TestHelper.verify(new TestHelper.Verifier() {\n+      @Override\n+      public boolean verify() {\n+        Map<String, Map<String, RoutingTableSnapshot>> routingTableSnapshots =\n+            _routingTableProvider.getRoutingTableSnapshots();\n+\n+        // Get customized view snapshot\n+        Map<String, RoutingTableSnapshot> fullCustomizedViewSnapshot =\n+            routingTableSnapshots.get(PropertyType.CUSTOMIZEDVIEW.name());\n+\n+        for (String customizedStateType : fullCustomizedViewSnapshot.keySet()) {\n+          if (!_localVisibleCustomizedStateType.contains(customizedStateType)) {\n+            System.out.println(\n+                \"Local record does not contain customized state type \" + customizedStateType\n+                    + \", while it is shown in snapshot\");\n+            return false;\n+          }\n+\n+          // Get per customized state type snapshot\n+          RoutingTableSnapshot customizedViewSnapshot =\n+              fullCustomizedViewSnapshot.get(customizedStateType);\n+\n+          // local per customized state type map\n+          Map<String, Map<String, Map<String, String>>> localSnapshot =\n+              _localCustomizedView.getOrDefault(customizedStateType, Maps.newHashMap());\n+\n+          Collection<CustomizedView> customizedViews = customizedViewSnapshot.getCustomizeViews();\n+\n+          // Get per resource snapshot\n+          for (CustomizedView resourceCustomizedView : customizedViews) {\n+            ZNRecord record = resourceCustomizedView.getRecord();\n+            Map<String, Map<String, String>> resourceStateMap = record.getMapFields();\n+\n+            // Get local per resource map\n+            Map<String, Map<String, String>> localPerResourceCustomizedView = localSnapshot\n+                .getOrDefault(resourceCustomizedView.getResourceName(), Maps.newHashMap());\n+\n+            // Get per partition snapshot\n+            for (String partitionName : resourceStateMap.keySet()) {\n+              Map<String, String> stateMap =\n+                  resourceStateMap.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              // Get local per partition map\n+              Map<String, String> localStateMap =\n+                  localPerResourceCustomizedView.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              for (String instanceName : stateMap.keySet()) {\n+                // Per instance value\n+                String stateMapValue = stateMap.get(instanceName);\n+                String localStateMapValue = localStateMap.get(instanceName);\n+                if (isEmptyValue(stateMapValue) && isEmptyValue(localStateMapValue)) {\n+                  return true;\n+                }\n+                if ((!isEmptyValue(stateMapValue) && !isEmptyValue(localStateMapValue)\n+                    && !stateMapValue.equals(localStateMapValue)) || (isEmptyValue(stateMapValue)\n+                    || isEmptyValue(localStateMapValue))) {\n+                  System.out.println(\"The customized state value is: \" + stateMapValue\n+                      + \", it does not match local record value: \" + localStateMapValue\n+                      + \", for instance \" + instanceName + \".\");\n+                  return false;\n+                }\n+                return true;\n+              }\n+            }\n+          }\n+        }\n+        return false; // There is no any customized state type enabled for aggregation set\n+      }\n+    }, 12000);\n+\n+    Assert.assertTrue(result);\n+  }\n+\n+  private boolean isEmptyValue(String value) {\n+    return value == null || value.equals(\"\");\n+  }\n+\n+  /**\n+   * Update the local record of customized state\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   */\n+  private void updateLocalCustomizedViewMap(String instanceName,\n+      CustomizedStateType customizedStateType, String resourceName, String partitionName,\n+      CurrentStateValues customizedStateValue) {\n+    _localCustomizedView.putIfAbsent(customizedStateType.name(), new TreeMap<>());\n+    Map<String, Map<String, Map<String, String>>> localPerStateType =\n+        _localCustomizedView.get(customizedStateType.name());\n+    localPerStateType.putIfAbsent(resourceName, new TreeMap<>());\n+    Map<String, Map<String, String>> localPerResource = localPerStateType.get(resourceName);\n+    localPerResource.putIfAbsent(partitionName, new TreeMap<>());\n+    Map<String, String> localPerPartition = localPerResource.get(partitionName);\n+    if (customizedStateValue == null) {\n+      localPerPartition.remove(instanceName);\n+    } else {\n+      localPerPartition.put(instanceName, customizedStateValue.name());\n+    }\n+  }\n+\n+  /**\n+   * Call this method in the test for an update on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void update(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName, CurrentStateValues customizedStateValue)\n+      throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   *\n+   * Call this method in the test for an delete on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void delete(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName) throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   * Set the customized state types to be listened by routing table provider\n+   * @param customizedStateTypes a list of the types to listen\n+   */\n+  private void setTypesToListenInRoutingTableProvider(\n+      List<CustomizedStateType> customizedStateTypes) {\n+    List<String> enabledTypes = new ArrayList<>();\n+    _localVisibleCustomizedStateType.clear();\n+    for (CustomizedStateType type : customizedStateTypes) {\n+      enabledTypes.add(type.name());\n+      _localVisibleCustomizedStateType.add(type.name());\n+    }\n+    Map<PropertyType, List<String>> dataSource = new HashMap<>();\n+    dataSource.put(PropertyType.CUSTOMIZEDVIEW, enabledTypes);\n+    _routingTableProvider = new RoutingTableProvider(_spectator, dataSource);\n+  }\n+\n+  /**\n+   * First update of customized state\n+   * Currently only aggregates CURRENT_STATE\n+   * instance    state type  resource    partition            key                 value\n+   * ---------------------------------------------------------------------------------\n+   *    0            A          A           1            CURRENT_STATE         StatusA1 - D\n+   *    0            B          A           1            CURRENT_STATE         StatusB1\n+   *    0            B          A           2            CURRENT_STATE         StatusB2  -M -> StatusB3\n+   *    0            A          B           2            CURRENT_STATE         StatusA2  -M -> StatusA1\n+   *    1            C          A           1            CURRENT_STATE         StatusC1\n+   *    1            C          A           2            CURRENT_STATE         StatusC2\n+   *    1            A          B           1            CURRENT_STATE         StatusA3 -D\n+   *    1            B          B           1            CURRENT_STATE         StatusB3 -D -M-> StatusB2\n+   *    1            C          B           1            CURRENT_STATE         StatusC3 -M -> StatusC1\n+   *\n+   *    -D: to be deleted in the test\n+   *    -M: to be modified in the test\n+   */\n+  @Test\n+  public void testCustomizedStateViewAggregation() throws Exception {\n+\n+    update(INSTANCE_0, CustomizedStateType.TYPE_A, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusA1);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_B, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusB1);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_B, RESOURCE_A, PARTITION_A2,\n+        CurrentStateValues.StatusB2);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_A, RESOURCE_B, PARTITION_B2,\n+        CurrentStateValues.StatusA2);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_C, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusC1);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_C, RESOURCE_A, PARTITION_A2,\n+        CurrentStateValues.StatusC2);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_A, RESOURCE_B, PARTITION_B1,\n+        CurrentStateValues.StatusA3);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_B, RESOURCE_B, PARTITION_B1,\n+        CurrentStateValues.StatusB3);\n+\n+    // Test batch update API to update several customized states in the same customized state type for one resource, but for now only CURRENT_STATE will be aggregated in customized view\n+    Map<String, String> customizedStates = Maps.newHashMap();\n+    customizedStates.put(\"CURRENT_STATE\", CurrentStateValues.StatusC3.name());\n+    customizedStates.put(\"PREVIOUS_STATE\", CurrentStateValues.StatusC1.name());\n+    _customizedStateProvider_participant1\n+        .updateCustomizedState(CustomizedStateType.TYPE_C.name(), RESOURCE_B, PARTITION_B1,\n+            customizedStates);\n+    updateLocalCustomizedViewMap(INSTANCE_1, CustomizedStateType.TYPE_C, RESOURCE_B, PARTITION_B1,\n+        CurrentStateValues.StatusC3);\n+\n+    // Only listen to Type A\n+    setTypesToListenInRoutingTableProvider(Arrays.asList(CustomizedStateType.TYPE_A));", "originalCommit": "cd3bb8e1dc9a715fb413ecae735dace047559dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAzNDk4NQ==", "url": "https://github.com/apache/helix/pull/912#discussion_r399034985", "bodyText": "Added the changes in aggregation config. Now I am testing both changing aggregation config and routing table provider data sources.", "author": "mgao0", "createdAt": "2020-03-27T04:53:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNDI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNDczMg==", "url": "https://github.com/apache/helix/pull/912#discussion_r398324732", "bodyText": "To be more accurate, it's not several customized states. It's one customized state with different fields. We do not support multiple customized state update.", "author": "zhangmeng916", "createdAt": "2020-03-26T05:25:56Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;\n+  private String INSTANCE_1;\n+  private final String RESOURCE_A = \"TestDB0\";\n+  private final String RESOURCE_B = \"TestDB1\";\n+  private final String PARTITION_A1 = \"TestDB0_0\";\n+  private final String PARTITION_A2 = \"TestDB0_1\";\n+  private final String PARTITION_B1 = \"TestDB1_0\";\n+  private final String PARTITION_B2 = \"TestDB1_1\";\n+\n+  // Customized state values used for test, StatusA1 - StatusA3 are values for Customized state TypeA, etc.\n+  private enum CurrentStateValues {\n+    StatusA1, StatusA2, StatusA3, StatusB1, StatusB2, StatusB3, StatusC1, StatusC2, StatusC3\n+  }\n+\n+  private enum CustomizedStateType {\n+    TYPE_A, TYPE_B, TYPE_C\n+  }\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    int n = 2;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        2, // resources\n+        2, // partitions per resource\n+        n, // number of nodes\n+        2, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    // start participants\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    INSTANCE_0 = participants[0].getInstanceName();\n+    INSTANCE_1 = participants[1].getInstanceName();\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _spectator = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"spectator\", InstanceType.SPECTATOR, ZK_ADDR);\n+    _spectator.connect();\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();\n+\n+    // Initialize customized state provider\n+    _customizedStateProvider_participant0 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[0].getInstanceName());\n+    _customizedStateProvider_participant1 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[1].getInstanceName());\n+\n+    // Set up aggregation config\n+    List<String> aggregationEnabledTypes = Arrays\n+        .asList(CustomizedStateType.TYPE_A.name(), CustomizedStateType.TYPE_B.name(),\n+            CustomizedStateType.TYPE_C.name());\n+    CustomizedStateConfig.Builder customizedStateConfigBuilder =\n+        new CustomizedStateConfig.Builder();\n+    customizedStateConfigBuilder.setAggregationEnabledTypes(aggregationEnabledTypes);\n+    dataAccessor.updateProperty(dataAccessor.keyBuilder().customizedStateConfig(),\n+        customizedStateConfigBuilder.build());\n+\n+    _localCustomizedView = new HashMap<>();\n+    _localVisibleCustomizedStateType = new HashSet<>();\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _routingTableProvider.shutdown();\n+    _manager.disconnect();\n+    _spectator.disconnect();\n+  }\n+\n+  /**\n+   * Compare the customized state values between ZK and local record\n+   * @throws Exception thread interrupted exception\n+   */\n+  private void validateAggregationSnapshot() throws Exception {\n+    boolean result = TestHelper.verify(new TestHelper.Verifier() {\n+      @Override\n+      public boolean verify() {\n+        Map<String, Map<String, RoutingTableSnapshot>> routingTableSnapshots =\n+            _routingTableProvider.getRoutingTableSnapshots();\n+\n+        // Get customized view snapshot\n+        Map<String, RoutingTableSnapshot> fullCustomizedViewSnapshot =\n+            routingTableSnapshots.get(PropertyType.CUSTOMIZEDVIEW.name());\n+\n+        for (String customizedStateType : fullCustomizedViewSnapshot.keySet()) {\n+          if (!_localVisibleCustomizedStateType.contains(customizedStateType)) {\n+            System.out.println(\n+                \"Local record does not contain customized state type \" + customizedStateType\n+                    + \", while it is shown in snapshot\");\n+            return false;\n+          }\n+\n+          // Get per customized state type snapshot\n+          RoutingTableSnapshot customizedViewSnapshot =\n+              fullCustomizedViewSnapshot.get(customizedStateType);\n+\n+          // local per customized state type map\n+          Map<String, Map<String, Map<String, String>>> localSnapshot =\n+              _localCustomizedView.getOrDefault(customizedStateType, Maps.newHashMap());\n+\n+          Collection<CustomizedView> customizedViews = customizedViewSnapshot.getCustomizeViews();\n+\n+          // Get per resource snapshot\n+          for (CustomizedView resourceCustomizedView : customizedViews) {\n+            ZNRecord record = resourceCustomizedView.getRecord();\n+            Map<String, Map<String, String>> resourceStateMap = record.getMapFields();\n+\n+            // Get local per resource map\n+            Map<String, Map<String, String>> localPerResourceCustomizedView = localSnapshot\n+                .getOrDefault(resourceCustomizedView.getResourceName(), Maps.newHashMap());\n+\n+            // Get per partition snapshot\n+            for (String partitionName : resourceStateMap.keySet()) {\n+              Map<String, String> stateMap =\n+                  resourceStateMap.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              // Get local per partition map\n+              Map<String, String> localStateMap =\n+                  localPerResourceCustomizedView.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              for (String instanceName : stateMap.keySet()) {\n+                // Per instance value\n+                String stateMapValue = stateMap.get(instanceName);\n+                String localStateMapValue = localStateMap.get(instanceName);\n+                if (isEmptyValue(stateMapValue) && isEmptyValue(localStateMapValue)) {\n+                  return true;\n+                }\n+                if ((!isEmptyValue(stateMapValue) && !isEmptyValue(localStateMapValue)\n+                    && !stateMapValue.equals(localStateMapValue)) || (isEmptyValue(stateMapValue)\n+                    || isEmptyValue(localStateMapValue))) {\n+                  System.out.println(\"The customized state value is: \" + stateMapValue\n+                      + \", it does not match local record value: \" + localStateMapValue\n+                      + \", for instance \" + instanceName + \".\");\n+                  return false;\n+                }\n+                return true;\n+              }\n+            }\n+          }\n+        }\n+        return false; // There is no any customized state type enabled for aggregation set\n+      }\n+    }, 12000);\n+\n+    Assert.assertTrue(result);\n+  }\n+\n+  private boolean isEmptyValue(String value) {\n+    return value == null || value.equals(\"\");\n+  }\n+\n+  /**\n+   * Update the local record of customized state\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   */\n+  private void updateLocalCustomizedViewMap(String instanceName,\n+      CustomizedStateType customizedStateType, String resourceName, String partitionName,\n+      CurrentStateValues customizedStateValue) {\n+    _localCustomizedView.putIfAbsent(customizedStateType.name(), new TreeMap<>());\n+    Map<String, Map<String, Map<String, String>>> localPerStateType =\n+        _localCustomizedView.get(customizedStateType.name());\n+    localPerStateType.putIfAbsent(resourceName, new TreeMap<>());\n+    Map<String, Map<String, String>> localPerResource = localPerStateType.get(resourceName);\n+    localPerResource.putIfAbsent(partitionName, new TreeMap<>());\n+    Map<String, String> localPerPartition = localPerResource.get(partitionName);\n+    if (customizedStateValue == null) {\n+      localPerPartition.remove(instanceName);\n+    } else {\n+      localPerPartition.put(instanceName, customizedStateValue.name());\n+    }\n+  }\n+\n+  /**\n+   * Call this method in the test for an update on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void update(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName, CurrentStateValues customizedStateValue)\n+      throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   *\n+   * Call this method in the test for an delete on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void delete(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName) throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   * Set the customized state types to be listened by routing table provider\n+   * @param customizedStateTypes a list of the types to listen\n+   */\n+  private void setTypesToListenInRoutingTableProvider(\n+      List<CustomizedStateType> customizedStateTypes) {\n+    List<String> enabledTypes = new ArrayList<>();\n+    _localVisibleCustomizedStateType.clear();\n+    for (CustomizedStateType type : customizedStateTypes) {\n+      enabledTypes.add(type.name());\n+      _localVisibleCustomizedStateType.add(type.name());\n+    }\n+    Map<PropertyType, List<String>> dataSource = new HashMap<>();\n+    dataSource.put(PropertyType.CUSTOMIZEDVIEW, enabledTypes);\n+    _routingTableProvider = new RoutingTableProvider(_spectator, dataSource);\n+  }\n+\n+  /**\n+   * First update of customized state\n+   * Currently only aggregates CURRENT_STATE\n+   * instance    state type  resource    partition            key                 value\n+   * ---------------------------------------------------------------------------------\n+   *    0            A          A           1            CURRENT_STATE         StatusA1 - D\n+   *    0            B          A           1            CURRENT_STATE         StatusB1\n+   *    0            B          A           2            CURRENT_STATE         StatusB2  -M -> StatusB3\n+   *    0            A          B           2            CURRENT_STATE         StatusA2  -M -> StatusA1\n+   *    1            C          A           1            CURRENT_STATE         StatusC1\n+   *    1            C          A           2            CURRENT_STATE         StatusC2\n+   *    1            A          B           1            CURRENT_STATE         StatusA3 -D\n+   *    1            B          B           1            CURRENT_STATE         StatusB3 -D -M-> StatusB2\n+   *    1            C          B           1            CURRENT_STATE         StatusC3 -M -> StatusC1\n+   *\n+   *    -D: to be deleted in the test\n+   *    -M: to be modified in the test\n+   */\n+  @Test\n+  public void testCustomizedStateViewAggregation() throws Exception {\n+\n+    update(INSTANCE_0, CustomizedStateType.TYPE_A, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusA1);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_B, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusB1);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_B, RESOURCE_A, PARTITION_A2,\n+        CurrentStateValues.StatusB2);\n+    update(INSTANCE_0, CustomizedStateType.TYPE_A, RESOURCE_B, PARTITION_B2,\n+        CurrentStateValues.StatusA2);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_C, RESOURCE_A, PARTITION_A1,\n+        CurrentStateValues.StatusC1);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_C, RESOURCE_A, PARTITION_A2,\n+        CurrentStateValues.StatusC2);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_A, RESOURCE_B, PARTITION_B1,\n+        CurrentStateValues.StatusA3);\n+    update(INSTANCE_1, CustomizedStateType.TYPE_B, RESOURCE_B, PARTITION_B1,\n+        CurrentStateValues.StatusB3);\n+\n+    // Test batch update API to update several customized states in the same customized state type for one resource, but for now only CURRENT_STATE will be aggregated in customized view", "originalCommit": "cd3bb8e1dc9a715fb413ecae735dace047559dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAyOTY0MQ==", "url": "https://github.com/apache/helix/pull/912#discussion_r399029641", "bodyText": "Changed the expression.", "author": "mgao0", "createdAt": "2020-03-27T04:31:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNDczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTEyNA==", "url": "https://github.com/apache/helix/pull/912#discussion_r398325124", "bodyText": "We may not need this mapping when checking in the code. If the comment is clear enough, we're fine. Also it's a bit hard to read this mapping due to the state type and resource are both named with A, B, C.", "author": "zhangmeng916", "createdAt": "2020-03-26T05:27:27Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;\n+  private String INSTANCE_1;\n+  private final String RESOURCE_A = \"TestDB0\";\n+  private final String RESOURCE_B = \"TestDB1\";\n+  private final String PARTITION_A1 = \"TestDB0_0\";\n+  private final String PARTITION_A2 = \"TestDB0_1\";\n+  private final String PARTITION_B1 = \"TestDB1_0\";\n+  private final String PARTITION_B2 = \"TestDB1_1\";\n+\n+  // Customized state values used for test, StatusA1 - StatusA3 are values for Customized state TypeA, etc.\n+  private enum CurrentStateValues {\n+    StatusA1, StatusA2, StatusA3, StatusB1, StatusB2, StatusB3, StatusC1, StatusC2, StatusC3\n+  }\n+\n+  private enum CustomizedStateType {\n+    TYPE_A, TYPE_B, TYPE_C\n+  }\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    int n = 2;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        2, // resources\n+        2, // partitions per resource\n+        n, // number of nodes\n+        2, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    // start participants\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    INSTANCE_0 = participants[0].getInstanceName();\n+    INSTANCE_1 = participants[1].getInstanceName();\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _spectator = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"spectator\", InstanceType.SPECTATOR, ZK_ADDR);\n+    _spectator.connect();\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();\n+\n+    // Initialize customized state provider\n+    _customizedStateProvider_participant0 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[0].getInstanceName());\n+    _customizedStateProvider_participant1 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[1].getInstanceName());\n+\n+    // Set up aggregation config\n+    List<String> aggregationEnabledTypes = Arrays\n+        .asList(CustomizedStateType.TYPE_A.name(), CustomizedStateType.TYPE_B.name(),\n+            CustomizedStateType.TYPE_C.name());\n+    CustomizedStateConfig.Builder customizedStateConfigBuilder =\n+        new CustomizedStateConfig.Builder();\n+    customizedStateConfigBuilder.setAggregationEnabledTypes(aggregationEnabledTypes);\n+    dataAccessor.updateProperty(dataAccessor.keyBuilder().customizedStateConfig(),\n+        customizedStateConfigBuilder.build());\n+\n+    _localCustomizedView = new HashMap<>();\n+    _localVisibleCustomizedStateType = new HashSet<>();\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _routingTableProvider.shutdown();\n+    _manager.disconnect();\n+    _spectator.disconnect();\n+  }\n+\n+  /**\n+   * Compare the customized state values between ZK and local record\n+   * @throws Exception thread interrupted exception\n+   */\n+  private void validateAggregationSnapshot() throws Exception {\n+    boolean result = TestHelper.verify(new TestHelper.Verifier() {\n+      @Override\n+      public boolean verify() {\n+        Map<String, Map<String, RoutingTableSnapshot>> routingTableSnapshots =\n+            _routingTableProvider.getRoutingTableSnapshots();\n+\n+        // Get customized view snapshot\n+        Map<String, RoutingTableSnapshot> fullCustomizedViewSnapshot =\n+            routingTableSnapshots.get(PropertyType.CUSTOMIZEDVIEW.name());\n+\n+        for (String customizedStateType : fullCustomizedViewSnapshot.keySet()) {\n+          if (!_localVisibleCustomizedStateType.contains(customizedStateType)) {\n+            System.out.println(\n+                \"Local record does not contain customized state type \" + customizedStateType\n+                    + \", while it is shown in snapshot\");\n+            return false;\n+          }\n+\n+          // Get per customized state type snapshot\n+          RoutingTableSnapshot customizedViewSnapshot =\n+              fullCustomizedViewSnapshot.get(customizedStateType);\n+\n+          // local per customized state type map\n+          Map<String, Map<String, Map<String, String>>> localSnapshot =\n+              _localCustomizedView.getOrDefault(customizedStateType, Maps.newHashMap());\n+\n+          Collection<CustomizedView> customizedViews = customizedViewSnapshot.getCustomizeViews();\n+\n+          // Get per resource snapshot\n+          for (CustomizedView resourceCustomizedView : customizedViews) {\n+            ZNRecord record = resourceCustomizedView.getRecord();\n+            Map<String, Map<String, String>> resourceStateMap = record.getMapFields();\n+\n+            // Get local per resource map\n+            Map<String, Map<String, String>> localPerResourceCustomizedView = localSnapshot\n+                .getOrDefault(resourceCustomizedView.getResourceName(), Maps.newHashMap());\n+\n+            // Get per partition snapshot\n+            for (String partitionName : resourceStateMap.keySet()) {\n+              Map<String, String> stateMap =\n+                  resourceStateMap.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              // Get local per partition map\n+              Map<String, String> localStateMap =\n+                  localPerResourceCustomizedView.getOrDefault(partitionName, Maps.newTreeMap());\n+\n+              for (String instanceName : stateMap.keySet()) {\n+                // Per instance value\n+                String stateMapValue = stateMap.get(instanceName);\n+                String localStateMapValue = localStateMap.get(instanceName);\n+                if (isEmptyValue(stateMapValue) && isEmptyValue(localStateMapValue)) {\n+                  return true;\n+                }\n+                if ((!isEmptyValue(stateMapValue) && !isEmptyValue(localStateMapValue)\n+                    && !stateMapValue.equals(localStateMapValue)) || (isEmptyValue(stateMapValue)\n+                    || isEmptyValue(localStateMapValue))) {\n+                  System.out.println(\"The customized state value is: \" + stateMapValue\n+                      + \", it does not match local record value: \" + localStateMapValue\n+                      + \", for instance \" + instanceName + \".\");\n+                  return false;\n+                }\n+                return true;\n+              }\n+            }\n+          }\n+        }\n+        return false; // There is no any customized state type enabled for aggregation set\n+      }\n+    }, 12000);\n+\n+    Assert.assertTrue(result);\n+  }\n+\n+  private boolean isEmptyValue(String value) {\n+    return value == null || value.equals(\"\");\n+  }\n+\n+  /**\n+   * Update the local record of customized state\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   */\n+  private void updateLocalCustomizedViewMap(String instanceName,\n+      CustomizedStateType customizedStateType, String resourceName, String partitionName,\n+      CurrentStateValues customizedStateValue) {\n+    _localCustomizedView.putIfAbsent(customizedStateType.name(), new TreeMap<>());\n+    Map<String, Map<String, Map<String, String>>> localPerStateType =\n+        _localCustomizedView.get(customizedStateType.name());\n+    localPerStateType.putIfAbsent(resourceName, new TreeMap<>());\n+    Map<String, Map<String, String>> localPerResource = localPerStateType.get(resourceName);\n+    localPerResource.putIfAbsent(partitionName, new TreeMap<>());\n+    Map<String, String> localPerPartition = localPerResource.get(partitionName);\n+    if (customizedStateValue == null) {\n+      localPerPartition.remove(instanceName);\n+    } else {\n+      localPerPartition.put(instanceName, customizedStateValue.name());\n+    }\n+  }\n+\n+  /**\n+   * Call this method in the test for an update on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @param customizedStateValue if update, this will be the value to update; a null value indicate delete operation\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void update(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName, CurrentStateValues customizedStateValue)\n+      throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .updateCustomizedState(customizedStateType.name(), resourceName, partitionName,\n+              customizedStateValue.name());\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          customizedStateValue);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   *\n+   * Call this method in the test for an delete on customized state in both ZK and local map\n+   * @param instanceName the instance to be updated\n+   * @param customizedStateType the customized state type to be updated\n+   * @param resourceName the resource to be updated\n+   * @param partitionName the partition to be updated\n+   * @throws Exception if the input instance name is not valid\n+   */\n+  private void delete(String instanceName, CustomizedStateType customizedStateType,\n+      String resourceName, String partitionName) throws Exception {\n+    if (instanceName.equals(INSTANCE_0)) {\n+      _customizedStateProvider_participant0\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_0, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else if (instanceName.equals(INSTANCE_1)) {\n+      _customizedStateProvider_participant1\n+          .deletePerPartitionCustomizedState(customizedStateType.name(), resourceName,\n+              partitionName);\n+      updateLocalCustomizedViewMap(INSTANCE_1, customizedStateType, resourceName, partitionName,\n+          null);\n+    } else {\n+      throw new Exception(\"The input instance name is not valid.\");\n+    }\n+  }\n+\n+  /**\n+   * Set the customized state types to be listened by routing table provider\n+   * @param customizedStateTypes a list of the types to listen\n+   */\n+  private void setTypesToListenInRoutingTableProvider(\n+      List<CustomizedStateType> customizedStateTypes) {\n+    List<String> enabledTypes = new ArrayList<>();\n+    _localVisibleCustomizedStateType.clear();\n+    for (CustomizedStateType type : customizedStateTypes) {\n+      enabledTypes.add(type.name());\n+      _localVisibleCustomizedStateType.add(type.name());\n+    }\n+    Map<PropertyType, List<String>> dataSource = new HashMap<>();\n+    dataSource.put(PropertyType.CUSTOMIZEDVIEW, enabledTypes);\n+    _routingTableProvider = new RoutingTableProvider(_spectator, dataSource);\n+  }\n+\n+  /**\n+   * First update of customized state", "originalCommit": "cd3bb8e1dc9a715fb413ecae735dace047559dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAyOTc3NA==", "url": "https://github.com/apache/helix/pull/912#discussion_r399029774", "bodyText": "Makes sense. I removed the comments.", "author": "mgao0", "createdAt": "2020-03-27T04:32:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTU1NQ==", "url": "https://github.com/apache/helix/pull/912#discussion_r398325555", "bodyText": "This is not the right description. Aggregation config controls which customized states are aggregated into customized view, and routing table provider listens to that customized view. Routing table provider does not have the ability to make choice, and it'll listen to all changes in customized view.", "author": "zhangmeng916", "createdAt": "2020-03-26T05:29:11Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider", "originalCommit": "cd3bb8e1dc9a715fb413ecae735dace047559dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAzMTgwOA==", "url": "https://github.com/apache/helix/pull/912#discussion_r399031808", "bodyText": "I changed the comment. Please take a look and see if it is correct.", "author": "mgao0", "createdAt": "2020-03-27T04:41:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTU1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTk3NA==", "url": "https://github.com/apache/helix/pull/912#discussion_r398325974", "bodyText": "customized state values -> customized view values.\nState is the raw data input, and view is the aggregated output.", "author": "zhangmeng916", "createdAt": "2020-03-26T05:30:51Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;\n+  private String INSTANCE_1;\n+  private final String RESOURCE_A = \"TestDB0\";\n+  private final String RESOURCE_B = \"TestDB1\";\n+  private final String PARTITION_A1 = \"TestDB0_0\";\n+  private final String PARTITION_A2 = \"TestDB0_1\";\n+  private final String PARTITION_B1 = \"TestDB1_0\";\n+  private final String PARTITION_B2 = \"TestDB1_1\";\n+\n+  // Customized state values used for test, StatusA1 - StatusA3 are values for Customized state TypeA, etc.\n+  private enum CurrentStateValues {\n+    StatusA1, StatusA2, StatusA3, StatusB1, StatusB2, StatusB3, StatusC1, StatusC2, StatusC3\n+  }\n+\n+  private enum CustomizedStateType {\n+    TYPE_A, TYPE_B, TYPE_C\n+  }\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    int n = 2;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        2, // resources\n+        2, // partitions per resource\n+        n, // number of nodes\n+        2, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    // start participants\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    INSTANCE_0 = participants[0].getInstanceName();\n+    INSTANCE_1 = participants[1].getInstanceName();\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _spectator = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"spectator\", InstanceType.SPECTATOR, ZK_ADDR);\n+    _spectator.connect();\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();\n+\n+    // Initialize customized state provider\n+    _customizedStateProvider_participant0 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[0].getInstanceName());\n+    _customizedStateProvider_participant1 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[1].getInstanceName());\n+\n+    // Set up aggregation config\n+    List<String> aggregationEnabledTypes = Arrays\n+        .asList(CustomizedStateType.TYPE_A.name(), CustomizedStateType.TYPE_B.name(),\n+            CustomizedStateType.TYPE_C.name());\n+    CustomizedStateConfig.Builder customizedStateConfigBuilder =\n+        new CustomizedStateConfig.Builder();\n+    customizedStateConfigBuilder.setAggregationEnabledTypes(aggregationEnabledTypes);\n+    dataAccessor.updateProperty(dataAccessor.keyBuilder().customizedStateConfig(),\n+        customizedStateConfigBuilder.build());\n+\n+    _localCustomizedView = new HashMap<>();\n+    _localVisibleCustomizedStateType = new HashSet<>();\n+  }\n+\n+  @AfterClass\n+  public void afterClass() {\n+    _routingTableProvider.shutdown();\n+    _manager.disconnect();\n+    _spectator.disconnect();\n+  }\n+\n+  /**\n+   * Compare the customized state values between ZK and local record", "originalCommit": "cd3bb8e1dc9a715fb413ecae735dace047559dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAzMzA4Mg==", "url": "https://github.com/apache/helix/pull/912#discussion_r399033082", "bodyText": "Updated.", "author": "mgao0", "createdAt": "2020-03-27T04:45:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNjk1OA==", "url": "https://github.com/apache/helix/pull/912#discussion_r398326958", "bodyText": "This is the right way to change aggregation enabled types config. In the following test, you should change this config to determine which state type should be aggregated and will be shown in customized view (then read by routing table provider).", "author": "zhangmeng916", "createdAt": "2020-03-26T05:34:28Z", "path": "helix-core/src/test/java/org/apache/helix/integration/TestCustomizedViewAggregation.java", "diffHunk": "@@ -0,0 +1,404 @@\n+package org.apache.helix.integration;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import com.google.common.collect.Maps;\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.HelixManagerFactory;\n+import org.apache.helix.InstanceType;\n+import org.apache.helix.PropertyType;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZNRecord;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.customizedstate.CustomizedStateProvider;\n+import org.apache.helix.customizedstate.CustomizedStateProviderFactory;\n+import org.apache.helix.integration.manager.ClusterControllerManager;\n+import org.apache.helix.integration.manager.MockParticipantManager;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.spectator.RoutingTableProvider;\n+import org.apache.helix.spectator.RoutingTableSnapshot;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewAggregation extends ZkUnitTestBase {\n+\n+  private static CustomizedStateProvider _customizedStateProvider_participant0;\n+  private static CustomizedStateProvider _customizedStateProvider_participant1;\n+  private static RoutingTableProvider _routingTableProvider;\n+  private static HelixManager _spectator;\n+  private static HelixManager _manager;\n+  // 1st key: customized state type, 2nd key: resource name, 3rd key: partition name, 4th key: instance name, value: state value\n+  // This map contains all the customized state information that is enabled for aggregation in config, including those are not listened by routing table provider\n+  private static Map<String, Map<String, Map<String, Map<String, String>>>> _localCustomizedView;\n+  // The set contains customized state types that are listened by routing table provider\n+  private static Set<String> _localVisibleCustomizedStateType;\n+  private String INSTANCE_0;\n+  private String INSTANCE_1;\n+  private final String RESOURCE_A = \"TestDB0\";\n+  private final String RESOURCE_B = \"TestDB1\";\n+  private final String PARTITION_A1 = \"TestDB0_0\";\n+  private final String PARTITION_A2 = \"TestDB0_1\";\n+  private final String PARTITION_B1 = \"TestDB1_0\";\n+  private final String PARTITION_B2 = \"TestDB1_1\";\n+\n+  // Customized state values used for test, StatusA1 - StatusA3 are values for Customized state TypeA, etc.\n+  private enum CurrentStateValues {\n+    StatusA1, StatusA2, StatusA3, StatusB1, StatusB2, StatusB3, StatusC1, StatusC2, StatusC3\n+  }\n+\n+  private enum CustomizedStateType {\n+    TYPE_A, TYPE_B, TYPE_C\n+  }\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+\n+    String className = TestHelper.getTestClassName();\n+    String methodName = TestHelper.getTestMethodName();\n+    String clusterName = className + \"_\" + methodName;\n+    int n = 2;\n+\n+    System.out.println(\"START \" + clusterName + \" at \" + new Date(System.currentTimeMillis()));\n+\n+    TestHelper.setupCluster(clusterName, ZK_ADDR, 12918, // participant port\n+        \"localhost\", // participant name prefix\n+        \"TestDB\", // resource name prefix\n+        2, // resources\n+        2, // partitions per resource\n+        n, // number of nodes\n+        2, // replicas\n+        \"MasterSlave\", true); // do rebalance\n+\n+    ClusterControllerManager controller =\n+        new ClusterControllerManager(ZK_ADDR, clusterName, \"controller_0\");\n+    controller.syncStart();\n+\n+    // start participants\n+    MockParticipantManager[] participants = new MockParticipantManager[n];\n+    for (int i = 0; i < n; i++) {\n+      String instanceName = \"localhost_\" + (12918 + i);\n+\n+      participants[i] = new MockParticipantManager(ZK_ADDR, clusterName, instanceName);\n+      participants[i].syncStart();\n+    }\n+\n+    INSTANCE_0 = participants[0].getInstanceName();\n+    INSTANCE_1 = participants[1].getInstanceName();\n+\n+    _manager = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"admin\", InstanceType.ADMINISTRATOR, ZK_ADDR);\n+    _manager.connect();\n+\n+    _spectator = HelixManagerFactory\n+        .getZKHelixManager(clusterName, \"spectator\", InstanceType.SPECTATOR, ZK_ADDR);\n+    _spectator.connect();\n+    HelixDataAccessor dataAccessor = _manager.getHelixDataAccessor();\n+\n+    // Initialize customized state provider\n+    _customizedStateProvider_participant0 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[0].getInstanceName());\n+    _customizedStateProvider_participant1 = CustomizedStateProviderFactory.getInstance()\n+        .buildCustomizedStateProvider(_manager, participants[1].getInstanceName());\n+\n+    // Set up aggregation config\n+    List<String> aggregationEnabledTypes = Arrays", "originalCommit": "cd3bb8e1dc9a715fb413ecae735dace047559dbc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAzMzI1NA==", "url": "https://github.com/apache/helix/pull/912#discussion_r399033254", "bodyText": "I didn't test the aggregation config in this version. In the new version, I added a few more tests on updating the aggregation config.", "author": "mgao0", "createdAt": "2020-03-27T04:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODMyNjk1OA=="}], "type": "inlineReview"}, {"oid": "ef9773b5dc4570496fb2a08c0820fba1d7e4bd91", "url": "https://github.com/apache/helix/commit/ef9773b5dc4570496fb2a08c0820fba1d7e4bd91", "message": "Added integration test for customized view aggregation", "committedDate": "2020-03-31T06:15:45Z", "type": "commit"}, {"oid": "332ecb6161dc31fa20a8b49225097dc705a205a1", "url": "https://github.com/apache/helix/commit/332ecb6161dc31fa20a8b49225097dc705a205a1", "message": "Modified test", "committedDate": "2020-03-31T06:15:45Z", "type": "commit"}, {"oid": "b2d6f5e7a955c9e179eefcd3654a17615ea8df7a", "url": "https://github.com/apache/helix/commit/b2d6f5e7a955c9e179eefcd3654a17615ea8df7a", "message": "Fix set addAll UnsupportedOperationException", "committedDate": "2020-03-31T16:40:40Z", "type": "commit"}, {"oid": "b2d6f5e7a955c9e179eefcd3654a17615ea8df7a", "url": "https://github.com/apache/helix/commit/b2d6f5e7a955c9e179eefcd3654a17615ea8df7a", "message": "Fix set addAll UnsupportedOperationException", "committedDate": "2020-03-31T16:40:40Z", "type": "forcePushed"}]}