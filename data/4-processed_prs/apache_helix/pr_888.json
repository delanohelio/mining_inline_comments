{"pr_number": 888, "pr_title": "Modify data providers and add customized view aggregation stage", "pr_createdAt": "2020-03-12T17:58:49Z", "pr_url": "https://github.com/apache/helix/pull/888", "timeline": [{"oid": "6bad0aa18fa10f9d9cf65608f3571ec8ebd87446", "url": "https://github.com/apache/helix/commit/6bad0aa18fa10f9d9cf65608f3571ec8ebd87446", "message": "modify providers and add customized view aggregation stage", "committedDate": "2020-03-12T17:53:49Z", "type": "commit"}, {"oid": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "url": "https://github.com/apache/helix/commit/ee66bf8f53084ac086d9b0282d239b813c6afc75", "message": "add one more stage", "committedDate": "2020-03-12T18:11:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MTA0Ng==", "url": "https://github.com/apache/helix/pull/888#discussion_r392541046", "bodyText": "Instead of calling the raw method, do we have a method in customizedStateConfig to get the types?", "author": "jiajunwang", "createdAt": "2020-03-14T00:54:23Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -286,6 +292,27 @@ private void refreshResourceConfig(final HelixDataAccessor accessor,\n     }\n   }\n \n+  private void refreshCustomizedStateConfig(final HelixDataAccessor accessor,\n+      Set<HelixConstants.ChangeType> refreshedType) {\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_STATE_CONFIG)\n+        .getAndSet(false)) {\n+      CustomizedStateConfig customizedStateConfig =\n+          accessor.getProperty(accessor.keyBuilder().customizedStateConfig());\n+      if (customizedStateConfig != null) {\n+        _aggregationEnabledTypes = new HashSet<>(customizedStateConfig.getRecord().getListFields()\n+            .get(CustomizedStateConfig.CustomizedStateProperty.AGGREGATION_ENABLED_TYPES.name()));", "originalCommit": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MTMzNQ==", "url": "https://github.com/apache/helix/pull/888#discussion_r392541335", "bodyText": "getEnabledCustomizedStateTypes()?", "author": "jiajunwang", "createdAt": "2020-03-14T00:56:34Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -374,6 +405,14 @@ public void setClusterConfig(ClusterConfig clusterConfig) {\n     _clusterConfig = clusterConfig;\n   }\n \n+  public Set<String> getCustomizedStateConfig() {", "originalCommit": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MTQzNQ==", "url": "https://github.com/apache/helix/pull/888#discussion_r392541435", "bodyText": "Same, the name should reflect what we set. Moreover, do we need this set to be public?", "author": "jiajunwang", "createdAt": "2020-03-14T00:57:20Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -374,6 +405,14 @@ public void setClusterConfig(ClusterConfig clusterConfig) {\n     _clusterConfig = clusterConfig;\n   }\n \n+  public Set<String> getCustomizedStateConfig() {\n+    return _aggregationEnabledTypes;\n+  }\n+\n+  public void setCustomizedStateConfig(Set<String> aggregationEnabledTypes) {", "originalCommit": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1ODM3NA==", "url": "https://github.com/apache/helix/pull/888#discussion_r392558374", "bodyText": "It's likely to be only used in test for now. So I keep it as public.", "author": "zhangmeng916", "createdAt": "2020-03-14T05:20:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MTQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MjMyMw==", "url": "https://github.com/apache/helix/pull/888#discussion_r392542323", "bodyText": "The map is initialized as en empty map. Do we need to check for NPE here?", "author": "jiajunwang", "createdAt": "2020-03-14T01:05:40Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -156,6 +161,23 @@ private void refreshTargetExternalViews(final HelixDataAccessor accessor) {\n     }\n   }\n \n+  public void refreshCustomizedViewMap(final HelixDataAccessor accessor) {\n+    // As we are not listening on customized view change, customized view will be\n+    // refreshed once during the cache's first refresh() call, or when full refresh is required\n+    List<String> stateTypes = accessor.getChildNames(accessor.keyBuilder().customizedViews());\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW).getAndSet(false)) {\n+      for (String stateType: stateTypes) {\n+        _customizedViewCacheMap.get(stateType).refresh(accessor);", "originalCommit": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0MjUxNg==", "url": "https://github.com/apache/helix/pull/888#discussion_r392542516", "bodyText": "Haven't we refreshed this in the BaseControllerDataProvider, can we just use that result here?", "author": "jiajunwang", "createdAt": "2020-03-14T01:07:08Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateComputationStage.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.controller.dataproviders.BaseControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractBaseStage;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.LiveInstance;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedStateComputationStage extends AbstractBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateComputationStage.class);\n+\n+  @Override\n+  public void process(ClusterEvent event) throws Exception {\n+    HelixManager helixManager = event.getAttribute(AttributeName.helixmanager.name());\n+    Set<String> aggregationEnabledTypes = new HashSet<>();\n+    if (helixManager.getHelixDataAccessor().getProperty(", "originalCommit": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NDE1Nw==", "url": "https://github.com/apache/helix/pull/888#discussion_r392544157", "bodyText": "If you passed \"this\", I guess you don't need to pass \"_aggregationEnabledTypes\" in addition. You can always call BaseControllerDataProvider.getCustomizedStateConfig() in the CustomizedStateCache. And that method is safer and cleaner.", "author": "jiajunwang", "createdAt": "2020-03-14T01:24:56Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -217,6 +222,7 @@ public String getObjName(StateModelDefinition obj) {\n       }\n     }, false);\n     _currentStateCache = new CurrentStateCache(this);\n+    _customizedStateCache = new CustomizedStateCache(this, _aggregationEnabledTypes);", "originalCommit": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1ODM1Ng==", "url": "https://github.com/apache/helix/pull/888#discussion_r392558356", "bodyText": "I tried, but this will break the other constructor:\npublic CustomizedStateCache(String clusterName, Set aggregationEnabledTypes) {\nthis(createDefaultControlContextProvider(clusterName), aggregationEnabledTypes);\n}\nThe clusterName does not contain any aggregation type information, and we need to provide them explicitly.", "author": "zhangmeng916", "createdAt": "2020-03-14T05:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyMzc1OA==", "url": "https://github.com/apache/helix/pull/888#discussion_r392723758", "bodyText": "My major concern is that it relies on the reference of the input set (aggregationEnabledTypes) to accept any types update. Ideally, it should be read explicitly in the CustomizedStateCache logic. So it exactly knows that this set might have been changed. For now, every read of this set in the CustomizedStateCache can return different content. This may introduce bugs.", "author": "jiajunwang", "createdAt": "2020-03-15T23:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc4OTEyMQ==", "url": "https://github.com/apache/helix/pull/888#discussion_r392789121", "bodyText": "I agree. I suggest we defer the decision in the next PR together with the controller. The main reason is that then I can show easily which test is broken with the change in controller logic and cache change. We can decide whether changing the test logic makes more sense or the cache logic.", "author": "zhangmeng916", "createdAt": "2020-03-16T05:29:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NDE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjA5Mg==", "url": "https://github.com/apache/helix/pull/888#discussion_r392546092", "bodyText": "I think if we add it here, it will be done by the Task pipeline as well. Is it necessary?", "author": "jiajunwang", "createdAt": "2020-03-14T01:49:14Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -96,13 +99,15 @@\n \n   // Special caches\n   private CurrentStateCache _currentStateCache;\n+  private CustomizedStateCache _customizedStateCache;", "originalCommit": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU1ODY2NA==", "url": "https://github.com/apache/helix/pull/888#discussion_r392558664", "bodyText": "Currently I do not see the usage of customized state in task pipeline. I kept it here mainly for two reasons, one is that it's similar to current state cache, and easier to identify and debug if we put them together, also it keeps some assumption of our tests. The other reason is that we may have extended use case in the future, our TF users may also have some customized state they need.", "author": "zhangmeng916", "createdAt": "2020-03-14T05:26:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjA5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyMjI0Ng==", "url": "https://github.com/apache/helix/pull/888#discussion_r392722246", "bodyText": "This will increase the read throughput and pipeline latency, which is one of the major concerns. Before we have a real use case, I prefer to keep it in the resource data provider only.", "author": "jiajunwang", "createdAt": "2020-03-15T22:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjQ4NQ==", "url": "https://github.com/apache/helix/pull/888#discussion_r392546485", "bodyText": "This logic confused me. Are we setting curCustomizedViews or customizedViewCache? Or both?\nCould you please split these 2 parts?", "author": "jiajunwang", "createdAt": "2020-03-14T01:54:12Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.ClusterStatusMonitor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);", "originalCommit": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MDUxNg==", "url": "https://github.com/apache/helix/pull/888#discussion_r392560516", "bodyText": "The logic here is that if customizedViewCache is not null, we will get the mapping (resource -> customizedView) from the cache, and use that in the later computation stage. However, if the customizedViewCache is null, meaning the stateType does not exist in the customizedViewCache list, we will initialize a new customizedViewCache for it.", "author": "zhangmeng916", "createdAt": "2020-03-14T06:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyODAwMA==", "url": "https://github.com/apache/helix/pull/888#discussion_r392728000", "bodyText": "Maybe you can enrich the comment here.\nIf customizedViewCache != null, you have curCustomizedViews assigned. Otherwise, you have an empty curCustomizedViews. And a customizedViewCache will be initialized then assign to the local var \"customizedViewCache\".\nThe thing confused me the most is what's the difference between curCustomizedViews and customizedViewCache? For the following code, they could be completely different things. To be honest, I can still not following.\nI was expecting either one of the following cases:\ncurCustomizedViews = (customizedViewCache != null)? customizedViewCache.getCustomizedViewMap() : new HashMap<>();\nOr,\nCustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\nif (customizedViewCache != null) {\ncustomizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n}\ncurCustomizedViews = customizedViewCache.getCustomizedViewMap();\nBut never the mix.", "author": "jiajunwang", "createdAt": "2020-03-15T23:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0NjU1OA==", "url": "https://github.com/apache/helix/pull/888#discussion_r392546558", "bodyText": "I think this has been done in the external view stage. There is no need to do it twice.", "author": "jiajunwang", "createdAt": "2020-03-14T01:55:20Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.ClusterStatusMonitor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n+      }\n+\n+      for (Resource resource : resourceMap.values()) {\n+        try {\n+          computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n+              newCustomizedViews);\n+          // Keep MBeans for existing resources and unregister MBeans for dropped resources\n+          if (clusterStatusMonitor != null) {\n+            clusterStatusMonitor.retainResourceMonitor(monitoringResources);", "originalCommit": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0Njc4NA==", "url": "https://github.com/apache/helix/pull/888#discussion_r392546784", "bodyText": "Shall we just pass the in-memory content to the cache instead of requiring it to read from ZK again?", "author": "jiajunwang", "createdAt": "2020-03-14T01:58:35Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,171 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.apache.helix.monitoring.mbeans.ClusterStatusMonitor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+    ClusterStatusMonitor clusterStatusMonitor =\n+        event.getAttribute(AttributeName.clusterStatusMonitor.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n+      }\n+\n+      for (Resource resource : resourceMap.values()) {\n+        try {\n+          computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n+              newCustomizedViews);\n+          // Keep MBeans for existing resources and unregister MBeans for dropped resources\n+          if (clusterStatusMonitor != null) {\n+            clusterStatusMonitor.retainResourceMonitor(monitoringResources);\n+          }\n+\n+          List<PropertyKey> keys = new ArrayList<>();\n+          for (Iterator<CustomizedView> it = newCustomizedViews.iterator(); it.hasNext(); ) {\n+            CustomizedView view = it.next();\n+            String resourceName = view.getResourceName();\n+            keys.add(keyBuilder.customizedView(stateType, resourceName));\n+          }\n+          // add/update customized-views\n+          if (newCustomizedViews.size() > 0) {\n+            dataAccessor.setChildren(keys, newCustomizedViews);\n+            customizedViewCache.refresh(dataAccessor);", "originalCommit": "ee66bf8f53084ac086d9b0282d239b813c6afc75", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU2MTIzNw==", "url": "https://github.com/apache/helix/pull/888#discussion_r392561237", "bodyText": "I tried to use in-memory content, and that does require a couple of set functions in CustomizedViewCache. I feel it's not clean. Please let me know if you think it's worth.", "author": "zhangmeng916", "createdAt": "2020-03-14T06:15:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0Njc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyODI5Ng==", "url": "https://github.com/apache/helix/pull/888#discussion_r392728296", "bodyText": "Worth it. Because if you have 1K resources, you might refresh 1K times, right?", "author": "jiajunwang", "createdAt": "2020-03-15T23:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0Njc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyODQyNw==", "url": "https://github.com/apache/helix/pull/888#discussion_r392728427", "bodyText": "But, actually, I have another question even before that. Why do you need to refresh this cache? It is not used in the following logic. And as for the next pipeline, it will refresh the cache from ZK anyway.\nFinally, in your previous logic, CustomizedViewCache could be a newly created instance (created by \"new CustomizedViewCache(event.getClusterName(), stateType);\" And you are not put it back to the Resource Cache), right? So refresh it does not help anyone in my understanding. Please correct me if I missed anything.", "author": "jiajunwang", "createdAt": "2020-03-15T23:53:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0Njc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc4ODU3NA==", "url": "https://github.com/apache/helix/pull/888#discussion_r392788574", "bodyText": "I remove all the cache refresh/remove logic in this stage. But let me double check. I saw external view computation stage does have cache refresh and remove, and I'll make sure the cache is not used anywhere.", "author": "zhangmeng916", "createdAt": "2020-03-16T05:26:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0Njc4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMyOTEyNg==", "url": "https://github.com/apache/helix/pull/888#discussion_r393329126", "bodyText": "I've confirmed that routing table would not read from the customized view cache output from this stage, so we are safe to remove the refresh of cache", "author": "zhangmeng916", "createdAt": "2020-03-16T21:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjU0Njc4NA=="}], "type": "inlineReview"}, {"oid": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "url": "https://github.com/apache/helix/commit/fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "message": "fix some comments", "committedDate": "2020-03-14T06:17:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyMzQ0MQ==", "url": "https://github.com/apache/helix/pull/888#discussion_r392723441", "bodyText": "If it is null, shall we change clean the _aggregationEnabledTypes?", "author": "jiajunwang", "createdAt": "2020-03-15T23:08:53Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -286,6 +292,27 @@ private void refreshResourceConfig(final HelixDataAccessor accessor,\n     }\n   }\n \n+  private void refreshCustomizedStateConfig(final HelixDataAccessor accessor,\n+      Set<HelixConstants.ChangeType> refreshedType) {\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_STATE_CONFIG)\n+        .getAndSet(false)) {\n+      CustomizedStateConfig customizedStateConfig =\n+          accessor.getProperty(accessor.keyBuilder().customizedStateConfig());\n+      if (customizedStateConfig != null) {", "originalCommit": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyMzk3Nw==", "url": "https://github.com/apache/helix/pull/888#discussion_r392723977", "bodyText": "Can we leverage the removeCustomizedViewTypes() that already defined?", "author": "jiajunwang", "createdAt": "2020-03-15T23:15:32Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -156,6 +161,30 @@ private void refreshTargetExternalViews(final HelixDataAccessor accessor) {\n     }\n   }\n \n+  public void refreshCustomizedViewMap(final HelixDataAccessor accessor) {\n+    // As we are not listening on customized view change, customized view will be\n+    // refreshed once during the cache's first refresh() call, or when full refresh is required\n+    List<String> stateTypes = accessor.getChildNames(accessor.keyBuilder().customizedViews());\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW).getAndSet(false)) {\n+      for (String stateType : stateTypes) {\n+        if (!_customizedViewCacheMap.containsKey(stateType)) {\n+          CustomizedViewCache newCustomizedViewCache =\n+              new CustomizedViewCache(getClusterName(), stateType);\n+          newCustomizedViewCache.refresh(accessor);\n+          _customizedViewCacheMap.put(stateType, newCustomizedViewCache);\n+        } else {\n+          _customizedViewCacheMap.get(stateType).refresh(accessor);\n+        }\n+      }\n+      for (String stateType : _customizedViewCacheMap.keySet()) {", "originalCommit": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyNDExNw==", "url": "https://github.com/apache/helix/pull/888#discussion_r392724117", "bodyText": "nit, the var names here are confusing.\nstateTypes -> currentStateTypes\nthe stateType here -> cachedStateType\nWill that be cleaner?", "author": "jiajunwang", "createdAt": "2020-03-15T23:16:47Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -156,6 +161,30 @@ private void refreshTargetExternalViews(final HelixDataAccessor accessor) {\n     }\n   }\n \n+  public void refreshCustomizedViewMap(final HelixDataAccessor accessor) {\n+    // As we are not listening on customized view change, customized view will be\n+    // refreshed once during the cache's first refresh() call, or when full refresh is required\n+    List<String> stateTypes = accessor.getChildNames(accessor.keyBuilder().customizedViews());\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW).getAndSet(false)) {\n+      for (String stateType : stateTypes) {\n+        if (!_customizedViewCacheMap.containsKey(stateType)) {\n+          CustomizedViewCache newCustomizedViewCache =\n+              new CustomizedViewCache(getClusterName(), stateType);\n+          newCustomizedViewCache.refresh(accessor);\n+          _customizedViewCacheMap.put(stateType, newCustomizedViewCache);\n+        } else {\n+          _customizedViewCacheMap.get(stateType).refresh(accessor);\n+        }\n+      }\n+      for (String stateType : _customizedViewCacheMap.keySet()) {\n+        if (!stateTypes.contains(stateType)) {", "originalCommit": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyNDMzNQ==", "url": "https://github.com/apache/helix/pull/888#discussion_r392724335", "bodyText": "How about just pass the instanceName?", "author": "jiajunwang", "createdAt": "2020-03-15T23:19:17Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateComputationStage.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.controller.dataproviders.BaseControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractBaseStage;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.LiveInstance;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedStateComputationStage extends AbstractBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateComputationStage.class);\n+\n+  @Override\n+  public void process(ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    BaseControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+    final Map<String, Resource> resourceMap = event.getAttribute(AttributeName.RESOURCES.name());\n+    Set<String> aggregationEnabledTypes = cache.getAggregationEnabledCustomizedStateTypes();\n+\n+    if (cache == null || resourceMap == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires DataCache|RESOURCE\");\n+    }\n+\n+    Map<String, LiveInstance> liveInstances = cache.getLiveInstances();\n+    final CustomizedStateOutput customizedStateOutput = new CustomizedStateOutput();\n+\n+    for (LiveInstance instance : liveInstances.values()) {\n+      String instanceName = instance.getInstanceName();\n+      // update customized states.\n+      for (String customizedStateType : aggregationEnabledTypes) {\n+        Map<String, CustomizedState> customizedStateMap =\n+            cache.getCustomizedState(instanceName, customizedStateType);\n+        updateCustomizedStates(instance, customizedStateType, customizedStateMap,\n+            customizedStateOutput, resourceMap);\n+      }\n+    }\n+    event.addAttribute(AttributeName.CUSTOMIZED_STATE.name(), customizedStateOutput);\n+  }\n+\n+  // update customized state in CustomizedStateOutput\n+  private void updateCustomizedStates(LiveInstance instance, String customizedStateType,", "originalCommit": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyNDc5Mw==", "url": "https://github.com/apache/helix/pull/888#discussion_r392724793", "bodyText": "As you mentioned it is now for test only, I would prefer protected.", "author": "jiajunwang", "createdAt": "2020-03-15T23:24:27Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -374,6 +405,14 @@ public void setClusterConfig(ClusterConfig clusterConfig) {\n     _clusterConfig = clusterConfig;\n   }\n \n+  public Set<String> getAggregationEnabledCustomizedStateTypes() {\n+    return _aggregationEnabledTypes;\n+  }\n+\n+  public void SetAggregationEnabledCustomizedStateTypes(Set<String> aggregationEnabledTypes) {", "originalCommit": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyNDk4Nw==", "url": "https://github.com/apache/helix/pull/888#discussion_r392724987", "bodyText": "Question, I assume the reason that we refresh it in this stage is to read the most recent status. If this is the case, can we bypass the refresh that is done in the cache refresh? It seems to me that one of them is not necessary.", "author": "jiajunwang", "createdAt": "2020-03-15T23:26:19Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    cache.refreshCustomizedViewMap(dataAccessor);", "originalCommit": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyODc2NQ==", "url": "https://github.com/apache/helix/pull/888#discussion_r392728765", "bodyText": "Same here, if we don't remove it, will the next pipeline refresh the cache and delete it anyway?", "author": "jiajunwang", "createdAt": "2020-03-15T23:56:50Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n+      }\n+\n+      for (Resource resource : resourceMap.values()) {\n+        try {\n+          computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n+              newCustomizedViews);\n+\n+          List<PropertyKey> keys = new ArrayList<>();\n+          for (Iterator<CustomizedView> it = newCustomizedViews.iterator(); it.hasNext(); ) {\n+            CustomizedView view = it.next();\n+            String resourceName = view.getResourceName();\n+            keys.add(keyBuilder.customizedView(stateType, resourceName));\n+          }\n+          // add/update customized-views\n+          if (newCustomizedViews.size() > 0) {\n+            dataAccessor.setChildren(keys, newCustomizedViews);\n+            customizedViewCache.refresh(dataAccessor);\n+          }\n+\n+          List<String> customizedViewsToRemove = new ArrayList<>();\n+\n+          // remove stale customized views\n+          for (String resourceName : curCustomizedViews.keySet()) {\n+            if (!resourceMap.keySet().contains(resourceName)) {\n+              LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for resource: \" + resourceName);\n+              dataAccessor.removeProperty(keyBuilder.customizedView(stateType, resourceName));\n+              customizedViewsToRemove.add(resourceName);\n+            }\n+          }\n+          customizedViewCache.removeCustomizedView(customizedViewsToRemove);", "originalCommit": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyOTA5NA==", "url": "https://github.com/apache/helix/pull/888#discussion_r392729094", "bodyText": "Shall we call it updatedCustomizedViews to be clearer?", "author": "jiajunwang", "createdAt": "2020-03-15T23:59:47Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedViewAggregationStage.java", "diffHunk": "@@ -0,0 +1,164 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixException;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.common.caches.CustomizedViewCache;\n+import org.apache.helix.controller.LogUtil;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractAsyncBaseStage;\n+import org.apache.helix.controller.pipeline.AsyncWorkerType;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedView;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedViewAggregationStage extends AbstractAsyncBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedViewAggregationStage.class);\n+\n+  @Override\n+  public AsyncWorkerType getAsyncWorkerType() {\n+    return AsyncWorkerType.CustomizedStateViewComputeWorker;\n+  }\n+\n+  @Override\n+  public void execute(final ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    HelixManager manager = event.getAttribute(AttributeName.helixmanager.name());\n+    Map<String, Resource> resourceMap =\n+        event.getAttribute(AttributeName.RESOURCES_TO_REBALANCE.name());\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+\n+    if (manager == null || resourceMap == null || cache == null) {\n+      throw new StageException(\n+          \"Missing attributes in event:\" + event + \". Requires ClusterManager|RESOURCES|DataCache\");\n+    }\n+\n+    HelixDataAccessor dataAccessor = manager.getHelixDataAccessor();\n+    PropertyKey.Builder keyBuilder = dataAccessor.keyBuilder();\n+\n+    CustomizedStateOutput customizedStateOutput =\n+        event.getAttribute(AttributeName.CUSTOMIZED_STATE.name());\n+\n+    List<CustomizedView> newCustomizedViews = new ArrayList<>();\n+    Set<String> monitoringResources = new HashSet<>();\n+\n+    cache.refreshCustomizedViewMap(dataAccessor);\n+    Map<String, CustomizedViewCache> customizedViewCacheMap = cache.getCustomizedViewCacheMap();\n+\n+    // remove stale customized view type from ZK and cache\n+    List<String> customizedViewTypesToRemove = new ArrayList<>();\n+    for (String stateType : customizedViewCacheMap.keySet()) {\n+      if (!customizedStateOutput.getAllStateTypes().contains(stateType)) {\n+        LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for stateType: \" + stateType);\n+        dataAccessor.removeProperty(keyBuilder.customizedView(stateType));\n+        customizedViewTypesToRemove.add(stateType);\n+      }\n+    }\n+\n+    cache.removeCustomizedViewTypes(customizedViewTypesToRemove);\n+\n+    // update customized view\n+    for (String stateType : customizedStateOutput.getAllStateTypes()) {\n+      Map<String, CustomizedView> curCustomizedViews = new HashMap<>();\n+      CustomizedViewCache customizedViewCache = customizedViewCacheMap.get(stateType);\n+      if (customizedViewCache != null) {\n+        curCustomizedViews = customizedViewCache.getCustomizedViewMap();\n+      } else {\n+        customizedViewCache = new CustomizedViewCache(event.getClusterName(), stateType);\n+      }\n+\n+      for (Resource resource : resourceMap.values()) {\n+        try {\n+          computeCustomizedStateView(resource, stateType, customizedStateOutput, curCustomizedViews,\n+              newCustomizedViews);\n+\n+          List<PropertyKey> keys = new ArrayList<>();\n+          for (Iterator<CustomizedView> it = newCustomizedViews.iterator(); it.hasNext(); ) {\n+            CustomizedView view = it.next();\n+            String resourceName = view.getResourceName();\n+            keys.add(keyBuilder.customizedView(stateType, resourceName));\n+          }\n+          // add/update customized-views\n+          if (newCustomizedViews.size() > 0) {\n+            dataAccessor.setChildren(keys, newCustomizedViews);\n+            customizedViewCache.refresh(dataAccessor);\n+          }\n+\n+          List<String> customizedViewsToRemove = new ArrayList<>();\n+\n+          // remove stale customized views\n+          for (String resourceName : curCustomizedViews.keySet()) {\n+            if (!resourceMap.keySet().contains(resourceName)) {\n+              LogUtil.logInfo(LOG, _eventId, \"Remove customizedView for resource: \" + resourceName);\n+              dataAccessor.removeProperty(keyBuilder.customizedView(stateType, resourceName));\n+              customizedViewsToRemove.add(resourceName);\n+            }\n+          }\n+          customizedViewCache.removeCustomizedView(customizedViewsToRemove);\n+        } catch (HelixException ex) {\n+          LogUtil.logError(LOG, _eventId,\n+              \"Failed to calculate customized view for resource \" + resource.getResourceName(), ex);\n+        }\n+      }\n+    }\n+  }\n+\n+  private void computeCustomizedStateView(final Resource resource, final String stateType,\n+      CustomizedStateOutput customizedStateOutput,\n+      final Map<String, CustomizedView> curCustomizedViews,\n+      List<CustomizedView> newCustomizedViews) {", "originalCommit": "fdec37695b6cb698abc9f7c7da8a37d6a9f94ea5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "766c1d7df4f5f5478055dd9079395f52c71fa54f", "url": "https://github.com/apache/helix/commit/766c1d7df4f5f5478055dd9079395f52c71fa54f", "message": "move to resource provider", "committedDate": "2020-03-16T05:46:55Z", "type": "commit"}, {"oid": "3d97f24bbeedc8369fdc1710c60426e3bde2b115", "url": "https://github.com/apache/helix/commit/3d97f24bbeedc8369fdc1710c60426e3bde2b115", "message": "change one test", "committedDate": "2020-03-16T07:05:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1NTk5NA==", "url": "https://github.com/apache/helix/pull/888#discussion_r393855994", "bodyText": "nit, not necessary", "author": "jiajunwang", "createdAt": "2020-03-17T17:39:30Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -286,6 +286,7 @@ private void refreshResourceConfig(final HelixDataAccessor accessor,\n     }\n   }\n \n+", "originalCommit": "3d97f24bbeedc8369fdc1710c60426e3bde2b115", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1NzcyNw==", "url": "https://github.com/apache/helix/pull/888#discussion_r393857727", "bodyText": "nit, since the customizedStateConfig is created in the current method scope, I think directly assign the type set to _aggregationEnabledTypes is fine. A copy constructor is not necessary.\nBut no strong preference here.", "author": "jiajunwang", "createdAt": "2020-03-17T17:42:17Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -139,6 +155,27 @@ protected void dumpDebugInfo() {\n     }\n   }\n \n+  private void refreshCustomizedStateConfig(final HelixDataAccessor accessor) {\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_STATE_CONFIG)\n+        .getAndSet(false)) {\n+      CustomizedStateConfig customizedStateConfig =\n+          accessor.getProperty(accessor.keyBuilder().customizedStateConfig());\n+      if (customizedStateConfig != null) {\n+        _aggregationEnabledTypes =", "originalCommit": "3d97f24bbeedc8369fdc1710c60426e3bde2b115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk2NTk0Mg==", "url": "https://github.com/apache/helix/pull/888#discussion_r393965942", "bodyText": "This is actually converting list to set. Any easier method?", "author": "zhangmeng916", "createdAt": "2020-03-17T20:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1NzcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk3Nzg0Mg==", "url": "https://github.com/apache/helix/pull/888#discussion_r393977842", "bodyText": "In that case, should be good. I thought it was just for protecting the input.", "author": "jiajunwang", "createdAt": "2020-03-17T21:21:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg1NzcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2MzUwNA==", "url": "https://github.com/apache/helix/pull/888#discussion_r393863504", "bodyText": "nit, this else is not necessary.", "author": "jiajunwang", "createdAt": "2020-03-17T17:51:34Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -156,6 +193,47 @@ private void refreshTargetExternalViews(final HelixDataAccessor accessor) {\n     }\n   }\n \n+  public void refreshCustomizedViewMap(final HelixDataAccessor accessor) {\n+    // As we are not listening on customized view change, customized view will be\n+    // refreshed once during the cache's first refresh() call, or when full refresh is required\n+    List<String> newStateTypes = accessor.getChildNames(accessor.keyBuilder().customizedViews());\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_VIEW).getAndSet(false)) {\n+      for (String stateType : newStateTypes) {\n+        if (!_customizedViewCacheMap.containsKey(stateType)) {\n+          CustomizedViewCache newCustomizedViewCache =\n+              new CustomizedViewCache(getClusterName(), stateType);\n+          newCustomizedViewCache.refresh(accessor);\n+          _customizedViewCacheMap.put(stateType, newCustomizedViewCache);\n+        } else {", "originalCommit": "3d97f24bbeedc8369fdc1710c60426e3bde2b115", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2NDk0Mw==", "url": "https://github.com/apache/helix/pull/888#discussion_r393864943", "bodyText": "private?", "author": "jiajunwang", "createdAt": "2020-03-17T17:53:52Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -193,6 +279,17 @@ public void removeExternalViews(List<String> resourceNames) {\n     }\n   }\n \n+  /**\n+   * Remove dead customized views for certain state types from map\n+   * @param stateTypeNames\n+   */\n+\n+  public void removeCustomizedViewTypes(List<String> stateTypeNames) {", "originalCommit": "3d97f24bbeedc8369fdc1710c60426e3bde2b115", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2NTQxMg==", "url": "https://github.com/apache/helix/pull/888#discussion_r393865412", "bodyText": "Should this be RESOURCES_TO_REBALANCE like the CustomizedViewAggregationStage does?", "author": "jiajunwang", "createdAt": "2020-03-17T17:54:38Z", "path": "helix-core/src/main/java/org/apache/helix/controller/stages/CustomizedStateComputationStage.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.AbstractBaseStage;\n+import org.apache.helix.controller.pipeline.StageException;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.LiveInstance;\n+import org.apache.helix.model.Partition;\n+import org.apache.helix.model.Resource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+public class CustomizedStateComputationStage extends AbstractBaseStage {\n+  private static Logger LOG = LoggerFactory.getLogger(CustomizedStateComputationStage.class);\n+\n+  @Override\n+  public void process(ClusterEvent event) throws Exception {\n+    _eventId = event.getEventId();\n+    ResourceControllerDataProvider cache =\n+        event.getAttribute(AttributeName.ControllerDataProvider.name());\n+    final Map<String, Resource> resourceMap = event.getAttribute(AttributeName.RESOURCES.name());", "originalCommit": "3d97f24bbeedc8369fdc1710c60426e3bde2b115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk3NTQyNg==", "url": "https://github.com/apache/helix/pull/888#discussion_r393975426", "bodyText": "I followed CurrentStateComputationStage convention here. What is exactly the difference for them?", "author": "zhangmeng916", "createdAt": "2020-03-17T21:16:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2NTQxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk3NzUwMQ==", "url": "https://github.com/apache/helix/pull/888#discussion_r393977501", "bodyText": "The RESOURCES_TO_REBALANCE is a set of valid resources that we filtered. I think it would be a better input.", "author": "jiajunwang", "createdAt": "2020-03-17T21:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg2NTQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4NDk3Nw==", "url": "https://github.com/apache/helix/pull/888#discussion_r393884977", "bodyText": "Maybe we shall consider moving these 3 calculations to the update stages in the async thread. But let's leave it here for now. We will revisit anyway.", "author": "jiajunwang", "createdAt": "2020-03-17T18:27:01Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -123,8 +136,11 @@ public synchronized void refresh(HelixDataAccessor accessor) {\n     }\n \n     // Refresh resource controller specific property caches\n+    refreshCustomizedStateConfig(accessor);\n+    _customizedStateCache.refresh(accessor, _liveInstanceCache.getPropertyMap());\n     refreshExternalViews(accessor);", "originalCommit": "3d97f24bbeedc8369fdc1710c60426e3bde2b115", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzk3NTc4Mw==", "url": "https://github.com/apache/helix/pull/888#discussion_r393975783", "bodyText": "ok, will discuss in the controller PR.", "author": "zhangmeng916", "createdAt": "2020-03-17T21:16:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4NDk3Nw=="}], "type": "inlineReview"}, {"oid": "9cced13eb96bbe0b7b052b33ab1f6866594143d3", "url": "https://github.com/apache/helix/commit/9cced13eb96bbe0b7b052b33ab1f6866594143d3", "message": "minor fix", "committedDate": "2020-03-17T21:17:40Z", "type": "commit"}, {"oid": "c866f259af102bb5aa475ef0a21920a59227c81b", "url": "https://github.com/apache/helix/commit/c866f259af102bb5aa475ef0a21920a59227c81b", "message": "add unit tests", "committedDate": "2020-03-17T22:28:28Z", "type": "commit"}, {"oid": "3cc5d99007c2e9b0b30af64cb059c54fd849cb7b", "url": "https://github.com/apache/helix/commit/3cc5d99007c2e9b0b30af64cb059c54fd849cb7b", "message": "change resource map", "committedDate": "2020-03-17T22:30:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDAzODQzMg==", "url": "https://github.com/apache/helix/pull/888#discussion_r394038432", "bodyText": "nit, safer to add a protected readonly method for getting the list instead of returning the list. Otherwise, the children may modify this list.", "author": "jiajunwang", "createdAt": "2020-03-18T00:03:31Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/BaseControllerDataProvider.java", "diffHunk": "@@ -89,7 +89,7 @@\n   // Property caches\n   private final PropertyCache<ResourceConfig> _resourceConfigCache;\n   private final PropertyCache<InstanceConfig> _instanceConfigCache;\n-  private final PropertyCache<LiveInstance> _liveInstanceCache;\n+  protected final PropertyCache<LiveInstance> _liveInstanceCache;", "originalCommit": "3cc5d99007c2e9b0b30af64cb059c54fd849cb7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0MTU1Mg==", "url": "https://github.com/apache/helix/pull/888#discussion_r394041552", "bodyText": "Can we explicitly call this outside the refreshCustomizedStateConfig and just before _customizedStateCache.refresh()? Since _customizedStateCache.setAggregationEnabledTypes and refresh must be ordered, putting them together is easier for us to understand and maintain.", "author": "jiajunwang", "createdAt": "2020-03-18T00:16:15Z", "path": "helix-core/src/main/java/org/apache/helix/controller/dataproviders/ResourceControllerDataProvider.java", "diffHunk": "@@ -139,6 +155,28 @@ protected void dumpDebugInfo() {\n     }\n   }\n \n+  private void refreshCustomizedStateConfig(final HelixDataAccessor accessor) {\n+    if (_propertyDataChangedMap.get(HelixConstants.ChangeType.CUSTOMIZED_STATE_CONFIG)\n+        .getAndSet(false)) {\n+      CustomizedStateConfig customizedStateConfig =\n+          accessor.getProperty(accessor.keyBuilder().customizedStateConfig());\n+      if (customizedStateConfig != null) {\n+        _aggregationEnabledTypes =\n+            new HashSet<>(customizedStateConfig.getAggregationEnabledTypes());\n+      } else {\n+        _aggregationEnabledTypes.clear();\n+      }\n+      _customizedStateCache.setAggregationEnabledTypes(_aggregationEnabledTypes);", "originalCommit": "3cc5d99007c2e9b0b30af64cb059c54fd849cb7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7add5ce7f747c42220226a372c8f94073640e989", "url": "https://github.com/apache/helix/commit/7add5ce7f747c42220226a372c8f94073640e989", "message": "minor fix", "committedDate": "2020-03-18T00:35:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODA3Mg==", "url": "https://github.com/apache/helix/pull/888#discussion_r394048072", "bodyText": "More accurate to convert the 2 lists to sets for assertion? If the ordering is different, this assert would fail.", "author": "huizhilu", "createdAt": "2020-03-18T00:42:44Z", "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestCustomizedViewStage.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.Pipeline;\n+import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewStage extends ZkUnitTestBase {\n+  private final String RESOURCE_NAME = \"testResourceName\";\n+  private final String PARTITION_NAME = \"testResourceName_0\";\n+  private final String CUSTOMIZED_STATE_NAME = \"customizedState1\";\n+  private final String INSTANCE_NAME = \"localhost_1\";\n+\n+  @Test\n+  public void testCachedCustomizedViews() throws Exception {\n+    String clusterName = \"CLUSTER_\" + TestHelper.getTestMethodName();\n+\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n+    HelixManager manager = new DummyClusterManager(clusterName, accessor);\n+\n+    setupLiveInstances(clusterName, new int[]{0, 1});\n+    setupStateModel(clusterName);\n+\n+    ClusterEvent event = new ClusterEvent(ClusterEventType.Unknown);\n+    ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n+    event.addAttribute(AttributeName.helixmanager.name(), manager);\n+    event.addAttribute(AttributeName.ControllerDataProvider.name(), cache);\n+\n+    CustomizedStateConfig config = new CustomizedStateConfig();\n+    List<String> aggregationEnabledTypes = new ArrayList<>();\n+    aggregationEnabledTypes.add(CUSTOMIZED_STATE_NAME);\n+    config.setAggregationEnabledTypes(aggregationEnabledTypes);\n+\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    accessor.setProperty(keyBuilder.customizedStateConfig(), config);\n+\n+    CustomizedState customizedState = new CustomizedState(RESOURCE_NAME);\n+    customizedState.setState(PARTITION_NAME, \"STARTED\");\n+    accessor\n+        .setProperty(keyBuilder.customizedState(INSTANCE_NAME, \"customizedState1\", RESOURCE_NAME),\n+            customizedState);\n+\n+    CustomizedViewAggregationStage customizedViewComputeStage =\n+        new CustomizedViewAggregationStage();\n+    Pipeline dataRefresh = new Pipeline();\n+    dataRefresh.addStage(new ReadClusterDataStage());\n+    runPipeline(event, dataRefresh);\n+    runStage(event, new ResourceComputationStage());\n+    runStage(event, new CustomizedStateComputationStage());\n+    runStage(event, customizedViewComputeStage);\n+    Assert.assertEquals(cache.getCustomizedViewCacheMap().values(),\n+        accessor.getChildValues(accessor.keyBuilder().customizedViews()));\n+\n+    // Assure there is no customized view got updated when running the stage again\n+    List<CustomizedView> oldCustomizedViews =\n+        accessor.getChildValues(accessor.keyBuilder().customizedViews());\n+    runStage(event, customizedViewComputeStage);\n+    List<CustomizedView> newCustomizedViews =\n+        accessor.getChildValues(accessor.keyBuilder().customizedViews());\n+    Assert.assertEquals(oldCustomizedViews, newCustomizedViews);", "originalCommit": "7add5ce7f747c42220226a372c8f94073640e989", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1MTYxNw==", "url": "https://github.com/apache/helix/pull/888#discussion_r394051617", "bodyText": "I thought the children were retrieved in a certain order, but by looking at the code, seems actually it's random based on the order whichever child is gotten back first. Is it right?", "author": "zhangmeng916", "createdAt": "2020-03-18T00:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1NzEwNw==", "url": "https://github.com/apache/helix/pull/888#discussion_r394057107", "bodyText": "Ordering is not guaranteed. In ZK's Znode implementation, it is using a set to store children. And it is converted to a list when returning to the client. So the ordering could be random.\nIf you are just checking if they have the same element without ordering, I would suggest using Sets so ordering is ignored. Only if you also want to check the ordering, a list is more appropriate.", "author": "huizhilu", "createdAt": "2020-03-18T01:21:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA2Nzg3OQ==", "url": "https://github.com/apache/helix/pull/888#discussion_r394067879", "bodyText": "Actually I found in TestExternalVeiwStage the following code.\nAssert.assertEquals(oldExternalViews, newExternalViews);\nfor (int i = 0; i < oldExternalViews.size(); i++) {\nAssert.assertEquals(oldExternalViews.get(i).getStat().getVersion(),\nnewExternalViews.get(i).getStat().getVersion());\n}\nI believe this test doesn't fail. I think my test is using the same logic. Since I would also like to examine each item based on index, like the above code, let's keep it as list for now.  If we encounter any test failure, let's revisit it.", "author": "zhangmeng916", "createdAt": "2020-03-18T02:06:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA0ODA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1NzM0OQ==", "url": "https://github.com/apache/helix/pull/888#discussion_r394057349", "bodyText": "And also here. Collection vs List. Would be better to make them 2 sets.", "author": "huizhilu", "createdAt": "2020-03-18T01:22:20Z", "path": "helix-core/src/test/java/org/apache/helix/controller/stages/TestCustomizedViewStage.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package org.apache.helix.controller.stages;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.helix.HelixDataAccessor;\n+import org.apache.helix.HelixManager;\n+import org.apache.helix.PropertyKey;\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.ZkUnitTestBase;\n+import org.apache.helix.controller.dataproviders.ResourceControllerDataProvider;\n+import org.apache.helix.controller.pipeline.Pipeline;\n+import org.apache.helix.manager.zk.ZKHelixDataAccessor;\n+import org.apache.helix.manager.zk.ZkBaseDataAccessor;\n+import org.apache.helix.model.CustomizedState;\n+import org.apache.helix.model.CustomizedStateConfig;\n+import org.apache.helix.model.CustomizedView;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+public class TestCustomizedViewStage extends ZkUnitTestBase {\n+  private final String RESOURCE_NAME = \"testResourceName\";\n+  private final String PARTITION_NAME = \"testResourceName_0\";\n+  private final String CUSTOMIZED_STATE_NAME = \"customizedState1\";\n+  private final String INSTANCE_NAME = \"localhost_1\";\n+\n+  @Test\n+  public void testCachedCustomizedViews() throws Exception {\n+    String clusterName = \"CLUSTER_\" + TestHelper.getTestMethodName();\n+\n+    HelixDataAccessor accessor =\n+        new ZKHelixDataAccessor(clusterName, new ZkBaseDataAccessor<>(_gZkClient));\n+    HelixManager manager = new DummyClusterManager(clusterName, accessor);\n+\n+    setupLiveInstances(clusterName, new int[]{0, 1});\n+    setupStateModel(clusterName);\n+\n+    ClusterEvent event = new ClusterEvent(ClusterEventType.Unknown);\n+    ResourceControllerDataProvider cache = new ResourceControllerDataProvider(clusterName);\n+    event.addAttribute(AttributeName.helixmanager.name(), manager);\n+    event.addAttribute(AttributeName.ControllerDataProvider.name(), cache);\n+\n+    CustomizedStateConfig config = new CustomizedStateConfig();\n+    List<String> aggregationEnabledTypes = new ArrayList<>();\n+    aggregationEnabledTypes.add(CUSTOMIZED_STATE_NAME);\n+    config.setAggregationEnabledTypes(aggregationEnabledTypes);\n+\n+    PropertyKey.Builder keyBuilder = accessor.keyBuilder();\n+    accessor.setProperty(keyBuilder.customizedStateConfig(), config);\n+\n+    CustomizedState customizedState = new CustomizedState(RESOURCE_NAME);\n+    customizedState.setState(PARTITION_NAME, \"STARTED\");\n+    accessor\n+        .setProperty(keyBuilder.customizedState(INSTANCE_NAME, \"customizedState1\", RESOURCE_NAME),\n+            customizedState);\n+\n+    CustomizedViewAggregationStage customizedViewComputeStage =\n+        new CustomizedViewAggregationStage();\n+    Pipeline dataRefresh = new Pipeline();\n+    dataRefresh.addStage(new ReadClusterDataStage());\n+    runPipeline(event, dataRefresh);\n+    runStage(event, new ResourceComputationStage());\n+    runStage(event, new CustomizedStateComputationStage());\n+    runStage(event, customizedViewComputeStage);\n+    Assert.assertEquals(cache.getCustomizedViewCacheMap().values(),", "originalCommit": "7add5ce7f747c42220226a372c8f94073640e989", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA3MzE4OA==", "url": "https://github.com/apache/helix/pull/888#discussion_r394073188", "bodyText": "Please see the comments above.", "author": "zhangmeng916", "createdAt": "2020-03-18T02:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1NzM0OQ=="}], "type": "inlineReview"}]}