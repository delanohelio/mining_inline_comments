{"pr_number": 1197, "pr_title": "Support option to skip direct ZK read for health check API", "pr_createdAt": "2020-07-31T19:23:56Z", "pr_url": "https://github.com/apache/helix/pull/1197", "timeline": [{"oid": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "url": "https://github.com/apache/helix/commit/b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "message": "Support option to skip direct ZK read for health check API\n\nThis change support the option \"skipZKRead\" in multiple health check API call.\nIf the option is true, Helix will directly query custom partition health from provided source instead of ZK read.", "committedDate": "2020-07-31T19:18:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzNTQ2Ng==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464035466", "bodyText": "Could it use Interface instead: ZKHelixDataAccessor -> HelixDataAccessor?", "author": "huizhilu", "createdAt": "2020-08-02T05:50:28Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/common/HelixDataAccessorWrapper.java", "diffHunk": "@@ -64,22 +65,38 @@ public HelixDataAccessorWrapper(ZKHelixDataAccessor dataAccessor) {\n     _restClient = CustomRestClientFactory.get();\n   }\n \n+  public HelixDataAccessorWrapper(ZKHelixDataAccessor dataAccessor, CustomRestClient customRestClient) {", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3NzQyOA==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464577428", "bodyText": "I cannot remember the details. But there are some places use the method only for ZKHelixDataAccessor but not interface.", "author": "junkaixue", "createdAt": "2020-08-03T18:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzNTQ2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzNTYyMQ==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464035621", "bodyText": "Not used in this file?", "author": "huizhilu", "createdAt": "2020-08-02T05:52:37Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/common/HelixDataAccessorWrapper.java", "diffHunk": "@@ -19,6 +19,7 @@\n  * under the License.\n  */\n \n+import com.google.common.annotations.VisibleForTesting;", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzNzk0Nw==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464037947", "bodyText": "Remove these unused imports?", "author": "huizhilu", "createdAt": "2020-08-02T06:22:50Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestPerInstanceAccessor.java", "diffHunk": "@@ -33,9 +33,15 @@\n \n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableMap;\n+import org.apache.helix.ConfigAccessor;\n import org.apache.helix.HelixDataAccessor;\n import org.apache.helix.HelixException;\n import org.apache.helix.TestHelper;\n+import org.apache.helix.model.RESTConfig;", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzODgyMQ==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464038821", "bodyText": "Nit: since parameter is boolean type, Boolean.valueOf -> Boolean.parseBoolean()?", "author": "huizhilu", "createdAt": "2020-08-02T06:34:13Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/InstancesAccessor.java", "diffHunk": "@@ -172,7 +172,7 @@ public Response instancesOperations(@PathParam(\"clusterId\") String clusterId,\n         admin.enableInstance(clusterId, enableInstances, false);\n         break;\n       case stoppable:\n-        return batchGetStoppableInstances(clusterId, node);\n+        return batchGetStoppableInstances(clusterId, node, Boolean.valueOf(skipZKRead));", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3NDc1Nw==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464574757", "bodyText": "parseBoolean can cause exception if that does not match. But the valueOf has a default value.", "author": "junkaixue", "createdAt": "2020-08-03T18:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDAzODgyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNTMyNQ==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464205325", "bodyText": "Add a JavaDoc for a public method. Here, we should explain what skipZkRead parameter does, and its implications.", "author": "narendly", "createdAt": "2020-08-03T05:47:41Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/common/HelixDataAccessorWrapper.java", "diffHunk": "@@ -64,22 +65,38 @@ public HelixDataAccessorWrapper(ZKHelixDataAccessor dataAccessor) {\n     _restClient = CustomRestClientFactory.get();\n   }\n \n+  public HelixDataAccessorWrapper(ZKHelixDataAccessor dataAccessor, CustomRestClient customRestClient) {\n+    super(dataAccessor);\n+    _restClient = customRestClient;\n+  }\n+\n   public Map<String, Map<String, Boolean>> getAllPartitionsHealthOnLiveInstance(\n       RESTConfig restConfig, Map<String, String> customPayLoads) {\n+    return getAllPartitionsHealthOnLiveInstance(restConfig, customPayLoads, false);\n+  }\n+\n+  public Map<String, Map<String, Boolean>> getAllPartitionsHealthOnLiveInstance(", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNTY2MA==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464205660", "bodyText": "I suggest we use something like onlyUseZkAsSource or something as the boolean flag, and use the same name all throughout since having skipZkRead and requireFullRead here and there could be confusing down the road.", "author": "narendly", "createdAt": "2020-08-03T05:49:01Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/common/HelixDataAccessorWrapper.java", "diffHunk": "@@ -101,7 +118,7 @@ public HelixDataAccessorWrapper(ZKHelixDataAccessor dataAccessor) {\n   }\n \n   private Map<String, Boolean> getPartitionsHealth(String instance, ZNRecord partitionHealthRecord,\n-      RESTConfig restConfig, Map<String, String> customPayLoads) {\n+      RESTConfig restConfig, Map<String, String> customPayLoads, boolean requireFullRead) {", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4MzUyNQ==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464583525", "bodyText": "I understand your concern. But it will be confusing to use one flag because they are completely in different purpose:\n\nSkip the zk access for reading partition health.\nBecause of the contract we made for customized API, if no entry as body for \"PARTITION\", they will return all the partition health status. If they have it but partition list is empty, no result will be return. Here' when we only do partition health retrieving, we dont know what are the partitions on the instance. Also this function I would say is a separate function and logically not connected with \"skipZKRead\"\n\nI can add some comments in the function and rename the function. But I do not think make this name to be \"onlyUseZkAsSource\" is a good choice. There are no logic related to ZK for this private function.", "author": "junkaixue", "createdAt": "2020-08-03T18:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNTY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNTg0NA==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464205844", "bodyText": "Suggest we consolidate the nomenclature for the boolean flag (as explained above).", "author": "narendly", "createdAt": "2020-08-03T05:49:45Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/InstancesAccessor.java", "diffHunk": "@@ -144,7 +144,7 @@ public Response getAllInstances(@PathParam(\"clusterId\") String clusterId,\n \n   @POST\n   public Response instancesOperations(@PathParam(\"clusterId\") String clusterId,\n-      @QueryParam(\"command\") String command, String content) {\n+      @QueryParam(\"skipZKRead\") String skipZKRead, @QueryParam(\"command\") String command, String content) {", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNTk1Nw==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464205957", "bodyText": "Nit: format?", "author": "narendly", "createdAt": "2020-08-03T05:50:10Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/helix/InstancesAccessor.java", "diffHunk": "@@ -218,7 +218,8 @@ private Response batchGetStoppableInstances(String clusterId, JsonNode node) thr\n       ObjectNode failedStoppableInstances = result.putObject(\n           InstancesAccessor.InstancesProperties.instance_not_stoppable_with_reasons.name());\n       InstanceService instanceService =\n-          new InstanceServiceImpl(new HelixDataAccessorWrapper((ZKHelixDataAccessor) getDataAccssor(clusterId)), getConfigAccessor());\n+          new InstanceServiceImpl(new HelixDataAccessorWrapper((ZKHelixDataAccessor) getDataAccssor(clusterId)), getConfigAccessor(),\n+              skipZKRead);", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNjE5Ng==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464206196", "bodyText": "Should this field be final?", "author": "narendly", "createdAt": "2020-08-03T05:51:07Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/service/InstanceServiceImpl.java", "diffHunk": "@@ -61,19 +61,32 @@\n   private final HelixDataAccessorWrapper _dataAccessor;\n   private final ConfigAccessor _configAccessor;\n   private final CustomRestClient _customRestClient;\n+  private boolean _skipZKRead;", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3NjMxMQ==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464576311", "bodyText": "Final requires constructor have redundant code. Tried to refactor, but there is no good solution. Otherwise, the new constructor need to do same assignment for each fields once.\nAnd there is no set during the process. I think it should be fine.", "author": "junkaixue", "createdAt": "2020-08-03T18:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNjE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNjM0Nw==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464206347", "bodyText": "Could we remove this constructor since you added a more comprehensive one below?", "author": "narendly", "createdAt": "2020-08-03T05:51:40Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/service/InstanceServiceImpl.java", "diffHunk": "@@ -61,19 +61,32 @@\n   private final HelixDataAccessorWrapper _dataAccessor;\n   private final ConfigAccessor _configAccessor;\n   private final CustomRestClient _customRestClient;\n+  private boolean _skipZKRead;\n \n   public InstanceServiceImpl(HelixDataAccessorWrapper dataAccessor, ConfigAccessor configAccessor) {\n     _dataAccessor = dataAccessor;\n     _configAccessor = configAccessor;\n     _customRestClient = CustomRestClientFactory.get();\n   }\n \n+  public InstanceServiceImpl(HelixDataAccessorWrapper dataAccessor, ConfigAccessor configAccessor, boolean skipZKRead) {\n+    this(dataAccessor,configAccessor);\n+    this._skipZKRead = skipZKRead;\n+  }\n+\n   @VisibleForTesting\n   InstanceServiceImpl(HelixDataAccessorWrapper dataAccessor, ConfigAccessor configAccessor,\n       CustomRestClient customRestClient) {\n+    this(dataAccessor, configAccessor, customRestClient, false);", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNjYxNw==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464206617", "bodyText": "Typo: siblingInstance", "author": "narendly", "createdAt": "2020-08-03T05:52:42Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/service/TestInstanceService.java", "diffHunk": "@@ -140,6 +151,70 @@ public void testGetInstanceStoppableCheckConnectionRefused() throws IOException\n     Assert.assertEquals(actual.getFailedChecks().get(0), expectedFailedCheck);\n   }\n \n+  @Test\n+  public void testCustomPartitionCheckWithSkipZKRead() throws IOException {\n+    // Let ZK result is health, but http request is unhealthy.\n+    // We expect the check fail if we skipZKRead.\n+\n+    String testPartition = \"PARTITION_0\";\n+    String slibilingInstance = \"instance0.linkedin.com_1236\";", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNjcyMA==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464206720", "bodyText": "Why does this jsonContent need multiple string concatenations?", "author": "narendly", "createdAt": "2020-08-03T05:53:08Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/service/TestInstanceService.java", "diffHunk": "@@ -140,6 +151,70 @@ public void testGetInstanceStoppableCheckConnectionRefused() throws IOException\n     Assert.assertEquals(actual.getFailedChecks().get(0), expectedFailedCheck);\n   }\n \n+  @Test\n+  public void testCustomPartitionCheckWithSkipZKRead() throws IOException {\n+    // Let ZK result is health, but http request is unhealthy.\n+    // We expect the check fail if we skipZKRead.\n+\n+    String testPartition = \"PARTITION_0\";\n+    String slibilingInstance = \"instance0.linkedin.com_1236\";\n+    String jsonContent = \"{\\n\" + \"   \\\"param1\\\": \\\"value1\\\",\\n\" + \"\\\"param2\\\": \\\"value2\\\"\\n\" + \"}\";", "originalCommit": "b9fc05b9762d88056f22c68f64dc98b7d72fad0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU3NjYwNA==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464576604", "bodyText": "Was for viewing purpose for each entry set a line. Let me format it.", "author": "junkaixue", "createdAt": "2020-08-03T18:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDIwNjcyMA=="}], "type": "inlineReview"}, {"oid": "a35971916d24868dfd5519214e409009ea01b11c", "url": "https://github.com/apache/helix/commit/a35971916d24868dfd5519214e409009ea01b11c", "message": "Address comments", "committedDate": "2020-08-03T18:38:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2ODIzOA==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464668238", "bodyText": "Why we cannot combine this case together with the case where skipZKRead is set to true? Is that because backward compatibility make it harder to code?", "author": "zhangmeng916", "createdAt": "2020-08-03T21:20:10Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/common/HelixDataAccessorWrapper.java", "diffHunk": "@@ -64,24 +63,47 @@ public HelixDataAccessorWrapper(ZKHelixDataAccessor dataAccessor) {\n     _restClient = CustomRestClientFactory.get();\n   }\n \n+  public HelixDataAccessorWrapper(ZKHelixDataAccessor dataAccessor, CustomRestClient customRestClient) {\n+    super(dataAccessor);\n+    _restClient = customRestClient;\n+  }\n+\n   public Map<String, Map<String, Boolean>> getAllPartitionsHealthOnLiveInstance(\n       RESTConfig restConfig, Map<String, String> customPayLoads) {\n+    return getAllPartitionsHealthOnLiveInstance(restConfig, customPayLoads, false);\n+  }\n+\n+  /**\n+   * Retrieve partition health status for each live instances combined with reading health partition report from ZK\n+   * and customized REST API call.\n+   *\n+   * @param restConfig        restConfig for the cluster contains customize REST API endpoint\n+   * @param customPayLoads    user passed in customized payloads\n+   * @param skipZKRead        skip the ZK read if this flag is true\n+   * @return                  A map of instance -> partition -> healthy or not (boolean).\n+   */\n+  public Map<String, Map<String, Boolean>> getAllPartitionsHealthOnLiveInstance(\n+      RESTConfig restConfig, Map<String, String> customPayLoads, boolean skipZKRead) {\n     // Only checks the instances are online with valid reports\n     List<String> liveInstances = getChildNames(keyBuilder().liveInstances());\n     // Make a parallel batch call for getting all healthreports from ZK.\n-    List<HelixProperty> zkHealthReports = getProperty(liveInstances.stream()\n-        .map(instance -> keyBuilder().healthReport(instance, PARTITION_HEALTH_KEY))\n-        .collect(Collectors.toList()), false);\n+    List<HelixProperty> zkHealthReports;\n+    if (!skipZKRead) {\n+      zkHealthReports = getProperty(liveInstances.stream()\n+          .map(instance -> keyBuilder().healthReport(instance, PARTITION_HEALTH_KEY))\n+          .collect(Collectors.toList()), false);\n+    } else {\n+      zkHealthReports =\n+          liveInstances.stream().map(instance -> new HelixProperty(instance)).collect(Collectors.toList());\n+    }\n     Map<String, Future<Map<String, Boolean>>> parallelTasks = new HashMap<>();\n     for (int i = 0; i < liveInstances.size(); i++) {\n       String liveInstance = liveInstances.get(i);\n-      Optional<ZNRecord> maybeHealthRecord =\n-          Optional.ofNullable(zkHealthReports.get(i)).map(HelixProperty::getRecord);\n-      parallelTasks.put(liveInstance,\n-          POOL.submit(() -> maybeHealthRecord\n-              .map(record -> getPartitionsHealth(liveInstance, record, restConfig, customPayLoads))\n-              .orElseGet(() -> getHealthStatusFromRest(liveInstance, Collections.emptyList(),\n-                  restConfig, customPayLoads))));\n+      Optional<ZNRecord> maybeHealthRecord = Optional.ofNullable(zkHealthReports.get(i)).map(HelixProperty::getRecord);\n+      parallelTasks.put(liveInstance, POOL.submit(() -> maybeHealthRecord.map(\n+          record -> getPartitionsHealthFromCustomAPI(liveInstance, record, restConfig, customPayLoads, skipZKRead))\n+          .orElseGet(\n+              () -> getHealthStatusFromRest(liveInstance, Collections.emptyList(), restConfig, customPayLoads))));", "originalCommit": "a35971916d24868dfd5519214e409009ea01b11c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY4MzkzOA==", "url": "https://github.com/apache/helix/pull/1197#discussion_r464683938", "bodyText": "Because there are a couple of scenarios:\n\nPartitions read from ZK, they are all healthy. No expired partitions. Directly return the ZK partition data.\nPartitions read from ZK, there are some expired partitions, query SN to get latest update.\nPartitions skip read from ZK, no partition data from ZK and no expired data, query SN without any partition specific to get all partition health status.", "author": "junkaixue", "createdAt": "2020-08-03T21:58:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDY2ODIzOA=="}], "type": "inlineReview"}]}