{"pr_number": 788, "pr_title": "Implement request forwarding for ZkRoutingDataWriter", "pr_createdAt": "2020-02-20T21:44:43Z", "pr_url": "https://github.com/apache/helix/pull/788", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTM4Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382281387", "bodyText": "Can we refactor this out into a private method getCurrentLeaderEndpoint()? That will make the code more readable and reduce duplication.", "author": "narendly", "createdAt": "2020-02-20T21:59:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5Mzk0Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382293943", "bodyText": "Agreed.", "author": "NealSun96", "createdAt": "2020-02-20T22:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNjAwOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382336008", "bodyText": "_leaderHostName is an instance variable now since it's used during multiple occasions. I'm refactoring the calling code since it can be generalized and reduce duplication.", "author": "NealSun96", "createdAt": "2020-02-21T00:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0MTcyMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382341722", "bodyText": "On a second thought I cannot do that because _leaderHostName will be changing. Modified my planned code structure for that. Duplication can still be reduced.", "author": "NealSun96", "createdAt": "2020-02-21T00:51:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTk4Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382281982", "bodyText": "What's the point of recording \"\"? Do you really need the ternary operator in this case?", "author": "narendly", "createdAt": "2020-02-20T22:00:38Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NDU5MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r382294591", "bodyText": "When there's no response body, it is still necessary to log \"the forward request has failed\". Constructing it like this reduces duplication.\nMaybe I can change \"\" to \"No response body is returned\" or something else meaningful.", "author": "NealSun96", "createdAt": "2020-02-20T22:29:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTk4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjExNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382326117", "bodyText": "You could do this:\nString errorMessage = \"The forwarded request from \" + (this node's hostname) + \" to leader \" + (leader's hostname) + \" has failed for addMetadataStoreRealm()!\";\nif (respEntity != null) {\n  errorMessage += \" Response: \" + EntityUtils.toString(respEntity);\n}\nLOG. error(errorMessage);", "author": "narendly", "createdAt": "2020-02-20T23:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4MTk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NDg5NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382284894", "bodyText": "See above - refactor!", "author": "narendly", "createdAt": "2020-02-20T22:07:08Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -90,7 +117,24 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NDcxOQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r382294719", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-20T22:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NDg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTE1Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382285157", "bodyText": "Could we configure a timeout for these requests?\nhttps://www.baeldung.com/httpclient-timeout\nSomething like 1 minute sounds reasonable. Make that 1 minute a constant somewhere and you could use it throughout.", "author": "narendly", "createdAt": "2020-02-20T22:07:43Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NTI1OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382295258", "bodyText": "I'll take a look. Very good point.", "author": "NealSun96", "createdAt": "2020-02-20T22:31:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NzcxNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382347717", "bodyText": "@narendly What's your opinion on the necessity of setting a socket timeout in addition to a connection timeout?", "author": "NealSun96", "createdAt": "2020-02-21T01:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTY3MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382285670", "bodyText": "Why is the ternary necessary?\nDid you meant to have a log msg like:\n\"the forwarded request to leader has failed for deleteMetadataStoreRealm:  \"?", "author": "narendly", "createdAt": "2020-02-20T22:08:53Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -90,7 +117,24 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpDelete deleteRequest = new HttpDelete(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n+      if (response.getStatusLine().getStatusCode() != 200) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NTQyNA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382295424", "bodyText": "Ditto my reply above.", "author": "NealSun96", "createdAt": "2020-02-20T22:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjQ0Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382326443", "bodyText": "See above", "author": "narendly", "createdAt": "2020-02-20T23:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NTY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NjAyNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382286026", "bodyText": "refactor?", "author": "narendly", "createdAt": "2020-02-20T22:09:42Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -136,7 +180,23 @@ public synchronized boolean addShardingKey(String realm, String shardingKey) {\n       return true;\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm\n+            + \"/sharding-keys/\" + shardingKey;", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NjI4NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382286284", "bodyText": "Nit: \"failed\"", "author": "narendly", "createdAt": "2020-02-20T22:10:18Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -225,6 +302,11 @@ public synchronized boolean setRoutingData(Map<String, List<String>> routingData\n   @Override\n   public synchronized void close() {\n     _zkClient.close();\n+    try {\n+      _forwardHttpClient.close();\n+    } catch (IOException e) {\n+      LOG.error(\"HttpClient fails to close. \", e);", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI5NTUxNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382295517", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-20T22:31:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NjI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382286772", "bodyText": "Where are you throwing an IllegalStateException?", "author": "narendly", "createdAt": "2020-02-20T22:11:27Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -90,9 +90,13 @@ public Response getAllMetadataStoreRealms() {\n   @Path(\"/metadata-store-realms/{realm}\")\n   public Response addMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n     try {\n-      _metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm);\n+      if (!_metadataStoreDirectory.addMetadataStoreRealm(_namespace, realm)) {\n+        return serverError();\n+      }\n     } catch (IllegalArgumentException ex) {\n       return notFound(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTA2Ng==", "url": "https://github.com/apache/helix/pull/788#discussion_r382309066", "bodyText": "In ZkRoutingDataWriter if _zkClient.isClosed().", "author": "NealSun96", "createdAt": "2020-02-20T23:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxOTgxNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382319817", "bodyText": "If that\u2019s the case, I would put it in addMetadatStoreRealm or a proper place, but not here in this endpoint logic. It is not endpoint logic\u2019s responsibility to process such exception.", "author": "huizhilu", "createdAt": "2020-02-20T23:37:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNzEzMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382327132", "bodyText": "+1. Let's make sure the MSDS server logs the errors. it would be helpful if we could include as much detail as possible including the host name, etc.", "author": "narendly", "createdAt": "2020-02-20T23:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMjMyNA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382332324", "bodyText": "If it's not handled, the exception will cause a server error anyways. Are you suggesting to handle it and not raise server error? IMO zkClient being closed is definitely a server error.", "author": "NealSun96", "createdAt": "2020-02-21T00:16:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNjg0OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382336848", "bodyText": "You could let this IllegalStateException float up all the way to the servlet..\nFor instance, for uncaught exceptions, the servlet container usually catch the Exception, logs it and returns http status 500.\nJust make sure MetadataStoreDirectory logs the exception properly.\nThe idea being conveyed here is that the REST resource (MetadataStoreDirectoryAccessor) shouldn't probably know about/handle every kind of exception that might be thrown from downstream api calls.", "author": "narendly", "createdAt": "2020-02-21T00:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NTcxNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382345717", "bodyText": "I see. I'll remove this section of the code. Thank you both for the insight.", "author": "NealSun96", "createdAt": "2020-02-21T01:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4Njc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NzU5MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382287590", "bodyText": "Nit: rename to MSDS_SERVER_HOSTNAME_KEY?\nAnd for the actual value, let's use \"msds_hostname\" so it doesn't conflict with some general \"instance_hostname\" key.", "author": "narendly", "createdAt": "2020-02-20T22:13:21Z", "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -37,5 +37,6 @@\n   // Field name in JSON REST response of getting sharding keys.\n   public static final String SHARDING_KEYS = \"shardingKeys\";\n \n-\n+  // The key for system properties that contains the hostname of an instance\n+  public static final String HOSTNAME_SYSTEM_PROPERTY_KEY = \"instance_hostname\";", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTE4NQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r382309185", "bodyText": "Sure.", "author": "NealSun96", "createdAt": "2020-02-20T23:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NzU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NzY2MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382287660", "bodyText": "hostname of the MSDS server instance", "author": "narendly", "createdAt": "2020-02-20T22:13:31Z", "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -37,5 +37,6 @@\n   // Field name in JSON REST response of getting sharding keys.\n   public static final String SHARDING_KEYS = \"shardingKeys\";\n \n-\n+  // The key for system properties that contains the hostname of an instance", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMwOTI2MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382309260", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-20T23:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI4NzY2MA=="}], "type": "inlineReview"}, {"oid": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "url": "https://github.com/apache/helix/commit/da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "message": "revert to notFound", "committedDate": "2020-02-20T23:32:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTg1MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382315850", "bodyText": "What if the property is not set in system?", "author": "huizhilu", "createdAt": "2020-02-20T23:26:38Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +71,12 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    ZNRecord myServerInfo = new ZNRecord(\n+        System.getProperty(MetadataStoreRoutingConstants.HOSTNAME_SYSTEM_PROPERTY_KEY));", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNDg3OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382324878", "bodyText": "+1. We could probably throw an IllegalStateException here if System.getProperty returns null.", "author": "narendly", "createdAt": "2020-02-20T23:51:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMjQxMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r382332412", "bodyText": "Good point. Fixing.", "author": "NealSun96", "createdAt": "2020-02-21T00:17:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjYxMA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382316610", "bodyText": "I would use created code rather than the hard coded 201: easier to read and maintain", "author": "huizhilu", "createdAt": "2020-02-20T23:28:47Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {", "originalCommit": "ad07262cd6d99f7c9771a5768f466bb08d278be9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTM4MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382325380", "bodyText": "+1. Don't we already have this as part of Helix REST? See javax.ws.rs.core.Response;?", "author": "narendly", "createdAt": "2020-02-20T23:53:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjYxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMjYxOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382332618", "bodyText": "Sure.", "author": "NealSun96", "createdAt": "2020-02-21T00:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382321567", "bodyText": "Can we have a message in the server error message why it fails or what the client should do? Server error is too plain.", "author": "huizhilu", "createdAt": "2020-02-20T23:41:32Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -153,9 +161,13 @@ public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n   public Response addShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n     try {\n-      _metadataStoreDirectory.addShardingKey(_namespace, realm, shardingKey);\n+      if (!_metadataStoreDirectory.addShardingKey(_namespace, realm, shardingKey)) {\n+        return serverError();", "originalCommit": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMzE1Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r382333153", "bodyText": "There are numerous different reasons why this could happen, and one single returned message is not going to cover all cases; saying it's a server error is sufficient to express that it's a server side situation.\nOn the other hand, whenever false is returned here, there are server logs that can help us identify the cause.", "author": "NealSun96", "createdAt": "2020-02-21T00:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM0NjE0OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382346148", "bodyText": "That is for server side. Think about client side: what is response for this? If you are a user, what would you like to know?", "author": "huizhilu", "createdAt": "2020-02-21T01:04:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM1NDQ0NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382354444", "bodyText": "Here are the situations where this condition can be invoked:\n\nWhen the request forwarded to the leader instance returns a non-ok;\nWhen the request forwarded to the leader raises an IOException;\nWhen writing to ZooKeeper fails.\n\nAll of them happen on the layer of ZkRoutingDataWriter. I'll need some advice on how to propagate the correct information back to the REST layer - I do not see an easy way to do this.\nAt the same time, I believe it's unnecessary to let clients know the exact situation among these 3 situations, because these situations are unrelated to client input and there's nothing clients can do. All these situations are strictly internal errors and are out of the hands of clients.", "author": "NealSun96", "createdAt": "2020-02-21T01:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM5MTE4MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382391180", "bodyText": "I understand the possible situations and there is no need to tell the client the real reason (and it is impossible here because the api just returns true or false). I meant, include a message suggesting what to do like \u201cserver error , please contact admin\u201d is helpful than plain response. Imagine, what would you get if you do curl this endpoint but server error?\nAnyway, I have an issue Created to improve the response. You don\u2019t have to do it here. Focus on the main task of the pr instead.", "author": "huizhilu", "createdAt": "2020-02-21T04:24:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyMTU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjM1NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382326354", "bodyText": "More helpful to include which host is forwarding to which leader.", "author": "narendly", "createdAt": "2020-02-20T23:56:12Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,7 +88,23 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpPut putRequest = new HttpPut(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(putRequest);\n+      if (response.getStatusLine().getStatusCode() != 201) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for addMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for addMetadataStoreRealm\", e);", "originalCommit": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzMzI2MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382333260", "bodyText": "As in the hostnames? Okay.", "author": "NealSun96", "createdAt": "2020-02-21T00:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjM1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMzNTE3MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r382335171", "bodyText": "Like this:\nString errorMessage = \"The forwarded request from \" + (this node's hostname) + \" to leader \" + (leader's hostname) + \" has failed for addMetadataStoreRealm()!\";\nif (respEntity != null) {\n  errorMessage += \" Response: \" + EntityUtils.toString(respEntity);\n}\nLOG. error(errorMessage);", "author": "narendly", "createdAt": "2020-02-21T00:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNjU1OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r382326558", "bodyText": "Improve logging with host name and leader host name", "author": "narendly", "createdAt": "2020-02-20T23:56:50Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -90,7 +117,24 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n     }\n \n-    // TODO: Forward the request to leader\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url =\n+        leaderHostName + \"/admin/v2/namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    HttpDelete deleteRequest = new HttpDelete(url);\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(deleteRequest);\n+      if (response.getStatusLine().getStatusCode() != 200) {\n+        HttpEntity respEntity = response.getEntity();\n+        LOG.error(\"the forwarded request to leader has failed for deleteMetadataStoreRealm: {}\",\n+            respEntity != null ? EntityUtils.toString(respEntity) : \"\");\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"the forwarded request to leader raised an exception for deleteMetadataStoreRealm\",\n+          e);", "originalCommit": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNzQ4Ng==", "url": "https://github.com/apache/helix/pull/788#discussion_r382327486", "bodyText": "Remove?", "author": "narendly", "createdAt": "2020-02-20T23:59:46Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -102,9 +106,13 @@ public Response addMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n   @Path(\"/metadata-store-realms/{realm}\")\n   public Response deleteMetadataStoreRealm(@PathParam(\"realm\") String realm) {\n     try {\n-      _metadataStoreDirectory.deleteMetadataStoreRealm(_namespace, realm);\n+      if (!_metadataStoreDirectory.deleteMetadataStoreRealm(_namespace, realm)) {\n+        return serverError();\n+      }\n     } catch (IllegalArgumentException ex) {\n       return notFound(ex.getMessage());\n+    } catch (IllegalStateException ex) {\n+      return serverError();", "originalCommit": "da16ebc7ceeed3e13f6858a8b1a50d11ffc1e4e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMDQ2MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384310461", "bodyText": "Can you do\ngetInstance().init(namespace, zkAddress); here to cut down on duplicate code?", "author": "narendly", "createdAt": "2020-02-26T07:21:31Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -42,49 +42,77 @@\n \n \n /**\n+ * NOTE: This is a singleton class. DO NOT EXTEND!\n  * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update\n  * callback.\n  */\n public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n   private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n \n-  // TODO: enable the line below when implementation is complete\n   // The following maps' keys represent the namespace\n-  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n-  private final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n-  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n-  private final Map<String, String> _routingZkAddressMap;\n+  // NOTE: made protected for testing reasons. DO NOT MODIFY!\n+  protected final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  protected final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n+  protected final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  protected final Map<String, String> _routingZkAddressMap;\n   // <namespace, <realm, <list of sharding keys>> mappings\n-  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+  protected final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n \n-  /**\n-   * Creates a ZkMetadataStoreDirectory based on the given routing ZK addresses.\n-   * @param routingZkAddressMap (namespace, routing ZK connect string)\n-   * @throws InvalidRoutingDataException\n-   */\n-  public ZkMetadataStoreDirectory(Map<String, String> routingZkAddressMap)\n+  private static volatile ZkMetadataStoreDirectory _zkMetadataStoreDirectoryInstance;\n+\n+  public static ZkMetadataStoreDirectory getInstance() {\n+    if (_zkMetadataStoreDirectoryInstance == null) {\n+      synchronized (ZkMetadataStoreDirectory.class) {\n+        if (_zkMetadataStoreDirectoryInstance == null) {\n+          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n+        }\n+      }\n+    }\n+\n+    return _zkMetadataStoreDirectoryInstance;\n+  }\n+\n+  public static ZkMetadataStoreDirectory getInstance(String namespace, String zkAddress)\n       throws InvalidRoutingDataException {\n-    if (routingZkAddressMap == null || routingZkAddressMap.isEmpty()) {\n-      throw new InvalidRoutingDataException(\"Routing ZK Addresses given are invalid!\");\n+    if (_zkMetadataStoreDirectoryInstance == null) {\n+      synchronized (ZkMetadataStoreDirectory.class) {\n+        if (_zkMetadataStoreDirectoryInstance == null) {\n+          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n+        }\n+      }\n     }\n-    _routingDataReaderMap = new HashMap<>();\n-    _routingDataWriterMap = new HashMap<>();\n-    _routingZkAddressMap = routingZkAddressMap;\n+    _zkMetadataStoreDirectoryInstance.init(namespace, zkAddress);", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNTM3OQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384735379", "bodyText": "That is a good point. Let me try that.", "author": "NealSun96", "createdAt": "2020-02-26T20:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMDQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMDk2MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384310960", "bodyText": "Remove print statements? We want to avoid this kind of stuff in production code.", "author": "narendly", "createdAt": "2020-02-26T07:23:05Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -40,8 +52,11 @@\n   private final String _namespace;\n   private final HelixZkClient _zkClient;\n   private final ZkDistributedLeaderElection _leaderElection;\n+  private final CloseableHttpClient _forwardHttpClient;\n+  private final String _myHostName;\n \n   public ZkRoutingDataWriter(String namespace, String zkAddress) {\n+    System.out.println(\"writer created namespace=\" + namespace + \" zkAddress=\" + zkAddress);", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzODYwNQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384638605", "bodyText": "This one escaped my own review. Fixing.", "author": "NealSun96", "createdAt": "2020-02-26T17:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTIwNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384311206", "bodyText": "Also include the check: _myHostName.isEmpty()", "author": "narendly", "createdAt": "2020-02-26T07:23:48Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +77,21 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (_myHostName == null) {", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzODg1Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384638852", "bodyText": "Makes sense.", "author": "NealSun96", "createdAt": "2020-02-26T17:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTU2MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384311560", "bodyText": "Let's make this a Java constant so that we could make this configurable later.\nprivate static final int HTTP_REQUEST_TIMEOUT = 60;", "author": "narendly", "createdAt": "2020-02-26T07:24:46Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +77,21 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (_myHostName == null) {\n+      throw new IllegalStateException(\n+          \"Unable to get the hostname of this server instance. System.getProperty fails to fetch \"\n+              + MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY + \".\");\n+    }\n+    ZNRecord myServerInfo = new ZNRecord(_myHostName);\n+\n     _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n         MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+\n+    int timeout = 60; // seconds", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0ODQ1OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384648458", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-26T17:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjM0MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384312340", "bodyText": "Generally a good idea to refactor this to a private method so that it's easier to read. For instance, create private String getUrlSuffix()\nSome of these string literals have already been defined in MetadataStoreDirectoryConstants.java. Could you use the constants there please?", "author": "narendly", "createdAt": "2020-02-26T07:27:16Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,8 +103,9 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY1MjQ1Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384652452", "bodyText": "I wanted to include the url creation as a part of forwardRequestToLeader, but I do not see a good way to generalize url construction. The 4 endpoints require 2 different urls; refactoring it results in an if statement, which isn't generalization. On the other hand, leaving url construction logic in the methods also clearly indicates which urls each endpoints correspond to, which is good for maintenance.\nIn MetadataStoreRoutingConstants, the constants are not quite the same as the strings in these urls. (shardingKeys vs sharding-keys, metadataStoreRealms vs metadata-store-realms)", "author": "NealSun96", "createdAt": "2020-02-26T17:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY1NDgwNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384654806", "bodyText": "I do see a lot of duplication here. It seems it's possible to achieve the refactoring. Let me sync with you privately.\n\n\nIf you don't have them, you can create them. That's what the constant file is for. Please clearly note what they are used for.", "author": "narendly", "createdAt": "2020-02-26T17:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjM0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY2MDYyMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384660621", "bodyText": "Resolved by offline discussion. A method that joins parameters will be used for url suffix building.", "author": "NealSun96", "createdAt": "2020-02-26T17:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMjM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzA0MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384313041", "bodyText": "Same here, let's make these String constants.\nI believe \"addMetadataStoreRealm\" should come from MetadataStoreDirectoryConstants.\n\"put\" could be a private enum called\nenum RequestForwardingHttpVerbs {\n    PUT,\n    POST,\n    DELETE\n}\n``` something like this.", "author": "narendly", "createdAt": "2020-02-26T07:29:26Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,8 +103,9 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addMetadataStoreRealm\",", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY1NDYwMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384654601", "bodyText": "I agree with this. Let me add an enum for it.", "author": "NealSun96", "createdAt": "2020-02-26T17:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzE0Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384313142", "bodyText": "Refactor into a private method.", "author": "narendly", "createdAt": "2020-02-26T07:29:45Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -87,11 +114,12 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+      return deleteZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzI3Ng==", "url": "https://github.com/apache/helix/pull/788#discussion_r384313276", "bodyText": "Use constants. No magic string literals floating around the code.", "author": "narendly", "createdAt": "2020-02-26T07:30:08Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -87,11 +114,12 @@ public synchronized boolean deleteMetadataStoreRealm(String realm) {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+      return deleteZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix = \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm;\n+    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteMetadataStoreRealm\",", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzQzOQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384313439", "bodyText": "Replace string literals.", "author": "narendly", "createdAt": "2020-02-26T07:30:41Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -100,44 +128,14 @@ public synchronized boolean addShardingKey(String realm, String shardingKey) {\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      // If the realm does not exist already, then create the realm\n-      String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n-      if (!_zkClient.exists(realmPath)) {\n-        // Create the realm\n-        if (!createZkRealm(realm)) {\n-          // Failed to create the realm - log and return false\n-          LOG.error(\n-              \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n-              _namespace, realm, shardingKey);\n-          return false;\n-        }\n-      }\n-\n-      // Add the sharding key to an empty ZNRecord\n-      ZNRecord znRecord;\n-      try {\n-        znRecord = _zkClient.readData(realmPath);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n-          Collections.singletonList(shardingKey));\n-      try {\n-        _zkClient.writeData(realmPath, znRecord);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      return true;\n+      return createZkShardingKey(realm, shardingKey);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix =\n+        \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm + \"/sharding-keys/\"\n+            + shardingKey;\n+    return forwardRequestToLeader(url_suffix, \"put\", \"addShardingKey\",\n+        Response.Status.CREATED.getStatusCode());", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMzUyMw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384313523", "bodyText": "String literals.", "author": "narendly", "createdAt": "2020-02-26T07:30:53Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -146,31 +144,14 @@ public synchronized boolean deleteShardingKey(String realm, String shardingKey)\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      ZNRecord znRecord =\n-          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n-      if (znRecord == null || !znRecord\n-          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .contains(shardingKey)) {\n-        // This realm does not exist or shardingKey doesn't exist. Return true!\n-        return true;\n-      }\n-      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .remove(shardingKey);\n-      // Overwrite this ZNRecord with the sharding key removed\n-      try {\n-        _zkClient\n-            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      return true;\n+      return deleteZkShardingKey(realm, shardingKey);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String url_suffix =\n+        \"namespaces/\" + _namespace + \"/metadata-store-realms/\" + realm + \"/sharding-keys/\"\n+            + shardingKey;\n+    return forwardRequestToLeader(url_suffix, \"delete\", \"deleteShardingKey\",\n+        Response.Status.OK.getStatusCode());", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDE0Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384314147", "bodyText": "Use an enum here instead of String literals.", "author": "narendly", "createdAt": "2020-02-26T07:32:50Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +235,119 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n+      int expectedResponseCode) throws IllegalArgumentException {\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + url_suffix;\n+    System.out.println(url);\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDQzMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384314431", "bodyText": "Also a good idea to log the response code.", "author": "narendly", "createdAt": "2020-02-26T07:33:40Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +235,119 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n+      int expectedResponseCode) throws IllegalArgumentException {\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + url_suffix;\n+    System.out.println(url);\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n+    }\n+\n+    return sendRequestToLeader(request, expectedResponseCode, endPoint, leaderHostName);\n+  }\n+\n+  // Set to be protected for testing purposes\n+  protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n+      String endPoint, String leaderHostName) {\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(request);\n+      if (response.getStatusLine().getStatusCode() != expectedResponseCode) {\n+        HttpEntity respEntity = response.getEntity();\n+        String errorLog =\n+            \"The forwarded request to leader has failed for \" + endPoint + \". Current hostname: \"\n+                + _myHostName + \" Leader hostname: \" + leaderHostName;\n+        if (respEntity != null) {\n+          errorLog += \" Response: \" + EntityUtils.toString(respEntity);", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5MzIwMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384693201", "bodyText": "Added the response code on line 336 because it always exists. Thank you for the suggestion.", "author": "NealSun96", "createdAt": "2020-02-26T18:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDQ5Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384314493", "bodyText": "Remove empty line?", "author": "narendly", "createdAt": "2020-02-26T07:33:53Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +235,119 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private boolean forwardRequestToLeader(String url_suffix, String request_method, String endPoint,\n+      int expectedResponseCode) throws IllegalArgumentException {\n+    String leaderHostName = _leaderElection.getCurrentLeaderInfo().getId();\n+    String url = leaderHostName + url_suffix;\n+    System.out.println(url);\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported request_method: \" + request_method);\n+    }\n+\n+    return sendRequestToLeader(request, expectedResponseCode, endPoint, leaderHostName);\n+  }\n+\n+  // Set to be protected for testing purposes\n+  protected boolean sendRequestToLeader(HttpUriRequest request, int expectedResponseCode,\n+      String endPoint, String leaderHostName) {\n+    try {\n+      HttpResponse response = _forwardHttpClient.execute(request);\n+      if (response.getStatusLine().getStatusCode() != expectedResponseCode) {\n+        HttpEntity respEntity = response.getEntity();\n+        String errorLog =\n+            \"The forwarded request to leader has failed for \" + endPoint + \". Current hostname: \"\n+                + _myHostName + \" Leader hostname: \" + leaderHostName;\n+        if (respEntity != null) {\n+          errorLog += \" Response: \" + EntityUtils.toString(respEntity);\n+        }\n+        LOG.error(errorLog);\n+        return false;\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\n+          \"The forwarded request to leader raised an exception for {}. Current hostname: {} Leader hostname: {}\",\n+          endPoint, _myHostName, leaderHostName, e);\n+      return false;\n+    }\n+", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDc4Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384314783", "bodyText": "Nit: \"Initialize\" would the the term.", "author": "narendly", "createdAt": "2020-02-26T07:34:48Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/ServerContext.java", "diffHunk": "@@ -64,6 +66,8 @@ public ServerContext(String zkAddr) {\n     // cannot be started correctly.\n     _helixDataAccessorPool = new HashMap<>();\n     _taskDriverPool = new HashMap<>();\n+    // Initiate the singleton ZkMetadataStoreDirectory instance to allow it to be closed later", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5MzM4Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384693387", "bodyText": "I agree.", "author": "NealSun96", "createdAt": "2020-02-26T18:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDc4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5NDQ4Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384694487", "bodyText": "Hm, I think my eyes were caught by the \"initiate\" in the comment on line 63, therefore I wrote \"initiate\" too.", "author": "NealSun96", "createdAt": "2020-02-26T18:53:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNDc4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTE0NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384315144", "bodyText": "Could you add some comments about the Jersey behavior here for reference as a block comment?", "author": "narendly", "createdAt": "2020-02-26T07:35:56Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -152,8 +155,13 @@ public Response getShardingKeys(@QueryParam(\"realm\") String realm) {\n   @Path(\"/metadata-store-realms/{realm}/sharding-keys/{sharding-key: .+}\")\n   public Response addShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n+    if (shardingKey.charAt(0) != '/') {\n+      shardingKey = \"/\" + shardingKey;\n+    }", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5Njk5NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384696994", "bodyText": "Fixed together with the later occurrence.", "author": "NealSun96", "createdAt": "2020-02-26T18:58:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTMzMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384315332", "bodyText": "Now this is duplicate code. Could you refactor this out to a private method? You could explain the JAX-RS behavior around slashes there.", "author": "narendly", "createdAt": "2020-02-26T07:36:26Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/metadatastore/MetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -165,8 +173,13 @@ public Response addShardingKey(@PathParam(\"realm\") String realm,\n   @Path(\"/metadata-store-realms/{realm}/sharding-keys/{sharding-key: .+}\")\n   public Response deleteShardingKey(@PathParam(\"realm\") String realm,\n       @PathParam(\"sharding-key\") String shardingKey) {\n+    if (shardingKey.charAt(0) != '/') {\n+      shardingKey = \"/\" + shardingKey;\n+    }", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY5NzA2Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384697062", "bodyText": "Done so.", "author": "NealSun96", "createdAt": "2020-02-26T18:58:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384315906", "bodyText": "Also add here that the reason we are not putting this in the test package is because the Jersey framework does not recognize resources in the test package when it spins up servers.", "author": "narendly", "createdAt": "2020-02-26T07:38:07Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMjI3MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384702271", "bodyText": "This might not be true. On Monday we assumed that Jersey isn't able to recognize it in the test package, and we moved this file into the same package as MetadataStoreDirectoryAccessor for it to work, hence our conclusion. However, on Tuesday, after moving it to its own package (not in the test package, but its own package), it was not working either.\nAfter research, I realized that its package path was not correctly added. On Monday, this file is in the same package as MetadataStoreDirectoryAccessor, and it was working because the package for MetadataStoreDirectoryAccessor was added already. There were some major changes to MockHelixRestServer for it to work in this current package. Therefore, the conclusion on Monday is not true anymore - the reason it wasn't working might not be due to the test package.\nRegardless, I think it's fine to leave this file here. However, if you believe this file is better in the test package, I can experiment with that and verify our conclusion.", "author": "NealSun96", "createdAt": "2020-02-26T19:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MDIyMA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384770220", "bodyText": "Why wasn't it working then? I'd like to know the reason. If you don't think putting this class in the test package causes a problem, should we move it back to the test package?", "author": "narendly", "createdAt": "2020-02-26T21:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4NjkwNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384786907", "bodyText": "It wasn't working because the file's package was never added properly. Our method of overriding silently failed.\nSure, let me experiment with moving it to a test package and let's see if it still works.", "author": "NealSun96", "createdAt": "2020-02-26T21:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0MjE0MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384842141", "bodyText": "The experiment was successful. It shows that it works in the test package too. Now the file sits in test.org.apache.helix.rest.server.mock.", "author": "NealSun96", "createdAt": "2020-02-27T00:07:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNTkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjE0OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384316148", "bodyText": "Static boolean -> make it all caps?", "author": "narendly", "createdAt": "2020-02-26T07:38:49Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwMzUxMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384703512", "bodyText": "This is not a constant variable, though. It's a flag value that's used to identify if there were zookeeper operations. Should it still be all caps?", "author": "NealSun96", "createdAt": "2020-02-26T19:10:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjE0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjIxMw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384772213", "bodyText": "I'm actually fine either way since this is just a global created for testing.", "author": "narendly", "createdAt": "2020-02-26T21:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjM0MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384316340", "bodyText": "Do not leave any stacktraces here. Let's use LOG.error(...)", "author": "narendly", "createdAt": "2020-02-26T07:39:31Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;\n+  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n+  public static MetadataStoreDirectory _mockMSDInstance;\n+\n+  /**\n+   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n+   */\n+  @Override\n+  protected void buildMetadataStoreDirectory(String namespace, String address) {\n+    try {\n+      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n+      _mockMSDInstance = _metadataStoreDirectory;\n+    } catch (InvalidRoutingDataException e) {\n+      e.printStackTrace();", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwNDUyMA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384704520", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-26T19:12:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjM0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjQzMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384316431", "bodyText": "Not impossible, but difficult. You're making it happen here ;)", "author": "narendly", "createdAt": "2020-02-26T07:39:50Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;\n+  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n+  public static MetadataStoreDirectory _mockMSDInstance;\n+\n+  /**\n+   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n+   */\n+  @Override\n+  protected void buildMetadataStoreDirectory(String namespace, String address) {\n+    try {\n+      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n+      _mockMSDInstance = _metadataStoreDirectory;\n+    } catch (InvalidRoutingDataException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  /**\n+   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n+   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjk2MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384316961", "bodyText": "Could you create an issue and link that issue here as a TODO? The TODO should talk about how you should make this a configurable thing where developers could just feed in configs (like # of servers and names of resources to be included) to start multiple mock server instances. The purpose is to test features that involve multiple servers (like distributed leader election, distributed locking, etc.)", "author": "narendly", "createdAt": "2020-02-26T07:41:21Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyMTgxMw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384721813", "bodyText": "#816 I'll link this in the code.", "author": "NealSun96", "createdAt": "2020-02-26T19:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNjk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzI4OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384317288", "bodyText": "Nit: Should you clear the maps?", "author": "narendly", "createdAt": "2020-02-26T07:42:19Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/server/resources/mock/MockMetadataStoreDirectoryAccessor.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package org.apache.helix.rest.server.resources.mock;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import javax.ws.rs.Path;\n+\n+import org.apache.helix.msdcommon.datamodel.TrieRoutingData;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.MetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.ZkMetadataStoreDirectory;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataWriter;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataWriter;\n+import org.apache.helix.rest.server.resources.metadatastore.MetadataStoreDirectoryAccessor;\n+\n+\n+/**\n+ * An accessor that mocks the MetadataStoreDirectoryAccessor for testing purpose.\n+ */\n+@Path(\"/mock\")\n+public class MockMetadataStoreDirectoryAccessor extends MetadataStoreDirectoryAccessor {\n+  // A flag that will be modified if the underlying MockZkRoutingDataWriter makes an operation\n+  // against ZooKeeper\n+  public static boolean operatedOnZk = false;\n+  // The instance of mockMSD that's created by this accessor; it's saved here to be closed later\n+  public static MetadataStoreDirectory _mockMSDInstance;\n+\n+  /**\n+   * This method is overriden so that an instance of MockZkMetadataStoreDirectory can be passed in\n+   */\n+  @Override\n+  protected void buildMetadataStoreDirectory(String namespace, String address) {\n+    try {\n+      _metadataStoreDirectory = new MockZkMetadataStoreDirectory(namespace, address);\n+      _mockMSDInstance = _metadataStoreDirectory;\n+    } catch (InvalidRoutingDataException e) {\n+      e.printStackTrace();\n+    }\n+  }\n+\n+  /**\n+   * Used to artificially create another instance of ZkMetadataStoreDirectory.\n+   * ZkMetadataStoreDirectory being a singleton makes it impossible to test it,\n+   * therefore this is the only way to create another instance.\n+   */\n+  class MockZkMetadataStoreDirectory extends ZkMetadataStoreDirectory {\n+    MockZkMetadataStoreDirectory(String namespace, String zkAddress)\n+        throws InvalidRoutingDataException {\n+      super();\n+\n+      // Manually populate the map so that MockZkRoutingDataWriter can be passed in\n+      _routingZkAddressMap.put(namespace, zkAddress);\n+      _routingDataReaderMap.put(namespace, new ZkRoutingDataReader(namespace, zkAddress, this));\n+      _routingDataWriterMap.put(namespace, new MockZkRoutingDataWriter(namespace, zkAddress));\n+      _realmToShardingKeysMap.put(namespace, _routingDataReaderMap.get(namespace).getRoutingData());\n+      _routingDataMap.put(namespace, new TrieRoutingData(_realmToShardingKeysMap.get(namespace)));\n+    }\n+\n+    @Override\n+    public void close() {\n+      _routingDataReaderMap.values().forEach(MetadataStoreRoutingDataReader::close);\n+      _routingDataWriterMap.values().forEach(MetadataStoreRoutingDataWriter::close);", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwNjc1OQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384706759", "bodyText": "It's not necessary because MockMSD is not a singleton. A new instance is created each time.", "author": "NealSun96", "createdAt": "2020-02-26T19:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzI4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjQ5Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384772493", "bodyText": "OK.", "author": "narendly", "createdAt": "2020-02-26T21:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzgwOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384317808", "bodyText": "Nit: MockZkRoutingDataWriter so there's no ambiguity?", "author": "narendly", "createdAt": "2020-02-26T07:43:47Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java", "diffHunk": "@@ -40,15 +41,35 @@\n   private static final String DUMMY_SHARDING_KEY = \"SHARDING_KEY\";\n   private MetadataStoreRoutingDataWriter _zkRoutingDataWriter;\n \n+  // MockWriter is used for testing request forwarding features in non-leader situations\n+  class MockWriter extends ZkRoutingDataWriter {", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwODAwOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384708008", "bodyText": "Ditto below. This mock writer is for unit testing ZkRoutingDataWriter, it's not the one for integration testing.", "author": "NealSun96", "createdAt": "2020-02-26T19:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzgwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjY0MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384772640", "bodyText": "OK", "author": "narendly", "createdAt": "2020-02-26T21:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxNzgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxODIwNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384318207", "bodyText": "Shouldn't you make the HTTP call? Otherwise you won't be covering distributed leader election? I think we should make the HTTP call here to the leader. Otherwise it's not a true integration test.\nOr is this meant to be a unit test?", "author": "narendly", "createdAt": "2020-02-26T07:44:56Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/metadatastore/accessor/TestZkRoutingDataWriter.java", "diffHunk": "@@ -40,15 +41,35 @@\n   private static final String DUMMY_SHARDING_KEY = \"SHARDING_KEY\";\n   private MetadataStoreRoutingDataWriter _zkRoutingDataWriter;\n \n+  // MockWriter is used for testing request forwarding features in non-leader situations\n+  class MockWriter extends ZkRoutingDataWriter {\n+    HttpUriRequest calledRequest;\n+\n+    MockWriter(String namespace, String zkAddress) {\n+      super(namespace, zkAddress);\n+    }\n+\n+    // This method does not call super() because the http call should not be actually made\n+    @Override", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcwODkyMA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384708920", "bodyText": "I think you got the wrong file. :)\nThe MockZkRoutingDataWriter for integration testing is in MockMetadataStoreDirectoryAccessor.java, and that's where the actual HTTP calls are made to the leader. This file is for unit-testing, where only the forwarding logic is tested.", "author": "NealSun96", "createdAt": "2020-02-26T19:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxODIwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Mjc4Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384772787", "bodyText": "Ok, so a unit test.", "author": "narendly", "createdAt": "2020-02-26T21:20:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxODIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAzOQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384319039", "bodyText": "Why do you need to create a new HashSet out of a set?\nYou could probably return Collections.unmodifiableSet(....keySet()) as well if you want to prevent modifications", "author": "narendly", "createdAt": "2020-02-26T07:47:21Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/MetadataStoreDirectoryAccessorTestBase.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.helix.TestHelper;\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.metadatastore.accessor.MetadataStoreRoutingDataReader;\n+import org.apache.helix.rest.metadatastore.accessor.ZkRoutingDataReader;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+\n+\n+public class MetadataStoreDirectoryAccessorTestBase extends AbstractTestClass {\n+  /*\n+   * The following are constants to be used for testing.\n+   */\n+  protected static final String TEST_NAMESPACE_URI_PREFIX = \"/namespaces/\" + TEST_NAMESPACE;\n+  protected static final String NON_EXISTING_NAMESPACE_URI_PREFIX =\n+      \"/namespaces/not-existed-namespace/metadata-store-realms/\";\n+  protected static final String TEST_REALM_1 = \"testRealm1\";\n+  protected static final List<String> TEST_SHARDING_KEYS_1 =\n+      Arrays.asList(\"/sharding/key/1/a\", \"/sharding/key/1/b\", \"/sharding/key/1/c\");\n+  protected static final String TEST_REALM_2 = \"testRealm2\";\n+  protected static final List<String> TEST_SHARDING_KEYS_2 =\n+      Arrays.asList(\"/sharding/key/1/d\", \"/sharding/key/1/e\", \"/sharding/key/1/f\");\n+  protected static final String TEST_REALM_3 = \"testRealm3\";\n+  protected static final String TEST_SHARDING_KEY = \"/sharding/key/1/x\";\n+\n+  // List of all ZK addresses, each of which corresponds to a namespace/routing ZK\n+  protected List<String> _zkList;\n+  protected MetadataStoreRoutingDataReader _routingDataReader;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    _zkList = new ArrayList<>(ZK_SERVER_MAP.keySet());\n+\n+    deleteRoutingDataPath();\n+\n+    // Write dummy mappings in ZK\n+    // Create a node that represents a realm address and add 3 sharding keys to it\n+    ZNRecord znRecord = new ZNRecord(\"RoutingInfo\");\n+\n+    _zkList.forEach(zk -> {\n+      ZK_SERVER_MAP.get(zk).getZkClient().setZkSerializer(new ZNRecordSerializer());\n+      // Write first realm and sharding keys pair\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          TEST_SHARDING_KEYS_1);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_1,\n+              true);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_1,\n+              znRecord);\n+\n+      // Create another realm and sharding keys pair\n+      znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY,\n+          TEST_SHARDING_KEYS_2);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .createPersistent(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_2,\n+              true);\n+      ZK_SERVER_MAP.get(zk).getZkClient()\n+          .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + TEST_REALM_2,\n+              znRecord);\n+    });\n+\n+    _routingDataReader = new ZkRoutingDataReader(TEST_NAMESPACE, _zkAddrTestNS, null);\n+\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY,\n+        getBaseUri().toString());\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    System.clearProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    deleteRoutingDataPath();\n+  }\n+\n+  protected void deleteRoutingDataPath() throws Exception {\n+    Assert.assertTrue(TestHelper.verify(() -> {\n+      _zkList.forEach(zk -> ZK_SERVER_MAP.get(zk).getZkClient()\n+          .deleteRecursively(MetadataStoreRoutingConstants.ROUTING_DATA_PATH));\n+\n+      for (String zk : _zkList) {\n+        if (ZK_SERVER_MAP.get(zk).getZkClient()\n+            .exists(MetadataStoreRoutingConstants.ROUTING_DATA_PATH)) {\n+          return false;\n+        }\n+      }\n+\n+      return true;\n+    }, TestHelper.WAIT_DURATION), \"Routing data path should be deleted after the tests.\");\n+  }\n+\n+  protected Set<String> getAllMetadataStoreRealmsHelper() throws InvalidRoutingDataException {\n+    return new HashSet<>(_routingDataReader.getRoutingData().keySet());", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMDIxOQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384710219", "bodyText": "Because in TestMetadataStoreDirectoryAccessor we need to modify this set. For example:\nSet<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\nexpectedRealmsSet.add(TEST_REALM_3);\n\nkeySet() is unmodifiable. Making a copy makes it modifiable.", "author": "NealSun96", "createdAt": "2020-02-26T19:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MzMyNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384773327", "bodyText": "getAllMetadataStoreRealmsHelper -> this naming is a little confusing. Consider renaming or explain what it does and why it's needed.", "author": "narendly", "createdAt": "2020-02-26T21:21:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzNTg0MA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384835840", "bodyText": "Renamed and added comments.", "author": "NealSun96", "createdAt": "2020-02-26T23:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTI1NA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384319254", "bodyText": "Avoid static imports. Just qualify with \"MetadataStoreRoutingConstants.\"", "author": "narendly", "createdAt": "2020-02-26T07:48:03Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMTA1Mw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384711053", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-26T19:24:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTQzMg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384319432", "bodyText": "Nit: I think TestMSDAccessorLeaderElection sounds better.", "author": "narendly", "createdAt": "2020-02-26T07:48:32Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMTU2Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384711567", "bodyText": "Sure, saying \"leader election\" is sufficient.", "author": "NealSun96", "createdAt": "2020-02-26T19:25:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTU5Ng==", "url": "https://github.com/apache/helix/pull/788#discussion_r384319596", "bodyText": "private static final String is how you declare a constant.", "author": "narendly", "createdAt": "2020-02-26T07:49:00Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMjI2Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384712267", "bodyText": "Oops. Fixing it.", "author": "NealSun96", "createdAt": "2020-02-26T19:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxOTU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDE5MQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384320191", "bodyText": "We see a lot of getPort() + 1's here. Let's just create a new variable,\nint newPort = getPort() + 1; and use newPort throughout? This will make your code more readable.", "author": "narendly", "createdAt": "2020-02-26T07:50:45Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMzA0Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384713042", "bodyText": "Sure.", "author": "NealSun96", "createdAt": "2020-02-26T19:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDMyMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384320321", "bodyText": "LOG.error instead of printing stacktrace please.", "author": "narendly", "createdAt": "2020-02-26T07:51:04Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxMzg2Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384713867", "bodyText": "Ack.", "author": "NealSun96", "createdAt": "2020-02-26T19:29:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDczNw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384320737", "bodyText": "\"put\" could be an enum.", "author": "narendly", "createdAt": "2020-02-26T07:52:15Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+\n+    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n+    // it didn't exist yet.\n+    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // Set the new uri to be used in leader election\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n+\n+    // Start http client for testing\n+    _httpClient = HttpClients.createDefault();\n+\n+    // Start zkclient to verify leader election behavior\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+    _mockHelixRestServer.shutdown();\n+    _httpClient.close();\n+    _zkClient.close();\n+  }\n+\n+  @Test\n+  public void testAddMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n+        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxNTAxNQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384715015", "bodyText": "Using the same enum as the other class.", "author": "NealSun96", "createdAt": "2020-02-26T19:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMDc3Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384320772", "bodyText": "Use enum for \"delete\"", "author": "narendly", "createdAt": "2020-02-26T07:52:23Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+\n+    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n+    // it didn't exist yet.\n+    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // Set the new uri to be used in leader election\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n+\n+    // Start http client for testing\n+    _httpClient = HttpClients.createDefault();\n+\n+    // Start zkclient to verify leader election behavior\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+    _mockHelixRestServer.shutdown();\n+    _httpClient.close();\n+    _zkClient.close();\n+  }\n+\n+  @Test\n+  public void testAddMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n+        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n+        Response.Status.CREATED.getStatusCode());\n+    expectedRealmsSet.add(TEST_REALM_3);\n+    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n+  public void testDeleteMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMTUxOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384321518", "bodyText": "Enum!", "author": "narendly", "createdAt": "2020-02-26T07:54:30Z", "path": "helix-rest/src/test/java/org/apache/helix/rest/server/TestMSDADistributedLeaderElection.java", "diffHunk": "@@ -0,0 +1,225 @@\n+package org.apache.helix.rest.server;\n+\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Set;\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants;\n+import org.apache.helix.msdcommon.exception.InvalidRoutingDataException;\n+import org.apache.helix.rest.common.ContextPropertyKeys;\n+import org.apache.helix.rest.common.HelixRestNamespace;\n+import org.apache.helix.rest.common.ServletType;\n+import org.apache.helix.rest.server.auditlog.AuditLogger;\n+import org.apache.helix.rest.server.filters.CORSFilter;\n+import org.apache.helix.rest.server.resources.mock.MockMetadataStoreDirectoryAccessor;\n+import org.apache.helix.zookeeper.api.client.HelixZkClient;\n+import org.apache.helix.zookeeper.datamodel.ZNRecord;\n+import org.apache.helix.zookeeper.datamodel.serializer.ZNRecordSerializer;\n+import org.apache.helix.zookeeper.impl.factory.DedicatedZkClientFactory;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.methods.HttpDelete;\n+import org.apache.http.client.methods.HttpPut;\n+import org.apache.http.client.methods.HttpUriRequest;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClients;\n+import org.glassfish.jersey.server.ResourceConfig;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.apache.helix.msdcommon.constant.MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE;\n+\n+\n+public class TestMSDADistributedLeaderElection extends MetadataStoreDirectoryAccessorTestBase {\n+  private final String MOCK_URL_PREFIX = \"/mock\";\n+\n+  private HelixRestServer _mockHelixRestServer;\n+  private String _mockBaseUri;\n+  private String _leaderBaseUri;\n+  private CloseableHttpClient _httpClient;\n+  private HelixZkClient _zkClient;\n+\n+  @BeforeClass\n+  public void beforeClass() throws Exception {\n+    super.beforeClass();\n+    _leaderBaseUri = getBaseUri().toString();\n+\n+    // Start a second server for testing Distributed Leader Election for writes\n+    _mockBaseUri =\n+        getBaseUri().getScheme() + \"://\" + getBaseUri().getHost() + \":\" + (getBaseUri().getPort()\n+            + 1);\n+    try {\n+      List<HelixRestNamespace> namespaces = new ArrayList<>();\n+      // Add test namespace\n+      namespaces.add(new HelixRestNamespace(TEST_NAMESPACE,\n+          HelixRestNamespace.HelixMetadataStoreType.ZOOKEEPER, _zkAddrTestNS, false));\n+      _mockHelixRestServer =\n+          new MockHelixRestServer(namespaces, getBaseUri().getPort() + 1, getBaseUri().getPath(),\n+              Collections.singletonList(_auditLogger));\n+      _mockHelixRestServer.start();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();\n+    }\n+\n+    // Calling the original endpoint to create an instance of MetadataStoreDirectory in case\n+    // it didn't exist yet.\n+    get(TEST_NAMESPACE_URI_PREFIX + \"/metadata-store-realms\", null,\n+        Response.Status.OK.getStatusCode(), true);\n+\n+    // Set the new uri to be used in leader election\n+    System.setProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY, _mockBaseUri);\n+\n+    // Start http client for testing\n+    _httpClient = HttpClients.createDefault();\n+\n+    // Start zkclient to verify leader election behavior\n+    _zkClient = DedicatedZkClientFactory.getInstance()\n+        .buildZkClient(new HelixZkClient.ZkConnectionConfig(_zkAddrTestNS),\n+            new HelixZkClient.ZkClientConfig().setZkSerializer(new ZNRecordSerializer()));\n+  }\n+\n+  @AfterClass\n+  public void afterClass() throws Exception {\n+    super.afterClass();\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+    _mockHelixRestServer.shutdown();\n+    _httpClient.close();\n+    _zkClient.close();\n+  }\n+\n+  @Test\n+  public void testAddMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    Assert.assertFalse(expectedRealmsSet.contains(TEST_REALM_3),\n+        \"Metadata store directory should not have realm: \" + TEST_REALM_3);\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"put\",\n+        Response.Status.CREATED.getStatusCode());\n+    expectedRealmsSet.add(TEST_REALM_3);\n+    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testAddMetadataStoreRealmRequestForwarding\")\n+  public void testDeleteMetadataStoreRealmRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedRealmsSet = getAllMetadataStoreRealmsHelper();\n+    sendRequestAndValidate(\"/metadata-store-realms/\" + TEST_REALM_3, \"delete\",\n+        Response.Status.OK.getStatusCode());\n+    expectedRealmsSet.remove(TEST_REALM_3);\n+    Assert.assertEquals(getAllMetadataStoreRealmsHelper(), expectedRealmsSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testDeleteMetadataStoreRealmRequestForwarding\")\n+  public void testAddShardingKeyRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n+    Assert.assertFalse(expectedShardingKeysSet.contains(TEST_SHARDING_KEY),\n+        \"Realm does not have sharding key: \" + TEST_SHARDING_KEY);\n+    sendRequestAndValidate(\n+        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"put\",\n+        Response.Status.CREATED.getStatusCode());\n+    expectedShardingKeysSet.add(TEST_SHARDING_KEY);\n+    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  @Test(dependsOnMethods = \"testAddShardingKeyRequestForwarding\")\n+  public void testDeleteShardingKeyRequestForwarding()\n+      throws InvalidRoutingDataException, IOException {\n+    Set<String> expectedShardingKeysSet = getShardingKeysInRealmHelper();\n+    sendRequestAndValidate(\n+        \"/metadata-store-realms/\" + TEST_REALM_1 + \"/sharding-keys/\" + TEST_SHARDING_KEY, \"delete\",\n+        Response.Status.OK.getStatusCode());\n+    expectedShardingKeysSet.remove(TEST_SHARDING_KEY);\n+    Assert.assertEquals(getShardingKeysInRealmHelper(), expectedShardingKeysSet);\n+    MockMetadataStoreDirectoryAccessor._mockMSDInstance.close();\n+  }\n+\n+  private void sendRequestAndValidate(String url_suffix, String request_method,\n+      int expectedResponseCode) throws IllegalArgumentException, IOException {\n+    String url = _mockBaseUri + TEST_NAMESPACE_URI_PREFIX + MOCK_URL_PREFIX + url_suffix;\n+    HttpUriRequest request;\n+    switch (request_method) {\n+      case \"put\":\n+        request = new HttpPut(url);\n+        break;\n+      case \"delete\":\n+        request = new HttpDelete(url);\n+        break;", "originalCommit": "11590ba901e970e4298b9515e7514e9f61d42f84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f77c181059e08811faa96e3b0ed242d3ca78ef8f", "url": "https://github.com/apache/helix/commit/f77c181059e08811faa96e3b0ed242d3ca78ef8f", "message": "implement request forwarding", "committedDate": "2020-02-26T18:08:29Z", "type": "commit"}, {"oid": "2b00953af8a4c2d64b00d10d900516a300a287ce", "url": "https://github.com/apache/helix/commit/2b00953af8a4c2d64b00d10d900516a300a287ce", "message": "revert to notFound", "committedDate": "2020-02-26T18:08:29Z", "type": "commit"}, {"oid": "bd396337b593ea4172e7b895fa4355214e322e54", "url": "https://github.com/apache/helix/commit/bd396337b593ea4172e7b895fa4355214e322e54", "message": "fix existing bugs and make accessor tests work", "committedDate": "2020-02-26T18:13:37Z", "type": "commit"}, {"oid": "b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "url": "https://github.com/apache/helix/commit/b70550c60934b9dd8ce7b220aed9f28c09bd86a9", "message": "address comments, add tests, convert MSD to singleton, fix leader election", "committedDate": "2020-02-26T18:14:11Z", "type": "commit"}, {"oid": "798fd3d3251c43f80074b161da1f0d54bbef4f48", "url": "https://github.com/apache/helix/commit/798fd3d3251c43f80074b161da1f0d54bbef4f48", "message": "add integration tests, modify sharding keys endpoint, correct writer forwarding behavior", "committedDate": "2020-02-26T18:17:40Z", "type": "commit"}, {"oid": "54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "url": "https://github.com/apache/helix/commit/54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "message": "address first comments, need to rebase", "committedDate": "2020-02-26T18:17:40Z", "type": "commit"}, {"oid": "54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "url": "https://github.com/apache/helix/commit/54a7e7c2b366891e7e4e7fb552fc82c29011c36a", "message": "address first comments, need to rebase", "committedDate": "2020-02-26T18:17:40Z", "type": "forcePushed"}, {"oid": "b8e14234b348fd4059a374468691d87d6a4a88b8", "url": "https://github.com/apache/helix/commit/b8e14234b348fd4059a374468691d87d6a4a88b8", "message": "address many comments", "committedDate": "2020-02-26T20:22:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NDE5Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384764197", "bodyText": "Is there a reason why you couldn't include * 1000 in the constant itself?", "author": "narendly", "createdAt": "2020-02-26T21:04:21Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -62,10 +77,24 @@ public ZkRoutingDataWriter(String namespace, String zkAddress) {\n     }\n \n     // Get the hostname (REST endpoint) from System property\n-    // TODO: Fill in when Helix REST implementations are ready\n-    ZNRecord myServerInfo = new ZNRecord(\"dummy hostname\");\n+    _myHostName = System.getProperty(MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY);\n+    if (_myHostName == null || _myHostName.isEmpty()) {\n+      throw new IllegalStateException(\n+          \"Unable to get the hostname of this server instance. System.getProperty fails to fetch \"\n+              + MetadataStoreRoutingConstants.MSDS_SERVER_HOSTNAME_KEY + \".\");\n+    }\n+    ZNRecord myServerInfo = new ZNRecord(_myHostName);\n+\n     _leaderElection = new ZkDistributedLeaderElection(_zkClient,\n         MetadataStoreRoutingConstants.LEADER_ELECTION_ZNODE, myServerInfo);\n+\n+    RequestConfig config = RequestConfig.custom()\n+        .setConnectTimeout(MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)\n+        .setConnectionRequestTimeout(\n+            MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)\n+        .setSocketTimeout(MetadataStoreRoutingConstants.HTTP_REQUEST_FORWARDING_TIMEOUT * 1000)", "originalCommit": "b8e14234b348fd4059a374468691d87d6a4a88b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc4ODE0OA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384788148", "bodyText": "Good point. Let me move the multiplication.", "author": "NealSun96", "createdAt": "2020-02-26T21:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NDE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NTYyOA==", "url": "https://github.com/apache/helix/pull/788#discussion_r384765628", "bodyText": "If you want these HTTP verbs included in MetadataStoreRoutingConstants , you could use a more generalized name like HttpVerbs.  HttpRequestForwardingVerbs if you want to keep it as an enum in this class.\nIf you want to generalize and put this in MetadataStoreRoutingConstants, then I'm pretty sure you could already find the supported HTTP verb enum somewhere defined in helix-rest module. Use that instead.", "author": "narendly", "createdAt": "2020-02-26T21:07:20Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -77,8 +106,11 @@ public synchronized boolean addMetadataStoreRealm(String realm) {\n       return createZkRealm(realm);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String urlSuffix =\n+        constructUrlSuffix(MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, realm);\n+    return forwardRequestToLeader(urlSuffix,\n+        MetadataStoreRoutingConstants.HttpRequestForwardingVerbs.PUT, \"addMetadataStoreRealm\",", "originalCommit": "b8e14234b348fd4059a374468691d87d6a4a88b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMjQzMQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384812431", "bodyText": "Created HttpConstants.RestVerbs in org.apache.helix.rest.common that serves the enum purpose.", "author": "NealSun96", "createdAt": "2020-02-26T22:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NTYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NjEwNQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384766105", "bodyText": "I still see a string literal here?", "author": "narendly", "createdAt": "2020-02-26T21:08:18Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -146,31 +152,15 @@ public synchronized boolean deleteShardingKey(String realm, String shardingKey)\n       if (_zkClient.isClosed()) {\n         throw new IllegalStateException(\"ZkClient is closed!\");\n       }\n-      ZNRecord znRecord =\n-          _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n-      if (znRecord == null || !znRecord\n-          .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .contains(shardingKey)) {\n-        // This realm does not exist or shardingKey doesn't exist. Return true!\n-        return true;\n-      }\n-      znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n-          .remove(shardingKey);\n-      // Overwrite this ZNRecord with the sharding key removed\n-      try {\n-        _zkClient\n-            .writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n-      } catch (Exception e) {\n-        LOG.error(\n-            \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n-            _namespace, realm, shardingKey, e);\n-        return false;\n-      }\n-      return true;\n+      return deleteZkShardingKey(realm, shardingKey);\n     }\n \n-    // TODO: Forward the request to leader\n-    return true;\n+    String urlSuffix =\n+        constructUrlSuffix(MetadataStoreRoutingConstants.MSDS_GET_ALL_REALMS_ENDPOINT, realm,\n+            MetadataStoreRoutingConstants.MSDS_GET_ALL_SHARDING_KEYS_ENDPOINT, shardingKey);\n+    return forwardRequestToLeader(urlSuffix,\n+        MetadataStoreRoutingConstants.HttpRequestForwardingVerbs.DELETE, \"deleteShardingKey\",", "originalCommit": "b8e14234b348fd4059a374468691d87d6a4a88b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgxMjgyNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384812826", "bodyText": "Removing this method name parameter altogether because it's better to use url to log. The url is more verbose.", "author": "NealSun96", "createdAt": "2020-02-26T22:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NjEwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NzI2OQ==", "url": "https://github.com/apache/helix/pull/788#discussion_r384767269", "bodyText": "Do not rely on this behavior. Let's make sure this method creates a valid URL. Would you be okay with this failing when we swap out the HTTP client we're using right now with a different one?\nDo you think making this assumption is hacky? Could we improve it?", "author": "narendly", "createdAt": "2020-02-26T21:10:28Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/accessor/ZkRoutingDataWriter.java", "diffHunk": "@@ -249,4 +244,126 @@ private boolean createZkRealm(String realm) {\n \n     return true;\n   }\n+\n+  protected boolean deleteZkRealm(String realm) {\n+    return _zkClient.delete(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm);\n+  }\n+\n+  protected boolean createZkShardingKey(String realm, String shardingKey) {\n+    // If the realm does not exist already, then create the realm\n+    String realmPath = MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm;\n+    if (!_zkClient.exists(realmPath)) {\n+      // Create the realm\n+      if (!createZkRealm(realm)) {\n+        // Failed to create the realm - log and return false\n+        LOG.error(\n+            \"Failed to add sharding key because ZkRealm creation failed! Namespace: {}, Realm: {}, Sharding key: {}\",\n+            _namespace, realm, shardingKey);\n+        return false;\n+      }\n+    }\n+\n+    ZNRecord znRecord;\n+    try {\n+      znRecord = _zkClient.readData(realmPath);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to read the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    List<String> shardingKeys =\n+        znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY);\n+    if (shardingKeys == null || shardingKeys.isEmpty()) {\n+      shardingKeys = new ArrayList<>();\n+    }\n+    shardingKeys.add(shardingKey);\n+    znRecord.setListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY, shardingKeys);\n+    try {\n+      _zkClient.writeData(realmPath, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the realm ZNRecord in addShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  protected boolean deleteZkShardingKey(String realm, String shardingKey) {\n+    ZNRecord znRecord =\n+        _zkClient.readData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, true);\n+    if (znRecord == null || !znRecord\n+        .getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .contains(shardingKey)) {\n+      // This realm does not exist or shardingKey doesn't exist. Return true!\n+      return true;\n+    }\n+    znRecord.getListField(MetadataStoreRoutingConstants.ZNRECORD_LIST_FIELD_KEY)\n+        .remove(shardingKey);\n+    // Overwrite this ZNRecord with the sharding key removed\n+    try {\n+      _zkClient.writeData(MetadataStoreRoutingConstants.ROUTING_DATA_PATH + \"/\" + realm, znRecord);\n+    } catch (Exception e) {\n+      LOG.error(\n+          \"Failed to write the data back in deleteShardingKey()! Namespace: {}, Realm: {}, ShardingKey: {}\",\n+          _namespace, realm, shardingKey, e);\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private String constructUrlSuffix(String... urlParams) {\n+    List<String> allUrlParameters = new ArrayList<>(\n+        Arrays.asList(MetadataStoreRoutingConstants.MSDS_NAMESPACES_URL_PREFIX, _namespace));\n+    allUrlParameters.addAll(Arrays.asList(urlParams));\n+    // HttpUriRequest will convert all double slashes to single slashes", "originalCommit": "b8e14234b348fd4059a374468691d87d6a4a88b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzNDc4Nw==", "url": "https://github.com/apache/helix/pull/788#discussion_r384834787", "bodyText": "We now take out all possible double slashes.", "author": "NealSun96", "createdAt": "2020-02-26T23:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NzI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Mzg4Mg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384773882", "bodyText": "If you want to do this, I think you could find HTTP verbs defined elsewhere already.", "author": "narendly", "createdAt": "2020-02-26T21:22:33Z", "path": "metadata-store-directory-common/src/main/java/org/apache/helix/msdcommon/constant/MetadataStoreRoutingConstants.java", "diffHunk": "@@ -20,6 +20,11 @@\n  */\n \n public class MetadataStoreRoutingConstants {\n+  public enum HttpRequestForwardingVerbs {", "originalCommit": "b8e14234b348fd4059a374468691d87d6a4a88b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7c3039213453521df2ad78afa27795e69e187dab", "url": "https://github.com/apache/helix/commit/7c3039213453521df2ad78afa27795e69e187dab", "message": "address remaining comments", "committedDate": "2020-02-27T00:00:39Z", "type": "commit"}, {"oid": "a4edecd6800350ac57f1d09c60f4d9fa36ab27c6", "url": "https://github.com/apache/helix/commit/a4edecd6800350ac57f1d09c60f4d9fa36ab27c6", "message": "move mock class", "committedDate": "2020-02-27T00:08:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg1OTUwNg==", "url": "https://github.com/apache/helix/pull/788#discussion_r384859506", "bodyText": "Remove empty line", "author": "narendly", "createdAt": "2020-02-27T01:05:25Z", "path": "helix-rest/src/main/java/org/apache/helix/rest/metadatastore/ZkMetadataStoreDirectory.java", "diffHunk": "@@ -42,49 +42,69 @@\n \n \n /**\n+ * NOTE: This is a singleton class. DO NOT EXTEND!\n  * ZK-based MetadataStoreDirectory that listens on the routing data in routing ZKs with a update\n  * callback.\n  */\n public class ZkMetadataStoreDirectory implements MetadataStoreDirectory, RoutingDataListener {\n   private static final Logger LOG = LoggerFactory.getLogger(ZkMetadataStoreDirectory.class);\n \n-  // TODO: enable the line below when implementation is complete\n   // The following maps' keys represent the namespace\n-  private final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n-  private final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n-  private final Map<String, MetadataStoreRoutingData> _routingDataMap;\n-  private final Map<String, String> _routingZkAddressMap;\n+  // NOTE: made protected for testing reasons. DO NOT MODIFY!\n+  protected final Map<String, MetadataStoreRoutingDataReader> _routingDataReaderMap;\n+  protected final Map<String, MetadataStoreRoutingDataWriter> _routingDataWriterMap;\n+  protected final Map<String, MetadataStoreRoutingData> _routingDataMap;\n+  protected final Map<String, String> _routingZkAddressMap;\n   // <namespace, <realm, <list of sharding keys>> mappings\n-  private final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+  protected final Map<String, Map<String, List<String>>> _realmToShardingKeysMap;\n+\n+  private static volatile ZkMetadataStoreDirectory _zkMetadataStoreDirectoryInstance;\n+\n+  public static ZkMetadataStoreDirectory getInstance() {\n+    if (_zkMetadataStoreDirectoryInstance == null) {\n+      synchronized (ZkMetadataStoreDirectory.class) {\n+        if (_zkMetadataStoreDirectoryInstance == null) {\n+          _zkMetadataStoreDirectoryInstance = new ZkMetadataStoreDirectory();\n+        }\n+      }\n+    }\n+", "originalCommit": "a4edecd6800350ac57f1d09c60f4d9fa36ab27c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a08279b6e6b2355be6f2e2b9a1f7f26f45d7779", "url": "https://github.com/apache/helix/commit/1a08279b6e6b2355be6f2e2b9a1f7f26f45d7779", "message": "remove empty line", "committedDate": "2020-02-27T01:16:08Z", "type": "commit"}]}