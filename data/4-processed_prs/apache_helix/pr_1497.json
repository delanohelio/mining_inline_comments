{"pr_number": 1497, "pr_title": "Fix TestRoutingTableProviderPeriodicRefresh.", "pr_createdAt": "2020-10-29T00:31:32Z", "pr_url": "https://github.com/apache/helix/pull/1497", "timeline": [{"oid": "71838107fc9878bd2a9311b35e6f4757046c5f10", "url": "https://github.com/apache/helix/commit/71838107fc9878bd2a9311b35e6f4757046c5f10", "message": "Fix TestRoutingTableProviderPeriodicRefresh.\n\nThe test was unstable and do not clean up the environment one the failure. This PR tolerates more test results to be accepted as good result.\nAlso enhance the clean up logic to prevent leakages.", "committedDate": "2020-10-29T00:26:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0MzczMg==", "url": "https://github.com/apache/helix/pull/1497#discussion_r513843732", "bodyText": "Could you elaborate on the reason of failure before? Is it because periodic refresh sometimes take a bit more than 1000, so it's possible that newRefreshCount == prevRefreshCount; or, is it because periodic refresh may take less time, so it's possible that newRefreshCount == prevRefreshCount + 2?", "author": "NealSun96", "createdAt": "2020-10-29T00:43:29Z", "path": "helix-core/src/test/java/org/apache/helix/integration/spectator/TestRoutingTableProviderPeriodicRefresh.java", "diffHunk": "@@ -203,34 +208,32 @@ synchronized int getRefreshCount() {\n \n   @Test\n   public void testPeriodicRefresh() throws InterruptedException {\n-    // Wait so that initial refreshes finish (not triggered by periodic refresh timer)\n-    Thread.sleep(1000L);\n+    // Wait to ensure that the initial refreshes finish (not triggered by periodic refresh timer)\n+    Thread.sleep(REFRESH_PERIOD_MS * 2);\n \n     // Test short refresh\n     int prevRefreshCount = _routingTableProvider.getRefreshCount();\n-    // Wait for one timer duration\n-    Thread.sleep(1000L);\n-    // The timer should have gone off, incrementing the refresh count\n-    Assert.assertEquals(_routingTableProvider.getRefreshCount(), prevRefreshCount + 1);", "originalCommit": "71838107fc9878bd2a9311b35e6f4757046c5f10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkyODg0MA==", "url": "https://github.com/apache/helix/pull/1497#discussion_r513928840", "bodyText": "I guess it is just because of some timing issues. When you set up a time window that equals the interval, you might have one or two refreshes happen.", "author": "jiajunwang", "createdAt": "2020-10-29T03:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0MzczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0Mzg1Ng==", "url": "https://github.com/apache/helix/pull/1497#discussion_r513843856", "bodyText": "While this eliminates flakiness, would it be too loose to ensure correctness?", "author": "NealSun96", "createdAt": "2020-10-29T00:43:58Z", "path": "helix-core/src/test/java/org/apache/helix/integration/spectator/TestRoutingTableProviderPeriodicRefresh.java", "diffHunk": "@@ -203,34 +208,32 @@ synchronized int getRefreshCount() {\n \n   @Test\n   public void testPeriodicRefresh() throws InterruptedException {\n-    // Wait so that initial refreshes finish (not triggered by periodic refresh timer)\n-    Thread.sleep(1000L);\n+    // Wait to ensure that the initial refreshes finish (not triggered by periodic refresh timer)\n+    Thread.sleep(REFRESH_PERIOD_MS * 2);\n \n     // Test short refresh\n     int prevRefreshCount = _routingTableProvider.getRefreshCount();\n-    // Wait for one timer duration\n-    Thread.sleep(1000L);\n-    // The timer should have gone off, incrementing the refresh count\n-    Assert.assertEquals(_routingTableProvider.getRefreshCount(), prevRefreshCount + 1);\n+    // Wait for more than one timer duration\n+    Thread.sleep((long) (REFRESH_PERIOD_MS * 1.5));\n+    // The timer should have gone off, incrementing the refresh count by one or two depends on the\n+    // timing.\n+    int newRefreshCount = _routingTableProvider.getRefreshCount();\n+    Assert.assertTrue(\n+        newRefreshCount == prevRefreshCount + 1 || newRefreshCount == prevRefreshCount + 2);", "originalCommit": "71838107fc9878bd2a9311b35e6f4757046c5f10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzkzMjY4Ng==", "url": "https://github.com/apache/helix/pull/1497#discussion_r513932686", "bodyText": "The java schedule task method that we are using is not accurate anyway. Moreover, the main test purpose here is to ensure the refresh happens. If it is faster a little bit, I guess we are still good.\nOn the other hand, if the refresh does respect the interval, so during 1.5 seconds, it happens more than 2 times, then the test will still fail.", "author": "jiajunwang", "createdAt": "2020-10-29T03:48:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0Mzg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQyOTkxMQ==", "url": "https://github.com/apache/helix/pull/1497#discussion_r514429911", "bodyText": "This comment is tied with my other comment. If we already know it's flaky between 1 or 2 refreshes, why don't we just assert(+1 || +2), while keeping sleep(1000)?\nIf we change it to sleep(1500), we are opening doors to \"slow refresh\" cases. If a refresh doesn't respect the refresh period, and instead took around 1500, the previous version of the test will catch it, but now it won't. Like you said, maybe even 1500 is fine since there is no hard requirement, we are just ensuring the refresh happens, but it feels to me that correctness check is relaxed.", "author": "NealSun96", "createdAt": "2020-10-29T17:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0Mzg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3NzY0NQ==", "url": "https://github.com/apache/helix/pull/1497#discussion_r514477645", "bodyText": "As I replied to Lei, this PR is not to improve the test. This is mainly for unblocking the other devs since the test cannot pass. Alternatively, we can disable it. But I prefer the current version. At least it checks some of the logic.\nWe will need to address this by re-writing the test logic.", "author": "jiajunwang", "createdAt": "2020-10-29T18:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0Mzg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDUyNDQ1Mw==", "url": "https://github.com/apache/helix/pull/1497#discussion_r514524453", "bodyText": "Talked offline: since periodic refresh can happen slightly less, equally, or slightly more frequent than the configured wait period, I agree with @jiajunwang 's change to use both sleep(1500) and assert(+1 || +2).", "author": "NealSun96", "createdAt": "2020-10-29T19:52:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg0Mzg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMzNjQ1Nw==", "url": "https://github.com/apache/helix/pull/1497#discussion_r514336457", "bodyText": "why 1000ms, could 500ms, or even 100ms work? That will reduce the test time.", "author": "lei-xia", "createdAt": "2020-10-29T15:11:28Z", "path": "helix-core/src/test/java/org/apache/helix/integration/spectator/TestRoutingTableProviderPeriodicRefresh.java", "diffHunk": "@@ -64,6 +62,8 @@\n   private static final int PARTITION_NUMBER = 20;\n   private static final int REPLICA_NUMBER = 3;\n \n+  private static final long REFRESH_PERIOD_MS = 1000L;", "originalCommit": "71838107fc9878bd2a9311b35e6f4757046c5f10", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ3NTk5OQ==", "url": "https://github.com/apache/helix/pull/1497#discussion_r514475999", "bodyText": "Works in theory. But I prefer to keep the main test logic the same. I don't have a strong motivation to optimize this test since as Kai mentioned, we shall rewrite it eventually. Just want to make it work first.", "author": "jiajunwang", "createdAt": "2020-10-29T18:25:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMzNjQ1Nw=="}], "type": "inlineReview"}]}