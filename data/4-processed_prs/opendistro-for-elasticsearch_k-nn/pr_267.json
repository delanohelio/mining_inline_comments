{"pr_number": 267, "pr_title": "Support for hamming bit distance in custom scoring", "pr_createdAt": "2020-11-12T07:07:36Z", "pr_url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267", "timeline": [{"oid": "cf42301256e83c8ecca3de27d816b80ee9a73766", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/cf42301256e83c8ecca3de27d816b80ee9a73766", "message": "initial changes to support hamming distance", "committedDate": "2020-10-08T00:31:25Z", "type": "commit"}, {"oid": "891a1705da026689644e6053ca6c30af49e3f6bf", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/891a1705da026689644e6053ca6c30af49e3f6bf", "message": "Rename", "committedDate": "2020-10-08T16:42:18Z", "type": "commit"}, {"oid": "af70594585896fbbaf12b4759c6ae7e7ddff1407", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/af70594585896fbbaf12b4759c6ae7e7ddff1407", "message": "update hamming distance to use BigInteger and hex_embeddings", "committedDate": "2020-10-08T16:43:33Z", "type": "commit"}, {"oid": "dccd9dede3afc8521f1a2ca20867be48accd9b4e", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/dccd9dede3afc8521f1a2ca20867be48accd9b4e", "message": "update hamming distance of base64 and long types", "committedDate": "2020-10-19T16:57:18Z", "type": "commit"}, {"oid": "1510bf076afed39aab3c1e5712f4b991ea41e9aa", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/1510bf076afed39aab3c1e5712f4b991ea41e9aa", "message": "a bit of refactoring of hamming distance", "committedDate": "2020-10-19T20:46:10Z", "type": "commit"}, {"oid": "96a2065366f3a46dc47748ffca1ba21df6015f94", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/96a2065366f3a46dc47748ffca1ba21df6015f94", "message": "cast to correct ScriptDocValues", "committedDate": "2020-10-23T17:43:42Z", "type": "commit"}, {"oid": "44f8036024094cb51e1f6b4c4a42add8e8fa2c53", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/44f8036024094cb51e1f6b4c4a42add8e8fa2c53", "message": "Merge branch 'master' of github.com:opendistro-for-elasticsearch/k-NN into hamming-support", "committedDate": "2020-10-23T17:47:18Z", "type": "commit"}, {"oid": "9ea4288752a74622407630b02d13a2f0b573ed3e", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/9ea4288752a74622407630b02d13a2f0b573ed3e", "message": "refactor scoring for hamming distance", "committedDate": "2020-11-05T22:50:10Z", "type": "commit"}, {"oid": "01611e17a1d850c2bc38e032d6410d93a6402406", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/01611e17a1d850c2bc38e032d6410d93a6402406", "message": "Refactor scoring logic to couple script logic only with doc values type", "committedDate": "2020-11-07T00:12:54Z", "type": "commit"}, {"oid": "174f38762a69ad3c4e9a48c7fa645298de4bfbbd", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/174f38762a69ad3c4e9a48c7fa645298de4bfbbd", "message": "add back binary encoding for hamming distance", "committedDate": "2020-11-07T00:51:05Z", "type": "commit"}, {"oid": "7647c40a79e304a951f62a0880d52b88b5fbf396", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/7647c40a79e304a951f62a0880d52b88b5fbf396", "message": "code cleanup", "committedDate": "2020-11-10T19:22:29Z", "type": "commit"}, {"oid": "ffd78da58432a59757fbc746170f5b5a59c05a15", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/ffd78da58432a59757fbc746170f5b5a59c05a15", "message": "revert list long to long", "committedDate": "2020-11-11T19:24:55Z", "type": "commit"}, {"oid": "89d28c53208c4c0d3e0669f3c62627d844bafda2", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/89d28c53208c4c0d3e0669f3c62627d844bafda2", "message": "remove log statements", "committedDate": "2020-11-11T19:35:54Z", "type": "commit"}, {"oid": "a1db15a66ed45b8738cc5c92070ef833335e5418", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/a1db15a66ed45b8738cc5c92070ef833335e5418", "message": "rename classes", "committedDate": "2020-11-11T21:16:52Z", "type": "commit"}, {"oid": "700f4939bce93a04a6b3eecc303055e9c9f31f6e", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/700f4939bce93a04a6b3eecc303055e9c9f31f6e", "message": "rename scripts -> script for tests", "committedDate": "2020-11-12T00:29:27Z", "type": "commit"}, {"oid": "1f189991feeed9bfe6edbe9a6cd416785fbf95ba", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/1f189991feeed9bfe6edbe9a6cd416785fbf95ba", "message": "intial commit for testing hamming", "committedDate": "2020-11-12T00:30:07Z", "type": "commit"}, {"oid": "4069e966ab3356f407d7ae7b0ba776e64d411be6", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/4069e966ab3356f407d7ae7b0ba776e64d411be6", "message": "minor formatting change", "committedDate": "2020-11-12T04:01:31Z", "type": "commit"}, {"oid": "bfca4cf1580a2c23a1b2f16697d1b8ea3579187a", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/bfca4cf1580a2c23a1b2f16697d1b8ea3579187a", "message": "add more test cases for hamming distance support", "committedDate": "2020-11-12T06:34:55Z", "type": "commit"}, {"oid": "413c3272c31d4344ea0c16ea1b209fe1e3222259", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/413c3272c31d4344ea0c16ea1b209fe1e3222259", "message": "remove unused constants", "committedDate": "2020-11-12T17:40:09Z", "type": "commit"}, {"oid": "9cb28bf738d1512357ba7af09c46f66d064689c9", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/9cb28bf738d1512357ba7af09c46f66d064689c9", "message": "stylistic fixes", "committedDate": "2020-11-12T17:40:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNzE5MA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522317190", "bodyText": "may be LongType?", "author": "VijayanB", "createdAt": "2020-11-12T18:17:24Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoreScript.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.BinaryDocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.UncheckedIOException;\n+import java.util.BitSet;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+/**\n+ * KNNScoreScript is used for adjusting the score of query results based on similarity distance methods. Scripts\n+ * operate on a per document basis. Because the scoring method is passed in during construction, KNNScoreScripts are\n+ * only concerned with the types of the query and docs being processed.\n+ */\n+public abstract class KNNScoreScript<T> extends ScoreScript {\n+    protected final T queryValue;\n+    protected final String field;\n+    protected final BiFunction<T, T, Float> scoringMethod;\n+\n+    public KNNScoreScript(Map<String, Object> params, T queryValue, String field,\n+                          BiFunction<T, T, Float> scoringMethod, SearchLookup lookup, LeafReaderContext leafContext) {\n+        super(params, lookup, leafContext);\n+        this.queryValue = queryValue;\n+        this.field = field;\n+        this.scoringMethod = scoringMethod;\n+    }\n+\n+    /**\n+     * KNNScoreScript with Long type. The query value passed in as well as the DocValues being searched over are\n+     * expected to be Longs.\n+     */\n+    public static class Longs extends KNNScoreScript<Long> {", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2MzY0Ng==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522563646", "bodyText": "Yes, I think that makes sense. Will update.", "author": "jmazanec15", "createdAt": "2020-11-13T02:08:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNzE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNzIzMw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522317233", "bodyText": "Q: cosinesimil is one word without underscore while bit_hamming is not, so any reason why it is different from cosinesimil?", "author": "VijayanB", "createdAt": "2020-11-12T18:17:28Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/index/util/KNNConstants.java", "diffHunk": "@@ -23,5 +23,6 @@\n     public static final String HNSW_ALGO_INDEX_THREAD_QTY = \"indexThreadQty\";\n     public static final String L2 = \"l2\";\n     public static final String COSINESIMIL = \"cosinesimil\";\n+    public static final String BIT_HAMMING = \"bit_hamming\";", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2MzM2Ng==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522563366", "bodyText": "Good catch. I will change to bithamming.", "author": "jmazanec15", "createdAt": "2020-11-13T02:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNzIzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxODIwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522318209", "bodyText": "same as above", "author": "VijayanB", "createdAt": "2020-11-12T18:19:01Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoreScript.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.BinaryDocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.UncheckedIOException;\n+import java.util.BitSet;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+/**\n+ * KNNScoreScript is used for adjusting the score of query results based on similarity distance methods. Scripts\n+ * operate on a per document basis. Because the scoring method is passed in during construction, KNNScoreScripts are\n+ * only concerned with the types of the query and docs being processed.\n+ */\n+public abstract class KNNScoreScript<T> extends ScoreScript {\n+    protected final T queryValue;\n+    protected final String field;\n+    protected final BiFunction<T, T, Float> scoringMethod;\n+\n+    public KNNScoreScript(Map<String, Object> params, T queryValue, String field,\n+                          BiFunction<T, T, Float> scoringMethod, SearchLookup lookup, LeafReaderContext leafContext) {\n+        super(params, lookup, leafContext);\n+        this.queryValue = queryValue;\n+        this.field = field;\n+        this.scoringMethod = scoringMethod;\n+    }\n+\n+    /**\n+     * KNNScoreScript with Long type. The query value passed in as well as the DocValues being searched over are\n+     * expected to be Longs.\n+     */\n+    public static class Longs extends KNNScoreScript<Long> {\n+        /**\n+         * This function calculates the similarity score for each doc in the segment.\n+         *\n+         * @param explanationHolder A helper to take in an explanation from a script and turn\n+         *                          it into an {@link org.apache.lucene.search.Explanation}\n+         * @return score for the provided space between the doc and the query\n+         */\n+        @Override\n+        public double execute(ScoreScript.ExplanationHolder explanationHolder) {\n+            ScriptDocValues.Longs scriptDocValues = (ScriptDocValues.Longs) getDoc().get(this.field);\n+            if (scriptDocValues.size() == 0) {\n+                return Float.MIN_VALUE;\n+            }\n+            return this.scoringMethod.apply(this.queryValue, scriptDocValues.getValue());\n+        }\n+\n+        public Longs(Map<String, Object> params, Long queryValue, String field,\n+                    BiFunction<Long, Long, Float> scoringMethod, SearchLookup lookup, LeafReaderContext leafContext) {\n+            super(params, queryValue, field, scoringMethod, lookup, leafContext);\n+        }\n+    }\n+\n+    /**\n+     * KNNScoreScript with BitSet type. The query value passed in as well as the DocValues being searched over\n+     * are expected to be BitSets.\n+     */\n+    public static class BitSets extends KNNScoreScript<BitSet> {", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2Mzc0NA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522563744", "bodyText": "ack", "author": "jmazanec15", "createdAt": "2020-11-13T02:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxODIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzMDEyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522330121", "bodyText": "It is always better to  do constant.equalsIgnoreCase(variable) to avoid null pointer exception.", "author": "VijayanB", "createdAt": "2020-11-12T18:38:20Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoringSpaceFactory.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.index.util.KNNConstants;\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+/**\n+ * Factory to create correct KNNScoringSpace based on the spaceType passed in.\n+ */\n+public class KNNScoringSpaceFactory {\n+    public static KNNScoringSpace getSpace(String spaceType, Object query, MappedFieldType mappedFieldType) {\n+        if (spaceType.equalsIgnoreCase(KNNConstants.BIT_HAMMING)) {", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2OTY5NQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522569695", "bodyText": "Good catch. Will fix", "author": "jmazanec15", "createdAt": "2020-11-13T02:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzMDEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzMDY4MA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522330680", "bodyText": "Also you don't need else if, since you are returning inside if.", "author": "VijayanB", "createdAt": "2020-11-12T18:39:17Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoringSpaceFactory.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.index.util.KNNConstants;\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+/**\n+ * Factory to create correct KNNScoringSpace based on the spaceType passed in.\n+ */\n+public class KNNScoringSpaceFactory {\n+    public static KNNScoringSpace getSpace(String spaceType, Object query, MappedFieldType mappedFieldType) {\n+        if (spaceType.equalsIgnoreCase(KNNConstants.BIT_HAMMING)) {", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2OTY2Mw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522569663", "bodyText": "Makes sense", "author": "jmazanec15", "createdAt": "2020-11-13T02:20:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzMDY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNDE4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522334187", "bodyText": "calculateHammingDistance?", "author": "VijayanB", "createdAt": "2020-11-12T18:44:56Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoringUtil.java", "diffHunk": "@@ -73,6 +89,30 @@ public static float cosinesimil(float[] queryVector, float[] inputVector) {\n         return (float) (dotProduct / (Math.sqrt(normalizedProduct)));\n     }\n \n+\n+    /**\n+     * This method calculates hamming distance on 2 BitSets\n+     *\n+     * @param queryBits query BitSet\n+     * @param inputBits input BitSet\n+     * @return hamming distance\n+     */\n+    public static float bitHamming(BitSet queryBits, BitSet inputBits) {\n+        inputBits.xor(queryBits);\n+        return inputBits.cardinality();\n+    }\n+\n+    /**\n+     * This method calculates hamming distance on 2 longs\n+     *\n+     * @param queryLong query Long\n+     * @param inputLong input Long\n+     * @return hamming distance\n+     */\n+    public static float bitHamming(Long queryLong, Long inputLong) {", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2OTYwNg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522569606", "bodyText": "Makes sense, will update", "author": "jmazanec15", "createdAt": "2020-11-13T02:20:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNDE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNTcxMg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522335712", "bodyText": "do we need assert here? method says Add a single numeric field Doc to an index. If it is part of test method, may be we can assert inside actual test method instead of helper method. What do you think?", "author": "VijayanB", "createdAt": "2020-11-12T18:47:28Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/knn/KNNRestTestCase.java", "diffHunk": "@@ -356,6 +356,28 @@ protected void addDocWithNumericField(String index, String docId, String fieldNa\n                 RestStatus.fromCode(response.getStatusLine().getStatusCode()));\n     }\n \n+    /**\n+     * Add a single numeric field Doc to an index\n+     */\n+    protected void addDocWithBinaryField(String index, String docId, String fieldName, String base64String)\n+            throws IOException {\n+        Request request = new Request(\n+                \"POST\",\n+                \"/\" + index + \"/_doc/\" + docId + \"?refresh=true\"\n+        );\n+\n+        XContentBuilder builder = XContentFactory.jsonBuilder().startObject()\n+                .field(fieldName, base64String)\n+                .endObject();\n+\n+        request.setJsonEntity(Strings.toString(builder));\n+\n+        Response response = client().performRequest(request);\n+\n+        assertEquals(request.getEndpoint() + \": failed\", RestStatus.CREATED,", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2OTMyMg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522569322", "bodyText": "I left the assert in this function because the test methods are not actually testing this functionality. The test methods are expecting this functionality to work, so I included it in here. Do you think it would be better practice to return the response and check it in the tests?", "author": "jmazanec15", "createdAt": "2020-11-13T02:19:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNTcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE1NDQ5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r523154491", "bodyText": "I am not sure what is the convention, in my opinion, it will be clear to differentiate testing vs helping method for maintenance.", "author": "VijayanB", "createdAt": "2020-11-13T18:43:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNTcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUxNjAyMA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r524516020", "bodyText": "I think some of our other methods in this test case follow this convention. I think, to stay on track for this PR, we follow this convention. And, if we decide that we need to refactor testing logic, we take up another PR for it.", "author": "jmazanec15", "createdAt": "2020-11-16T19:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNTcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNzg5Mg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522337892", "bodyText": "is it possible to refer from constant?", "author": "VijayanB", "createdAt": "2020-11-12T18:51:04Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/knn/KNNRestTestCase.java", "diffHunk": "@@ -572,4 +594,26 @@ protected Request constructKNNScriptQueryRequest(String indexName, QueryBuilder\n         request.setJsonEntity(Strings.toString(builder));\n         return request;\n     }\n+\n+    protected Request constructKNNScriptQueryRequest(String indexName, QueryBuilder qb, Map<String, Object> params,\n+                                                     int size) throws Exception {\n+        Script script = new Script(Script.DEFAULT_SCRIPT_TYPE, KNNScoringScriptEngine.NAME, KNNScoringScriptEngine.SCRIPT_SOURCE, params);\n+        ScriptScoreQueryBuilder sc = new ScriptScoreQueryBuilder(qb, script);\n+        XContentBuilder builder = XContentFactory.jsonBuilder().startObject()\n+                .field(\"size\", size)\n+                .startObject(\"query\");\n+        builder.startObject(\"script_score\");", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3NDU1MA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522574550", "bodyText": "This is a part of Elasticsearch Query DSL. I couldnt find a constant I could refer to for this.", "author": "jmazanec15", "createdAt": "2020-11-13T02:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMzNzg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MjAxOA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522342018", "bodyText": "no need of else if since you are returning inside if.", "author": "VijayanB", "createdAt": "2020-11-12T18:57:54Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoringSpace.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.index.KNNVectorFieldMapper;\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.mapper.BinaryFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.BitSet;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.index.mapper.NumberFieldMapper.NumberType.LONG;\n+\n+/**\n+ * KNNScoringSpace is used to validate/prepare a user provided query and similarity space for knn scripting execution\n+ * and provide the correct KNNScoringScript.\n+ */\n+public abstract class KNNScoringSpace {\n+\n+    protected Object processedQuery;\n+    protected BiFunction<?, ?, Float> scoringMethod;\n+    protected MappedFieldType fieldType;\n+\n+    public KNNScoringSpace(Object query, MappedFieldType fieldType) {\n+        this.fieldType = fieldType;\n+        prepareQuery(query);\n+    }\n+\n+    /**\n+     * Prepare the query and the scoring method for the given FieldType and similarity space. When preparing these\n+     * properties, the fieldType and the spaceType will dictate if they are validated and how they are processed. This\n+     * method has the responsibility of ensuring that the query and scoring method that will be used when scoring the\n+     * docs in an index is compatible.\n+     *\n+     * @param query Raw query object passed in to be validated and processed for the given similarity space\n+     */\n+    protected abstract void prepareQuery(Object query);\n+\n+    protected boolean isLongFieldType(MappedFieldType fieldType) {\n+        return fieldType instanceof NumberFieldMapper.NumberFieldType\n+                && ((NumberFieldMapper.NumberFieldType) fieldType).numericType() == LONG.numericType();\n+    }\n+\n+    protected boolean isBinaryFieldType(MappedFieldType fieldType) {\n+        return fieldType instanceof BinaryFieldMapper.BinaryFieldType;\n+    }\n+\n+    protected boolean isKNNVectorFieldType(MappedFieldType fieldType) {\n+        return fieldType instanceof KNNVectorFieldMapper.KNNVectorFieldType;\n+    }\n+\n+    protected Long parseLongQuery(Object query) {\n+        /*\n+         * Because there is no way to specify the type of integral that is passed in during query, it is necessary to\n+         * cast it to a Long here.\n+         */\n+        Long processedQueryLong;\n+        if (query instanceof Integer) {\n+            processedQueryLong = Long.valueOf((Integer) query);\n+        } else if (query instanceof Long) {\n+            processedQueryLong = (Long) query;\n+        } else {\n+            throw new IllegalArgumentException(\"Incompatible query_value for hamming space. query_value must \" +\n+                    \"be either a Long or an Integer.\");\n+        }\n+\n+        return processedQueryLong;\n+    }\n+\n+    protected BitSet parseBinaryQuery(Object query) {\n+        return BitSet.valueOf(Base64.getDecoder().decode((String) query));\n+    }\n+\n+    protected float[] parseKNNVectorQuery(Object query) {\n+        float[] parsedQuery = KNNScoringUtil.convertVectorToPrimitive(query);\n+        if (((KNNVectorFieldMapper.KNNVectorFieldType) fieldType).getDimension() != parsedQuery.length) {\n+            KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+            throw new IllegalStateException(\"[KNN] query vector and field vector dimensions mismatch. \" +\n+                    \"query vector: \" + parsedQuery.length + \", stored vector: \" +\n+                    ((KNNVectorFieldMapper.KNNVectorFieldType) fieldType).getDimension());\n+        }\n+        return parsedQuery;\n+    }\n+\n+    /**\n+     * Return the correct scoring script for a given query. The scoring script\n+     *\n+     * @param params Map of parameters\n+     * @param field Fieldname\n+     * @param lookup SearchLookup\n+     * @param ctx ctx LeafReaderContext to be used for scoring documents\n+     * @return ScoreScript for this query\n+     * @throws IOException throws IOException if ScoreScript cannot be constructed\n+     */\n+    public abstract ScoreScript getScoreScript(Map<String, Object> params, String field, SearchLookup lookup,\n+                                               LeafReaderContext ctx) throws IOException;\n+\n+    public static class L2 extends KNNScoringSpace {\n+\n+        public L2(Object query, MappedFieldType fieldType) {\n+            super(query, fieldType);\n+        }\n+\n+        @Override\n+        protected void prepareQuery(Object query) {\n+            if (!isKNNVectorFieldType(fieldType)) {\n+                throw new IllegalArgumentException(\"Incompatible field_type for l2 space. The field type must \" +\n+                        \"be knn_vector.\");\n+            }\n+\n+            this.processedQuery = parseKNNVectorQuery(query);\n+            this.scoringMethod = (float[] q, float[] v) -> 1 / (1 + KNNScoringUtil.l2Squared(q, v));\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public ScoreScript getScoreScript(Map<String, Object> params, String field, SearchLookup lookup,\n+                                          LeafReaderContext ctx) throws IOException {\n+            return new KNNScoreScript.KNNVectors(params, (float[]) processedQuery, field,\n+                    (BiFunction<float[], float[], Float>) this.scoringMethod, lookup, ctx);\n+\n+        }\n+    }\n+\n+    public static class CosineSimilarity extends KNNScoringSpace {\n+\n+        public CosineSimilarity(Object query, MappedFieldType fieldType) {\n+            super(query, fieldType);\n+        }\n+\n+        @Override\n+        protected void prepareQuery(Object query) {\n+            if (!(fieldType instanceof KNNVectorFieldMapper.KNNVectorFieldType)) {\n+                throw new IllegalArgumentException(\"Incompatible field_type for cosine space. The field type must \" +\n+                        \"be knn_vector.\");\n+            }\n+\n+            this.processedQuery = parseKNNVectorQuery(query);\n+            float qVectorSquaredMagnitude = KNNScoringUtil.getVectorMagnitudeSquared((float[]) this.processedQuery);\n+            this.scoringMethod = (float[] q, float[] v) -> 1 + KNNScoringUtil.cosinesimilOptimized(q, v,\n+                    qVectorSquaredMagnitude);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public ScoreScript getScoreScript(Map<String, Object> params, String field, SearchLookup lookup,\n+                                          LeafReaderContext ctx) throws IOException {\n+                return new KNNScoreScript.KNNVectors(params, (float[]) processedQuery, field,\n+                        (BiFunction<float[], float[], Float>) this.scoringMethod, lookup, ctx);\n+        }\n+    }\n+\n+    public static class HammingBit extends KNNScoringSpace {\n+        public HammingBit(Object query, MappedFieldType fieldType) {\n+            super(query, fieldType);\n+        }\n+\n+        @Override\n+        protected void prepareQuery(Object query) {\n+            if (isLongFieldType(fieldType)) {\n+                this.processedQuery = parseLongQuery(query);\n+                this.scoringMethod = (Long q, Long v) -> 1.0f / (1 + KNNScoringUtil.bitHamming(q, v));\n+            } else if (isBinaryFieldType(fieldType)) {\n+                this.processedQuery = parseBinaryQuery(query);\n+                this.scoringMethod = (BitSet q, BitSet v) -> 1.0f / (1 + KNNScoringUtil.bitHamming(q, v));\n+            } else {\n+                throw new IllegalArgumentException(\"Incompatible field_type for hamming space. The field type must \" +\n+                        \"of type long or binary.\");\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public ScoreScript getScoreScript(Map<String, Object> params, String field, SearchLookup lookup,\n+                                          LeafReaderContext ctx) throws IOException {\n+            if (isLongFieldType(fieldType)) {", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2OTgxNw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522569817", "bodyText": "Makes sense. Will update", "author": "jmazanec15", "createdAt": "2020-11-13T02:21:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MjAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MzY0NA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522343644", "bodyText": "I believe L2 is Euclidean distance, may be name class as Euclidean?", "author": "VijayanB", "createdAt": "2020-11-12T19:00:37Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoringSpace.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.index.KNNVectorFieldMapper;\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.mapper.BinaryFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.BitSet;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.index.mapper.NumberFieldMapper.NumberType.LONG;\n+\n+/**\n+ * KNNScoringSpace is used to validate/prepare a user provided query and similarity space for knn scripting execution\n+ * and provide the correct KNNScoringScript.\n+ */\n+public abstract class KNNScoringSpace {\n+\n+    protected Object processedQuery;\n+    protected BiFunction<?, ?, Float> scoringMethod;\n+    protected MappedFieldType fieldType;\n+\n+    public KNNScoringSpace(Object query, MappedFieldType fieldType) {\n+        this.fieldType = fieldType;\n+        prepareQuery(query);\n+    }\n+\n+    /**\n+     * Prepare the query and the scoring method for the given FieldType and similarity space. When preparing these\n+     * properties, the fieldType and the spaceType will dictate if they are validated and how they are processed. This\n+     * method has the responsibility of ensuring that the query and scoring method that will be used when scoring the\n+     * docs in an index is compatible.\n+     *\n+     * @param query Raw query object passed in to be validated and processed for the given similarity space\n+     */\n+    protected abstract void prepareQuery(Object query);\n+\n+    protected boolean isLongFieldType(MappedFieldType fieldType) {\n+        return fieldType instanceof NumberFieldMapper.NumberFieldType\n+                && ((NumberFieldMapper.NumberFieldType) fieldType).numericType() == LONG.numericType();\n+    }\n+\n+    protected boolean isBinaryFieldType(MappedFieldType fieldType) {\n+        return fieldType instanceof BinaryFieldMapper.BinaryFieldType;\n+    }\n+\n+    protected boolean isKNNVectorFieldType(MappedFieldType fieldType) {\n+        return fieldType instanceof KNNVectorFieldMapper.KNNVectorFieldType;\n+    }\n+\n+    protected Long parseLongQuery(Object query) {\n+        /*\n+         * Because there is no way to specify the type of integral that is passed in during query, it is necessary to\n+         * cast it to a Long here.\n+         */\n+        Long processedQueryLong;\n+        if (query instanceof Integer) {\n+            processedQueryLong = Long.valueOf((Integer) query);\n+        } else if (query instanceof Long) {\n+            processedQueryLong = (Long) query;\n+        } else {\n+            throw new IllegalArgumentException(\"Incompatible query_value for hamming space. query_value must \" +\n+                    \"be either a Long or an Integer.\");\n+        }\n+\n+        return processedQueryLong;\n+    }\n+\n+    protected BitSet parseBinaryQuery(Object query) {\n+        return BitSet.valueOf(Base64.getDecoder().decode((String) query));\n+    }\n+\n+    protected float[] parseKNNVectorQuery(Object query) {\n+        float[] parsedQuery = KNNScoringUtil.convertVectorToPrimitive(query);\n+        if (((KNNVectorFieldMapper.KNNVectorFieldType) fieldType).getDimension() != parsedQuery.length) {\n+            KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+            throw new IllegalStateException(\"[KNN] query vector and field vector dimensions mismatch. \" +\n+                    \"query vector: \" + parsedQuery.length + \", stored vector: \" +\n+                    ((KNNVectorFieldMapper.KNNVectorFieldType) fieldType).getDimension());\n+        }\n+        return parsedQuery;\n+    }\n+\n+    /**\n+     * Return the correct scoring script for a given query. The scoring script\n+     *\n+     * @param params Map of parameters\n+     * @param field Fieldname\n+     * @param lookup SearchLookup\n+     * @param ctx ctx LeafReaderContext to be used for scoring documents\n+     * @return ScoreScript for this query\n+     * @throws IOException throws IOException if ScoreScript cannot be constructed\n+     */\n+    public abstract ScoreScript getScoreScript(Map<String, Object> params, String field, SearchLookup lookup,\n+                                               LeafReaderContext ctx) throws IOException;\n+\n+    public static class L2 extends KNNScoringSpace {", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3MDYyNw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522570627", "bodyText": "I think we should keep as L2 because thats how we refer to it in user facing APIs. Additionally, nmslib refers to it as L2, so I think we should maintain consistency.", "author": "jmazanec15", "createdAt": "2020-11-13T02:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MzY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE1NTMzNQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r523155335", "bodyText": "got it. i was concerned about having a class name with two characters. If it makes sense, i totally agree. Also, what do you think about L2ScoringSpace / CosineSimilarityScoringSpace ?", "author": "VijayanB", "createdAt": "2020-11-13T18:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MzY0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1MzA2NQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r524453065", "bodyText": "I decided not to add ScoringSpace to the end to remove redundancy. For instance, when using it in the ScoringSpaceFactory, the call looks like KNNScoringSpace.HammingBit. I thought this was more concise and cleaner than doing KNNScoringSpace.HammingBitScoringSpace. What are your thoughts?", "author": "jmazanec15", "createdAt": "2020-11-16T17:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0MzY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3Mzk3Mw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522373973", "bodyText": "why isLongFieldType/isBinaryFieldType/isKNNVectorFieldType are protected?", "author": "VijayanB", "createdAt": "2020-11-12T19:40:54Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoringSpace.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.index.KNNVectorFieldMapper;\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.mapper.BinaryFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.BitSet;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.index.mapper.NumberFieldMapper.NumberType.LONG;\n+\n+/**\n+ * KNNScoringSpace is used to validate/prepare a user provided query and similarity space for knn scripting execution\n+ * and provide the correct KNNScoringScript.\n+ */\n+public abstract class KNNScoringSpace {\n+\n+    protected Object processedQuery;\n+    protected BiFunction<?, ?, Float> scoringMethod;\n+    protected MappedFieldType fieldType;\n+\n+    public KNNScoringSpace(Object query, MappedFieldType fieldType) {\n+        this.fieldType = fieldType;\n+        prepareQuery(query);\n+    }\n+\n+    /**\n+     * Prepare the query and the scoring method for the given FieldType and similarity space. When preparing these\n+     * properties, the fieldType and the spaceType will dictate if they are validated and how they are processed. This\n+     * method has the responsibility of ensuring that the query and scoring method that will be used when scoring the\n+     * docs in an index is compatible.\n+     *\n+     * @param query Raw query object passed in to be validated and processed for the given similarity space\n+     */\n+    protected abstract void prepareQuery(Object query);\n+\n+    protected boolean isLongFieldType(MappedFieldType fieldType) {", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3MTExNQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522571115", "bodyText": "My intention was to allow subclasses to utilize these methods, while preventing them from being used outside of the class. Do you think they should have a different access modifier?", "author": "jmazanec15", "createdAt": "2020-11-13T02:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3Mzk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3Nzk0Nw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522377947", "bodyText": "why not make processedQuery as method and do validation inside it? it is kind of dangerous to call protected method inside constructor because you are calling an instance method before creating an instance.\nIMO, KNNScoringSpace can be made interface and make helper method in a different class.", "author": "VijayanB", "createdAt": "2020-11-12T19:47:31Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoringSpace.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.index.KNNVectorFieldMapper;\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.mapper.BinaryFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.BitSet;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.index.mapper.NumberFieldMapper.NumberType.LONG;\n+\n+/**\n+ * KNNScoringSpace is used to validate/prepare a user provided query and similarity space for knn scripting execution\n+ * and provide the correct KNNScoringScript.\n+ */\n+public abstract class KNNScoringSpace {\n+\n+    protected Object processedQuery;", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3NzgyMA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522577820", "bodyText": "Agree with first point.\nFor second point, could you explain more why you think that?", "author": "jmazanec15", "createdAt": "2020-11-13T02:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3Nzk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE1ODYwMA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r523158600", "bodyText": "Generally subclass are used when it naturally depicts parent -> child relationship where there are logics which are common to be inherited and some to be overridden.  Here, there is no strategy/algorithm that is common while child class can behave differently. I only see some helper methods that will be used by child class and the common method(getScoreScript) which will be called by outside is abstract.  Also, any reason why made L2/Hamming as inner class ? Interface is preferred if intention is that L2ScoringSpace/BitHammingScoringSpace are all ScoringSpace.\nDid i convince you?", "author": "VijayanB", "createdAt": "2020-11-13T18:51:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3Nzk0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1NzY4OA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r524457688", "bodyText": "Yes, I think you did. I will update to use an interface.", "author": "jmazanec15", "createdAt": "2020-11-16T17:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM3Nzk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4NDUwMw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522384503", "bodyText": "may be createScoringSpace or create instead of get?", "author": "VijayanB", "createdAt": "2020-11-12T19:58:43Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoringSpaceFactory.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.index.util.KNNConstants;\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+\n+/**\n+ * Factory to create correct KNNScoringSpace based on the spaceType passed in.\n+ */\n+public class KNNScoringSpaceFactory {\n+    public static KNNScoringSpace getSpace(String spaceType, Object query, MappedFieldType mappedFieldType) {", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU2OTc1Mg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522569752", "bodyText": "Makes sense. Will update.", "author": "jmazanec15", "createdAt": "2020-11-13T02:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4NDUwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4NjI3Mg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522386272", "bodyText": "is this even required since the fieldType is already tested in parseQuery?", "author": "VijayanB", "createdAt": "2020-11-12T20:01:23Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoringSpace.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.index.KNNVectorFieldMapper;\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.index.mapper.BinaryFieldMapper;\n+import org.elasticsearch.index.mapper.MappedFieldType;\n+import org.elasticsearch.index.mapper.NumberFieldMapper;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.BitSet;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+import static org.elasticsearch.index.mapper.NumberFieldMapper.NumberType.LONG;\n+\n+/**\n+ * KNNScoringSpace is used to validate/prepare a user provided query and similarity space for knn scripting execution\n+ * and provide the correct KNNScoringScript.\n+ */\n+public abstract class KNNScoringSpace {\n+\n+    protected Object processedQuery;\n+    protected BiFunction<?, ?, Float> scoringMethod;\n+    protected MappedFieldType fieldType;\n+\n+    public KNNScoringSpace(Object query, MappedFieldType fieldType) {\n+        this.fieldType = fieldType;\n+        prepareQuery(query);\n+    }\n+\n+    /**\n+     * Prepare the query and the scoring method for the given FieldType and similarity space. When preparing these\n+     * properties, the fieldType and the spaceType will dictate if they are validated and how they are processed. This\n+     * method has the responsibility of ensuring that the query and scoring method that will be used when scoring the\n+     * docs in an index is compatible.\n+     *\n+     * @param query Raw query object passed in to be validated and processed for the given similarity space\n+     */\n+    protected abstract void prepareQuery(Object query);\n+\n+    protected boolean isLongFieldType(MappedFieldType fieldType) {\n+        return fieldType instanceof NumberFieldMapper.NumberFieldType\n+                && ((NumberFieldMapper.NumberFieldType) fieldType).numericType() == LONG.numericType();\n+    }\n+\n+    protected boolean isBinaryFieldType(MappedFieldType fieldType) {\n+        return fieldType instanceof BinaryFieldMapper.BinaryFieldType;\n+    }\n+\n+    protected boolean isKNNVectorFieldType(MappedFieldType fieldType) {\n+        return fieldType instanceof KNNVectorFieldMapper.KNNVectorFieldType;\n+    }\n+\n+    protected Long parseLongQuery(Object query) {\n+        /*\n+         * Because there is no way to specify the type of integral that is passed in during query, it is necessary to\n+         * cast it to a Long here.\n+         */\n+        Long processedQueryLong;\n+        if (query instanceof Integer) {\n+            processedQueryLong = Long.valueOf((Integer) query);\n+        } else if (query instanceof Long) {\n+            processedQueryLong = (Long) query;\n+        } else {\n+            throw new IllegalArgumentException(\"Incompatible query_value for hamming space. query_value must \" +\n+                    \"be either a Long or an Integer.\");\n+        }\n+\n+        return processedQueryLong;\n+    }\n+\n+    protected BitSet parseBinaryQuery(Object query) {\n+        return BitSet.valueOf(Base64.getDecoder().decode((String) query));\n+    }\n+\n+    protected float[] parseKNNVectorQuery(Object query) {\n+        float[] parsedQuery = KNNScoringUtil.convertVectorToPrimitive(query);\n+        if (((KNNVectorFieldMapper.KNNVectorFieldType) fieldType).getDimension() != parsedQuery.length) {\n+            KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+            throw new IllegalStateException(\"[KNN] query vector and field vector dimensions mismatch. \" +\n+                    \"query vector: \" + parsedQuery.length + \", stored vector: \" +\n+                    ((KNNVectorFieldMapper.KNNVectorFieldType) fieldType).getDimension());\n+        }\n+        return parsedQuery;\n+    }\n+\n+    /**\n+     * Return the correct scoring script for a given query. The scoring script\n+     *\n+     * @param params Map of parameters\n+     * @param field Fieldname\n+     * @param lookup SearchLookup\n+     * @param ctx ctx LeafReaderContext to be used for scoring documents\n+     * @return ScoreScript for this query\n+     * @throws IOException throws IOException if ScoreScript cannot be constructed\n+     */\n+    public abstract ScoreScript getScoreScript(Map<String, Object> params, String field, SearchLookup lookup,\n+                                               LeafReaderContext ctx) throws IOException;\n+\n+    public static class L2 extends KNNScoringSpace {\n+\n+        public L2(Object query, MappedFieldType fieldType) {\n+            super(query, fieldType);\n+        }\n+\n+        @Override\n+        protected void prepareQuery(Object query) {\n+            if (!isKNNVectorFieldType(fieldType)) {\n+                throw new IllegalArgumentException(\"Incompatible field_type for l2 space. The field type must \" +\n+                        \"be knn_vector.\");\n+            }\n+\n+            this.processedQuery = parseKNNVectorQuery(query);\n+            this.scoringMethod = (float[] q, float[] v) -> 1 / (1 + KNNScoringUtil.l2Squared(q, v));\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public ScoreScript getScoreScript(Map<String, Object> params, String field, SearchLookup lookup,\n+                                          LeafReaderContext ctx) throws IOException {\n+            return new KNNScoreScript.KNNVectors(params, (float[]) processedQuery, field,\n+                    (BiFunction<float[], float[], Float>) this.scoringMethod, lookup, ctx);\n+\n+        }\n+    }\n+\n+    public static class CosineSimilarity extends KNNScoringSpace {\n+\n+        public CosineSimilarity(Object query, MappedFieldType fieldType) {\n+            super(query, fieldType);\n+        }\n+\n+        @Override\n+        protected void prepareQuery(Object query) {\n+            if (!(fieldType instanceof KNNVectorFieldMapper.KNNVectorFieldType)) {\n+                throw new IllegalArgumentException(\"Incompatible field_type for cosine space. The field type must \" +\n+                        \"be knn_vector.\");\n+            }\n+\n+            this.processedQuery = parseKNNVectorQuery(query);\n+            float qVectorSquaredMagnitude = KNNScoringUtil.getVectorMagnitudeSquared((float[]) this.processedQuery);\n+            this.scoringMethod = (float[] q, float[] v) -> 1 + KNNScoringUtil.cosinesimilOptimized(q, v,\n+                    qVectorSquaredMagnitude);\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public ScoreScript getScoreScript(Map<String, Object> params, String field, SearchLookup lookup,\n+                                          LeafReaderContext ctx) throws IOException {\n+                return new KNNScoreScript.KNNVectors(params, (float[]) processedQuery, field,\n+                        (BiFunction<float[], float[], Float>) this.scoringMethod, lookup, ctx);\n+        }\n+    }\n+\n+    public static class HammingBit extends KNNScoringSpace {\n+        public HammingBit(Object query, MappedFieldType fieldType) {\n+            super(query, fieldType);\n+        }\n+\n+        @Override\n+        protected void prepareQuery(Object query) {\n+            if (isLongFieldType(fieldType)) {\n+                this.processedQuery = parseLongQuery(query);\n+                this.scoringMethod = (Long q, Long v) -> 1.0f / (1 + KNNScoringUtil.bitHamming(q, v));\n+            } else if (isBinaryFieldType(fieldType)) {\n+                this.processedQuery = parseBinaryQuery(query);\n+                this.scoringMethod = (BitSet q, BitSet v) -> 1.0f / (1 + KNNScoringUtil.bitHamming(q, v));\n+            } else {\n+                throw new IllegalArgumentException(\"Incompatible field_type for hamming space. The field type must \" +\n+                        \"of type long or binary.\");\n+            }\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public ScoreScript getScoreScript(Map<String, Object> params, String field, SearchLookup lookup,\n+                                          LeafReaderContext ctx) throws IOException {\n+            if (isLongFieldType(fieldType)) {\n+                return new KNNScoreScript.Longs(params, (Long) this.processedQuery, field,\n+                        (BiFunction<Long, Long, Float>) this.scoringMethod, lookup, ctx);\n+            } else if (isBinaryFieldType(fieldType)) {\n+                return new KNNScoreScript.BitSets(params, (BitSet) this.processedQuery, field,\n+                        (BiFunction<BitSet, BitSet, Float>) this.scoringMethod, lookup, ctx);\n+            } else {", "originalCommit": "9cb28bf738d1512357ba7af09c46f66d064689c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU3Mjg4Nw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r522572887", "bodyText": "I don't believe so.", "author": "jmazanec15", "createdAt": "2020-11-13T02:31:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4NjI3Mg=="}], "type": "inlineReview"}, {"oid": "65d5644445963faf08ed36920aba358189704992", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/65d5644445963faf08ed36920aba358189704992", "message": "switch hamming binary to use BigInteger instead of BitSet", "committedDate": "2020-11-13T02:16:56Z", "type": "commit"}, {"oid": "86f1f388ee8e1894fb6e7a27e45101ecb21f741c", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/86f1f388ee8e1894fb6e7a27e45101ecb21f741c", "message": "address comments", "committedDate": "2020-11-13T02:48:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE3MDU4Ng==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r523170586", "bodyText": "nit: can we move this close to class?", "author": "VijayanB", "createdAt": "2020-11-13T19:15:18Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoreScript.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.BinaryDocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.UncheckedIOException;\n+import java.math.BigInteger;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+/**\n+ * KNNScoreScript is used for adjusting the score of query results based on similarity distance methods. Scripts\n+ * operate on a per document basis. Because the scoring method is passed in during construction, KNNScoreScripts are\n+ * only concerned with the types of the query and docs being processed.\n+ */\n+public abstract class KNNScoreScript<T> extends ScoreScript {\n+    protected final T queryValue;\n+    protected final String field;\n+    protected final BiFunction<T, T, Float> scoringMethod;\n+\n+    public KNNScoreScript(Map<String, Object> params, T queryValue, String field,\n+                          BiFunction<T, T, Float> scoringMethod, SearchLookup lookup, LeafReaderContext leafContext) {\n+        super(params, lookup, leafContext);\n+        this.queryValue = queryValue;\n+        this.field = field;\n+        this.scoringMethod = scoringMethod;\n+    }\n+\n+    /**\n+     * KNNScoreScript with Long type. The query value passed in as well as the DocValues being searched over are\n+     * expected to be Longs.\n+     */\n+    public static class LongType extends KNNScoreScript<Long> {\n+        /**\n+         * This function calculates the similarity score for each doc in the segment.\n+         *\n+         * @param explanationHolder A helper to take in an explanation from a script and turn\n+         *                          it into an {@link org.apache.lucene.search.Explanation}\n+         * @return score for the provided space between the doc and the query\n+         */\n+        @Override\n+        public double execute(ScoreScript.ExplanationHolder explanationHolder) {\n+            ScriptDocValues.Longs scriptDocValues = (ScriptDocValues.Longs) getDoc().get(this.field);\n+            if (scriptDocValues.size() == 0) {\n+                return Float.MIN_VALUE;\n+            }\n+            return this.scoringMethod.apply(this.queryValue, scriptDocValues.getValue());\n+        }\n+\n+        public LongType(Map<String, Object> params, Long queryValue, String field,\n+                    BiFunction<Long, Long, Float> scoringMethod, SearchLookup lookup, LeafReaderContext leafContext) {\n+            super(params, queryValue, field, scoringMethod, lookup, leafContext);\n+        }\n+    }\n+\n+    /**\n+     * KNNScoreScript with BigInteger type. The query value passed in as well as the DocValues being searched over\n+     * are expected to be BigInteger.\n+     */\n+    public static class BigIntegerType extends KNNScoreScript<BigInteger> {\n+        /**\n+         * This function calculates the similarity score for each doc in the segment.\n+         *\n+         * @param explanationHolder A helper to take in an explanation from a script and turn\n+         *                          it into an {@link org.apache.lucene.search.Explanation}\n+         * @return score for the provided space between the doc and the query\n+         */\n+        @Override\n+        public double execute(ScoreScript.ExplanationHolder explanationHolder) {\n+            ScriptDocValues.BytesRefs scriptDocValues = (ScriptDocValues.BytesRefs) getDoc().get(this.field);\n+            if (scriptDocValues.size() == 0) {\n+                return Float.MIN_VALUE;\n+            }\n+            return this.scoringMethod.apply(this.queryValue, new BigInteger(1, scriptDocValues.getValue().bytes));\n+        }\n+\n+        public BigIntegerType(Map<String, Object> params, BigInteger queryValue, String field,\n+                           BiFunction<BigInteger, BigInteger, Float> scoringMethod, SearchLookup lookup,\n+                           LeafReaderContext leafContext) {\n+            super(params, queryValue, field, scoringMethod, lookup, leafContext);\n+        }\n+    }\n+\n+    /**\n+     * KNNVectors with float[] type. The query value passed in is expected to be float[]. The fieldType of the docs\n+     * being searched over are expected to be KNNVector type.\n+     */\n+    public static class KNNVectorType extends KNNScoreScript<float[]> {\n+        private BinaryDocValues binaryDocValuesReader;\n+        private boolean vectorExist = true;\n+\n+        /**\n+         * This function called for each doc in the segment. We evaluate the score of the vector in the doc\n+         *\n+         * @param explanationHolder A helper to take in an explanation from a script and turn\n+         *                          it into an {@link org.apache.lucene.search.Explanation}\n+         * @return score of the vector to the query vector\n+         */\n+        @Override\n+        public double execute(ScoreScript.ExplanationHolder explanationHolder) {\n+            // If this document does not contain the vector, push it to end of the results.\n+            if (!vectorExist) {\n+                return Float.MIN_VALUE;\n+            }\n+\n+            try {\n+                float[] docVector;\n+                BytesRef bytesref = binaryDocValuesReader.binaryValue();\n+                try (ByteArrayInputStream byteStream = new ByteArrayInputStream(bytesref.bytes, bytesref.offset,\n+                        bytesref.length); ObjectInputStream objectStream = new ObjectInputStream(byteStream)) {\n+                    docVector = (float[]) objectStream.readObject();\n+                } catch (ClassNotFoundException e) {\n+                    KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+                    throw new RuntimeException(e);\n+                }\n+\n+                return this.scoringMethod.apply(queryValue, docVector);\n+            } catch (IOException e) {\n+                KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+\n+        @Override\n+        public void setDocument(int docId) {\n+            try {\n+                this.vectorExist = this.binaryDocValuesReader.advanceExact(docId);\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+\n+        public KNNVectorType(Map<String, Object> params, float[] queryValue, String field,", "originalCommit": "86f1f388ee8e1894fb6e7a27e45101ecb21f741c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0MjIxMg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r524442212", "bodyText": "Yes we can", "author": "jmazanec15", "createdAt": "2020-11-16T17:24:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE3MDU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI2OTM0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r523269342", "bodyText": "What do you think about following format?\n    public KNNScoreScriptFactory(Map<String, Object> params, SearchLookup lookup) {\n     KNNCounter.SCRIPT_QUERY_REQUESTS.increment();\n     this.params = params;\n     this.lookup = lookup;\n     this.field = getValue(params, \"field\")\n     similaritySpace = getValue(params, \"space_type\")\n     this.knnScoringSpace = KNNScoringSpaceFactory.create(similaritySpace, this.query,\n            lookup.doc().mapperService().fieldType(this.field));\n\n}\n\n private Object getValue(Map<String, Object> params, String fieldName) {\n    final Object value = params.get(fieldName);\n    if (value != null) \n     return value.toString();\n   KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n   throw new IllegalArgumentException(\"Missing parameter [\"+ fieldName +\"]\");\n  }", "author": "VijayanB", "createdAt": "2020-11-13T22:38:28Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoreScriptFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+public class KNNScoreScriptFactory implements ScoreScript.LeafFactory {\n+    private final Map<String, Object> params;\n+    private final SearchLookup lookup;\n+    private String similaritySpace;\n+    private String field;\n+    private Object query;\n+    private KNNScoringSpace knnScoringSpace;\n+\n+    public KNNScoreScriptFactory(Map<String, Object> params, SearchLookup lookup) {", "originalCommit": "86f1f388ee8e1894fb6e7a27e45101ecb21f741c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ1MDk5MQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r524450991", "bodyText": "Yeah, I think overall that is cleaner. I will update to follow that, with a few minor tweaks.", "author": "jmazanec15", "createdAt": "2020-11-16T17:36:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzI2OTM0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM2NTc5OQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r523365799", "bodyText": "needsScore", "author": "VijayanB", "createdAt": "2020-11-14T02:56:13Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoreScriptFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+public class KNNScoreScriptFactory implements ScoreScript.LeafFactory {\n+    private final Map<String, Object> params;\n+    private final SearchLookup lookup;\n+    private String similaritySpace;\n+    private String field;\n+    private Object query;\n+    private KNNScoringSpace knnScoringSpace;\n+\n+    public KNNScoreScriptFactory(Map<String, Object> params, SearchLookup lookup) {\n+        KNNCounter.SCRIPT_QUERY_REQUESTS.increment();\n+        this.params = params;\n+        this.lookup = lookup;\n+\n+        parseParameters();\n+\n+        this.knnScoringSpace = KNNScoringSpaceFactory.create(this.similaritySpace, this.query,\n+                lookup.doc().mapperService().fieldType(this.field));\n+\n+    }\n+\n+    private void parseParameters() {\n+        final Object field = params.get(\"field\");\n+        if (field == null) {\n+            KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+            throw new IllegalArgumentException(\"Missing parameter [field]\");\n+        }\n+\n+        this.field = field.toString();\n+\n+        final Object space = params.get(\"space_type\");\n+        if (space == null) {\n+            KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+            throw new IllegalArgumentException(\"Missing parameter [space_type]\");\n+        }\n+\n+        this.similaritySpace = space.toString();\n+\n+        final Object queryValue = params.get(\"query_value\");\n+        if (queryValue == null) {\n+            KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+            throw new IllegalArgumentException(\"Missing parameter [query_value]\");\n+        }\n+        this.query = queryValue;\n+    }\n+\n+    public boolean needs_score() {", "originalCommit": "86f1f388ee8e1894fb6e7a27e45101ecb21f741c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0NTYxMg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r524445612", "bodyText": "Thats actually a method in the LeafFactory interface. So, we can't change.", "author": "jmazanec15", "createdAt": "2020-11-16T17:28:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM2NTc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDUzNzMxOQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r524537319", "bodyText": "i see. Can you add @OverRide annotation ?", "author": "VijayanB", "createdAt": "2020-11-16T20:00:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM2NTc5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDYxMTg0Mg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r524611842", "bodyText": "ack", "author": "jmazanec15", "createdAt": "2020-11-16T21:34:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM2NTc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM2NjIzNQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r523366235", "bodyText": "nit: does scriptDocValues has isEmpty method?", "author": "VijayanB", "createdAt": "2020-11-14T03:00:54Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoreScript.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.BinaryDocValues;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.apache.lucene.util.BytesRef;\n+import org.elasticsearch.index.fielddata.ScriptDocValues;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.UncheckedIOException;\n+import java.math.BigInteger;\n+import java.util.Map;\n+import java.util.function.BiFunction;\n+\n+/**\n+ * KNNScoreScript is used for adjusting the score of query results based on similarity distance methods. Scripts\n+ * operate on a per document basis. Because the scoring method is passed in during construction, KNNScoreScripts are\n+ * only concerned with the types of the query and docs being processed.\n+ */\n+public abstract class KNNScoreScript<T> extends ScoreScript {\n+    protected final T queryValue;\n+    protected final String field;\n+    protected final BiFunction<T, T, Float> scoringMethod;\n+\n+    public KNNScoreScript(Map<String, Object> params, T queryValue, String field,\n+                          BiFunction<T, T, Float> scoringMethod, SearchLookup lookup, LeafReaderContext leafContext) {\n+        super(params, lookup, leafContext);\n+        this.queryValue = queryValue;\n+        this.field = field;\n+        this.scoringMethod = scoringMethod;\n+    }\n+\n+    /**\n+     * KNNScoreScript with Long type. The query value passed in as well as the DocValues being searched over are\n+     * expected to be Longs.\n+     */\n+    public static class LongType extends KNNScoreScript<Long> {\n+        /**\n+         * This function calculates the similarity score for each doc in the segment.\n+         *\n+         * @param explanationHolder A helper to take in an explanation from a script and turn\n+         *                          it into an {@link org.apache.lucene.search.Explanation}\n+         * @return score for the provided space between the doc and the query\n+         */\n+        @Override\n+        public double execute(ScoreScript.ExplanationHolder explanationHolder) {\n+            ScriptDocValues.Longs scriptDocValues = (ScriptDocValues.Longs) getDoc().get(this.field);\n+            if (scriptDocValues.size() == 0) {\n+                return Float.MIN_VALUE;\n+            }\n+            return this.scoringMethod.apply(this.queryValue, scriptDocValues.getValue());\n+        }\n+\n+        public LongType(Map<String, Object> params, Long queryValue, String field,\n+                    BiFunction<Long, Long, Float> scoringMethod, SearchLookup lookup, LeafReaderContext leafContext) {\n+            super(params, queryValue, field, scoringMethod, lookup, leafContext);\n+        }\n+    }\n+\n+    /**\n+     * KNNScoreScript with BigInteger type. The query value passed in as well as the DocValues being searched over\n+     * are expected to be BigInteger.\n+     */\n+    public static class BigIntegerType extends KNNScoreScript<BigInteger> {\n+        /**\n+         * This function calculates the similarity score for each doc in the segment.\n+         *\n+         * @param explanationHolder A helper to take in an explanation from a script and turn\n+         *                          it into an {@link org.apache.lucene.search.Explanation}\n+         * @return score for the provided space between the doc and the query\n+         */\n+        @Override\n+        public double execute(ScoreScript.ExplanationHolder explanationHolder) {\n+            ScriptDocValues.BytesRefs scriptDocValues = (ScriptDocValues.BytesRefs) getDoc().get(this.field);\n+            if (scriptDocValues.size() == 0) {", "originalCommit": "86f1f388ee8e1894fb6e7a27e45101ecb21f741c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0MjAzNw==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r524442037", "bodyText": "Yes it does. I will update.", "author": "jmazanec15", "createdAt": "2020-11-16T17:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM2NjIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM2NjQxMA==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r523366410", "bodyText": "nit: is this required? if so, can we move to block comment?", "author": "VijayanB", "createdAt": "2020-11-14T03:03:00Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoreScriptFactory.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n+package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n+\n+import com.amazon.opendistroforelasticsearch.knn.plugin.stats.KNNCounter;\n+import org.apache.lucene.index.LeafReaderContext;\n+import org.elasticsearch.script.ScoreScript;\n+import org.elasticsearch.search.lookup.SearchLookup;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+public class KNNScoreScriptFactory implements ScoreScript.LeafFactory {\n+    private final Map<String, Object> params;\n+    private final SearchLookup lookup;\n+    private String similaritySpace;\n+    private String field;\n+    private Object query;\n+    private KNNScoringSpace knnScoringSpace;\n+\n+    public KNNScoreScriptFactory(Map<String, Object> params, SearchLookup lookup) {\n+        KNNCounter.SCRIPT_QUERY_REQUESTS.increment();\n+        this.params = params;\n+        this.lookup = lookup;\n+\n+        parseParameters();\n+\n+        this.knnScoringSpace = KNNScoringSpaceFactory.create(this.similaritySpace, this.query,\n+                lookup.doc().mapperService().fieldType(this.field));\n+\n+    }\n+\n+    private void parseParameters() {\n+        final Object field = params.get(\"field\");\n+        if (field == null) {\n+            KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+            throw new IllegalArgumentException(\"Missing parameter [field]\");\n+        }\n+\n+        this.field = field.toString();\n+\n+        final Object space = params.get(\"space_type\");\n+        if (space == null) {\n+            KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+            throw new IllegalArgumentException(\"Missing parameter [space_type]\");\n+        }\n+\n+        this.similaritySpace = space.toString();\n+\n+        final Object queryValue = params.get(\"query_value\");\n+        if (queryValue == null) {\n+            KNNCounter.SCRIPT_QUERY_ERRORS.increment();\n+            throw new IllegalArgumentException(\"Missing parameter [query_value]\");\n+        }\n+        this.query = queryValue;\n+    }\n+\n+    public boolean needs_score() {\n+        return false;\n+    }\n+\n+    /**\n+     * For each segment, supply the KNNScoreScript that should be run on the values returned from the fetch phase.\n+     * Because the method to score the documents was set during Factory construction, the scripts are agnostic of\n+     * the similarity space. The KNNScoringSpace will return the correct script, given the query, the field type, and\n+     * the similarity space.\n+     *\n+     * @param ctx LeafReaderContext for the segment\n+     * @return ScoreScript to be executed\n+     */\n+    @Override // called number of segments times", "originalCommit": "86f1f388ee8e1894fb6e7a27e45101ecb21f741c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ0NTgzOQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r524445839", "bodyText": "Good point, will update.", "author": "jmazanec15", "createdAt": "2020-11-16T17:28:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM2NjQxMA=="}], "type": "inlineReview"}, {"oid": "6d44514bcda5522f82bec5a26bce60bae1c41238", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/6d44514bcda5522f82bec5a26bce60bae1c41238", "message": "Refactor to address PR comments", "committedDate": "2020-11-16T19:25:47Z", "type": "commit"}, {"oid": "66e940f87c8cd208d0ed5f9b635a8ef3a9a5ba9d", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/66e940f87c8cd208d0ed5f9b635a8ef3a9a5ba9d", "message": "Add Override annotation", "committedDate": "2020-11-16T21:36:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MjcwMQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r525572701", "bodyText": "Should we merge this class with KNNScoringSpaceUtil?", "author": "vamshin", "createdAt": "2020-11-17T22:39:40Z", "path": "src/main/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScoringUtil.java", "diffHunk": "@@ -1,9 +1,24 @@\n+/*\n+ *   Copyright 2020 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *   Licensed under the Apache License, Version 2.0 (the \"License\").\n+ *   You may not use this file except in compliance with the License.\n+ *   A copy of the License is located at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *   or in the \"license\" file accompanying this file. This file is distributed\n+ *   on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *   express or implied. See the License for the specific language governing\n+ *   permissions and limitations under the License.\n+ */\n+\n package com.amazon.opendistroforelasticsearch.knn.plugin.script;\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n-import java.util.ArrayList;\n+import java.math.BigInteger;\n \n public class KNNScoringUtil {", "originalCommit": "66e940f87c8cd208d0ed5f9b635a8ef3a9a5ba9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwMzUyMQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r526303521", "bodyText": "So, I thought it might be worth keeping KNNScoringSpaceUtil and KNNScoringUtil separate. KNNScoringSpaceUtil contains utility functions for parsing/preparing queries, KNNScoringUtil contains the methods that compute the distance for a particular space.\nI could rename KNNScoringUtil to KNNDistanceUtil if that sounds better? What do you think @vamshin @VijayanB ?", "author": "jmazanec15", "createdAt": "2020-11-18T17:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3MjcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3OTMwMg==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r525579302", "bodyText": "How about we add a testcase in such a way a segment contains docs with field name and with out the field name.   This would test how the scoring is handled for the segments with the above combination.\nWe could try forcemerge and then assert that docs with out the similarity field are not in the top hits. One test for long and one test for base64 should be good?", "author": "vamshin", "createdAt": "2020-11-17T22:53:40Z", "path": "src/test/java/com/amazon/opendistroforelasticsearch/knn/plugin/script/KNNScriptScoringIT.java", "diffHunk": "@@ -308,4 +322,169 @@ public void testKNNScoreforNonVectorDocument() throws Exception {\n         assertEquals(0.33333, scores.get(0), 0.001);\n         assertEquals(Float.MIN_VALUE, scores.get(1), 0.001);\n     }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testHammingScriptScore_Long() throws Exception {", "originalCommit": "66e940f87c8cd208d0ed5f9b635a8ef3a9a5ba9d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMwOTcwOQ==", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/pull/267#discussion_r526309709", "bodyText": "Sure, so at the moment, I add 4 docs with the field and then 3 docs without the field, and then confirm the docs without the field arent in the results. What I will do is put in a refresh in between the addition of the docs with the field and the docs without the field, to confirm that a segment either has only docs with the field or only docs without the field. Then, IO will confirm the docs without the field arent in the results. Then I will forcemerge to 1 segment, and repeat the experiment.", "author": "jmazanec15", "createdAt": "2020-11-18T18:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU3OTMwMg=="}], "type": "inlineReview"}, {"oid": "ecdfe06bab99b841382081b8e5be7de03031350c", "url": "https://github.com/opendistro-for-elasticsearch/k-NN/commit/ecdfe06bab99b841382081b8e5be7de03031350c", "message": "update test case to include single segment test", "committedDate": "2020-11-18T18:37:59Z", "type": "commit"}]}