{"pr_number": 291, "pr_title": "Add support for MaxConcurrentActivityExecutionSize for async activities", "pr_createdAt": "2020-12-30T04:24:33Z", "pr_url": "https://github.com/temporalio/sdk-java/pull/291", "timeline": [{"oid": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed", "url": "https://github.com/temporalio/sdk-java/commit/3c3b1e6a180c2ace5406b0beb43605c48925d1ed", "message": "Add support for MaxConcurrentActivityExecutionSize for async activities", "committedDate": "2020-12-30T04:18:19Z", "type": "commit"}, {"oid": "4d6246a56c9fb22ac041acfaabd43ea628a7210a", "url": "https://github.com/temporalio/sdk-java/commit/4d6246a56c9fb22ac041acfaabd43ea628a7210a", "message": "do note invoke completion handle on heartbeat", "committedDate": "2020-12-30T04:27:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTQ2OQ==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r549931469", "bodyText": "I don't think you want to complete on a heartbeat.", "author": "mfateev", "createdAt": "2020-12-30T04:27:32Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityCompletionClientImpl.java", "diffHunk": "@@ -23,58 +23,98 @@\n import io.temporal.client.ActivityCompletionClient;\n import io.temporal.client.ActivityCompletionException;\n import io.temporal.internal.external.ManualActivityCompletionClientFactory;\n+import io.temporal.workflow.Functions;\n import java.util.Optional;\n \n class ActivityCompletionClientImpl implements ActivityCompletionClient {\n \n   private final ManualActivityCompletionClientFactory factory;\n+  private final Functions.Proc completionHandle;\n \n   public ActivityCompletionClientImpl(\n-      ManualActivityCompletionClientFactory manualActivityCompletionClientFactory) {\n+      ManualActivityCompletionClientFactory manualActivityCompletionClientFactory,\n+      Functions.Proc completionHandle) {\n     this.factory = manualActivityCompletionClientFactory;\n+    this.completionHandle = completionHandle;\n   }\n \n   @Override\n   public <R> void complete(byte[] taskToken, R result) {\n-    factory.getClient(taskToken).complete(result);\n+    try {\n+      factory.getClient(taskToken).complete(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <R> void complete(String workflowId, Optional<String> runId, String activityId, R result) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).complete(result);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).complete(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public void completeExceptionally(byte[] taskToken, Exception result) {\n-    factory.getClient(taskToken).fail(result);\n+    try {\n+      factory.getClient(taskToken).fail(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public void completeExceptionally(\n       String workflowId, Optional<String> runId, String activityId, Exception result) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).fail(result);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).fail(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void reportCancellation(byte[] taskToken, V details) {\n-    factory.getClient(taskToken).reportCancellation(details);\n+    try {\n+      factory.getClient(taskToken).reportCancellation(details);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void reportCancellation(\n       String workflowId, Optional<String> runId, String activityId, V details) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).reportCancellation(details);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).reportCancellation(details);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void heartbeat(byte[] taskToken, V details) throws ActivityCompletionException {\n-    factory.getClient(taskToken).recordHeartbeat(details);\n+    try {\n+      factory.getClient(taskToken).recordHeartbeat(details);\n+    } finally {\n+      completionHandle.apply();", "originalCommit": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTQ4MA==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r549931480", "bodyText": "ditto", "author": "mfateev", "createdAt": "2020-12-30T04:27:41Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityCompletionClientImpl.java", "diffHunk": "@@ -23,58 +23,98 @@\n import io.temporal.client.ActivityCompletionClient;\n import io.temporal.client.ActivityCompletionException;\n import io.temporal.internal.external.ManualActivityCompletionClientFactory;\n+import io.temporal.workflow.Functions;\n import java.util.Optional;\n \n class ActivityCompletionClientImpl implements ActivityCompletionClient {\n \n   private final ManualActivityCompletionClientFactory factory;\n+  private final Functions.Proc completionHandle;\n \n   public ActivityCompletionClientImpl(\n-      ManualActivityCompletionClientFactory manualActivityCompletionClientFactory) {\n+      ManualActivityCompletionClientFactory manualActivityCompletionClientFactory,\n+      Functions.Proc completionHandle) {\n     this.factory = manualActivityCompletionClientFactory;\n+    this.completionHandle = completionHandle;\n   }\n \n   @Override\n   public <R> void complete(byte[] taskToken, R result) {\n-    factory.getClient(taskToken).complete(result);\n+    try {\n+      factory.getClient(taskToken).complete(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <R> void complete(String workflowId, Optional<String> runId, String activityId, R result) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).complete(result);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).complete(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public void completeExceptionally(byte[] taskToken, Exception result) {\n-    factory.getClient(taskToken).fail(result);\n+    try {\n+      factory.getClient(taskToken).fail(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public void completeExceptionally(\n       String workflowId, Optional<String> runId, String activityId, Exception result) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).fail(result);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).fail(result);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void reportCancellation(byte[] taskToken, V details) {\n-    factory.getClient(taskToken).reportCancellation(details);\n+    try {\n+      factory.getClient(taskToken).reportCancellation(details);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void reportCancellation(\n       String workflowId, Optional<String> runId, String activityId, V details) {\n-    factory.getClient(toExecution(workflowId, runId), activityId).reportCancellation(details);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).reportCancellation(details);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void heartbeat(byte[] taskToken, V details) throws ActivityCompletionException {\n-    factory.getClient(taskToken).recordHeartbeat(details);\n+    try {\n+      factory.getClient(taskToken).recordHeartbeat(details);\n+    } finally {\n+      completionHandle.apply();\n+    }\n   }\n \n   @Override\n   public <V> void heartbeat(String workflowId, Optional<String> runId, String activityId, V details)\n       throws ActivityCompletionException {\n-    factory.getClient(toExecution(workflowId, runId), activityId).recordHeartbeat(details);\n+    try {\n+      factory.getClient(toExecution(workflowId, runId), activityId).recordHeartbeat(details);\n+    } finally {\n+      completionHandle.apply();", "originalCommit": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTc2OA==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r549931768", "bodyText": "Make this method and other methods thread safe. It looks like doNotComplete on return should be also made thread safe.", "author": "mfateev", "createdAt": "2020-12-30T04:29:40Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -228,6 +239,17 @@ public boolean isDoNotCompleteOnReturn() {\n     return doNotCompleteOnReturn;\n   }\n \n+  public boolean isUseLocalManualCompletion() {\n+    return useLocalManualCompletion;\n+  }\n+\n+  @Override\n+  public ActivityCompletionClient useLocalManualCompletion() {\n+    doNotCompleteOnReturn();\n+    useLocalManualCompletion = true;\n+    return new ActivityCompletionClientImpl(manualCompletionClientFactory, completionHandle);", "originalCommit": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDAzNDM4OQ==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550034389", "bodyText": "Done", "author": "vitarb", "createdAt": "2020-12-30T08:34:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTc2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTg5Mg==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r549931892", "bodyText": "Why? it makes perfect sense for local activities implemented asynchronously.", "author": "mfateev", "createdAt": "2020-12-30T04:30:32Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/LocalActivityExecutionContextImpl.java", "diffHunk": "@@ -72,6 +73,18 @@ public boolean isDoNotCompleteOnReturn() {\n         \"isDoNotCompleteOnReturn is not supported for local activities\");\n   }\n \n+  @Override\n+  public boolean isUseLocalManualCompletion() {\n+    throw new UnsupportedOperationException(\n+        \"isUseLocalManualCompletion is not supported for local activities\");", "originalCommit": "3c3b1e6a180c2ace5406b0beb43605c48925d1ed", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDAzMDE3OQ==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550030179", "bodyText": "We need to rethink our behavior for limiting local activity throughput as currently semaphore and setMaxConcurrentActivityExecutionSize is only applied to normal activities. Also I don't think we support async local activities in principle. This would be a bigger change, and I suggest keep it out of scope for this PR.", "author": "vitarb", "createdAt": "2020-12-30T08:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTg5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTM4OA==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550329388", "bodyText": "Let's keep it out of the scope of this PR.\nI believe that async local activities can be an important performance optimization in some cases.", "author": "mfateev", "createdAt": "2020-12-30T21:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkzMTg5Mg=="}], "type": "inlineReview"}, {"oid": "21c998bde43f7001cd467f7b1d741db624c82a8d", "url": "https://github.com/temporalio/sdk-java/commit/21c998bde43f7001cd467f7b1d741db624c82a8d", "message": "Use synchronization in async APIs in the context", "committedDate": "2020-12-30T08:33:51Z", "type": "commit"}, {"oid": "7c5c66102bda999773ceeb2bde0c0b2d1fd6c786", "url": "https://github.com/temporalio/sdk-java/commit/7c5c66102bda999773ceeb2bde0c0b2d1fd6c786", "message": "update comments", "committedDate": "2020-12-30T20:57:03Z", "type": "commit"}, {"oid": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00", "url": "https://github.com/temporalio/sdk-java/commit/0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00", "message": "apply formatting", "committedDate": "2020-12-30T20:57:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyODg4NQ==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550328885", "bodyText": "Does it need to be the Impl or the ManualActivityCompletionClientFactory interface would be enough?", "author": "mfateev", "createdAt": "2020-12-30T21:14:08Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -72,6 +75,9 @@\n   private final Lock lock = new ReentrantLock();\n   private ScheduledFuture future;\n   private ActivityCompletionException lastException;\n+  private final ManualActivityCompletionClientFactoryImpl manualCompletionClientFactory;", "originalCommit": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NDI5Nw==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550354297", "bodyText": "Interface is enough.", "author": "vitarb", "createdAt": "2020-12-30T23:21:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyODg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTAwNg==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550329006", "bodyText": "Needs locking as well", "author": "mfateev", "createdAt": "2020-12-30T21:14:46Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -220,14 +231,35 @@ private void sendHeartbeatRequest(Object details) {\n \n   @Override\n   public void doNotCompleteOnReturn() {\n-    doNotCompleteOnReturn = true;\n+    lock.lock();\n+    try {\n+      doNotCompleteOnReturn = true;\n+    } finally {\n+      lock.unlock();\n+    }\n   }\n \n   @Override\n   public boolean isDoNotCompleteOnReturn() {\n     return doNotCompleteOnReturn;", "originalCommit": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NDQ2OQ==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550354469", "bodyText": "Added.", "author": "vitarb", "createdAt": "2020-12-30T23:23:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTA1MA==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550329050", "bodyText": "Needs locking as well", "author": "mfateev", "createdAt": "2020-12-30T21:14:58Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/sync/ActivityExecutionContextImpl.java", "diffHunk": "@@ -220,14 +231,35 @@ private void sendHeartbeatRequest(Object details) {\n \n   @Override\n   public void doNotCompleteOnReturn() {\n-    doNotCompleteOnReturn = true;\n+    lock.lock();\n+    try {\n+      doNotCompleteOnReturn = true;\n+    } finally {\n+      lock.unlock();\n+    }\n   }\n \n   @Override\n   public boolean isDoNotCompleteOnReturn() {\n     return doNotCompleteOnReturn;\n   }\n \n+  public boolean isUseLocalManualCompletion() {\n+    return useLocalManualCompletion;", "originalCommit": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NDQ2Mw==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550354463", "bodyText": "Added.", "author": "vitarb", "createdAt": "2020-12-30T23:23:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTg2Ng==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550329866", "bodyText": "Does response != null check mean that if activity throws an exception the counter is not decremented?", "author": "mfateev", "createdAt": "2020-12-30T21:18:05Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/worker/ActivityWorker.java", "diffHunk": "@@ -210,17 +210,20 @@ public void handle(ActivityTask task) throws Exception {\n           if (info.hasDetails()) {\n             canceledRequest.setDetails(info.getDetails());\n           }\n-          sendReply(\n-              r,\n-              new Result(r.getActivityId(), null, null, canceledRequest.build(), null),\n-              metricsScope);\n+          response =\n+              new Result(r.getActivityId(), null, null, canceledRequest.build(), null, false);\n+          sendReply(r, response, metricsScope);\n         }\n       } finally {\n         MDC.remove(LoggerTag.ACTIVITY_ID);\n         MDC.remove(LoggerTag.ACTIVITY_TYPE);\n         MDC.remove(LoggerTag.WORKFLOW_ID);\n         MDC.remove(LoggerTag.RUN_ID);\n-        task.getCompletionHandle().apply();\n+        // Apply completion handle if task has been completed synchronously or is async and manual\n+        // completion hasn't been requested.\n+        if (response != null && !response.isManualCompletion()) {", "originalCommit": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3NzkxMw==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550377913", "bodyText": "No, it should be null only if activity is async.", "author": "vitarb", "createdAt": "2020-12-31T02:16:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMyOTg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMzMDQxMg==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550330412", "bodyText": "This doesn't need to be static. Move to the AsyncActivityWithManualCompletion field.", "author": "mfateev", "createdAt": "2020-12-30T21:20:30Z", "path": "temporal-sdk/src/test/java/io/temporal/workflow/LocalAsyncCompletionWorkflowTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.activity.Activity;\n+import io.temporal.activity.ActivityExecutionContext;\n+import io.temporal.activity.ActivityInterface;\n+import io.temporal.activity.ActivityMethod;\n+import io.temporal.activity.ActivityOptions;\n+import io.temporal.client.ActivityCompletionClient;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.common.RetryOptions;\n+import io.temporal.worker.WorkerOptions;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalAsyncCompletionWorkflowTest {\n+\n+  public static final int MAX_CONCURRENT_ACTIVITIES = 1;\n+\n+  @Rule\n+  public TestWorkflowRule testWorkflowRule =\n+      TestWorkflowRule.newBuilder()\n+          .setWorkerOptions(\n+              WorkerOptions.newBuilder()\n+                  .setMaxConcurrentActivityExecutionSize(MAX_CONCURRENT_ACTIVITIES)\n+                  .setActivityPollThreadCount(5)\n+                  .build())\n+          .setWorkflowTypes(TestWorkflowImpl.class)\n+          .setActivityImplementations(new AsyncActivityWithManualCompletion())\n+          .setUseExternalService(Boolean.parseBoolean(System.getenv(\"USE_DOCKER_SERVICE\")))\n+          .setTarget(System.getenv(\"TEMPORAL_SERVICE_ADDRESS\"))\n+          .build();\n+\n+  private static final AtomicInteger concurrentActivitiesCount = new AtomicInteger(0);\n+\n+  @WorkflowInterface\n+  public interface TestWorkflow {\n+\n+    @WorkflowMethod\n+    String execute(String taskQueue);\n+  }\n+\n+  public static class TestWorkflowImpl implements TestWorkflow {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivity activity =\n+          Workflow.newActivityStub(\n+              TestActivity.class,\n+              ActivityOptions.newBuilder()\n+                  .setScheduleToStartTimeout(Duration.ofSeconds(10))\n+                  .setScheduleToCloseTimeout(Duration.ofSeconds(10))\n+                  .setHeartbeatTimeout(Duration.ofSeconds(1))\n+                  .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\n+                  .build());\n+      List<Promise<Integer>> promises = new ArrayList<>();\n+      for (int i = 0; i < 10; i++) {\n+        promises.add(Async.function(() -> activity.execute(2)));\n+      }\n+      Promise.allOf(promises).get();\n+      for (Promise<Integer> promise : promises) {\n+        if (promise.getFailure() != null) {\n+          return \"exception\";\n+        }\n+        if (promise.get() != 4) { // All activities compute 2 * 2\n+          return \"wrong result\";\n+        }\n+      }\n+      return \"success\";\n+    }\n+  }\n+\n+  @ActivityInterface\n+  public interface TestActivity {\n+\n+    @ActivityMethod\n+    int execute(int value);\n+  }\n+\n+  public static class AsyncActivityWithManualCompletion implements TestActivity {\n+\n+    @Override\n+    public int execute(int value) {\n+      int concurrentActivities = concurrentActivitiesCount.incrementAndGet();", "originalCommit": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NTY0MA==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550355640", "bodyText": "Done", "author": "vitarb", "createdAt": "2020-12-30T23:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMzMDQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMzMDc5NA==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550330794", "bodyText": "I would move completion to a separate thread just to increase code coverage. See HelloAsyncActivityCompletion.", "author": "mfateev", "createdAt": "2020-12-30T21:22:28Z", "path": "temporal-sdk/src/test/java/io/temporal/workflow/LocalAsyncCompletionWorkflowTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.\n+ *\n+ *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ *  Modifications copyright (C) 2017 Uber Technologies, Inc.\n+ *\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\"). You may not\n+ *  use this file except in compliance with the License. A copy of the License is\n+ *  located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ *  or in the \"license\" file accompanying this file. This file is distributed on\n+ *  an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ *  express or implied. See the License for the specific language governing\n+ *  permissions and limitations under the License.\n+ */\n+\n+package io.temporal.workflow;\n+\n+import io.temporal.activity.Activity;\n+import io.temporal.activity.ActivityExecutionContext;\n+import io.temporal.activity.ActivityInterface;\n+import io.temporal.activity.ActivityMethod;\n+import io.temporal.activity.ActivityOptions;\n+import io.temporal.client.ActivityCompletionClient;\n+import io.temporal.client.WorkflowOptions;\n+import io.temporal.common.RetryOptions;\n+import io.temporal.worker.WorkerOptions;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+public class LocalAsyncCompletionWorkflowTest {\n+\n+  public static final int MAX_CONCURRENT_ACTIVITIES = 1;\n+\n+  @Rule\n+  public TestWorkflowRule testWorkflowRule =\n+      TestWorkflowRule.newBuilder()\n+          .setWorkerOptions(\n+              WorkerOptions.newBuilder()\n+                  .setMaxConcurrentActivityExecutionSize(MAX_CONCURRENT_ACTIVITIES)\n+                  .setActivityPollThreadCount(5)\n+                  .build())\n+          .setWorkflowTypes(TestWorkflowImpl.class)\n+          .setActivityImplementations(new AsyncActivityWithManualCompletion())\n+          .setUseExternalService(Boolean.parseBoolean(System.getenv(\"USE_DOCKER_SERVICE\")))\n+          .setTarget(System.getenv(\"TEMPORAL_SERVICE_ADDRESS\"))\n+          .build();\n+\n+  private static final AtomicInteger concurrentActivitiesCount = new AtomicInteger(0);\n+\n+  @WorkflowInterface\n+  public interface TestWorkflow {\n+\n+    @WorkflowMethod\n+    String execute(String taskQueue);\n+  }\n+\n+  public static class TestWorkflowImpl implements TestWorkflow {\n+\n+    @Override\n+    public String execute(String taskQueue) {\n+      TestActivity activity =\n+          Workflow.newActivityStub(\n+              TestActivity.class,\n+              ActivityOptions.newBuilder()\n+                  .setScheduleToStartTimeout(Duration.ofSeconds(10))\n+                  .setScheduleToCloseTimeout(Duration.ofSeconds(10))\n+                  .setHeartbeatTimeout(Duration.ofSeconds(1))\n+                  .setRetryOptions(RetryOptions.newBuilder().setMaximumAttempts(1).build())\n+                  .build());\n+      List<Promise<Integer>> promises = new ArrayList<>();\n+      for (int i = 0; i < 10; i++) {\n+        promises.add(Async.function(() -> activity.execute(2)));\n+      }\n+      Promise.allOf(promises).get();\n+      for (Promise<Integer> promise : promises) {\n+        if (promise.getFailure() != null) {\n+          return \"exception\";\n+        }\n+        if (promise.get() != 4) { // All activities compute 2 * 2\n+          return \"wrong result\";\n+        }\n+      }\n+      return \"success\";\n+    }\n+  }\n+\n+  @ActivityInterface\n+  public interface TestActivity {\n+\n+    @ActivityMethod\n+    int execute(int value);\n+  }\n+\n+  public static class AsyncActivityWithManualCompletion implements TestActivity {\n+\n+    @Override\n+    public int execute(int value) {\n+      int concurrentActivities = concurrentActivitiesCount.incrementAndGet();\n+      if (concurrentActivities > MAX_CONCURRENT_ACTIVITIES) {\n+        throw new RuntimeException(\n+            String.format(\n+                \"More than %d activities was running concurrently!\", MAX_CONCURRENT_ACTIVITIES));\n+      }\n+      ActivityExecutionContext context = Activity.getExecutionContext();\n+      context.heartbeat(value);\n+      ActivityCompletionClient completionClient = context.useLocalManualCompletion();\n+      try {\n+        Thread.sleep(500);\n+        completionClient.complete(context.getTaskToken(), value * 2);\n+      } catch (InterruptedException e) {\n+        Thread.currentThread().interrupt();\n+        e.printStackTrace();\n+        completionClient.completeExceptionally(context.getTaskToken(), e);", "originalCommit": "0a2a5dc2401c6d7fd9cd97d9c1dc4256565e2c00", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM1NTY1MA==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550355650", "bodyText": "Done", "author": "vitarb", "createdAt": "2020-12-30T23:30:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDMzMDc5NA=="}], "type": "inlineReview"}, {"oid": "7a77f55d6b47b97b2ac6807068b1357421d26110", "url": "https://github.com/temporalio/sdk-java/commit/7a77f55d6b47b97b2ac6807068b1357421d26110", "message": "Address PR feedback", "committedDate": "2020-12-30T23:29:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2MjU1Mw==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550362553", "bodyText": "nit: Might be worth having a constructor overload for empty completion handles", "author": "Sushisource", "createdAt": "2020-12-31T00:17:31Z", "path": "temporal-sdk/src/main/java/io/temporal/internal/worker/LocalActivityWorker.java", "diffHunk": "@@ -220,7 +220,8 @@ public Throwable wrapFailure(Task task, Throwable failure) {\n       metricsScope.counter(MetricsType.LOCAL_ACTIVITY_TOTAL_COUNTER).inc(1);\n \n       Stopwatch sw = metricsScope.timer(MetricsType.LOCAL_ACTIVITY_EXECUTION_LATENCY).start();\n-      ActivityTaskHandler.Result result = handler.handle(activityTask.build(), metricsScope, true);\n+      ActivityTaskHandler.Result result =\n+          handler.handle(new ActivityTask(activityTask.build(), () -> {}), metricsScope, true);", "originalCommit": "7a77f55d6b47b97b2ac6807068b1357421d26110", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM3Nzk5Mw==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550377993", "bodyText": "I don't think this warrants a separate constructor. Would prefer to keep as is.", "author": "vitarb", "createdAt": "2020-12-31T02:17:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2MjU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM2MjgzOA==", "url": "https://github.com/temporalio/sdk-java/pull/291#discussion_r550362838", "bodyText": "nit: Constructor overload might be nice for these Result types as well, looks like they're frequently constructed w/ a bunch of empty params.", "author": "Sushisource", "createdAt": "2020-12-31T00:19:29Z", "path": "temporal-sdk/src/test/java/io/temporal/internal/statemachines/LocalActivityStateMachineTest.java", "diffHunk": "@@ -172,7 +172,8 @@ protected void buildWorkflow(AsyncWorkflowBuilder<Void> builder) {\n               RespondActivityTaskCompletedRequest.newBuilder().setResult(result2).build(),\n               null,\n               null,\n-              null);\n+              null,", "originalCommit": "7a77f55d6b47b97b2ac6807068b1357421d26110", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}