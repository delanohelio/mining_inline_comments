{"pr_number": 145, "pr_title": "Query Verification: Implemented td verification", "pr_createdAt": "2020-08-11T22:22:27Z", "pr_url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145", "timeline": [{"oid": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "message": "Implemented td verification", "committedDate": "2020-08-11T22:15:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODMyNA==", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468898324", "bodyText": "Maybe have some comments to explain why not starting with 0", "author": "yzhvictor", "createdAt": "2020-08-11T22:24:10Z", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {", "originalCommit": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyODAyMg==", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r470728022", "bodyText": "Updated. The reason was that ResultSet column indexes start at 1 instead of 0", "author": "krishsuchdev", "createdAt": "2020-08-14T16:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODczMw==", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468898733", "bodyText": "Do we need to close this stream?", "author": "yzhvictor", "createdAt": "2020-08-11T22:25:09Z", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");", "originalCommit": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5ODg5NQ==", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468898895", "bodyText": "use String.format(...)", "author": "yzhvictor", "createdAt": "2020-08-11T22:25:31Z", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";", "originalCommit": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5OTE2Mw==", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468899163", "bodyText": "Can just be List", "author": "yzhvictor", "createdAt": "2020-08-11T22:26:13Z", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";\n+\n+                    statement += tableReference.get(\"datasetId\").getAsString() + \".\" + tableReference.get(\"tableId\").getAsString() + \" (\";\n+\n+                    // Generate column syntax for each field provided in JSON\n+                    ArrayList<String> columns = new ArrayList<String>();", "originalCommit": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5OTI2Mw==", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468899263", "bodyText": "Use StringBuilder and append?", "author": "yzhvictor", "createdAt": "2020-08-11T22:26:32Z", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";\n+\n+                    statement += tableReference.get(\"datasetId\").getAsString() + \".\" + tableReference.get(\"tableId\").getAsString() + \" (\";\n+\n+                    // Generate column syntax for each field provided in JSON\n+                    ArrayList<String> columns = new ArrayList<String>();\n+                    for (JsonElement fieldElement : schemaObject.getAsJsonArray(\"fields\")) {\n+                        JsonObject field = fieldElement.getAsJsonObject();\n+\n+                        // Assemble column syntax\n+                        String column = field.get(\"name\").getAsString() + \" \" + field.get(\"type\").getAsString();", "originalCommit": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5OTM4MQ==", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468899381", "bodyText": "StringBuilder instead?", "author": "yzhvictor", "createdAt": "2020-08-11T22:26:51Z", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";", "originalCommit": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNjg2MQ==", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468936861", "bodyText": "This isn't going to work if there's semicolons in quotes I think. Can you add a comment noting this?", "author": "Luminarys", "createdAt": "2020-08-12T00:26:09Z", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());", "originalCommit": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyODc4Mw==", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r470728783", "bodyText": "That's true, updated", "author": "krishsuchdev", "createdAt": "2020-08-14T16:28:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNjg2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODkzNzA5Nw==", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/pull/145#discussion_r468937097", "bodyText": "You can use inferred types here, i.e. new ArrayList<>();", "author": "Luminarys", "createdAt": "2020-08-12T00:26:56Z", "path": "tools/query_verification/src/main/java/com/google/bigquery/TeradataManager.java", "diffHunk": "@@ -0,0 +1,364 @@\n+package com.google.bigquery;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+import java.io.BufferedReader;\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.sql.*;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Class to communicate with TD to create tables and run queries using the JDBC driver.\n+ */\n+public class TeradataManager implements DataWarehouseManager {\n+\n+    private final QueryVerificationQuery query;\n+    private final QueryVerificationSchema schema;\n+    private final List<QueryVerificationData> data;\n+\n+    private Statement statementConnection;\n+    private Connection csvConnection;\n+\n+    public TeradataManager(QueryVerificationQuery query, QueryVerificationSchema schema, List<QueryVerificationData> data) {\n+        this.query = query;\n+        this.schema = schema;\n+        this.data = data;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"Teradata\";\n+    }\n+\n+    /**\n+     * Sends query jobs to TD\n+     * @return List of query results\n+     * @throws Exception\n+     */\n+    @Override\n+    public List<QueryJobResults> runQueries() throws Exception {\n+        setupConnection();\n+\n+        List<String> tables = createTablesFromSchema();\n+        populateTablesFromData();\n+\n+        // Create query jobs\n+        List<String> statements = getStatementsFromQuery();\n+\n+        // Store results from every job\n+        List<QueryJobResults> jobResults = new ArrayList<QueryJobResults>();\n+\n+        for (int i = 0; i < statements.size(); i++) {\n+            String statement = statements.get(i);\n+\n+            QueryJobResults jobResult;\n+            try {\n+                // Run query job\n+                ResultSet resultSet = statementConnection.executeQuery(statement);\n+\n+                // Parse and store query results\n+                List<List<String>> rawResults = new ArrayList<List<String>>();\n+                Set<List<Object>> results = new HashSet<List<Object>>();\n+                ResultSetMetaData resultSetMetaData = resultSet.getMetaData();\n+\n+                while (resultSet.next()) {\n+                    List<String> rowRawResults = new ArrayList<String>();\n+                    for (int j = 1; j <= resultSetMetaData.getColumnCount(); j++) {\n+                        rowRawResults.add(resultSet.getString(j));\n+                    }\n+                    rawResults.add(rowRawResults);\n+                    results.add(parseResults(resultSet, resultSetMetaData));\n+                }\n+\n+                jobResult = QueryJobResults.create(statement, query, null, results, rawResults);\n+            } catch (SQLException e) {\n+                // Print out errors returned from TD\n+                jobResult = QueryJobResults.create(statement, query, e.getMessage(), null, null);\n+            }\n+\n+            // Store results\n+            jobResults.add(jobResult);\n+        }\n+\n+        // Clear tables created\n+        tables.forEach(this::deleteTable);\n+\n+        closeConnection();\n+\n+        return jobResults;\n+    }\n+\n+    /**\n+     * Reads connection properties to TD database from config file\n+     * @return databaseServerName, username, password\n+     */\n+    private String[] getConnectionPropertiesFromConfigFile() {\n+        InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream(\"config.json\");\n+        String configContents = new BufferedReader(new InputStreamReader(inputStream)).lines().collect(Collectors.joining(\"\\n\"));\n+\n+        JsonObject configJson = JsonParser.parseString(configContents).getAsJsonObject();\n+        JsonObject tdJsonObject = configJson.getAsJsonObject(getName().toLowerCase());\n+\n+        String[] connectionProperties = new String[3];\n+        connectionProperties[0] = tdJsonObject.get(\"databaseServerName\").getAsString();\n+        connectionProperties[1] = tdJsonObject.get(\"username\").getAsString();\n+        connectionProperties[2] = tdJsonObject.get(\"password\").getAsString();\n+\n+        if (connectionProperties[0].isEmpty()) {\n+            throw new IllegalArgumentException(\"Please enter the \" + getName() + \" database server name and credentials in config.json\");\n+        }\n+\n+        return connectionProperties;\n+    }\n+\n+    /**\n+     * Establishes a connection to the TD database\n+     */\n+    private void setupConnection() {\n+        try {\n+            String[] connectionProperties = getConnectionPropertiesFromConfigFile();\n+            String url = \"jdbc:teradata://\" + connectionProperties[0] + \"/TMODE=ANSI,CHARSET=UTF8\";\n+            String user = connectionProperties[1];\n+            String password = connectionProperties[2];\n+\n+            // Create connection for running queries\n+            Connection connection = DriverManager.getConnection(url, user, password);\n+            statementConnection = connection.createStatement();\n+\n+            // Create connection for uploading CSV files\n+            csvConnection = DriverManager.getConnection(url + \",TYPE=FASTLOADCSV\", user, password);\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    /**\n+     * Closes the connection to the TD database\n+     */\n+    private void closeConnection() {\n+        try {\n+            statementConnection.close();\n+        } catch (SQLException throwables) {\n+            throwables.printStackTrace();\n+        }\n+    }\n+\n+    public List<String> getStatementsFromQuery() {\n+        return Arrays.stream(query.query().split(\";\")).map(String::trim).filter(statement -> !statement.isEmpty()).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Creates TD tables based on the provided schema\n+     * @return List of newly created tables\n+     */\n+    public List<String> createTablesFromSchema() throws IllegalArgumentException {\n+        List<String> tables = new ArrayList<String>();\n+\n+        if (schema != null) {\n+            String ddlSchema;\n+            if (schema.isInJsonFormat()) {\n+                // Schema is JSON\n+                ddlSchema = String.join(\";\\n\", generateDdlStatementsFromJsonSchema());\n+            } else {\n+                // Schema is DDL\n+                ddlSchema = schema.schema();\n+            }\n+            try {\n+                statementConnection.executeUpdate(ddlSchema);\n+            } catch (SQLException e) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted. \" + e.getMessage());\n+            }\n+\n+            tables = getTablesFromDdlSchema();\n+\n+            if (tables.isEmpty()) {\n+                throw new IllegalArgumentException(schema.path() + \" is not correctly formatted.\");\n+            }\n+        }\n+\n+        return tables;\n+    }\n+\n+    /**\n+     * Reads JSON schema to generate equivalent DDL statements\n+     * @return List of DDL statements\n+     */\n+    public List<String> generateDdlStatementsFromJsonSchema() {\n+        List<String> ddlStatements = new ArrayList<String>();\n+        for (JsonElement schemaElement : schema.getJsonArray()) {\n+            if (schema.getJsonArray().size() == 0) {\n+                return null;\n+            }\n+            JsonObject schemaObject = schemaElement.getAsJsonObject();\n+\n+            if (schemaObject.has(\"tableReference\")) {\n+                JsonObject tableReference = schemaObject.get(\"tableReference\").getAsJsonObject();\n+\n+                if (tableReference.has(\"datasetId\") && tableReference.has(\"tableId\")) {\n+                    String statement = \"CREATE TABLE \";\n+\n+                    statement += tableReference.get(\"datasetId\").getAsString() + \".\" + tableReference.get(\"tableId\").getAsString() + \" (\";\n+\n+                    // Generate column syntax for each field provided in JSON\n+                    ArrayList<String> columns = new ArrayList<String>();", "originalCommit": "f8cbb55af6c9a15e5f0b18d6126a02c6ddca084f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1a875bdafffd454dab3d634ffe14832136f62391", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/1a875bdafffd454dab3d634ffe14832136f62391", "message": "Merge branch 'master' into td", "committedDate": "2020-08-14T14:56:20Z", "type": "commit"}, {"oid": "2fe279cf4e5210501be8ab8f84403ab70b52c620", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/2fe279cf4e5210501be8ab8f84403ab70b52c620", "message": "Fix query job results builder", "committedDate": "2020-08-14T15:05:54Z", "type": "commit"}, {"oid": "6e947cbff25af7f0d1990f71990539afd543f8b9", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/6e947cbff25af7f0d1990f71990539afd543f8b9", "message": "Add decimal precision", "committedDate": "2020-08-14T15:06:25Z", "type": "commit"}, {"oid": "62ec042b5f725fef29704fcd257b20e29e63bd68", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/62ec042b5f725fef29704fcd257b20e29e63bd68", "message": "Updates on generating ddl statements", "committedDate": "2020-08-14T16:23:22Z", "type": "commit"}, {"oid": "5e76263286423970d54468d2e5af6f568d84ebfd", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/5e76263286423970d54468d2e5af6f568d84ebfd", "message": "Update tests", "committedDate": "2020-08-14T21:57:39Z", "type": "commit"}, {"oid": "cd5cb35854e089886316aa3e9e83d3a3c66ee239", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/cd5cb35854e089886316aa3e9e83d3a3c66ee239", "message": "Update README", "committedDate": "2020-08-14T21:57:58Z", "type": "commit"}, {"oid": "07f9f335e8806d85220b05a3ba96ba041cb56940", "url": "https://github.com/GoogleCloudPlatform/bigquery-utils/commit/07f9f335e8806d85220b05a3ba96ba041cb56940", "message": "Merge branch 'master' into td", "committedDate": "2020-08-14T22:00:40Z", "type": "commit"}]}