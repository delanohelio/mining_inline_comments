{"pr_number": 13431, "pr_title": "[WFLY-13699] Integration tests for Elytron distributed-realm", "pr_createdAt": "2020-07-28T07:00:46Z", "pr_url": "https://github.com/wildfly/wildfly/pull/13431", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3MjI1OQ==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r462172259", "bodyText": "The import ordering seems off here, all static imports should be in a block of their own at the start.", "author": "darranl", "createdAt": "2020-07-29T09:40:38Z", "path": "testsuite/integration/elytron/src/test/java/org/wildfly/test/integration/elytron/realm/DistributedRealmTestCase.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat Middleware LLC, and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+package org.wildfly.test.integration.elytron.realm;\n+\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URISyntaxException;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;", "originalCommit": "b6394b553cfd24292f5b2f901759e1e3b1569711", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA4Mzk1Nw==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r463083957", "bodyText": "Fixed, thanks.", "author": "OndrejKotek", "createdAt": "2020-07-30T15:31:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3MjI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NDM5OQ==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r462174399", "bodyText": "Not directly related to this PR so not a request to change anything.\nWe end up using these builders in many places, it starts to feel like maybe they should be developed in a module adjacent to the subsystem in WildFly Core so as resources are maintained the test builders can also be maintained.", "author": "darranl", "createdAt": "2020-07-29T09:44:24Z", "path": "testsuite/shared/src/main/java/org/wildfly/test/security/common/elytron/LdapRealm.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.wildfly.test.security.common.elytron;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.jboss.as.controller.PathAddress;\n+import org.jboss.as.controller.PathElement;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.operations.common.Util;\n+import org.jboss.as.test.integration.management.util.CLIWrapper;\n+import org.jboss.as.test.integration.security.common.Utils;\n+import org.jboss.dmr.ModelNode;\n+\n+/**\n+ * A {@link ConfigurableElement} to define the ldap-realm resource within the Elytron subsystem.\n+ *\n+ * @author Ondrej Kotek\n+ */\n+public class LdapRealm implements SecurityRealm {", "originalCommit": "b6394b553cfd24292f5b2f901759e1e3b1569711", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwNzU2MA==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r463107560", "bodyText": "It seems the builders grow enough with new tests, I don't see many maintenance commits: https://github.com/wildfly/wildfly/commits/master/testsuite/shared/src/main/java/org/wildfly/test/security/common/elytron\nHave you noticed any issues with this approach?", "author": "OndrejKotek", "createdAt": "2020-07-30T16:06:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NDM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjAwOA==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r462176008", "bodyText": "Other tests in the project are not a good example to go by.\nOne issue I have is in two years time something may happen and suddenly we have a failing test in CI, where a test relies on multiple resources potentially \"engineered\" to behave in a certain way it can often be time consuming to try and reverse engineer the original intent of the test before getting to the failure itself.\nA javadoc comment describing the general relationship of resources under test would certainly help a lot.\nI am not marking this as requesting changes but if you did have time that would be great.", "author": "darranl", "createdAt": "2020-07-29T09:47:13Z", "path": "testsuite/integration/elytron/src/test/java/org/wildfly/test/integration/elytron/realm/DistributedRealmTestCase.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat Middleware LLC, and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+package org.wildfly.test.integration.elytron.realm;\n+\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URISyntaxException;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.Base64.Encoder;\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+import static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.util.EntityUtils;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.container.test.api.OperateOnDeployment;\n+import org.jboss.arquillian.container.test.api.RunAsClient;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.as.arquillian.api.ServerSetup;\n+import org.jboss.as.test.integration.security.common.Utils;\n+import static org.jboss.as.test.integration.security.common.Utils.REDIRECT_STRATEGY;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.asset.StringAsset;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.wildfly.test.security.common.AbstractElytronSetupTask;\n+import org.wildfly.test.security.common.elytron.ConfigurableElement;\n+import org.wildfly.test.security.common.elytron.DirContext;\n+import org.wildfly.test.security.common.elytron.DistributedRealm;\n+import org.wildfly.test.security.common.elytron.LdapRealm;\n+import org.wildfly.test.security.common.elytron.MechanismConfiguration;\n+import org.wildfly.test.security.common.elytron.PropertiesRealm;\n+import org.wildfly.test.security.common.elytron.SimpleHttpAuthenticationFactory;\n+import org.wildfly.test.security.common.elytron.SimpleSecurityDomain;\n+import org.wildfly.test.security.common.elytron.TokenRealm;\n+import org.wildfly.test.security.common.elytron.UserWithAttributeValues;\n+import org.wildfly.test.undertow.common.UndertowApplicationSecurityDomain;\n+\n+/**\n+ * Tests the {@link DistributedRealm} within the Elytron subsystem.\n+ *\n+ * @author Ondrej Kotek\n+ */\n+@RunWith(Arquillian.class)\n+@RunAsClient\n+@ServerSetup({DistributedRealmTestCase.ServerSetup.class})\n+public class DistributedRealmTestCase {", "originalCommit": "b6394b553cfd24292f5b2f901759e1e3b1569711", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA4Nzk0MQ==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r463087941", "bodyText": "I added the general javadoc comment and several comments to the code to make it clear. I appreciate further feedback.", "author": "OndrejKotek", "createdAt": "2020-07-30T15:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjE3NjAwOA=="}], "type": "inlineReview"}, {"oid": "62c1483e0f25d094fed69cc5927977dcdaeaa390", "url": "https://github.com/wildfly/wildfly/commit/62c1483e0f25d094fed69cc5927977dcdaeaa390", "message": "[WFLY-13699] Integration tests for Elytron distributed-realm", "committedDate": "2020-07-30T15:29:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2Njc4Mg==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r465166782", "bodyText": "Just thinking whether it makes sense to move this method into the org.jboss.as.test.integration.security.common.Utils similarly as makeCallWithBasicAuthn is there.", "author": "jstourac", "createdAt": "2020-08-04T16:12:12Z", "path": "testsuite/integration/elytron/src/test/java/org/wildfly/test/integration/elytron/realm/DistributedRealmTestCase.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * JBoss, Home of Professional Open Source.\n+ * Copyright 2020, Red Hat Middleware LLC, and individual contributors\n+ * as indicated by the @author tags. See the copyright.txt file in the\n+ * distribution for a full listing of individual contributors.\n+ *\n+ * This is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as\n+ * published by the Free Software Foundation; either version 2.1 of\n+ * the License, or (at your option) any later version.\n+ *\n+ * This software is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this software; if not, write to the Free\n+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n+ * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n+ */\n+package org.wildfly.test.integration.elytron.realm;\n+\n+\n+import static javax.servlet.http.HttpServletResponse.SC_INTERNAL_SERVER_ERROR;\n+import static javax.servlet.http.HttpServletResponse.SC_OK;\n+import static javax.servlet.http.HttpServletResponse.SC_UNAUTHORIZED;\n+import static org.jboss.as.test.integration.security.common.Utils.REDIRECT_STRATEGY;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.Base64.Encoder;\n+import org.apache.http.Header;\n+import org.apache.http.HttpEntity;\n+import org.apache.http.HttpResponse;\n+import org.apache.http.client.ClientProtocolException;\n+import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.util.EntityUtils;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.arquillian.container.test.api.OperateOnDeployment;\n+import org.jboss.arquillian.container.test.api.RunAsClient;\n+import org.jboss.arquillian.junit.Arquillian;\n+import org.jboss.arquillian.test.api.ArquillianResource;\n+import org.jboss.as.arquillian.api.ServerSetup;\n+import org.jboss.as.test.integration.security.common.Utils;\n+import org.jboss.shrinkwrap.api.ShrinkWrap;\n+import org.jboss.shrinkwrap.api.asset.StringAsset;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.wildfly.test.security.common.AbstractElytronSetupTask;\n+import org.wildfly.test.security.common.elytron.ConfigurableElement;\n+import org.wildfly.test.security.common.elytron.DirContext;\n+import org.wildfly.test.security.common.elytron.DistributedRealm;\n+import org.wildfly.test.security.common.elytron.LdapRealm;\n+import org.wildfly.test.security.common.elytron.MechanismConfiguration;\n+import org.wildfly.test.security.common.elytron.PropertiesRealm;\n+import org.wildfly.test.security.common.elytron.SimpleHttpAuthenticationFactory;\n+import org.wildfly.test.security.common.elytron.SimpleSecurityDomain;\n+import org.wildfly.test.security.common.elytron.TokenRealm;\n+import org.wildfly.test.security.common.elytron.UserWithAttributeValues;\n+import org.wildfly.test.undertow.common.UndertowApplicationSecurityDomain;\n+\n+/**\n+ * Tests the {@link DistributedRealm} within the Elytron subsystem. The tests cover both the credential and evidence\n+ * based authn, trying all identities distributed among the realms backing a distributed-realm by invoking deployed applications.\n+ *\n+ * For the credential based authn testing, there are three properties-realm containing identities with corresponding numbers.\n+ * For the evidence based authn testing, there are two JWT token-realm that differ in accepted issuers.\n+ * To test the ability to distinguish between the authn types, these realms are mixed into one distributed-realm\n+ * that backs secured deployments for both the authn types testing (BASIC and BEARER_TOKEN methods are used).\n+ *\n+ * To test the behavior when a realm is not available, there is also a deployment backed by a distributed-realm with\n+ * an unavailable LDAP realm among the properties-realm.\n+ *\n+ * @author Ondrej Kotek\n+ */\n+@RunWith(Arquillian.class)\n+@RunAsClient\n+@ServerSetup({DistributedRealmTestCase.ServerSetup.class})\n+public class DistributedRealmTestCase {\n+\n+    private static final String DEPLOYMENT_FOR_CREDENTIALS = \"DistributedRealmDeployment-Credentials\";\n+    private static final String DEPLOYMENT_FOR_EVIDENCE = \"DistributedRealmDeployment-Evidence\";\n+    private static final String DEPLOYMENT_FOR_UNAVAILABLE_REALM = \"DistributedRealmDeployment-UnavailableRealm\";\n+    private static final String INDEX_PAGE_CONTENT = \"index page content\";\n+\n+    private static final Encoder B64_ENCODER = Base64.getUrlEncoder().withoutPadding();\n+    private static final String JWT_HEADER_B64 = B64_ENCODER\n+            .encodeToString(\"{\\\"alg\\\":\\\"none\\\",\\\"typ\\\":\\\"JWT\\\"}\".getBytes(StandardCharsets.UTF_8));\n+    private static final String JWT_ISSUER_1 = \"issuer1.wildfly.org\";\n+    private static final String JWT_ISSUER_2 = \"issuer2.wildfly.org\";\n+\n+    @Deployment(name = DEPLOYMENT_FOR_CREDENTIALS)\n+    public static WebArchive deployment() {\n+        return deployment(DEPLOYMENT_FOR_CREDENTIALS, \"distributed-realm-web.xml\");\n+    }\n+\n+    @Deployment(name = DEPLOYMENT_FOR_EVIDENCE)\n+    public static WebArchive deploymentForEvidence() {\n+        return deployment(DEPLOYMENT_FOR_EVIDENCE, \"distributed-realm-bearer-token-web.xml\");\n+    }\n+\n+    @Deployment(name = DEPLOYMENT_FOR_UNAVAILABLE_REALM)\n+    public static WebArchive deploymentForUnavailableRealm() {\n+        return deployment(DEPLOYMENT_FOR_UNAVAILABLE_REALM, \"distributed-realm-web.xml\");\n+    }\n+\n+    private static WebArchive deployment(String name, String webXml) {\n+        final WebArchive war = ShrinkWrap.create(WebArchive.class, name + \".war\");\n+        war.add(new StringAsset(INDEX_PAGE_CONTENT), \"index.html\");\n+        war.addAsWebInfResource(DistributedRealmTestCase.class.getPackage(), webXml, \"web.xml\");\n+        war.addAsWebInfResource(Utils.getJBossWebXmlAsset(name), \"jboss-web.xml\");\n+        return war;\n+    }\n+\n+    @Test\n+    @OperateOnDeployment(DEPLOYMENT_FOR_CREDENTIALS)\n+    public void testIdentityPerRealm_Success(@ArquillianResource URL webAppUrl) throws Exception {\n+        String result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user1\", \"password1\", SC_OK);\n+        assertEquals(INDEX_PAGE_CONTENT, result);\n+\n+        result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user2\", \"password2\", SC_OK);\n+        assertEquals(INDEX_PAGE_CONTENT, result);\n+\n+        result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user3\", \"password3\", SC_OK);\n+        assertEquals(INDEX_PAGE_CONTENT, result);\n+    }\n+\n+    @Test\n+    @OperateOnDeployment(DEPLOYMENT_FOR_CREDENTIALS)\n+    public void testIdentityPerRealm_WrongPassword(@ArquillianResource URL webAppUrl) throws Exception {\n+        String result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user1\", \"wrongPassword1\", SC_UNAUTHORIZED);\n+        assertNotEquals(INDEX_PAGE_CONTENT, result);\n+\n+        result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user2\", \"wrongPassword2\", SC_UNAUTHORIZED);\n+        assertNotEquals(INDEX_PAGE_CONTENT, result);\n+\n+        result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user3\", \"wrongPassword3\", SC_UNAUTHORIZED);\n+        assertNotEquals(INDEX_PAGE_CONTENT, result);\n+    }\n+\n+    @Test\n+    @OperateOnDeployment(DEPLOYMENT_FOR_CREDENTIALS)\n+    public void testWrongUserName(@ArquillianResource URL webAppUrl) throws Exception {\n+        String result = Utils.makeCallWithBasicAuthn(webAppUrl, \"non-existing-user1\", \"password1\", SC_UNAUTHORIZED);\n+        assertNotEquals(INDEX_PAGE_CONTENT, result);\n+    }\n+\n+    @Test\n+    @OperateOnDeployment(DEPLOYMENT_FOR_CREDENTIALS)\n+    public void testIdentityInTwoRealms_FirstRealmUsed(@ArquillianResource URL webAppUrl) throws Exception {\n+        String result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user12\", \"passwordInRealm1\", SC_OK);\n+        assertEquals(INDEX_PAGE_CONTENT, result);\n+\n+        result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user12\", \"passwordInRealm2\", SC_UNAUTHORIZED);\n+        assertNotEquals(INDEX_PAGE_CONTENT, result);\n+    }\n+\n+    @Test\n+    @OperateOnDeployment(DEPLOYMENT_FOR_UNAVAILABLE_REALM)\n+    public void testIdentityPerRealm_UnavailableRealm(@ArquillianResource URL webAppUrl) throws Exception {\n+        // user1 and user2 are in the realms that are before  the unavailable realm\n+        String result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user1\", \"password1\", SC_OK);\n+        assertEquals(INDEX_PAGE_CONTENT, result);\n+        result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user2\", \"password2\", SC_OK);\n+        assertEquals(INDEX_PAGE_CONTENT, result);\n+\n+        // user3 is in the realm that is after the unavailable realm\n+        result = Utils.makeCallWithBasicAuthn(webAppUrl, \"user3\", \"password3\", SC_INTERNAL_SERVER_ERROR);\n+        assertNotEquals(INDEX_PAGE_CONTENT, result);\n+    }\n+\n+    @Test\n+    @OperateOnDeployment(DEPLOYMENT_FOR_EVIDENCE)\n+    public void testIdentityPerRealm_Evidence(@ArquillianResource URL webAppUrl) throws Exception {\n+        try (CloseableHttpClient httpClient = HttpClientBuilder.create().setRedirectStrategy(REDIRECT_STRATEGY).build()) {\n+            String result = doHttpRequestTokenAuthn(httpClient, webAppUrl, createJwtToken(\"userA\", JWT_ISSUER_1), SC_OK);\n+            assertEquals(INDEX_PAGE_CONTENT, result);\n+\n+            result = doHttpRequestTokenAuthn(httpClient, webAppUrl, createJwtToken(\"userB\", JWT_ISSUER_2), SC_OK);\n+            assertEquals(INDEX_PAGE_CONTENT, result);\n+\n+            result = doHttpRequestTokenAuthn(httpClient, webAppUrl, createJwtToken(\"userC\", \"unknown_issuer\"), SC_UNAUTHORIZED);\n+            assertNotEquals(INDEX_PAGE_CONTENT, result);\n+        }\n+    }\n+\n+    private String createJwtToken(String userName, String issuer) {\n+        String jwtPayload = String.format(\"{\" //\n+                + \"\\\"iss\\\": \\\"%1$s\\\",\" //\n+                + \"\\\"sub\\\": \\\"elytron@wildfly.org\\\",\" //\n+                + \"\\\"exp\\\": 2051222399,\" //\n+                + \"\\\"aud\\\": \\\"%1$s\\\",\" //\n+                + \"\\\"groups\\\": [\\\"%2$s\\\"]\" //\n+                + \"}\", issuer, userName);\n+        return JWT_HEADER_B64 + \".\" + B64_ENCODER.encodeToString(jwtPayload.getBytes(StandardCharsets.UTF_8)) + \".\";\n+    }\n+\n+    /**\n+     * Do HTTP request using given client with BEARER_TOKEN authentication. The implementation makes 2 calls - the first without\n+     * Authorization header provided (just to check response code and WWW-Authenticate header value), the second with\n+     * Authorization header.\n+     *\n+     * @param httpClient client instance\n+     * @param url URL to make request to\n+     * @param token bearer token\n+     * @param expectedStatusCode expected status code\n+     * @return response body\n+     */\n+    private String doHttpRequestTokenAuthn(final CloseableHttpClient httpClient, final URL url, String token,", "originalCommit": "62c1483e0f25d094fed69cc5927977dcdaeaa390", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MTYyOQ==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r467041629", "bodyText": "Agree, I will use the same method in the next test case for the Elytron failover-realm. Moved.", "author": "OndrejKotek", "createdAt": "2020-08-07T13:31:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE2Njc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMDQ1NQ==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r465910455", "bodyText": "should be probably x509CredentialMapper.getDigestAlgorithm() instead", "author": "jstourac", "createdAt": "2020-08-05T18:08:23Z", "path": "testsuite/shared/src/main/java/org/wildfly/test/security/common/elytron/LdapRealm.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.wildfly.test.security.common.elytron;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.jboss.as.controller.PathAddress;\n+import org.jboss.as.controller.PathElement;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.operations.common.Util;\n+import org.jboss.as.test.integration.management.util.CLIWrapper;\n+import org.jboss.as.test.integration.security.common.Utils;\n+import org.jboss.dmr.ModelNode;\n+\n+/**\n+ * A {@link ConfigurableElement} to define the ldap-realm resource within the Elytron subsystem.\n+ *\n+ * @author Ondrej Kotek\n+ */\n+public class LdapRealm implements SecurityRealm {\n+\n+    private final PathAddress address;\n+    private final String name;\n+    private final String dirContext;\n+    private final Boolean directVerification;\n+    private final Boolean allowBlankPassword;\n+    private final IdentityMapping identityMapping;\n+\n+    LdapRealm(Builder builder) {\n+        this.name = builder.name;\n+        this.address = PathAddress.pathAddress(PathElement.pathElement(\"subsystem\", \"elytron\"), PathElement.pathElement(\"ldap-realm\", name));\n+        this.dirContext = builder.dirContext;\n+        this.directVerification = builder.directVerification;\n+        this.allowBlankPassword = builder.allowBlankPassword;\n+        this.identityMapping = builder.identityMapping;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public ModelNode getAddOperation() {\n+        ModelNode addOperation = Util.createAddOperation(address);\n+        addOperation.get(\"ldap-realm\");\n+        if (dirContext != null) {\n+            addOperation.get(\"dir-context\").set(dirContext);\n+        }\n+        if (directVerification != null) {\n+            addOperation.get(\"direct-verification\").set(directVerification);\n+        }\n+        if (allowBlankPassword != null) {\n+            addOperation.get(\"allow-blank-password\").set(allowBlankPassword);\n+        }\n+        if (identityMapping != null) {\n+            addOperation.get(\"identity-mapping\").set(getIdentityMappingModel().asObject());\n+        }\n+\n+        return addOperation;\n+    }\n+\n+    private ModelNode getIdentityMappingModel() {\n+        ModelNode identityMappingModelNode = new ModelNode();\n+        if (!identityMapping.getAttributeMappings().isEmpty()) {\n+            List<ModelNode> attributeMappingNodeList = new ArrayList<ModelNode>();\n+            for (AttributeMapping attributeMapping : identityMapping.getAttributeMappings()) {\n+                ModelNode node = new ModelNode();\n+                if (attributeMapping.getFrom() != null) {\n+                    node.add(\"from\", attributeMapping.getFrom());\n+                }\n+                if (attributeMapping.getTo() != null) {\n+                    node.add(\"to\", attributeMapping.getTo());\n+                }\n+                if (attributeMapping.getFilter() != null) {\n+                    node.add(\"filter\", attributeMapping.getFilter());\n+                }\n+                if (attributeMapping.getFilterBaseDn() != null) {\n+                    node.add(\"filter-base-dn\", attributeMapping.getFilterBaseDn());\n+                }\n+                if (attributeMapping.getExtractRdn() != null) {\n+                    node.add(\"extract-rdn\", attributeMapping.getExtractRdn());\n+                }\n+                if (attributeMapping.getSearchRecursive() != null) {\n+                    node.add(\"search-recursive\", attributeMapping.getSearchRecursive());\n+                }\n+                if (attributeMapping.getRoleRecursion() != null) {\n+                    node.add(\"role-recursion\", attributeMapping.getRoleRecursion());\n+                }\n+                if (attributeMapping.getRoleRecursionName() != null) {\n+                    node.add(\"role-recursion-name\", attributeMapping.getRoleRecursionName());\n+                }\n+                if (attributeMapping.getReference() != null) {\n+                    node.add(\"reference\", attributeMapping.getReference());\n+                }\n+                attributeMappingNodeList.add(node.asObject());\n+            }\n+            ModelNode attributeMappingNode = new ModelNode();\n+            attributeMappingNode.set(attributeMappingNodeList);\n+            identityMappingModelNode.add(\"attribute-mapping\", attributeMappingNode);\n+        }\n+        if (identityMapping.getFilterName() != null) {\n+            identityMappingModelNode.add(\"filter-name\", identityMapping.getFilterName());\n+        }\n+        if (identityMapping.getIteratorFilter() != null) {\n+            identityMappingModelNode.add(\"iterator-filter\", identityMapping.getIteratorFilter());\n+        }\n+        if (!identityMapping.getNewIdentityAttributes().isEmpty()) {\n+            List<ModelNode> newIdentityAttributesNodeList = new ArrayList<ModelNode>();\n+            for (NewIdentityAttributes newIdentityAttribute : identityMapping.getNewIdentityAttributes()) {\n+                ModelNode attributeNode = new ModelNode();\n+                if (newIdentityAttribute.getName() != null) {\n+                    attributeNode.add(\"name\", newIdentityAttribute.getName());\n+                }\n+\n+                ModelNode valuesList = new ModelNode().setEmptyList();\n+                for (String value : newIdentityAttribute.getValues()) {\n+                    valuesList.add(value);\n+                }\n+                attributeNode.add(\"value\", valuesList);\n+\n+                newIdentityAttributesNodeList.add(attributeNode.asObject());\n+            }\n+            ModelNode newIdentityAttributesNode = new ModelNode();\n+            newIdentityAttributesNode.set(newIdentityAttributesNodeList);\n+            identityMappingModelNode.add(\"new-identity-attributes\", newIdentityAttributesNode);\n+        }\n+        if (identityMapping.getNewIdentityParentDn() != null) {\n+            identityMappingModelNode.add(\"new-identity-parent-dn\", identityMapping.getNewIdentityParentDn());\n+        }\n+        if (identityMapping.getOtpCredentialMapper() != null) {\n+            OtpCredentialMapper otpCredentialMapper = identityMapping.getOtpCredentialMapper();\n+            ModelNode node = new ModelNode();\n+            node.add(\"algorithm-from\", otpCredentialMapper.getAlgorithmFrom());\n+            node.add(\"hash-from\", otpCredentialMapper.getHashFrom());\n+            node.add(\"seed-from\", otpCredentialMapper.getSeedFrom());\n+            node.add(\"sequence-from\", otpCredentialMapper.getSequenceFrom());\n+            identityMappingModelNode.add(\"otp-credential-mapper\", node.asObject());\n+        }\n+        if (identityMapping.getRdnIdentifier() != null) {\n+            identityMappingModelNode.add(\"rdn-identifier\", identityMapping.getRdnIdentifier());\n+        }\n+        if (identityMapping.getSearchBaseDn() != null) {\n+            identityMappingModelNode.add(\"search-base-dn\", identityMapping.getSearchBaseDn());\n+        }\n+        if (identityMapping.getUseRecursiveSearch() != null) {\n+            identityMappingModelNode.add(\"use-recursive-search\", identityMapping.getUseRecursiveSearch());\n+        }\n+        if (identityMapping.getUserPasswordMapper() != null) {\n+            UserPasswordMapper userPasswordMapper = identityMapping.getUserPasswordMapper();\n+            ModelNode node = new ModelNode();\n+            node.add(\"from\", userPasswordMapper.getFrom());\n+            if (userPasswordMapper.getWritable() != null) {\n+                node.add(\"writable\", userPasswordMapper.getWritable());\n+            }\n+            if (userPasswordMapper.getVerifiable() != null) {\n+                node.add(\"verifiable\", userPasswordMapper.getVerifiable());\n+            }\n+            identityMappingModelNode.add(\"user-password-mapper\", node.asObject());\n+        }\n+        if (identityMapping.getX509CredentialMapper() != null) {\n+            X509CredentialMapper x509CredentialMapper = identityMapping.getX509CredentialMapper();\n+            ModelNode node = new ModelNode();\n+            if (x509CredentialMapper.getDigestFrom() != null) {\n+                node.add(\"digest-from\", x509CredentialMapper.getDigestFrom());\n+            }\n+            if (x509CredentialMapper.getDigestFrom() != null) {", "originalCommit": "62c1483e0f25d094fed69cc5927977dcdaeaa390", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MTkzNQ==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r467041935", "bodyText": "Fixed, thanks!", "author": "OndrejKotek", "createdAt": "2020-08-07T13:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMDQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMDcwMg==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r465910702", "bodyText": "should be probably x509CredentialMapper.getCertificateFrom() instead", "author": "jstourac", "createdAt": "2020-08-05T18:08:52Z", "path": "testsuite/shared/src/main/java/org/wildfly/test/security/common/elytron/LdapRealm.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.wildfly.test.security.common.elytron;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.jboss.as.controller.PathAddress;\n+import org.jboss.as.controller.PathElement;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.operations.common.Util;\n+import org.jboss.as.test.integration.management.util.CLIWrapper;\n+import org.jboss.as.test.integration.security.common.Utils;\n+import org.jboss.dmr.ModelNode;\n+\n+/**\n+ * A {@link ConfigurableElement} to define the ldap-realm resource within the Elytron subsystem.\n+ *\n+ * @author Ondrej Kotek\n+ */\n+public class LdapRealm implements SecurityRealm {\n+\n+    private final PathAddress address;\n+    private final String name;\n+    private final String dirContext;\n+    private final Boolean directVerification;\n+    private final Boolean allowBlankPassword;\n+    private final IdentityMapping identityMapping;\n+\n+    LdapRealm(Builder builder) {\n+        this.name = builder.name;\n+        this.address = PathAddress.pathAddress(PathElement.pathElement(\"subsystem\", \"elytron\"), PathElement.pathElement(\"ldap-realm\", name));\n+        this.dirContext = builder.dirContext;\n+        this.directVerification = builder.directVerification;\n+        this.allowBlankPassword = builder.allowBlankPassword;\n+        this.identityMapping = builder.identityMapping;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public ModelNode getAddOperation() {\n+        ModelNode addOperation = Util.createAddOperation(address);\n+        addOperation.get(\"ldap-realm\");\n+        if (dirContext != null) {\n+            addOperation.get(\"dir-context\").set(dirContext);\n+        }\n+        if (directVerification != null) {\n+            addOperation.get(\"direct-verification\").set(directVerification);\n+        }\n+        if (allowBlankPassword != null) {\n+            addOperation.get(\"allow-blank-password\").set(allowBlankPassword);\n+        }\n+        if (identityMapping != null) {\n+            addOperation.get(\"identity-mapping\").set(getIdentityMappingModel().asObject());\n+        }\n+\n+        return addOperation;\n+    }\n+\n+    private ModelNode getIdentityMappingModel() {\n+        ModelNode identityMappingModelNode = new ModelNode();\n+        if (!identityMapping.getAttributeMappings().isEmpty()) {\n+            List<ModelNode> attributeMappingNodeList = new ArrayList<ModelNode>();\n+            for (AttributeMapping attributeMapping : identityMapping.getAttributeMappings()) {\n+                ModelNode node = new ModelNode();\n+                if (attributeMapping.getFrom() != null) {\n+                    node.add(\"from\", attributeMapping.getFrom());\n+                }\n+                if (attributeMapping.getTo() != null) {\n+                    node.add(\"to\", attributeMapping.getTo());\n+                }\n+                if (attributeMapping.getFilter() != null) {\n+                    node.add(\"filter\", attributeMapping.getFilter());\n+                }\n+                if (attributeMapping.getFilterBaseDn() != null) {\n+                    node.add(\"filter-base-dn\", attributeMapping.getFilterBaseDn());\n+                }\n+                if (attributeMapping.getExtractRdn() != null) {\n+                    node.add(\"extract-rdn\", attributeMapping.getExtractRdn());\n+                }\n+                if (attributeMapping.getSearchRecursive() != null) {\n+                    node.add(\"search-recursive\", attributeMapping.getSearchRecursive());\n+                }\n+                if (attributeMapping.getRoleRecursion() != null) {\n+                    node.add(\"role-recursion\", attributeMapping.getRoleRecursion());\n+                }\n+                if (attributeMapping.getRoleRecursionName() != null) {\n+                    node.add(\"role-recursion-name\", attributeMapping.getRoleRecursionName());\n+                }\n+                if (attributeMapping.getReference() != null) {\n+                    node.add(\"reference\", attributeMapping.getReference());\n+                }\n+                attributeMappingNodeList.add(node.asObject());\n+            }\n+            ModelNode attributeMappingNode = new ModelNode();\n+            attributeMappingNode.set(attributeMappingNodeList);\n+            identityMappingModelNode.add(\"attribute-mapping\", attributeMappingNode);\n+        }\n+        if (identityMapping.getFilterName() != null) {\n+            identityMappingModelNode.add(\"filter-name\", identityMapping.getFilterName());\n+        }\n+        if (identityMapping.getIteratorFilter() != null) {\n+            identityMappingModelNode.add(\"iterator-filter\", identityMapping.getIteratorFilter());\n+        }\n+        if (!identityMapping.getNewIdentityAttributes().isEmpty()) {\n+            List<ModelNode> newIdentityAttributesNodeList = new ArrayList<ModelNode>();\n+            for (NewIdentityAttributes newIdentityAttribute : identityMapping.getNewIdentityAttributes()) {\n+                ModelNode attributeNode = new ModelNode();\n+                if (newIdentityAttribute.getName() != null) {\n+                    attributeNode.add(\"name\", newIdentityAttribute.getName());\n+                }\n+\n+                ModelNode valuesList = new ModelNode().setEmptyList();\n+                for (String value : newIdentityAttribute.getValues()) {\n+                    valuesList.add(value);\n+                }\n+                attributeNode.add(\"value\", valuesList);\n+\n+                newIdentityAttributesNodeList.add(attributeNode.asObject());\n+            }\n+            ModelNode newIdentityAttributesNode = new ModelNode();\n+            newIdentityAttributesNode.set(newIdentityAttributesNodeList);\n+            identityMappingModelNode.add(\"new-identity-attributes\", newIdentityAttributesNode);\n+        }\n+        if (identityMapping.getNewIdentityParentDn() != null) {\n+            identityMappingModelNode.add(\"new-identity-parent-dn\", identityMapping.getNewIdentityParentDn());\n+        }\n+        if (identityMapping.getOtpCredentialMapper() != null) {\n+            OtpCredentialMapper otpCredentialMapper = identityMapping.getOtpCredentialMapper();\n+            ModelNode node = new ModelNode();\n+            node.add(\"algorithm-from\", otpCredentialMapper.getAlgorithmFrom());\n+            node.add(\"hash-from\", otpCredentialMapper.getHashFrom());\n+            node.add(\"seed-from\", otpCredentialMapper.getSeedFrom());\n+            node.add(\"sequence-from\", otpCredentialMapper.getSequenceFrom());\n+            identityMappingModelNode.add(\"otp-credential-mapper\", node.asObject());\n+        }\n+        if (identityMapping.getRdnIdentifier() != null) {\n+            identityMappingModelNode.add(\"rdn-identifier\", identityMapping.getRdnIdentifier());\n+        }\n+        if (identityMapping.getSearchBaseDn() != null) {\n+            identityMappingModelNode.add(\"search-base-dn\", identityMapping.getSearchBaseDn());\n+        }\n+        if (identityMapping.getUseRecursiveSearch() != null) {\n+            identityMappingModelNode.add(\"use-recursive-search\", identityMapping.getUseRecursiveSearch());\n+        }\n+        if (identityMapping.getUserPasswordMapper() != null) {\n+            UserPasswordMapper userPasswordMapper = identityMapping.getUserPasswordMapper();\n+            ModelNode node = new ModelNode();\n+            node.add(\"from\", userPasswordMapper.getFrom());\n+            if (userPasswordMapper.getWritable() != null) {\n+                node.add(\"writable\", userPasswordMapper.getWritable());\n+            }\n+            if (userPasswordMapper.getVerifiable() != null) {\n+                node.add(\"verifiable\", userPasswordMapper.getVerifiable());\n+            }\n+            identityMappingModelNode.add(\"user-password-mapper\", node.asObject());\n+        }\n+        if (identityMapping.getX509CredentialMapper() != null) {\n+            X509CredentialMapper x509CredentialMapper = identityMapping.getX509CredentialMapper();\n+            ModelNode node = new ModelNode();\n+            if (x509CredentialMapper.getDigestFrom() != null) {\n+                node.add(\"digest-from\", x509CredentialMapper.getDigestFrom());\n+            }\n+            if (x509CredentialMapper.getDigestFrom() != null) {\n+                node.add(\"digest-algorithm\", x509CredentialMapper.getDigestAlgorithm());\n+            }\n+            if (x509CredentialMapper.getDigestFrom() != null) {", "originalCommit": "62c1483e0f25d094fed69cc5927977dcdaeaa390", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MjAxNQ==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r467042015", "bodyText": "Fixed, thanks!", "author": "OndrejKotek", "createdAt": "2020-08-07T13:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMDcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMTI1MA==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r465911250", "bodyText": "should be probably x509CredentialMapper.getSerialNumberFrom() instead", "author": "jstourac", "createdAt": "2020-08-05T18:09:54Z", "path": "testsuite/shared/src/main/java/org/wildfly/test/security/common/elytron/LdapRealm.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.wildfly.test.security.common.elytron;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.jboss.as.controller.PathAddress;\n+import org.jboss.as.controller.PathElement;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.operations.common.Util;\n+import org.jboss.as.test.integration.management.util.CLIWrapper;\n+import org.jboss.as.test.integration.security.common.Utils;\n+import org.jboss.dmr.ModelNode;\n+\n+/**\n+ * A {@link ConfigurableElement} to define the ldap-realm resource within the Elytron subsystem.\n+ *\n+ * @author Ondrej Kotek\n+ */\n+public class LdapRealm implements SecurityRealm {\n+\n+    private final PathAddress address;\n+    private final String name;\n+    private final String dirContext;\n+    private final Boolean directVerification;\n+    private final Boolean allowBlankPassword;\n+    private final IdentityMapping identityMapping;\n+\n+    LdapRealm(Builder builder) {\n+        this.name = builder.name;\n+        this.address = PathAddress.pathAddress(PathElement.pathElement(\"subsystem\", \"elytron\"), PathElement.pathElement(\"ldap-realm\", name));\n+        this.dirContext = builder.dirContext;\n+        this.directVerification = builder.directVerification;\n+        this.allowBlankPassword = builder.allowBlankPassword;\n+        this.identityMapping = builder.identityMapping;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public ModelNode getAddOperation() {\n+        ModelNode addOperation = Util.createAddOperation(address);\n+        addOperation.get(\"ldap-realm\");\n+        if (dirContext != null) {\n+            addOperation.get(\"dir-context\").set(dirContext);\n+        }\n+        if (directVerification != null) {\n+            addOperation.get(\"direct-verification\").set(directVerification);\n+        }\n+        if (allowBlankPassword != null) {\n+            addOperation.get(\"allow-blank-password\").set(allowBlankPassword);\n+        }\n+        if (identityMapping != null) {\n+            addOperation.get(\"identity-mapping\").set(getIdentityMappingModel().asObject());\n+        }\n+\n+        return addOperation;\n+    }\n+\n+    private ModelNode getIdentityMappingModel() {\n+        ModelNode identityMappingModelNode = new ModelNode();\n+        if (!identityMapping.getAttributeMappings().isEmpty()) {\n+            List<ModelNode> attributeMappingNodeList = new ArrayList<ModelNode>();\n+            for (AttributeMapping attributeMapping : identityMapping.getAttributeMappings()) {\n+                ModelNode node = new ModelNode();\n+                if (attributeMapping.getFrom() != null) {\n+                    node.add(\"from\", attributeMapping.getFrom());\n+                }\n+                if (attributeMapping.getTo() != null) {\n+                    node.add(\"to\", attributeMapping.getTo());\n+                }\n+                if (attributeMapping.getFilter() != null) {\n+                    node.add(\"filter\", attributeMapping.getFilter());\n+                }\n+                if (attributeMapping.getFilterBaseDn() != null) {\n+                    node.add(\"filter-base-dn\", attributeMapping.getFilterBaseDn());\n+                }\n+                if (attributeMapping.getExtractRdn() != null) {\n+                    node.add(\"extract-rdn\", attributeMapping.getExtractRdn());\n+                }\n+                if (attributeMapping.getSearchRecursive() != null) {\n+                    node.add(\"search-recursive\", attributeMapping.getSearchRecursive());\n+                }\n+                if (attributeMapping.getRoleRecursion() != null) {\n+                    node.add(\"role-recursion\", attributeMapping.getRoleRecursion());\n+                }\n+                if (attributeMapping.getRoleRecursionName() != null) {\n+                    node.add(\"role-recursion-name\", attributeMapping.getRoleRecursionName());\n+                }\n+                if (attributeMapping.getReference() != null) {\n+                    node.add(\"reference\", attributeMapping.getReference());\n+                }\n+                attributeMappingNodeList.add(node.asObject());\n+            }\n+            ModelNode attributeMappingNode = new ModelNode();\n+            attributeMappingNode.set(attributeMappingNodeList);\n+            identityMappingModelNode.add(\"attribute-mapping\", attributeMappingNode);\n+        }\n+        if (identityMapping.getFilterName() != null) {\n+            identityMappingModelNode.add(\"filter-name\", identityMapping.getFilterName());\n+        }\n+        if (identityMapping.getIteratorFilter() != null) {\n+            identityMappingModelNode.add(\"iterator-filter\", identityMapping.getIteratorFilter());\n+        }\n+        if (!identityMapping.getNewIdentityAttributes().isEmpty()) {\n+            List<ModelNode> newIdentityAttributesNodeList = new ArrayList<ModelNode>();\n+            for (NewIdentityAttributes newIdentityAttribute : identityMapping.getNewIdentityAttributes()) {\n+                ModelNode attributeNode = new ModelNode();\n+                if (newIdentityAttribute.getName() != null) {\n+                    attributeNode.add(\"name\", newIdentityAttribute.getName());\n+                }\n+\n+                ModelNode valuesList = new ModelNode().setEmptyList();\n+                for (String value : newIdentityAttribute.getValues()) {\n+                    valuesList.add(value);\n+                }\n+                attributeNode.add(\"value\", valuesList);\n+\n+                newIdentityAttributesNodeList.add(attributeNode.asObject());\n+            }\n+            ModelNode newIdentityAttributesNode = new ModelNode();\n+            newIdentityAttributesNode.set(newIdentityAttributesNodeList);\n+            identityMappingModelNode.add(\"new-identity-attributes\", newIdentityAttributesNode);\n+        }\n+        if (identityMapping.getNewIdentityParentDn() != null) {\n+            identityMappingModelNode.add(\"new-identity-parent-dn\", identityMapping.getNewIdentityParentDn());\n+        }\n+        if (identityMapping.getOtpCredentialMapper() != null) {\n+            OtpCredentialMapper otpCredentialMapper = identityMapping.getOtpCredentialMapper();\n+            ModelNode node = new ModelNode();\n+            node.add(\"algorithm-from\", otpCredentialMapper.getAlgorithmFrom());\n+            node.add(\"hash-from\", otpCredentialMapper.getHashFrom());\n+            node.add(\"seed-from\", otpCredentialMapper.getSeedFrom());\n+            node.add(\"sequence-from\", otpCredentialMapper.getSequenceFrom());\n+            identityMappingModelNode.add(\"otp-credential-mapper\", node.asObject());\n+        }\n+        if (identityMapping.getRdnIdentifier() != null) {\n+            identityMappingModelNode.add(\"rdn-identifier\", identityMapping.getRdnIdentifier());\n+        }\n+        if (identityMapping.getSearchBaseDn() != null) {\n+            identityMappingModelNode.add(\"search-base-dn\", identityMapping.getSearchBaseDn());\n+        }\n+        if (identityMapping.getUseRecursiveSearch() != null) {\n+            identityMappingModelNode.add(\"use-recursive-search\", identityMapping.getUseRecursiveSearch());\n+        }\n+        if (identityMapping.getUserPasswordMapper() != null) {\n+            UserPasswordMapper userPasswordMapper = identityMapping.getUserPasswordMapper();\n+            ModelNode node = new ModelNode();\n+            node.add(\"from\", userPasswordMapper.getFrom());\n+            if (userPasswordMapper.getWritable() != null) {\n+                node.add(\"writable\", userPasswordMapper.getWritable());\n+            }\n+            if (userPasswordMapper.getVerifiable() != null) {\n+                node.add(\"verifiable\", userPasswordMapper.getVerifiable());\n+            }\n+            identityMappingModelNode.add(\"user-password-mapper\", node.asObject());\n+        }\n+        if (identityMapping.getX509CredentialMapper() != null) {\n+            X509CredentialMapper x509CredentialMapper = identityMapping.getX509CredentialMapper();\n+            ModelNode node = new ModelNode();\n+            if (x509CredentialMapper.getDigestFrom() != null) {\n+                node.add(\"digest-from\", x509CredentialMapper.getDigestFrom());\n+            }\n+            if (x509CredentialMapper.getDigestFrom() != null) {\n+                node.add(\"digest-algorithm\", x509CredentialMapper.getDigestAlgorithm());\n+            }\n+            if (x509CredentialMapper.getDigestFrom() != null) {\n+                node.add(\"certificate-from\", x509CredentialMapper.getCertificateFrom());\n+            }\n+            if (x509CredentialMapper.getDigestFrom() != null) {", "originalCommit": "62c1483e0f25d094fed69cc5927977dcdaeaa390", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MjA5Mw==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r467042093", "bodyText": "Fixed, thanks!", "author": "OndrejKotek", "createdAt": "2020-08-07T13:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMTI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMTI4Ng==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r465911286", "bodyText": "should be probably x509CredentialMapper.getSubjectDnFrom() instead", "author": "jstourac", "createdAt": "2020-08-05T18:09:58Z", "path": "testsuite/shared/src/main/java/org/wildfly/test/security/common/elytron/LdapRealm.java", "diffHunk": "@@ -0,0 +1,804 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.wildfly.test.security.common.elytron;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import org.jboss.as.controller.PathAddress;\n+import org.jboss.as.controller.PathElement;\n+import org.jboss.as.controller.client.ModelControllerClient;\n+import org.jboss.as.controller.operations.common.Util;\n+import org.jboss.as.test.integration.management.util.CLIWrapper;\n+import org.jboss.as.test.integration.security.common.Utils;\n+import org.jboss.dmr.ModelNode;\n+\n+/**\n+ * A {@link ConfigurableElement} to define the ldap-realm resource within the Elytron subsystem.\n+ *\n+ * @author Ondrej Kotek\n+ */\n+public class LdapRealm implements SecurityRealm {\n+\n+    private final PathAddress address;\n+    private final String name;\n+    private final String dirContext;\n+    private final Boolean directVerification;\n+    private final Boolean allowBlankPassword;\n+    private final IdentityMapping identityMapping;\n+\n+    LdapRealm(Builder builder) {\n+        this.name = builder.name;\n+        this.address = PathAddress.pathAddress(PathElement.pathElement(\"subsystem\", \"elytron\"), PathElement.pathElement(\"ldap-realm\", name));\n+        this.dirContext = builder.dirContext;\n+        this.directVerification = builder.directVerification;\n+        this.allowBlankPassword = builder.allowBlankPassword;\n+        this.identityMapping = builder.identityMapping;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public ModelNode getAddOperation() {\n+        ModelNode addOperation = Util.createAddOperation(address);\n+        addOperation.get(\"ldap-realm\");\n+        if (dirContext != null) {\n+            addOperation.get(\"dir-context\").set(dirContext);\n+        }\n+        if (directVerification != null) {\n+            addOperation.get(\"direct-verification\").set(directVerification);\n+        }\n+        if (allowBlankPassword != null) {\n+            addOperation.get(\"allow-blank-password\").set(allowBlankPassword);\n+        }\n+        if (identityMapping != null) {\n+            addOperation.get(\"identity-mapping\").set(getIdentityMappingModel().asObject());\n+        }\n+\n+        return addOperation;\n+    }\n+\n+    private ModelNode getIdentityMappingModel() {\n+        ModelNode identityMappingModelNode = new ModelNode();\n+        if (!identityMapping.getAttributeMappings().isEmpty()) {\n+            List<ModelNode> attributeMappingNodeList = new ArrayList<ModelNode>();\n+            for (AttributeMapping attributeMapping : identityMapping.getAttributeMappings()) {\n+                ModelNode node = new ModelNode();\n+                if (attributeMapping.getFrom() != null) {\n+                    node.add(\"from\", attributeMapping.getFrom());\n+                }\n+                if (attributeMapping.getTo() != null) {\n+                    node.add(\"to\", attributeMapping.getTo());\n+                }\n+                if (attributeMapping.getFilter() != null) {\n+                    node.add(\"filter\", attributeMapping.getFilter());\n+                }\n+                if (attributeMapping.getFilterBaseDn() != null) {\n+                    node.add(\"filter-base-dn\", attributeMapping.getFilterBaseDn());\n+                }\n+                if (attributeMapping.getExtractRdn() != null) {\n+                    node.add(\"extract-rdn\", attributeMapping.getExtractRdn());\n+                }\n+                if (attributeMapping.getSearchRecursive() != null) {\n+                    node.add(\"search-recursive\", attributeMapping.getSearchRecursive());\n+                }\n+                if (attributeMapping.getRoleRecursion() != null) {\n+                    node.add(\"role-recursion\", attributeMapping.getRoleRecursion());\n+                }\n+                if (attributeMapping.getRoleRecursionName() != null) {\n+                    node.add(\"role-recursion-name\", attributeMapping.getRoleRecursionName());\n+                }\n+                if (attributeMapping.getReference() != null) {\n+                    node.add(\"reference\", attributeMapping.getReference());\n+                }\n+                attributeMappingNodeList.add(node.asObject());\n+            }\n+            ModelNode attributeMappingNode = new ModelNode();\n+            attributeMappingNode.set(attributeMappingNodeList);\n+            identityMappingModelNode.add(\"attribute-mapping\", attributeMappingNode);\n+        }\n+        if (identityMapping.getFilterName() != null) {\n+            identityMappingModelNode.add(\"filter-name\", identityMapping.getFilterName());\n+        }\n+        if (identityMapping.getIteratorFilter() != null) {\n+            identityMappingModelNode.add(\"iterator-filter\", identityMapping.getIteratorFilter());\n+        }\n+        if (!identityMapping.getNewIdentityAttributes().isEmpty()) {\n+            List<ModelNode> newIdentityAttributesNodeList = new ArrayList<ModelNode>();\n+            for (NewIdentityAttributes newIdentityAttribute : identityMapping.getNewIdentityAttributes()) {\n+                ModelNode attributeNode = new ModelNode();\n+                if (newIdentityAttribute.getName() != null) {\n+                    attributeNode.add(\"name\", newIdentityAttribute.getName());\n+                }\n+\n+                ModelNode valuesList = new ModelNode().setEmptyList();\n+                for (String value : newIdentityAttribute.getValues()) {\n+                    valuesList.add(value);\n+                }\n+                attributeNode.add(\"value\", valuesList);\n+\n+                newIdentityAttributesNodeList.add(attributeNode.asObject());\n+            }\n+            ModelNode newIdentityAttributesNode = new ModelNode();\n+            newIdentityAttributesNode.set(newIdentityAttributesNodeList);\n+            identityMappingModelNode.add(\"new-identity-attributes\", newIdentityAttributesNode);\n+        }\n+        if (identityMapping.getNewIdentityParentDn() != null) {\n+            identityMappingModelNode.add(\"new-identity-parent-dn\", identityMapping.getNewIdentityParentDn());\n+        }\n+        if (identityMapping.getOtpCredentialMapper() != null) {\n+            OtpCredentialMapper otpCredentialMapper = identityMapping.getOtpCredentialMapper();\n+            ModelNode node = new ModelNode();\n+            node.add(\"algorithm-from\", otpCredentialMapper.getAlgorithmFrom());\n+            node.add(\"hash-from\", otpCredentialMapper.getHashFrom());\n+            node.add(\"seed-from\", otpCredentialMapper.getSeedFrom());\n+            node.add(\"sequence-from\", otpCredentialMapper.getSequenceFrom());\n+            identityMappingModelNode.add(\"otp-credential-mapper\", node.asObject());\n+        }\n+        if (identityMapping.getRdnIdentifier() != null) {\n+            identityMappingModelNode.add(\"rdn-identifier\", identityMapping.getRdnIdentifier());\n+        }\n+        if (identityMapping.getSearchBaseDn() != null) {\n+            identityMappingModelNode.add(\"search-base-dn\", identityMapping.getSearchBaseDn());\n+        }\n+        if (identityMapping.getUseRecursiveSearch() != null) {\n+            identityMappingModelNode.add(\"use-recursive-search\", identityMapping.getUseRecursiveSearch());\n+        }\n+        if (identityMapping.getUserPasswordMapper() != null) {\n+            UserPasswordMapper userPasswordMapper = identityMapping.getUserPasswordMapper();\n+            ModelNode node = new ModelNode();\n+            node.add(\"from\", userPasswordMapper.getFrom());\n+            if (userPasswordMapper.getWritable() != null) {\n+                node.add(\"writable\", userPasswordMapper.getWritable());\n+            }\n+            if (userPasswordMapper.getVerifiable() != null) {\n+                node.add(\"verifiable\", userPasswordMapper.getVerifiable());\n+            }\n+            identityMappingModelNode.add(\"user-password-mapper\", node.asObject());\n+        }\n+        if (identityMapping.getX509CredentialMapper() != null) {\n+            X509CredentialMapper x509CredentialMapper = identityMapping.getX509CredentialMapper();\n+            ModelNode node = new ModelNode();\n+            if (x509CredentialMapper.getDigestFrom() != null) {\n+                node.add(\"digest-from\", x509CredentialMapper.getDigestFrom());\n+            }\n+            if (x509CredentialMapper.getDigestFrom() != null) {\n+                node.add(\"digest-algorithm\", x509CredentialMapper.getDigestAlgorithm());\n+            }\n+            if (x509CredentialMapper.getDigestFrom() != null) {\n+                node.add(\"certificate-from\", x509CredentialMapper.getCertificateFrom());\n+            }\n+            if (x509CredentialMapper.getDigestFrom() != null) {\n+                node.add(\"serial-number-from\", x509CredentialMapper.getSerialNumberFrom());\n+            }\n+            if (x509CredentialMapper.getDigestFrom() != null) {", "originalCommit": "62c1483e0f25d094fed69cc5927977dcdaeaa390", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzA0MjE3Mg==", "url": "https://github.com/wildfly/wildfly/pull/13431#discussion_r467042172", "bodyText": "Fixed, thanks!", "author": "OndrejKotek", "createdAt": "2020-08-07T13:32:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkxMTI4Ng=="}], "type": "inlineReview"}, {"oid": "7d51f39decadcbf0d3edc558cb15859ef41d629a", "url": "https://github.com/wildfly/wildfly/commit/7d51f39decadcbf0d3edc558cb15859ef41d629a", "message": "[WFLY-13699] Integration tests for Elytron distributed-realm", "committedDate": "2020-08-07T13:29:10Z", "type": "commit"}, {"oid": "7d51f39decadcbf0d3edc558cb15859ef41d629a", "url": "https://github.com/wildfly/wildfly/commit/7d51f39decadcbf0d3edc558cb15859ef41d629a", "message": "[WFLY-13699] Integration tests for Elytron distributed-realm", "committedDate": "2020-08-07T13:29:10Z", "type": "forcePushed"}]}