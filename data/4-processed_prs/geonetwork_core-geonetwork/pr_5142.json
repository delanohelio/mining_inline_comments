{"pr_number": 5142, "pr_title": "Fix for polar extents (issue #4810)", "pr_createdAt": "2020-10-30T11:50:50Z", "pr_url": "https://github.com/geonetwork/core-geonetwork/pull/5142", "timeline": [{"oid": "64c8d38656a7bbe4930d57acfd5150d34553d397", "url": "https://github.com/geonetwork/core-geonetwork/commit/64c8d38656a7bbe4930d57acfd5150d34553d397", "message": "Fix for polar extents (issue #4810)", "committedDate": "2020-10-30T10:52:13Z", "type": "commit"}, {"oid": "2fb973144ab08444f08a9c6f861f92382e4d9faa", "url": "https://github.com/geonetwork/core-geonetwork/commit/2fb973144ab08444f08a9c6f861f92382e4d9faa", "message": "Fix for polar extents (issue #4810)", "committedDate": "2020-11-02T22:50:35Z", "type": "commit"}, {"oid": "2fb973144ab08444f08a9c6f861f92382e4d9faa", "url": "https://github.com/geonetwork/core-geonetwork/commit/2fb973144ab08444f08a9c6f861f92382e4d9faa", "message": "Fix for polar extents (issue #4810)", "committedDate": "2020-11-02T22:50:35Z", "type": "forcePushed"}, {"oid": "4b5567bcf4e9ec5f74381042e52875a46bde2ab0", "url": "https://github.com/geonetwork/core-geonetwork/commit/4b5567bcf4e9ec5f74381042e52875a46bde2ab0", "message": "Properly set point of origin", "committedDate": "2020-11-03T09:18:13Z", "type": "commit"}, {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee", "url": "https://github.com/geonetwork/core-geonetwork/commit/408392f1a03ca82b66ff76f42787e096b5529eee", "message": "Use datum line, fix longitudinal ordering", "committedDate": "2020-11-03T14:50:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMzI5OQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r516803299", "bodyText": "es6 will not work, sorry :/ please turn all let and const into var", "author": "jahow", "createdAt": "2020-11-03T16:37:16Z", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];\n+                  // No need to densify if shape already has a reasonable amount of points\n+                  if (inCoords.length > 4 * parts) return;\n+                  for (let i = 0; i < inCoords.length - 1; i++) {\n+                    let p0, p1, x0, y0, dX;\n+                    p0 = inCoords[i];\n+                    p1 = inCoords[i+1];\n+                    x0 = p0[0];\n+                    y0 = p0[1];\n+                    dX = (p1[0] - x0) / parts;\n+                    dY = (p1[1] - y0) / parts;\n+                    outCoords.push(p0);\n+                    for (let j = 1; j < parts; j++) {\n+                      // Add coords\n+                      outCoords.push([x0 + (j * dX), y0 + (j * dY)]);\n+                    }\n+                  }\n+                  // Add first coord to close polygon\n+                  outCoords.push(inCoords[0]);\n+                  feat.setGeometry(new ol.geom.Polygon([outCoords]));\n+                }\n+\n+                /**\n+                 * Given three colinear points (p1, p2, p3), check if p2 lies on line segment p1-p3.\n+                 */ \n+                var onSegment = function(p1, p2, p3) {\n+                  if (p2[0] <= Math.max(p1[0], p3[0]) && p2[0] >= Math.min(p1[0], p3[0]) && \n+                      p2[1] <= Math.max(p1[1], p3[1]) && p2[1] >= Math.min(p1[1], p3[1])) {\n+                        return true;\n+                  }\n+                  return false;\n+                }\n+\n+                /**\n+                 * Finds the orientation of an ordered triplet (p1, p2, p3). \n+                 * Returns one of the following values: \n+                 * 0 : Colinear points \n+                 * 1 : Clockwise points \n+                 * 2 : Counterclockwise \n+                 *\n+                 * See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp for details of below formula.\n+                 */ \n+                var getOrientation = function(p1, p2, p3) {\n+                  let value = ((p2[1] - p1[1]) * (p3[0] - p2[0])) - ((p2[0] - p1[0]) * (p3[1] - p2[1]));\n+                  if (value > 0) return 1;\n+                  else if (value < 0) return 2;\n+                  return 0;\n+                }\n+\n+                /**\n+                 * Returns true if the line segments 'line1' and 'line2' (with points A and B) intersect. \n+                 */\n+                var linesIntersect = function(line1A, line1B, line2A, line2B) {\n+                  // Find the 4 orientations required for the general and special cases \n+                  let o1 = getOrientation(line1A, line1B, line2A);\n+                  let o2 = getOrientation(line1A, line1B, line2B);\n+                  let o3 = getOrientation(line2A, line2B, line1A);\n+                  let o4 = getOrientation(line2A, line2B, line1B);\n+\n+                  // General case\n+                  if ((o1 !== o2) && (o3 !== o4)) return true;\n+\n+                  // Special cases:\n+                  // Line1(A,B) and Line2(A) are colinear and Line2(A) lies on Line1\n+                  if ((o1 === 0) && onSegment(line1A, line2A, line1B)) return true;\n+                  // Line1(A,B) and Line2(B) are colinear and Line2(B) lies on Line1\n+                  if ((o2 === 0) && onSegment(line1A, line2B, line1B)) return true;\n+                  // Line2(A,B) and Line1(A) are colinear and Line1(A) lies on Line2\n+                  if ((o3 === 0) && onSegment(line2A, line1A, line2B)) return true;\n+                  // Line2(A,B) and Line1(B) are colinear and Line1(B) lies on Line2\n+                  if ((o4 === 0) && onSegment(line2A, line1B, line2B)) return true;\n+                  // Nothing intersects\n+                  return false;                  \n+                }\n+\n+                /**\n+                 * Calculates the intersection point between 'line1' and 'line2'.\n+                 * Assumes that the lines actually intersect (use linesIntersect() to verify).\n+                 */\n+                var getIntersection = function(line1A, line1B, line2A, line2B) {\n+                  // Line 1 represented as a1x + b1y = c1 \n+                  let a1 = line1B[1] - line1A[1]; \n+                  let b1 = line1A[0] - line1B[0]; \n+                  let c1 = a1 * line1A[0] + b1 * line1A[1]; \n+       \n+                  // Line 2 represented as a2x + b2y = c2 \n+                  let a2 = line2B[1] - line2A[1]; \n+                  let b2 = line2A[0] - line2B[0]; \n+                  let c2 = a2 * line2A[0] + b2 * line2A[1]; \n+                \n+                  let determinant = a1 * b2 - a2 * b1;                \n+                  let x = (b2 * c1 - b1 * c2) / determinant; \n+                  let y = (a1 * c2 - a2 * c1) / determinant; \n+                  return [x, y];\n+                }\n+\n+                /**\n+                 * Makes a \"cut\" at the datum line from the geometry edge up or down to the polar coordinate.\n+                 * The feature geometry is also transformed to WGS 1984 (EPSG:4326).\n+                 * NOTE: This is not suitable for complex or multipart polygons!\n+                 * \n+                 *           North pole polygon                   South pole polygon\n+                 *          +======+===========+                 +------------------+\n+                 *          |      |           |                 |                  |\n+                 *          |      o           |                 |            o     |\n+                 *          |                  |                 |            |     |\n+                 *          +------------------+                 +============+=====+\n+                 * \n+                 *   === -> \"cut side\" \n+                 *   o   -> polar coordinate\n+                 * @param {ol.feature} feat\n+                 * @param polarCoord\n+                 */\n+                var modifyPolarExtent = function(feat, polarCoord) {\n+                  const atNorthPole = polarCoord == northPole;\n+                  const polarLat = atNorthPole ? 90 : -90;\n+                  const parts = feat.getGeometry().getCoordinates();\n+\n+                  // Set the point of origin at equator (where datum line towards polar coordinate starts)\n+                  let originCoord = getXY(180, 0);\n+\n+                  // Show some warnings/info (when in debug mode)\n+                  console.log('Search extent contains ' + (atNorthPole ? 'north' : 'south') + ' pole');\n+                  if (parts.length > 1) {\n+                    console.warn('Multi-polygon polar search extents are not supported: this will produce unexpected results');\n+                  }\n+\n+                  // Find (1st) polar-side line segment that crosses the \"datum\".\n+                  // NOTE: this also works for non-square shapes, but NOT for shapes that cross the datum line multiple times!\n+                  let coords = parts[0];\n+                  let intersectionPointIndex = -1;\n+                  let lineStart = null;\n+                  let lineEnd = null;\n+                  for (let i = 0; i < coords.length - 1; i++) {\n+                    const p1 = coords[i];\n+                    const p2 = coords[i + 1];\n+                    if (linesIntersect(p1, p2, originCoord, polarCoord)) {\n+                      intersectionPointIndex = i + 1;\n+                      lineStart = p1;\n+                      lineEnd = p2;\n+                      break;\n+                    }\n+                  }\n+                  \n+                  if (lineStart !== null) {\n+                    // Calculate intersection point between extent segment and datum line\n+                    let intersectionPoint = getIntersection(lineStart, lineEnd, originCoord, polarCoord);\n+                    coords.splice(intersectionPointIndex, 0, intersectionPoint);\n+                    feat.setGeometry(new ol.geom.Polygon([coords]));\n+                  }\n+\n+                  // Transform to WGS 1984 (EPSG:4326)\n+                  feat.getGeometry().transform(proj, 'EPSG:4326');\n+                  \n+                  if (intersectionPointIndex >= 0) {\n+                    // Get all (transformed) coordinates and previous and next longitudes\n+                    coords = feat.getGeometry().getCoordinates()[0];\n+                    const prevLon = coords[intersectionPointIndex - 1][0];\n+                    const nextLon = coords[intersectionPointIndex + 1][0];\n+                    // Determine polar longitudes (order)\n+                    const polarLon1 = prevLon < 0 && nextLon > 0 ? -180 : 180;\n+                    const polarLon2 = -polarLon1;\n+                    // Get longitude of inserted coordinate, negate if needed (ensure correct hemisphere)\n+                    let insertedLon = coords[intersectionPointIndex][0];\n+                    if ((insertedLon > 0 && polarLon1 < 0) || (insertedLon < 0 && polarLon1 > 0)) {\n+                      insertedLon = -insertedLon;\n+                      coords[intersectionPointIndex][0] = insertedLon;\n+                    }                \n+                    // Get latitude of inserted coordinate\n+                    const insertedLat = coords[intersectionPointIndex][1];\n+                    // Insert 3 coordinates (2 at either side of the pole) to create the \"cut\"\n+                    coords.splice(intersectionPointIndex + 1, 0, [polarLon1, polarLat], [polarLon2, polarLat], [-insertedLon, insertedLat]);\n+                    feat.setGeometry(new ol.geom.Polygon([coords]));\n+                  }\n+                }\n+\n+\n+                // Transform extent to WGS 1984 (EPSG:4326)\n+                var lonlatFeat, writer, proj, wkt;\n                 lonlatFeat = feature.clone();\n-                lonlatFeat.getGeometry().transform(\n-                    scope.map.getView().getProjection().getCode(),\n-                    'EPSG:4326');\n+                if (proj !== 'EPSG:4326') {\n+                  if (proj !== 'EPSG:3857') {\n+                    // Densify edges so we get a more accurate reprojection (relates to issue #4810)\n+                    densifyEdges(lonlatFeat);\n+                  }\n+                  // Check if original extent includes a pole\n+                  let polarCoord = getInsidePole(feature);\n+                  if (polarCoord) \n+                  {\n+                    // Original extent includes a north or south pole: manipulate extent.\n+                    // Solves issue #4810: Query by south pole area doesn't give any results.\n+                    modifyPolarExtent(lonlatFeat, polarCoord);\n+                  } else {\n+                    // No pole included so a basic transformation to WGS 1984 (EPSG:4326) will do\n+                    lonlatFeat.getGeometry().transform(proj, 'EPSG:4326');\n+                  }\n+                }\n+\n+                // Write the extent as 4326 WKT polygon\n                 writer = new ol.format.WKT();\n                 wkt = writer.writeFeature(lonlatFeat);\n                 bboxSet(parent, wkt);\n               };\n \n               // If given extent coords are given through attributes,\n               // display the bbox on the map\n-              var coords = scope.$eval(attrs['gnDrawBboxExtent']);\n+              let coords = scope.$eval(attrs['gnDrawBboxExtent']);", "originalCommit": "408392f1a03ca82b66ff76f42787e096b5529eee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4NTU5Ng==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517185596", "bodyText": "I know, Paul mentioned that yes.", "author": "GeoSander", "createdAt": "2020-11-04T08:56:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMzI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzOTMyNA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517139324", "bodyText": "This should be removed", "author": "jahow", "createdAt": "2020-11-04T07:23:44Z", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];\n+                  // No need to densify if shape already has a reasonable amount of points\n+                  if (inCoords.length > 4 * parts) return;\n+                  for (let i = 0; i < inCoords.length - 1; i++) {\n+                    let p0, p1, x0, y0, dX;\n+                    p0 = inCoords[i];\n+                    p1 = inCoords[i+1];\n+                    x0 = p0[0];\n+                    y0 = p0[1];\n+                    dX = (p1[0] - x0) / parts;\n+                    dY = (p1[1] - y0) / parts;\n+                    outCoords.push(p0);\n+                    for (let j = 1; j < parts; j++) {\n+                      // Add coords\n+                      outCoords.push([x0 + (j * dX), y0 + (j * dY)]);\n+                    }\n+                  }\n+                  // Add first coord to close polygon\n+                  outCoords.push(inCoords[0]);\n+                  feat.setGeometry(new ol.geom.Polygon([outCoords]));\n+                }\n+\n+                /**\n+                 * Given three colinear points (p1, p2, p3), check if p2 lies on line segment p1-p3.\n+                 */ \n+                var onSegment = function(p1, p2, p3) {\n+                  if (p2[0] <= Math.max(p1[0], p3[0]) && p2[0] >= Math.min(p1[0], p3[0]) && \n+                      p2[1] <= Math.max(p1[1], p3[1]) && p2[1] >= Math.min(p1[1], p3[1])) {\n+                        return true;\n+                  }\n+                  return false;\n+                }\n+\n+                /**\n+                 * Finds the orientation of an ordered triplet (p1, p2, p3). \n+                 * Returns one of the following values: \n+                 * 0 : Colinear points \n+                 * 1 : Clockwise points \n+                 * 2 : Counterclockwise \n+                 *\n+                 * See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp for details of below formula.\n+                 */ \n+                var getOrientation = function(p1, p2, p3) {\n+                  let value = ((p2[1] - p1[1]) * (p3[0] - p2[0])) - ((p2[0] - p1[0]) * (p3[1] - p2[1]));\n+                  if (value > 0) return 1;\n+                  else if (value < 0) return 2;\n+                  return 0;\n+                }\n+\n+                /**\n+                 * Returns true if the line segments 'line1' and 'line2' (with points A and B) intersect. \n+                 */\n+                var linesIntersect = function(line1A, line1B, line2A, line2B) {\n+                  // Find the 4 orientations required for the general and special cases \n+                  let o1 = getOrientation(line1A, line1B, line2A);\n+                  let o2 = getOrientation(line1A, line1B, line2B);\n+                  let o3 = getOrientation(line2A, line2B, line1A);\n+                  let o4 = getOrientation(line2A, line2B, line1B);\n+\n+                  // General case\n+                  if ((o1 !== o2) && (o3 !== o4)) return true;\n+\n+                  // Special cases:\n+                  // Line1(A,B) and Line2(A) are colinear and Line2(A) lies on Line1\n+                  if ((o1 === 0) && onSegment(line1A, line2A, line1B)) return true;\n+                  // Line1(A,B) and Line2(B) are colinear and Line2(B) lies on Line1\n+                  if ((o2 === 0) && onSegment(line1A, line2B, line1B)) return true;\n+                  // Line2(A,B) and Line1(A) are colinear and Line1(A) lies on Line2\n+                  if ((o3 === 0) && onSegment(line2A, line1A, line2B)) return true;\n+                  // Line2(A,B) and Line1(B) are colinear and Line1(B) lies on Line2\n+                  if ((o4 === 0) && onSegment(line2A, line1B, line2B)) return true;\n+                  // Nothing intersects\n+                  return false;                  \n+                }\n+\n+                /**\n+                 * Calculates the intersection point between 'line1' and 'line2'.\n+                 * Assumes that the lines actually intersect (use linesIntersect() to verify).\n+                 */\n+                var getIntersection = function(line1A, line1B, line2A, line2B) {\n+                  // Line 1 represented as a1x + b1y = c1 \n+                  let a1 = line1B[1] - line1A[1]; \n+                  let b1 = line1A[0] - line1B[0]; \n+                  let c1 = a1 * line1A[0] + b1 * line1A[1]; \n+       \n+                  // Line 2 represented as a2x + b2y = c2 \n+                  let a2 = line2B[1] - line2A[1]; \n+                  let b2 = line2A[0] - line2B[0]; \n+                  let c2 = a2 * line2A[0] + b2 * line2A[1]; \n+                \n+                  let determinant = a1 * b2 - a2 * b1;                \n+                  let x = (b2 * c1 - b1 * c2) / determinant; \n+                  let y = (a1 * c2 - a2 * c1) / determinant; \n+                  return [x, y];\n+                }\n+\n+                /**\n+                 * Makes a \"cut\" at the datum line from the geometry edge up or down to the polar coordinate.\n+                 * The feature geometry is also transformed to WGS 1984 (EPSG:4326).\n+                 * NOTE: This is not suitable for complex or multipart polygons!\n+                 * \n+                 *           North pole polygon                   South pole polygon\n+                 *          +======+===========+                 +------------------+\n+                 *          |      |           |                 |                  |\n+                 *          |      o           |                 |            o     |\n+                 *          |                  |                 |            |     |\n+                 *          +------------------+                 +============+=====+\n+                 * \n+                 *   === -> \"cut side\" \n+                 *   o   -> polar coordinate\n+                 * @param {ol.feature} feat\n+                 * @param polarCoord\n+                 */\n+                var modifyPolarExtent = function(feat, polarCoord) {\n+                  const atNorthPole = polarCoord == northPole;\n+                  const polarLat = atNorthPole ? 90 : -90;\n+                  const parts = feat.getGeometry().getCoordinates();\n+\n+                  // Set the point of origin at equator (where datum line towards polar coordinate starts)\n+                  let originCoord = getXY(180, 0);\n+\n+                  // Show some warnings/info (when in debug mode)\n+                  console.log('Search extent contains ' + (atNorthPole ? 'north' : 'south') + ' pole');", "originalCommit": "408392f1a03ca82b66ff76f42787e096b5529eee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4NTE0OA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517185148", "bodyText": "Removed? You mean replaced by library calls or moved to a service?", "author": "GeoSander", "createdAt": "2020-11-04T08:55:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzOTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNzU1Ng==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517207556", "bodyText": "No, I mean the console.log call should be removed altogether. It can be useful in debug mode but as it is currently it will always show even in production mode.", "author": "jahow", "createdAt": "2020-11-04T09:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzOTMyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjE3MQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517216171", "bodyText": "Ah right. Earlier it showed an entire block of code :)\nThink I forgot to replace it with console.debug. Would that be okay for you or do you really want to remove it altogether?", "author": "GeoSander", "createdAt": "2020-11-04T09:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzOTMyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517142648", "bodyText": "I think all those utilities should not be added here, but in another service. This adds way too much code inside a simple scope method.", "author": "jahow", "createdAt": "2020-11-04T07:31:59Z", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {", "originalCommit": "408392f1a03ca82b66ff76f42787e096b5529eee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4MjQyNw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517182427", "bodyText": "You've got a valid point there. Any suggestions where to put it?", "author": "GeoSander", "createdAt": "2020-11-04T08:50:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE5MTU0MQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517191541", "bodyText": "Well, there is a GeometryService.js file which could be a good place for these. You'd then have to import GeometryService in this directive.", "author": "jahow", "createdAt": "2020-11-04T09:05:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE5Mjk4MQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517192981", "bodyText": "Another option is adding a service right next to the directive, e.g. MapFieldDirectiveMapFieldService. Maybe better as it keeps the code close.", "author": "jahow", "createdAt": "2020-11-04T09:08:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNTQ0MA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517205440", "bodyText": "You mean MapFieldService, I guess? If we won't intend to use the functionality anywhere else in the future (e.g. for the main map), that probably makes sense yes.", "author": "GeoSander", "createdAt": "2020-11-04T09:28:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0NTkyMw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517145923", "bodyText": "this can be written as ol.proj.fromLonLat([0, -90], proj)", "author": "jahow", "createdAt": "2020-11-04T07:39:29Z", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);", "originalCommit": "408392f1a03ca82b66ff76f42787e096b5529eee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4Mjc0OA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517182748", "bodyText": "Ah, was looking for that, thanks. Will change.", "author": "GeoSander", "createdAt": "2020-11-04T08:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0NTkyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0NjMyMg==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517146322", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            var densifyEdges = function(feat, parts=4) {\n          \n          \n            \n                            var densifyEdges = function(feat, parts) {", "author": "jahow", "createdAt": "2020-11-04T07:40:19Z", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {", "originalCommit": "408392f1a03ca82b66ff76f42787e096b5529eee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0Njg3MQ==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517146871", "bodyText": "This will not work for linestrings right? maybe this should be documented better, the header only mentions \"line segments\"", "author": "jahow", "createdAt": "2020-11-04T07:41:34Z", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];", "originalCommit": "408392f1a03ca82b66ff76f42787e096b5529eee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4NDUwNA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517184504", "bodyText": "For lines, this issue does not apply. Lines will reproject just fine.\nBut does the user even have the possibility to draw a line for a search query? Does that even make sense? People are interested in areas usually?", "author": "GeoSander", "createdAt": "2020-11-04T08:54:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0Njg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4OTMyNw==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517189327", "bodyText": "Oh no, queries will always use polygons, I was just suggesting to make that clearer in the function documentation :)", "author": "jahow", "createdAt": "2020-11-04T09:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0Njg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNjM4MA==", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517206380", "bodyText": "Ok, will change!", "author": "GeoSander", "createdAt": "2020-11-04T09:29:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0Njg3MQ=="}], "type": "inlineReview"}, {"oid": "f147f9d7372b525977f17ebd7497f2fba29cb78c", "url": "https://github.com/geonetwork/core-geonetwork/commit/f147f9d7372b525977f17ebd7497f2fba29cb78c", "message": "Moved geometry functions to new MapFieldService", "committedDate": "2020-11-05T12:16:44Z", "type": "commit"}, {"oid": "6c620064d2f1cb5504e092d07eb4e462e41f0053", "url": "https://github.com/geonetwork/core-geonetwork/commit/6c620064d2f1cb5504e092d07eb4e462e41f0053", "message": "Applied formatting", "committedDate": "2020-11-05T12:21:08Z", "type": "commit"}, {"oid": "299181f71fd1170943670b2213c852b90648399c", "url": "https://github.com/geonetwork/core-geonetwork/commit/299181f71fd1170943670b2213c852b90648399c", "message": "Merge remote-tracking branch 'upstream/master' into master", "committedDate": "2020-11-05T12:29:09Z", "type": "commit"}, {"oid": "83e06a479c2f919f62e27760dd8dfcdad8980795", "url": "https://github.com/geonetwork/core-geonetwork/commit/83e06a479c2f919f62e27760dd8dfcdad8980795", "message": "Moved transform functionality to GeometryService", "committedDate": "2020-11-05T15:54:28Z", "type": "commit"}]}