{"pr_number": 3673, "pr_title": "[#3669] add a script to fix the translations ids", "pr_createdAt": "2020-11-20T16:04:01Z", "pr_url": "https://github.com/akvo/akvo-flow/pull/3673", "timeline": [{"oid": "f670d99b0131b56709c0b32349716fad8bf0b53c", "url": "https://github.com/akvo/akvo-flow/commit/f670d99b0131b56709c0b32349716fad8bf0b53c", "message": "[#3669] add a script to fix the translations ids", "committedDate": "2020-11-20T15:54:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0NDEyNA==", "url": "https://github.com/akvo/akvo-flow/pull/3673#discussion_r527944124", "bodyText": "If you know the id of the entity you want, you can just do .get(), you don't need to query for it:\nYou need to convert the Long value into  Key:\nhttps://cloud.google.com/appengine/docs/standard/java/datastore/entities#Retrieving_an_entity\nYou can get a Key passing the Long value and the Kind name:\nhttps://cloud.google.com/appengine/docs/standard/java/javadoc/com/google/appengine/api/datastore/KeyFactory.html#createkey_2", "author": "iperdomo", "createdAt": "2020-11-20T20:07:58Z", "path": "scripts/data/src/org/akvo/gae/remoteapi/FixOldTranslations.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.akvo.gae.remoteapi;\n+\n+import com.google.appengine.api.datastore.DatastoreService;\n+import com.google.appengine.api.datastore.Entity;\n+import com.google.appengine.api.datastore.FetchOptions;\n+import com.google.appengine.api.datastore.KeyFactory;\n+import com.google.appengine.api.datastore.PreparedQuery;\n+import com.google.appengine.api.datastore.Query;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class FixOldTranslations implements Process {\n+\n+    boolean fix = true; //set true to actually fix the translations\n+\n+    @Override\n+    public void execute(DatastoreService ds, String[] args) throws Exception {\n+        List<Entity> translations = fetchBrokenTranslations(ds);\n+        List<Entity> updatedTranslations = translations.stream().map(it -> fixTranslation(ds, it)).filter(Objects::nonNull).collect(Collectors.toList());\n+        if (fix && !updatedTranslations.isEmpty()) {\n+            ds.put(updatedTranslations);\n+            System.out.println(\"Fixed \" + updatedTranslations.size() + \" broken translations\");\n+        }\n+    }\n+\n+    private Entity fixTranslation(DatastoreService ds, Entity t) {\n+        Entity fixed = null;\n+        String parentType = (String) t.getProperty(\"parentType\");\n+        switch (parentType) {\n+            case \"QUESTION_TEXT\":\n+            case \"QUESTION_NAME\":\n+            case \"QUESTION_DESC\":\n+            case \"QUESTION_TIP\":\n+                fixed = fixQuestionTranslation(t, ds);\n+                break;\n+            case \"QUESTION_GROUP_NAME\":\n+            case \"QUESTION_GROUP_DESC\":\n+                fixed = fixQuestionGroupTranslation(t, ds);\n+                break;\n+            case \"QUESTION_OPTION\":\n+                fixed = fixQuestionOptionTranslation(t, ds);\n+                break;\n+            default:\n+                break;\n+        }\n+        return fixed;\n+    }\n+\n+    private Entity fixQuestionGroupTranslation(Entity t, final DatastoreService ds) {\n+        System.out.println(\"Fixing QuestionGroup translation\");\n+        Long parentId = (Long) t.getProperty(\"parentId\");\n+        return fixTranslation(t, ds, parentId);\n+    }\n+\n+    private Entity fixQuestionTranslation(Entity t, final DatastoreService ds) {\n+        System.out.println(\"Fixing Question translation\");\n+        Long parentId = (Long) t.getProperty(\"parentId\");\n+        if (parentId != null) {\n+            final Entity question = fetchQuestion(ds, parentId);\n+            if (question != null) {\n+                return fixTranslation(t, ds, (Long) question.getProperty(\"questionGroupId\"));\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Entity fixQuestionOptionTranslation(Entity t, final DatastoreService ds) {\n+        System.out.println(\"Fixing QuestionOption translation\");\n+        Long parentId = (Long) t.getProperty(\"parentId\");\n+        if (parentId != null) {\n+            final Query.Filter fs = new Query.FilterPredicate(Entity.KEY_RESERVED_PROPERTY,\n+                    Query.FilterOperator.EQUAL, KeyFactory.createKey(\"QuestionOption\", parentId));\n+            final Query q = new Query(\"QuestionOption\").setFilter(fs);\n+            Entity option = ds.prepare(q).asSingleEntity();\n+            if (option != null) {\n+                final Entity question = fetchQuestion(ds, (Long) option.getProperty(\"questionId\"));\n+                if (question != null) {\n+                    return fixTranslation(t, ds, (Long) question.getProperty(\"questionGroupId\"));\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Entity fixTranslation(Entity t, DatastoreService ds, Long groupId) {\n+        final Entity qGroup = fetchGroup(ds, groupId);\n+        if (qGroup != null) {\n+            t.setProperty(\"surveyId\", qGroup.getProperty(\"surveyId\"));\n+            t.setProperty(\"questionGroupId\", groupId);\n+            return t;\n+        }\n+        return null;\n+    }\n+\n+    private List<Entity> fetchBrokenTranslations(DatastoreService ds) {\n+        List<Entity> translations = new ArrayList<>();\n+        final Query q = new Query(\"Translation\");\n+        final PreparedQuery pq = ds.prepare(q);\n+        final Query.Filter filterNullSurveyId = new Query.FilterPredicate(\"surveyId\", Query.FilterOperator.EQUAL, null);\n+        final Query.Filter filterNullQuestionGroup = new Query.FilterPredicate(\"questionGroupId\", Query.FilterOperator.EQUAL, null);\n+        q.setFilter(Query.CompositeFilterOperator.or(filterNullSurveyId, filterNullQuestionGroup));\n+        List<Entity> entities = pq.asList(FetchOptions.Builder.withChunkSize(500));\n+        translations.addAll(entities);\n+        System.out.println(\"Found \" + translations.size() + \" broken translations\");\n+        return translations;\n+    }\n+\n+    private Entity fetchGroup(DatastoreService ds, Long groupId) {\n+        if (groupId == null) {\n+            return null;\n+        }\n+        final Query.Filter fs = new Query.FilterPredicate(Entity.KEY_RESERVED_PROPERTY,", "originalCommit": "f670d99b0131b56709c0b32349716fad8bf0b53c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0NjI0Mg==", "url": "https://github.com/akvo/akvo-flow/pull/3673#discussion_r527946242", "bodyText": "I wonder if this query is \"correct\". In the Datastore a missing property gets exposed as a null value, when you have already the object in memory, but you can't query for entities with a missing property. See: https://cloud.google.com/appengine/docs/standard/java/datastore/query-restrictions#entities_lacking_a_property_named_in_the_query_are_ignored\nIf we're sure that the value is null then just ignore this comment.", "author": "iperdomo", "createdAt": "2020-11-20T20:12:41Z", "path": "scripts/data/src/org/akvo/gae/remoteapi/FixOldTranslations.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.akvo.gae.remoteapi;\n+\n+import com.google.appengine.api.datastore.DatastoreService;\n+import com.google.appengine.api.datastore.Entity;\n+import com.google.appengine.api.datastore.FetchOptions;\n+import com.google.appengine.api.datastore.KeyFactory;\n+import com.google.appengine.api.datastore.PreparedQuery;\n+import com.google.appengine.api.datastore.Query;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class FixOldTranslations implements Process {\n+\n+    boolean fix = true; //set true to actually fix the translations\n+\n+    @Override\n+    public void execute(DatastoreService ds, String[] args) throws Exception {\n+        List<Entity> translations = fetchBrokenTranslations(ds);\n+        List<Entity> updatedTranslations = translations.stream().map(it -> fixTranslation(ds, it)).filter(Objects::nonNull).collect(Collectors.toList());\n+        if (fix && !updatedTranslations.isEmpty()) {\n+            ds.put(updatedTranslations);\n+            System.out.println(\"Fixed \" + updatedTranslations.size() + \" broken translations\");\n+        }\n+    }\n+\n+    private Entity fixTranslation(DatastoreService ds, Entity t) {\n+        Entity fixed = null;\n+        String parentType = (String) t.getProperty(\"parentType\");\n+        switch (parentType) {\n+            case \"QUESTION_TEXT\":\n+            case \"QUESTION_NAME\":\n+            case \"QUESTION_DESC\":\n+            case \"QUESTION_TIP\":\n+                fixed = fixQuestionTranslation(t, ds);\n+                break;\n+            case \"QUESTION_GROUP_NAME\":\n+            case \"QUESTION_GROUP_DESC\":\n+                fixed = fixQuestionGroupTranslation(t, ds);\n+                break;\n+            case \"QUESTION_OPTION\":\n+                fixed = fixQuestionOptionTranslation(t, ds);\n+                break;\n+            default:\n+                break;\n+        }\n+        return fixed;\n+    }\n+\n+    private Entity fixQuestionGroupTranslation(Entity t, final DatastoreService ds) {\n+        System.out.println(\"Fixing QuestionGroup translation\");\n+        Long parentId = (Long) t.getProperty(\"parentId\");\n+        return fixTranslation(t, ds, parentId);\n+    }\n+\n+    private Entity fixQuestionTranslation(Entity t, final DatastoreService ds) {\n+        System.out.println(\"Fixing Question translation\");\n+        Long parentId = (Long) t.getProperty(\"parentId\");\n+        if (parentId != null) {\n+            final Entity question = fetchQuestion(ds, parentId);\n+            if (question != null) {\n+                return fixTranslation(t, ds, (Long) question.getProperty(\"questionGroupId\"));\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Entity fixQuestionOptionTranslation(Entity t, final DatastoreService ds) {\n+        System.out.println(\"Fixing QuestionOption translation\");\n+        Long parentId = (Long) t.getProperty(\"parentId\");\n+        if (parentId != null) {\n+            final Query.Filter fs = new Query.FilterPredicate(Entity.KEY_RESERVED_PROPERTY,\n+                    Query.FilterOperator.EQUAL, KeyFactory.createKey(\"QuestionOption\", parentId));\n+            final Query q = new Query(\"QuestionOption\").setFilter(fs);\n+            Entity option = ds.prepare(q).asSingleEntity();\n+            if (option != null) {\n+                final Entity question = fetchQuestion(ds, (Long) option.getProperty(\"questionId\"));\n+                if (question != null) {\n+                    return fixTranslation(t, ds, (Long) question.getProperty(\"questionGroupId\"));\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Entity fixTranslation(Entity t, DatastoreService ds, Long groupId) {\n+        final Entity qGroup = fetchGroup(ds, groupId);\n+        if (qGroup != null) {\n+            t.setProperty(\"surveyId\", qGroup.getProperty(\"surveyId\"));\n+            t.setProperty(\"questionGroupId\", groupId);\n+            return t;\n+        }\n+        return null;\n+    }\n+\n+    private List<Entity> fetchBrokenTranslations(DatastoreService ds) {\n+        List<Entity> translations = new ArrayList<>();\n+        final Query q = new Query(\"Translation\");\n+        final PreparedQuery pq = ds.prepare(q);\n+        final Query.Filter filterNullSurveyId = new Query.FilterPredicate(\"surveyId\", Query.FilterOperator.EQUAL, null);", "originalCommit": "f670d99b0131b56709c0b32349716fad8bf0b53c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0Nzk0Ng==", "url": "https://github.com/akvo/akvo-flow/pull/3673#discussion_r527947946", "bodyText": "yes I am sure this works, I have tested it and Translations do get found with these missing properties and loads of them", "author": "valllllll2000", "createdAt": "2020-11-20T20:16:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0NjI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk0NjY4Mw==", "url": "https://github.com/akvo/akvo-flow/pull/3673#discussion_r527946683", "bodyText": "Use ds.get() if we know the id of the entity we want", "author": "iperdomo", "createdAt": "2020-11-20T20:13:43Z", "path": "scripts/data/src/org/akvo/gae/remoteapi/FixOldTranslations.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package org.akvo.gae.remoteapi;\n+\n+import com.google.appengine.api.datastore.DatastoreService;\n+import com.google.appengine.api.datastore.Entity;\n+import com.google.appengine.api.datastore.FetchOptions;\n+import com.google.appengine.api.datastore.KeyFactory;\n+import com.google.appengine.api.datastore.PreparedQuery;\n+import com.google.appengine.api.datastore.Query;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class FixOldTranslations implements Process {\n+\n+    boolean fix = true; //set true to actually fix the translations\n+\n+    @Override\n+    public void execute(DatastoreService ds, String[] args) throws Exception {\n+        List<Entity> translations = fetchBrokenTranslations(ds);\n+        List<Entity> updatedTranslations = translations.stream().map(it -> fixTranslation(ds, it)).filter(Objects::nonNull).collect(Collectors.toList());\n+        if (fix && !updatedTranslations.isEmpty()) {\n+            ds.put(updatedTranslations);\n+            System.out.println(\"Fixed \" + updatedTranslations.size() + \" broken translations\");\n+        }\n+    }\n+\n+    private Entity fixTranslation(DatastoreService ds, Entity t) {\n+        Entity fixed = null;\n+        String parentType = (String) t.getProperty(\"parentType\");\n+        switch (parentType) {\n+            case \"QUESTION_TEXT\":\n+            case \"QUESTION_NAME\":\n+            case \"QUESTION_DESC\":\n+            case \"QUESTION_TIP\":\n+                fixed = fixQuestionTranslation(t, ds);\n+                break;\n+            case \"QUESTION_GROUP_NAME\":\n+            case \"QUESTION_GROUP_DESC\":\n+                fixed = fixQuestionGroupTranslation(t, ds);\n+                break;\n+            case \"QUESTION_OPTION\":\n+                fixed = fixQuestionOptionTranslation(t, ds);\n+                break;\n+            default:\n+                break;\n+        }\n+        return fixed;\n+    }\n+\n+    private Entity fixQuestionGroupTranslation(Entity t, final DatastoreService ds) {\n+        System.out.println(\"Fixing QuestionGroup translation\");\n+        Long parentId = (Long) t.getProperty(\"parentId\");\n+        return fixTranslation(t, ds, parentId);\n+    }\n+\n+    private Entity fixQuestionTranslation(Entity t, final DatastoreService ds) {\n+        System.out.println(\"Fixing Question translation\");\n+        Long parentId = (Long) t.getProperty(\"parentId\");\n+        if (parentId != null) {\n+            final Entity question = fetchQuestion(ds, parentId);\n+            if (question != null) {\n+                return fixTranslation(t, ds, (Long) question.getProperty(\"questionGroupId\"));\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private Entity fixQuestionOptionTranslation(Entity t, final DatastoreService ds) {\n+        System.out.println(\"Fixing QuestionOption translation\");\n+        Long parentId = (Long) t.getProperty(\"parentId\");\n+        if (parentId != null) {\n+            final Query.Filter fs = new Query.FilterPredicate(Entity.KEY_RESERVED_PROPERTY,", "originalCommit": "f670d99b0131b56709c0b32349716fad8bf0b53c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "558f126a65a0695232be96b71c8a9494a29ff6c1", "url": "https://github.com/akvo/akvo-flow/commit/558f126a65a0695232be96b71c8a9494a29ff6c1", "message": "[#3669] use get by key to retrieve Entities", "committedDate": "2020-11-20T20:28:49Z", "type": "commit"}]}