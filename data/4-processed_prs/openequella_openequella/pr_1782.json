{"pr_number": 1782, "pr_title": "Feature/rest endpoint for search2", "pr_createdAt": "2020-06-03T00:58:47Z", "pr_url": "https://github.com/openequella/openEQUELLA/pull/1782", "timeline": [{"oid": "7ddc2e9e1246377388206181ea788ebb5684184c", "url": "https://github.com/openequella/openEQUELLA/commit/7ddc2e9e1246377388206181ea788ebb5684184c", "message": "Add a new Search REST endpoint, including:\n\n1. Create a new class called 'SearchParam' where search parameters are\ndefined and marked as 'QueryParam'.\n\n2. Create new model classes for search results so the response structure\nwill be static.\n\n3. Create a helper class which provides common functions required in a\nsearch.\n\n4. Create a new REST Resource for the path of 'search2'.", "committedDate": "2020-06-03T00:48:01Z", "type": "commit"}, {"oid": "9ba784a27598a94bf144db2c0e34da8d1fa801fb", "url": "https://github.com/openequella/openEQUELLA/commit/9ba784a27598a94bf144db2c0e34da8d1fa801fb", "message": "Create a new abstract REST test and refactor AuthApiTest.\n\nCreate a new REST test for the endpoint 'search2'.", "committedDate": "2020-06-03T00:52:40Z", "type": "commit"}, {"oid": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "url": "https://github.com/openequella/openEQUELLA/commit/b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "message": "Add headers for all the search2 related classes.", "committedDate": "2020-06-03T01:24:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2MTY4NQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434261685", "bodyText": "Interesting path name. Are numbers allowed in idiomatic rest?", "author": "SammyIsConfused", "createdAt": "2020-06-03T01:34:34Z", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/search/SearchResource.scala", "diffHunk": "@@ -0,0 +1,48 @@\n+package com.tle.web.api.search\n+\n+import com.tle.beans.item.ItemIdKey\n+import com.tle.common.searching.SearchResults\n+import com.tle.legacy.LegacyGuice\n+import com.tle.web.api.item.equella.interfaces.beans.EquellaItemBean\n+import com.tle.web.api.search.model.{SearchParam, SearchResult}\n+import com.tle.web.api.search.SearchHelper._\n+import io.swagger.annotations.{Api, ApiOperation}\n+import javax.ws.rs.{BeanParam, GET, Path, Produces}\n+import javax.ws.rs.core.Response\n+import org.jboss.resteasy.annotations.cache.NoCache\n+\n+import scala.collection.JavaConverters._\n+\n+@NoCache\n+@Path(\"search2\")", "originalCommit": "9ba784a27598a94bf144db2c0e34da8d1fa801fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5NDIxNg==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434294216", "bodyText": "Yup. Typically though we'd have something like /v1/search and now a new /v2/search.\nThis came about after discussion, as a method to bring in some kind of versioning. Currently there is none so suddenly adding a simple prefix (e.g. /v2/) did really match. So it was decided to simply do it in this fashion.", "author": "edalex-ian", "createdAt": "2020-06-03T03:57:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2MTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NTk4NQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434265985", "bodyText": "Is this @TestInstitution annotation needed? I thought this was set automatically by way of it extending AbstractRestApiTest.", "author": "SammyIsConfused", "createdAt": "2020-06-03T01:53:23Z", "path": "autotest/OldTests/src/test/java/io/github/openequella/rest/Search2ApiTest.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package io.github.openequella.rest;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import com.tle.webtests.framework.TestInstitution;\n+import java.io.IOException;\n+import org.apache.commons.httpclient.HttpMethod;\n+import org.apache.commons.httpclient.NameValuePair;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.codehaus.jackson.JsonNode;\n+import org.testng.annotations.Test;\n+\n+@TestInstitution(\"rest\")", "originalCommit": "9ba784a27598a94bf144db2c0e34da8d1fa801fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI3MzEwMQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434273101", "bodyText": "No, I will remove this annotation.", "author": "PenghaiZhang", "createdAt": "2020-06-03T02:24:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NTk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NjQ0NA==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434266444", "bodyText": "These asserts mean that the institution can not have any other items added it to it without breaking the test. Thats fine, just highlighting that further tests in the same institution that involve adding/removing items could break these.", "author": "SammyIsConfused", "createdAt": "2020-06-03T01:55:33Z", "path": "autotest/OldTests/src/test/java/io/github/openequella/rest/Search2ApiTest.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package io.github.openequella.rest;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import com.tle.webtests.framework.TestInstitution;\n+import java.io.IOException;\n+import org.apache.commons.httpclient.HttpMethod;\n+import org.apache.commons.httpclient.NameValuePair;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.codehaus.jackson.JsonNode;\n+import org.testng.annotations.Test;\n+\n+@TestInstitution(\"rest\")\n+public class Search2ApiTest extends AbstractRestApiTest {\n+  private static final String SEARCH_API_ENDPOINT = TEST_CONFIG.getInstitutionUrl() + \"api/search2\";\n+\n+  @Test\n+  public void noParamSearchTest() throws IOException {\n+    JsonNode result = doSearch(200);\n+    assertEquals(result.get(\"available\").asInt(), 73);", "originalCommit": "9ba784a27598a94bf144db2c0e34da8d1fa801fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI3MzU0OA==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434273548", "bodyText": "Hmmm,  I should not bring inflexibility in just because of this assertion.  I will change this assertion.", "author": "PenghaiZhang", "createdAt": "2020-06-03T02:26:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NjQ0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NzEwMA==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434267100", "bodyText": "Might be a good idea to have a short comment on each of these test methods explaining its purpose, I.E what is the test case we are checking here?", "author": "SammyIsConfused", "createdAt": "2020-06-03T01:58:14Z", "path": "autotest/OldTests/src/test/java/io/github/openequella/rest/Search2ApiTest.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package io.github.openequella.rest;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+import com.tle.webtests.framework.TestInstitution;\n+import java.io.IOException;\n+import org.apache.commons.httpclient.HttpMethod;\n+import org.apache.commons.httpclient.NameValuePair;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.codehaus.jackson.JsonNode;\n+import org.testng.annotations.Test;\n+\n+@TestInstitution(\"rest\")\n+public class Search2ApiTest extends AbstractRestApiTest {\n+  private static final String SEARCH_API_ENDPOINT = TEST_CONFIG.getInstitutionUrl() + \"api/search2\";\n+\n+  @Test\n+  public void noParamSearchTest() throws IOException {\n+    JsonNode result = doSearch(200);\n+    assertEquals(result.get(\"available\").asInt(), 73);\n+  }\n+\n+  @Test\n+  public void queryTest() throws IOException {", "originalCommit": "9ba784a27598a94bf144db2c0e34da8d1fa801fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5NjE4OA==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434296188", "bodyText": "You can use the description attribute on the annotation for that. \ud83d\udc4d", "author": "edalex-ian", "createdAt": "2020-06-03T04:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NzEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5NDQyMw==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434294423", "bodyText": "This doesn't so much retrieve items (you'd use the item endpoints for that). This is used to search for items based on specified criteria.", "author": "edalex-ian", "createdAt": "2020-06-03T03:58:51Z", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/search/SearchResource.scala", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.search\n+\n+import com.tle.beans.item.ItemIdKey\n+import com.tle.common.searching.SearchResults\n+import com.tle.legacy.LegacyGuice\n+import com.tle.web.api.item.equella.interfaces.beans.EquellaItemBean\n+import com.tle.web.api.search.model.{SearchParam, SearchResult}\n+import com.tle.web.api.search.SearchHelper._\n+import io.swagger.annotations.{Api, ApiOperation}\n+import javax.ws.rs.{BeanParam, GET, Path, Produces}\n+import javax.ws.rs.core.Response\n+import org.jboss.resteasy.annotations.cache.NoCache\n+\n+import scala.collection.JavaConverters._\n+\n+@NoCache\n+@Path(\"search2\")\n+@Produces(Array(\"application/json\"))\n+@Api(\"Search V2\")\n+class SearchResource {\n+\n+  @GET\n+  @ApiOperation(\n+    value = \"List items\",\n+    notes = \"This endpoint is used to retrieve items.\",", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5NDY0Mg==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434294642", "bodyText": "I wonder if we're able to use an enum for this instead. \ud83e\udd14", "author": "edalex-ian", "createdAt": "2020-06-03T04:00:04Z", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/search/model/SearchParam.scala", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.search.model\n+\n+import io.swagger.annotations.ApiParam\n+import javax.ws.rs.{DefaultValue, QueryParam}\n+\n+class SearchParam {\n+  @ApiParam(\"Query string\")\n+  @QueryParam(\"query\")\n+  var query: String = _\n+\n+  @ApiParam(\"The first record of the search results to return\")\n+  @QueryParam(\"start\") @DefaultValue(\"0\")\n+  var start: Int = _\n+\n+  @ApiParam(\"The number of results to return\")\n+  @QueryParam(\"length\") @DefaultValue(\"10\")\n+  var length: Int = _\n+\n+  @ApiParam(\"List of collections\")\n+  @QueryParam(\"collections\")\n+  var collections: Array[String] = _\n+\n+  @ApiParam(value = \"The order of the search results\",\n+            allowableValues = \"relevance,modified,name,rating,created\")\n+  @QueryParam(\"order\")\n+  var order: String = \"\"\n+\n+  @ApiParam(\"Reverse the order of the search results\")\n+  @QueryParam(\"reverseOrder\")\n+  var reverseOrder: Boolean = _\n+\n+  @ApiParam(\n+    \"An advanced search UUID. If a value is supplied, the collections in the advanced search will be used and the collections parameter will be ignored.\")\n+  @QueryParam(\"advancedSearch\")\n+  var advancedSearch: String = _\n+\n+  @ApiParam(\n+    \"For details on structuring the where clause see https://github.com/openequella/openequella.github.io/blob/master/guides/RestAPIGuide.md#searching\")\n+  @QueryParam(\"whereClause\")\n+  var whereClause: String = _\n+\n+  @ApiParam(value = \"Filter by item status.\",\n+            allowableValues =\n+              \"DRAFT,LIVE,REJECTED,MODERATING,ARCHIVED,SUSPENDED,DELETED,REVIEW,PERSONAL\")\n+  @QueryParam(\"status\")\n+  var status: Array[String] = _", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5NDkwMw==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434294903", "bodyText": "Should we do the results as a generic, as we may find good use for this elsewhere.", "author": "edalex-ian", "createdAt": "2020-06-03T04:01:06Z", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/search/model/SearchResult.scala", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.search.model\n+\n+case class SearchResult(start: Int, length: Int, available: Int, results: List[SearchResultItem])", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5NjQ4Ng==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434296486", "bodyText": "Could we add some JavaDoc to this object to define how this will be used.", "author": "edalex-ian", "createdAt": "2020-06-03T04:08:41Z", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/search/SearchHelper.scala", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.search\n+\n+import java.text.{ParseException, SimpleDateFormat}\n+import java.util.Date\n+import com.dytech.edge.exceptions.BadRequestException\n+import com.tle.beans.entity.DynaCollection\n+import com.tle.beans.item.{ItemIdKey, ItemStatus}\n+import com.tle.common.Check\n+import com.tle.common.Utils.parseDate\n+import com.tle.common.beans.exception.NotFoundException\n+import com.tle.common.search.DefaultSearch\n+import com.tle.common.search.whereparser.WhereParser\n+import com.tle.core.freetext.queries.FreeTextBooleanQuery\n+import com.tle.core.item.serializer.{ItemSerializerItemBean, ItemSerializerService}\n+import com.tle.legacy.LegacyGuice\n+import com.tle.web.api.interfaces.beans.AbstractExtendableBean\n+import com.tle.web.api.item.equella.interfaces.beans.EquellaItemBean\n+import com.tle.web.api.item.interfaces.beans.AttachmentBean\n+import com.tle.web.api.search.model.{SearchResultAttachment, SearchParam, SearchResultItem}\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+\n+object SearchHelper {", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5ODIwNA==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434298204", "bodyText": "Is it possible to just have Date directly in the params and then RestEasy parses it?", "author": "edalex-ian", "createdAt": "2020-06-03T04:16:27Z", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/search/SearchHelper.scala", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.search\n+\n+import java.text.{ParseException, SimpleDateFormat}\n+import java.util.Date\n+import com.dytech.edge.exceptions.BadRequestException\n+import com.tle.beans.entity.DynaCollection\n+import com.tle.beans.item.{ItemIdKey, ItemStatus}\n+import com.tle.common.Check\n+import com.tle.common.Utils.parseDate\n+import com.tle.common.beans.exception.NotFoundException\n+import com.tle.common.search.DefaultSearch\n+import com.tle.common.search.whereparser.WhereParser\n+import com.tle.core.freetext.queries.FreeTextBooleanQuery\n+import com.tle.core.item.serializer.{ItemSerializerItemBean, ItemSerializerService}\n+import com.tle.legacy.LegacyGuice\n+import com.tle.web.api.interfaces.beans.AbstractExtendableBean\n+import com.tle.web.api.item.equella.interfaces.beans.EquellaItemBean\n+import com.tle.web.api.item.interfaces.beans.AttachmentBean\n+import com.tle.web.api.search.model.{SearchResultAttachment, SearchParam, SearchResultItem}\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+\n+object SearchHelper {\n+\n+  /**\n+    * Create a new search with search criteria.\n+    * The search criteria is dependent on what parameters are passed in.\n+    * @param params Search parameters.\n+    * @return An instance of DefaultSearch\n+    */\n+  def createSearch(params: SearchParam): DefaultSearch = {\n+    val search = new DefaultSearch\n+    search.setQuery(params.query)\n+    search.setOwner(params.owner)\n+\n+    val orderType = DefaultSearch.getOrderType(params.order, params.query)\n+    search.setSortFields(orderType.getSortField(params.reverseOrder))\n+\n+    val collectionUuids = handleCollections(params.advancedSearch, params.collections)\n+    search.setCollectionUuids(collectionUuids.orNull)\n+\n+    val itemStatus = handleItemStatus(params.status)\n+    search.setItemStatuses(itemStatus.orNull)\n+\n+    val modifiedBefore = handleModifiedDate(params.modifiedBefore)\n+    val modifiedAfter  = handleModifiedDate(params.modifiedAfter)\n+    if (modifiedBefore.isDefined || modifiedAfter.isDefined) {\n+      search.setDateRange(Array(modifiedAfter.orNull, modifiedBefore.orNull))\n+    }\n+\n+    val dynaCollectionQuery = handleDynaCollection(params.dynaCollection)\n+    val whereQuery          = handleWhereClause(params.whereClause)\n+    val freeTextQuery = dynaCollectionQuery match {\n+      case Some(q) => q.add(whereQuery.orNull)\n+      case None    => whereQuery.orNull\n+    }\n+    search.setFreeTextQuery(freeTextQuery)\n+\n+    search\n+  }\n+\n+  /**\n+    * Return a free text query based on what dynamic collection uuid is provided.\n+    * @param dynaCollectionUuid The uuid of a dynamic collection.\n+    * @return An option which wraps an instance of FreeTextBooleanQuery.\n+    */\n+  def handleDynaCollection(dynaCollectionUuid: String): Option[FreeTextBooleanQuery] = {\n+    if (Check.isEmpty(dynaCollectionUuid)) {\n+      return None\n+    }\n+    val virtualDynaColl = LegacyGuice.dynaCollectionService.getByCompoundId(dynaCollectionUuid)\n+    Option(virtualDynaColl) match {\n+      case Some(v) =>\n+        val dynaCollection: DynaCollection = v.getVt\n+        val uuidAndVirtual: Array[String]  = dynaCollectionUuid.split(\":\")\n+        val virtual                        = if (uuidAndVirtual.length > 1) uuidAndVirtual(1) else null\n+        Some(LegacyGuice.dynaCollectionService.getSearchClause(dynaCollection, virtual))\n+      case None =>\n+        throw new NotFoundException(s\"No dynamic collection matching UUID $dynaCollectionUuid\")\n+    }\n+  }\n+\n+  /**\n+    * Return a free text query based on what where clause is provided.\n+    * @param whereClause A where clause which is added to the search SQL.\n+    * @return An option which wraps an instance of FreeTextBooleanQuery.\n+    */\n+  def handleWhereClause(whereClause: String): Option[FreeTextBooleanQuery] = {\n+    if (Check.isEmpty(whereClause)) {\n+      return None\n+    }\n+    Some(WhereParser.parse(whereClause))\n+  }\n+\n+  /**\n+    * Parse a string to a new instance of Date in the format of \"yyyy-MM-dd\".\n+    * @param date The string to parse.\n+    * @return An option which wraps an instace of Date.\n+    */\n+  def handleModifiedDate(date: String): Option[Date] = {", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI5OTUyMg==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434299522", "bodyText": "When you get crazy number of params like this, good to use named params.", "author": "edalex-ian", "createdAt": "2020-06-03T04:22:20Z", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/search/SearchHelper.scala", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.search\n+\n+import java.text.{ParseException, SimpleDateFormat}\n+import java.util.Date\n+import com.dytech.edge.exceptions.BadRequestException\n+import com.tle.beans.entity.DynaCollection\n+import com.tle.beans.item.{ItemIdKey, ItemStatus}\n+import com.tle.common.Check\n+import com.tle.common.Utils.parseDate\n+import com.tle.common.beans.exception.NotFoundException\n+import com.tle.common.search.DefaultSearch\n+import com.tle.common.search.whereparser.WhereParser\n+import com.tle.core.freetext.queries.FreeTextBooleanQuery\n+import com.tle.core.item.serializer.{ItemSerializerItemBean, ItemSerializerService}\n+import com.tle.legacy.LegacyGuice\n+import com.tle.web.api.interfaces.beans.AbstractExtendableBean\n+import com.tle.web.api.item.equella.interfaces.beans.EquellaItemBean\n+import com.tle.web.api.item.interfaces.beans.AttachmentBean\n+import com.tle.web.api.search.model.{SearchResultAttachment, SearchParam, SearchResultItem}\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+\n+object SearchHelper {\n+\n+  /**\n+    * Create a new search with search criteria.\n+    * The search criteria is dependent on what parameters are passed in.\n+    * @param params Search parameters.\n+    * @return An instance of DefaultSearch\n+    */\n+  def createSearch(params: SearchParam): DefaultSearch = {\n+    val search = new DefaultSearch\n+    search.setQuery(params.query)\n+    search.setOwner(params.owner)\n+\n+    val orderType = DefaultSearch.getOrderType(params.order, params.query)\n+    search.setSortFields(orderType.getSortField(params.reverseOrder))\n+\n+    val collectionUuids = handleCollections(params.advancedSearch, params.collections)\n+    search.setCollectionUuids(collectionUuids.orNull)\n+\n+    val itemStatus = handleItemStatus(params.status)\n+    search.setItemStatuses(itemStatus.orNull)\n+\n+    val modifiedBefore = handleModifiedDate(params.modifiedBefore)\n+    val modifiedAfter  = handleModifiedDate(params.modifiedAfter)\n+    if (modifiedBefore.isDefined || modifiedAfter.isDefined) {\n+      search.setDateRange(Array(modifiedAfter.orNull, modifiedBefore.orNull))\n+    }\n+\n+    val dynaCollectionQuery = handleDynaCollection(params.dynaCollection)\n+    val whereQuery          = handleWhereClause(params.whereClause)\n+    val freeTextQuery = dynaCollectionQuery match {\n+      case Some(q) => q.add(whereQuery.orNull)\n+      case None    => whereQuery.orNull\n+    }\n+    search.setFreeTextQuery(freeTextQuery)\n+\n+    search\n+  }\n+\n+  /**\n+    * Return a free text query based on what dynamic collection uuid is provided.\n+    * @param dynaCollectionUuid The uuid of a dynamic collection.\n+    * @return An option which wraps an instance of FreeTextBooleanQuery.\n+    */\n+  def handleDynaCollection(dynaCollectionUuid: String): Option[FreeTextBooleanQuery] = {\n+    if (Check.isEmpty(dynaCollectionUuid)) {\n+      return None\n+    }\n+    val virtualDynaColl = LegacyGuice.dynaCollectionService.getByCompoundId(dynaCollectionUuid)\n+    Option(virtualDynaColl) match {\n+      case Some(v) =>\n+        val dynaCollection: DynaCollection = v.getVt\n+        val uuidAndVirtual: Array[String]  = dynaCollectionUuid.split(\":\")\n+        val virtual                        = if (uuidAndVirtual.length > 1) uuidAndVirtual(1) else null\n+        Some(LegacyGuice.dynaCollectionService.getSearchClause(dynaCollection, virtual))\n+      case None =>\n+        throw new NotFoundException(s\"No dynamic collection matching UUID $dynaCollectionUuid\")\n+    }\n+  }\n+\n+  /**\n+    * Return a free text query based on what where clause is provided.\n+    * @param whereClause A where clause which is added to the search SQL.\n+    * @return An option which wraps an instance of FreeTextBooleanQuery.\n+    */\n+  def handleWhereClause(whereClause: String): Option[FreeTextBooleanQuery] = {\n+    if (Check.isEmpty(whereClause)) {\n+      return None\n+    }\n+    Some(WhereParser.parse(whereClause))\n+  }\n+\n+  /**\n+    * Parse a string to a new instance of Date in the format of \"yyyy-MM-dd\".\n+    * @param date The string to parse.\n+    * @return An option which wraps an instace of Date.\n+    */\n+  def handleModifiedDate(date: String): Option[Date] = {\n+    if (Check.isEmpty(date)) {\n+      return None\n+    }\n+    try {\n+      Some(parseDate(date, new SimpleDateFormat(\"yyyy-MM-dd\")))\n+    } catch {\n+      case _: ParseException => throw new BadRequestException(s\"Invalid date: $date\")\n+    }\n+  }\n+\n+  /**\n+    * Convert a list of strings to another list of ItemStatus.\n+    * @param list A list of strings to convert\n+    * @return An option which wraps a list of ItemStatus.\n+    */\n+  def handleItemStatus(list: Array[String]): Option[java.util.List[ItemStatus]] = {\n+    if (list.isEmpty) {\n+      return None\n+    }\n+\n+    val itemStatusList = list\n+      .map(s => {\n+        try {\n+          ItemStatus.valueOf(s.toUpperCase())\n+        } catch {\n+          case _: IllegalArgumentException =>\n+            throw new BadRequestException(s\"Invalid Item status: $s\")\n+        }\n+      })\n+      .toList\n+      .asJava\n+    Some(itemStatusList)\n+  }\n+\n+  /**\n+    * Return a list of Collection IDs, depending on if Advanced search is provided or not.\n+    * @param advancedSearch The UUID of an Advanced search.\n+    * @param collections A list of Collection IDs.\n+    * @return An option which wraps a list of Collection IDs.\n+    */\n+  def handleCollections(advancedSearch: String,\n+                        collections: Array[String]): Option[java.util.Collection[String]] = {\n+    if (!Check.isEmpty(advancedSearch)) {\n+      Option(LegacyGuice.powerSearchService.getByUuid(advancedSearch)) match {\n+        case Some(ps) =>\n+          var collectionUuids = ListBuffer[String]()\n+          ps.getItemdefs.asScala.foreach(collectionUuids += _.getUuid)\n+          return Some(collectionUuids.toList.asJava)\n+        case None =>\n+          throw new NotFoundException(s\"No advanced search UUID matching $advancedSearch\")\n+      }\n+    }\n+\n+    if (collections.isEmpty) {\n+      return None\n+    }\n+\n+    val collectionIds = ListBuffer[String]()\n+    collections.foreach(c =>\n+      Option(LegacyGuice.itemDefinitionService.getByUuid(c)) match {\n+        case Some(_) => collectionIds += c\n+        case None    => throw new NotFoundException(s\"No collection UUID matching $c\")\n+    })\n+    Some(collectionIds.toList.asJava)\n+  }\n+\n+  /**\n+    * Create a serializer for ItemBean.\n+    */\n+  def createSerializer(itemIds: List[ItemIdKey]): ItemSerializerItemBean = {\n+    val ids      = itemIds.map(_.getKey.asInstanceOf[java.lang.Long]).asJavaCollection\n+    val category = List(ItemSerializerService.CATEGORY_ALL).asJavaCollection\n+    LegacyGuice.itemSerializerService.createItemBeanSerializer(ids, category, false)\n+  }\n+\n+  /**\n+    * Convert a tuple of ItemIdKey and EquellaItemBean to an instance of SearchResultItem.\n+    * @param itemKeyAndBean An EquellaItemBean and its ItemIdKey.\n+    * @return An instance of SearchResultItem.\n+    */\n+  def convertToItem(itemKeyAndBean: (ItemIdKey, EquellaItemBean)): SearchResultItem = {\n+    val key          = itemKeyAndBean._1\n+    val bean         = itemKeyAndBean._2\n+    val commentCount = LegacyGuice.itemCommentService.getComments(key, null, null, -1).size()\n+    SearchResultItem(\n+      key.getUuid,\n+      Option(bean.getName),\n+      Option(bean.getDescription),\n+      bean.getStatus,\n+      bean.getCreatedDate,\n+      bean.getModifiedDate,\n+      bean.getCollection.getUuid,\n+      commentCount,\n+      convertToAttachment(bean.getAttachments),\n+      bean.getThumbnail,\n+      bean.getDisplayFields.asScala.toList,\n+      Option(bean.getDisplayOptions),\n+      getLinksFromBean(bean)", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMwMTQ0Mg==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434301442", "bodyText": "I wonder if this function is needed or whether it should be done with Either or similar to what you did with freeTextQuery up on line 71.", "author": "edalex-ian", "createdAt": "2020-06-03T04:30:47Z", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/search/SearchHelper.scala", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.search\n+\n+import java.text.{ParseException, SimpleDateFormat}\n+import java.util.Date\n+import com.dytech.edge.exceptions.BadRequestException\n+import com.tle.beans.entity.DynaCollection\n+import com.tle.beans.item.{ItemIdKey, ItemStatus}\n+import com.tle.common.Check\n+import com.tle.common.Utils.parseDate\n+import com.tle.common.beans.exception.NotFoundException\n+import com.tle.common.search.DefaultSearch\n+import com.tle.common.search.whereparser.WhereParser\n+import com.tle.core.freetext.queries.FreeTextBooleanQuery\n+import com.tle.core.item.serializer.{ItemSerializerItemBean, ItemSerializerService}\n+import com.tle.legacy.LegacyGuice\n+import com.tle.web.api.interfaces.beans.AbstractExtendableBean\n+import com.tle.web.api.item.equella.interfaces.beans.EquellaItemBean\n+import com.tle.web.api.item.interfaces.beans.AttachmentBean\n+import com.tle.web.api.search.model.{SearchResultAttachment, SearchParam, SearchResultItem}\n+import scala.collection.JavaConverters._\n+import scala.collection.mutable.ListBuffer\n+\n+object SearchHelper {\n+\n+  /**\n+    * Create a new search with search criteria.\n+    * The search criteria is dependent on what parameters are passed in.\n+    * @param params Search parameters.\n+    * @return An instance of DefaultSearch\n+    */\n+  def createSearch(params: SearchParam): DefaultSearch = {\n+    val search = new DefaultSearch\n+    search.setQuery(params.query)\n+    search.setOwner(params.owner)\n+\n+    val orderType = DefaultSearch.getOrderType(params.order, params.query)\n+    search.setSortFields(orderType.getSortField(params.reverseOrder))\n+\n+    val collectionUuids = handleCollections(params.advancedSearch, params.collections)\n+    search.setCollectionUuids(collectionUuids.orNull)\n+\n+    val itemStatus = handleItemStatus(params.status)\n+    search.setItemStatuses(itemStatus.orNull)\n+\n+    val modifiedBefore = handleModifiedDate(params.modifiedBefore)\n+    val modifiedAfter  = handleModifiedDate(params.modifiedAfter)\n+    if (modifiedBefore.isDefined || modifiedAfter.isDefined) {\n+      search.setDateRange(Array(modifiedAfter.orNull, modifiedBefore.orNull))\n+    }\n+\n+    val dynaCollectionQuery = handleDynaCollection(params.dynaCollection)\n+    val whereQuery          = handleWhereClause(params.whereClause)\n+    val freeTextQuery = dynaCollectionQuery match {\n+      case Some(q) => q.add(whereQuery.orNull)\n+      case None    => whereQuery.orNull\n+    }\n+    search.setFreeTextQuery(freeTextQuery)\n+\n+    search\n+  }\n+\n+  /**\n+    * Return a free text query based on what dynamic collection uuid is provided.\n+    * @param dynaCollectionUuid The uuid of a dynamic collection.\n+    * @return An option which wraps an instance of FreeTextBooleanQuery.\n+    */\n+  def handleDynaCollection(dynaCollectionUuid: String): Option[FreeTextBooleanQuery] = {\n+    if (Check.isEmpty(dynaCollectionUuid)) {\n+      return None\n+    }\n+    val virtualDynaColl = LegacyGuice.dynaCollectionService.getByCompoundId(dynaCollectionUuid)\n+    Option(virtualDynaColl) match {\n+      case Some(v) =>\n+        val dynaCollection: DynaCollection = v.getVt\n+        val uuidAndVirtual: Array[String]  = dynaCollectionUuid.split(\":\")\n+        val virtual                        = if (uuidAndVirtual.length > 1) uuidAndVirtual(1) else null\n+        Some(LegacyGuice.dynaCollectionService.getSearchClause(dynaCollection, virtual))\n+      case None =>\n+        throw new NotFoundException(s\"No dynamic collection matching UUID $dynaCollectionUuid\")\n+    }\n+  }\n+\n+  /**\n+    * Return a free text query based on what where clause is provided.\n+    * @param whereClause A where clause which is added to the search SQL.\n+    * @return An option which wraps an instance of FreeTextBooleanQuery.\n+    */\n+  def handleWhereClause(whereClause: String): Option[FreeTextBooleanQuery] = {\n+    if (Check.isEmpty(whereClause)) {\n+      return None\n+    }\n+    Some(WhereParser.parse(whereClause))\n+  }", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMwNzgwMg==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434307802", "bodyText": "Could we please add some JavaDoc to the class?", "author": "edalex-ian", "createdAt": "2020-06-03T04:57:33Z", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/search/model/SearchParam.scala", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.search.model\n+\n+import io.swagger.annotations.ApiParam\n+import javax.ws.rs.{DefaultValue, QueryParam}\n+\n+class SearchParam {", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMwODA2MA==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434308060", "bodyText": "I wonder if we can simply use one of the date types for this and the other date fields?", "author": "edalex-ian", "createdAt": "2020-06-03T04:58:37Z", "path": "Source/Plugins/Core/com.equella.core/scalasrc/com/tle/web/api/search/model/SearchParam.scala", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to The Apereo Foundation under one or more contributor license\n+ * agreements. See the NOTICE file distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * The Apereo Foundation licenses this file to you under the Apache License,\n+ * Version 2.0, (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.tle.web.api.search.model\n+\n+import io.swagger.annotations.ApiParam\n+import javax.ws.rs.{DefaultValue, QueryParam}\n+\n+class SearchParam {\n+  @ApiParam(\"Query string\")\n+  @QueryParam(\"query\")\n+  var query: String = _\n+\n+  @ApiParam(\"The first record of the search results to return\")\n+  @QueryParam(\"start\") @DefaultValue(\"0\")\n+  var start: Int = _\n+\n+  @ApiParam(\"The number of results to return\")\n+  @QueryParam(\"length\") @DefaultValue(\"10\")\n+  var length: Int = _\n+\n+  @ApiParam(\"List of collections\")\n+  @QueryParam(\"collections\")\n+  var collections: Array[String] = _\n+\n+  @ApiParam(value = \"The order of the search results\",\n+            allowableValues = \"relevance,modified,name,rating,created\")\n+  @QueryParam(\"order\")\n+  var order: String = \"\"\n+\n+  @ApiParam(\"Reverse the order of the search results\")\n+  @QueryParam(\"reverseOrder\")\n+  var reverseOrder: Boolean = _\n+\n+  @ApiParam(\n+    \"An advanced search UUID. If a value is supplied, the collections in the advanced search will be used and the collections parameter will be ignored.\")\n+  @QueryParam(\"advancedSearch\")\n+  var advancedSearch: String = _\n+\n+  @ApiParam(\n+    \"For details on structuring the where clause see https://github.com/openequella/openequella.github.io/blob/master/guides/RestAPIGuide.md#searching\")\n+  @QueryParam(\"whereClause\")\n+  var whereClause: String = _\n+\n+  @ApiParam(value = \"Filter by item status.\",\n+            allowableValues =\n+              \"DRAFT,LIVE,REJECTED,MODERATING,ARCHIVED,SUSPENDED,DELETED,REVIEW,PERSONAL\")\n+  @QueryParam(\"status\")\n+  var status: Array[String] = _\n+\n+  @ApiParam(\"An ISO date format (yyyy-MM-dd)\")\n+  @QueryParam(\"modifiedBefore\")\n+  var modifiedBefore: String = _", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMwOTQ4NQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434309485", "bodyText": "Good stuff creating this. I envisaged we'd need this eventually, but in my case it wasn't needed yet. \ud83d\udc4d", "author": "edalex-ian", "createdAt": "2020-06-03T05:04:20Z", "path": "autotest/OldTests/src/test/java/io/github/openequella/rest/AbstractRestApiTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package io.github.openequella.rest;\n+\n+import com.tle.webtests.framework.TestConfig;\n+import com.tle.webtests.framework.TestInstitution;\n+import java.io.IOException;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpMethod;\n+import org.apache.commons.httpclient.HttpStatus;\n+import org.apache.commons.httpclient.NameValuePair;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+\n+@TestInstitution(\"rest\")\n+public class AbstractRestApiTest {", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMwOTYwOQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1782#discussion_r434309609", "bodyText": "stray blank line", "author": "edalex-ian", "createdAt": "2020-06-03T05:04:52Z", "path": "autotest/OldTests/src/test/java/io/github/openequella/rest/AbstractRestApiTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package io.github.openequella.rest;\n+\n+import com.tle.webtests.framework.TestConfig;\n+import com.tle.webtests.framework.TestInstitution;\n+import java.io.IOException;\n+import org.apache.commons.httpclient.HttpClient;\n+import org.apache.commons.httpclient.HttpMethod;\n+import org.apache.commons.httpclient.HttpStatus;\n+import org.apache.commons.httpclient.NameValuePair;\n+import org.apache.commons.httpclient.methods.GetMethod;\n+import org.apache.commons.httpclient.methods.PostMethod;\n+import org.apache.commons.httpclient.methods.PutMethod;\n+import org.codehaus.jackson.map.ObjectMapper;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+\n+@TestInstitution(\"rest\")\n+public class AbstractRestApiTest {\n+\n+  protected static final TestConfig TEST_CONFIG = new TestConfig(AbstractRestApiTest.class);\n+  protected static final String USERNAME = \"AutoTest\";\n+  protected static final String PASSWORD = \"automated\";\n+  private static final String AUTH_API_ENDPOINT = TEST_CONFIG.getInstitutionUrl() + \"api/auth\";\n+\n+  protected final HttpClient httpClient = new HttpClient();\n+  protected final ObjectMapper mapper = new ObjectMapper();\n+\n+  @BeforeClass\n+  public void login() throws IOException {\n+    makeClientRequest(buildLoginMethod(USERNAME, PASSWORD));\n+  }\n+\n+  @AfterClass\n+  public void logout() throws IOException {\n+    makeClientRequest(buildLogoutMethod());\n+  }\n+\n+  protected int makeClientRequest(HttpMethod method) throws IOException {\n+    return httpClient.executeMethod(method);\n+  }\n+\n+  protected HttpMethod buildLoginMethod(String username, String password) {\n+", "originalCommit": "b13f35117a6f4a063d4d6ffc1b8ef8b08306f7d2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "238339c751261dc6df53fb6aa6b0e378504a67b3", "url": "https://github.com/openequella/openEQUELLA/commit/238339c751261dc6df53fb6aa6b0e378504a67b3", "message": "Refactor Search2ApiTest: adding descriptions for each test and making\nsome assertions more reasonable.", "committedDate": "2020-06-04T00:00:36Z", "type": "commit"}, {"oid": "3e844216d981ed490e76345b2bbf5f7d32c5a042", "url": "https://github.com/openequella/openEQUELLA/commit/3e844216d981ed490e76345b2bbf5f7d32c5a042", "message": "Use enum instead of String for the queryparam of status.\n\nSearchResult takes a type parameter.\n\nSimplify how to handle free text query for a search.\n\nAdd Javadoc for SearchHelper and SearchParam.", "committedDate": "2020-06-04T00:13:04Z", "type": "commit"}, {"oid": "51915af11e984b777af8674a49c5ff08c3bc960c", "url": "https://github.com/openequella/openEQUELLA/commit/51915af11e984b777af8674a49c5ff08c3bc960c", "message": "Resteasy can check if a String is a valid value of ItemStatus so remove\nthe function 'handleItemStatus'.\n\nThe tests for searching by order or reversed order really do not need\nto check what is the first item in the search result list.", "committedDate": "2020-06-04T01:59:05Z", "type": "commit"}]}