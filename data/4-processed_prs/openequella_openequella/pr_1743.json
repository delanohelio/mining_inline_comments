{"pr_number": 1743, "pr_title": "Reorder facets in the Facet search setting page", "pr_createdAt": "2020-05-18T02:16:12Z", "pr_url": "https://github.com/openequella/openEQUELLA/pull/1743", "timeline": [{"oid": "e1f948992e492d4fe95970731aa8d2879d8ac192", "url": "https://github.com/openequella/openEQUELLA/commit/e1f948992e492d4fe95970731aa8d2879d8ac192", "message": "Update 'react-beautiful-dnd' to the latest version.", "committedDate": "2020-05-18T01:41:48Z", "type": "commit"}, {"oid": "da1c3e1e7005bba9ca3b578e0fa3004d4bee33f6", "url": "https://github.com/openequella/openEQUELLA/commit/da1c3e1e7005bba9ca3b578e0fa3004d4bee33f6", "message": "Implement the functionality of reordering facets.", "committedDate": "2020-05-18T01:42:01Z", "type": "commit"}, {"oid": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "url": "https://github.com/openequella/openEQUELLA/commit/0be93c5bb7f98abf026366db9ac84f5525b3b5be", "message": "Make sure the Jest test of FacetedSearchSettingsPage works properly with\nthe reordering feature.", "committedDate": "2020-05-18T01:42:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM0MjczNA==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426342734", "bodyText": "Before dropping an dragged ListItem, its ListItemSecondaryAction does not get dragged and moved in accordance with the item, and it stays in its old place until the item is dropped. This makes UI not look very good.\nThe recommended solution I found is to use ListItemIcon for icons instead of ListItemSecondaryAction.", "author": "PenghaiZhang", "createdAt": "2020-05-18T02:35:33Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsPage.tsx", "diffHunk": "@@ -207,46 +231,84 @@ const FacetedSearchSettingsPage = ({ updateTemplate }: TemplateUpdateProps) => {\n   };\n \n   /**\n-   * Only renders a ListItem for each non-deleted facet.\n+   * Fired when a dragged facet is dropped.\n+   */\n+  const onDragEnd = (result: DropResult) => {\n+    if (!result.destination) {\n+      return;\n+    }\n+    const reorderedFacets = reorder(\n+      facets,\n+      result.source.index,\n+      result.destination.index\n+    );\n+    setFacets(reorderedFacets);\n+  };\n+\n+  /**\n+   * Render a Draggable area which renders a ListItem for each non-deleted facet.\n    */\n   const facetListItems: ReactElement[] = facets\n     .filter((facet) => !facet.deleted)\n     .map((facet, index) => {\n+      const id = facet.id ?? facet.name + index;\n       return (\n-        <ListItem divider key={facet.id ?? facet.name + index}>\n-          <ListItemText primary={facet.name} />\n-          <ListItemSecondaryAction>\n-            <IconButton\n-              color={\"secondary\"}\n-              onClick={() => {\n-                setShowEditingDialog(true);\n-                setCurrentFacet(facet);\n-              }}\n+        <Draggable key={id} draggableId={id.toString()} index={index}>\n+          {(draggable: DraggableProvided) => (\n+            <ListItem\n+              ref={draggable.innerRef}\n+              {...draggable.draggableProps}\n+              {...draggable.dragHandleProps}\n+              divider\n             >\n-              <EditIcon />\n-            </IconButton>\n-            |\n-            <IconButton color=\"secondary\" onClick={() => deleteFacet(facet)}>\n-              <DeleteIcon />\n-            </IconButton>\n-          </ListItemSecondaryAction>", "originalCommit": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM2OTk3MQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426369971", "bodyText": "Should be pinned.\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \"react-beautiful-dnd\": \"^13.0.0\",\n          \n          \n            \n                \"react-beautiful-dnd\": \"13.0.0\",\n          \n      \n    \n    \n  \n\n\nDo we know if such a major upgrade breaks anything else? Did you say this is also used by the DnD file uploader?", "author": "edalex-ian", "createdAt": "2020-05-18T04:57:47Z", "path": "Source/Plugins/Core/com.equella.core/js/package.json", "diffHunk": "@@ -48,7 +48,7 @@\n     \"oeq-cloudproviders\": \"git+https://github.com/apereo/openEQUELLA-cloudprovidersdk.git#32d958ddfff64ca748e7e1b2eae0f0487946a487\",\n     \"prop-types\": \"15.7.2\",\n     \"react\": \"16.13.1\",\n-    \"react-beautiful-dnd\": \"7.1.3\",\n+    \"react-beautiful-dnd\": \"^13.0.0\",", "originalCommit": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5MzUyNA==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426393524", "bodyText": "Yes, the file uploader uses this. I manually tested the file uploader on last Friday and it worked fine.", "author": "PenghaiZhang", "createdAt": "2020-05-18T06:26:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM2OTk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MDc3Mw==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426370773", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                \"@types/react-beautiful-dnd\": \"^12.1.2\",\n          \n          \n            \n                \"@types/react-beautiful-dnd\": \"12.1.2\",", "author": "edalex-ian", "createdAt": "2020-05-18T05:01:36Z", "path": "Source/Plugins/Core/com.equella.core/js/package.json", "diffHunk": "@@ -89,6 +89,7 @@\n     \"@types/node\": \"12.12.38\",\n     \"@types/react\": \"16.9.34\",\n     \"@types/react-autosuggest\": \"9.3.13\",\n+    \"@types/react-beautiful-dnd\": \"^12.1.2\",", "originalCommit": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTE2Nw==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426371167", "bodyText": "Must've missed this previously. Isn't the spread operator here redundant?", "author": "edalex-ian", "createdAt": "2020-05-18T05:03:15Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -96,16 +97,73 @@ export const removeFlags = (facet: FacetWithFlags): Facet => {\n };\n \n /**\n- * Given a list of facets, return the highest order index.\n+ * Given a list of facets, return the highest order index of non-deleted facets.\n  * If the list is empty then return -1.\n  */\n export const getHighestOrderIndex = (facets: FacetWithFlags[]) => {\n   if (facets.length == 0) {\n     return -1;\n   }\n-  return Math.max(...facets.map((facet) => facet.orderIndex));\n+  return Math.max(\n+    ...facets.filter((facet) => !facet.deleted).map((facet) => facet.orderIndex)", "originalCommit": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5NTA3OQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426395079", "bodyText": "I think Math.max expects one or more numbers rather than an array of numbers.  So the spread operator is required.", "author": "PenghaiZhang", "createdAt": "2020-05-18T06:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTE2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM5Nzk1Mg==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426397952", "bodyText": "Ahhh, oops. I see what you're doing now. My bad. \ud83d\ude0a", "author": "edalex-ian", "createdAt": "2020-05-18T06:38:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MTE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3MjU3NQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426372575", "bodyText": "I thought endIndex was meant to be the new index, so why isn't this simply:\ndraggedFacet.orderIndex = endIndex\n\n?", "author": "edalex-ian", "createdAt": "2020-05-18T05:09:57Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -96,16 +97,73 @@ export const removeFlags = (facet: FacetWithFlags): Facet => {\n };\n \n /**\n- * Given a list of facets, return the highest order index.\n+ * Given a list of facets, return the highest order index of non-deleted facets.\n  * If the list is empty then return -1.\n  */\n export const getHighestOrderIndex = (facets: FacetWithFlags[]) => {\n   if (facets.length == 0) {\n     return -1;\n   }\n-  return Math.max(...facets.map((facet) => facet.orderIndex));\n+  return Math.max(\n+    ...facets.filter((facet) => !facet.deleted).map((facet) => facet.orderIndex)\n+  );\n };\n \n export const facetComparator = (target: FacetWithFlags) => {\n   return (facet: FacetWithFlags) => facet === target;\n };\n+\n+/**\n+ * Reorder a list of facets, excluding deleted ones.\n+ * Firstly, update order index and the 'updated' flag of the dragged facet.\n+ * Secondly, remove this facet from the list.\n+ * Thirdly, update properties of facets in the dragged and dropped range.\n+ * Lastly, insert the dragged facet to the list at its new place.\n+ *\n+ * For example, in a array of five facets [f1, f2, f3, f4, f5] where indexes are from 0 - 4,\n+ * moving f2 to the end of the array results in that f2'index becomes 4 and indexes of f3, f4 and f5\n+ * become 1, 2 and 3, respectively. f1' index keeps 0.\n+ *\n+ * Given the same array, moving f5 to the second position of the array results in that\n+ * f5's index become 1 and indexes of f2, f3 and f4 become 2, 3 and 4, respectively. f1' index keeps 0.\n+ *\n+ * @param facets List of facets.\n+ * @param startIndex Current index of the dragged facet.\n+ * @param endIndex  New index of the dragged facet.\n+ */\n+export const reorder = (\n+  facets: FacetWithFlags[],\n+  startIndex: number,\n+  endIndex: number\n+): FacetWithFlags[] => {\n+  const filterFacetsByOrderRange = (facet: FacetWithFlags) => {\n+    if (startIndex < endIndex) {\n+      return facet.orderIndex > startIndex && facet.orderIndex <= endIndex;\n+    }\n+    return facet.orderIndex >= endIndex && facet.orderIndex < startIndex;\n+  };\n+  // Deep copy to avoid mutating objects of the original array.\n+  const copiedFacets: FacetWithFlags[] = lodash.cloneDeep(facets);\n+  // Deleted facets do not need reordering so leave them alone for now.\n+  const deletedFacets = copiedFacets.filter((facets) => facets.deleted);\n+  const nonDeletedFacets = copiedFacets.filter((facet) => !facet.deleted);\n+  // Update the dragged facet.\n+  const draggedFacet = nonDeletedFacets[startIndex];\n+  draggedFacet.updated = true;\n+  draggedFacet.orderIndex = draggedFacet.orderIndex + (endIndex - startIndex);", "originalCommit": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4MjE4Nw==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426382187", "bodyText": "hmmmm, this method seems more convoluted then it should need to be. Roughly, couldn't it just be a map function?\nexport const reorder = (\n  facets: FacetWithFlags[],\n  startIndex: number,\n  endIndex: number\n): FacetWithFalgs[] =>\n  facets.map( (f) => {\n    let newOrderIndex = 0;\n    if( f.deleted ) {\n      return {...f};\n    }\n    else if( f.orderIndex === startIndex ) {\n      newOrderIndex = endIndex;\n    }\n    else if( f.orderIndex > startIndex && f.orderIndex <= endIndex ) {\n      newOrderIndex = f.orderIndex - 1;\n    }\n    else if( etc etc etc ) {\n      // .......\n    }\n\n    return { ...f, orderIndex: newOrderIndex };\n  });\nStops all the in-place mutations, and increases readability. And also removes your need for lodash etc.\nBut maybe I've missed something. Like, maybe you're using both the array index and the orderindex for display? (hopefully not).", "author": "edalex-ian", "createdAt": "2020-05-18T05:49:21Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -96,16 +97,73 @@ export const removeFlags = (facet: FacetWithFlags): Facet => {\n };\n \n /**\n- * Given a list of facets, return the highest order index.\n+ * Given a list of facets, return the highest order index of non-deleted facets.\n  * If the list is empty then return -1.\n  */\n export const getHighestOrderIndex = (facets: FacetWithFlags[]) => {\n   if (facets.length == 0) {\n     return -1;\n   }\n-  return Math.max(...facets.map((facet) => facet.orderIndex));\n+  return Math.max(\n+    ...facets.filter((facet) => !facet.deleted).map((facet) => facet.orderIndex)\n+  );\n };\n \n export const facetComparator = (target: FacetWithFlags) => {\n   return (facet: FacetWithFlags) => facet === target;\n };\n+\n+/**\n+ * Reorder a list of facets, excluding deleted ones.\n+ * Firstly, update order index and the 'updated' flag of the dragged facet.\n+ * Secondly, remove this facet from the list.\n+ * Thirdly, update properties of facets in the dragged and dropped range.\n+ * Lastly, insert the dragged facet to the list at its new place.\n+ *\n+ * For example, in a array of five facets [f1, f2, f3, f4, f5] where indexes are from 0 - 4,\n+ * moving f2 to the end of the array results in that f2'index becomes 4 and indexes of f3, f4 and f5\n+ * become 1, 2 and 3, respectively. f1' index keeps 0.\n+ *\n+ * Given the same array, moving f5 to the second position of the array results in that\n+ * f5's index become 1 and indexes of f2, f3 and f4 become 2, 3 and 4, respectively. f1' index keeps 0.\n+ *\n+ * @param facets List of facets.\n+ * @param startIndex Current index of the dragged facet.\n+ * @param endIndex  New index of the dragged facet.\n+ */\n+export const reorder = (\n+  facets: FacetWithFlags[],\n+  startIndex: number,\n+  endIndex: number\n+): FacetWithFlags[] => {", "originalCommit": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NDY4Mg==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426384682", "bodyText": "I do again wonder if this could simply be done with a map and then filter. i.e. map through and update the flag of the specified facet - maybe new facets (i.e. not persisted on server) should have a local ID (e.g. new1, new2, new3) - to be deleted: true; and then filter through and remove and deleted facets that only have a local ID.\nNote: Mapping again would be with the spread operator to create new instances and a new array.", "author": "edalex-ian", "createdAt": "2020-05-18T05:58:07Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsPage.tsx", "diffHunk": "@@ -184,19 +196,31 @@ const FacetedSearchSettingsPage = ({ updateTemplate }: TemplateUpdateProps) => {\n \n   /**\n    * Visually delete a facet.\n-   * If ID is available, then update the delete flag; otherwise simply remove this facet from state.\n+   * Firstly, if ID is available, then update the delete flag. Otherwise, remove this facet from state.\n+   * Secondly, based on the deleted facet's order index, decrement higher ones by 1.\n+   *\n+   * For example, given an array like [f1, f2, f3, f4], removing f2 results in decrementing\n+   * the order indexes of f3 and f4 by 1 so there are no gaps between each order indexe.\n    */\n-  const deleteFacet = (facet: FacetWithFlags) => {\n-    if (facet.id) {\n-      setFacets(\n-        replaceElement(facets, facetComparator(facet), {\n-          ...facet,\n+  const deleteFacet = (deletedfacet: FacetWithFlags) => {", "originalCommit": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQ0NTE3OA==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426445178", "bodyText": "Yes, I can simplify this function with map as well.\nFor the idea of local ID, I am not quite sure what is the best approach. I can call Date.now() to generate a unique number as a local ID, but I have not found a proper way to tell if an ID is a local one or not later.", "author": "PenghaiZhang", "createdAt": "2020-05-18T08:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NDY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NTIzMg==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426385232", "bodyText": "hmmm, see if you did have a local only id like mentioned above (e.g. new1, new2, etc) then this would also be simpler.", "author": "edalex-ian", "createdAt": "2020-05-18T06:00:05Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsPage.tsx", "diffHunk": "@@ -207,46 +231,84 @@ const FacetedSearchSettingsPage = ({ updateTemplate }: TemplateUpdateProps) => {\n   };\n \n   /**\n-   * Only renders a ListItem for each non-deleted facet.\n+   * Fired when a dragged facet is dropped.\n+   */\n+  const onDragEnd = (result: DropResult) => {\n+    if (!result.destination) {\n+      return;\n+    }\n+    const reorderedFacets = reorder(\n+      facets,\n+      result.source.index,\n+      result.destination.index\n+    );\n+    setFacets(reorderedFacets);\n+  };\n+\n+  /**\n+   * Render a Draggable area which renders a ListItem for each non-deleted facet.\n    */\n   const facetListItems: ReactElement[] = facets\n     .filter((facet) => !facet.deleted)\n     .map((facet, index) => {\n+      const id = facet.id ?? facet.name + index;", "originalCommit": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk0NjU2Ng==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426946566", "bodyText": "As discussed. No need for a local ID, think I got tunnel vision.\nMind you though, a nitpick might be that this const should be called key.", "author": "edalex-ian", "createdAt": "2020-05-18T23:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NTIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NTg1OQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426385859", "bodyText": "This is a great candidate to have its own unit test in something like FacetSearchSettingsModule.test.ts.", "author": "edalex-ian", "createdAt": "2020-05-18T06:02:19Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -96,16 +97,73 @@ export const removeFlags = (facet: FacetWithFlags): Facet => {\n };\n \n /**\n- * Given a list of facets, return the highest order index.\n+ * Given a list of facets, return the highest order index of non-deleted facets.\n  * If the list is empty then return -1.\n  */\n export const getHighestOrderIndex = (facets: FacetWithFlags[]) => {\n   if (facets.length == 0) {\n     return -1;\n   }\n-  return Math.max(...facets.map((facet) => facet.orderIndex));\n+  return Math.max(\n+    ...facets.filter((facet) => !facet.deleted).map((facet) => facet.orderIndex)\n+  );\n };\n \n export const facetComparator = (target: FacetWithFlags) => {\n   return (facet: FacetWithFlags) => facet === target;\n };\n+\n+/**\n+ * Reorder a list of facets, excluding deleted ones.\n+ * Firstly, update order index and the 'updated' flag of the dragged facet.\n+ * Secondly, remove this facet from the list.\n+ * Thirdly, update properties of facets in the dragged and dropped range.\n+ * Lastly, insert the dragged facet to the list at its new place.\n+ *\n+ * For example, in a array of five facets [f1, f2, f3, f4, f5] where indexes are from 0 - 4,\n+ * moving f2 to the end of the array results in that f2'index becomes 4 and indexes of f3, f4 and f5\n+ * become 1, 2 and 3, respectively. f1' index keeps 0.\n+ *\n+ * Given the same array, moving f5 to the second position of the array results in that\n+ * f5's index become 1 and indexes of f2, f3 and f4 become 2, 3 and 4, respectively. f1' index keeps 0.\n+ *\n+ * @param facets List of facets.\n+ * @param startIndex Current index of the dragged facet.\n+ * @param endIndex  New index of the dragged facet.\n+ */\n+export const reorder = (", "originalCommit": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjQxODk3MA==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426418970", "bodyText": "In order to give a test for this function, I wonder if we would have to put it in the module, or put it in the page but outside the functional component and export it.", "author": "PenghaiZhang", "createdAt": "2020-05-18T07:27:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NTg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4NzEwNw==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r426387107", "bodyText": "Hmmm, I kind of like that this function is over here - especially as it knows nothing of state etc. However, I do wonder if this is here, should the delete be over here too. Dunno. \ud83e\udd14", "author": "edalex-ian", "createdAt": "2020-05-18T06:06:26Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -96,16 +97,73 @@ export const removeFlags = (facet: FacetWithFlags): Facet => {\n };\n \n /**\n- * Given a list of facets, return the highest order index.\n+ * Given a list of facets, return the highest order index of non-deleted facets.\n  * If the list is empty then return -1.\n  */\n export const getHighestOrderIndex = (facets: FacetWithFlags[]) => {\n   if (facets.length == 0) {\n     return -1;\n   }\n-  return Math.max(...facets.map((facet) => facet.orderIndex));\n+  return Math.max(\n+    ...facets.filter((facet) => !facet.deleted).map((facet) => facet.orderIndex)\n+  );\n };\n \n export const facetComparator = (target: FacetWithFlags) => {\n   return (facet: FacetWithFlags) => facet === target;\n };\n+\n+/**\n+ * Reorder a list of facets, excluding deleted ones.\n+ * Firstly, update order index and the 'updated' flag of the dragged facet.\n+ * Secondly, remove this facet from the list.\n+ * Thirdly, update properties of facets in the dragged and dropped range.\n+ * Lastly, insert the dragged facet to the list at its new place.\n+ *\n+ * For example, in a array of five facets [f1, f2, f3, f4, f5] where indexes are from 0 - 4,\n+ * moving f2 to the end of the array results in that f2'index becomes 4 and indexes of f3, f4 and f5\n+ * become 1, 2 and 3, respectively. f1' index keeps 0.\n+ *\n+ * Given the same array, moving f5 to the second position of the array results in that\n+ * f5's index become 1 and indexes of f2, f3 and f4 become 2, 3 and 4, respectively. f1' index keeps 0.\n+ *\n+ * @param facets List of facets.\n+ * @param startIndex Current index of the dragged facet.\n+ * @param endIndex  New index of the dragged facet.\n+ */\n+export const reorder = (", "originalCommit": "0be93c5bb7f98abf026366db9ac84f5525b3b5be", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3402c45d3dd16f72705acbaf092979c90ae567fa", "url": "https://github.com/openequella/openEQUELLA/commit/3402c45d3dd16f72705acbaf092979c90ae567fa", "message": "Should pin the version of 'react-beautiful-dnd'.", "committedDate": "2020-05-19T02:41:25Z", "type": "commit"}, {"oid": "1f1a0a42a602a004a5d8d4b3dfa270218df25012", "url": "https://github.com/openequella/openEQUELLA/commit/1f1a0a42a602a004a5d8d4b3dfa270218df25012", "message": "Simplify the function 'reorder', including:\n\n1. Using 'map' to loop through the list of facets and update facets;\n2. Removing the use of lodash.\n\nMove the function of deleting a facet to module and simplify its logic.\n\nSort facets based on their order indexes before they get rendered.", "committedDate": "2020-05-19T03:07:36Z", "type": "commit"}, {"oid": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "url": "https://github.com/openequella/openEQUELLA/commit/b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "message": "In the Jest test of FacetedSearchSettings, add tests for functions 'reorder'\nand 'removeFacetFromList'.", "committedDate": "2020-05-19T03:14:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3MjE3Ng==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428372176", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Add a new mock facet which does not have no ID.\n          \n          \n            \n                // Add a new mock facet which does not have an ID.", "author": "SammyIsConfused", "createdAt": "2020-05-20T23:55:31Z", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/mainui/FacetedSearchSettingsPage.test.tsx", "diffHunk": "@@ -189,4 +202,75 @@ describe(\"<FacetedSearchSettingsPage />\", () => {\n       expect(messageDialog.props().open).toBeTruthy();\n     });\n   });\n+\n+  it(\"should update order indexes when reorder facets\", () => {\n+    // Given the mocked facets, reorder the second one and third one.\n+    const reorderFacets = FacetedSearchSettingsModule.reorder(\n+      mockFacetsWithFlags,\n+      1,\n+      2\n+    );\n+    // The second facet's order index should be changed from 1 to 2.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 2 && f.updated && f.orderIndex === 2)\n+    ).toHaveLength(1);\n+    // The third facet's order index should be changed from 2 to 1.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 3 && f.updated && f.orderIndex === 1)\n+    ).toHaveLength(1);\n+    // The first facet's order index keeps unchanged.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 1 && f.orderIndex === 0)\n+    ).toHaveLength(1);\n+  });\n+\n+  describe(\"when remove a facet\", () => {\n+    // Add a new mock facet which does not have no ID.", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3MjI5Ng==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428372296", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              it(\"should update order indexes when reorder facets\", () => {\n          \n          \n            \n              it(\"should update order indexes when facets are reordered\", () => {", "author": "SammyIsConfused", "createdAt": "2020-05-20T23:55:55Z", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/mainui/FacetedSearchSettingsPage.test.tsx", "diffHunk": "@@ -189,4 +202,75 @@ describe(\"<FacetedSearchSettingsPage />\", () => {\n       expect(messageDialog.props().open).toBeTruthy();\n     });\n   });\n+\n+  it(\"should update order indexes when reorder facets\", () => {", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3MjU0NA==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428372544", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                it(\"should keep this facet in state if this facet has an ID\", () => {\n          \n          \n            \n                it(\"should keep this facet in state if it has an ID\", () => {", "author": "SammyIsConfused", "createdAt": "2020-05-20T23:56:50Z", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/mainui/FacetedSearchSettingsPage.test.tsx", "diffHunk": "@@ -189,4 +202,75 @@ describe(\"<FacetedSearchSettingsPage />\", () => {\n       expect(messageDialog.props().open).toBeTruthy();\n     });\n   });\n+\n+  it(\"should update order indexes when reorder facets\", () => {\n+    // Given the mocked facets, reorder the second one and third one.\n+    const reorderFacets = FacetedSearchSettingsModule.reorder(\n+      mockFacetsWithFlags,\n+      1,\n+      2\n+    );\n+    // The second facet's order index should be changed from 1 to 2.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 2 && f.updated && f.orderIndex === 2)\n+    ).toHaveLength(1);\n+    // The third facet's order index should be changed from 2 to 1.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 3 && f.updated && f.orderIndex === 1)\n+    ).toHaveLength(1);\n+    // The first facet's order index keeps unchanged.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 1 && f.orderIndex === 0)\n+    ).toHaveLength(1);\n+  });\n+\n+  describe(\"when remove a facet\", () => {\n+    // Add a new mock facet which does not have no ID.\n+    const newFacet: FacetWithFlags = {\n+      name: \"mocked facet4\",\n+      schemaNode: \"item/age\",\n+      maxResults: 4,\n+      orderIndex: 3,\n+      updated: false,\n+      deleted: false,\n+    };\n+    mockFacetsWithFlags.push(newFacet);\n+    it(\"should keep this facet in state if this facet has an ID\", () => {", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3MzY1Mg==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428373652", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                it(\"should remove this facet from state if this facet does not have an ID\", () => {\n          \n          \n            \n                it(\"should remove this facet from state if it does not have an ID\", () => {", "author": "SammyIsConfused", "createdAt": "2020-05-21T00:00:29Z", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/mainui/FacetedSearchSettingsPage.test.tsx", "diffHunk": "@@ -189,4 +202,75 @@ describe(\"<FacetedSearchSettingsPage />\", () => {\n       expect(messageDialog.props().open).toBeTruthy();\n     });\n   });\n+\n+  it(\"should update order indexes when reorder facets\", () => {\n+    // Given the mocked facets, reorder the second one and third one.\n+    const reorderFacets = FacetedSearchSettingsModule.reorder(\n+      mockFacetsWithFlags,\n+      1,\n+      2\n+    );\n+    // The second facet's order index should be changed from 1 to 2.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 2 && f.updated && f.orderIndex === 2)\n+    ).toHaveLength(1);\n+    // The third facet's order index should be changed from 2 to 1.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 3 && f.updated && f.orderIndex === 1)\n+    ).toHaveLength(1);\n+    // The first facet's order index keeps unchanged.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 1 && f.orderIndex === 0)\n+    ).toHaveLength(1);\n+  });\n+\n+  describe(\"when remove a facet\", () => {\n+    // Add a new mock facet which does not have no ID.\n+    const newFacet: FacetWithFlags = {\n+      name: \"mocked facet4\",\n+      schemaNode: \"item/age\",\n+      maxResults: 4,\n+      orderIndex: 3,\n+      updated: false,\n+      deleted: false,\n+    };\n+    mockFacetsWithFlags.push(newFacet);\n+    it(\"should keep this facet in state if this facet has an ID\", () => {\n+      const facetToRemove = mockFacetsWithFlags[1];\n+      // Remove the second facet which has an ID.\n+      const updatedFacets = FacetedSearchSettingsModule.removeFacetFromList(\n+        mockFacetsWithFlags,\n+        facetToRemove\n+      );\n+      // The total number of facets stored in state should keep 4.\n+      expect(updatedFacets).toHaveLength(4);\n+      // The first facet' order index keeps 0.\n+      expect(\n+        updatedFacets.filter(\n+          (f) => f.id === 1 && !f.updated && f.orderIndex === 0\n+        )\n+      ).toHaveLength(1);\n+      // The third facet's order index is 1 now.\n+      expect(\n+        updatedFacets.filter(\n+          (f) => f.id === 3 && f.updated && f.orderIndex === 1\n+        )\n+      ).toHaveLength(1);\n+      // The fourth facet's order index is updated to 2 although it does not have an ID.\n+      expect(\n+        updatedFacets.filter((f) => !f.id && f.updated && f.orderIndex === 2)\n+      ).toHaveLength(1);\n+    });\n+    it(\"should remove this facet from state if this facet does not have an ID\", () => {", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3Mzg2MQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428373861", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // The first facet' order index keeps 0.\n          \n          \n            \n                  // The first facet's order index keeps 0.", "author": "SammyIsConfused", "createdAt": "2020-05-21T00:01:13Z", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/mainui/FacetedSearchSettingsPage.test.tsx", "diffHunk": "@@ -189,4 +202,75 @@ describe(\"<FacetedSearchSettingsPage />\", () => {\n       expect(messageDialog.props().open).toBeTruthy();\n     });\n   });\n+\n+  it(\"should update order indexes when reorder facets\", () => {\n+    // Given the mocked facets, reorder the second one and third one.\n+    const reorderFacets = FacetedSearchSettingsModule.reorder(\n+      mockFacetsWithFlags,\n+      1,\n+      2\n+    );\n+    // The second facet's order index should be changed from 1 to 2.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 2 && f.updated && f.orderIndex === 2)\n+    ).toHaveLength(1);\n+    // The third facet's order index should be changed from 2 to 1.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 3 && f.updated && f.orderIndex === 1)\n+    ).toHaveLength(1);\n+    // The first facet's order index keeps unchanged.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 1 && f.orderIndex === 0)\n+    ).toHaveLength(1);\n+  });\n+\n+  describe(\"when remove a facet\", () => {\n+    // Add a new mock facet which does not have no ID.\n+    const newFacet: FacetWithFlags = {\n+      name: \"mocked facet4\",\n+      schemaNode: \"item/age\",\n+      maxResults: 4,\n+      orderIndex: 3,\n+      updated: false,\n+      deleted: false,\n+    };\n+    mockFacetsWithFlags.push(newFacet);\n+    it(\"should keep this facet in state if this facet has an ID\", () => {\n+      const facetToRemove = mockFacetsWithFlags[1];\n+      // Remove the second facet which has an ID.\n+      const updatedFacets = FacetedSearchSettingsModule.removeFacetFromList(\n+        mockFacetsWithFlags,\n+        facetToRemove\n+      );\n+      // The total number of facets stored in state should keep 4.\n+      expect(updatedFacets).toHaveLength(4);\n+      // The first facet' order index keeps 0.", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3NDM1NQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428374355", "bodyText": "Love this. You've made it so clear how this is supposed to work.", "author": "SammyIsConfused", "createdAt": "2020-05-21T00:02:50Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -96,16 +96,81 @@ export const removeFlags = (facet: FacetWithFlags): Facet => {\n };\n \n /**\n- * Given a list of facets, return the highest order index.\n+ * Given a list of facets, return the highest order index of non-deleted facets.\n  * If the list is empty then return -1.\n  */\n export const getHighestOrderIndex = (facets: FacetWithFlags[]) => {\n   if (facets.length == 0) {\n     return -1;\n   }\n-  return Math.max(...facets.map((facet) => facet.orderIndex));\n+  return Math.max(\n+    ...facets.filter((facet) => !facet.deleted).map((facet) => facet.orderIndex)\n+  );\n };\n \n export const facetComparator = (target: FacetWithFlags) => {\n   return (facet: FacetWithFlags) => facet === target;\n };\n+\n+/**\n+ * Reorder a list of facets, excluding deleted ones.\n+ * For example, in a array of five facets [f1, f2, f3, f4, f5] where indexes are from 0 - 4,\n+ * moving f2 to the end of the array results in that f2'index becomes 4 and indexes of f3, f4 and f5\n+ * become 1, 2 and 3, respectively. f1' index keeps 0.\n+ *\n+ * Given the same array, moving f5 to the second position of the array results in that\n+ * f5's index become 1 and indexes of f2, f3 and f4 become 2, 3 and 4, respectively. f1' index keeps 0.", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3NTczMQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428375731", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * And return a new array which keep non-deleted facets and those deleted but having an ID back to state.\n          \n          \n            \n             * And return a new array which keeps the non-deleted facets and flags the deleted ones back to state.\n          \n      \n    \n    \n  \n\nPotentially I haven't read this one correctly, but I think this is what it meant?", "author": "SammyIsConfused", "createdAt": "2020-05-21T00:08:00Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -96,16 +96,81 @@ export const removeFlags = (facet: FacetWithFlags): Facet => {\n };\n \n /**\n- * Given a list of facets, return the highest order index.\n+ * Given a list of facets, return the highest order index of non-deleted facets.\n  * If the list is empty then return -1.\n  */\n export const getHighestOrderIndex = (facets: FacetWithFlags[]) => {\n   if (facets.length == 0) {\n     return -1;\n   }\n-  return Math.max(...facets.map((facet) => facet.orderIndex));\n+  return Math.max(\n+    ...facets.filter((facet) => !facet.deleted).map((facet) => facet.orderIndex)\n+  );\n };\n \n export const facetComparator = (target: FacetWithFlags) => {\n   return (facet: FacetWithFlags) => facet === target;\n };\n+\n+/**\n+ * Reorder a list of facets, excluding deleted ones.\n+ * For example, in a array of five facets [f1, f2, f3, f4, f5] where indexes are from 0 - 4,\n+ * moving f2 to the end of the array results in that f2'index becomes 4 and indexes of f3, f4 and f5\n+ * become 1, 2 and 3, respectively. f1' index keeps 0.\n+ *\n+ * Given the same array, moving f5 to the second position of the array results in that\n+ * f5's index become 1 and indexes of f2, f3 and f4 become 2, 3 and 4, respectively. f1' index keeps 0.\n+ *\n+ * @param facets List of facets.\n+ * @param startIndex Current index of the dragged facet.\n+ * @param endIndex  New index of the dragged facet.\n+ */\n+export const reorder = (\n+  facets: FacetWithFlags[],\n+  startIndex: number,\n+  endIndex: number\n+): FacetWithFlags[] =>\n+  facets.map((facet) => {\n+    let newOrderIndex = 0;\n+    if (facet.deleted) {\n+      return { ...facet };\n+    }\n+\n+    if (facet.orderIndex === startIndex) {\n+      newOrderIndex = endIndex;\n+    } else if (facet.orderIndex > startIndex && facet.orderIndex <= endIndex) {\n+      newOrderIndex = facet.orderIndex - 1;\n+    } else if (facet.orderIndex >= endIndex && facet.orderIndex < startIndex) {\n+      newOrderIndex = facet.orderIndex + 1;\n+    } else {\n+      return { ...facet };\n+    }\n+\n+    return { ...facet, orderIndex: newOrderIndex, updated: true };\n+  });\n+\n+/**\n+ * Remove a facet from the given list and update order indexes of facets that have a higher order index.\n+ * And return a new array which keep non-deleted facets and those deleted but having an ID back to state.", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3ODk1Mw==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428378953", "bodyText": "For these expect statements, is there any reason you couldn't just keep it simple like:\nexpect( reorderFacets.find((f) => f.id === ?).orderIndex).toEqual(?)", "author": "edalex-ian", "createdAt": "2020-05-21T00:19:34Z", "path": "Source/Plugins/Core/com.equella.core/js/__tests__/tsrc/mainui/FacetedSearchSettingsPage.test.tsx", "diffHunk": "@@ -190,4 +202,75 @@ describe(\"<FacetedSearchSettingsPage />\", () => {\n       expect(messageDialog.props().open).toBeTruthy();\n     });\n   });\n+\n+  it(\"should update order indexes when reorder facets\", () => {\n+    // Given the mocked facets, reorder the second one and third one.\n+    const reorderFacets = FacetedSearchSettingsModule.reorder(\n+      mockFacetsWithFlags,\n+      1,\n+      2\n+    );\n+    // The second facet's order index should be changed from 1 to 2.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 2 && f.updated && f.orderIndex === 2)\n+    ).toHaveLength(1);\n+    // The third facet's order index should be changed from 2 to 1.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 3 && f.updated && f.orderIndex === 1)\n+    ).toHaveLength(1);\n+    // The first facet's order index keeps unchanged.\n+    expect(\n+      reorderFacets.filter((f) => f.id === 1 && f.orderIndex === 0)\n+    ).toHaveLength(1);", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ2MTU1Mg==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428461552", "bodyText": "hmmm, I think the reason is that Typescript thinks reorderFacets.find((f) => f.id === ?) could possibly return undefined, although we know this won't happen.", "author": "PenghaiZhang", "createdAt": "2020-05-21T06:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3ODk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MTUxNw==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428381517", "bodyText": "Could we please add an explicit return type? Just for doco sake.", "author": "edalex-ian", "createdAt": "2020-05-21T00:29:02Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -135,35 +129,48 @@ export const reorder = (\n   facets: FacetWithFlags[],\n   startIndex: number,\n   endIndex: number\n-): FacetWithFlags[] => {\n-  const filterFacetsByOrderRange = (facet: FacetWithFlags) => {\n-    if (startIndex < endIndex) {\n-      return facet.orderIndex > startIndex && facet.orderIndex <= endIndex;\n+): FacetWithFlags[] =>\n+  facets.map((facet) => {\n+    let newOrderIndex = 0;\n+    if (facet.deleted) {\n+      return { ...facet };\n+    }\n+\n+    if (facet.orderIndex === startIndex) {\n+      newOrderIndex = endIndex;\n+    } else if (facet.orderIndex > startIndex && facet.orderIndex <= endIndex) {\n+      newOrderIndex = facet.orderIndex - 1;\n+    } else if (facet.orderIndex >= endIndex && facet.orderIndex < startIndex) {\n+      newOrderIndex = facet.orderIndex + 1;\n+    } else {\n+      return { ...facet };\n     }\n-    return facet.orderIndex >= endIndex && facet.orderIndex < startIndex;\n-  };\n-  // Deep copy to avoid mutating objects of the original array.\n-  const copiedFacets: FacetWithFlags[] = lodash.cloneDeep(facets);\n-  // Deleted facets do not need reordering so leave them alone for now.\n-  const deletedFacets = copiedFacets.filter((facets) => facets.deleted);\n-  const nonDeletedFacets = copiedFacets.filter((facet) => !facet.deleted);\n-  // Update the dragged facet.\n-  const draggedFacet = nonDeletedFacets[startIndex];\n-  draggedFacet.updated = true;\n-  draggedFacet.orderIndex = draggedFacet.orderIndex + (endIndex - startIndex);\n-  // Remove it from its original place.\n-  nonDeletedFacets.splice(startIndex, 1);\n-  // Update facets within the range\n-  nonDeletedFacets\n-    .filter((facet) => filterFacetsByOrderRange(facet))\n-    .forEach((facet) => {\n-      facet.updated = true;\n-      facet.orderIndex =\n-        facet.orderIndex -\n-        Math.abs(endIndex - startIndex) / (endIndex - startIndex);\n-    });\n-  // Insert the dragged one to the list at its new place.\n-  nonDeletedFacets.splice(endIndex, 0, draggedFacet);\n-  // Combine deleted and non-deleted and return.\n-  return nonDeletedFacets.concat(deletedFacets);\n+\n+    return { ...facet, orderIndex: newOrderIndex, updated: true };\n+  });\n+\n+/**\n+ * Remove a facet from the given list and update order indexes of facets that have a higher order index.\n+ * And return a new array which keep non-deleted facets and those deleted but having an ID back to state.\n+ *\n+ * For example, given an array like [f1, f2, f3, f4], removing f2 results in decrementing\n+ * the order indexes of f3 and f4 by 1.\n+ */\n+export const removeFacetFromList = (\n+  facets: FacetWithFlags[],\n+  deletedFacet: FacetWithFlags\n+) => {", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MTcwOQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428381709", "bodyText": "Rather than requiring a whole facet to be passed in, why not just the orderIndex of target facet?", "author": "edalex-ian", "createdAt": "2020-05-21T00:29:50Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -135,35 +129,48 @@ export const reorder = (\n   facets: FacetWithFlags[],\n   startIndex: number,\n   endIndex: number\n-): FacetWithFlags[] => {\n-  const filterFacetsByOrderRange = (facet: FacetWithFlags) => {\n-    if (startIndex < endIndex) {\n-      return facet.orderIndex > startIndex && facet.orderIndex <= endIndex;\n+): FacetWithFlags[] =>\n+  facets.map((facet) => {\n+    let newOrderIndex = 0;\n+    if (facet.deleted) {\n+      return { ...facet };\n+    }\n+\n+    if (facet.orderIndex === startIndex) {\n+      newOrderIndex = endIndex;\n+    } else if (facet.orderIndex > startIndex && facet.orderIndex <= endIndex) {\n+      newOrderIndex = facet.orderIndex - 1;\n+    } else if (facet.orderIndex >= endIndex && facet.orderIndex < startIndex) {\n+      newOrderIndex = facet.orderIndex + 1;\n+    } else {\n+      return { ...facet };\n     }\n-    return facet.orderIndex >= endIndex && facet.orderIndex < startIndex;\n-  };\n-  // Deep copy to avoid mutating objects of the original array.\n-  const copiedFacets: FacetWithFlags[] = lodash.cloneDeep(facets);\n-  // Deleted facets do not need reordering so leave them alone for now.\n-  const deletedFacets = copiedFacets.filter((facets) => facets.deleted);\n-  const nonDeletedFacets = copiedFacets.filter((facet) => !facet.deleted);\n-  // Update the dragged facet.\n-  const draggedFacet = nonDeletedFacets[startIndex];\n-  draggedFacet.updated = true;\n-  draggedFacet.orderIndex = draggedFacet.orderIndex + (endIndex - startIndex);\n-  // Remove it from its original place.\n-  nonDeletedFacets.splice(startIndex, 1);\n-  // Update facets within the range\n-  nonDeletedFacets\n-    .filter((facet) => filterFacetsByOrderRange(facet))\n-    .forEach((facet) => {\n-      facet.updated = true;\n-      facet.orderIndex =\n-        facet.orderIndex -\n-        Math.abs(endIndex - startIndex) / (endIndex - startIndex);\n-    });\n-  // Insert the dragged one to the list at its new place.\n-  nonDeletedFacets.splice(endIndex, 0, draggedFacet);\n-  // Combine deleted and non-deleted and return.\n-  return nonDeletedFacets.concat(deletedFacets);\n+\n+    return { ...facet, orderIndex: newOrderIndex, updated: true };\n+  });\n+\n+/**\n+ * Remove a facet from the given list and update order indexes of facets that have a higher order index.\n+ * And return a new array which keep non-deleted facets and those deleted but having an ID back to state.\n+ *\n+ * For example, given an array like [f1, f2, f3, f4], removing f2 results in decrementing\n+ * the order indexes of f3 and f4 by 1.\n+ */\n+export const removeFacetFromList = (\n+  facets: FacetWithFlags[],\n+  deletedFacet: FacetWithFlags", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM4MTgyOQ==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428381829", "bodyText": "Missing @param statements.", "author": "edalex-ian", "createdAt": "2020-05-21T00:30:06Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -135,35 +129,48 @@ export const reorder = (\n   facets: FacetWithFlags[],\n   startIndex: number,\n   endIndex: number\n-): FacetWithFlags[] => {\n-  const filterFacetsByOrderRange = (facet: FacetWithFlags) => {\n-    if (startIndex < endIndex) {\n-      return facet.orderIndex > startIndex && facet.orderIndex <= endIndex;\n+): FacetWithFlags[] =>\n+  facets.map((facet) => {\n+    let newOrderIndex = 0;\n+    if (facet.deleted) {\n+      return { ...facet };\n+    }\n+\n+    if (facet.orderIndex === startIndex) {\n+      newOrderIndex = endIndex;\n+    } else if (facet.orderIndex > startIndex && facet.orderIndex <= endIndex) {\n+      newOrderIndex = facet.orderIndex - 1;\n+    } else if (facet.orderIndex >= endIndex && facet.orderIndex < startIndex) {\n+      newOrderIndex = facet.orderIndex + 1;\n+    } else {\n+      return { ...facet };\n     }\n-    return facet.orderIndex >= endIndex && facet.orderIndex < startIndex;\n-  };\n-  // Deep copy to avoid mutating objects of the original array.\n-  const copiedFacets: FacetWithFlags[] = lodash.cloneDeep(facets);\n-  // Deleted facets do not need reordering so leave them alone for now.\n-  const deletedFacets = copiedFacets.filter((facets) => facets.deleted);\n-  const nonDeletedFacets = copiedFacets.filter((facet) => !facet.deleted);\n-  // Update the dragged facet.\n-  const draggedFacet = nonDeletedFacets[startIndex];\n-  draggedFacet.updated = true;\n-  draggedFacet.orderIndex = draggedFacet.orderIndex + (endIndex - startIndex);\n-  // Remove it from its original place.\n-  nonDeletedFacets.splice(startIndex, 1);\n-  // Update facets within the range\n-  nonDeletedFacets\n-    .filter((facet) => filterFacetsByOrderRange(facet))\n-    .forEach((facet) => {\n-      facet.updated = true;\n-      facet.orderIndex =\n-        facet.orderIndex -\n-        Math.abs(endIndex - startIndex) / (endIndex - startIndex);\n-    });\n-  // Insert the dragged one to the list at its new place.\n-  nonDeletedFacets.splice(endIndex, 0, draggedFacet);\n-  // Combine deleted and non-deleted and return.\n-  return nonDeletedFacets.concat(deletedFacets);\n+\n+    return { ...facet, orderIndex: newOrderIndex, updated: true };\n+  });\n+\n+/**\n+ * Remove a facet from the given list and update order indexes of facets that have a higher order index.\n+ * And return a new array which keep non-deleted facets and those deleted but having an ID back to state.\n+ *\n+ * For example, given an array like [f1, f2, f3, f4], removing f2 results in decrementing\n+ * the order indexes of f3 and f4 by 1.\n+ */", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NDM0NA==", "url": "https://github.com/openequella/openEQUELLA/pull/1743#discussion_r428394344", "bodyText": "Not sure we need to mention 'state' here, as this function is nicely independent and oblivious to state. Or should this be \"ID back to server\"?", "author": "edalex-ian", "createdAt": "2020-05-21T01:19:51Z", "path": "Source/Plugins/Core/com.equella.core/js/tsrc/settings/Search/facetedsearch/FacetedSearchSettingsModule.ts", "diffHunk": "@@ -135,35 +129,48 @@ export const reorder = (\n   facets: FacetWithFlags[],\n   startIndex: number,\n   endIndex: number\n-): FacetWithFlags[] => {\n-  const filterFacetsByOrderRange = (facet: FacetWithFlags) => {\n-    if (startIndex < endIndex) {\n-      return facet.orderIndex > startIndex && facet.orderIndex <= endIndex;\n+): FacetWithFlags[] =>\n+  facets.map((facet) => {\n+    let newOrderIndex = 0;\n+    if (facet.deleted) {\n+      return { ...facet };\n+    }\n+\n+    if (facet.orderIndex === startIndex) {\n+      newOrderIndex = endIndex;\n+    } else if (facet.orderIndex > startIndex && facet.orderIndex <= endIndex) {\n+      newOrderIndex = facet.orderIndex - 1;\n+    } else if (facet.orderIndex >= endIndex && facet.orderIndex < startIndex) {\n+      newOrderIndex = facet.orderIndex + 1;\n+    } else {\n+      return { ...facet };\n     }\n-    return facet.orderIndex >= endIndex && facet.orderIndex < startIndex;\n-  };\n-  // Deep copy to avoid mutating objects of the original array.\n-  const copiedFacets: FacetWithFlags[] = lodash.cloneDeep(facets);\n-  // Deleted facets do not need reordering so leave them alone for now.\n-  const deletedFacets = copiedFacets.filter((facets) => facets.deleted);\n-  const nonDeletedFacets = copiedFacets.filter((facet) => !facet.deleted);\n-  // Update the dragged facet.\n-  const draggedFacet = nonDeletedFacets[startIndex];\n-  draggedFacet.updated = true;\n-  draggedFacet.orderIndex = draggedFacet.orderIndex + (endIndex - startIndex);\n-  // Remove it from its original place.\n-  nonDeletedFacets.splice(startIndex, 1);\n-  // Update facets within the range\n-  nonDeletedFacets\n-    .filter((facet) => filterFacetsByOrderRange(facet))\n-    .forEach((facet) => {\n-      facet.updated = true;\n-      facet.orderIndex =\n-        facet.orderIndex -\n-        Math.abs(endIndex - startIndex) / (endIndex - startIndex);\n-    });\n-  // Insert the dragged one to the list at its new place.\n-  nonDeletedFacets.splice(endIndex, 0, draggedFacet);\n-  // Combine deleted and non-deleted and return.\n-  return nonDeletedFacets.concat(deletedFacets);\n+\n+    return { ...facet, orderIndex: newOrderIndex, updated: true };\n+  });\n+\n+/**\n+ * Remove a facet from the given list and update order indexes of facets that have a higher order index.\n+ * And return a new array which keep non-deleted facets and those deleted but having an ID back to state.", "originalCommit": "b1101bf8b8ce9f0ef6316408bdb0cd471e26808f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "18aef179b3fd20e37ff5b32280a798d8e56b3fda", "url": "https://github.com/openequella/openEQUELLA/commit/18aef179b3fd20e37ff5b32280a798d8e56b3fda", "message": "Reword the descriptions of the Jest test of Faceted search setting page;\n\nMake function 'removeFacetFromList' take an order index as a parameter\nrather than the whole facet.", "committedDate": "2020-05-22T00:36:27Z", "type": "commit"}, {"oid": "6fe9fc31c65297492650f4fd23f9bb5fd601e0e1", "url": "https://github.com/openequella/openEQUELLA/commit/6fe9fc31c65297492650f4fd23f9bb5fd601e0e1", "message": "In the Jest test of Facet search setting, as we know the testing IDs must\nexist, add '!' after 'reorderFacets.find((f) => f.id === xxx)' to make\nTypescript happy.", "committedDate": "2020-05-22T01:09:20Z", "type": "commit"}, {"oid": "0c6743cd64cef9573b23527255c99566d1e0f77c", "url": "https://github.com/openequella/openEQUELLA/commit/0c6743cd64cef9573b23527255c99566d1e0f77c", "message": "Merge branch 'component/search_configuration' into feature/reorder-facets", "committedDate": "2020-05-22T01:19:04Z", "type": "commit"}, {"oid": "a2496dbbb0506085d47a42635bf905060fdf2c97", "url": "https://github.com/openequella/openEQUELLA/commit/a2496dbbb0506085d47a42635bf905060fdf2c97", "message": "update package-lock.json for 'react-beautiful-dnd'.", "committedDate": "2020-05-22T01:22:38Z", "type": "commit"}]}