{"pr_number": 16830, "pr_title": "SQL: Root operator (#16829)", "pr_createdAt": "2020-03-31T12:24:28Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16830", "timeline": [{"oid": "b646dc26aaf9e41e53f50679392df59eb91be510", "url": "https://github.com/hazelcast/hazelcast/commit/b646dc26aaf9e41e53f50679392df59eb91be510", "message": "Implemented root operator.", "committedDate": "2020-03-31T12:20:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5MTI3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401491276", "bodyText": "Subsequent calls must return the same instance\n\nLooks like QueryResultProducer is itself an iterator.", "author": "taburet", "createdAt": "2020-04-01T09:50:06Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/QueryResultProducer.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * Generic interface which produces iterator over results which are then delivered to users.\n+ * Returned iterator must provide rows which were not returned yet.\n+ */\n+public interface QueryResultProducer {\n+    /**\n+     * Get iterator over results. Subsequent calls must return the same instance.", "originalCommit": "b646dc26aaf9e41e53f50679392df59eb91be510", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUwMDE1MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401500151", "bodyText": "Yes. There are no strong indications for an inheritance, so the composition is used instead because it simplifies testing.", "author": "devozerov", "createdAt": "2020-04-01T10:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5MTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401498938", "bodyText": "Are push/pop public only for testing purposes?", "author": "taburet", "createdAt": "2020-04-01T10:02:24Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/CreateExecPlanNodeVisitor.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec;\n+\n+import com.hazelcast.sql.impl.exec.root.RootExec;\n+import com.hazelcast.sql.impl.operation.QueryExecuteOperation;\n+import com.hazelcast.sql.impl.plan.node.PlanNode;\n+import com.hazelcast.sql.impl.plan.node.PlanNodeVisitor;\n+import com.hazelcast.sql.impl.plan.node.RootPlanNode;\n+\n+import java.util.ArrayList;\n+\n+ /**\n+ * Visitor which builds an executor for every observed physical node.\n+ */\n+public class CreateExecPlanNodeVisitor implements PlanNodeVisitor {\n+    /** Operation. */\n+    private final QueryExecuteOperation operation;\n+\n+    /** Stack of elements to be merged. */\n+    private final ArrayList<Exec> stack = new ArrayList<>(1);\n+\n+    /** Result. */\n+    private Exec exec;\n+\n+    public CreateExecPlanNodeVisitor(\n+        QueryExecuteOperation operation\n+    ) {\n+        this.operation = operation;\n+    }\n+\n+    @Override\n+    public void onRootNode(RootPlanNode node) {\n+        assert stack.size() == 1;\n+\n+        exec = new RootExec(\n+            node.getId(),\n+            pop(),\n+            operation.getRootConsumer(),\n+            operation.getRootBatchSize()\n+        );\n+    }\n+\n+    @Override\n+    public void onOtherNode(PlanNode node) {\n+        if (node instanceof CreateExecPlanNodeVisitorCallback) {\n+            ((CreateExecPlanNodeVisitorCallback) node).onVisit(this);\n+        } else {\n+            throw new UnsupportedOperationException(\"Unsupported node: \" + node);\n+        }\n+    }\n+\n+    public Exec getExec() {\n+        return exec;\n+    }\n+\n+    public Exec pop() {", "originalCommit": "b646dc26aaf9e41e53f50679392df59eb91be510", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUwMDU0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401500545", "bodyText": "Yes, otherwise it is impossible to introduce new plan nodes and execs for testing.", "author": "devozerov", "createdAt": "2020-04-01T10:05:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUxNDQyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401514422", "bodyText": "Probably they deserve \"only for testing\" comment.", "author": "taburet", "createdAt": "2020-04-01T10:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUxNTE3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401515177", "bodyText": "They are exposed as public for testing, but they are also used by the real implementation (e.g. see root node processing).", "author": "devozerov", "createdAt": "2020-04-01T10:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUxNjcxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401516717", "bodyText": "\"public only for testing\" comment? :)", "author": "taburet", "createdAt": "2020-04-01T10:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1OTI0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401559244", "bodyText": "Got it. Added JavaDoc.", "author": "devozerov", "createdAt": "2020-04-01T11:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTQ5ODkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMDA5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401530099", "bodyText": "That implies next can be called without preceding hasNext call, is that possible?", "author": "taburet", "createdAt": "2020-04-01T10:58:58Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/exec/root/BlockingRootResultConsumer.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.exec.root;\n+\n+import com.hazelcast.sql.HazelcastSqlException;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.worker.QueryFragmentContext;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+\n+/**\n+ * Blocking array-based result consumer which delivers the results to API caller.\n+ */\n+public class BlockingRootResultConsumer implements RootResultConsumer {\n+    /** Mutex for concurrency support. */\n+    private final Object mux = new Object();\n+\n+    /** Iterator over produced rows. */\n+    private final InternalIterator iterator = new InternalIterator();\n+\n+    /** Query context to schedule root execution when the next batch is needed. */\n+    private volatile QueryFragmentContext context;\n+\n+    /** The batch that is currently being consumed. */\n+    private List<Row> currentBatch;\n+\n+    /** When \"true\" no more batches are expected. */\n+    private boolean done;\n+\n+    /** Error which occurred during query execution. */\n+    private HazelcastSqlException doneError;\n+\n+    @Override\n+    public void setup(QueryFragmentContext context) {\n+        this.context = context;\n+    }\n+\n+    @Override\n+    public boolean consume(List<Row> batch, boolean last) {\n+        assert !batch.isEmpty();\n+\n+        synchronized (mux) {\n+            assert !done;\n+\n+            if (currentBatch == null) {\n+                currentBatch = batch;\n+\n+                if (last) {\n+                    done = true;\n+                }\n+\n+                mux.notifyAll();\n+\n+                return true;\n+            } else {\n+                return false;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void onError(HazelcastSqlException error) {\n+        synchronized (mux) {\n+            if (!done) {\n+                done = true;\n+                doneError = error;\n+\n+                mux.notifyAll();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Poll the next batch from the upstream, waiting if needed.\n+     *\n+     * @return The batch or {@code null} if end of stream is reached.\n+     */\n+    private List<Row> awaitNextBatch() {\n+        synchronized (mux) {\n+            while (true) {\n+                // Consume the batch if it is available.\n+                if (currentBatch != null) {\n+                    List<Row> res = currentBatch;\n+\n+                    currentBatch = null;\n+\n+                    return res;\n+                }\n+\n+                // Handle end of the stream.\n+                if (done) {\n+                    if (doneError != null) {\n+                        throw doneError;\n+                    }\n+\n+                    return null;\n+                }\n+\n+                // Otherwise wait.\n+                try {\n+                    mux.wait();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+\n+                    throw HazelcastSqlException.error(\"Thread was interrupted while waiting for more results.\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Request the next batch from the executor.\n+     */\n+    private void requestNextBatch() {\n+        synchronized (mux) {\n+            if (done) {\n+                return;\n+            }\n+        }\n+\n+        // We may reach this place only if some rows are already produced, and this is possible only after the setup,\n+        // so the context should be initialized.\n+        assert context != null;\n+\n+        context.schedule();\n+    }\n+\n+    @Override\n+    public Iterator<Row> iterator() {\n+        return iterator;\n+    }\n+\n+    /**\n+     * Iterator over results.\n+     */\n+    private class InternalIterator implements Iterator<Row> {\n+\n+        private List<Row> batch;\n+        private int position;\n+\n+        @Override\n+        public boolean hasNext() {\n+            setNextBatchIfNeeded();\n+\n+            assert batch != null || done;\n+\n+            return batch != null;\n+        }\n+\n+        @Override\n+        public Row next() {\n+            setNextBatchIfNeeded();", "originalCommit": "b646dc26aaf9e41e53f50679392df59eb91be510", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU1OTYyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401559621", "bodyText": "Yes, it is possible. The Iterator interface doesn't require users to call hasNext first.", "author": "devozerov", "createdAt": "2020-04-01T11:57:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMDA5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU4MjA3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401582070", "bodyText": "I'd replace it with the\nif (!hasNext()) {\n    throw new NoSuchElementException();\n}", "author": "petrpleshachkov", "createdAt": "2020-04-01T12:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMDA5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYwMTY2NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401601665", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-04-01T13:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUzMDA5OQ=="}], "type": "inlineReview"}, {"oid": "b81fd1281e6aec85638b3a37b8e41adfd5d36ef1", "url": "https://github.com/hazelcast/hazelcast/commit/b81fd1281e6aec85638b3a37b8e41adfd5d36ef1", "message": "Review comments.", "committedDate": "2020-04-01T11:56:26Z", "type": "commit"}, {"oid": "72ee4a8eac960c3e675271f9bdad90a6068ceaee", "url": "https://github.com/hazelcast/hazelcast/commit/72ee4a8eac960c3e675271f9bdad90a6068ceaee", "message": "Review comments.", "committedDate": "2020-04-01T13:09:37Z", "type": "commit"}, {"oid": "8fb290356a3f5bcf37176e8d35359ec6e71c2e52", "url": "https://github.com/hazelcast/hazelcast/commit/8fb290356a3f5bcf37176e8d35359ec6e71c2e52", "message": "Simplified further.", "committedDate": "2020-04-01T13:11:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU5MjU0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401592547", "bodyText": "It seems the old version is grammatically correct? :-)", "author": "petrpleshachkov", "createdAt": "2020-04-01T12:55:36Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/mailbox/OutboundHandler.java", "diffHunk": "@@ -23,7 +23,7 @@\n     /**\n      * Handle flow control response from the remote inbound handler.\n      *\n-     * @param remainingMemory Amount of memory which is available on the remote end.", "originalCommit": "b81fd1281e6aec85638b3a37b8e41adfd5d36ef1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTYxMjM2OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16830#discussion_r401612368", "bodyText": "Fixed. Bad merge, I guess )", "author": "devozerov", "createdAt": "2020-04-01T13:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTU5MjU0Nw=="}], "type": "inlineReview"}, {"oid": "4e88e4b2e8696e7f92a0129792679b1c938c7683", "url": "https://github.com/hazelcast/hazelcast/commit/4e88e4b2e8696e7f92a0129792679b1c938c7683", "message": "Typo.", "committedDate": "2020-04-01T13:24:57Z", "type": "commit"}]}