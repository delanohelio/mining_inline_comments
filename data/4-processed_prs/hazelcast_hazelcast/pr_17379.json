{"pr_number": 17379, "pr_title": "Introduce SQL string functions (#17378)", "pr_createdAt": "2020-08-19T13:17:09Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17379", "timeline": [{"oid": "977c38cd535043f2127d900b5cab6a69656cf3cf", "url": "https://github.com/hazelcast/hazelcast/commit/977c38cd535043f2127d900b5cab6a69656cf3cf", "message": "SQL math expressions (#17339)", "committedDate": "2020-08-12T15:23:50Z", "type": "commit"}, {"oid": "298a55b287a0d68f302eb17d2189e10cb7aa10cc", "url": "https://github.com/hazelcast/hazelcast/commit/298a55b287a0d68f302eb17d2189e10cb7aa10cc", "message": "Merge branch 'master' into issues/17339\n\n# Conflicts:\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/SqlTestSupport.java", "committedDate": "2020-08-14T06:01:45Z", "type": "commit"}, {"oid": "474282c2fda86b821e4666ea6ada8bff548f4f89", "url": "https://github.com/hazelcast/hazelcast/commit/474282c2fda86b821e4666ea6ada8bff548f4f89", "message": "Refactored tests", "committedDate": "2020-08-14T06:35:15Z", "type": "commit"}, {"oid": "e3edaf8de7f23d9af988aebc44332c0e4a5128f2", "url": "https://github.com/hazelcast/hazelcast/commit/e3edaf8de7f23d9af988aebc44332c0e4a5128f2", "message": "ABS tests for negative zero", "committedDate": "2020-08-14T06:40:47Z", "type": "commit"}, {"oid": "932c75f84fdec229b719bda8067b0db573bebfda", "url": "https://github.com/hazelcast/hazelcast/commit/932c75f84fdec229b719bda8067b0db573bebfda", "message": "Removed unnecessary tests for Float.MIN_VALUE and Double.MIN_VALUE", "committedDate": "2020-08-14T06:42:31Z", "type": "commit"}, {"oid": "5cd155b6a6d1313e18bd3cc57dfda2c69be7d1b8", "url": "https://github.com/hazelcast/hazelcast/commit/5cd155b6a6d1313e18bd3cc57dfda2c69be7d1b8", "message": "Added missing test for numeric literals in single quotes for CEIL/FLOOR tests", "committedDate": "2020-08-14T06:45:08Z", "type": "commit"}, {"oid": "20a0d1a438f5d09cbf25a948c0af91fc4d0620a4", "url": "https://github.com/hazelcast/hazelcast/commit/20a0d1a438f5d09cbf25a948c0af91fc4d0620a4", "message": "Test for several rows for RAND", "committedDate": "2020-08-14T06:51:12Z", "type": "commit"}, {"oid": "95442d9b91abe7324b404b3fee044505319410ce", "url": "https://github.com/hazelcast/hazelcast/commit/95442d9b91abe7324b404b3fee044505319410ce", "message": "Added \"notAny\" to ROUND/TRUNCATE", "committedDate": "2020-08-14T07:00:40Z", "type": "commit"}, {"oid": "d466387bbc40ac2977bf76730cb827e30455df61", "url": "https://github.com/hazelcast/hazelcast/commit/d466387bbc40ac2977bf76730cb827e30455df61", "message": "Fixed inference for double functions (DECIMAL -> DOUBLE) and RAND (DECIMAL -> BIGINT)", "committedDate": "2020-08-14T07:10:09Z", "type": "commit"}, {"oid": "cbe1191d997e2ec6b6f153bf26bcb58fa23ff189", "url": "https://github.com/hazelcast/hazelcast/commit/cbe1191d997e2ec6b6f153bf26bcb58fa23ff189", "message": "Fixed SpotBugs problem", "committedDate": "2020-08-14T07:34:58Z", "type": "commit"}, {"oid": "493b6d471f6c1fa75b02a2de74eb800763df1d97", "url": "https://github.com/hazelcast/hazelcast/commit/493b6d471f6c1fa75b02a2de74eb800763df1d97", "message": "Changed operand type inference for double functions", "committedDate": "2020-08-14T08:45:54Z", "type": "commit"}, {"oid": "883ec348410adabed42e705bc43486fd47910e34", "url": "https://github.com/hazelcast/hazelcast/commit/883ec348410adabed42e705bc43486fd47910e34", "message": "DoubleFunction: removed concrete functions from JavaDoc.", "committedDate": "2020-08-14T09:02:35Z", "type": "commit"}, {"oid": "f3111ee9c98418fbbe9a62cf6382f033755058d5", "url": "https://github.com/hazelcast/hazelcast/commit/f3111ee9c98418fbbe9a62cf6382f033755058d5", "message": "Explicit inference for RAND", "committedDate": "2020-08-14T11:26:26Z", "type": "commit"}, {"oid": "71084cebcb6c919e0639a367f33369499f968d0d", "url": "https://github.com/hazelcast/hazelcast/commit/71084cebcb6c919e0639a367f33369499f968d0d", "message": "Assert types in RoundTruncateFunction", "committedDate": "2020-08-14T11:35:24Z", "type": "commit"}, {"oid": "9c400000d1523948822545362cc863d509afeabc", "url": "https://github.com/hazelcast/hazelcast/commit/9c400000d1523948822545362cc863d509afeabc", "message": "Extended tests for RAND", "committedDate": "2020-08-14T11:38:25Z", "type": "commit"}, {"oid": "63b76e16d69d95177d08f87bb4efef4f949b83c3", "url": "https://github.com/hazelcast/hazelcast/commit/63b76e16d69d95177d08f87bb4efef4f949b83c3", "message": "Checkstyle", "committedDate": "2020-08-14T11:40:12Z", "type": "commit"}, {"oid": "5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "url": "https://github.com/hazelcast/hazelcast/commit/5ce9f81ee0c5574f58c1197f9107bea75f3c9e51", "message": "Added lenght overflow handling to ROUND/TRUNCATE", "committedDate": "2020-08-14T12:16:16Z", "type": "commit"}, {"oid": "dfaecc359d9ca7ccc76f148ea7149796ceb862f7", "url": "https://github.com/hazelcast/hazelcast/commit/dfaecc359d9ca7ccc76f148ea7149796ceb862f7", "message": "Merge branch 'master' into issues/17339", "committedDate": "2020-08-15T07:48:45Z", "type": "commit"}, {"oid": "6b2cf5f249013cf53d34b8d63625624de1cde5ca", "url": "https://github.com/hazelcast/hazelcast/commit/6b2cf5f249013cf53d34b8d63625624de1cde5ca", "message": "Predicates", "committedDate": "2020-08-15T14:28:58Z", "type": "commit"}, {"oid": "9654d668ef107bd5a3b7d1dccdcfe4efb8948e4e", "url": "https://github.com/hazelcast/hazelcast/commit/9654d668ef107bd5a3b7d1dccdcfe4efb8948e4e", "message": "WIP on tests", "committedDate": "2020-08-17T07:09:41Z", "type": "commit"}, {"oid": "87bfbdc0702a4b8a10739e64f7f922ccbea4d998", "url": "https://github.com/hazelcast/hazelcast/commit/87bfbdc0702a4b8a10739e64f7f922ccbea4d998", "message": "wip", "committedDate": "2020-08-17T07:32:01Z", "type": "commit"}, {"oid": "a70841209bd9c914591e087d5467c0eb9cefb667", "url": "https://github.com/hazelcast/hazelcast/commit/a70841209bd9c914591e087d5467c0eb9cefb667", "message": "wip", "committedDate": "2020-08-17T09:27:59Z", "type": "commit"}, {"oid": "c857ffa974be0181e3f3f72daefa547ad8e694a2", "url": "https://github.com/hazelcast/hazelcast/commit/c857ffa974be0181e3f3f72daefa547ad8e694a2", "message": "WIP", "committedDate": "2020-08-17T10:56:10Z", "type": "commit"}, {"oid": "5d78551ec10c434ec481669e5c111daf3fddd895", "url": "https://github.com/hazelcast/hazelcast/commit/5d78551ec10c434ec481669e5c111daf3fddd895", "message": "SUBSTRING ready", "committedDate": "2020-08-17T11:39:41Z", "type": "commit"}, {"oid": "dfaaf2843c0cf50137ed752805a1eea8cddd82bb", "url": "https://github.com/hazelcast/hazelcast/commit/dfaaf2843c0cf50137ed752805a1eea8cddd82bb", "message": "IDs", "committedDate": "2020-08-19T13:06:39Z", "type": "commit"}, {"oid": "2125ed36b764146a68f872b9f58826aa90eaefad", "url": "https://github.com/hazelcast/hazelcast/commit/2125ed36b764146a68f872b9f58826aa90eaefad", "message": "Merge branch 'master' into sql-string-exp\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/parse/UnsupportedOperationVisitor.java\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/SqlDataSerializerHook.java", "committedDate": "2020-08-19T13:08:47Z", "type": "commit"}, {"oid": "b828911b95c636c4b27c19b9b889dd180bb0d7f5", "url": "https://github.com/hazelcast/hazelcast/commit/b828911b95c636c4b27c19b9b889dd180bb0d7f5", "message": "SUID for LikeFunction", "committedDate": "2020-08-19T14:03:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNTY4NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473635685", "bodyText": "notAny", "author": "taburet", "createdAt": "2020-08-20T06:14:02Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/HazelcastSqlOperatorTable.java", "diffHunk": "@@ -337,6 +341,59 @@\n \n     //#endregion\n \n+    //#region String functions\n+\n+    public static final SqlBinaryOperator CONCAT = new SqlBinaryOperator(\n+        \"||\",\n+        SqlKind.OTHER,\n+        60,\n+        true,\n+        ReturnTypes.DYADIC_STRING_SUM_PRECISION_NULLABLE,\n+        HazelcastInferTypes.VARCHAR_IF_UNKNOWN,\n+        OperandTypes.STRING_SAME_SAME", "originalCommit": "b828911b95c636c4b27c19b9b889dd180bb0d7f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1MTQ4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473651488", "bodyText": "Fixed in 6a01e16", "author": "devozerov", "createdAt": "2020-08-20T06:36:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNTY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNjAxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473636016", "bodyText": "precedence", "author": "taburet", "createdAt": "2020-08-20T06:14:40Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlLikeOperator.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlSpecialOperator;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+\n+public class HazelcastSqlLikeOperator extends SqlSpecialOperator {\n+\n+    private static final int PRECISION = 32;", "originalCommit": "b828911b95c636c4b27c19b9b889dd180bb0d7f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1MTU5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473651590", "bodyText": "Renamed in 6a01e16", "author": "devozerov", "createdAt": "2020-08-20T06:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNjAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNjEzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473636137", "bodyText": "notAny", "author": "taburet", "createdAt": "2020-08-20T06:14:49Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlLikeOperator.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlSpecialOperator;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlSingleOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.calcite.sql.type.SqlTypeUtil;\n+\n+public class HazelcastSqlLikeOperator extends SqlSpecialOperator {\n+\n+    private static final int PRECISION = 32;\n+\n+    public HazelcastSqlLikeOperator() {\n+        super(\n+            \"LIKE\",\n+            SqlKind.LIKE,\n+            PRECISION,\n+            false,\n+            ReturnTypes.BOOLEAN_NULLABLE,\n+            new ReplaceUnknownOperandTypeInference(SqlTypeName.VARCHAR),\n+            null", "originalCommit": "b828911b95c636c4b27c19b9b889dd180bb0d7f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1MTcwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473651700", "bodyText": "Fixed in 6a01e16", "author": "devozerov", "createdAt": "2020-08-20T06:36:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNjEzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNzgxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473637819", "bodyText": "notAny", "author": "taburet", "createdAt": "2020-08-20T06:17:16Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlStringFunction.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.hazelcast.sql.impl.calcite.validate.types.HazelcastInferTypes;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.SqlReturnTypeInference;\n+\n+public class HazelcastSqlStringFunction extends SqlFunction {\n+    public HazelcastSqlStringFunction(String name, SqlReturnTypeInference returnTypeInference) {\n+        super(\n+            name,\n+            SqlKind.OTHER_FUNCTION,\n+            returnTypeInference,\n+            HazelcastInferTypes.VARCHAR_IF_UNKNOWN,\n+            OperandTypes.CHARACTER,", "originalCommit": "b828911b95c636c4b27c19b9b889dd180bb0d7f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1MTkzNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473651937", "bodyText": "Fixed in 6a01e16", "author": "devozerov", "createdAt": "2020-08-20T06:36:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzNzgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzODQ2Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473638462", "bodyText": "notAny", "author": "taburet", "createdAt": "2020-08-20T06:18:12Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/operators/HazelcastSqlSubstringFunction.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.calcite.validate.operators;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.hazelcast.sql.impl.calcite.validate.types.ReplaceUnknownOperandTypeInference;\n+import org.apache.calcite.linq4j.Ord;\n+import org.apache.calcite.sql.SqlCall;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlKind;\n+import org.apache.calcite.sql.SqlNode;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlUtil;\n+import org.apache.calcite.sql.SqlWriter;\n+import org.apache.calcite.sql.type.FamilyOperandTypeChecker;\n+import org.apache.calcite.sql.type.OperandTypes;\n+import org.apache.calcite.sql.type.ReturnTypes;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+\n+import java.util.List;\n+\n+import static org.apache.calcite.sql.type.SqlTypeName.INTEGER;\n+import static org.apache.calcite.sql.type.SqlTypeName.VARCHAR;\n+\n+public class HazelcastSqlSubstringFunction extends SqlFunction {\n+    public HazelcastSqlSubstringFunction() {\n+        super(\n+            \"SUBSTRING\",\n+            SqlKind.OTHER_FUNCTION,\n+            ReturnTypes.ARG0_NULLABLE_VARYING,\n+            new ReplaceUnknownOperandTypeInference(new SqlTypeName[] { VARCHAR, INTEGER, INTEGER }),\n+            null,\n+            SqlFunctionCategory.STRING\n+        );\n+    }\n+\n+    @Override\n+    public String getSignatureTemplate(int operandsCount) {\n+        switch (operandsCount) {\n+            case 2:\n+                return \"{0}({1} FROM {2})\";\n+            case 3:\n+                return \"{0}({1} FROM {2} FOR {3})\";\n+            default:\n+                throw new AssertionError();\n+        }\n+    }\n+\n+    @Override\n+    public String getAllowedSignatures(String opName) {\n+        StringBuilder ret = new StringBuilder();\n+        for (Ord<SqlTypeName> typeName : Ord.zip(SqlTypeName.CHAR_TYPES)) {\n+            if (typeName.i > 0) {\n+                ret.append(NL);\n+            }\n+\n+            ret.append(\n+                SqlUtil.getAliasedSignature(this, opName, ImmutableList.of(typeName.e, SqlTypeName.INTEGER))\n+            );\n+            ret.append(NL);\n+            ret.append(\n+                SqlUtil.getAliasedSignature(this, opName, ImmutableList.of(typeName.e, SqlTypeName.INTEGER, SqlTypeName.INTEGER))\n+            );\n+        }\n+        return ret.toString();\n+    }\n+\n+    @Override\n+    public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure) {", "originalCommit": "b828911b95c636c4b27c19b9b889dd180bb0d7f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1MTk3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473651978", "bodyText": "Fixed in 6a01e16", "author": "devozerov", "createdAt": "2020-08-20T06:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzYzODQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY0NDAwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473644002", "bodyText": ".equals?", "author": "taburet", "createdAt": "2020-08-20T06:26:12Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/validate/types/HazelcastInferTypes.java", "diffHunk": "@@ -81,6 +81,18 @@\n         }\n     };\n \n+    public static final SqlOperandTypeInference VARCHAR_IF_UNKNOWN = (callBinding, returnType, operandTypes) -> {\n+        RelDataType unknownType = callBinding.getTypeFactory().createUnknownType();\n+\n+        for (int i = 0; i < operandTypes.length; i++) {\n+            RelDataType operandType = operandTypes[i];\n+\n+            if (operandType == unknownType) {", "originalCommit": "b828911b95c636c4b27c19b9b889dd180bb0d7f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1MjUxNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473652516", "bodyText": "Removed this anonymous class. Now using ReplaceUnknownOperandTypeInference, where this specific == has been replaced with equals.\nSee 6a01e16", "author": "devozerov", "createdAt": "2020-08-20T06:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY0NDAwMg=="}], "type": "inlineReview"}, {"oid": "6a01e16bd9b3450ef82536e461db30bb9017f1bc", "url": "https://github.com/hazelcast/hazelcast/commit/6a01e16bd9b3450ef82536e461db30bb9017f1bc", "message": "WIP on review comments", "committedDate": "2020-08-20T06:35:03Z", "type": "commit"}, {"oid": "03e7d2db16ccae3341710b34cec000554d079d43", "url": "https://github.com/hazelcast/hazelcast/commit/03e7d2db16ccae3341710b34cec000554d079d43", "message": "Adjusted type IDs to simplify merge with indexes PR.", "committedDate": "2020-08-20T06:35:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1MjY1Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473652657", "bodyText": "that's not ascii, that's unicode code point", "author": "taburet", "createdAt": "2020-08-20T06:37:52Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");\n+    }\n+\n+    public static Integer position(String seek, String source, int position) {\n+        if (seek == null) {\n+            return null;\n+        }\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        if (position == 0) {\n+            return source.indexOf(seek) + 1;\n+        } else {\n+            int position0 = position - 1;\n+\n+            if (position0 < 0 || position0 > source.length()) {\n+                return 0;\n+            }\n+\n+            return source.indexOf(seek, position0) + 1;\n+        }\n+    }\n+\n+    public static String substring(String source, Integer startPos, Integer length) {\n+        // TODO: Validate the implementation against ANSI.\n+        if (source == null || startPos == null || length == null) {\n+            return null;\n+        }\n+\n+        int sourceLength = source.length();\n+\n+        if (startPos < 0) {\n+            startPos += sourceLength + 1;\n+        }\n+\n+        int endPos = startPos + length;\n+\n+        if (endPos < startPos) {\n+            throw QueryException.error(\"End position is less than start position.\");\n+        }\n+\n+        if (startPos > sourceLength || endPos < 1) {\n+            return \"\";\n+        }\n+\n+        int startPos0 = Math.max(startPos, 1);\n+        int endPos0 = Math.min(endPos, sourceLength + 1);\n+\n+        return source.substring(startPos0 - 1, endPos0 - 1);\n+    }\n+\n+    public static Integer charLength(String value) {\n+        return value != null ? value.length() : null;\n+    }\n+\n+    public static Integer ascii(String value) {\n+        return value != null ? value.isEmpty() ? 0 : value.codePointAt(0) : null;", "originalCommit": "b828911b95c636c4b27c19b9b889dd180bb0d7f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2NTMyNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473665326", "bodyText": "What is the problem with it? Will it return incorrect values for some ASCII characters?\nThe behavior of this function is not well-defined for non-ASCII characters. The only common thing across databases is that it should return the value that could be converted back to the same character through CHR/NCHAR/etc function. This will be possible with Character.toChars() when it is time to implement CHR function.\nPerhaps a simple cast should also work fine.", "author": "devozerov", "createdAt": "2020-08-20T06:54:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1MjY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1ODM4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473658382", "bodyText": "if at least one operand is null, it should return null", "author": "taburet", "createdAt": "2020-08-20T06:45:31Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");", "originalCommit": "03e7d2db16ccae3341710b34cec000554d079d43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2OTI5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473669291", "bodyText": "There is no such requirement in the standard. It is up to the vendor to decide how to treat NULL values here. E.g. PG and MySQL return NULL in this case, while Oracle and SQL Server treats NULL as an empty string.\nWhy do you think that returning NULL is better than treating it as an empty string?", "author": "devozerov", "createdAt": "2020-08-20T06:59:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1ODM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY5ODA0OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473698048", "bodyText": "From the standard:\n<concatenation> ::= <character value expression> <concatenation operator> <character factor>\n...\nLet S1 and S2 be the result of the <character value expression> and <character factor>, respectively.\n...\nIf either S1 or S2 is the null value, then the result of the <concatenation> is the null value.", "author": "taburet", "createdAt": "2020-08-20T07:33:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1ODM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcxODM3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473718375", "bodyText": "Fixed in 2dab533", "author": "devozerov", "createdAt": "2020-08-20T07:49:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1ODM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2MjEyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473662125", "bodyText": "if escape was provided and its value is null, it should return null", "author": "taburet", "createdAt": "2020-08-20T06:50:22Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape = operand3 != null ? asVarchar(operand3, row, context) : null;", "originalCommit": "03e7d2db16ccae3341710b34cec000554d079d43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY3NzEzNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473677136", "bodyText": "Fixed in bf96a79", "author": "devozerov", "createdAt": "2020-08-20T07:09:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2MjEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2NDQ5Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473664497", "bodyText": "never used", "author": "taburet", "createdAt": "2020-08-20T06:53:25Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");\n+    }\n+\n+    public static Integer position(String seek, String source, int position) {\n+        if (seek == null) {\n+            return null;\n+        }\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        if (position == 0) {\n+            return source.indexOf(seek) + 1;\n+        } else {\n+            int position0 = position - 1;\n+\n+            if (position0 < 0 || position0 > source.length()) {\n+                return 0;\n+            }\n+\n+            return source.indexOf(seek, position0) + 1;\n+        }\n+    }\n+\n+    public static String substring(String source, Integer startPos, Integer length) {", "originalCommit": "03e7d2db16ccae3341710b34cec000554d079d43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY3NjgwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473676806", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-08-20T07:09:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2NDQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2NDU2OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473664569", "bodyText": "never used", "author": "taburet", "createdAt": "2020-08-20T06:53:31Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");\n+    }\n+\n+    public static Integer position(String seek, String source, int position) {", "originalCommit": "03e7d2db16ccae3341710b34cec000554d079d43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY3Njg3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473676873", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-08-20T07:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY2NDU2OQ=="}], "type": "inlineReview"}, {"oid": "571f47ec6ddf8c9d19bc8d3b64fcfc6b9871160c", "url": "https://github.com/hazelcast/hazelcast/commit/571f47ec6ddf8c9d19bc8d3b64fcfc6b9871160c", "message": "Remove leftovers", "committedDate": "2020-08-20T07:08:41Z", "type": "commit"}, {"oid": "bf96a792b021e758f55a09c628d72d04b8d98594", "url": "https://github.com/hazelcast/hazelcast/commit/bf96a792b021e758f55a09c628d72d04b8d98594", "message": "Return NULL if LIKE ESCAPE is NULL", "committedDate": "2020-08-20T07:08:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4MDYwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473680604", "bodyText": "why title case and not upper case?", "author": "taburet", "createdAt": "2020-08-20T07:13:37Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");\n+    }\n+\n+    public static Integer position(String seek, String source, int position) {\n+        if (seek == null) {\n+            return null;\n+        }\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        if (position == 0) {\n+            return source.indexOf(seek) + 1;\n+        } else {\n+            int position0 = position - 1;\n+\n+            if (position0 < 0 || position0 > source.length()) {\n+                return 0;\n+            }\n+\n+            return source.indexOf(seek, position0) + 1;\n+        }\n+    }\n+\n+    public static String substring(String source, Integer startPos, Integer length) {\n+        // TODO: Validate the implementation against ANSI.\n+        if (source == null || startPos == null || length == null) {\n+            return null;\n+        }\n+\n+        int sourceLength = source.length();\n+\n+        if (startPos < 0) {\n+            startPos += sourceLength + 1;\n+        }\n+\n+        int endPos = startPos + length;\n+\n+        if (endPos < startPos) {\n+            throw QueryException.error(\"End position is less than start position.\");\n+        }\n+\n+        if (startPos > sourceLength || endPos < 1) {\n+            return \"\";\n+        }\n+\n+        int startPos0 = Math.max(startPos, 1);\n+        int endPos0 = Math.min(endPos, sourceLength + 1);\n+\n+        return source.substring(startPos0 - 1, endPos0 - 1);\n+    }\n+\n+    public static Integer charLength(String value) {\n+        return value != null ? value.length() : null;\n+    }\n+\n+    public static Integer ascii(String value) {\n+        return value != null ? value.isEmpty() ? 0 : value.codePointAt(0) : null;\n+    }\n+\n+    public static String upper(String value) {\n+        return value != null ? value.toUpperCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String lower(String value) {\n+        return value != null ? value.toLowerCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String initcap(String value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        if (value.isEmpty()) {\n+            return value;\n+        }\n+\n+        int strLen = value.length();\n+\n+        StringBuilder res = new StringBuilder(strLen);\n+\n+        boolean capitalizeNext = true;\n+\n+        for (int i = 0; i < strLen; i++) {\n+            char c = value.charAt(i);\n+\n+            if (Character.isWhitespace(c)) {\n+                res.append(c);\n+\n+                capitalizeNext = true;\n+            } else if (capitalizeNext) {\n+                res.append(Character.toTitleCase(c));", "originalCommit": "03e7d2db16ccae3341710b34cec000554d079d43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcwNzMxMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473707311", "bodyText": "There are some very subtle differences for some characters, e.g. [1]. I think both variants are good enough.\n[1] https://stackoverflow.com/questions/47887244/whats-the-difference-between-character-touppercase-and-character-totitlecase/47887432#47887432", "author": "devozerov", "createdAt": "2020-08-20T07:41:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4MDYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4MjAyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473682023", "bodyText": "upper case letters should be lowercased if they are not starting a word", "author": "taburet", "createdAt": "2020-08-20T07:15:19Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return (first != null ? first : \"\") + (second != null ? second : \"\");\n+    }\n+\n+    public static Integer position(String seek, String source, int position) {\n+        if (seek == null) {\n+            return null;\n+        }\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        if (position == 0) {\n+            return source.indexOf(seek) + 1;\n+        } else {\n+            int position0 = position - 1;\n+\n+            if (position0 < 0 || position0 > source.length()) {\n+                return 0;\n+            }\n+\n+            return source.indexOf(seek, position0) + 1;\n+        }\n+    }\n+\n+    public static String substring(String source, Integer startPos, Integer length) {\n+        // TODO: Validate the implementation against ANSI.\n+        if (source == null || startPos == null || length == null) {\n+            return null;\n+        }\n+\n+        int sourceLength = source.length();\n+\n+        if (startPos < 0) {\n+            startPos += sourceLength + 1;\n+        }\n+\n+        int endPos = startPos + length;\n+\n+        if (endPos < startPos) {\n+            throw QueryException.error(\"End position is less than start position.\");\n+        }\n+\n+        if (startPos > sourceLength || endPos < 1) {\n+            return \"\";\n+        }\n+\n+        int startPos0 = Math.max(startPos, 1);\n+        int endPos0 = Math.min(endPos, sourceLength + 1);\n+\n+        return source.substring(startPos0 - 1, endPos0 - 1);\n+    }\n+\n+    public static Integer charLength(String value) {\n+        return value != null ? value.length() : null;\n+    }\n+\n+    public static Integer ascii(String value) {\n+        return value != null ? value.isEmpty() ? 0 : value.codePointAt(0) : null;\n+    }\n+\n+    public static String upper(String value) {\n+        return value != null ? value.toUpperCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String lower(String value) {\n+        return value != null ? value.toLowerCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String initcap(String value) {", "originalCommit": "03e7d2db16ccae3341710b34cec000554d079d43", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcxMjA5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473712096", "bodyText": "Fixed in e2c7927", "author": "devozerov", "createdAt": "2020-08-20T07:44:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY4MjAyMw=="}], "type": "inlineReview"}, {"oid": "e2c7927a1e78d7f0e656e88a7073c08315eb4607", "url": "https://github.com/hazelcast/hazelcast/commit/e2c7927a1e78d7f0e656e88a7073c08315eb4607", "message": "Lowercase non-title characters for INITCAP", "committedDate": "2020-08-20T07:44:14Z", "type": "commit"}, {"oid": "2dab533ac3628b139b36fa06814602a8c4eba960", "url": "https://github.com/hazelcast/hazelcast/commit/2dab533ac3628b139b36fa06814602a8c4eba960", "message": "Return NULL for if one of CONCAT arguments is NULL", "committedDate": "2020-08-20T07:48:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcyMDA0MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473720041", "bodyText": "if start was provided and its value is null, it should return null", "author": "taburet", "createdAt": "2020-08-20T07:50:55Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);\n+        }\n+\n+        if (input == null) {\n+            // NULL always yields NULL\n+            return null;\n+        }\n+\n+        Integer start = operand2 != null ? MathFunctionUtils.asInt(operand2, row, context) : null;\n+\n+        if (start == null) {\n+            // Start position is not specific, start with the very first character\n+            start = 1;", "originalCommit": "e2c7927a1e78d7f0e656e88a7073c08315eb4607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzczMDQ1OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473730459", "bodyText": "Fixed in 37f0ac6", "author": "devozerov", "createdAt": "2020-08-20T07:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcyMDA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcyMDU4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473720581", "bodyText": "if length was provided and its value is null, it should return null", "author": "taburet", "createdAt": "2020-08-20T07:51:20Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);\n+        }\n+\n+        if (input == null) {\n+            // NULL always yields NULL\n+            return null;\n+        }\n+\n+        Integer start = operand2 != null ? MathFunctionUtils.asInt(operand2, row, context) : null;\n+\n+        if (start == null) {\n+            // Start position is not specific, start with the very first character\n+            start = 1;\n+        } else if (start < 1) {\n+            // Different databases provide different semantics on negative values. Oracle start counting\n+            // from the end, SQL Server starts from the beginning, and uses the value to calculate the\n+            // final length, etc.\n+            // These semantics are pretty complicated, so wi disallow it completely.\n+            throw QueryException.dataException(\"SUBSTRING \\\"start\\\" operand must be positive\");\n+        }\n+\n+        // In SQL start position is 1-based. Convert it to 0-based for Java.\n+        int adjustedStart = start - 1;\n+\n+        if (adjustedStart > input.length()) {\n+            // Start position is beyond the string length, e.g. SUBSTRING(\"abc\", 4)\n+            return \"\";\n+        }\n+\n+        Integer length = operand3 != null ? MathFunctionUtils.asInt(operand3, row, context) : null;\n+\n+        if (length == null) {\n+            // Length is not specified, just cut from the start\n+            return adjustedStart > 0 ? input.substring(adjustedStart) : input;", "originalCommit": "e2c7927a1e78d7f0e656e88a7073c08315eb4607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzczMDI5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473730294", "bodyText": "Fixed in 37f0ac6", "author": "devozerov", "createdAt": "2020-08-20T07:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzcyMDU4MQ=="}], "type": "inlineReview"}, {"oid": "37f0ac6b7b8fb8fbe440400f71d934f7044ee78b", "url": "https://github.com/hazelcast/hazelcast/commit/37f0ac6b7b8fb8fbe440400f71d934f7044ee78b", "message": "Return NULL if any of SUBSTRING arguments are NULL", "committedDate": "2020-08-20T07:58:00Z", "type": "commit"}, {"oid": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "url": "https://github.com/hazelcast/hazelcast/commit/f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "message": "Merge branch 'master' into issues/17378", "committedDate": "2020-08-20T08:44:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0NTM4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473945383", "bodyText": "Is it possible for substring to have 1 argument?", "author": "viliam-durina", "createdAt": "2020-08-20T12:52:07Z", "path": "hazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/opt/physical/visitor/RexToExpression.java", "diffHunk": "@@ -266,6 +292,26 @@ private RexToExpression() {\n                     );\n                 }\n \n+                // Strings.\n+\n+                if (function == CHAR_LENGTH || function == CHARACTER_LENGTH || function == LENGTH) {\n+                    return CharLengthFunction.create(operands[0]);\n+                } else if (function == HazelcastSqlOperatorTable.UPPER) {\n+                    return UpperFunction.create(operands[0]);\n+                } else if (function == HazelcastSqlOperatorTable.LOWER) {\n+                    return LowerFunction.create(operands[0]);\n+                } else if (function == HazelcastSqlOperatorTable.INITCAP) {\n+                    return InitcapFunction.create(operands[0]);\n+                } else if (function == HazelcastSqlOperatorTable.ASCII) {\n+                    return AsciiFunction.create(operands[0]);\n+                } else if (function == HazelcastSqlOperatorTable.SUBSTRING) {\n+                    Expression<?> input = operands[0];\n+                    Expression<?> start = operands.length > 1 ? operands[1] : null;", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwMTQyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474201423", "bodyText": "Yes, in this case it is a no-op.", "author": "devozerov", "createdAt": "2020-08-20T18:53:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0NTM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwNTQ4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474205481", "bodyText": "Wrong. It is not supported. Fixed RexToExpression.", "author": "devozerov", "createdAt": "2020-08-20T19:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0NTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MDc0Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473950747", "bodyText": "Maybe we should include the original exception in the message. The user won't see the cause, i wonder if it will even be in the member logs.\nAlso I couldn't find a test for this scenario.\n\"NPE on\" -> \"NPE in\"", "author": "viliam-durina", "createdAt": "2020-08-20T13:00:50Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwMzA5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474203091", "bodyText": "This is a defensive handler \"just in case\". We are going to make expressions more restrictive, not allowing any argument here except for strings, so exceptions will never happen. Meanwhile, this handler is added just for some unexpected situations that I cannot even imagine how to reproduce.\nLet's assume that this handler will be removed soon during expressions polishing.", "author": "devozerov", "createdAt": "2020-08-20T18:56:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MDc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzNTc1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474435750", "bodyText": "It might be better to catch the exc in ObjectConverter.asVarchar(), when it calls the toString. Then it would not be necessary to handle it specially here if I'm not mistaken.\nTo test it we can query an OBJECT value with broken toString method.", "author": "viliam-durina", "createdAt": "2020-08-21T06:33:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MDc0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0MjY4Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474442682", "bodyText": "OBJECT Is restricted on the upper level at the moment. We cannot pass a custom object here at the moment.", "author": "devozerov", "createdAt": "2020-08-21T06:52:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MDc0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MTYxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473951610", "bodyText": "Maybe we should name this StringFunctionUtils - everything else in this package uses \"function\", there's also MathFunctionUtils", "author": "viliam-durina", "createdAt": "2020-08-20T13:02:16Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIwMzQ0NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474203445", "bodyText": "Renamed", "author": "devozerov", "createdAt": "2020-08-20T18:57:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MTYxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MzEyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473953127", "bodyText": "SUBSTRING(this, 1, 1) syntax is also valid, shouldn't we test it? I guess after calcite parsing it's the same for us...", "author": "viliam-durina", "createdAt": "2020-08-20T13:04:46Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/string/SubstringFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+@SuppressWarnings(\"SpellCheckingInspection\")\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class SubstringFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {\n+    @Test\n+    public void test_input() {\n+        // String column\n+        put(\"abcde\");\n+        checkValueInternal(\"SELECT SUBSTRING(this FROM 1) FROM map\", SqlColumnType.VARCHAR, \"abcde\");\n+        checkValueInternal(\"SELECT SUBSTRING(this FROM 1 FOR 1) FROM map\", SqlColumnType.VARCHAR, \"a\");", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMjgwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474212809", "bodyText": "Added such tests", "author": "devozerov", "createdAt": "2020-08-20T19:15:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1MzEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NTg5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473955896", "bodyText": "This line is not covered by integration test. Actually I can't figure out how can you pass null operand2.", "author": "viliam-durina", "createdAt": "2020-08-20T13:09:19Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);\n+        }\n+\n+        if (input == null) {\n+            // NULL always yields NULL\n+            return null;\n+        }\n+\n+        Integer start;\n+\n+        if (operand2 != null) {\n+            start = MathFunctionUtils.asInt(operand2, row, context);\n+\n+            if (start == null) {\n+                return null;\n+            }\n+        } else {\n+            start = null;", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMjk5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474212991", "bodyText": "No longer relevant, since the function cannot have 1 argument", "author": "devozerov", "createdAt": "2020-08-20T19:15:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1NTg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1Njg0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473956842", "bodyText": "This can be >=", "author": "viliam-durina", "createdAt": "2020-08-20T13:10:48Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);\n+        }\n+\n+        if (input == null) {\n+            // NULL always yields NULL\n+            return null;\n+        }\n+\n+        Integer start;\n+\n+        if (operand2 != null) {\n+            start = MathFunctionUtils.asInt(operand2, row, context);\n+\n+            if (start == null) {\n+                return null;\n+            }\n+        } else {\n+            start = null;\n+        }\n+\n+        if (start == null) {\n+            // Start position is not specific, start with the very first character\n+            start = 1;\n+        } else if (start < 1) {\n+            // Different databases provide different semantics on negative values. Oracle start counting\n+            // from the end, SQL Server starts from the beginning, and uses the value to calculate the\n+            // final length, etc.\n+            // These semantics are pretty complicated, so wi disallow it completely.\n+            throw QueryException.dataException(\"SUBSTRING \\\"start\\\" operand must be positive\");\n+        }\n+\n+        // In SQL start position is 1-based. Convert it to 0-based for Java.\n+        int adjustedStart = start - 1;\n+\n+        if (adjustedStart > input.length()) {", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxMzY4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474213687", "bodyText": "Fixed", "author": "devozerov", "createdAt": "2020-08-20T19:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1Njg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1ODM5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473958395", "bodyText": "The start == 0 case is handled again in String.substring:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return adjustedStart > 0 ? input.substring(adjustedStart) : input;\n          \n          \n            \n                        return input.substring(adjustedStart);\n          \n      \n    \n    \n  \n\nAgain on line 114", "author": "viliam-durina", "createdAt": "2020-08-20T13:13:27Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/SubstringFunction.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.expression.math.MathFunctionUtils;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+\n+public class SubstringFunction extends TriExpression<String> implements IdentifiedDataSerializable {\n+    public SubstringFunction() {\n+        // No-op\n+    }\n+\n+    private SubstringFunction(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        super(input, start, length);\n+    }\n+\n+    public static SubstringFunction create(Expression<?> input, Expression<?> start, Expression<?> length) {\n+        return new SubstringFunction(input, start, length);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    @Override\n+    public String eval(Row row, ExpressionEvalContext context) {\n+        // Get input\n+        String input;\n+\n+        try {\n+            input = StringExpressionUtils.asVarchar(operand1, row, context);\n+        } catch (Exception e) {\n+            // Conversion to String failed. E.g. NPE on UserClass.toString()\n+            throw QueryException.dataException(\"Failed to get value of input operand of SUBSTRING function\", e);\n+        }\n+\n+        if (input == null) {\n+            // NULL always yields NULL\n+            return null;\n+        }\n+\n+        Integer start;\n+\n+        if (operand2 != null) {\n+            start = MathFunctionUtils.asInt(operand2, row, context);\n+\n+            if (start == null) {\n+                return null;\n+            }\n+        } else {\n+            start = null;\n+        }\n+\n+        if (start == null) {\n+            // Start position is not specific, start with the very first character\n+            start = 1;\n+        } else if (start < 1) {\n+            // Different databases provide different semantics on negative values. Oracle start counting\n+            // from the end, SQL Server starts from the beginning, and uses the value to calculate the\n+            // final length, etc.\n+            // These semantics are pretty complicated, so wi disallow it completely.\n+            throw QueryException.dataException(\"SUBSTRING \\\"start\\\" operand must be positive\");\n+        }\n+\n+        // In SQL start position is 1-based. Convert it to 0-based for Java.\n+        int adjustedStart = start - 1;\n+\n+        if (adjustedStart > input.length()) {\n+            // Start position is beyond the string length, e.g. SUBSTRING(\"abc\", 4)\n+            return \"\";\n+        }\n+\n+        Integer length;\n+\n+        if (operand3 != null) {\n+            length = MathFunctionUtils.asInt(operand3, row, context);\n+\n+            if (length == null) {\n+                return null;\n+            }\n+        } else {\n+            length = null;\n+        }\n+\n+        if (length == null) {\n+            // Length is not specified, just cut from the start\n+            return adjustedStart > 0 ? input.substring(adjustedStart) : input;", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNTA1NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474215054", "bodyText": "I didn't get the comment. Could you please clarify the problem?\nIf this is about two branches with identical content (if (length == null) and if (adjustedStart + length > input.length())), then this is intentional to make code simpler to understand", "author": "devozerov", "createdAt": "2020-08-20T19:19:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1ODM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQzNzE3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474437173", "bodyText": "The point was that we don't to special-case when adjustedStart == 0. input.substring(0) works just fine, it returns input. The same test for start == 0 is inside of String.substring.", "author": "viliam-durina", "createdAt": "2020-08-21T06:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1ODM5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0MjM1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474442350", "bodyText": "I see. Formally, String.substring() still does additional checks, so I'd better avoid calling it as a micro-opt", "author": "devozerov", "createdAt": "2020-08-21T06:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk1ODM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2ODIwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473968208", "bodyText": "We should capitalize not only after whitespace, but also after any non-letter. Oracle, Postgresql, do this, mysql and mssql don't have this function.", "author": "viliam-durina", "createdAt": "2020-08-20T13:24:33Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return first != null && second != null ? first + \"\" + second : null;\n+    }\n+\n+    public static Integer charLength(String value) {\n+        return value != null ? value.length() : null;\n+    }\n+\n+    public static Integer ascii(String value) {\n+        return value != null ? value.isEmpty() ? 0 : value.codePointAt(0) : null;\n+    }\n+\n+    public static String upper(String value) {\n+        return value != null ? value.toUpperCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String lower(String value) {\n+        return value != null ? value.toLowerCase(Locale.ROOT) : null;\n+    }\n+\n+    public static String initcap(String value) {\n+        if (value == null) {\n+            return null;\n+        }\n+\n+        if (value.isEmpty()) {\n+            return value;\n+        }\n+\n+        int strLen = value.length();\n+\n+        StringBuilder res = new StringBuilder(strLen);\n+\n+        boolean capitalizeNext = true;\n+\n+        for (int i = 0; i < strLen; i++) {\n+            char c = value.charAt(i);\n+\n+            if (Character.isWhitespace(c)) {", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNjkyMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474216923", "bodyText": "Fixed. Now the condition to trigger capitalization of the next character is if (!Character.isLetterOrDigit(c))", "author": "devozerov", "createdAt": "2020-08-20T19:23:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk2ODIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk3MTQwOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473971408", "bodyText": "Why the + \"\" +?", "author": "viliam-durina", "createdAt": "2020-08-20T13:27:34Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/StringExpressionUtils.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.row.Row;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Utility methods for string functions.\n+ */\n+public final class StringExpressionUtils {\n+    private StringExpressionUtils() {\n+        // No-op.\n+    }\n+\n+    public static String concat(String first, String second) {\n+        return first != null && second != null ? first + \"\" + second : null;", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxNzAwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474217005", "bodyText": "Leftover. Removed.", "author": "devozerov", "createdAt": "2020-08-20T19:23:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk3MTQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk3Njg4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473976887", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                throw QueryException.error(\"Escape parameter should be a single character: \" + escape);\n          \n          \n            \n                                throw QueryException.error(\"ESCAPE parameter must be a single character: \" + escape);\n          \n      \n    \n    \n  \n\nWe can also leak user data to error logs by including the value.", "author": "viliam-durina", "createdAt": "2020-08-20T13:32:44Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape;\n+\n+        if (operand3 != null) {\n+            escape = asVarchar(operand3, row, context);\n+\n+            if (escape == null) {\n+                return null;\n+            }\n+        } else {\n+            escape = null;\n+        }\n+\n+        if (state == null) {\n+            state = new State();\n+        }\n+\n+        return state.like(source, pattern, escape);\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return QueryDataType.BOOLEAN;\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_LIKE;\n+    }\n+\n+    /**\n+     * Helper class to execute LIKE function. Caches the last observed pattern to avoid constant re-compilation.\n+     */\n+    public static class State {\n+        /** Last observed pattern. */\n+        private String lastPattern;\n+\n+        /** Last observed escape. */\n+        private String lastEscape;\n+\n+        /** Last Java pattern. */\n+        private Pattern lastJavaPattern;\n+\n+        public boolean like(String source, String pattern, String escape) {\n+            Pattern javaPattern = convertToJavaPattern(pattern, escape);\n+\n+            Matcher matcher = javaPattern.matcher(source);\n+\n+            return matcher.matches();\n+        }\n+\n+        private Pattern convertToJavaPattern(String pattern, String escape) {\n+            if (lastJavaPattern != null && Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {\n+                return lastJavaPattern;\n+            }\n+\n+            String javaPatternStr = constructJavaPatternString(pattern, escape);\n+            Pattern javaPattern = Pattern.compile(javaPatternStr);\n+\n+            lastPattern = pattern;\n+            lastEscape = escape;\n+            lastJavaPattern = javaPattern;\n+\n+            return javaPattern;\n+        }\n+\n+        @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+        private static String constructJavaPatternString(String pattern, String escape) {\n+            // Get the escape character.\n+            Character escapeChar;\n+\n+            if (escape != null) {\n+                if (escape.length() != 1) {\n+                    throw QueryException.error(\"Escape parameter should be a single character: \" + escape);", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxODE3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474218175", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-08-20T19:25:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk3Njg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk5ODY5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r473998691", "bodyText": "- isn't a top-level special char, only inside of [] or {}.", "author": "viliam-durina", "createdAt": "2020-08-20T13:52:28Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzNDEwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474234102", "bodyText": "Fixed in 939d0a0\nAlso added a test to check escaping all special characters.", "author": "devozerov", "createdAt": "2020-08-20T19:48:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk5ODY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwMTExMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474001112", "bodyText": "We enable DOTALL mode for .*, but not for .. Why not for both?\nIf we'll do it for both, we can instead pass the DOTALL flag to Pattern.compile and save some parsing time.\nAlso we miss tests for matching newlines.", "author": "viliam-durina", "createdAt": "2020-08-20T13:54:43Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIzMTk0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474231943", "bodyText": "Fixed in a26fc69", "author": "devozerov", "createdAt": "2020-08-20T19:44:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwMTExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwMzIwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474003205", "bodyText": "Why don't we use the term \"regex\"?\n\nescaping in Java -> escaping in regex\nconvertToJavaPattern -> convertToRegex\nlastJavaPattern -> lastRegex\n\netc.", "author": "viliam-durina", "createdAt": "2020-08-20T13:56:34Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyMzkwOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474223909", "bodyText": "It is a matter of taste.", "author": "devozerov", "createdAt": "2020-08-20T19:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwMzIwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwNzM4Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474007383", "bodyText": "If pattern = \"(_\" and escape = \"(\", we'll produce the regex \\_ - the non-special _ will be unnecessarily escaped. This happens when the escape character is one of the regex special characters.\nWhile I couldn't find any case where this is an issue (in regex you can unnecessarily escape any character), seems weird to produce such output.", "author": "viliam-durina", "createdAt": "2020-08-20T14:02:23Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape;\n+\n+        if (operand3 != null) {\n+            escape = asVarchar(operand3, row, context);\n+\n+            if (escape == null) {\n+                return null;\n+            }\n+        } else {\n+            escape = null;\n+        }\n+\n+        if (state == null) {\n+            state = new State();\n+        }\n+\n+        return state.like(source, pattern, escape);\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return QueryDataType.BOOLEAN;\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_LIKE;\n+    }\n+\n+    /**\n+     * Helper class to execute LIKE function. Caches the last observed pattern to avoid constant re-compilation.\n+     */\n+    public static class State {\n+        /** Last observed pattern. */\n+        private String lastPattern;\n+\n+        /** Last observed escape. */\n+        private String lastEscape;\n+\n+        /** Last Java pattern. */\n+        private Pattern lastJavaPattern;\n+\n+        public boolean like(String source, String pattern, String escape) {\n+            Pattern javaPattern = convertToJavaPattern(pattern, escape);\n+\n+            Matcher matcher = javaPattern.matcher(source);\n+\n+            return matcher.matches();\n+        }\n+\n+        private Pattern convertToJavaPattern(String pattern, String escape) {\n+            if (lastJavaPattern != null && Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {\n+                return lastJavaPattern;\n+            }\n+\n+            String javaPatternStr = constructJavaPatternString(pattern, escape);\n+            Pattern javaPattern = Pattern.compile(javaPatternStr);\n+\n+            lastPattern = pattern;\n+            lastEscape = escape;\n+            lastJavaPattern = javaPattern;\n+\n+            return javaPattern;\n+        }\n+\n+        @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+        private static String constructJavaPatternString(String pattern, String escape) {\n+            // Get the escape character.\n+            Character escapeChar;\n+\n+            if (escape != null) {\n+                if (escape.length() != 1) {\n+                    throw QueryException.error(\"Escape parameter should be a single character: \" + escape);\n+                }\n+\n+                escapeChar = escape.charAt(0);\n+            } else {\n+                escapeChar = null;\n+            }\n+\n+            // Main logic.\n+            StringBuilder javaPattern = new StringBuilder();\n+\n+            int i;\n+\n+            for (i = 0; i < pattern.length(); i++) {\n+                char patternChar = pattern.charAt(i);\n+\n+                // Escape special character as needed.\n+                if (ESCAPE_CHARACTERS_JAVA.indexOf(patternChar) >= 0) {", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyMzUxMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474223513", "bodyText": "I am not quite sure I understand the problem. Does it lead to incorrect results in any case?", "author": "devozerov", "createdAt": "2020-08-20T19:34:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwNzM4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0Mjk2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474442966", "bodyText": "It only causes that _ or % can be unnecessarily escaped. But since regex allows escaping any non-alphanumerical characters, it's not really a problem.", "author": "viliam-durina", "createdAt": "2020-08-21T06:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwNzM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwOTA1MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474009050", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return QueryException.error(\"Only '_' or '%' pattern wildcards could be escaped\");\n          \n          \n            \n                        return QueryException.error(\"Only '_', '%' and the escape character can be escaped\");", "author": "viliam-durina", "createdAt": "2020-08-20T14:04:46Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape;\n+\n+        if (operand3 != null) {\n+            escape = asVarchar(operand3, row, context);\n+\n+            if (escape == null) {\n+                return null;\n+            }\n+        } else {\n+            escape = null;\n+        }\n+\n+        if (state == null) {\n+            state = new State();\n+        }\n+\n+        return state.like(source, pattern, escape);\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return QueryDataType.BOOLEAN;\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_LIKE;\n+    }\n+\n+    /**\n+     * Helper class to execute LIKE function. Caches the last observed pattern to avoid constant re-compilation.\n+     */\n+    public static class State {\n+        /** Last observed pattern. */\n+        private String lastPattern;\n+\n+        /** Last observed escape. */\n+        private String lastEscape;\n+\n+        /** Last Java pattern. */\n+        private Pattern lastJavaPattern;\n+\n+        public boolean like(String source, String pattern, String escape) {\n+            Pattern javaPattern = convertToJavaPattern(pattern, escape);\n+\n+            Matcher matcher = javaPattern.matcher(source);\n+\n+            return matcher.matches();\n+        }\n+\n+        private Pattern convertToJavaPattern(String pattern, String escape) {\n+            if (lastJavaPattern != null && Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {\n+                return lastJavaPattern;\n+            }\n+\n+            String javaPatternStr = constructJavaPatternString(pattern, escape);\n+            Pattern javaPattern = Pattern.compile(javaPatternStr);\n+\n+            lastPattern = pattern;\n+            lastEscape = escape;\n+            lastJavaPattern = javaPattern;\n+\n+            return javaPattern;\n+        }\n+\n+        @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")\n+        private static String constructJavaPatternString(String pattern, String escape) {\n+            // Get the escape character.\n+            Character escapeChar;\n+\n+            if (escape != null) {\n+                if (escape.length() != 1) {\n+                    throw QueryException.error(\"Escape parameter should be a single character: \" + escape);\n+                }\n+\n+                escapeChar = escape.charAt(0);\n+            } else {\n+                escapeChar = null;\n+            }\n+\n+            // Main logic.\n+            StringBuilder javaPattern = new StringBuilder();\n+\n+            int i;\n+\n+            for (i = 0; i < pattern.length(); i++) {\n+                char patternChar = pattern.charAt(i);\n+\n+                // Escape special character as needed.\n+                if (ESCAPE_CHARACTERS_JAVA.indexOf(patternChar) >= 0) {\n+                    javaPattern.append('\\\\');\n+                }\n+\n+                if (escapeChar != null && patternChar == escapeChar) {\n+                    if (i == (pattern.length() - 1)) {\n+                        throw escapeWildcardsOnly();\n+                    }\n+\n+                    char nextPatternChar = pattern.charAt(i + 1);\n+\n+                    if ((nextPatternChar == ONE_SQL) || (nextPatternChar == MANY_SQL) || (nextPatternChar == escapeChar)) {\n+                        javaPattern.append(nextPatternChar);\n+\n+                        i++;\n+                    } else {\n+                        throw escapeWildcardsOnly();\n+                    }\n+                } else if (patternChar == ONE_SQL) {\n+                    javaPattern.append(ONE_JAVA);\n+                } else if (patternChar == MANY_SQL) {\n+                    javaPattern.append(MANY_JAVA);\n+                } else {\n+                    javaPattern.append(patternChar);\n+                }\n+            }\n+\n+            return javaPattern.toString();\n+        }\n+\n+        private static QueryException escapeWildcardsOnly() {\n+            return QueryException.error(\"Only '_' or '%' pattern wildcards could be escaped\");", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyMjAxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474222010", "bodyText": "Applied the suggested change.", "author": "devozerov", "createdAt": "2020-08-20T19:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAwOTA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxMTYyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474011628", "bodyText": "We can create the state immediately in constructor and don't need this branching.", "author": "viliam-durina", "createdAt": "2020-08-20T14:08:30Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape;\n+\n+        if (operand3 != null) {\n+            escape = asVarchar(operand3, row, context);\n+\n+            if (escape == null) {\n+                return null;\n+            }\n+        } else {\n+            escape = null;\n+        }\n+\n+        if (state == null) {\n+            state = new State();", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxODg3Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474218873", "bodyText": "The function might have never been invoked. No need to create it beforehand.", "author": "devozerov", "createdAt": "2020-08-20T19:27:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxMTYyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ0NDg4OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474444888", "bodyText": "The state is 3 fields that will be null. And the case when the function is never invoked is rare. That's much cheaper than checking for nullity for every item. It's also less code, so in this regard it's a micro-optimization.\nBut I admit it's also a matter of style, so I'm marking as resolved.", "author": "viliam-durina", "createdAt": "2020-08-21T06:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxMTYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNDAyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474014028", "bodyText": "The first condition isn't needed: pattern is always not null here (we can assert it). If pattern.equals(lastPattern) it means that we've already been here and lastJavaPattern is also not null.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (lastJavaPattern != null && Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {\n          \n          \n            \n                        if (Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {", "author": "viliam-durina", "createdAt": "2020-08-20T14:11:59Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/expression/string/LikeFunction.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.SqlDataSerializerHook;\n+import com.hazelcast.sql.impl.expression.Expression;\n+import com.hazelcast.sql.impl.expression.ExpressionEvalContext;\n+import com.hazelcast.sql.impl.expression.TriExpression;\n+import com.hazelcast.sql.impl.row.Row;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static com.hazelcast.sql.impl.expression.string.StringExpressionUtils.asVarchar;\n+\n+/**\n+ * LIKE string function.\n+ */\n+public class LikeFunction extends TriExpression<Boolean> implements IdentifiedDataSerializable {\n+\n+    private static final long serialVersionUID = 4157617157954663651L;\n+\n+    /** Single-symbol wildcard in SQL. */\n+    private static final char ONE_SQL = '_';\n+\n+    /** Multi-symbol wildcard in SQL. */\n+    private static final char MANY_SQL = '%';\n+\n+    /** Single-symbol wildcard in Java. */\n+    private static final String ONE_JAVA = \".\";\n+\n+    /** Multi-symbol wildcard in Java. */\n+    private static final String MANY_JAVA = \"(?s:.*)\";\n+\n+    /** Special characters which require escaping in Java. */\n+    private static final String ESCAPE_CHARACTERS_JAVA = \"[]()|^-+*?{}$\\\\.\";\n+\n+    private transient State state;\n+\n+    public LikeFunction() {\n+        // No-op.\n+    }\n+\n+    private LikeFunction(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        super(source, pattern, escape);\n+    }\n+\n+    public static LikeFunction create(Expression<?> source, Expression<?> pattern, Expression<?> escape) {\n+        return new LikeFunction(source, pattern, escape);\n+    }\n+\n+    @SuppressFBWarnings(value = \"NP_BOOLEAN_RETURN_NULL\", justification = \"SQL has three-valued boolean logic\")\n+    @Override\n+    public Boolean eval(Row row, ExpressionEvalContext context) {\n+        String source = asVarchar(operand1, row, context);\n+\n+        if (source == null) {\n+            return null;\n+        }\n+\n+        String pattern = asVarchar(operand2, row, context);\n+\n+        if (pattern == null) {\n+            return null;\n+        }\n+\n+        String escape;\n+\n+        if (operand3 != null) {\n+            escape = asVarchar(operand3, row, context);\n+\n+            if (escape == null) {\n+                return null;\n+            }\n+        } else {\n+            escape = null;\n+        }\n+\n+        if (state == null) {\n+            state = new State();\n+        }\n+\n+        return state.like(source, pattern, escape);\n+    }\n+\n+    @Override\n+    public QueryDataType getType() {\n+        return QueryDataType.BOOLEAN;\n+    }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.EXPRESSION_LIKE;\n+    }\n+\n+    /**\n+     * Helper class to execute LIKE function. Caches the last observed pattern to avoid constant re-compilation.\n+     */\n+    public static class State {\n+        /** Last observed pattern. */\n+        private String lastPattern;\n+\n+        /** Last observed escape. */\n+        private String lastEscape;\n+\n+        /** Last Java pattern. */\n+        private Pattern lastJavaPattern;\n+\n+        public boolean like(String source, String pattern, String escape) {\n+            Pattern javaPattern = convertToJavaPattern(pattern, escape);\n+\n+            Matcher matcher = javaPattern.matcher(source);\n+\n+            return matcher.matches();\n+        }\n+\n+        private Pattern convertToJavaPattern(String pattern, String escape) {\n+            if (lastJavaPattern != null && Objects.equals(pattern, lastPattern) && Objects.equals(escape, lastEscape)) {", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIyMDc2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474220764", "bodyText": "Removed unnecessary check.", "author": "devozerov", "createdAt": "2020-08-20T19:30:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAxNDAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyMjg5NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474022894", "bodyText": "This also works:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    check(\"this || ?\", null, new Object[] { null });\n          \n          \n            \n                    check(\"this || ?\", null, (Object) null);", "author": "viliam-durina", "createdAt": "2020-08-20T14:24:14Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/string/ConcatFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionBiValue;\n+import com.hazelcast.sql.support.expressions.ExpressionType;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.BIG_DECIMAL;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.BIG_INTEGER;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.BOOLEAN;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.BYTE;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.DOUBLE;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.FLOAT;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.INTEGER;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.LONG;\n+import static com.hazelcast.sql.support.expressions.ExpressionTypes.SHORT;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class ConcatFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {\n+    @Test\n+    public void test_literal() {\n+        put(\"1\");\n+\n+        check(\"this || 2\", \"12\");\n+        check(\"this || '2'\", \"12\");\n+        check(\"this || 2e0\", \"12.0\");\n+\n+        check(\"this || true\", \"1true\");\n+\n+        check(\"this || null\", null);\n+        check(\"null || null\", null);\n+\n+        check(\"1 || 2\", \"12\");\n+        check(\"'1' || '2'\", \"12\");\n+    }\n+\n+    @Test\n+    public void test_parameter() {\n+        put(\"1\");\n+\n+        check(\"this || ?\", \"12\", \"2\");\n+        check(\"this || ?\", \"12\", '2');\n+        check(\"this || ?\", null, new Object[] { null });", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyNzM3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474027378", "bodyText": "We can add these tests:\ncheckColumn(new DoubleVal().field1(Double.NaN), \"Nan\");\ncheckColumn(new DoubleVal().field1(Double.NEGATIVE_INFINITY), \"-Infinity\");\nThe second one currently fails, but should not.", "author": "viliam-durina", "createdAt": "2020-08-20T14:29:53Z", "path": "hazelcast-sql/src/test/java/com/hazelcast/sql/impl/expression/string/InitcapFunctionIntegrationTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.expression.string;\n+\n+import com.hazelcast.sql.SqlColumnType;\n+import com.hazelcast.sql.SqlErrorCode;\n+import com.hazelcast.sql.impl.expression.SqlExpressionIntegrationTestSupport;\n+import com.hazelcast.sql.support.expressions.ExpressionValue;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.ByteVal;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.CharacterVal;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.IntegerVal;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.LongVal;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.ShortVal;\n+import com.hazelcast.sql.support.expressions.ExpressionValue.StringVal;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.ParallelJVMTest;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import static com.hazelcast.sql.support.expressions.ExpressionValue.BigDecimalVal;\n+import static com.hazelcast.sql.support.expressions.ExpressionValue.BigIntegerVal;\n+import static com.hazelcast.sql.support.expressions.ExpressionValue.DoubleVal;\n+import static com.hazelcast.sql.support.expressions.ExpressionValue.FloatVal;\n+import static com.hazelcast.sql.support.expressions.ExpressionValue.ObjectVal;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category({QuickTest.class, ParallelJVMTest.class})\n+public class InitcapFunctionIntegrationTest extends SqlExpressionIntegrationTestSupport {\n+    @Test\n+    public void test_column() {\n+        checkColumn(new StringVal(), null);\n+        checkColumn(new StringVal().field1(\"fiRst\"), \"First\");\n+        checkColumn(new StringVal().field1(\"fiRst seCond\"), \"First Second\");\n+\n+        checkColumn(new CharacterVal().field1('a'), \"A\");\n+\n+        checkColumn(new ByteVal().field1((byte) 100), \"100\");\n+        checkColumn(new ShortVal().field1((short) 100), \"100\");\n+        checkColumn(new IntegerVal().field1(100), \"100\");\n+        checkColumn(new LongVal().field1((long) 100), \"100\");\n+        checkColumn(new BigIntegerVal().field1(new BigInteger(\"100\")), \"100\");\n+        checkColumn(new BigDecimalVal().field1(new BigDecimal(\"100.5\")), \"100.5\");\n+        checkColumn(new FloatVal().field1(100.5f), Float.toString(100.5f));\n+        checkColumn(new DoubleVal().field1(100.5d), Double.toString(100.5d));", "originalCommit": "f33b6fdd5c514deaa4a4f0e07cafd6368d5488a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDIxOTYwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17379#discussion_r474219606", "bodyText": "It should not work at all. We currently use too relaxed behavior that should be restricted otherwise. We'd better not dedicate more time to tests that otherwise should not work at all. This behavior will be restricted very soon.", "author": "devozerov", "createdAt": "2020-08-20T19:28:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDAyNzM3OA=="}], "type": "inlineReview"}, {"oid": "c869c8996a970ea7d51e919890696763c1ecac50", "url": "https://github.com/hazelcast/hazelcast/commit/c869c8996a970ea7d51e919890696763c1ecac50", "message": "Remove leftover in concat implementation", "committedDate": "2020-08-20T18:51:16Z", "type": "commit"}, {"oid": "1434d937e8d9f98c7429fa672993a77693999b87", "url": "https://github.com/hazelcast/hazelcast/commit/1434d937e8d9f98c7429fa672993a77693999b87", "message": "Include error text to the exception in SubstringFunction", "committedDate": "2020-08-20T18:54:53Z", "type": "commit"}, {"oid": "daaa6666e7f4aaa67ed957e0113202c565059d82", "url": "https://github.com/hazelcast/hazelcast/commit/daaa6666e7f4aaa67ed957e0113202c565059d82", "message": "StringExpressionUtils -> StringFunctionUtils", "committedDate": "2020-08-20T18:56:59Z", "type": "commit"}, {"oid": "3e3e6fcc8a73b446e02f323dfd546d7ab5fa821d", "url": "https://github.com/hazelcast/hazelcast/commit/3e3e6fcc8a73b446e02f323dfd546d7ab5fa821d", "message": "Tests for SUBSTRING(x,y,z)", "committedDate": "2020-08-20T19:15:11Z", "type": "commit"}, {"oid": "77b2c2f19e8e2435fc686e0215cfd275cf7322e6", "url": "https://github.com/hazelcast/hazelcast/commit/77b2c2f19e8e2435fc686e0215cfd275cf7322e6", "message": "\">=\" instead of \">\" when checking for string overflow in SUBSTRING", "committedDate": "2020-08-20T19:17:08Z", "type": "commit"}, {"oid": "4b01526f230f46d0b9cce59610696ecd8ff63fd1", "url": "https://github.com/hazelcast/hazelcast/commit/4b01526f230f46d0b9cce59610696ecd8ff63fd1", "message": "INITCAP: capitalize after any non-letter/digit.", "committedDate": "2020-08-20T19:22:46Z", "type": "commit"}, {"oid": "67200f6ab9dc0e1407051b1e631aa63400bcfb50", "url": "https://github.com/hazelcast/hazelcast/commit/67200f6ab9dc0e1407051b1e631aa63400bcfb50", "message": "Exception wording in LIKE", "committedDate": "2020-08-20T19:24:57Z", "type": "commit"}, {"oid": "58c6e639b5a0322a041afbc22b86696dff1a079a", "url": "https://github.com/hazelcast/hazelcast/commit/58c6e639b5a0322a041afbc22b86696dff1a079a", "message": "Do not leak faulty ESCAPE value to logs.", "committedDate": "2020-08-20T19:25:52Z", "type": "commit"}, {"oid": "8c5972ea11c58da1cb145c16a8ddbe820c5d5614", "url": "https://github.com/hazelcast/hazelcast/commit/8c5972ea11c58da1cb145c16a8ddbe820c5d5614", "message": "Removed unnecessary condition in LIKE function", "committedDate": "2020-08-20T19:30:17Z", "type": "commit"}, {"oid": "f030d3d7a79d2ec2ca7a6b54770e45dec61587c6", "url": "https://github.com/hazelcast/hazelcast/commit/f030d3d7a79d2ec2ca7a6b54770e45dec61587c6", "message": "LIKE exceptions wording", "committedDate": "2020-08-20T19:31:58Z", "type": "commit"}, {"oid": "a26fc6962a53f7afefb071f059a1a2839ff422e5", "url": "https://github.com/hazelcast/hazelcast/commit/a26fc6962a53f7afefb071f059a1a2839ff422e5", "message": "LIKE function:\n1) Use DOTALL for both SQL patterns\n2) Add tests for the new line", "committedDate": "2020-08-20T19:44:01Z", "type": "commit"}, {"oid": "939d0a007f0bb858bd0f9c953abbab5bedd64fa0", "url": "https://github.com/hazelcast/hazelcast/commit/939d0a007f0bb858bd0f9c953abbab5bedd64fa0", "message": "Do not escape minus", "committedDate": "2020-08-20T19:48:05Z", "type": "commit"}]}