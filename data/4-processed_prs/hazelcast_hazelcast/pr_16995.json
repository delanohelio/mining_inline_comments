{"pr_number": 16995, "pr_title": "SQL: IMap table metadata resolution (#16984)", "pr_createdAt": "2020-05-19T14:39:26Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/16995", "timeline": [{"oid": "13d348ca0fadf1e4bb0ea28ebf3270a044255591", "url": "https://github.com/hazelcast/hazelcast/commit/13d348ca0fadf1e4bb0ea28ebf3270a044255591", "message": "Initial integration with Apache Calcite (#16979)", "committedDate": "2020-05-13T11:43:29Z", "type": "commit"}, {"oid": "5fc43c85404605c5f8e93f54c1b75b8e6a48f50c", "url": "https://github.com/hazelcast/hazelcast/commit/5fc43c85404605c5f8e93f54c1b75b8e6a48f50c", "message": "Merge branch 'master' into issues/16979", "committedDate": "2020-05-15T06:54:43Z", "type": "commit"}, {"oid": "7ddc10c7c9d8cfe1053b540dfc10e5318edfc555", "url": "https://github.com/hazelcast/hazelcast/commit/7ddc10c7c9d8cfe1053b540dfc10e5318edfc555", "message": "Moved the code from the branch.", "committedDate": "2020-05-15T07:27:51Z", "type": "commit"}, {"oid": "b23c75599ae062f89a16c76473cfc3f3e96297ec", "url": "https://github.com/hazelcast/hazelcast/commit/b23c75599ae062f89a16c76473cfc3f3e96297ec", "message": "WIP.", "committedDate": "2020-05-15T10:30:56Z", "type": "commit"}, {"oid": "65947aa7eacfdf6ef3caa05f84b031ee2176a63a", "url": "https://github.com/hazelcast/hazelcast/commit/65947aa7eacfdf6ef3caa05f84b031ee2176a63a", "message": "Minors.", "committedDate": "2020-05-15T14:13:57Z", "type": "commit"}, {"oid": "2bfdc860e2278e1bcfb3f375572b1a99869964f9", "url": "https://github.com/hazelcast/hazelcast/commit/2bfdc860e2278e1bcfb3f375572b1a99869964f9", "message": "Sampling tests.", "committedDate": "2020-05-18T13:01:12Z", "type": "commit"}, {"oid": "c3fbb27a5cb1d9760673fa245bcb09832030636b", "url": "https://github.com/hazelcast/hazelcast/commit/c3fbb27a5cb1d9760673fa245bcb09832030636b", "message": "HD resolver test.", "committedDate": "2020-05-18T17:38:01Z", "type": "commit"}, {"oid": "e9ca63a401fe8ab0567e7db9bd5c228d0e1c2899", "url": "https://github.com/hazelcast/hazelcast/commit/e9ca63a401fe8ab0567e7db9bd5c228d0e1c2899", "message": "Merge branch 'master' into issues/16984\n\n# Conflicts:\n#\thazelcast-sql/src/main/java/com/hazelcast/sql/impl/calcite/schema/HazelcastTable.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/QueryUtils.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/TableField.java\n#\thazelcast/src/main/java/com/hazelcast/sql/impl/schema/TableResolver.java\n#\thazelcast/src/test/java/com/hazelcast/sql/impl/exec/scan/MapScanExecTest.java", "committedDate": "2020-05-19T11:52:19Z", "type": "commit"}, {"oid": "e99cd189a8f93c331872eb68fb5fee97df3f124c", "url": "https://github.com/hazelcast/hazelcast/commit/e99cd189a8f93c331872eb68fb5fee97df3f124c", "message": "Done with tests.", "committedDate": "2020-05-19T14:20:41Z", "type": "commit"}, {"oid": "d38067928911e69167e71056275faea1711e38e1", "url": "https://github.com/hazelcast/hazelcast/commit/d38067928911e69167e71056275faea1711e38e1", "message": "Done.", "committedDate": "2020-05-19T14:29:58Z", "type": "commit"}, {"oid": "46522463d6f5773db5406817135d6d4c4fea24c4", "url": "https://github.com/hazelcast/hazelcast/commit/46522463d6f5773db5406817135d6d4c4fea24c4", "message": "Made QueryPath IDS.", "committedDate": "2020-05-19T17:32:19Z", "type": "commit"}, {"oid": "499dc4fc1d46387a492ea7723df7333a1aed7655", "url": "https://github.com/hazelcast/hazelcast/commit/499dc4fc1d46387a492ea7723df7333a1aed7655", "message": "Merge branch 'master' into issues/16984", "committedDate": "2020-05-21T07:20:25Z", "type": "commit"}, {"oid": "61ad93acb29fc77d725c93f9b13bf4791114d52f", "url": "https://github.com/hazelcast/hazelcast/commit/61ad93acb29fc77d725c93f9b13bf4791114d52f", "message": "Fix for Portable.", "committedDate": "2020-05-25T07:05:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2MzI2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r429963266", "bodyText": "Minor : parentheses are not needed", "author": "petrpleshachkov", "createdAt": "2020-05-25T14:26:58Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/extract/QueryPath.java", "diffHunk": "@@ -94,4 +104,59 @@ private static boolean isEmpty(String path) {\n     private static QueryException badPathException(String path) {\n         throw QueryException.error(\"Field cannot be empty: \" + path);\n     }\n+\n+    @Override\n+    public int getFactoryId() {\n+        return SqlDataSerializerHook.F_ID;\n+    }\n+\n+    @Override\n+    public int getClassId() {\n+        return SqlDataSerializerHook.QUERY_PATH;\n+    }\n+\n+    @Override\n+    public void writeData(ObjectDataOutput out) throws IOException {\n+        out.writeBoolean(key);\n+        out.writeUTF(path);\n+    }\n+\n+    @Override\n+    public void readData(ObjectDataInput in) throws IOException {\n+        key = in.readBoolean();\n+        path = in.readUTF();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        QueryPath path1 = (QueryPath) o;\n+\n+        if (key != path1.key) {\n+            return false;\n+        }\n+\n+        return path != null ? path.equals(path1.path) : path1.path == null;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = (key ? 1 : 0);", "originalCommit": "61ad93acb29fc77d725c93f9b13bf4791114d52f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI2MjEyMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430262122", "bodyText": "Fixed.", "author": "devozerov", "createdAt": "2020-05-26T09:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk2MzI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk3MTM3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r429971371", "bodyText": "Return directly return new PartitionedMapTable(mapName, e); instead of doing this on the higher level?", "author": "petrpleshachkov", "createdAt": "2020-05-25T14:44:09Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/PartitionedMapTableResolver.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema.map;\n+\n+import com.hazelcast.cluster.memberselector.MemberSelectors;\n+import com.hazelcast.config.InMemoryFormat;\n+import com.hazelcast.config.MapConfig;\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.internal.util.collection.PartitionIdSet;\n+import com.hazelcast.map.impl.MapContainer;\n+import com.hazelcast.map.impl.MapService;\n+import com.hazelcast.map.impl.MapServiceContext;\n+import com.hazelcast.map.impl.PartitionContainer;\n+import com.hazelcast.map.impl.record.Record;\n+import com.hazelcast.map.impl.recordstore.RecordStore;\n+import com.hazelcast.spi.impl.NodeEngine;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.QueryUtils;\n+import com.hazelcast.sql.impl.schema.ConstantTableStatistics;\n+import com.hazelcast.sql.impl.schema.Table;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.map.sample.MapSampleMetadata;\n+import com.hazelcast.sql.impl.schema.map.sample.MapSampleMetadataResolver;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.hazelcast.sql.impl.QueryUtils.SCHEMA_NAME_PARTITIONED;\n+\n+public class PartitionedMapTableResolver extends AbstractMapTableResolver {\n+\n+    private static final List<List<String>> SEARCH_PATHS =\n+        Collections.singletonList(Arrays.asList(QueryUtils.CATALOG, SCHEMA_NAME_PARTITIONED));\n+\n+    public PartitionedMapTableResolver(NodeEngine nodeEngine) {\n+        super(nodeEngine, SEARCH_PATHS);\n+    }\n+\n+    @Override\n+    public Collection<Table> getTables() {\n+        MapService mapService = nodeEngine.getService(MapService.SERVICE_NAME);\n+        MapServiceContext context = mapService.getMapServiceContext();\n+\n+        List<Table> res = new ArrayList<>();\n+        Set<String> knownNames = new HashSet<>();\n+\n+        // Get started maps.\n+        for (String mapName : context.getMapContainers().keySet()) {\n+            PartitionedMapTable table;\n+\n+            try {\n+                table = createTable(context, mapName);\n+            } catch (QueryException e) {\n+                table = new PartitionedMapTable(mapName, e);\n+            }\n+\n+            if (table == null) {\n+                continue;\n+            }\n+\n+            res.add(table);\n+            knownNames.add(mapName);\n+        }\n+\n+        // Get maps that are not started locally yet.\n+        for (Map.Entry<String, MapConfig> configEntry : nodeEngine.getConfig().getMapConfigs().entrySet()) {\n+            String configMapName = configEntry.getKey();\n+\n+            // Skip templates.\n+            if (configMapName.contains(\"*\")) {\n+                continue;\n+            }\n+\n+            if (knownNames.add(configMapName)) {\n+                res.add(emptyMap(configMapName));\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"checkstyle:MethodLength\", \"checkstyle:CyclomaticComplexity\", \"checkstyle:NPathComplexity\"})\n+    private PartitionedMapTable createTable(MapServiceContext context, String name) {\n+        try {\n+            MapContainer mapContainer = context.getMapContainer(name);\n+\n+            // Handle concurrent map destroy.\n+            if (mapContainer == null) {\n+                return null;\n+            }\n+\n+            MapConfig config = mapContainer.getMapConfig();\n+\n+            // HD maps are not supported at the moment.\n+            if (config.getInMemoryFormat() == InMemoryFormat.NATIVE) {\n+                throw QueryException.error(\"IMap with InMemoryFormat.NATIVE is not supported: \" + name);\n+            }\n+\n+            boolean binary = config.getInMemoryFormat() == InMemoryFormat.BINARY;\n+\n+            for (PartitionContainer partitionContainer : context.getPartitionContainers()) {\n+                // Resolve sample.\n+                RecordStore<?> recordStore = partitionContainer.getExistingRecordStore(name);\n+\n+                if (recordStore == null) {\n+                    continue;\n+                }\n+\n+                Iterator<Map.Entry<Data, Record>> recordStoreIterator = recordStore.iterator();\n+\n+                if (!recordStoreIterator.hasNext()) {\n+                    continue;\n+                }\n+\n+                Map.Entry<Data, Record> entry = recordStoreIterator.next();\n+\n+                InternalSerializationService ss = (InternalSerializationService) nodeEngine.getSerializationService();\n+\n+                MapSampleMetadata keyMetadata = MapSampleMetadataResolver.resolve(\n+                    ss,\n+                    entry.getKey(),\n+                    binary,\n+                    true\n+                );\n+                MapSampleMetadata valueMetadata = MapSampleMetadataResolver.resolve(\n+                    ss,\n+                    entry.getValue().getValue(),\n+                    binary,\n+                    false\n+                );\n+\n+                List<TableField> fields = mergeMapFields(keyMetadata.getFields(), valueMetadata.getFields());\n+\n+                long estimatedRowCount = getEstimatedRowCount(name, context);\n+\n+                // Done.\n+                return new PartitionedMapTable(\n+                    name,\n+                    fields,\n+                    new ConstantTableStatistics(estimatedRowCount),\n+                    keyMetadata.getDescriptor(),\n+                    valueMetadata.getDescriptor()\n+                );\n+            }\n+\n+            return emptyMap(name);\n+        } catch (QueryException e) {\n+            throw e;", "originalCommit": "61ad93acb29fc77d725c93f9b13bf4791114d52f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI2MjE4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430262187", "bodyText": "Refactored.", "author": "devozerov", "createdAt": "2020-05-26T09:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk3MTM3MQ=="}], "type": "inlineReview"}, {"oid": "eefa5a4a400434aae14c1b84b9733584b5aaad8c", "url": "https://github.com/hazelcast/hazelcast/commit/eefa5a4a400434aae14c1b84b9733584b5aaad8c", "message": "Review comments.", "committedDate": "2020-05-26T09:01:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI4Mzk1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430283958", "bodyText": "Do we have to expose here LinkedHashMap? Maybe Map is enough?", "author": "petrpleshachkov", "createdAt": "2020-05-26T09:37:24Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/sample/MapSampleMetadata.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema.map.sample;\n+\n+import com.hazelcast.sql.impl.extract.QueryTargetDescriptor;\n+import com.hazelcast.sql.impl.schema.TableField;\n+\n+import java.util.LinkedHashMap;\n+\n+/**\n+ * Metadata from sample resolution.\n+ */\n+public class MapSampleMetadata {\n+\n+    private final QueryTargetDescriptor descriptor;\n+    private final LinkedHashMap<String, TableField> fields;\n+\n+    public MapSampleMetadata(QueryTargetDescriptor descriptor, LinkedHashMap<String, TableField> fields) {\n+        this.descriptor = descriptor;\n+        this.fields = fields;\n+    }\n+\n+    public QueryTargetDescriptor getDescriptor() {\n+        return descriptor;\n+    }\n+\n+    @SuppressWarnings(\"checkstyle:IllegalType\")\n+    public LinkedHashMap<String, TableField> getFields() {", "originalCommit": "eefa5a4a400434aae14c1b84b9733584b5aaad8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwODczMg==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430908732", "bodyText": "Order of fields is important for us, LinkedHashMap reflects that.", "author": "devozerov", "createdAt": "2020-05-27T07:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDI4Mzk1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4OTk4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430889987", "bodyText": "checkException()?", "author": "taburet", "createdAt": "2020-05-27T06:42:28Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/AbstractMapTable.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema.map;\n+\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.extract.QueryTargetDescriptor;\n+import com.hazelcast.sql.impl.schema.Table;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.TableStatistics;\n+\n+import java.util.List;\n+\n+/**\n+ * Table backed by IMap or ReplicatedMap.\n+ */\n+public abstract class AbstractMapTable extends Table {\n+\n+    private final QueryTargetDescriptor keyDescriptor;\n+    private final QueryTargetDescriptor valueDescriptor;\n+    private final QueryException exception;\n+\n+    protected AbstractMapTable(\n+        String schemaName,\n+        String name,\n+        List<TableField> fields,\n+        TableStatistics statistics,\n+        QueryTargetDescriptor keyDescriptor,\n+        QueryTargetDescriptor valueDescriptor\n+    ) {\n+        super(schemaName, name, fields, statistics);\n+\n+        this.keyDescriptor = keyDescriptor;\n+        this.valueDescriptor = valueDescriptor;\n+\n+        exception = null;\n+    }\n+\n+    protected AbstractMapTable(String schemaName, String name, QueryException exception) {\n+        super(schemaName, name, null, null);\n+\n+        this.keyDescriptor = null;\n+        this.valueDescriptor = null;\n+\n+        this.exception = exception;\n+    }\n+\n+    @Override\n+    public int getFieldCount() {\n+        checkException();\n+\n+        return super.getFieldCount();\n+    }\n+\n+    @Override\n+    public <T extends TableField> T getField(int index) {\n+        checkException();\n+\n+        return super.getField(index);\n+    }\n+\n+    @Override\n+    public TableStatistics getStatistics() {\n+        checkException();\n+\n+        return super.getStatistics();\n+    }\n+\n+    public QueryTargetDescriptor getKeyDescriptor() {\n+        return keyDescriptor;\n+    }\n+\n+    public QueryTargetDescriptor getValueDescriptor() {\n+        return valueDescriptor;", "originalCommit": "eefa5a4a400434aae14c1b84b9733584b5aaad8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwOTQ5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430909499", "bodyText": "checkException() is needed to let optimizer know that the table exists, but is not functional. Descriptors are used after the optimization process, so an exception check is not needed here. To summarize, exception check is only needed in the overridden methods.", "author": "devozerov", "createdAt": "2020-05-27T07:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4OTk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkzODE4Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430938186", "bodyText": "assert exception == null?", "author": "taburet", "createdAt": "2020-05-27T08:17:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4OTk4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0MjEyMA==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430942120", "bodyText": "Maybe, but again - exceptions are needed by Calcite integration, that works with Table interface, and never touch extension methods.", "author": "devozerov", "createdAt": "2020-05-27T08:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4OTk4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzUwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430907504", "bodyText": "Is there any specific reason for using portable style resolution only for binary? If user would change the storage format, we may end up with a different schema.", "author": "taburet", "createdAt": "2020-05-27T07:21:48Z", "path": "hazelcast/src/main/java/com/hazelcast/sql/impl/schema/map/sample/MapSampleMetadataResolver.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.sql.impl.schema.map.sample;\n+\n+import com.hazelcast.internal.serialization.Data;\n+import com.hazelcast.internal.serialization.InternalSerializationService;\n+import com.hazelcast.nio.serialization.ClassDefinition;\n+import com.hazelcast.nio.serialization.FieldType;\n+import com.hazelcast.nio.serialization.IdentifiedDataSerializable;\n+import com.hazelcast.nio.serialization.Portable;\n+import com.hazelcast.sql.impl.QueryException;\n+import com.hazelcast.sql.impl.extract.GenericQueryTargetDescriptor;\n+import com.hazelcast.sql.impl.extract.QueryPath;\n+import com.hazelcast.sql.impl.schema.TableField;\n+import com.hazelcast.sql.impl.schema.map.MapTableField;\n+import com.hazelcast.sql.impl.type.QueryDataType;\n+import com.hazelcast.sql.impl.type.QueryDataTypeUtils;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.util.LinkedHashMap;\n+import java.util.TreeMap;\n+\n+/**\n+ * Helper class that resolves a map-backed table from a key/value sample.\n+ */\n+public final class MapSampleMetadataResolver {\n+\n+    private static final String METHOD_PREFIX_GET = \"get\";\n+    private static final String METHOD_PREFIX_IS = \"is\";\n+    private static final String METHOD_GET_FACTORY_ID = \"getFactoryId\";\n+    private static final String METHOD_GET_CLASS_ID = \"getClassId\";\n+\n+    private MapSampleMetadataResolver() {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Resolves the metadata associated with the given key-value sample.\n+     *\n+     * @param ss Serialization service.\n+     * @param target Target to be analyzed.\n+     * @param binary Whether map objects are stored in binary form.\n+     * @param key Whether passed target is key or value.\n+     * @return Sample metadata.\n+     * @throws QueryException If metadata cannot be resolved.\n+     */\n+    public static MapSampleMetadata resolve(\n+        InternalSerializationService ss,\n+        Object target,\n+        boolean binary,\n+        boolean key\n+    ) {\n+        try {\n+            if (target instanceof Data) {\n+                Data data = (Data) target;\n+\n+                if (data.isPortable() && binary) {", "originalCommit": "eefa5a4a400434aae14c1b84b9733584b5aaad8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkxMjU3OA==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430912578", "bodyText": "The idea is as follows:\n\nBackground: in HZ key is always stored as Data, value is stored as either object or key. Portable object exposes different fields depending on whether we process it as object or as Data\nIf the format is OBJECT, we always deserialize to real objects\nIf the format is BINARY, we do not deserialize portables\nThis works almost in the same way as in Predicate API with one difference: if both key and value as Portables and storage format is OBJECT, then we extract Java fields form both key and value, while in Predicate API we extract portable fields from key, and Java fields from value.\nOur approach looks more consistent to me - user asked us to store key-value pairs In a form of Java objects, and we expose fields of Java objects from both key and value.", "author": "devozerov", "createdAt": "2020-05-27T07:31:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0MTA4MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430941081", "bodyText": "Another option is to resolve the schema for OBJECT format using the portable definition, but read the values from the Java object itself (I think it was done this way for performance reasons). But that might produce even more weird behavior, looks like we can't do anything about it.", "author": "taburet", "createdAt": "2020-05-27T08:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzUwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0MjY1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/16995#discussion_r430942655", "bodyText": "The problem is that portable definition may differ from real Java fields.", "author": "devozerov", "createdAt": "2020-05-27T08:24:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwNzUwNA=="}], "type": "inlineReview"}]}