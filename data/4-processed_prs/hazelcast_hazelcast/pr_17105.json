{"pr_number": 17105, "pr_title": "GenericRecord / GenericRecord.Builder", "pr_createdAt": "2020-06-18T12:46:56Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17105", "timeline": [{"oid": "a6a7efbc7d3f4ebcdbef172f7ec05258f904f204", "url": "https://github.com/hazelcast/hazelcast/commit/a6a7efbc7d3f4ebcdbef172f7ec05258f904f204", "message": "GenericRecord / GenericRecordBuilder\n\nNew interface to be returned when Portable factory is not configured.\nThis will allow users to add new logic including new Portable classes\nvia entryProcessor/Executor Callables without restarting the cluster.\n\nQuery system is rewritten with new InternalGenericRecord interface.\nOld query system was heavily depend on Portable. Any new format that\nexposes InternalGenericRecord can be supported on query/value extractors", "committedDate": "2020-06-18T13:05:58Z", "type": "forcePushed"}, {"oid": "59325368ccf9bb3114d2f80275ae5299caeda26a", "url": "https://github.com/hazelcast/hazelcast/commit/59325368ccf9bb3114d2f80275ae5299caeda26a", "message": "Remove CachedGenericRecordQueryReader back since it does not perform well", "committedDate": "2020-06-29T13:05:42Z", "type": "forcePushed"}, {"oid": "6f2173ee6dfb4f596ca8b2cbdb720b1c06539589", "url": "https://github.com/hazelcast/hazelcast/commit/6f2173ee6dfb4f596ca8b2cbdb720b1c06539589", "message": "test fix", "committedDate": "2020-06-30T12:34:25Z", "type": "forcePushed"}, {"oid": "26d2d89ed9f7b3acc210d043ca242db57800dbcf", "url": "https://github.com/hazelcast/hazelcast/commit/26d2d89ed9f7b3acc210d043ca242db57800dbcf", "message": "test fix", "committedDate": "2020-06-30T12:41:50Z", "type": "forcePushed"}, {"oid": "93c3d656c455818cd8e729f38e9593e7c8fd3017", "url": "https://github.com/hazelcast/hazelcast/commit/93c3d656c455818cd8e729f38e9593e7c8fd3017", "message": "test fix", "committedDate": "2020-07-01T07:52:00Z", "type": "forcePushed"}, {"oid": "42b861d2d80201823cc49f8f51ae4ad756515143", "url": "https://github.com/hazelcast/hazelcast/commit/42b861d2d80201823cc49f8f51ae4ad756515143", "message": "add class definition error check for PortableGenericRecord", "committedDate": "2020-07-14T11:52:46Z", "type": "forcePushed"}, {"oid": "c7c6480d374f7330611cdd276301b9c0280de993", "url": "https://github.com/hazelcast/hazelcast/commit/c7c6480d374f7330611cdd276301b9c0280de993", "message": "test fix", "committedDate": "2020-08-10T11:09:12Z", "type": "forcePushed"}, {"oid": "aae09a83a8f905c6be39ef90988b17ce32c1a912", "url": "https://github.com/hazelcast/hazelcast/commit/aae09a83a8f905c6be39ef90988b17ce32c1a912", "message": "GenericRecord / GenericRecordBuilder\n\nNew interface to be returned when Portable factory is not configured.\nThis will allow users to add new logic including new Portable classes\nvia entryProcessor/Executor Callables without restarting the cluster.\n\nQuery system is rewritten with new InternalGenericRecord interface.\nOld query system was heavily depend on Portable. Any new format that\nexposes InternalGenericRecord can be supported on query/value extractors\n\n(cherry picked from commit c759f204f2a4ed3409ba4b98787eec8239e84ca0)", "committedDate": "2020-08-13T08:28:10Z", "type": "commit"}, {"oid": "4a93f2a26936b90bef69ea9c7e49dc8823f59f6a", "url": "https://github.com/hazelcast/hazelcast/commit/4a93f2a26936b90bef69ea9c7e49dc8823f59f6a", "message": "Fix grammar, improve javadoc\n\n(cherry picked from commit 66deaaf832bdfa91689bff0f52404df8e4742170)", "committedDate": "2020-08-13T08:28:10Z", "type": "commit"}, {"oid": "b42aa43f399be50f2b8fe5eac02eaf1999731203", "url": "https://github.com/hazelcast/hazelcast/commit/b42aa43f399be50f2b8fe5eac02eaf1999731203", "message": "checkstyle fixes\n\n(cherry picked from commit c66bf598d263522ed0af176dd6f0b4a6966b0203)", "committedDate": "2020-08-13T08:28:10Z", "type": "commit"}, {"oid": "81f06bb135eb2716ebe15733aeab2bf7c9a7445e", "url": "https://github.com/hazelcast/hazelcast/commit/81f06bb135eb2716ebe15733aeab2bf7c9a7445e", "message": "Remove CachedGenericRecordQueryReader back since it does not perform well\n\n(cherry picked from commit ff51ce3dddc9552774fb601f80eef50c18567c22)", "committedDate": "2020-08-13T08:28:10Z", "type": "commit"}, {"oid": "121e46c017246a7557b351dc0a2ac838f8af9470", "url": "https://github.com/hazelcast/hazelcast/commit/121e46c017246a7557b351dc0a2ac838f8af9470", "message": "added toString to GenericPortableRecord", "committedDate": "2020-08-13T08:28:10Z", "type": "commit"}, {"oid": "eb80eda40ffa133ad9ecda6dd533d71dd8883697", "url": "https://github.com/hazelcast/hazelcast/commit/eb80eda40ffa133ad9ecda6dd533d71dd8883697", "message": "test fix", "committedDate": "2020-08-13T08:28:10Z", "type": "commit"}, {"oid": "dba8a6a5c5a2449c260a5ae494d09f94605e0190", "url": "https://github.com/hazelcast/hazelcast/commit/dba8a6a5c5a2449c260a5ae494d09f94605e0190", "message": "add class definition error check for PortableGenericRecord", "committedDate": "2020-08-13T08:28:10Z", "type": "commit"}, {"oid": "9a7bb269a89d4a0b5731685497a15ca4c40b9039", "url": "https://github.com/hazelcast/hazelcast/commit/9a7bb269a89d4a0b5731685497a15ca4c40b9039", "message": "test fix", "committedDate": "2020-08-13T08:28:10Z", "type": "commit"}, {"oid": "1fffe834b276b0731ba08d87b5aa25cfccba08ef", "url": "https://github.com/hazelcast/hazelcast/commit/1fffe834b276b0731ba08d87b5aa25cfccba08ef", "message": "Implements cloneWithGenericBuilder\n\nRemoved IOExceptions from GenericRecord interface.", "committedDate": "2020-08-20T12:56:19Z", "type": "commit"}, {"oid": "1fffe834b276b0731ba08d87b5aa25cfccba08ef", "url": "https://github.com/hazelcast/hazelcast/commit/1fffe834b276b0731ba08d87b5aa25cfccba08ef", "message": "Implements cloneWithGenericBuilder\n\nRemoved IOExceptions from GenericRecord interface.", "committedDate": "2020-08-20T12:56:19Z", "type": "forcePushed"}, {"oid": "5a18cd3b60ec1f990a79129ea15a41f6f731ec44", "url": "https://github.com/hazelcast/hazelcast/commit/5a18cd3b60ec1f990a79129ea15a41f6f731ec44", "message": "GenericRecordBuilder is made subinterface of GenericRecord", "committedDate": "2020-08-20T14:40:03Z", "type": "commit"}, {"oid": "5a18cd3b60ec1f990a79129ea15a41f6f731ec44", "url": "https://github.com/hazelcast/hazelcast/commit/5a18cd3b60ec1f990a79129ea15a41f6f731ec44", "message": "GenericRecordBuilder is made subinterface of GenericRecord", "committedDate": "2020-08-20T14:40:03Z", "type": "forcePushed"}, {"oid": "bbe11ef77d976e8516f712ed89847235687de68f", "url": "https://github.com/hazelcast/hazelcast/commit/bbe11ef77d976e8516f712ed89847235687de68f", "message": "test fix", "committedDate": "2020-08-21T07:39:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUwMzI4NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474503284", "bodyText": "switch/case instead of if/else  chain?", "author": "mdogan", "createdAt": "2020-08-21T08:09:43Z", "path": "hazelcast/src/main/java/com/hazelcast/query/impl/getters/ExtractorHelper.java", "diffHunk": "@@ -122,4 +123,94 @@ public static String extractArgumentsFromAttributeName(String attributeNameWithA\n         throw new IllegalArgumentException(\"Wrong argument input passed \" + attributeNameWithArguments);\n     }\n \n+    /**\n+     * @param add            Consumer that primitives will be passed to\n+     * @param primitiveArray primitive array to read from\n+     * @return false if primitive array is empty\n+     */\n+    @SuppressWarnings({\"checkstyle:cyclomaticcomplexity\", \"checkstyle:methodlength\", \"checkstyle:returncount\"})\n+    public static boolean reducePrimitiveArrayInto(Consumer add, Object primitiveArray) {\n+        // XXX: Standard Array.get has really bad performance, see\n+        // https://bugs.openjdk.java.net/browse/JDK-8051447. For large arrays\n+        // it may consume significant amount of time, so we are doing the\n+        // reduction manually for each primitive type.\n+\n+        if (primitiveArray instanceof long[]) {", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY4MDA3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474680075", "bodyText": "It is not possible, right?  I have found a JEP draft  https://openjdk.java.net/jeps/8213076 :)", "author": "sancar", "createdAt": "2020-08-21T12:58:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUwMzI4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY4MzA4Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474683087", "bodyText": "\ud83e\udd26 Other languages (kotlin, go) I use frequently has this . Somehow I thought you can do that in java too. sorry for the confusion...", "author": "mdogan", "createdAt": "2020-08-21T13:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUwMzI4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUwOTMwMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474509300", "bodyText": "What's the purpose of this interface?", "author": "mdogan", "createdAt": "2020-08-21T08:16:26Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/InternalValueReader.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.serialization.impl;\n+\n+import com.hazelcast.query.extractor.ValueReader;\n+\n+import java.io.IOException;\n+\n+public interface InternalValueReader extends ValueReader {", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDY5NDE5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474694190", "bodyText": "It was an abstraction for query mechanism but now I have realized that the abstraction is already done with InternalGenericRecord . Both Portable and Serialization 2.0 will implement their own InternalGenericRecord.\nThere will be only one InternalValueReader which is GenericRecordQueryReader. I will remove this interface and I will add javadoc to GenericRecordQueryReader", "author": "sancar", "createdAt": "2020-08-21T13:25:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUwOTMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxMDIyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474510227", "bodyText": "How this method is different than ValueReader.read(path, collector)? What is the use-case?", "author": "mdogan", "createdAt": "2020-08-21T08:17:29Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/InternalValueReader.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.serialization.impl;\n+\n+import com.hazelcast.query.extractor.ValueReader;\n+\n+import java.io.IOException;\n+\n+public interface InternalValueReader extends ValueReader {\n+\n+    Object read(String fieldPath) throws IOException;", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcwMTg0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474701844", "bodyText": "I am removing the interface but the method will remain in GenericRecordQueryReader. So I am referring to that.\nThis method will be used from our internal query logic. Specifically, it is called from PortableGetter without any collector or callback. In theory, we could reuse ValueReader methods but it will be complicated unnecessarily(and also create litter on the hot path of the query)", "author": "sancar", "createdAt": "2020-08-21T13:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxMDIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxNjQwMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474516402", "bodyText": "GenericRecord in the name seems redundant. just newBuilder() ?", "author": "mdogan", "createdAt": "2020-08-21T08:24:38Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.nio.serialization;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableGenericRecordBuilder;\n+\n+/**\n+ * A generic object interface that is returned when the domain class can not be created.\n+ * Currently this is valid for {@link Portable} objects.\n+ */\n+public interface GenericRecord {\n+\n+    /**\n+     * @return an empty generic record builder with same class definition as this one\n+     */\n+    Builder createGenericRecordBuilder();", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyODA1Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474528053", "bodyText": "More javadoc. When this method supposed to be used? How is this different from creating a Builder from scratch?", "author": "mdogan", "createdAt": "2020-08-21T08:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxNjQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxNjcxMA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474516710", "bodyText": "cloneWithBuilder()?", "author": "mdogan", "createdAt": "2020-08-21T08:24:57Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.nio.serialization;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableGenericRecordBuilder;\n+\n+/**\n+ * A generic object interface that is returned when the domain class can not be created.\n+ * Currently this is valid for {@link Portable} objects.\n+ */\n+public interface GenericRecord {\n+\n+    /**\n+     * @return an empty generic record builder with same class definition as this one\n+     */\n+    Builder createGenericRecordBuilder();\n+\n+    /**\n+     * Returned GenericRecordBuilder can be used to have exact copy and also just to update a couple of fields. By default,\n+     * it will copy all the fields.\n+     *\n+     * @return a generic record builder with same class definition as this one and populated with same values.\n+     */\n+    Builder cloneWithGenericRecordBuilder();", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyODM2MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474528360", "bodyText": "Code sample in javadoc please...", "author": "mdogan", "createdAt": "2020-08-21T08:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUxNjcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyMDg3Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474520872", "bodyText": "Need more explanation... when to use this builder? how to use this builder? a code snippet about the usage...", "author": "mdogan", "createdAt": "2020-08-21T08:29:38Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.nio.serialization;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableGenericRecordBuilder;\n+\n+/**\n+ * A generic object interface that is returned when the domain class can not be created.\n+ * Currently this is valid for {@link Portable} objects.\n+ */\n+public interface GenericRecord {\n+\n+    /**\n+     * @return an empty generic record builder with same class definition as this one\n+     */\n+    Builder createGenericRecordBuilder();\n+\n+    /**\n+     * Returned GenericRecordBuilder can be used to have exact copy and also just to update a couple of fields. By default,\n+     * it will copy all the fields.\n+     *\n+     * @return a generic record builder with same class definition as this one and populated with same values.\n+     */\n+    Builder cloneWithGenericRecordBuilder();\n+\n+    FieldType getFieldType(String fieldName);\n+\n+    GenericRecord[] readGenericRecordArray(String fieldName);\n+\n+    GenericRecord readGenericRecord(String fieldName);\n+\n+    boolean hasField(String fieldName);\n+\n+    int readInt(String fieldName);\n+\n+    long readLong(String fieldName);\n+\n+    String readUTF(String fieldName);\n+\n+    boolean readBoolean(String fieldName);\n+\n+    byte readByte(String fieldName);\n+\n+    char readChar(String fieldName);\n+\n+    double readDouble(String fieldName);\n+\n+    float readFloat(String fieldName);\n+\n+    short readShort(String fieldName);\n+\n+    byte[] readByteArray(String fieldName);\n+\n+    boolean[] readBooleanArray(String fieldName);\n+\n+    char[] readCharArray(String fieldName);\n+\n+    int[] readIntArray(String fieldName);\n+\n+    long[] readLongArray(String fieldName);\n+\n+    double[] readDoubleArray(String fieldName);\n+\n+    float[] readFloatArray(String fieldName);\n+\n+    short[] readShortArray(String fieldName);\n+\n+    String[] readUTFArray(String fieldName);\n+\n+    /**\n+     * Interface for creating {@link GenericRecord} instances.\n+     * Allows the usage of {@link Portable} without having a domain class.\n+     */\n+    interface Builder {", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyNDg3MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474524871", "bodyText": "better to have some javadoc on these methods...\n\nIs it allowed to write the same field more than once?\nIf not what happens when someone does; failure, exception?\nIs there a limitation for the field name? Can it contain non-printable chars? Is . allowed? Is $ allowed? etc...\nWhat happens if value is null for String, GenericRecord or arrays? Is this allowed?", "author": "mdogan", "createdAt": "2020-08-21T08:34:18Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.nio.serialization;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableGenericRecordBuilder;\n+\n+/**\n+ * A generic object interface that is returned when the domain class can not be created.\n+ * Currently this is valid for {@link Portable} objects.\n+ */\n+public interface GenericRecord {\n+\n+    /**\n+     * @return an empty generic record builder with same class definition as this one\n+     */\n+    Builder createGenericRecordBuilder();\n+\n+    /**\n+     * Returned GenericRecordBuilder can be used to have exact copy and also just to update a couple of fields. By default,\n+     * it will copy all the fields.\n+     *\n+     * @return a generic record builder with same class definition as this one and populated with same values.\n+     */\n+    Builder cloneWithGenericRecordBuilder();\n+\n+    FieldType getFieldType(String fieldName);\n+\n+    GenericRecord[] readGenericRecordArray(String fieldName);\n+\n+    GenericRecord readGenericRecord(String fieldName);\n+\n+    boolean hasField(String fieldName);\n+\n+    int readInt(String fieldName);\n+\n+    long readLong(String fieldName);\n+\n+    String readUTF(String fieldName);\n+\n+    boolean readBoolean(String fieldName);\n+\n+    byte readByte(String fieldName);\n+\n+    char readChar(String fieldName);\n+\n+    double readDouble(String fieldName);\n+\n+    float readFloat(String fieldName);\n+\n+    short readShort(String fieldName);\n+\n+    byte[] readByteArray(String fieldName);\n+\n+    boolean[] readBooleanArray(String fieldName);\n+\n+    char[] readCharArray(String fieldName);\n+\n+    int[] readIntArray(String fieldName);\n+\n+    long[] readLongArray(String fieldName);\n+\n+    double[] readDoubleArray(String fieldName);\n+\n+    float[] readFloatArray(String fieldName);\n+\n+    short[] readShortArray(String fieldName);\n+\n+    String[] readUTFArray(String fieldName);\n+\n+    /**\n+     * Interface for creating {@link GenericRecord} instances.\n+     * Allows the usage of {@link Portable} without having a domain class.\n+     */\n+    interface Builder {\n+\n+        /**\n+         * @param classDefinition of the portable that we will create\n+         * @return GenericRecordBuilder for Portable format\n+         */\n+        static Builder portable(ClassDefinition classDefinition) {\n+            return new PortableGenericRecordBuilder(classDefinition);\n+        }\n+\n+        GenericRecord build();\n+\n+        Builder writeInt(String fieldName, int value);", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUyNjg2Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474526863", "bodyText": "Need more javadoc. When and how to use GenericRecord? especially code samples for most common usage scenarios...", "author": "mdogan", "createdAt": "2020-08-21T08:36:24Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.nio.serialization;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableGenericRecordBuilder;\n+\n+/**\n+ * A generic object interface that is returned when the domain class can not be created.\n+ * Currently this is valid for {@link Portable} objects.\n+ */\n+public interface GenericRecord {", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzMDYyNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474530625", "bodyText": "I think it's better to order these methods. That way it will be easier to spot.", "author": "mdogan", "createdAt": "2020-08-21T08:40:35Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.nio.serialization;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableGenericRecordBuilder;\n+\n+/**\n+ * A generic object interface that is returned when the domain class can not be created.\n+ * Currently this is valid for {@link Portable} objects.\n+ */\n+public interface GenericRecord {\n+\n+    /**\n+     * @return an empty generic record builder with same class definition as this one\n+     */\n+    Builder createGenericRecordBuilder();\n+\n+    /**\n+     * Returned GenericRecordBuilder can be used to have exact copy and also just to update a couple of fields. By default,\n+     * it will copy all the fields.\n+     *\n+     * @return a generic record builder with same class definition as this one and populated with same values.\n+     */\n+    Builder cloneWithGenericRecordBuilder();\n+\n+    FieldType getFieldType(String fieldName);\n+\n+    GenericRecord[] readGenericRecordArray(String fieldName);\n+\n+    GenericRecord readGenericRecord(String fieldName);\n+\n+    boolean hasField(String fieldName);\n+\n+    int readInt(String fieldName);\n+\n+    long readLong(String fieldName);\n+\n+    String readUTF(String fieldName);\n+\n+    boolean readBoolean(String fieldName);\n+\n+    byte readByte(String fieldName);\n+\n+    char readChar(String fieldName);\n+\n+    double readDouble(String fieldName);\n+\n+    float readFloat(String fieldName);\n+\n+    short readShort(String fieldName);\n+\n+    byte[] readByteArray(String fieldName);\n+\n+    boolean[] readBooleanArray(String fieldName);\n+\n+    char[] readCharArray(String fieldName);\n+\n+    int[] readIntArray(String fieldName);\n+\n+    long[] readLongArray(String fieldName);\n+\n+    double[] readDoubleArray(String fieldName);\n+\n+    float[] readFloatArray(String fieldName);\n+\n+    short[] readShortArray(String fieldName);\n+\n+    String[] readUTFArray(String fieldName);\n+\n+    /**\n+     * Interface for creating {@link GenericRecord} instances.\n+     * Allows the usage of {@link Portable} without having a domain class.\n+     */\n+    interface Builder {\n+\n+        /**\n+         * @param classDefinition of the portable that we will create\n+         * @return GenericRecordBuilder for Portable format\n+         */\n+        static Builder portable(ClassDefinition classDefinition) {\n+            return new PortableGenericRecordBuilder(classDefinition);\n+        }\n+\n+        GenericRecord build();\n+\n+        Builder writeInt(String fieldName, int value);\n+\n+        Builder writeLong(String fieldName, long value);", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzMTI2NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474531264", "bodyText": "I think it's better to order these methods, maybe due to size of the field type.", "author": "mdogan", "createdAt": "2020-08-21T08:41:17Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.nio.serialization;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableGenericRecordBuilder;\n+\n+/**\n+ * A generic object interface that is returned when the domain class can not be created.\n+ * Currently this is valid for {@link Portable} objects.\n+ */\n+public interface GenericRecord {\n+\n+    /**\n+     * @return an empty generic record builder with same class definition as this one\n+     */\n+    Builder createGenericRecordBuilder();\n+\n+    /**\n+     * Returned GenericRecordBuilder can be used to have exact copy and also just to update a couple of fields. By default,\n+     * it will copy all the fields.\n+     *\n+     * @return a generic record builder with same class definition as this one and populated with same values.\n+     */\n+    Builder cloneWithGenericRecordBuilder();\n+\n+    FieldType getFieldType(String fieldName);\n+\n+    GenericRecord[] readGenericRecordArray(String fieldName);\n+\n+    GenericRecord readGenericRecord(String fieldName);\n+\n+    boolean hasField(String fieldName);\n+\n+    int readInt(String fieldName);", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzMjAwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474532003", "bodyText": "javadoc... what happens when field does not exist? returns null? or throws exception?", "author": "mdogan", "createdAt": "2020-08-21T08:42:06Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.nio.serialization;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableGenericRecordBuilder;\n+\n+/**\n+ * A generic object interface that is returned when the domain class can not be created.\n+ * Currently this is valid for {@link Portable} objects.\n+ */\n+public interface GenericRecord {\n+\n+    /**\n+     * @return an empty generic record builder with same class definition as this one\n+     */\n+    Builder createGenericRecordBuilder();\n+\n+    /**\n+     * Returned GenericRecordBuilder can be used to have exact copy and also just to update a couple of fields. By default,\n+     * it will copy all the fields.\n+     *\n+     * @return a generic record builder with same class definition as this one and populated with same values.\n+     */\n+    Builder cloneWithGenericRecordBuilder();\n+\n+    FieldType getFieldType(String fieldName);\n+\n+    GenericRecord[] readGenericRecordArray(String fieldName);\n+\n+    GenericRecord readGenericRecord(String fieldName);", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzNTI2Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474535266", "bodyText": "No need to cast (Portable) o), there's already local variable p.", "author": "mdogan", "createdAt": "2020-08-21T08:45:51Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableSerializer.java", "diffHunk": "@@ -49,21 +57,30 @@ public int getTypeId() {\n     }\n \n     @Override\n-    public void write(ObjectDataOutput out, Portable p) throws IOException {\n-        if (!(out instanceof BufferObjectDataOutput)) {\n-            throw new IllegalArgumentException(\"ObjectDataOutput must be instance of BufferObjectDataOutput!\");\n+    public void write(ObjectDataOutput out, Object o) throws IOException {\n+        if (o instanceof Portable) {\n+            Portable p = (Portable) o;\n+            if (!(out instanceof BufferObjectDataOutput)) {\n+                throw new IllegalArgumentException(\"ObjectDataOutput must be instance of BufferObjectDataOutput!\");\n+            }\n+            if (p.getClassId() == 0) {\n+                throw new IllegalArgumentException(\"Portable class ID cannot be zero!\");\n+            }\n+\n+            out.writeInt(p.getFactoryId());\n+            out.writeInt(p.getClassId());\n+            writeInternal((BufferObjectDataOutput) out, (Portable) o);", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzNTk3Nw==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474535977", "bodyText": "IllegalArgumentException?", "author": "mdogan", "createdAt": "2020-08-21T08:46:39Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableSerializer.java", "diffHunk": "@@ -49,21 +57,30 @@ public int getTypeId() {\n     }\n \n     @Override\n-    public void write(ObjectDataOutput out, Portable p) throws IOException {\n-        if (!(out instanceof BufferObjectDataOutput)) {\n-            throw new IllegalArgumentException(\"ObjectDataOutput must be instance of BufferObjectDataOutput!\");\n+    public void write(ObjectDataOutput out, Object o) throws IOException {\n+        if (o instanceof Portable) {\n+            Portable p = (Portable) o;\n+            if (!(out instanceof BufferObjectDataOutput)) {\n+                throw new IllegalArgumentException(\"ObjectDataOutput must be instance of BufferObjectDataOutput!\");\n+            }\n+            if (p.getClassId() == 0) {\n+                throw new IllegalArgumentException(\"Portable class ID cannot be zero!\");\n+            }\n+\n+            out.writeInt(p.getFactoryId());\n+            out.writeInt(p.getClassId());\n+            writeInternal((BufferObjectDataOutput) out, (Portable) o);\n+            return;\n         }\n-        if (p.getClassId() == 0) {\n-            throw new IllegalArgumentException(\"Portable class ID cannot be zero!\");\n+        if (o instanceof PortableGenericRecord) {\n+            writePortableGenericRecord(out, (PortableGenericRecord) o);\n+            return;\n         }\n-\n-        out.writeInt(p.getFactoryId());\n-        out.writeInt(p.getClassId());\n-        writeInternal((BufferObjectDataOutput) out, p);\n+        throw new IllegalStateException(\"PortableSerializer can only write Portable and PortableGenericRecord\");", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0MTgxOQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474541819", "bodyText": "Unexpected field type", "author": "mdogan", "createdAt": "2020-08-21T08:52:15Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableSerializer.java", "diffHunk": "@@ -179,5 +194,196 @@ public DefaultPortableReader createReader(BufferObjectDataInput in, int factoryI\n     public void destroy() {\n         factories.clear();\n     }\n+\n+    //Portable Generic Record\n+\n+    private void writePortableGenericRecord(ObjectDataOutput out, PortableGenericRecord record) throws IOException {\n+        ClassDefinition cd = record.getClassDefinition();\n+        if (checkClassDefErrors) {\n+            ClassDefinition existingCd = context.lookupClassDefinition(cd.getFactoryId(), cd.getClassId(), cd.getVersion());\n+            if (existingCd != null && !existingCd.equals(cd)) {\n+                throw new HazelcastSerializationException(\"Inconsistent class definition found. New class definition : \" + cd\n+                        + \", Existing class definition \" + existingCd);\n+            }\n+        }\n+        context.registerClassDefinition(cd);\n+        out.writeInt(cd.getFactoryId());\n+        out.writeInt(cd.getClassId());\n+        writePortableGenericRecordInternal(out, record);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:MethodLength\", \"checkstyle:CyclomaticComplexity\"})\n+    void writePortableGenericRecordInternal(ObjectDataOutput out, PortableGenericRecord record) throws IOException {\n+        ClassDefinition cd = record.getClassDefinition();\n+        out.writeInt(cd.getVersion());\n+\n+        BufferObjectDataOutput output = (BufferObjectDataOutput) out;\n+        DefaultPortableWriter writer = new DefaultPortableWriter(this, output, cd);\n+        Set<String> fieldNames = cd.getFieldNames();\n+        for (String fieldName : fieldNames) {\n+            switch (cd.getFieldType(fieldName)) {\n+                case PORTABLE:\n+                    writer.writeGenericRecord(fieldName, record.readGenericRecord(fieldName));\n+                    break;\n+                case BYTE:\n+                    writer.writeByte(fieldName, record.readByte(fieldName));\n+                    break;\n+                case BOOLEAN:\n+                    writer.writeBoolean(fieldName, record.readBoolean(fieldName));\n+                    break;\n+                case CHAR:\n+                    writer.writeChar(fieldName, record.readChar(fieldName));\n+                    break;\n+                case SHORT:\n+                    writer.writeShort(fieldName, record.readShort(fieldName));\n+                    break;\n+                case INT:\n+                    writer.writeInt(fieldName, record.readInt(fieldName));\n+                    break;\n+                case LONG:\n+                    writer.writeLong(fieldName, record.readLong(fieldName));\n+                    break;\n+                case FLOAT:\n+                    writer.writeFloat(fieldName, record.readFloat(fieldName));\n+                    break;\n+                case DOUBLE:\n+                    writer.writeDouble(fieldName, record.readDouble(fieldName));\n+                    break;\n+                case UTF:\n+                    writer.writeUTF(fieldName, record.readUTF(fieldName));\n+                    break;\n+                case PORTABLE_ARRAY:\n+                    writer.writeGenericRecordArray(fieldName, record.readGenericRecordArray(fieldName));\n+                    break;\n+                case BYTE_ARRAY:\n+                    writer.writeByteArray(fieldName, record.readByteArray(fieldName));\n+                    break;\n+                case BOOLEAN_ARRAY:\n+                    writer.writeBooleanArray(fieldName, record.readBooleanArray(fieldName));\n+                    break;\n+                case CHAR_ARRAY:\n+                    writer.writeCharArray(fieldName, record.readCharArray(fieldName));\n+                    break;\n+                case SHORT_ARRAY:\n+                    writer.writeShortArray(fieldName, record.readShortArray(fieldName));\n+                    break;\n+                case INT_ARRAY:\n+                    writer.writeIntArray(fieldName, record.readIntArray(fieldName));\n+                    break;\n+                case LONG_ARRAY:\n+                    writer.writeLongArray(fieldName, record.readLongArray(fieldName));\n+                    break;\n+                case FLOAT_ARRAY:\n+                    writer.writeFloatArray(fieldName, record.readFloatArray(fieldName));\n+                    break;\n+                case DOUBLE_ARRAY:\n+                    writer.writeDoubleArray(fieldName, record.readDoubleArray(fieldName));\n+                    break;\n+                case UTF_ARRAY:\n+                    writer.writeUTFArray(fieldName, record.readUTFArray(fieldName));\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unexpected value: \" + cd.getFieldType(fieldName));", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU5ODg5OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474598898", "bodyText": "GenericRecord  has this method already.", "author": "mdogan", "createdAt": "2020-08-21T09:57:03Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/InternalGenericRecord.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.serialization.impl;\n+\n+import com.hazelcast.nio.serialization.GenericRecord;\n+\n+/**\n+ * Additionally to GenericRecord, this one has more methods to be used in Query.\n+ *\n+ * @see GenericRecordQueryReader\n+ *\n+ * read*FromArray methods will return `null`\n+ * 1. if the array is null or empty\n+ * 2. there is no data at given index. In other words, the index is bigger than the length of the array\n+ */\n+public interface InternalGenericRecord extends GenericRecord {\n+\n+    GenericRecord[] readGenericRecordArray(String fieldName);", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU5OTEwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474599106", "bodyText": "What is this method for? can you add some doc?", "author": "mdogan", "createdAt": "2020-08-21T09:57:34Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/InternalGenericRecord.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.serialization.impl;\n+\n+import com.hazelcast.nio.serialization.GenericRecord;\n+\n+/**\n+ * Additionally to GenericRecord, this one has more methods to be used in Query.\n+ *\n+ * @see GenericRecordQueryReader\n+ *\n+ * read*FromArray methods will return `null`\n+ * 1. if the array is null or empty\n+ * 2. there is no data at given index. In other words, the index is bigger than the length of the array\n+ */\n+public interface InternalGenericRecord extends GenericRecord {\n+\n+    GenericRecord[] readGenericRecordArray(String fieldName);\n+\n+    Byte readByteFromArray(String fieldName, int index);\n+\n+    Boolean readBooleanFromArray(String fieldName, int index);\n+\n+    Character readCharFromArray(String fieldName, int index);\n+\n+    Integer readIntFromArray(String fieldName, int index);\n+\n+    Long readLongFromArray(String fieldName, int index);\n+\n+    Double readDoubleFromArray(String fieldName, int index);\n+\n+    Float readFloatFromArray(String fieldName, int index);\n+\n+    Short readShortFromArray(String fieldName, int index);\n+\n+    String readUTFFromArray(String fieldName, int index);\n+\n+    GenericRecord readGenericRecordFromArray(String fieldName, int index);\n+\n+    Object readObjectFromArray(String fieldName, int index);\n+\n+    Object[] readObjectArray(String fieldName);\n+\n+    Object readObject(String fieldName);", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU5OTQ5Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474599496", "bodyText": "Similarly for other readObject* methods too.", "author": "mdogan", "createdAt": "2020-08-21T09:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU5OTEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDYxNTk0MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r474615940", "bodyText": "Two read methods, with ValueCallback and ValueCollector, look exactly the same. I think you can merge these two using a signature like read(String path, Consumer c).", "author": "mdogan", "createdAt": "2020-08-21T10:33:02Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/GenericRecordQueryReader.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.serialization.impl;\n+\n+import com.hazelcast.internal.util.StringUtil;\n+import com.hazelcast.nio.serialization.FieldType;\n+import com.hazelcast.nio.serialization.GenericRecord;\n+import com.hazelcast.query.extractor.ValueCallback;\n+import com.hazelcast.query.extractor.ValueCollector;\n+import com.hazelcast.query.extractor.ValueReadingException;\n+import com.hazelcast.query.impl.getters.ExtractorHelper;\n+import com.hazelcast.query.impl.getters.MultiResult;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+\n+import static com.hazelcast.query.impl.getters.ExtractorHelper.extractArgumentsFromAttributeName;\n+import static com.hazelcast.query.impl.getters.ExtractorHelper.extractAttributeNameNameWithoutArguments;\n+\n+\n+public final class GenericRecordQueryReader implements InternalValueReader {\n+\n+    private final InternalGenericRecord rootRecord;\n+\n+    public GenericRecordQueryReader(InternalGenericRecord rootRecord) {\n+        this.rootRecord = rootRecord;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void read(String path, ValueCallback callback) {", "originalCommit": "bbe11ef77d976e8516f712ed89847235687de68f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8dc4a1edfebbd39bf6b8af3d4681cd242994e0af", "url": "https://github.com/hazelcast/hazelcast/commit/8dc4a1edfebbd39bf6b8af3d4681cd242994e0af", "message": "addressed review comments", "committedDate": "2020-08-23T18:23:53Z", "type": "commit"}, {"oid": "8dc4a1edfebbd39bf6b8af3d4681cd242994e0af", "url": "https://github.com/hazelcast/hazelcast/commit/8dc4a1edfebbd39bf6b8af3d4681cd242994e0af", "message": "addressed review comments", "committedDate": "2020-08-23T18:23:53Z", "type": "forcePushed"}, {"oid": "6de5121653a0851149442234bc68395fc9bc3e29", "url": "https://github.com/hazelcast/hazelcast/commit/6de5121653a0851149442234bc68395fc9bc3e29", "message": "addressed review comments", "committedDate": "2020-08-24T07:58:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQyMDU5OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r475420599", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * the objects will be returned as {@link GenericRecord}. This way, the clients s can be  read and write the objects back to\n          \n          \n            \n             * the cluster without having the class of the domain object\n          \n          \n            \n             * the objects will be returned as {@link GenericRecord}. This way, the clients can read and write the objects back to\n          \n          \n            \n             * the cluster without needing the classes of the domain objects on the classpath.", "author": "mdogan", "createdAt": "2020-08-24T08:20:25Z", "path": "hazelcast/src/main/java/com/hazelcast/nio/serialization/GenericRecord.java", "diffHunk": "@@ -0,0 +1,548 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.nio.serialization;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableGenericRecordBuilder;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A generic object interface that is returned to user when the domain class can not be created from any of the distributed\n+ * hazelcast data structures like {@link com.hazelcast.map.IMap} ,{@link com.hazelcast.collection.IQueue} etc.\n+ * <p>\n+ * On remote calls like distributed executor service or EntryProcessors, you may need to access to the domain object. In\n+ * case class of the domain object is not available on the cluster, GenericRecord allows to access, read and write the objects\n+ * back without the class of the domain object. Here is an read example with EntryProcessor:\n+ * <pre>\n+ * map.executeOnKey(key, (EntryProcessor<Object, Object, Object>) entry -> {\n+ *             Object value = entry.getValue();\n+ *             GenericRecord genericRecord = (GenericRecord) value;\n+ *\n+ *             int id = genericRecord.readInt(\"id\");\n+ *\n+ *             return null;\n+ *         });\n+ * </pre>\n+ * <p>\n+ * GenericRecord also allows to read from a cluster without having the classes on the client side.\n+ * For {@link Portable}, when {@link PortableFactory} is not provided in the config at the start,\n+ * a {@link HazelcastSerializationException} was thrown stating that a factory could not be found. Starting from 4.1,\n+ * the objects will be returned as {@link GenericRecord}. This way, the clients s can be  read and write the objects back to\n+ * the cluster without having the class of the domain object", "originalCommit": "6de5121653a0851149442234bc68395fc9bc3e29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "067fbf3a3c395e943ae498f597a0e6c5b7ef184b", "url": "https://github.com/hazelcast/hazelcast/commit/067fbf3a3c395e943ae498f597a0e6c5b7ef184b", "message": "javadoc fix", "committedDate": "2020-08-24T08:29:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUwMTEyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r475501127", "bodyText": "this check can be put two lines before at line 114.", "author": "ihsandemir", "createdAt": "2020-08-24T10:26:48Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/GenericRecordQueryReader.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.serialization.impl;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableInternalGenericRecord;\n+import com.hazelcast.internal.util.StringUtil;\n+import com.hazelcast.nio.serialization.FieldType;\n+import com.hazelcast.nio.serialization.GenericRecord;\n+import com.hazelcast.query.extractor.ValueCallback;\n+import com.hazelcast.query.extractor.ValueCollector;\n+import com.hazelcast.query.extractor.ValueReader;\n+import com.hazelcast.query.extractor.ValueReadingException;\n+import com.hazelcast.query.impl.getters.ExtractorHelper;\n+import com.hazelcast.query.impl.getters.MultiResult;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+import java.util.function.Consumer;\n+\n+import static com.hazelcast.query.impl.getters.ExtractorHelper.extractArgumentsFromAttributeName;\n+import static com.hazelcast.query.impl.getters.ExtractorHelper.extractAttributeNameNameWithoutArguments;\n+\n+/**\n+ * Reads a field or array of fields from a `InternalGenericRecord` according to given query `path`\n+ *\n+ * @see InternalGenericRecord\n+ * Any format that exposes an `InternalGenericRecord` will benefit from hazelcast query.\n+ * @see PortableInternalGenericRecord for Portable InternalGenericRecord\n+ * <p>\n+ * Example queries\n+ * \"age\"\n+ * \"engine.power\"\n+ * \"child[0].age\"\n+ * \"engine.wheel[0].pressure\"\n+ * \"engine.wheel[any].pressure\"\n+ * \"top500Companies[0].ceo\"\n+ * \"company.employees[any]\"\n+ * \"limbs[*].fingers\"\n+ * <p>\n+ * It also implements ValueReader to support reading into `ValueCallback` and `ValueCollector`\n+ */\n+public final class GenericRecordQueryReader implements ValueReader {\n+\n+    private final InternalGenericRecord rootRecord;\n+\n+    public GenericRecordQueryReader(InternalGenericRecord rootRecord) {\n+        this.rootRecord = rootRecord;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void read(String path, ValueCallback callback) {\n+        read(path, (ValueCollector) callback::onResult);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void read(String path, ValueCollector collector) {\n+        read(path, (Consumer) collector::addObject);\n+    }\n+\n+    private void read(String path, Consumer consumer) {\n+        try {\n+            Object result = read(path);\n+            if (result instanceof MultiResult) {\n+                MultiResult multiResult = (MultiResult) result;\n+                for (Object singleResult : multiResult.getResults()) {\n+                    consumer.accept(singleResult);\n+                }\n+            } else {\n+                consumer.accept(result);\n+            }\n+        } catch (IOException e) {\n+            throw new ValueReadingException(e.getMessage(), e);\n+        } catch (RuntimeException e) {\n+            throw new ValueReadingException(e.getMessage(), e);\n+        }\n+    }\n+\n+    public Object read(String fieldPath) throws IOException {\n+        if (fieldPath == null) {\n+            throw new IllegalArgumentException(\"field path can not be null\");\n+        }\n+        if (fieldPath.endsWith(\".\")) {\n+            throw new IllegalArgumentException(\"Malformed path \" + fieldPath);\n+        }\n+\n+        if (rootRecord.hasField(fieldPath)) {\n+            return readLeaf(rootRecord, fieldPath);\n+        }\n+\n+        LinkedList<Object> results = new LinkedList<>();\n+        results.add(rootRecord);\n+        MultiResult<Object> multiResult = new MultiResult<>(results);\n+\n+        int begin = 0;\n+        int end = StringUtil.indexOf(fieldPath, '.');\n+        //handle the paths except leaf\n+        while (end != -1) {\n+            String path = fieldPath.substring(begin, end);\n+            begin = end + 1;\n+            end = StringUtil.indexOf(fieldPath, '.', begin);\n+\n+            if (path.length() == 0) {", "originalCommit": "067fbf3a3c395e943ae498f597a0e6c5b7ef184b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMTk3NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r475511975", "bodyText": "if T is GenericRecord and readObjectFromArray returns portable T, is this possible?", "author": "ihsandemir", "createdAt": "2020-08-24T10:42:47Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/GenericRecordQueryReader.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.serialization.impl;\n+\n+import com.hazelcast.internal.serialization.impl.portable.PortableInternalGenericRecord;\n+import com.hazelcast.internal.util.StringUtil;\n+import com.hazelcast.nio.serialization.FieldType;\n+import com.hazelcast.nio.serialization.GenericRecord;\n+import com.hazelcast.query.extractor.ValueCallback;\n+import com.hazelcast.query.extractor.ValueCollector;\n+import com.hazelcast.query.extractor.ValueReader;\n+import com.hazelcast.query.extractor.ValueReadingException;\n+import com.hazelcast.query.impl.getters.ExtractorHelper;\n+import com.hazelcast.query.impl.getters.MultiResult;\n+\n+import java.io.IOException;\n+import java.util.LinkedList;\n+import java.util.ListIterator;\n+import java.util.function.Consumer;\n+\n+import static com.hazelcast.query.impl.getters.ExtractorHelper.extractArgumentsFromAttributeName;\n+import static com.hazelcast.query.impl.getters.ExtractorHelper.extractAttributeNameNameWithoutArguments;\n+\n+/**\n+ * Reads a field or array of fields from a `InternalGenericRecord` according to given query `path`\n+ *\n+ * @see InternalGenericRecord\n+ * Any format that exposes an `InternalGenericRecord` will benefit from hazelcast query.\n+ * @see PortableInternalGenericRecord for Portable InternalGenericRecord\n+ * <p>\n+ * Example queries\n+ * \"age\"\n+ * \"engine.power\"\n+ * \"child[0].age\"\n+ * \"engine.wheel[0].pressure\"\n+ * \"engine.wheel[any].pressure\"\n+ * \"top500Companies[0].ceo\"\n+ * \"company.employees[any]\"\n+ * \"limbs[*].fingers\"\n+ * <p>\n+ * It also implements ValueReader to support reading into `ValueCallback` and `ValueCollector`\n+ */\n+public final class GenericRecordQueryReader implements ValueReader {\n+\n+    private final InternalGenericRecord rootRecord;\n+\n+    public GenericRecordQueryReader(InternalGenericRecord rootRecord) {\n+        this.rootRecord = rootRecord;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void read(String path, ValueCallback callback) {\n+        read(path, (ValueCollector) callback::onResult);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void read(String path, ValueCollector collector) {\n+        read(path, (Consumer) collector::addObject);\n+    }\n+\n+    private void read(String path, Consumer consumer) {\n+        try {\n+            Object result = read(path);\n+            if (result instanceof MultiResult) {\n+                MultiResult multiResult = (MultiResult) result;\n+                for (Object singleResult : multiResult.getResults()) {\n+                    consumer.accept(singleResult);\n+                }\n+            } else {\n+                consumer.accept(result);\n+            }\n+        } catch (IOException e) {\n+            throw new ValueReadingException(e.getMessage(), e);\n+        } catch (RuntimeException e) {\n+            throw new ValueReadingException(e.getMessage(), e);\n+        }\n+    }\n+\n+    public Object read(String fieldPath) throws IOException {\n+        if (fieldPath == null) {\n+            throw new IllegalArgumentException(\"field path can not be null\");\n+        }\n+        if (fieldPath.endsWith(\".\")) {\n+            throw new IllegalArgumentException(\"Malformed path \" + fieldPath);\n+        }\n+\n+        if (rootRecord.hasField(fieldPath)) {\n+            return readLeaf(rootRecord, fieldPath);\n+        }\n+\n+        LinkedList<Object> results = new LinkedList<>();\n+        results.add(rootRecord);\n+        MultiResult<Object> multiResult = new MultiResult<>(results);\n+\n+        int begin = 0;\n+        int end = StringUtil.indexOf(fieldPath, '.');\n+        //handle the paths except leaf\n+        while (end != -1) {\n+            String path = fieldPath.substring(begin, end);\n+            begin = end + 1;\n+            end = StringUtil.indexOf(fieldPath, '.', begin);\n+\n+            if (path.length() == 0) {\n+                throw new IllegalArgumentException(\"The token's length cannot be zero: \" + fieldPath);\n+            }\n+\n+            ListIterator<Object> iterator = results.listIterator();\n+            String fieldName = extractAttributeNameNameWithoutArguments(path);\n+            if (!path.contains(\"]\")) {\n+                // ex: attribute\n+                while (iterator.hasNext()) {\n+                    InternalGenericRecord record = (InternalGenericRecord) iterator.next();\n+                    if (!record.hasField(fieldName)) {\n+                        iterator.remove();\n+                        multiResult.setNullOrEmptyTarget(true);\n+                        continue;\n+                    }\n+                    InternalGenericRecord subGenericRecord = (InternalGenericRecord) record.readGenericRecord(fieldName);\n+                    if (subGenericRecord == null) {\n+                        iterator.remove();\n+                        multiResult.setNullOrEmptyTarget(true);\n+                        continue;\n+                    }\n+                    iterator.set(subGenericRecord);\n+                }\n+            } else if (path.endsWith(\"[any]\")) {\n+                // ex: attribute any\n+                while (iterator.hasNext()) {\n+                    InternalGenericRecord record = (InternalGenericRecord) iterator.next();\n+                    iterator.remove();\n+                    if (!record.hasField(fieldName)) {\n+                        multiResult.setNullOrEmptyTarget(true);\n+                        continue;\n+                    }\n+                    GenericRecord[] genericRecords = record.readGenericRecordArray(fieldName);\n+                    if (genericRecords == null || genericRecords.length == 0) {\n+                        multiResult.setNullOrEmptyTarget(true);\n+                        continue;\n+                    }\n+                    for (GenericRecord genericRecord : genericRecords) {\n+                        if (genericRecord != null) {\n+                            iterator.add(genericRecord);\n+                        } else {\n+                            multiResult.setNullOrEmptyTarget(true);\n+                        }\n+                    }\n+                }\n+            } else {\n+                // ex: attribute[2]\n+                int index = Integer.parseInt(extractArgumentsFromAttributeName(path));\n+                while (iterator.hasNext()) {\n+                    InternalGenericRecord record = (InternalGenericRecord) iterator.next();\n+                    if (!record.hasField(fieldName)) {\n+                        iterator.remove();\n+                        multiResult.setNullOrEmptyTarget(true);\n+                        continue;\n+                    }\n+                    GenericRecord genericRecord = record.readGenericRecordFromArray(fieldName, index);\n+                    if (genericRecord != null) {\n+                        iterator.set(genericRecord);\n+                    } else {\n+                        iterator.remove();\n+                        multiResult.setNullOrEmptyTarget(true);\n+                    }\n+                }\n+            }\n+        }\n+\n+        //last loop that we have skipped\n+        String path = fieldPath.substring(begin);\n+        if (path.length() == 0) {\n+            throw new IllegalArgumentException(\"The token's length cannot be zero: \" + fieldPath);\n+        }\n+\n+        ListIterator<Object> iterator = results.listIterator();\n+        String fieldName = extractAttributeNameNameWithoutArguments(path);\n+        if (!path.contains(\"]\")) {\n+            // ex: attribute\n+            while (iterator.hasNext()) {\n+                InternalGenericRecord record = (InternalGenericRecord) iterator.next();\n+                Object leaf = readLeaf(record, fieldName);\n+                iterator.set(leaf);\n+            }\n+        } else if (path.endsWith(\"[any]\")) {\n+            // ex: attribute any\n+            while (iterator.hasNext()) {\n+                InternalGenericRecord record = (InternalGenericRecord) iterator.next();\n+                iterator.remove();\n+                Object leaves = readLeaf(record, fieldName);\n+                if (leaves == null) {\n+                    multiResult.setNullOrEmptyTarget(true);\n+                } else if (leaves instanceof Object[]) {\n+                    Object[] array = (Object[]) leaves;\n+                    if (array.length == 0) {\n+                        multiResult.setNullOrEmptyTarget(true);\n+                        continue;\n+                    }\n+                    for (Object leaf : array) {\n+                        iterator.add(leaf);\n+                    }\n+                } else {\n+                    assert leaves.getClass().isArray() : \"parameter is not an array\";\n+                    if (!ExtractorHelper.reducePrimitiveArrayInto(iterator::add, leaves)) {\n+                        multiResult.setNullOrEmptyTarget(true);\n+                    }\n+                }\n+            }\n+        } else {\n+            // ex: attribute[2]\n+            int index = Integer.parseInt(extractArgumentsFromAttributeName(path));\n+            while (iterator.hasNext()) {\n+                GenericRecord record = (GenericRecord) iterator.next();\n+                Object leaf = readIndexed((InternalGenericRecord) record, fieldName, index);\n+                iterator.set(leaf);\n+            }\n+        }\n+\n+        if (multiResult.isNullEmptyTarget()) {\n+            results.addFirst(null);\n+        } else if (results.size() == 1) {\n+            return results.get(0);\n+        }\n+        return multiResult;\n+    }\n+\n+    private <T> T readIndexed(InternalGenericRecord record, String path, int index) throws IOException {\n+        if (!record.hasField(path)) {\n+            return null;\n+        }\n+        FieldType type = record.getFieldType(path);\n+        switch (type) {\n+            case BYTE_ARRAY:\n+                return (T) record.readByteFromArray(path, index);\n+            case SHORT_ARRAY:\n+                return (T) record.readShortFromArray(path, index);\n+            case INT_ARRAY:\n+                return (T) record.readIntFromArray(path, index);\n+            case LONG_ARRAY:\n+                return (T) record.readLongFromArray(path, index);\n+            case FLOAT_ARRAY:\n+                return (T) record.readFloatFromArray(path, index);\n+            case DOUBLE_ARRAY:\n+                return (T) record.readDoubleFromArray(path, index);\n+            case BOOLEAN_ARRAY:\n+                return (T) record.readBooleanFromArray(path, index);\n+            case CHAR_ARRAY:\n+                return (T) record.readCharFromArray(path, index);\n+            case UTF_ARRAY:\n+                return (T) record.readUTFFromArray(path, index);\n+            case PORTABLE_ARRAY:\n+                return (T) record.readObjectFromArray(path, index);", "originalCommit": "067fbf3a3c395e943ae498f597a0e6c5b7ef184b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzNjEwNA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r475836104", "bodyText": "In readLeaf and readIndexed T can never be generic record. Having said that, Generics does not seem useful here at all because I am always assigning to Object. I will replace Generics with Object.", "author": "sancar", "createdAt": "2020-08-24T19:12:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMTk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMjY3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r475512670", "bodyText": "why not put this inside PortableContextImpl? it seems logically related.", "author": "ihsandemir", "createdAt": "2020-08-24T10:44:13Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/SerializationServiceV1.java", "diffHunk": "@@ -134,17 +133,19 @@\n \n     private final PortableContextImpl portableContext;\n     private final PortableSerializer portableSerializer;\n+    private final boolean checkClassDefErrors;\n \n     SerializationServiceV1(AbstractBuilder<?> builder) {\n         super(builder);\n+        checkClassDefErrors = builder.checkClassDefErrors;", "originalCommit": "067fbf3a3c395e943ae498f597a0e6c5b7ef184b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTg0MTYyOA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r475841628", "bodyText": "I could not really follow what you mean. I have checked again and it does not seem straight forward to remove this from registerClassDefinition. Leaving it as-is for now.", "author": "sancar", "createdAt": "2020-08-24T19:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMjY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIzNzU5NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r476237595", "bodyText": "I am not saying to remove, i mean make checkClassDefErrors a member of PortableContextImpl and carry this info with the context.", "author": "ihsandemir", "createdAt": "2020-08-25T07:33:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMjY3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI0OTEyMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r476249121", "bodyText": "Done", "author": "sancar", "createdAt": "2020-08-25T07:53:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUxMjY3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4MjI0Mw==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r475582243", "bodyText": "why did you prevent overwriting multiple times if it is a clone?", "author": "ihsandemir", "createdAt": "2020-08-24T12:59:46Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/serialization/impl/portable/PortableGenericRecordBuilder.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.serialization.impl.portable;\n+\n+import com.hazelcast.nio.serialization.ClassDefinition;\n+import com.hazelcast.nio.serialization.FieldDefinition;\n+import com.hazelcast.nio.serialization.FieldType;\n+import com.hazelcast.nio.serialization.GenericRecord;\n+import com.hazelcast.nio.serialization.HazelcastSerializationException;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+public class PortableGenericRecordBuilder implements GenericRecord.Builder {\n+\n+    private final ClassDefinition classDefinition;\n+    private final Object[] objects;\n+    private final boolean[] isOverWritten;\n+    private final boolean isClone;\n+\n+    public PortableGenericRecordBuilder(ClassDefinition classDefinition) {\n+        this.classDefinition = classDefinition;\n+        this.objects = new Object[classDefinition.getFieldCount()];\n+        this.isClone = false;\n+        this.isOverWritten = null;\n+    }\n+\n+    PortableGenericRecordBuilder(ClassDefinition classDefinition, Object[] objects) {\n+        this.classDefinition = classDefinition;\n+        this.objects = objects;\n+        this.isClone = true;\n+        this.isOverWritten = new boolean[objects.length];\n+    }\n+\n+    @Override\n+    public GenericRecord build() {\n+        return new PortableGenericRecord(classDefinition, objects);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeInt(String fieldName, int value) {\n+        return write(fieldName, value, FieldType.INT);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeLong(String fieldName, long value) {\n+        return write(fieldName, value, FieldType.LONG);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeUTF(String fieldName, String value) {\n+        return write(fieldName, value, FieldType.UTF);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeBoolean(String fieldName, boolean value) {\n+        return write(fieldName, value, FieldType.BOOLEAN);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeByte(String fieldName, byte value) {\n+        return write(fieldName, value, FieldType.BYTE);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeChar(String fieldName, char value) {\n+        return write(fieldName, value, FieldType.CHAR);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeDouble(String fieldName, double value) {\n+        return write(fieldName, value, FieldType.DOUBLE);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeFloat(String fieldName, float value) {\n+        return write(fieldName, value, FieldType.FLOAT);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeShort(String fieldName, short value) {\n+        return write(fieldName, value, FieldType.SHORT);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeGenericRecord(String fieldName, @Nullable GenericRecord value) {\n+        return write(fieldName, value, FieldType.PORTABLE);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeGenericRecordArray(String fieldName, GenericRecord[] value) {\n+        return write(fieldName, value, FieldType.PORTABLE_ARRAY);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeByteArray(String fieldName, byte[] value) {\n+        return write(fieldName, value, FieldType.BYTE_ARRAY);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeBooleanArray(String fieldName, boolean[] value) {\n+        return write(fieldName, value, FieldType.BOOLEAN_ARRAY);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeCharArray(String fieldName, char[] value) {\n+        return write(fieldName, value, FieldType.CHAR_ARRAY);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeIntArray(String fieldName, int[] value) {\n+        return write(fieldName, value, FieldType.INT_ARRAY);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeLongArray(String fieldName, long[] value) {\n+        return write(fieldName, value, FieldType.LONG_ARRAY);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeDoubleArray(String fieldName, double[] value) {\n+        return write(fieldName, value, FieldType.DOUBLE_ARRAY);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeFloatArray(String fieldName, float[] value) {\n+        return write(fieldName, value, FieldType.FLOAT_ARRAY);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeShortArray(String fieldName, short[] value) {\n+        return write(fieldName, value, FieldType.SHORT_ARRAY);\n+    }\n+\n+    @Override\n+    public GenericRecord.Builder writeUTFArray(String fieldName, String[] value) {\n+        return write(fieldName, value, FieldType.UTF_ARRAY);\n+    }\n+\n+    private GenericRecord.Builder write(String fieldName, Object value, FieldType fieldType) {\n+        FieldDefinition fd = check(fieldName, fieldType);\n+        int index = fd.getIndex();\n+        if (objects[index] != null) {\n+            if (!isClone) {\n+                throw new HazelcastSerializationException(\"It is illegal to the overwrite the field\");\n+            } else if (isOverWritten[index]) {\n+                throw new HazelcastSerializationException(\"Field can only overwritten once with `cloneWithBuilder`\");", "originalCommit": "067fbf3a3c395e943ae498f597a0e6c5b7ef184b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY2NjgyNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r475666827", "bodyText": "Because it will be written directly to the byte-array in the new format. And if I allow that, it might be complex to implement.", "author": "sancar", "createdAt": "2020-08-24T14:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4MjI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjIzODc0NA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r476238744", "bodyText": "yes, it will be written into byte-array eventually but here you only keep an array of objects, hence it should not harm to overwrite the object at the same index until you really serialize into byte array, right?", "author": "ihsandemir", "createdAt": "2020-08-25T07:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4MjI0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI0NjAwMQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r476246001", "bodyText": "I am thinking about the new format and there we will write to the byte-array early in order not to create temporary lists/maps. And note that the contract comes from the interface. The behaviour does not just belong to PortableGenericRecordBuilder . It is the contract of the Builder", "author": "sancar", "createdAt": "2020-08-25T07:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4MjI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwNjk1OA==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r475606958", "bodyText": "test name misleading, the GetInt return Integer?", "author": "ihsandemir", "createdAt": "2020-08-24T13:38:24Z", "path": "hazelcast/src/test/java/com/hazelcast/genericrecord/AbstractGenericRecordTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.genericrecord;\n+\n+import com.hazelcast.config.SerializationConfig;\n+import com.hazelcast.core.HazelcastInstance;\n+import com.hazelcast.core.HazelcastInstanceAware;\n+import com.hazelcast.core.IExecutorService;\n+import com.hazelcast.internal.serialization.impl.TestSerializationConstants;\n+import com.hazelcast.internal.serialization.impl.portable.InnerPortable;\n+import com.hazelcast.internal.serialization.impl.portable.MainPortable;\n+import com.hazelcast.internal.serialization.impl.portable.NamedPortable;\n+import com.hazelcast.internal.serialization.impl.portable.PortableTest;\n+import com.hazelcast.map.EntryProcessor;\n+import com.hazelcast.map.IMap;\n+import com.hazelcast.nio.serialization.ClassDefinition;\n+import com.hazelcast.nio.serialization.ClassDefinitionBuilder;\n+import com.hazelcast.nio.serialization.GenericRecord;\n+import com.hazelcast.nio.serialization.HazelcastSerializationException;\n+import com.hazelcast.test.HazelcastTestSupport;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Future;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public abstract class AbstractGenericRecordTest extends HazelcastTestSupport {\n+\n+    private final SerializationConfig serializationConfig = new SerializationConfig()\n+            .addPortableFactory(PortableTest.PORTABLE_FACTORY_ID, new PortableTest.TestPortableFactory());\n+\n+    /**\n+     * @return instance(client / member) with given serialization config\n+     */\n+    protected abstract HazelcastInstance createAccessorInstance(SerializationConfig serializationConfig);\n+\n+    /**\n+     * @return cluster without any Portable Factory Config\n+     */\n+    protected abstract HazelcastInstance[] createCluster();\n+\n+    @Test\n+    public void testPutWithoutFactory_readAsPortable() throws IOException {\n+\n+        NamedPortable[] nn = new NamedPortable[2];\n+        nn[0] = new NamedPortable(\"name\", 123);\n+        nn[1] = new NamedPortable(\"name\", 123);\n+        InnerPortable inner = new InnerPortable(new byte[]{0, 1, 2}, new char[]{'c', 'h', 'a', 'r'},\n+                new short[]{3, 4, 5}, new int[]{9, 8, 7, 6}, new long[]{0, 1, 5, 7, 9, 11},\n+                new float[]{0.6543f, -3.56f, 45.67f}, new double[]{456.456, 789.789, 321.321}, nn);\n+\n+        MainPortable expectedMain = new MainPortable((byte) 113, true, 'x', (short) -500, 56789, -50992225L, 900.5678f,\n+                -897543.3678909d, \"this is main portable object created for testing!\", inner);\n+\n+        HazelcastInstance[] instances = createCluster();\n+        ClassDefinition namedPortableClassDefinition =\n+                new ClassDefinitionBuilder(TestSerializationConstants.PORTABLE_FACTORY_ID, TestSerializationConstants.NAMED_PORTABLE)\n+                        .addUTFField(\"name\").addIntField(\"myint\").build();\n+        ClassDefinition innerPortableClassDefinition =\n+                new ClassDefinitionBuilder(TestSerializationConstants.PORTABLE_FACTORY_ID, TestSerializationConstants.INNER_PORTABLE)\n+                        .addByteArrayField(\"b\")\n+                        .addCharArrayField(\"c\")\n+                        .addShortArrayField(\"s\")\n+                        .addIntArrayField(\"i\")\n+                        .addLongArrayField(\"l\")\n+                        .addFloatArrayField(\"f\")\n+                        .addDoubleArrayField(\"d\")\n+                        .addPortableArrayField(\"nn\", namedPortableClassDefinition).build();\n+        ClassDefinition mainPortableClassDefinition =\n+                new ClassDefinitionBuilder(PortableTest.PORTABLE_FACTORY_ID, TestSerializationConstants.MAIN_PORTABLE)\n+                        .addByteField(\"b\")\n+                        .addBooleanField(\"bool\")\n+                        .addCharField(\"c\")\n+                        .addShortField(\"s\")\n+                        .addIntField(\"i\")\n+                        .addLongField(\"l\")\n+                        .addFloatField(\"f\")\n+                        .addDoubleField(\"d\")\n+                        .addUTFField(\"str\")\n+                        .addPortableField(\"p\", innerPortableClassDefinition)\n+                        .build();\n+\n+        GenericRecord namedRecord = GenericRecord.Builder.portable(namedPortableClassDefinition)\n+                .writeUTF(\"name\", nn[0].name)\n+                .writeInt(\"myint\", nn[0].myint).build();\n+        GenericRecord[] namedRecords = new GenericRecord[2];\n+        namedRecords[0] = namedRecord;\n+        namedRecords[1] = namedRecord;\n+\n+        GenericRecord innerRecord = GenericRecord.Builder.portable(innerPortableClassDefinition)\n+                .writeByteArray(\"b\", inner.bb)\n+                .writeCharArray(\"c\", inner.cc)\n+                .writeShortArray(\"s\", inner.ss)\n+                .writeIntArray(\"i\", inner.ii)\n+                .writeLongArray(\"l\", inner.ll)\n+                .writeFloatArray(\"f\", inner.ff)\n+                .writeDoubleArray(\"d\", inner.dd)\n+                .writeGenericRecordArray(\"nn\", namedRecords).build();\n+\n+        GenericRecord expected = GenericRecord.Builder.portable(mainPortableClassDefinition)\n+                .writeByte(\"b\", expectedMain.b)\n+                .writeBoolean(\"bool\", expectedMain.bool)\n+                .writeChar(\"c\", expectedMain.c)\n+                .writeShort(\"s\", expectedMain.s)\n+                .writeInt(\"i\", expectedMain.i)\n+                .writeLong(\"l\", expectedMain.l)\n+                .writeFloat(\"f\", expectedMain.f)\n+                .writeDouble(\"d\", expectedMain.d)\n+                .writeUTF(\"str\", expectedMain.str)\n+                .writeGenericRecord(\"p\", innerRecord)\n+                .build();\n+\n+        assertEquals(expectedMain.c, expected.readChar(\"c\"));\n+        assertEquals(expectedMain.f, expected.readFloat(\"f\"), 0.1);\n+\n+        IMap<Object, Object> clusterMap = instances[0].getMap(\"test\");\n+        clusterMap.put(1, expected);\n+\n+        HazelcastInstance instance = createAccessorInstance(serializationConfig);\n+        IMap<Object, Object> map = instance.getMap(\"test\");\n+\n+        MainPortable actual = (MainPortable) map.get(1);\n+\n+        assertEquals(expectedMain, actual);\n+    }\n+\n+    @Test\n+    public void testPutGenericRecordBack() throws IOException {\n+\n+        HazelcastInstance[] instances = createCluster();\n+\n+        HazelcastInstance instance = createAccessorInstance(serializationConfig);\n+        IMap<Object, Object> map = instance.getMap(\"test\");\n+        NamedPortable expected = new NamedPortable(\"foo\", 900);\n+        map.put(1, expected);\n+\n+        IMap<Object, Object> clusterMap = instances[0].getMap(\"test\");\n+        GenericRecord record = (GenericRecord) clusterMap.get(1);\n+\n+        clusterMap.put(2, record);\n+\n+        //read from the cluster without serialization config\n+        GenericRecord actualRecord = (GenericRecord) clusterMap.get(2);\n+\n+        assertTrue(actualRecord.hasField(\"name\"));\n+        assertTrue(actualRecord.hasField(\"myint\"));\n+\n+        assertEquals(expected.name, actualRecord.readUTF(\"name\"));\n+        assertEquals(expected.myint, actualRecord.readInt(\"myint\"));\n+\n+\n+        //read from the instance with serialization config\n+        NamedPortable actualPortable = (NamedPortable) map.get(2);\n+        assertEquals(expected, actualPortable);\n+    }\n+\n+    @Test\n+    public void testReadReturnsGenericRecord() throws IOException {\n+\n+        HazelcastInstance[] instances = createCluster();\n+\n+        HazelcastInstance instance = createAccessorInstance(serializationConfig);\n+        IMap<Object, Object> map = instance.getMap(\"test\");\n+        NamedPortable expected = new NamedPortable(\"foo\", 900);\n+        map.put(1, expected);\n+\n+        IMap<Object, Object> clusterMap = instances[0].getMap(\"test\");\n+        GenericRecord actual = (GenericRecord) clusterMap.get(1);\n+\n+        assertTrue(actual.hasField(\"name\"));\n+        assertTrue(actual.hasField(\"myint\"));\n+\n+        assertEquals(expected.name, actual.readUTF(\"name\"));\n+        assertEquals(expected.myint, actual.readInt(\"myint\"));\n+    }\n+\n+    @Test\n+    public void testEntryProcessorReturnsGenericRecord() throws IOException {\n+\n+        HazelcastInstance[] instances = createCluster();\n+\n+        HazelcastInstance instance = createAccessorInstance(serializationConfig);\n+        IMap<Object, Object> map = instance.getMap(\"test\");\n+        NamedPortable expected = new NamedPortable(\"foo\", 900);\n+\n+        String key = generateKeyOwnedBy(instances[0]);\n+        map.put(key, expected);\n+        Object returnValue = map.executeOnKey(key, (EntryProcessor<Object, Object, Object>) entry -> {\n+            Object value = entry.getValue();\n+            GenericRecord genericRecord = (GenericRecord) value;\n+\n+            GenericRecord modifiedGenericRecord = genericRecord.newBuilder()\n+                    .writeUTF(\"name\", \"bar\")\n+                    .writeInt(\"myint\", 4).build();\n+\n+            entry.setValue(modifiedGenericRecord);\n+\n+            return genericRecord.readInt(\"myint\");\n+        });\n+        assertEquals(expected.myint, returnValue);\n+\n+        NamedPortable actualPortable = (NamedPortable) map.get(key);\n+        assertEquals(\"bar\", actualPortable.name);\n+        assertEquals(4, actualPortable.myint);\n+    }\n+\n+    @Test\n+    public void testCloneWithGenericBuilderOnEntryProcessor() throws IOException {\n+\n+        HazelcastInstance[] instances = createCluster();\n+\n+        HazelcastInstance instance = createAccessorInstance(serializationConfig);\n+        IMap<Object, Object> map = instance.getMap(\"test\");\n+        NamedPortable expected = new NamedPortable(\"foo\", 900);\n+\n+        String key = generateKeyOwnedBy(instances[0]);\n+        map.put(key, expected);\n+        Object returnValue = map.executeOnKey(key, (EntryProcessor<Object, Object, Object>) entry -> {\n+            Object value = entry.getValue();\n+            GenericRecord genericRecord = (GenericRecord) value;\n+\n+            GenericRecord modifiedGenericRecord = genericRecord.cloneWithBuilder()\n+                    .writeInt(\"myint\", 4).build();\n+\n+            entry.setValue(modifiedGenericRecord);\n+\n+            return genericRecord.readInt(\"myint\");\n+        });\n+        assertEquals(expected.myint, returnValue);\n+\n+        NamedPortable actualPortable = (NamedPortable) map.get(key);\n+        assertEquals(\"foo\", actualPortable.name);\n+        assertEquals(4, actualPortable.myint);\n+    }\n+\n+    private static class GetInt implements Callable<Integer>, HazelcastInstanceAware, Serializable {\n+\n+        volatile HazelcastInstance instance;\n+\n+        @Override\n+        public void setHazelcastInstance(HazelcastInstance hazelcastInstance) {\n+            instance = hazelcastInstance;\n+        }\n+\n+        @Override\n+        public Integer call() throws Exception {\n+            IMap<Object, Object> map = instance.getMap(\"test\");\n+            GenericRecord genericRecord = (GenericRecord) map.get(1);\n+            return genericRecord.readInt(\"myint\");\n+        }\n+    }\n+\n+    @Test\n+    public void testRemoteLogicReturnsGenericRecord() throws Exception {", "originalCommit": "067fbf3a3c395e943ae498f597a0e6c5b7ef184b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgzODYxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17105#discussion_r475838617", "bodyText": "The test is actually testing the GenericRecord is passed to GetInt when it calls map.get. Renaming it to testGenericRecordIsReturnedInRemoteLogic", "author": "sancar", "createdAt": "2020-08-24T19:17:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTYwNjk1OA=="}], "type": "inlineReview"}, {"oid": "0609e029a1de12a1e30632dd7d04266c85f8d49a", "url": "https://github.com/hazelcast/hazelcast/commit/0609e029a1de12a1e30632dd7d04266c85f8d49a", "message": "addressed review comments  take 3", "committedDate": "2020-08-24T19:25:44Z", "type": "commit"}, {"oid": "c2dcd273a1c5d1a8732b67c90c577f1156d1a4d4", "url": "https://github.com/hazelcast/hazelcast/commit/c2dcd273a1c5d1a8732b67c90c577f1156d1a4d4", "message": "addressed review comments  take 4", "committedDate": "2020-08-25T07:56:12Z", "type": "commit"}, {"oid": "661370a574f95239f1ae69da71afa04eb79d2c25", "url": "https://github.com/hazelcast/hazelcast/commit/661370a574f95239f1ae69da71afa04eb79d2c25", "message": "adding Beta to GenericRecord and Builder interfaces", "committedDate": "2020-08-25T08:29:47Z", "type": "commit"}]}