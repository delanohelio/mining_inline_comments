{"pr_number": 17559, "pr_title": "State tracking for configuration overrides", "pr_createdAt": "2020-09-16T20:33:33Z", "pr_url": "https://github.com/hazelcast/hazelcast/pull/17559", "timeline": [{"oid": "c601f6a9c539ce9d243c948df1ea77960f61bc84", "url": "https://github.com/hazelcast/hazelcast/commit/c601f6a9c539ce9d243c948df1ea77960f61bc84", "message": "State tracking for configuration overrides", "committedDate": "2020-09-17T09:17:01Z", "type": "commit"}, {"oid": "c601f6a9c539ce9d243c948df1ea77960f61bc84", "url": "https://github.com/hazelcast/hazelcast/commit/c601f6a9c539ce9d243c948df1ea77960f61bc84", "message": "State tracking for configuration overrides", "committedDate": "2020-09-17T09:17:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1MzMwMw==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r490153303", "bodyText": "I guess here's this \"eager\" change you mentioned in the description. Why is it better to read it lazily here?", "author": "leszko", "createdAt": "2020-09-17T10:57:30Z", "path": "hazelcast/src/main/java/com/hazelcast/client/config/impl/AbstractQueryCacheConfigBuilderHelper.java", "diffHunk": "@@ -60,32 +60,29 @@ protected String getTextContent(Node node) {\n     }\n \n     protected void populateQueryCacheConfig(QueryCacheConfig queryCacheConfig,\n-                                            Node childNode, String textContent, String nodeName) {\n+                                            Node childNode, String nodeName) {", "originalCommit": "c601f6a9c539ce9d243c948df1ea77960f61bc84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE4OTkwNQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r490189905", "bodyText": "Here, it's just actually to simplify things. There's no point in passing both Node and the content because the content is in the Node.\nWhen it comes to eager, it just means we should not fetch the value when we're not sure it's needed. And in many places, we'd fetch the value first, and only then check if they key matches some of the existing config properties. So laziness is implemented just by moving the extraction of textContent into if blocks", "author": "pivovarit", "createdAt": "2020-09-17T12:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1MzMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1NDc5MQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r490154791", "bodyText": "Isn't the .trim() executed already in getTextContent() method?", "author": "leszko", "createdAt": "2020-09-17T11:00:19Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/config/MemberDomConfigProcessor.java", "diffHunk": "@@ -1736,21 +1707,20 @@ protected void handleMap(Node parentNode) throws Exception {\n     void handleMapNode(Node parentNode, final MapConfig mapConfig) throws Exception {\n         for (Node node : childElements(parentNode)) {\n             String nodeName = cleanNodeName(node);\n-            String value = getTextContent(node).trim();\n             if (matches(\"backup-count\", nodeName)) {\n-                mapConfig.setBackupCount(getIntegerValue(\"backup-count\", value));\n+                mapConfig.setBackupCount(getIntegerValue(\"backup-count\", getTextContent(node).trim()));\n             } else if (matches(\"metadata-policy\", nodeName)) {\n-                mapConfig.setMetadataPolicy(MetadataPolicy.valueOf(upperCaseInternal(value)));\n+                mapConfig.setMetadataPolicy(MetadataPolicy.valueOf(upperCaseInternal(getTextContent(node).trim())));", "originalCommit": "c601f6a9c539ce9d243c948df1ea77960f61bc84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5MDI0Mg==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r490190242", "bodyText": "Yeah, it's a leftover. Will remove now", "author": "pivovarit", "createdAt": "2020-09-17T12:05:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1NDc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1NTkxNw==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r490155917", "bodyText": "nit: maybe the opposite isRead?", "author": "leszko", "createdAt": "2020-09-17T11:02:31Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/config/override/ConfigNode.java", "diffHunk": "@@ -31,6 +31,7 @@\n     private final String name;\n     private final Map<String, ConfigNode> children = new LinkedHashMap<>();\n     private String value;\n+    private boolean unread = true;", "originalCommit": "c601f6a9c539ce9d243c948df1ea77960f61bc84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE5MDUxMg==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r490190512", "bodyText": "I don't really care. Will switch \ud83d\udc4d", "author": "pivovarit", "createdAt": "2020-09-17T12:05:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE1NTkxNw=="}], "type": "inlineReview"}, {"oid": "dad4416820edf259579aab753e01e05db1ebd869", "url": "https://github.com/hazelcast/hazelcast/commit/dad4416820edf259579aab753e01e05db1ebd869", "message": "Remove redundant .trim() calls and invert 'unread' ConfigNode property", "committedDate": "2020-09-17T12:36:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MTAwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r498081006", "bodyText": "In the edge case when properties.size() == unprocessed.size() I'd consider logging at WARN with a specific message saying that there are override properties defined, but we did not apply any of them.", "author": "blazember", "createdAt": "2020-10-01T08:44:15Z", "path": "hazelcast/src/main/java/com/hazelcast/internal/config/override/ExternalConfigurationOverride.java", "diffHunk": "@@ -41,47 +40,64 @@\n     private static final ILogger LOGGER = Logger.getLogger(ExternalConfigurationOverride.class);\n \n     public Config overwriteMemberConfig(Config config) {\n-        return overwrite(config, (provider, c) -> {\n+        return overwrite(config, (provider, rootNode, target) -> {\n               try {\n-                  new YamlMemberDomConfigProcessor(true, c, false)\n-                    .buildConfig(new ConfigOverrideElementAdapter(propsToNode(provider.properties())));\n+                  new YamlMemberDomConfigProcessor(true, target, false)\n+                    .buildConfig(new ConfigOverrideElementAdapter(rootNode));\n               } catch (Exception e) {\n-                  throw new InvalidConfigurationException(\"failed to overwrite configuration coming from \" + provider.name(), e);\n+                  throw new InvalidConfigurationException(\"failed to overwrite configuration coming from \" + provider, e);\n               }\n           },\n           new EnvConfigProvider(EnvVariablesConfigParser.member()),\n           new SystemPropertiesConfigProvider(SystemPropertiesConfigParser.member()));\n     }\n \n     public ClientConfig overwriteClientConfig(ClientConfig config) {\n-        return overwrite(config, (provider, c) -> {\n+        return overwrite(config, (provider, rootNode, target) -> {\n               try {\n-                  new YamlClientDomConfigProcessor(true, c, false)\n-                    .buildConfig(new ConfigOverrideElementAdapter(propsToNode(provider.properties())));\n+                  new YamlClientDomConfigProcessor(true, target, false)\n+                    .buildConfig(new ConfigOverrideElementAdapter(rootNode));\n               } catch (Exception e) {\n-                  throw new InvalidConfigurationException(\"failed to overwrite configuration coming from \" + provider.name(), e);\n+                  throw new InvalidConfigurationException(\"failed to overwrite configuration coming from \" + provider, e);\n               }\n           },\n           new EnvConfigProvider(EnvVariablesConfigParser.client()),\n           new SystemPropertiesConfigProvider(SystemPropertiesConfigParser.client()));\n     }\n \n-    private <T> T overwrite(T config, BiConsumer<ConfigProvider, T> configProcessor, ConfigProvider... providers) {\n+    private <T> T overwrite(T config, ConfigConsumer<T> configProcessor, ConfigProvider... providers) {\n         ConfigOverrideValidator.validate(new HashSet<>(Arrays.asList(providers)));\n \n         for (ConfigProvider configProvider : providers) {\n             Map<String, String> properties = configProvider.properties();\n \n             if (!properties.isEmpty()) {\n-                LOGGER.info(format(\"Detected external configuration overrides in %s: [%s]\",\n+\n+                ConfigNode rootNode = propsToNode(properties);\n+                configProcessor.apply(configProvider.name(), rootNode, config);\n+\n+                Map<String, String> unprocessed = new ConfigNodeStateTracker().unprocessedNodes(rootNode);\n+\n+                LOGGER.info(format(\"Detected external configuration entries in %s: [%s]\",", "originalCommit": "dad4416820edf259579aab753e01e05db1ebd869", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEwMjA1Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r498102056", "bodyText": "I'm not convinced. That would provide some extra value only for huge sets of config entries provided.\n@Holmistr what do you think is the way to go?", "author": "pivovarit", "createdAt": "2020-10-01T09:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEyNjUwNg==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r498126506", "bodyText": "I don't see that much value in the extra log line. In general, I would expect the end user to go one by one when there's such warning. It's in his/her interest to fix those inconsistencies. Let's leave it like this.", "author": "Holmistr", "createdAt": "2020-10-01T10:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEyOTg1NQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r498129855", "bodyText": "What I wanted to highlight is that in the mentioned case we would log \"Detected external configuration entries in environment variables: []\". With the warnings logged below the situation is clear, so I'm fine with the current approach as well.", "author": "blazember", "createdAt": "2020-10-01T10:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEzNzg3OQ==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r498137879", "bodyText": "What if we just skip the empty log if the list if empty?", "author": "pivovarit", "createdAt": "2020-10-01T10:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MTAwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE0MjE3MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r498142170", "bodyText": "I think it is reasonable to keep a log line that makes clear that there were no overrides. I would either leave this as is or log a specific message. I'm fine with both.", "author": "blazember", "createdAt": "2020-10-01T10:27:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MTAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4Mjg3Ng==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r498082876", "bodyText": "Do we have this mechanism for the failover client config as well?", "author": "blazember", "createdAt": "2020-10-01T08:47:24Z", "path": "hazelcast/src/test/java/com/hazelcast/internal/config/override/ConfigNodeStateTrackerTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2008-2020, Hazelcast, Inc. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.hazelcast.internal.config.override;\n+\n+import com.hazelcast.client.config.ClientConfig;\n+import com.hazelcast.client.config.impl.YamlClientDomConfigProcessor;\n+import com.hazelcast.config.Config;\n+import com.hazelcast.internal.config.YamlMemberDomConfigProcessor;\n+import com.hazelcast.test.HazelcastParallelClassRunner;\n+import com.hazelcast.test.annotation.QuickTest;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.runner.RunWith;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(HazelcastParallelClassRunner.class)\n+@Category(QuickTest.class)\n+public class ConfigNodeStateTrackerTest {\n+\n+    @Test\n+    public void shouldDetectUnappliedMemberConfigEntries() throws Exception {\n+        Map<String, String> entries = new HashMap<>();\n+        entries.put(\"HZ_CLUSTERNAME\", \"foo\");\n+        entries.put(\"HZ_CLUSTRNAME\", \"foo\");\n+        entries.put(\"HZ_NETWORK_PORT\", \"5702\");\n+        entries.put(\"HZ_NETWORK_JOIN_TCPIP_BLE\", \"false\");\n+        entries.put(\"HZ_NETWORK_JOIN_MULTCAST_ENABLED\", \"false\");\n+\n+        ConfigNode configNode = PropertiesToNodeConverter.propsToNode(EnvVariablesConfigParser.member().parse(entries));\n+\n+        new YamlMemberDomConfigProcessor(true, new Config(), false)\n+          .buildConfig(new ConfigOverrideElementAdapter(configNode));\n+\n+        Map<String, String> unprocessed = new ConfigNodeStateTracker().unprocessedNodes(configNode);\n+        assertTrue(unprocessed.containsKey(\"hazelcast.network.port\"));\n+        assertTrue(unprocessed.containsKey(\"hazelcast.clustrname\"));\n+        assertTrue(unprocessed.containsKey(\"hazelcast.network.join.tcpip.ble\"));\n+        assertTrue(unprocessed.containsKey(\"hazelcast.network.join.multcast.enabled\"));\n+    }\n+\n+    @Test\n+    public void shouldDetectUnappliedClientConfigEntries() {\n+        Map<String, String> entries = new HashMap<>();\n+        entries.put(\"HZCLIENT_FOO\", \"foo\");\n+        entries.put(\"HZCLIENT_NETWORK_SOCKETINTERCEPTOR_ENABLE\", \"true\");\n+        entries.put(\"HZCLIENT_NETWORK_SMARTROUTING\", \"true\");\n+\n+        ConfigNode configNode = PropertiesToNodeConverter.propsToNode(EnvVariablesConfigParser.client().parse(entries));\n+\n+        new YamlClientDomConfigProcessor(true, new ClientConfig(), false)\n+          .buildConfig(new ConfigOverrideElementAdapter(configNode));\n+\n+        Map<String, String> unprocessed = new ConfigNodeStateTracker().unprocessedNodes(configNode);\n+        assertTrue(unprocessed.containsKey(\"hazelcast-client.foo\"));\n+        assertTrue(unprocessed.containsKey(\"hazelcast-client.network.socketinterceptor.enable\"));\n+        assertFalse(unprocessed.containsKey(\"hazelcast-client.network.smartrouting\"));\n+    }", "originalCommit": "dad4416820edf259579aab753e01e05db1ebd869", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA5MzY5MA==", "url": "https://github.com/hazelcast/hazelcast/pull/17559#discussion_r498093690", "bodyText": "No, if someone decides to use the failover mechanics, it means they are already busy with file juggling, and they should use just the standard file-based configuration.", "author": "pivovarit", "createdAt": "2020-10-01T09:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4Mjg3Ng=="}], "type": "inlineReview"}]}